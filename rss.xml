<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-09-02T21:51:54.238896</updated>
  <id>ff31e29b-30ed-44a3-9d29-34e62aa0708d</id>

  
    <entry>
      <title>モジュール -- モジュール名の見出しを作成し内容を追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>871b046f0d1126d7a7fdf1975e6e8598734cd08a:lang/cpp20/modules.md</id>
      <updated>2020-09-03T06:47:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index 1523aa25e..64240250e 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -49,23 +49,32 @@ export(opt) module モジュール名 属性(opt);
     - `export`がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。
     - あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。
     - モジュール実装ユニットはモジュールインターフェースユニットを暗黙的にインポートする。
-- モジュール名は、識別子または識別子をドットで繋いだもの(例えば、`foo`や`std.core`)である。
-    - `std`と`std`から始まるあらゆるモジュール名及び予約語を含むモジュール名は、今後の規格や処理系のために予約されているので、ユーザー定義のモジュール名として使うことはできない。
-    - モジュールの名前は、モジュールに属する型、関数などの名前とは無関係である。
-    - 処理系の中には、モジュールユニットのファイル名とモジュール名が揃っていることを期待するものがある(そうでない場合は追加のコマンドラインオプションが必要になる)。
 
 ```cpp
 export module foo;                // fooのモジュールインターフェースユニット
 module foo;                       // fooのモジュール実装ユニット
 module foo.bar;                   // foo.barのモジュール実装ユニット
 export module bar [[deprecated]]; // 属性
+```
+
+#### モジュール名の詳細
+
+モジュール名は、識別子または識別子をドットで繋いだもの(例えば、`foo`や`std.core`)である。
+- `std`と`std`から始まるあらゆるモジュール名及び予約語を含むモジュール名は、今後の規格や処理系のために予約されているので、ユーザー定義のモジュール名として使うことはできない。
+- モジュールの名前は、モジュールに属する型、関数などの名前とは無関係である。
+- 処理系の中には、モジュールユニットのファイル名とモジュール名が揃っていることを期待するものがある(そうでない場合は追加のコマンドラインオプションが必要になる)。
 
+モジュール名にはドットを使いたいが、一方で識別子にはドットが使えない。このような矛盾があるため、モジュール名にドットを使うとトークンが分割される。
+そのため、識別子の規則は分割されたそれぞれのトークンに適用される。
+
+```cpp
 module foo . bar;              // OK. &amp;#39;foo.bar&amp;#39;と等しい
 module foo . /*comment*/ bar;  // OK. &amp;#39;foo.bar&amp;#39;と等しい
 module foo . . bar;            // NG. ドットの間に識別子がない
 module _Foo.bar                // NG. 識別子&amp;#39;_Foo&amp;#39;は予約されている
 module foo__bar                // NG. 識別子&amp;#39;foo__bar&amp;#39;は予約されている
 module foo.__bar.baz           // NG. 識別子&amp;#39;__bar&amp;#39;は予約されている
+module foo.version.0           // NG. 識別子の1文字目は数字にできない
 ```
 
 #### プライベートモジュールフラグメント
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>丸カッコの値リストからの集成体初期化を許可 -- Fix typo</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html"/>
      <id>575f23515bd7eb3e021942cbb3d49c465650c9cf:lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md</id>
      <updated>2020-09-01T23:43:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
index eaac54322..e02fd183d 100644
--- a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
+++ b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
@@ -31,7 +31,7 @@ A aa[]((1, 2), (3, 4), (5, 6));
 * 波カッコによる初期化では縮小変換ができないが、丸カッコによる初期化ではできる。
 * 参照型のメンバへ一時オブジェクトをバインドするとき、波カッコによる初期化では寿命が延長されるが、丸カッコによる初期化では延長されない。
 
-ただし、各要素の評価準は左から右に評価される。この点は波カッコと同じになっている。
+ただし、各要素は左から右に評価される。この点は波カッコと同じになっている。
 
 ```cpp
 // P0960R3より引用
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>契約に基づくプログラミング -- Update contract-based_programming.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/contract-based_programming.html"/>
      <id>ddbc8fae8edeabbd6d35c4be03d7cb6507d8ae80:lang/cpp23/contract-based_programming.md</id>
      <updated>2020-08-31T10:03:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/contract-based_programming.md b/lang/cpp23/contract-based_programming.md
index a976fd458..e9b84b75b 100644
--- a/lang/cpp23/contract-based_programming.md
+++ b/lang/cpp23/contract-based_programming.md
@@ -126,7 +126,7 @@ C++20では、プログラムのコンパイルは次の3つのうちどれか
 * `audit`: 契約レベルが`default`または`audit`の契約がチェックされる。
 
 ビルドレベルを指定する方法は処理系定義である。ただし、ソースコード上で指定する方法は提供されない。
-
+`constexpr`などの定数表現評価では、チェックされた契約のみが評価される。
 チェックされない契約が評価されるかは未規定である。`false`に評価される場合の動作は未定義である。
 
 ### 違反ハンドラーと違反継続モード
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>MITSUNARI Shigeo</name>
        <email>herumi@nifty.com</email>
      </author>
    </entry>
  
    <entry>
      <title>if文とswitch文の条件式と初期化を分離 -- Update selection_statements_with_initializer.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/selection_statements_with_initializer.html"/>
      <id>33b05b121f9bc98db7d90ee4aad1e676dfb8fca9:lang/cpp17/selection_statements_with_initializer.md</id>
      <updated>2020-08-30T01:33:20+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/selection_statements_with_initializer.md b/lang/cpp17/selection_statements_with_initializer.md
index 426d69c28..831b706ce 100644
--- a/lang/cpp17/selection_statements_with_initializer.md
+++ b/lang/cpp17/selection_statements_with_initializer.md
@@ -136,9 +136,16 @@ if (std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mx); shared_flag) { unsafe_ping(); shared_f
 ## この機能が必要になった背景・経緯
 
 変数の宣言あるいは初期化を行い、`if`文や`switch`文のスコープ内だけで変数を使用するケースは多数あるにも関わらず、
-`if`文や`switch`文に初期化を行う記法は存在しなかった。
+`if`文や`switch`文で行える宣言は限定的だった。
+具体的には、単一かつ配列ではない変数しか宣言できず、その変数の初期値が条件になってしまうので、変数を宣言したうえで別の式を条件にすることはできなかった。
 
-C++14まででも同様の意味を持つ記述は不可能ではないが、外側にスコープを追加する必要があり冗長な記述になっていた:
+```cpp
+// ポインターを受け取ってnullチェックをするパターンは、C++14まででもよく見かけた。
+// しかし、この条件を反転(nullptrのとき真)することさえ不可能であった。
+if (auto* p = get_some_object()) { ... } // pがnullptrでなければ真
+```
+
+C++14まででも初期化付きの条件分岐と同様の意味を持つ記述は不可能ではないが、外側にスコープを追加する必要があり冗長な記述になっていた:
 
 ```cpp
 status_code foo() {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>