<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-03-03T04:48:49.958007</updated>
  <id>854c9f3b-569b-4d4d-bbea-dde456f2d289</id>

  
    <entry>
      <title>生文字列リテラル -- raw_string_literals: 例示コードのコメント更新</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/raw_string_literals.html"/>
      <id>8526c7ec28931fbf0a4d406281057bf40f6aaf4e:lang/cpp11/raw_string_literals.md</id>
      <updated>2021-03-03T13:42:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/raw_string_literals.md b/lang/cpp11/raw_string_literals.md
index fa377752d..c2e97999b 100644
--- a/lang/cpp11/raw_string_literals.md
+++ b/lang/cpp11/raw_string_literals.md
@@ -100,7 +100,7 @@ int main()
 
 // 文字列のフォーマット関数
 // not thread-safe, スレッドセーフな実装ではないので注意
-// Boost.Formatやcppformatを使用することを推奨
+// Boost.Format, fmtlibやstd::format(C++20)の使用を推奨
 template &amp;lt;class... Args&amp;gt;
 std::string format(const char* fmt, Args&amp;amp;&amp;amp;... args)
 {
@@ -133,7 +133,8 @@ int main()
 * str()[link /reference/sstream/basic_stringstream/str.md.nolink]
 * std::fprintf[link /reference/cstdio/fprintf.md.nolink]
 * Boost.Format[link http://www.boost.org/libs/format]
-* cppformat[link https://github.com/cppformat/cppformat]
+* fmtlib[link https://github.com/fmtlib/fmt]
+* std::format[link /reference/format/format.md]
 
 #### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shared_mutex -- shared_(timed_)mutex: 例示コードを調整</title>
      <link href="https://cpprefjp.github.io/reference/shared_mutex/shared_mutex.html"/>
      <id>de24e2dcf42b0d0b8ac25e22b75d4fc48b9ae0b4:reference/shared_mutex/shared_mutex.md</id>
      <updated>2021-03-03T13:24:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/shared_mutex/shared_mutex.md b/reference/shared_mutex/shared_mutex.md
index 18529dd8e..5c124a611 100644
--- a/reference/shared_mutex/shared_mutex.md
+++ b/reference/shared_mutex/shared_mutex.md
@@ -88,8 +88,12 @@ public:
   // 読み込み側：カウンタの値を読む
   void reader()
   {
-    std::shared_lock&amp;lt;std::shared_mutex&amp;gt; lock(mtx_);
-    print_value(count_);
+    int local_count;
+    {
+      std::shared_lock&amp;lt;std::shared_mutex&amp;gt; lock(mtx_);
+      local_count = count_;
+    } // 共有ロックをここで手放す
+    print_value(local_count);
   }
 };
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shared_timed_mutex -- shared_(timed_)mutex: 例示コードを調整</title>
      <link href="https://cpprefjp.github.io/reference/shared_mutex/shared_timed_mutex.html"/>
      <id>de24e2dcf42b0d0b8ac25e22b75d4fc48b9ae0b4:reference/shared_mutex/shared_timed_mutex.md</id>
      <updated>2021-03-03T13:24:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/shared_mutex/shared_timed_mutex.md b/reference/shared_mutex/shared_timed_mutex.md
index ef5f52bbf..64940c2d7 100644
--- a/reference/shared_mutex/shared_timed_mutex.md
+++ b/reference/shared_mutex/shared_timed_mutex.md
@@ -94,8 +94,12 @@ public:
   // 読み込み側：カウンタの値を読む
   void reader()
   {
-    std::shared_lock&amp;lt;std::shared_timed_mutex&amp;gt; lock(mtx_);
-    print_value(count_);
+    int local_count;
+    {
+      std::shared_lock&amp;lt;std::shared_mutex&amp;gt; lock(mtx_);
+      local_count = count_;
+    } // 共有ロックをここで手放す
+    print_value(local_count);
   }
 };
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- モジュールの説明を再編</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>526ecca8defd288b4c2f75af2f27fc41a369c3ac:lang/cpp20/modules.md</id>
      <updated>2021-03-03T05:21:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index 96e267a80..aa8b95f6f 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -42,26 +42,85 @@ C++20では標準ライブラリはモジュール化されないが、その中
 
 ## 仕様
 
+### 翻訳単位の分類
+
+C++20では翻訳単位がその役割によって細かく分類される。
+
+まず、モジュールを構成する翻訳単位(モジュールユニット)とそれ以外(従来の翻訳単位すべて)の区別がある。
+
+モジュールユニットはさらにインターフェースと実装に分けられる。
+
+* モジュールインターフェースユニット  
+    従来のヘッダーファイルに相当する翻訳単位(`#include`のようにソースファイルに展開されることはなく、単独で翻訳単位になる)。外部(別のモジュール)に公開したい宣言や定義を書く。
+* モジュール実装ユニット  
+    従来のソースファイルに相当する翻訳単位。公開しない宣言や定義を書く。
+
+また、それぞれにモジュール本体とパーティションという区別がある。
+
+パーティションは、モジュールを構成するファイルをさらに分割するために使うもので、内部的には別モジュールのように見えるが、外部からは見えないファイルである。
+
+まとめると、以下のようになる。
+
+* 翻訳単位
+    * モジュールユニット
+        * モジュールインターフェースユニット
+            * プライマリーモジュールインターフェース
+            * モジュールインターフェースパーティション
+        * モジュール実装ユニット
+            * モジュール本体の実装ユニット(特別な名称無し)
+            * モジュール実装パーティション
+    * モジュールユニット以外(特別な名称無し)
+
 ### モジュール宣言
 
 モジュール宣言の構文は以下のようになる：
 
 ```
-export(opt) module モジュール名 属性(opt);
+export(opt) module モジュール名 :パーティション名(opt) 属性(opt);
 ```
 
-- モジュール宣言は翻訳単位あたり1回だけ、原則として翻訳単位の先頭に記述する。
-- モジュール宣言を含む翻訳単位をモジュールユニットという。
-    - `export`がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。
-    - あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。
-    - モジュール実装ユニットはモジュールインターフェースユニットを暗黙的にインポートする。
+- モジュール宣言は翻訳単位あたり1回だけ、原則として翻訳単位の先頭に記述する。モジュール宣言を含む翻訳単位をモジュールユニットという。
+- `export`がある場合はモジュールインターフェースユニット、ない場合はモジュール実装ユニットになる。
+- パーティション名がある場合はそれぞれモジュールインターフェースパーティション、モジュール実装パーティションになる。
+
+どのモジュールも、必ずただ1つのプライマリーモジュールインターフェースユニットを持たなければならない。
+それ以外のモジュールユニットの個数は任意である。ただし、パーティション名はモジュール内で重複してはならない。
+
 
 ```cpp
 export module foo;                // fooのモジュールインターフェースユニット
 module foo;                       // fooのモジュール実装ユニット
 module foo.bar;                   // foo.barのモジュール実装ユニット
 export module bar [[deprecated]]; // 属性
+export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
+module lib:internal; // libモジュールのモジュール実装パーティションinternal
+```
+
+次のモジュールAは4つの翻訳単位からなる。
+
+```cpp
+// P1103R3より引用
+// 翻訳単位1 プライマリーモジュールインターフェースユニット
+export module A;
+export import :Foo;
+export int baz();
+
+// 翻訳単位2 モジュールインターフェースパーティション
+export module A:Foo;
+import :Internals;
+export int foo() { return 2 * (bar() + 1); }
+
+// 翻訳単位3 モジュール実装パーティション
+module A:Internals;
+int bar();
+
+// 翻訳単位4 モジュール実装ユニット
+module A;
+import :Internals;
+int bar() { return baz() - 10; }
+int baz() { return 30; }
 ```
+* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]
 
 #### モジュール名の詳細
 
@@ -194,6 +253,8 @@ import lib; // libのインポート
 
 モジュールインポート宣言は、モジュールのインターフェースユニットをインポートする。
 
+- モジュール実装ユニットはモジュールインターフェースユニットを暗黙的にインポートする。ソースファイルと同名のヘッダーファイルをインクルードすることは多いが、これを自動化したものである。
+
 インポートされた翻訳単位でエクスポートされている名前は、インポート宣言を記述した翻訳単位において**可視**(visible)となる。
 名前が可視であるとき、かつそのときに限り、名前は名前探索の候補となる。
 
@@ -210,6 +271,23 @@ export import lib; // libの再エクスポート
 
 モジュールをインポートすると、そのモジュールが再エクスポートしているモジュールも同時にインポートする。
 
+#### パーティションのインポート
+
+パーティションは内部的には別のモジュールのように振る舞うので、パーティション内の宣言などを利用するにはインポートが必要である。
+
+パーティションは主となるモジュールが異なる場合はインポートできないので、間違いのないように、インポート宣言にはモジュールパーティション名だけを書く。
+
+```cpp
+export module datetime;
+export import :date; // インターフェースパーティション date をインポート
+export import :time; // インターフェースパーティション time をインポート
+```
+
+モジュールインターフェースパーティションはモジュールインターフェースを分割するものなので、内部の宣言を外へ公開しなければ意味がない。そのため、モジュールインターフェースパーティションのインポート宣言は必ず再エクスポートしなければならない。
+
+* パーティション内の宣言はエクスポートしていなくても見える
+* ただし、再エクスポートされるのはパーティションがエクスポートしている宣言のみ
+
 #### インターフェース依存
 
 翻訳単位がモジュールユニットUに**インターフェース依存**(interface dependency)を持つとは、次のことをいう：
@@ -245,69 +323,6 @@ C++20までは到達可能という用語はなかったが、前者の条件を
 
 エクスポートの有無とは関係なく、モジュールをインポートしただけでインターフェース依存が発生し、そのモジュールインターフェースユニットおよびその中の宣言へ到達可能となる。
 
-### モジュールパーティション
-
-モジュールは分割することができる。分割したモジュールをモジュールパーティションという。
-
-モジュールパーティションを宣言する構文は以下のようになる：
-
-```
-export(opt) module モジュール名:モジュールパーティション名 属性(opt);
-```
-
-- モジュールパーティション名の書式は、モジュール名と同じである。
-- `export` がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。
-
-```cpp
-export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
-```
-
-```cpp
-module lib:internal; // libモジュールのモジュール実装パーティションinternal
-```
-
-モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：
-
-- 主となるモジュールが異なる場合はインポートできない。
-    - 外部へ公開するには、モジュールインターフェースから再エクスポートする。
-    - モジュールの利用者にパーティションの存在を意識させてはいけない。
-- インポート宣言にはモジュールパーティション名だけを書く。
-- インポートするとエクスポートしていない宣言も見えるようになる。
-    - ただし、再エクスポートはできない。
-
-主となるモジュールのインターフェースとパーティションを区別する場合は、プライマリーモジュールインターフェースユニットという事がある。
-
-```cpp
-// P1103R3より引用
-// 翻訳単位1
-export module A;
-export import :Foo;
-export int baz();
-
-// 翻訳単位2
-export module A:Foo;
-import :Internals;
-export int foo() { return 2 * (bar() + 1); }
-
-// 翻訳単位3
-module A:Internals;
-int bar();
-
-// 翻訳単位4
-module A;
-import :Internals;
-int bar() { return baz() - 10; }
-int baz() { return 30; }
-```
-* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]
-
-このモジュールAは4つの翻訳単位からなる。上から順に、
-
-1. (プライマリー)モジュールインターフェースユニット
-2. モジュールインターフェースパーティション `:Foo`
-3. モジュール実装パーティション `:Internals`
-4. モジュール実装ユニット
-
 ### モジュールにおけるODR
 
 同じトークン列であれば再定義しても良いというODRの例外は、その定義が名前のあるモジュールに属する場合は適用されない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sentinel_for -- LWG Issue 3453対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/sentinel_for.html"/>
      <id>ab8c40980dd4b91e4b59755886c997fb42b49180:reference/iterator/sentinel_for.md</id>
      <updated>2021-03-02T15:46:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/sentinel_for.md b/reference/iterator/sentinel_for.md
index a1ab3fc8e..35eecb5e4 100644
--- a/reference/iterator/sentinel_for.md
+++ b/reference/iterator/sentinel_for.md
@@ -29,6 +29,7 @@ namespace std {
 
 - `i == s`が適格である（未定義動作にならない）
 - `bool(i != s) == true`の（`i`が範囲終端に到達していない）時、`i`は間接参照可能であり`[++i, s)`も範囲を示す
+- `I&amp;amp;, S`が[`assignable_from`](/reference/concepts/assignable_from.md)`&amp;lt;I&amp;amp;, S&amp;gt;`のモデルとならないなら、構文的にも`assignable_from`コンセプトを満たさない
 
 ここでの`==`の[定義域](/reference/concepts.md)は静的ではなく、実行時に変化しうる。`[i, s)`が範囲を示している時に`i == oi`となるような別のイテレータ`oi`をインクリメント（`++oi`）した後で、範囲`[i, s)`が有効であり続ける必要はない。
 
@@ -106,4 +107,5 @@ int* is not sentinel for double*
 ## 参照
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [LWG Issue 3453. Generic code cannot call `ranges::advance(i, s)`](https://cplusplus.github.io/LWG/issue3453)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_chars -- from/to_chars : GCC対応を追記</title>
      <link href="https://cpprefjp.github.io/reference/charconv/from_chars.html"/>
      <id>3cdfcef53b11de41806c8ac4ac24608bcd23f2c8:reference/charconv/from_chars.md</id>
      <updated>2021-02-27T15:34:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/from_chars.md b/reference/charconv/from_chars.md
index eb347ae65..2aa8c38e5 100644
--- a/reference/charconv/from_chars.md
+++ b/reference/charconv/from_chars.md
@@ -32,8 +32,8 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 - (2)～(4)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
 ## 引数
-- `first` -- 入力文字列の先頭のポインタ。
-- `last` -- 入力文字列の終端の次を指すポインタ。
+- `first` -- 入力文字列の先頭ポインタ。
+- `last` -- 入力文字列の終端ポインタ。
 - `value` -- 変換結果を出力する変数。
 - `base` -- 入力文字列の整数の基数（n進数のn）指定、2進数から36進数まで。
 - `fmt` -- 入力文字列の浮動小数点数のフォーマット指定、[`chars_format`](../charconv/chars_format.md)のいずれか。
@@ -243,7 +243,7 @@ nan
 
 ### 処理系
 - [Clang](/implementation.md#clang): 7.0(整数のみ)
-- [GCC](/implementation.md#gcc): 8.0(整数のみ)
+- [GCC](/implementation.md#gcc): 8.0(整数のみ), 11.1(full support)
 - [Visual C++](/implementation.md#visual_cpp): 2017 update 7(整数のみ), update 9(full support)
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>to_chars -- from/to_chars : GCC対応を追記</title>
      <link href="https://cpprefjp.github.io/reference/charconv/to_chars.html"/>
      <id>3cdfcef53b11de41806c8ac4ac24608bcd23f2c8:reference/charconv/to_chars.md</id>
      <updated>2021-02-27T15:34:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/to_chars.md b/reference/charconv/to_chars.md
index 918998467..2b983f1be 100644
--- a/reference/charconv/to_chars.md
+++ b/reference/charconv/to_chars.md
@@ -46,8 +46,8 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 - (5)～(10)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
 ## 引数
-- `first` -- 変換結果の文字列を出力する範囲の先頭のポインタ。
-- `last` -- 変換結果の文字列を出力する範囲の終端の次を指すポインタ。
+- `first` -- 変換結果の文字列を出力する範囲の先頭ポインタ。
+- `last` -- 変換結果の文字列を出力する範囲の終端ポインタ。
 - `value` -- 文字列へ変換する値。
 - `base` -- 整数の出力基数（n進数のn）指定、2進数から36進数まで。
 - `fmt` -- 浮動小数点数の出力フォーマット指定、[`chars_format`](../charconv/chars_format.md)のいずれか。
@@ -209,7 +209,7 @@ z
 
 ### 処理系
 - [Clang](/implementation.md#clang): 7.0(整数のみ)
-- [GCC](/implementation.md#gcc): 8.0(整数のみ)
+- [GCC](/implementation.md#gcc): 8.0(整数のみ), 11.1(full support)
 - [Visual C++](/implementation.md#visual_cpp): 2017 update 7(整数のみ), update 9(full support)
 
 ## 関連項目
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>