<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-01-23T08:43:38.451414</updated>
  <id>c2ec0c4e-a355-42b4-9003-a3318bdff15e</id>

  
    <entry>
      <title>replace -- Merge pull request #936 from Jumpaku/Jumpaku-patch-3</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/replace.html"/>
      <id>10a3ed4a9209cb43584702a6a714c069cb6ce7b6:reference/string/basic_string/replace.md</id>
      <updated>2022-01-23T17:39:20+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/replace.md b/reference/string/basic_string/replace.md
index ec25752e6..5d5d89d8b 100644
--- a/reference/string/basic_string/replace.md
+++ b/reference/string/basic_string/replace.md
@@ -94,7 +94,7 @@ basic_string&amp;amp; replace(const_iterator i1,
 ## 効果
 - (1) : `replace(pos1, n1, str.`[`data()`](data.md)`, str.`[`size()`](size.md)`)`を呼び出す。
 - (2) :
-    - `n2`と`str.`[`size()`](size.md) `- pos2`のうち小さい方を`rlen`とする。`n == npos` の場合は、 `str.`[`size`](size.md)`() - pos2` が使用される。
+    - `n2`と`str.`[`size()`](size.md) `- pos2`のうち小さい方を`rlen`とする。`n2 == npos` の場合は、 `str.`[`size`](size.md)`() - pos2` が使用される。
     - `replace(pos1, n1, str.`[`data()`](data.md) `+ pos2, rlen)`を呼び出す。
 - (3) : `n1`と[`size()`](size.md) `- pos1`のうち小さい方を`xlen`とし、自身の`pos1`番目から`xlen`個の要素を、文字配列`s`の先頭`n2`文字で置き換える。
 - (4) : `replace(pos, n, s,` [`traits::length`](/reference/string/char_traits/length.md)`(s))`を呼び出す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- Update replace.md</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/replace.html"/>
      <id>7a6374f77d3c54c7f11047f819bed6fd43e901be:reference/string/basic_string/replace.md</id>
      <updated>2022-01-23T10:25:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/replace.md b/reference/string/basic_string/replace.md
index ec25752e6..5d5d89d8b 100644
--- a/reference/string/basic_string/replace.md
+++ b/reference/string/basic_string/replace.md
@@ -94,7 +94,7 @@ basic_string&amp;amp; replace(const_iterator i1,
 ## 効果
 - (1) : `replace(pos1, n1, str.`[`data()`](data.md)`, str.`[`size()`](size.md)`)`を呼び出す。
 - (2) :
-    - `n2`と`str.`[`size()`](size.md) `- pos2`のうち小さい方を`rlen`とする。`n == npos` の場合は、 `str.`[`size`](size.md)`() - pos2` が使用される。
+    - `n2`と`str.`[`size()`](size.md) `- pos2`のうち小さい方を`rlen`とする。`n2 == npos` の場合は、 `str.`[`size`](size.md)`() - pos2` が使用される。
     - `replace(pos1, n1, str.`[`data()`](data.md) `+ pos2, rlen)`を呼び出す。
 - (3) : `n1`と[`size()`](size.md) `- pos1`のうち小さい方を`xlen`とし、自身の`pos1`番目から`xlen`個の要素を、文字配列`s`の先頭`n2`文字で置き換える。
 - (4) : `replace(pos, n, s,` [`traits::length`](/reference/string/char_traits/length.md)`(s))`を呼び出す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Jumpaku</name>
        <email>Jumpaku@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>即時関数 -- Update immediate_functions.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/immediate_functions.html"/>
      <id>2a124ef72de057aa91dcbe773ddc039737dbf976:lang/cpp20/immediate_functions.md</id>
      <updated>2022-01-22T17:30:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/immediate_functions.md b/lang/cpp20/immediate_functions.md
index a857c63b3..63321ced0 100644
--- a/lang/cpp20/immediate_functions.md
+++ b/lang/cpp20/immediate_functions.md
@@ -46,12 +46,12 @@ Int2Int *pf = sqr; // エラー
 ```
 * P1073R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1073r3.html]
 
-定数式として評価できない部分があっても、実行されなければエラーとならない。
+定数式として評価できない部分があっても、評価しようとしなければエラーとならない。
 
 ```cpp example
 consteval void f(int n) {
   if(n &amp;lt; 0) {
-    throw &amp;#34;n should not be negative&amp;#34;;
+    throw &amp;#34;n should not be negative&amp;#34;; // throwは定数式として評価できないが、ここを通らなければOK
   }
 }
 
@@ -61,6 +61,8 @@ int main() {
 }
 ```
 
+この性質は様々なチェックをコンパイル時に行うために活用できる。たとえば、[`std::format`](/reference/format/format.md)におけるコンパイル時の書式文字列チェックで使用されている。
+
 ## 例
 ```cpp example
 // P1073R3より引用
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dangling -- Update dangling.md</title>
      <link href="https://cpprefjp.github.io/reference/ranges/dangling.html"/>
      <id>da8a30ca9040da3647b15dc58373ec2cbe063b7d:reference/ranges/dangling.md</id>
      <updated>2022-01-22T16:07:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/dangling.md b/reference/ranges/dangling.md
index 907a723b1..da04b3a85 100644
--- a/reference/ranges/dangling.md
+++ b/reference/ranges/dangling.md
@@ -19,7 +19,7 @@ namespace std::ranges {
 
 `dangling`は、イテレータまたはRangeがダングリングであることを示す型である。
 
-この型のオブジェクトは、イテレータまたはRangeを返す関数において、戻り値のイテレータやRangeがダングリングとなる場合に代わりに返される(逆は成立しない)。
+この型のオブジェクトは、イテレータまたはRangeを返す関数において、それらがダングリングとなることがコンパイル時にわかる場合に、代わりに返されることがある。
 
 `dangling`自身はイテレータでもRangeでもないため、呼び出し側でそれらを期待したコードを書いていればコンパイルエラーとなる。その結果、ダングリングイテレータ/Rangeにアクセスするというエラーをコンパイル時に発見することができる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_find -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
index 622ddb3b2..13e149535 100644
--- a/reference/algorithm/ranges_adjacent_find.md
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -71,7 +71,7 @@ found: index==2
 ```cpp
 struct adjacent_find_impl {
   template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr I adjacent_find(I first, S last, Pred pred = {}, Proj proj = {}) {
+  constexpr I operator()(I first, S last, Pred pred = {}, Proj proj = {}) const {
     if (first == last)
       return last;
 
@@ -84,7 +84,7 @@ struct adjacent_find_impl {
   }
 
   template&amp;lt;forward_range R, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_all_of.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_all_of.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_all_of.md b/reference/algorithm/ranges_all_of.md
index 146c1d15e..da98f8ef5 100644
--- a/reference/algorithm/ranges_all_of.md
+++ b/reference/algorithm/ranges_all_of.md
@@ -70,14 +70,14 @@ false
 ```cpp
 struct all_of_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for (; first != last; ++first)
       if (!invoke(pred, invoke(proj, *first))) return false;
     return true;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_any_of.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_any_of.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_any_of.md b/reference/algorithm/ranges_any_of.md
index dea211956..e4386d795 100644
--- a/reference/algorithm/ranges_any_of.md
+++ b/reference/algorithm/ranges_any_of.md
@@ -72,14 +72,14 @@ true
 ```cpp
 struct any_of_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first))) return true;
     return false;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_count.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 748e65a72..f0ed20105 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -71,7 +71,7 @@ count of 1: 3
 struct count_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
+  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) const {
     iter_difference_t&amp;lt;I&amp;gt; count = 0;
     for ( ; first != last; ++first)
       if (value == invoke(proj, *first)) count++;
@@ -80,7 +80,7 @@ struct count_impl {
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
+  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) const {
     return (*this)(begin(r), end(r), value, ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_count_if.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 8168a5098..b4aa6c9be 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -71,7 +71,7 @@ count of 1 or 3: 5
 ```cpp
 struct count_if_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, Pred pred, Proj proj = {}) const {
     iter_difference_t&amp;lt;I&amp;gt; count = 0;
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first))) count++;
@@ -79,7 +79,7 @@ struct count_if_impl {
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_equal.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
index 06dd47a12..b1faa1bda 100644
--- a/reference/algorithm/ranges_equal.md
+++ b/reference/algorithm/ranges_equal.md
@@ -78,7 +78,7 @@ true
 struct equal_impl {
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr bool operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     if constexpr (sized_sentinel_for&amp;lt;S1, I1&amp;gt; &amp;amp;&amp;amp; sized_sentinel_for&amp;lt;S2, I2&amp;gt;)
       if (distance(first1, last1) != distance(first2, last2))
         return false;
@@ -90,7 +90,7 @@ struct equal_impl {
 
   template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr bool operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 0bf006583..1bb8378f9 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -65,7 +65,7 @@ found: 1
 struct find_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr I operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
+  constexpr I operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (*first == value) return first;
     return last;
@@ -73,7 +73,7 @@ struct find_impl {
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) const {
     return (*this)(begin(r), end(r), value, ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find_end.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
index ec3bc16d8..d229238c8 100644
--- a/reference/algorithm/ranges_find_end.md
+++ b/reference/algorithm/ranges_find_end.md
@@ -70,7 +70,7 @@ found: index==2
 struct find_end_impl {
   template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     if (first2 == last2)
       return last1;
     I1 result = last1;
@@ -83,7 +83,7 @@ struct find_end_impl {
 
   template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index b8b5c40e5..03fb751ac 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -75,7 +75,7 @@ found: index==3, value==4
 struct find_first_of_impl {
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr I1 operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr I1 operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     for ( ; first1 != last1; ++first1)
       for (I2 it = first2; it != last2; ++it)
         if (invoke(pred, invoke(proj1, *first1), invoke(proj2, *it))) return first1;
@@ -84,7 +84,7 @@ struct find_first_of_impl {
 
   template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find_if.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
index d66779145..c2181730f 100644
--- a/reference/algorithm/ranges_find_if.md
+++ b/reference/algorithm/ranges_find_if.md
@@ -63,14 +63,14 @@ found: 1
 ```cpp
 struct find_if_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first)))
         return first;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate &amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
index 5b3b75fd3..b92565a21 100644
--- a/reference/algorithm/ranges_find_if_not.md
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -63,14 +63,14 @@ found: 1
 ```cpp
 struct find_if_not_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (!invoke(pred, invoke(proj, *first)))
         return first;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate &amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_for_each.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each.md b/reference/algorithm/ranges_for_each.md
index 9e7a54315..6837a0f22 100644
--- a/reference/algorithm/ranges_for_each.md
+++ b/reference/algorithm/ranges_for_each.md
@@ -106,7 +106,7 @@ int main() {
 struct for_each_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
     requires copy_constructible&amp;lt;Fun&amp;gt;
-  constexpr for_each_result&amp;lt;I, Fun&amp;gt; operator()(I first, S last, Fun f, Proj proj = {}) {
+  constexpr for_each_result&amp;lt;I, Fun&amp;gt; operator()(I first, S last, Fun f, Proj proj = {}) const {
     for (; first != last; ++first) {
       invoke(f, invoke(proj, *first));
     }
@@ -115,7 +115,7 @@ struct for_each_impl {
 
   template&amp;lt;input_range R, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
     requires copy_constructible&amp;lt;Fun&amp;gt;
-  constexpr for_each_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, Fun&amp;gt; operator()(R&amp;amp;&amp;amp; r, Fun f, Proj proj = {}) {
+  constexpr for_each_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, Fun&amp;gt; operator()(R&amp;amp;&amp;amp; r, Fun f, Proj proj = {}) const {
     return (*this)(begin(r), end(r), move(f), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index 7f8aaa302..29560990c 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -91,7 +91,7 @@ int main()
 struct for_each_n_impl {
   template&amp;lt;input_iterator I, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
     requires copy_constructible&amp;lt;Fun&amp;gt;
-  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; operator()(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {}) {
+  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; operator()(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {}) const {
     for (iter_difference_t&amp;lt;I&amp;gt; i = 0; i &amp;lt; n; ++i) {
       invoke(f, invoke(proj, *first));
       ++first;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_mismatch.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index 3f7e70a58..fc2907d51 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -110,7 +110,7 @@ mismatch value: (end,2)
 struct mismatch_impl {
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr ranges::mismatch_result&amp;lt;I1, I2&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr ranges::mismatch_result&amp;lt;I1, I2&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     for ( ; first1 != last1 &amp;amp;&amp;amp; first != last2; ++first1, ++first2)
       if (!bool(invoke(pred, invoke(proj1, *first1), invoke(proj2, *first2))))
         return {first1, first2};
@@ -119,7 +119,7 @@ struct mismatch_impl {
 
   template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_none_of.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_none_of.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_none_of.md b/reference/algorithm/ranges_none_of.md
index ca86e2667..565f38ae2 100644
--- a/reference/algorithm/ranges_none_of.md
+++ b/reference/algorithm/ranges_none_of.md
@@ -84,14 +84,14 @@ true
 ```cpp
 struct none_of_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first))) return false;
     return true;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_search.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index c5fcd40e1..da4d59038 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -74,7 +74,7 @@ struct search_impl {
   template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
   sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     for ( ; first1 != last1; ++first1) {
       I1 p1 = first1;
       I2 p2 = first2;
@@ -89,7 +89,7 @@ struct search_impl {
 
   template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search_n -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search_n.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_search_n.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search_n.md b/reference/algorithm/ranges_search_n.md
index 60dbcc95f..738defe83 100644
--- a/reference/algorithm/ranges_search_n.md
+++ b/reference/algorithm/ranges_search_n.md
@@ -83,7 +83,7 @@ found: index==0
 struct search_n_impl {
   template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I, const T*, Pred, Proj&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; operator()(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) {
+  constexpr subrange&amp;lt;I&amp;gt; operator()(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) const {
     if (first == last || count &amp;lt;= 0)
       return first;
 
@@ -107,7 +107,7 @@ struct search_n_impl {
 
   template&amp;lt;forward_range R, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T*, Pred, Proj&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) {
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) const {
     return (*this)(begin(r1), end(r1), count, value, ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>