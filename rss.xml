<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-28T04:22:43.102203</updated>
  <id>bf8f1437-444c-445e-81e5-2a4570844cca</id>

  
    <entry>
      <title>C++14 -- C++14 N3664追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp14.html"/>
      <id>39325f4b21fd96255cbcbfd5c39d065efe8deb30:lang/cpp14.md</id>
      <updated>2021-05-28T13:17:50+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++14&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++14とは、2014年12月に改訂され、ISO/IEC 14882:2014で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;前バージョンであるC++11からマイナーバージョンアップされ、小さな機能拡張が行われた。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++1yと呼ばれていた。前バージョンであるC++11が策定中、C++0xと呼ばれていたことから、「xの次」という意味で「y」が使われていた。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/binary_literals.html&#34;&gt;2進数リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2進数を表す&lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;プレフィックスを付けた数値リテラルの記述を可能とする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/return_type_deduction_for_normal_functions.html&#34;&gt;通常関数の戻り値型推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値型を&lt;code&gt;auto&lt;/code&gt;にすることで、&lt;code&gt;return&lt;/code&gt;文から戻り値の型を推論させる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/decltype_auto.html&#34;&gt;decltype(auto)&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;decltype&lt;/code&gt;の規則による変数の型推論&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/placeholder_type_in_trailing_return_type.html&#34;&gt;後置戻り値型をプレースホルダーにすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;戻り値の型を後置する関数宣言構文とラムダ式の戻り値型に&lt;code&gt;auto&lt;/code&gt;を使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/initialize_capture.html&#34;&gt;ラムダ式の初期化キャプチャ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャに代入構文を導入し、一つの変数に複数のキャプチャ方法を指定可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/generic_lambdas.html&#34;&gt;ジェネリックラムダ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式のパラメータを&lt;code&gt;auto&lt;/code&gt;にすることで、ジェネリックな関数呼び出し演算子を持つ関数オブジェクトを生成する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/variable_templates.html&#34;&gt;変数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数定義時のテンプレート指定を可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/relaxing_constraints_on_constexpr.html&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if&lt;/code&gt;文、&lt;code&gt;switch&lt;/code&gt;文による条件分岐の許可。&lt;br /&gt;&lt;code&gt;for&lt;/code&gt;文、&lt;code&gt;while&lt;/code&gt;文、&lt;code&gt;do-while&lt;/code&gt;文によるループの許可。&lt;br /&gt;&lt;code&gt;void&lt;/code&gt;戻り値型の許可&lt;br /&gt;初期化を伴う変数宣言の許可。&lt;br /&gt;変数書き換えの許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/member_initializers_and_aggregates.md.nolink&#34;&gt;宣言時のメンバ初期化を持つ型の集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;集成体において、宣言時に初期化されているメンバを持つことを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/brace_elision_in_array_temporary_initialization.html&#34;&gt;ネストする集成体初期化における波カッコ省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;一様初期化と初期化子リストを組み合わせた際、二重に波カッコが必要となっていた仕様を緩和し、波カッコを省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/deprecated_attr.html&#34;&gt;&lt;code&gt;[[deprecated]]&lt;/code&gt;属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非推奨の機能であることを示す属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/digit_separators.html&#34;&gt;数値リテラルの桁区切り文字&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;シングルクォーテーションで数値リテラルを桁区切りする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/sized_deallocation.html&#34;&gt;サイズ付きデアロケーション&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;サイズをとる&lt;code&gt;delete&lt;/code&gt;演算子のオーバーロードを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/clarifying_memory_allocation.html&#34;&gt;動的メモリ確保の省略の許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトの&lt;code&gt;::operator new&lt;/code&gt;による動的メモリ確保を省略したりまとめたりする事を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;p&gt;ここでは、コア言語作業グループへ問題報告され、その解決策として導入された言語仕様の変更を解説する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/feature_test_macros.html&#34;&gt;機能テストマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++14 の機能がサポートされているかどうかをテストするためのマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/no_whitespace_literal_operators.html&#34;&gt;リテラル演算子のスペースを省略可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator&#34;&#34;&lt;/code&gt;とサフィックス名の間にスペースを入力しなくてもよくなった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/nontype_template_parameters_of_type_nullptr_t.html&#34;&gt;&lt;code&gt;nullptr_t&lt;/code&gt;型の定数式を非型テンプレートパラメータとすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;nullptr_t&lt;/code&gt;型の値をテンプレート引数として渡せるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;順序付き連想コンテナのルックアップ処理で、一時オブジェクトが生成されるコストを抑える拡張が行われた&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/find.html&#34;&gt;std::map::find()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/count.html&#34;&gt;std::map::count()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/lower_bound.html&#34;&gt;std::map::lower_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/upper_bound.html&#34;&gt;std::map::upper_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/equal_range.html&#34;&gt;std::map::equal_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::map&lt;/code&gt;クラスのほか、&lt;code&gt;std::set&lt;/code&gt;、&lt;code&gt;std::multiset&lt;/code&gt;、&lt;code&gt;std::multimap&lt;/code&gt;の上記メンバ関数も対象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Forward Iteratorを値初期化した場合に、どこも指さないヌルイテレータになる、という規定が追加された(参照 : &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf&#34; target=&#34;_blank&#34;&gt;N3644 Null Forward Iterators&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以下のアルゴリズムに、2つ目の範囲の終端イテレータをパラメータにとるバージョンを追加。これにより、2つの範囲が同じ長さかを事前にユーザーがチェックする必要がなくなった&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/mismatch.html&#34;&gt;std::mismatch()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/equal.html&#34;&gt;std::equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/is_permutation.html&#34;&gt;std::is_permutation()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;乱数生成を行うアルゴリズム、&lt;code&gt;std::rand()&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/random_shuffle.html&#34;&gt;std::random_shuffle()&lt;/a&gt;&lt;/code&gt;を非推奨とする。&lt;code&gt;std::rand()&lt;/code&gt;の代わりに&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダで定義される乱数生成器と分布クラスを、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/random_shuffle.html&#34;&gt;std::random_shuffle()&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shuffle.html&#34;&gt;std::shuffle()&lt;/a&gt;&lt;/code&gt;を使用すること&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/unique_ptr.html&#34;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;を生成するヘルパ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_unique.html&#34;&gt;std::make_unique()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字列をクォート修飾する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iomanip/quoted.html&#34;&gt;std::quoted&lt;/a&gt;&lt;/code&gt;マニピュレータを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;汎用的なユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2つの値を入れ替える関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/exchange.html&#34;&gt;std::exchange()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;コンパイル時整数シーケンス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/integer_sequence.html&#34;&gt;std::integer_sequence&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;タプルを型の集合と見なし、型を指定して対応する値を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/get.html&#34;&gt;std::get()&lt;/a&gt;&lt;/code&gt;のオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの、メンバ型&lt;code&gt;type&lt;/code&gt;を定義するクラステンプレートに、エイリアステンプレート版を追加。そのバージョンには、&lt;code&gt;_t&lt;/code&gt;サフィックスが付く&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;リテラル演算子&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;の&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/op_s.html&#34;&gt;リテラル演算子&lt;code&gt;s&lt;/code&gt;&lt;/a&gt;を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#34;hello&#34;s&lt;/code&gt;は、文字コード未規定の&lt;code&gt;std::string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&#34;hello&#34;s&lt;/code&gt;は、文字コード未規定の&lt;code&gt;std::wstring&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u8&#34;hello&#34;s&lt;/code&gt;は、UTF-8文字コードの&lt;code&gt;std::string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&#34;hello&#34;s&lt;/code&gt;は、UTF-16文字コードの&lt;code&gt;std::u16string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U&#34;hello&#34;s&lt;/code&gt;は、UTF-32文字コードの&lt;code&gt;std::u32string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration.html&#34;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;の、各時間単位を表す、以下のリテラルを追加&lt;ul&gt;
&lt;li&gt;ナノ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_ns.html&#34;&gt;&lt;code&gt;ns&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;マイクロ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_us.html&#34;&gt;&lt;code&gt;us&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ミリ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_ms.html&#34;&gt;&lt;code&gt;ms&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_s.html&#34;&gt;&lt;code&gt;s&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_min.html&#34;&gt;&lt;code&gt;min&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;時単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_h.html&#34;&gt;&lt;code&gt;h&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;の、各要素型を表す、以下のリテラルを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_i.html&#34;&gt;&lt;code&gt;i&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_if.html&#34;&gt;&lt;code&gt;if&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_il.html&#34;&gt;&lt;code&gt;il&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Readers-writer lockと呼ばれる、書き込みを行うユーザーが1人、読み込みを行うユーザーが複数いる状況で効率的に振る舞うミューテックスの実装として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/shared_mutex.html&#34;&gt;&amp;lt;shared_mutex&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/cpp14&#34; target=&#34;_blank&#34;&gt;C++14 Overview - Standard C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>動的メモリ確保の省略の許可 -- C++14 N3664追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp14/clarifying_memory_allocation.html"/>
      <id>39325f4b21fd96255cbcbfd5c39d065efe8deb30:lang/cpp14/clarifying_memory_allocation.md</id>
      <updated>2021-05-28T13:17:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp14/clarifying_memory_allocation.md b/lang/cpp14/clarifying_memory_allocation.md
new file mode 100644
index 000000000..e0ccec855
--- /dev/null
+++ b/lang/cpp14/clarifying_memory_allocation.md
@@ -0,0 +1,160 @@
+# 動的メモリ確保の省略の許可
+* cpp14[meta cpp]
+
+## 概要
+
+以前の仕様では、`new`式による動的メモリ確保はコードに書かれた通りに実行されなければならず、ひとまとめにしたり省略したりすることはできなかった。
+
+メモリ確保の最適化のためにこの制限は緩和され、実装は`new/delete`の呼び出しをまとめたり省略したりすることができるようになる。
+
+```cpp
+void lump() {
+  // 個別のnew/deleteの呼び出しを
+  int* p1 = new int{1};
+  int* p2 = new int{2};
+  int* p3 = new int{3};
+
+  delete p1;
+  delete p2;
+  delete p3;
+
+  // このようにまとめることが許可される
+  int* p = new int[3]{1, 2, 3};
+
+  delete p;
+}
+
+void emit() {
+  // 確保サイズが分かっているようなnewの呼び出しを
+  int* p = new int{10};
+  delete p;
+
+  // 通常の変数宣言のように置き換えても良い
+  int n = 10;
+}
+```
+
+ただし、このようなまとめと省略は最適化の一環として許可されているものに過ぎず、必ず行われるわけではない。
+
+また、これらの機能と直接関係するものではないが、ユーザー定義されたものも含めた`operator new, operator delete`およびCライブラリの`malloc, calloc, free, realloc`の呼び出しはデータ競合を起こさない事が規定された。
+
+## 仕様
+
+実装は、オーバーロード可能なグローバルの割り当て関数（[`::operator new`](/reference/new/op_new.md)/[`::operator new[]`](/reference/new/op_new[].md)）の呼び出しを省略できる。その場合、（確保されるはずだった）ストレージは実装によって提供されるか、別の`new`式によるアロケーションを拡張してあてがわれる。
+
+ただし、`new`式の呼び出し`e1`のアロケーションを拡張して別の`new`式`e2`のストレージを提供する事ができるのは、アロケーションの拡張が行われなかった時にそれらが次の条件を全て満たしている場合に限る
+
+1. `e1`の評価は`e2`の評価よりも前に順序づけられる
+2. `e1`がストレージを確保するならば、`e2`が呼び出される
+3. `e1`と`e2`は同じオーバーロード可能なグローバルの割り当て関数を呼び出す
+4. `e1`と`e2`で呼び出される割り当て関数が例外を投げる場合、`e1`と`e2`のどちらの評価で発生した例外でも、まず同じハンドラでキャッチされる
+5. `e1`と`e2`によって返されるポインタ値は、評価される`delete`式のオペランドである
+6. `e2`の評価は、`e1`によって生成されたポインタ値をオペランドにとる`delete`式の評価の前に順序づけられる
+
+```cpp
+void ok () {
+  try {
+    int* e1 = new int{1};
+    int* e2 = new int{2};
+
+    delete e2;
+    delete e1;
+  } catch(...){}
+}
+
+void ng1 () {
+  // NG、e2 -&amp;gt; e1の順で確保されている
+  // この場合、e2を拡張してe1を省略することはできる
+  int* e2 = new int{2};
+  int* e1 = new int{1};
+
+  delete e1;
+  delete e2;
+}
+
+void ng2 (bool cond) {
+  int* e1 = new int{1};
+  
+  // NG、e2は必ずしも評価されない
+  if (cond) {
+    int* e2 = new int{2};
+
+    delete e2;
+  }
+
+  delete e1;
+}
+
+void ng3 () {
+  // NG、同じ::operator newを呼び出さない
+  int* e1 = new int{1};
+  int* e2 = new int[]{2};
+
+  delete e1;
+  delete[] e2;
+}
+
+void ng4() {
+  try {
+    int* e1 = new int{1};
+
+    // NG、最初にキャッチされるハンドラが異なる
+    try {
+      int* e2 = new int{2};
+      delete e2;
+    } catch (...) {}
+
+    delete e1;
+  } catch(...){}
+}
+
+void ng5() {
+  // NG、片方または両方がdeleteされていない
+  int* e1 = new int{1};
+  int* e2 = new int{2};
+
+  delete e2;
+  //delete e1;
+}
+
+void ng6 () {
+  int* e1 = new int{1};
+  int* e2 = new int{2};
+
+  // NG、e1 -&amp;gt; e2の順で解放されている
+  delete e1;
+  delete e2;
+}
+```
+
+ここでのNGはコンパイルエラーとなるわけではなく、メモリ確保省略がなされないことを表している。
+
+すなわち、`e2`の確保するメモリ領域の生存期間は`e1`のそれに完全に包含されており、どちらもきちんと`delete`され、同じ関数経由でメモリを確保している場合にのみ、`e1`と`e2`によるメモリ確保は統合される。
+
+このような`new`式の呼び出し`e1`の割り当てが拡張された場合、拡張後に呼び出される割り当て関数の`size`パラメータ（要求サイズ）は元の`e1`と`e2`で指定されていた`size`の合計値に、確保された領域にオブジェクトをアラインさせるために必要なパディングサイズを加えた値を超えない。
+
+`delete`式では、そのオペランドのポインタが割り当てが拡張された`new`式（`e1`）から返されたものであり、`e1`を拡張することによってストレージを提供されていた他の全ての`new`式（`e2`）から返されたポインタに対する`delete`式が評価済である場合、その`delete`式は`e1`を拡張して得られた領域を解放する。
+
+そうではない場合の`delete`式、すなわち`e2`から返されたポインタに対する`delete`式は、解放関数（`::operator delete`）を呼び出さない（領域上のオブジェクトの破棄のみを行う）。
+
+したがって、省略された`::operator new`呼び出しに対応する`::operator delete`の呼び出しもまた省略される。
+
+## この機能が必要になった背景・経緯
+
+動的メモリ確保と解放はとても重い処理であり、パフォーマンスの最適化のためには可能な限り回避する事が望ましい。ただし、呼び出しのミクロな最適化とメモリ割り当て戦略のマクロな最適化は区別される必要があり、それを考慮してメモリ確保を最適化するにはプログラムの実行時の振る舞いや、そこから提供されるヒントを考慮した最適化が必要となる。
+
+しかしC++11の仕様に厳密に従えば、`new/delete`式の呼び出しはその呼び出しから直接得られる情報しか用いてはならず、`new`によるメモリ確保はコードに書いた通りに実行されなければならなかった。そのため、ミクロな最適化もマクロな最適化も妨げられており、動的メモリ確保・解放処理の最適化を阻害していた。
+
+C++11時点で既に、そのような最適化を行うメモリアロケータ（[TCMalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)）やコンパイラが存在しており、それらの存在を追認しかつ動的メモリ確保・解放処理の更なる最適化を可能とするために規格書の文面を調整することとなった。
+
+それによって、ミクロな範囲での`new/delete`式の省略が許可され、マクロな範囲の様々な情報を考慮してそれを行う事が可能となった。
+
+## 関連項目
+
+- [C++20 可変サイズをもつコンテナの`constexpr`化](/lang/cpp20/more_constexpr_containers.md)
+
+
+## 参照
+
+- [N3664 Clarifying Memory Allocation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html)
+- [C++14言語編 - slideshare](https://www.slideshare.net/kariya_mitsuru/c14-84084931)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- C++14 N3664追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>39325f4b21fd96255cbcbfd5c39d065efe8deb30:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-28T13:17:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index bae99d54e..6a42b658e 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -329,6 +329,7 @@ int main() {
 
 ## 関連項目
 
+- [動的メモリ確保の省略の許可](/lang/cpp14/clarifying_memory_allocation.md)
 - [`allocator`](/reference/memory/allocator.md)
 - [`allocator_traits`](/reference/memory/allocator_traits.md)
 - [`construct_at`](/reference/memory/construct.md.nolink)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>任意の式によるSFINAE -- C++11 SFINAE expr : decltype(a + b, bool())の説明コメントを追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/sfinae_expressions.html"/>
      <id>b4235fc7c5fb8384fe4de49592703923fe8809c4:lang/cpp11/sfinae_expressions.md</id>
      <updated>2021-05-28T12:07:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/sfinae_expressions.md b/lang/cpp11/sfinae_expressions.md
index 9ebea4788..8526b9169 100644
--- a/lang/cpp11/sfinae_expressions.md
+++ b/lang/cpp11/sfinae_expressions.md
@@ -14,6 +14,11 @@
 template &amp;lt;class T1, class T2&amp;gt;
 auto is_addable(T1 a, T2 b) -&amp;gt; decltype(a + b, bool())
 {
+  // decltype(a + b, bool())は、式a + bを評価しつつ、
+  // 戻り値の型としてはboolを返すという動作。
+  // 組み込みのカンマ演算子の
+  // 「`a, b`は`a`を評価しつつ式の結果としては`b`を返す」という仕様を利用している
+
   std::cout &amp;lt;&amp;lt; &amp;#34;型T1とT2の間で、+演算子による加算が可能&amp;#34; &amp;lt;&amp;lt; std::endl;
   return true;
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>overrideとfinal -- override_final: コード説明コメントにてfinalクラス継承不可を明記</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/override_final.html"/>
      <id>f2669bf093d4e8f5f53df3c69f112fd4b26288fa:lang/cpp11/override_final.md</id>
      <updated>2021-05-28T09:49:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/override_final.md b/lang/cpp11/override_final.md
index 8d2beef61..11af2f0ba 100644
--- a/lang/cpp11/override_final.md
+++ b/lang/cpp11/override_final.md
@@ -65,7 +65,7 @@ class AAA {
 
 ## 例
 ```cpp example
-//基底クラス
+// 基底クラス
 class base {
   virtual void func_final() final;
   virtual void func_virt();
@@ -73,29 +73,29 @@ class base {
   void func_non_virt();
 };
 
-//派生クラス
+// 派生クラス
 class derived : public base {
-  //NG, final メンバ関数はオーバーライドできない
+  // NG, final メンバ関数はオーバーライドできない
   void func_final();
 
-  //OK, オーバーライドできている
+  // OK, オーバーライドできている
   void func_virt() override;
 
-  //NG, 引数の個数、型が違っており、オーバーライドできてない
+  // NG, 引数の個数、型が違っており、オーバーライドできてない
   void func_virt_int(short a) override;
 
-  //NG, 基底クラスの func_non_virt() は仮想関数では無いので、オーバーライドできていない
+  // NG, 基底クラスの func_non_virt() は仮想関数では無いので、オーバーライドできていない
   void func_non_virt() override;
 };
 
-//オーバーライド不可の基底クラス
+// オーバーライド不可の基底クラス
 class base_f final {
   virtual void func_virt();
 };
 
-//派生クラス
+// NG, final基底クラスからの継承はできない
 class derived_f : public base_f {
-  //NG, final 基底クラスのメンバ関数はオーバーライドできない
+  // NG, （結果的に）final基底クラスのメンバ関数はオーバーライドできない
   void func_virt();
 };
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>厳密な式の評価順 -- expression_evaluation_order: 調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/expression_evaluation_order.html"/>
      <id>8dbd27843b8385284a601eed184bf5e25e6f4d23:lang/cpp17/expression_evaluation_order.md</id>
      <updated>2021-05-27T18:13:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/expression_evaluation_order.md b/lang/cpp17/expression_evaluation_order.md
index 9be20dc13..ba082317b 100644
--- a/lang/cpp17/expression_evaluation_order.md
+++ b/lang/cpp17/expression_evaluation_order.md
@@ -4,18 +4,19 @@
 ## 概要
 
 C++14までは式の評価順序が未規定（unspecified）であったが、
-C++17では次の式は全てa, bの順で評価されるように定義された。
+C++17では次の式は全て`a`, `b`の順で評価されるように定義された。
 
-1. a.b
-1. a-&amp;gt;b
-1. a-&amp;gt;*b
-1. a(b1, b2, b3)
-1. b @= a
-1. a[b]
-1. a &amp;lt;&amp;lt; b
-1. a &amp;gt;&amp;gt; b
+1. `a.b`
+1. `a-&amp;gt;b`
+1. `a-&amp;gt;*b`
+1. `a(b1, b2, b3)`
+1. `b @= a`
+1. `a[b]`
+1. `a &amp;lt;&amp;lt; b`
+1. `a &amp;gt;&amp;gt; b`
 
-関数の引数リスト内の式（上記例で言えばb1, b2, b3）の評価順序は未規定である。
+関数の引数リスト内の式（上記例で言えば`b1`, `b2`, `b3`）の評価順序は未規定である。
+`@=`は代入演算子`=`や任意の複合代入演算子（`+=`, `-=`など）を表す。
 
 
 ## 仕様
@@ -36,7 +37,7 @@ C++17では式の評価順序が下記の通りに定められた。
 
 3番目の規則については、
 代入演算子`operator=`をオーバーロードした場合を考えるとわかりやすいと思う。
-代入演算子は右から左の順、つまりa, bの順で評価される。
+代入演算子は右から左の順、つまり`a`, `b`の順で評価される。
 
 ```cpp
 struct Hoge {
@@ -52,7 +53,7 @@ int main()
 Hogeクラスの代入演算子をオーバーロードすると、
 `b = a;`は`b.operator=(a);`となりメンバ関数呼び出しと等価になる。
 このとき3番目の規則が存在しなかったとすると、メンバ関数呼び出しの規則が適用される。
-メンバ関数呼び出しの評価順序は左から右の順、つまりb, aの順で評価され、
+メンバ関数呼び出しの評価順序は左から右の順、つまり`b`, `a`の順で評価され、
 代入式の評価順序と逆になってしまう。
 
 ```cpp
@@ -117,8 +118,8 @@ int main() {
 ```
 
 下記のプログラムの動作を考える。
-`std::cout`, f, g, hが互いに作用する
-（例えばf, g, h内で`std::cout`に何か出力するなど）場合、
+`std::cout`, `f`, `g`, `h`が互いに作用する
+（例えば`f`, `g`, `h`内で`std::cout`に何か出力するなど）場合、
 このプログラムの動作は不定であった。
 
 シフト演算子は左結合なので`(((std::cout &amp;lt;&amp;lt; f) &amp;lt;&amp;lt; g) &amp;lt;&amp;lt; h)`の順に評価されそうだが、
@@ -137,8 +138,8 @@ std::cout.operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g()).operator&amp;lt;&amp;lt;(h());
 
 このとき`operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g())`のように、
 メンバ関数呼び出しの連鎖が発生するが、この評価順は未規定であり、
-右から左、すなわちg, fの順で評価されるかも知れないし、
-左から右、すなわちf, gの順に評価されるかも知れない。
+右から左、すなわち`g`, `f`の順で評価されるかも知れないし、
+左から右、すなわち`f`, `g`の順に評価されるかも知れない。
 
 以上のように、シンプルな代入演算やメンバ関数の連鎖などC++で広く使われている手法でさえ、
 動作結果が不定となってしまう問題がある。
@@ -157,4 +158,4 @@ C++の既存のプログラムを壊すこと無く、なおかつ、
 
 ## 参照
 - [P0145R3 Refining Expression Evaluation Order for Idiomatic C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf)
-- [Wording for Order of Evaluation of Function Arguments](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0400r0.html)
+- [P0400R0 Wording for Order of Evaluation of Function Arguments](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0400r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- P0784R7 : operator newの省略について修正と追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>c44228943d181c419c872b3f3e7ae02c9a6f99ba:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-27T01:00:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index f43fcc721..bae99d54e 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -134,7 +134,7 @@ int main () {
 
 したがって、C++20のコンパイル時動的メモリ確保の仕様では、コンパイル時に確保したメモリ領域を実行時へ持ち越すことはできない。
 
-実際には、これらの定数式中の`new`式の評価は常に省略されている。この省略はC++14より許可されている最適化の一環として行われ、スタック領域などのストレージを別途割り当てることで動的メモリ確保を避けるものである。対応する`delete`式の呼び出しも同様に省略され、定数式においてはメモリの確保と解放が一貫していることのマーカーとしての役割しか持たない。
+実際には、これらの定数式中の`new`式において呼び出される`::operator new()`の評価は常に省略されている。この省略はC++14より許可されている最適化の一環として行われ、スタック領域などのストレージを別途あてがうことで動的メモリ確保を避けるものである。対応する`delete`式における`::operator delete()`の呼び出しも同様に省略され、定数式における`new/delete`式はメモリの確保と解放が一貫していることのマーカーとしての側面が強くなっている。
 
 ```cpp
 constexpr void f() {
@@ -142,12 +142,12 @@ constexpr void f() {
   int* d = new int{2};
   delete d;
 
-  // 次のようなコードと等価になる
+  // たとえば次のようなコードと等価になる
   int d{2};
 }
 ```
 
-実際にはどこのストレージが提供されるかは規定されていない。
+実際にはどこのストレージが提供されるかは実装定義である。
 
 ### `std::allocator/std::allocator_traits`
 
@@ -245,6 +245,10 @@ constexpr int g() {
 
 `destroy_at`には類似のファミリとして[`destroy_n`](/reference/memory/destroy_n.md)と、それらの`range`版があり（あるいは追加され）、`construct_at`も`range`版が同時に追加されるが、それらについても`construct_at/destroy_at`と同様の扱いが可能となる。
 
+`std::allocator::allocate()`はグローバルの`::operator new()`を呼び出すが、この呼び出しは`new`式の時と同様に省略されており、`std::allocator::deallocate()`における`::operator delete()`の呼び出しも省略されている。この2つもまた`new/delete`式と同様に、メモリの確保と解放が一貫していることのマーカーとしての側面が強くなっている。
+
+結局、C++20のコンパイル時動的メモリ確保は定数式にヒープ領域を導入するものではなく、デフォルトの`::operator new`による動的メモリ確保を別の領域をあてがう形に置換することで行われている。
+
 ## この機能が必要になった背景・経緯
 
 `std::vector`をはじめとする可変サイズのコンテナは実行時に非常に有用であるため、同様に定数式においても有用である可能性があり、その必要性がC++コミュニティからも示されいていた（[C++Now 2017: Ben Deane &amp;amp; Jason Turner &amp;#34;constexpr ALL the things!&amp;#34;](https://youtu.be/HMB9oXFobJc)、[P0810R0 constexpr in Practice](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0810r0.pdf)など）。
@@ -341,4 +345,5 @@ int main() {
 - [P0784R6 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r6.html)
 - [P0784R7 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html)
 - [動的メモリー確保 - 江添亮の入門C++](https://ezoeryou.github.io/cpp-intro/#動的メモリー確保)
+- [N3664 Clarifying Memory Allocation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html)
 - [P1974R0 Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>