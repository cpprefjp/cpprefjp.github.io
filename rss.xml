<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-18T11:51:03.029394</updated>
  <id>1cf82d05-2c57-409d-94b8-9635155acf95</id>

  
    <entry>
      <title>format -- format : vector&lt;vector&lt;int&gt;&gt;の書式指定の例を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/format.html"/>
      <id>c73a9543b5fc9445921fd23c14b862129e8d21d3:reference/format/format.md</id>
      <updated>2023-01-18T20:46:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format.md b/reference/format/format.md
index 110f2a53d..50e023e2f 100644
--- a/reference/format/format.md
+++ b/reference/format/format.md
@@ -390,16 +390,21 @@ int main() {
   std::vector&amp;lt;int&amp;gt; vx = {0xf, 0x1e, 0x3c};
   std::cout &amp;lt;&amp;lt; std::format(&amp;#34;5. {::#x}&amp;#34;, vx) &amp;lt;&amp;lt; std::endl;
 
+  // vector&amp;lt;vector&amp;lt;T&amp;gt;&amp;gt;の場合は、:で区切られた要素の書式がRangeの書式となり、
+  // さらに :で区切って要素の書式指定をする
+  std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; vvx = {{0xf, 0x1e}, {0x3c}};
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;6. {:::#x}&amp;#34;, vvx) &amp;lt;&amp;lt; std::endl;
+
   // コンテナの要素型が文字・文字列型の場合はデフォルトでデバッグ出力 (?) が適用されるが、
   // 要素への書式指定として ? を指定しなければ、デバッグ出力が解除される
   std::vector&amp;lt;std::string&amp;gt; vt = {&amp;#34;h\tello&amp;#34;, &amp;#34;w\norld&amp;#34;, &amp;#34;C++&amp;#34;};
-  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;6. {:}&amp;#34;, vt) &amp;lt;&amp;lt; std::endl;
-  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;7. {::}&amp;#34;, vt) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;7. {:}&amp;#34;, vt) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;8. {::}&amp;#34;, vt) &amp;lt;&amp;lt; std::endl;
 
   // 文字を要素とするコンテナは文字列として出力させることもできる
   std::vector&amp;lt;char&amp;gt; vc = {&amp;#39;h&amp;#39;, &amp;#39;\n&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;};
-  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;8. {:s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
-  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;9. {:?s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;9. {:s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;10. {:?s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
 }
 ```
 * std::ranges::views::iota[link /reference/ranges/iota_view.md]
@@ -412,12 +417,13 @@ int main() {
 3. {1, 2, 3}
 4. [1, 2, 3, 4]
 5. [0xf, 0x1e, 0x3c]
-6. [&amp;#34;h\tello&amp;#34;, &amp;#34;w\norld&amp;#34;, &amp;#34;C++&amp;#34;]
-7. [h    ello, w
+6. [[0xf, 0x1e], [0x3c]]
+7. [&amp;#34;h\tello&amp;#34;, &amp;#34;w\norld&amp;#34;, &amp;#34;C++&amp;#34;]
+8. [h    ello, w
 orld, C++]
-8. h
+9. h
 ello
-9. &amp;#34;h\nello&amp;#34;
+10. &amp;#34;h\nello&amp;#34;
 ```
 
 ### pair、tupleを出力する (C++23)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator delete -- operator delete : 一覧の整理</title>
      <link href="https://cpprefjp.github.io/reference/new/op_delete.html"/>
      <id>0f9f47544b06f157c39972ad9e2f7d28e274a304:reference/new/op_delete.md</id>
      <updated>2023-01-18T18:08:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/new/op_delete.md b/reference/new/op_delete.md
index 63c16b89b..b8981ba97 100644
--- a/reference/new/op_delete.md
+++ b/reference/new/op_delete.md
@@ -6,12 +6,16 @@
 ```cpp
 void operator delete(void* ptr) throw();                                                // (1) C++03 まで
 void operator delete(void* ptr) noexcept;                                               // (1) C++11 から
+
 void operator delete(void* ptr, std::size_t size) noexcept;                             // (2) C++14 から
+
 void operator delete(void* ptr, std::align_val_t alignment) noexcept;                   // (3) C++17 から
+
 void operator delete(void* ptr, std::size_t size, std::align_val_t alignment) noexcept; // (4) C++17 から
 
 void operator delete(void* ptr, const std::nothrow_t&amp;amp;) throw();                              // (5) C++03 まで
 void operator delete(void* ptr, const std::nothrow_t&amp;amp;) noexcept;                             // (5) C++11 から
+
 void operator delete(void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;amp;) noexcept; // (6) C++17 から
 
 void operator delete(void* ptr, void*) throw();                                     // (7) C++03 まで
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator delete[] -- operator delete : 一覧の整理</title>
      <link href="https://cpprefjp.github.io/reference/new/op_delete[].html"/>
      <id>0f9f47544b06f157c39972ad9e2f7d28e274a304:reference/new/op_delete[].md</id>
      <updated>2023-01-18T18:08:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/new/op_delete[].md b/reference/new/op_delete[].md
index 7be6ffe5c..9866bb4d4 100644
--- a/reference/new/op_delete[].md
+++ b/reference/new/op_delete[].md
@@ -6,12 +6,16 @@
 ```cpp
 void operator delete[](void* ptr) throw();                                                // (1) C++03 まで
 void operator delete[](void* ptr) noexcept;                                               // (1) C++11 から
+
 void operator delete[](void* ptr, std::size_t size) noexcept;                             // (2) C++14 から
+
 void operator delete[](void* ptr, std::align_val_t alignment) noexcept;                   // (3) C++17 から
+
 void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept; // (4) C++17 から
 
 void operator delete[](void* ptr, const std::nothrow_t&amp;amp;) throw();                              // (5) C++03 まで
 void operator delete[](void* ptr, const std::nothrow_t&amp;amp;) noexcept;                             // (5) C++11 から
+
 void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;amp;) noexcept; // (6) C++17 から
 
 void operator delete[](void* ptr, void*) throw();                                       // (7) C++03 まで
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変長データを扱うクラスの効率的な`delete` -- 可変長データを扱うクラスの効率的な`delete`、完成 #1102</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.html"/>
      <id>5e7e22e36add8468caa85af0a3c18a7a443a5e1b:lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md</id>
      <updated>2023-01-18T17:57:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md b/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
index dc5424748..913238ea8 100644
--- a/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
+++ b/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
@@ -126,6 +126,47 @@ struct S {
 
 *destroying operator delete*が`operator delete`として使用される`delete`式の実行において、`delete`式は`delete`対象オブジェクトのデストラクタを呼び出さないで`operator delete`を呼び出す。また、その際の*destroying operator delete*の第二引数（`std::destroying_delete_t`に対応する引数）に渡される値は未規定。
 
+`delete`式に指定されているポインタの指すオブジェクトがクラス型であり、そのデストラクタが仮想デストラクタである場合、その`delete`式の実行に伴う`operator delete`の探索はそのオブジェクトの動的型（実行時の実際のクラス型）のスコープで行われる。この探索は、クラスの仮想関数を基底クラスから呼び出す時と同じものである。
+
+```cpp
+// 基底クラス
+struct B {
+  virtual ~B();
+
+  // 普通のdelete演算子オーバーロード
+  void operator delete(void*, std::size_t);
+};
+
+// 派生クラス1
+struct D : B {
+  // 普通のdelete演算子オーバーロード
+  void operator delete(void*);
+};
+
+// 派生クラス2
+struct E : B {
+  void log_deletion();
+
+  // destroying operator delete
+  void operator delete(E *p, std::destroying_delete_t) {
+    p-&amp;gt;log_deletion();
+    p-&amp;gt;~E();
+    ::operator delete(p);
+  }
+};
+
+void f() {
+  B* bp = new D;
+  delete bp; // #1 D::operator delete(void*)が呼び出される
+
+  bp = new E;
+  delete bp; // #2 E::operator delete(E*, std::destroying_delete_t)が呼び出される
+}
+```
+
+`#1`において、`D`のオブジェクトは`delete`式によって破棄され、そのメモリ領域は`D::operator delete`によって解放される。  
+`#2`において、`E`のオブジェクトの破棄とそのメモリ領域の解放は`E::operator delete`（*destroying operator delete*）によって行われる。
+
 ## 例
 
 ### 可変サイズクラスの`delete`
@@ -292,16 +333,100 @@ destruct derived2
 ```
 
 ## この機能が必要になった背景・経緯
-（執筆中）
+
+1つ目の例に挙げた`inlined_fixed_string`のような可変サイズクラスの定義は、ポインタの間接参照を回避しながら可変長配列を定義することができ、よく書かれるパターンだった（実際には*flexible array member*を使用することが多い）。
+
+しかし、このようなクラスは[サイズ付きデアロケーション](/lang/cpp14/sized_deallocation.md)を活用して効率的に削除することができなかった。
+
+`inlined_fixed_string`のオブジェクトを指すポインタを`s`とすると、`delete s;`という式の実行において、C++14（[CWG Issue 2248](https://cplusplus.github.io/CWG/issues/2248)解決前）のコンパイラは次のようなコードを呼び出す必要があった
+
+```cpp
+::operator delete(s, full_size);
+```
+
+しかし、この場合に自動で`full_size`を取得することはできない。
+
+C++17では代わりに次のようなコードを出力する
+
+```cpp
+::operator delete(s, sizeof(inlined_fixed_string));
+```
+
+が、これは正しく確保したメモリ領域を解放していない。
+
+正しくは、クラスで`operator delete`をオーバーロードする必要がある
+
+```cpp
+static void operator delete(void* ptr) {
+  ::operator delete(ptr); // アロケータが知っているptrのサイズ情報に頼る（アロケータでそのサイズを求めるためのオーバーヘッドが発生しうる）
+}
+```
+
+すなわち、サイズ付きデアロケーションを全く利用しない。これは安全に解放できるようになる一方で、サイズ付きデアロケーションのパフォーマンス上の利点を全て捨てることになる。
+
+理想的には、クラスが保存している実際に確保したメモリのサイズを取得できることが望ましい
+
+```cpp
+static void operator delete(void* ptr) {
+  inlined_fixed_string *s = reinterpret_cast&amp;lt;inlined_fixed_string*&amp;gt;(ptr); // UB
+  std::size_t full_size = sizeof(inlined_fixed_string) + s-&amp;gt;size();       // UB
+  ::operator delete(ptr, full_size);
+}
+```
+
+しかし、前述のように、この`operator delete`実行の前に`ptr`にあるオブジェクトは破棄されているため、これは未定義動作となる。
+
+*destroying operator delete*は、この一番最後の`operator delete`相当のコードを安全にし、このような可変長クラスの`delete`を効率化するために導入された。
 
 ## 検討されたほかの選択肢
-（執筆中）
+
+### `delete p`以外の削除メカニズム
+
+*destroying operator delete*が必要となる場合に、`delete`式ではなく別のメカニズムによってオブジェクトの破棄とメモリ解放を行う方法が検討された。しかし、これに次のような欠点がある
+
+- ユーザー定義型が組み込み型と同様に使用されるという原則に違反している
+    - この方法の場合、`delete`式が使えなくなる
+- 仮想デストラクタを持つ既存のクラス階層は、動的にクラスレイアウトの先頭/末尾に領域を拡張する派生クラスに対して透過的に拡張できない
+- メモリ解放戦略のローカルな選択がコードの利用者にリークする
+    - `std::unique_ptr`などにおいてはカスタムデリータを指定しなければならない
+    - `std::make_unique`などは使用できない
+    - リソース管理に`new/delete`を使用する多くのリソース管理クラスを使用できない
+
+これらの欠点（特に、`delete`式が使用できないこと）によって、この方法は好まれなかった。
+
+### destroying operator deleteの別の構文
+
+*destroying operator delete*を宣言する構文として、いくつかの構文が検討された。
+
+```cpp
+struct S {
+  // 1. void*の代わりにS*をとる
+  void operator delete(S*);
+
+  // 2. 1+~を先頭につける
+  void operator ~delete(S*);
+
+  // 3. デストラクタ風宣言
+  ~S delete();
+};
+```
+
+1. 通常の`operator delete`オーバーロードと区別がつきづらい
+2. まだ通常の`operator delete`オーバーロードと区別がつきづらい
+    - `~delete`は新しい演算子であるため可読性の問題がある
+    - *destroying operator delete*は`delete`式の実行を完全にオーバーライドするものだが、異なる演算子オーバーロードになっていることによってそれを表現していない
+3. デストラクタ風味の宣言によって、サブオブジェクト（メンバや基底クラス）のデストラクタが自動で呼ばれるという勘違いを招く可能性がある。
+    - 加えて、2と同様の問題がある
+
+結局、`std::destroying_delete_t`を第二引数に取る形が一番シンプルかつ可読性が高いとして採用された。
 
 ## 関連項目
 
+- [C++14 サイズ付きデアロケーション](/lang/cpp14/sized_deallocation.md)
 - [`std::destroying_delete_t`](/reference/new/destroying_delete_t.md)
 
 ## 参照
 
 - [P0722R3 Efficient sized delete for variable sized classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0722r3.html)
 - [P0722R1 Efficient sized delete for variable sized classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0722r1.html)
+- [CWG Issue 2248. Problems with sized delete](https://cplusplus.github.io/CWG/issues/2248)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator delete[] -- operator delete[] : 番号の調整</title>
      <link href="https://cpprefjp.github.io/reference/new/op_delete[].html"/>
      <id>3a5b2dc12d79e256423a3b90bb35533e103ec671:reference/new/op_delete[].md</id>
      <updated>2023-01-18T09:33:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/new/op_delete[].md b/reference/new/op_delete[].md
index b734ca7cd..7be6ffe5c 100644
--- a/reference/new/op_delete[].md
+++ b/reference/new/op_delete[].md
@@ -11,11 +11,11 @@ void operator delete[](void* ptr, std::align_val_t alignment) noexcept;
 void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept; // (4) C++17 から
 
 void operator delete[](void* ptr, const std::nothrow_t&amp;amp;) throw();                              // (5) C++03 まで
-void operator delete[](void* ptr, const std::nothrow_t&amp;amp;) noexcept;                             // (6) C++11 から
-void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;amp;) noexcept; // (7) C++17 から
+void operator delete[](void* ptr, const std::nothrow_t&amp;amp;) noexcept;                             // (5) C++11 から
+void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;amp;) noexcept; // (6) C++17 から
 
-void operator delete[](void* ptr, void*) throw();                                       // (8) C++03 まで
-void operator delete[](void* ptr, void*) noexcept;                                      // (8) C++11 から
+void operator delete[](void* ptr, void*) throw();                                       // (7) C++03 まで
+void operator delete[](void* ptr, void*) noexcept;                                      // (7) C++11 から
 ```
 * std::nothrow_t[link nothrow_t.md]
 * std::align_val_t[link align_val_t.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unreachable -- utility/unreachable: 微調整</title>
      <link href="https://cpprefjp.github.io/reference/utility/unreachable.html"/>
      <id>da9f2c769593d5d8b94ad15ed3291ab538c5f83f:reference/utility/unreachable.md</id>
      <updated>2023-01-18T09:25:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/unreachable.md b/reference/utility/unreachable.md
index f4e949d46..9ba4c982d 100644
--- a/reference/utility/unreachable.md
+++ b/reference/utility/unreachable.md
@@ -19,7 +19,7 @@ namespace std {
 
 
 ## 備考
-`std::unreachable`関数の事前条件は決して満たされない（恒偽式）となるため、関数呼び出しは常に未定義の動作を引き起こす。
+`std::unreachable`関数の事前条件は決して満たされない（恒偽式）ため、関数呼び出しは常に未定義の動作を引き起こす。
 C++コンパイラはこの情報を利用し、`std::unreachable`呼び出しを含まないコードパスのみが実行されうると仮定して、より高速に動作するプログラムを生成する可能性がある。
 
 
@@ -28,15 +28,18 @@ C++コンパイラはこの情報を利用し、`std::unreachable`呼び出し
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;utility&amp;gt;
 
-int f(int x)
+int flip(int x)
 {
- switch (x) {
- case 0:
- case 1:
-   return x;
- default:
-   std::unreachable();
- }
+  switch (x) {
+  case 0:
+    return 1;
+  case 1:
+    return 0;
+  default:
+    // C++コンパイラは引数 x が値0,1以外を取らないと
+    // 仮定したコード生成を行う可能性がある。
+    std::unreachable();
+  }
 }
 
 int main()
@@ -50,8 +53,8 @@ int main()
 
 ### 出力
 ```
-0
 1
+0
 ```
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>