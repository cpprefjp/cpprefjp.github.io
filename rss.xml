<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-01T01:21:16.264932</updated>
  <id>4f5d37c0-e40a-4c79-a553-522f6e034f70</id>

  
    <entry>
      <title>operator= -- ゼロ幅スペース除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_assign.html"/>
      <id>653081e759e041f845ec7efa22dad18ab81635ca:reference/tuple/tuple/op_assign.md</id>
      <updated>2023-02-01T10:15:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_assign.md b/reference/tuple/tuple/op_assign.md
index 23b54f8aa..46582ddf2 100644
--- a/reference/tuple/tuple/op_assign.md
+++ b/reference/tuple/tuple/op_assign.md
@@ -96,11 +96,11 @@ constexpr const tuple&amp;amp; operator=(UTuple&amp;amp;&amp;amp;) const;        // (14) C++23
 - (13) : 要素数が同じかつ、次を全て満たすこと
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`
     - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
-    - C++23 : 全ての`i`について、[`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
+    - C++23 : 全ての`i`について、[`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
 - (14) : 要素数が同じかつ、次をすべて満たすこと
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`
     - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
-    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- ゼロ幅スペース除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_constructor.html"/>
      <id>653081e759e041f845ec7efa22dad18ab81635ca:reference/tuple/tuple/op_constructor.md</id>
      <updated>2023-02-01T10:15:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_constructor.md b/reference/tuple/tuple/op_constructor.md
index 2bf4e9eeb..cc7f01e03 100644
--- a/reference/tuple/tuple/op_constructor.md
+++ b/reference/tuple/tuple/op_constructor.md
@@ -304,7 +304,7 @@ explicit(see below) constexpr
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`であること
     - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
     - C++23 : `sizeof...(Types) ==` [`tuple_size_v`](../tuple_size.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;&amp;gt;`であること
-    - C++23 : `(`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, decltype(get&amp;lt;I&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt; &amp;amp;&amp;amp; ...) == true`であること
+    - C++23 : `(`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, decltype(get&amp;lt;I&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt; &amp;amp;&amp;amp; ...) == true`であること
     - C++23 : `sizeof...(Types) != 1`であるか、または`Types...`を`T`に展開したとして[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;UTuple, T&amp;gt; == false &amp;amp;&amp;amp;` [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, UTuple&amp;gt; == false`であること
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- ゼロ幅スペース除去</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_assign.html"/>
      <id>653081e759e041f845ec7efa22dad18ab81635ca:reference/utility/pair/op_assign.md</id>
      <updated>2023-02-01T10:15:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_assign.md b/reference/utility/pair/op_assign.md
index 9c1e43341..3e48d1d6c 100644
--- a/reference/utility/pair/op_assign.md
+++ b/reference/utility/pair/op_assign.md
@@ -66,13 +66,13 @@ template&amp;lt;pair-like P&amp;gt;
 - (9) : 次を全て満たすこと
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;P, pair&amp;gt;`
     - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;P&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
-    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
-    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
 - (10) : 次を全て満たすこと
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;P, pair&amp;gt;`
     - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;P&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
-    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
-    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>INVOKE -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/concepts/Invoke.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/concepts/Invoke.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;named requirement&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace &#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;INVOKE&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;C++における関数呼び出しという性質を抽象化しまとめた、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt; を定義する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++17からは、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt; を実体化した&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;関数テンプレートが提供される。&lt;/li&gt;
&lt;li&gt;C++23からは、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;&lt;/code&gt; を実体化した&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke_r.html&#34;&gt;std::invoke_r&lt;/a&gt;&lt;/code&gt;関数テンプレートが提供される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;用語定義&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;call-signature&lt;/em&gt; とは、戻り値型に続けて丸括弧の中に0個以上の引数型を並べたものである。 &lt;em&gt;cf.&lt;/em&gt; &lt;code&gt;int ( std::string, int )&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-type&lt;/em&gt; とは、関数呼び出し演算子を適用できる型 ( 関数、関数への参照、関数へのポインタ、&lt;code&gt;operator ()&lt;/code&gt; をオーバーロードした型もしくはそれを(直接または間接的に) &lt;code&gt;public&lt;/code&gt; 継承した型 ) もしくはメンバへのポインタ型を指す。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-object&lt;/em&gt; は、 &lt;em&gt;callable-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper-type&lt;/em&gt; は、 &lt;em&gt;callable-object&lt;/em&gt; を保持し、自身に対する関数呼び出し操作が行われたとき、保持しているオブジェクトに委譲する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; は、 &lt;em&gt;call-wrapper-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;target-object&lt;/em&gt; とは、 &lt;em&gt;callable-object&lt;/em&gt; に保持されているオブジェクトのことである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;要件（C++14まで）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が T 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN, R)&lt;/code&gt; を、 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること、と定義する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; が &lt;em&gt;weak-result-type&lt;/em&gt; を用意している場合、メンバ型 &lt;code&gt;result_type&lt;/code&gt; は&lt;em&gt;target-object&lt;/em&gt; の型 &lt;code&gt;T&lt;/code&gt; に応じて次のように定義される。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; がメンバ関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;result_type&lt;/code&gt; という名前のメンバ型を持つとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T::result_type&lt;/code&gt; と等しい。&lt;/li&gt;
&lt;li&gt;どの条件にも当てはまらない場合、 &lt;code&gt;result_type&lt;/code&gt; は定義されない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveAssignable&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++17）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveConstructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++20）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;Cpp17MoveConstructible&lt;/em&gt; かつ &lt;em&gt;Cpp17Destructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++23差分）&lt;/h2&gt;
&lt;p&gt;C++20 における 2. について、次の文言を項目の最後に追加する。この変更は、&lt;code&gt;R&lt;/code&gt;が参照かつ&lt;em&gt;INVOKE&lt;/em&gt;の実行結果が&lt;code&gt;R&lt;/code&gt;に束縛されることで寿命が延長される場合にダングリング参照が作成されてしまう事例を検出するための要件である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html&#34;&gt;reference_converts_from_temporary_v&lt;/a&gt;&amp;lt;R, decltype(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, …, tN))&amp;gt; == true&lt;/code&gt;の場合、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, …, tN)&lt;/code&gt;は&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/Cryolite/status/216814363221303296&#34; target=&#34;_blank&#34;&gt;第1引数がメンバ関数へのポインタの場合でも非静的メンバデータへのポインタの場合でも，第2引数がクラスオブジェクトへの参照の場合でもポインタの場合でもポインタっぽいものの場合でも，なんか知らんけどそれっぽく上手くいく&lt;/a&gt; ように取り計らった操作のことである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;function&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;bind&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/thread.html&#34;&gt;thread&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/async.html&#34;&gt;async&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/packaged_task.html&#34;&gt;packaged_task&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/call_once.html&#34;&gt;call_once&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf&#34; target=&#34;_blank&#34;&gt;P0777R1 Treating Unnecessary &lt;code&gt;decay&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++20から&lt;code&gt;decay_t&lt;/code&gt;を&lt;code&gt;remove_cvref_t&lt;/code&gt;へ変更。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2136r3.html&#34; target=&#34;_blank&#34;&gt;P2136R3 &lt;code&gt;invoke_r&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>simple-view -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/ranges/simple-view.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/ranges/simple-view.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/simple-view.md b/reference/ranges/simple-view.md
index 7b2c01bbd..d31987cb2 100644
--- a/reference/ranges/simple-view.md
+++ b/reference/ranges/simple-view.md
@@ -7,8 +7,8 @@
 template&amp;lt;class R&amp;gt;
   concept simple-view = // 説明専用コンセプト
     view&amp;lt;R&amp;gt; &amp;amp;&amp;amp; range&amp;lt;const R&amp;gt; &amp;amp;&amp;amp;
-    same_­as&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;const R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
-    same_­as&amp;lt;sentinel_t&amp;lt;R&amp;gt;, sentinel_t&amp;lt;const R&amp;gt;&amp;gt;;
+    same_as&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;const R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+    same_as&amp;lt;sentinel_t&amp;lt;R&amp;gt;, sentinel_t&amp;lt;const R&amp;gt;&amp;gt;;
 ```
 * same-as[link /reference/concepts/same_as.md]
 * view[link view.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_from_tuple -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/make_from_tuple.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/make_from_tuple.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/make_from_tuple.md b/reference/tuple/make_from_tuple.md
index e175fecd8..f4028bfcf 100644
--- a/reference/tuple/make_from_tuple.md
+++ b/reference/tuple/make_from_tuple.md
@@ -26,7 +26,7 @@ namespace std {
 また、型`T`の初期化はそのコンストラクタで行われ集成体初期化は考慮されない。つまり、`Tuple`に含まれる型が空かただ一つの`T`でない場合、型`T`は集成体（aggregate）であってはならない（C++17のみ、C++20以降はok）。
 
 更に、C++23以降は`make_from_tuple`の返り値が参照である場合でダングリング参照を生成しないために、`make_from_tuple`の内部で`T`が構築される際に、`Tuple`から取得されるオブジェクト（参照の初期化であるので、`Tuple`のサイズは1である必要がある）の寿命が延長されないことも要求され、これを満たさない場合はコンパイルエラーとなる。
-正確には、[`tuple_­size_­v`](tuple_size.md)`&amp;lt;`[`remove_­reference_­t`](/reference/type_traits/remove_reference.md)`&amp;lt;Tuple&amp;gt;&amp;gt; == 1`である場合、[`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T, decltype(get&amp;lt;0&amp;gt;(`[`declval`](/reference/utility/declval.md)`&amp;lt;Tuple&amp;gt;()))&amp;gt; == false`であること。
+正確には、[`tuple_size_v`](tuple_size.md)`&amp;lt;`[`remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;Tuple&amp;gt;&amp;gt; == 1`である場合、[`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T, decltype(get&amp;lt;0&amp;gt;(`[`declval`](/reference/utility/declval.md)`&amp;lt;Tuple&amp;gt;()))&amp;gt; == false`であること。
 
 ## 引数
 - `t` -- [`tuple-like`](tuple-like.md)な型`Tuple`のオブジェクト
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pair-like -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/pair-like.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/pair-like.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/pair-like.md b/reference/tuple/pair-like.md
index 7a15efbca..3cf2baf92 100644
--- a/reference/tuple/pair-like.md
+++ b/reference/tuple/pair-like.md
@@ -11,7 +11,7 @@ namespace std {
     template&amp;lt;class T&amp;gt;
     concept pair-like = // 説明専用コンセプト
       !is_reference_v&amp;lt;T&amp;gt; &amp;amp;&amp;amp; requires(T t) {
-        typename tuple_size&amp;lt;T&amp;gt;::type; // tuple_­size&amp;lt;T&amp;gt; が完全型であることを明確にする
+        typename tuple_size&amp;lt;T&amp;gt;::type; // tuple_size&amp;lt;T&amp;gt; が完全型であることを明確にする
         requires derived_from&amp;lt;tuple_size&amp;lt;T&amp;gt;, integral_constant&amp;lt;size_t, 2&amp;gt;&amp;gt;;
         typename tuple_element_t&amp;lt;0, remove_const_t&amp;lt;T&amp;gt;&amp;gt;;
         typename tuple_element_t&amp;lt;1, remove_const_t&amp;lt;T&amp;gt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_common_reference -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/basic_common_reference.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/tuple/basic_common_reference.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/basic_common_reference.md b/reference/tuple/tuple/basic_common_reference.md
index 637303d80..8d0fd167b 100644
--- a/reference/tuple/tuple/basic_common_reference.md
+++ b/reference/tuple/tuple/basic_common_reference.md
@@ -21,16 +21,16 @@ template&amp;lt;tuple-like TTuple, tuple-like UTuple,
 
 
 ## 効果
-[`tuple`](../tuple.md)`&amp;lt;`[`common_­reference_­t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;TTypes&amp;gt;, UQual&amp;lt;UTypes&amp;gt;&amp;gt;...&amp;gt;`によって得られた型をメンバ型`type`として定義する。
+[`tuple`](../tuple.md)`&amp;lt;`[`common_reference_t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;TTypes&amp;gt;, UQual&amp;lt;UTypes&amp;gt;&amp;gt;...&amp;gt;`によって得られた型をメンバ型`type`として定義する。
 
 
 ## 要件
 - `TTuple`か`UTuple`のどちらかが[`tuple`](../tuple.md)の特殊化であること。
-- `TTuple`と`UTuple`のそれぞれについて、（次の`T`を置き換える形で）[`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;T, `[`decay_­t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;&amp;gt;`であること。
+- `TTuple`と`UTuple`のそれぞれについて、（次の`T`を置き換える形で）[`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;T, `[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;&amp;gt;`であること。
     - 実質的には`TTuple`と`Utuple`について、参照型ではなく、最上位の`const`/`volatile`修飾も持っていないこと要求する。
 - `TTuple`と`UTuple`の要素数が一致していること。
-    - 具体的には、[`tuple_­size_­v`](../tuple_size.md)`&amp;lt;TTuple&amp;gt; ==` [`tuple_­size_­v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。
-- [`tuple`](../tuple.md)`&amp;lt;`[`common_­reference_­t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;TTypes&amp;gt;, UQual&amp;lt;UTypes&amp;gt;&amp;gt;...&amp;gt;`が正しく型を表すこと。
+    - 具体的には、[`tuple_size_v`](../tuple_size.md)`&amp;lt;TTuple&amp;gt; ==` [`tuple_size_v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。
+- [`tuple`](../tuple.md)`&amp;lt;`[`common_reference_t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;TTypes&amp;gt;, UQual&amp;lt;UTypes&amp;gt;&amp;gt;...&amp;gt;`が正しく型を表すこと。
 
 
 ## バージョン
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/common_type.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/tuple/common_type.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/common_type.md b/reference/tuple/tuple/common_type.md
index b8ffd1e73..f6d8d8902 100644
--- a/reference/tuple/tuple/common_type.md
+++ b/reference/tuple/tuple/common_type.md
@@ -18,16 +18,16 @@ namespace std {
 
 
 ## 効果
-[`tuple`](../tuple.md)`&amp;lt;`[`common_­type_­t`](/reference/type_traits/common_type.md)`&amp;lt;TTypes, UTypes&amp;gt;...&amp;gt;`によって得られた型をメンバ型`type`として定義する。
+[`tuple`](../tuple.md)`&amp;lt;`[`common_type_t`](/reference/type_traits/common_type.md)`&amp;lt;TTypes, UTypes&amp;gt;...&amp;gt;`によって得られた型をメンバ型`type`として定義する。
 
 
 ## 備考
 - `TTuple`か`UTuple`のどちらかが[`tuple`](../tuple.md)の特殊化であること。
-- `TTuple`と`UTuple`のそれぞれについて、（次の`T`を置き換える形で）[`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;T,` [`decay_­t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;&amp;gt;`であること。
+- `TTuple`と`UTuple`のそれぞれについて、（次の`T`を置き換える形で）[`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;T,` [`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;&amp;gt;`であること。
     - 実質的には`TTuple`と`Utuple`について、参照型ではなく、最上位の`const`/`volatile`修飾も持っていないこと要求する。
 - `TTuple`と`UTuple`の要素数が一致していること。
-    - 具体的には、[`tuple_­size_­v`](../tuple_size.md)`&amp;lt;TTuple&amp;gt; ==` [`tuple_­size_­v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。
-- [`tuple`](../tuple.md)`&amp;lt;`[`common_­type_­t`](/reference/type_traits/common_type.md)`&amp;lt;TTypes, UTypes&amp;gt;...&amp;gt;`が正しく型を表すこと。
+    - 具体的には、[`tuple_size_v`](../tuple_size.md)`&amp;lt;TTuple&amp;gt; ==` [`tuple_size_v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。
+- [`tuple`](../tuple.md)`&amp;lt;`[`common_type_t`](/reference/type_traits/common_type.md)`&amp;lt;TTypes, UTypes&amp;gt;...&amp;gt;`が正しく型を表すこと。
 
 
 ## バージョン
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_assign.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/tuple/op_assign.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_assign.md b/reference/tuple/tuple/op_assign.md
index 67c8ba00a..23b54f8aa 100644
--- a/reference/tuple/tuple/op_assign.md
+++ b/reference/tuple/tuple/op_assign.md
@@ -84,23 +84,23 @@ constexpr const tuple&amp;amp; operator=(UTuple&amp;amp;&amp;amp;) const;        // (14) C++23
 - (1) : 全ての`i`について、[`is_copy_assignable`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;Ti&amp;gt;::value == true`であること
 - (2) : C++23 : 全ての`i`について、[`is_copy_assignable_v`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;const Ti&amp;gt; == true`であること
 - (3) : 全ての`i`について、[`is_move_assignable`](/reference/type_traits/is_move_assignable.md)`&amp;lt;Ti&amp;gt;::value == true`であること
-- (4) : C++23 : 全ての`i`について、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, Ti&amp;gt; == true`であること
+- (4) : C++23 : 全ての`i`について、[`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, Ti&amp;gt; == true`であること
 - (5) : 要素数が同じかつ、パラメータの[`tuple`](../tuple.md)の全ての要素型が、元の[`tuple`](../tuple.md)の全ての要素型にコピー代入可能であること
-- (6) : C++23 : 要素数が同じかつ、全ての`i`について、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, const Ui&amp;amp;&amp;gt; == true`であること
+- (6) : C++23 : 要素数が同じかつ、全ての`i`について、[`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, const Ui&amp;amp;&amp;gt; == true`であること
 - (7) : 要素数が同じかつ、パラメータの[`tuple`](../tuple.md)の全ての要素型が、元の[`tuple`](../tuple.md)の全ての要素型にムーブ代入可能であること
-- (8) : C++23 : 要素数が同じかつ、全ての`i`について、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, Ui&amp;gt; = true`であること
+- (8) : C++23 : 要素数が同じかつ、全ての`i`について、[`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, Ui&amp;gt; = true`であること
 - (9) : 元の[`tuple`](../tuple.md)の要素数が2であり、パラメータの[`pair`](/reference/utility/pair.md)の全ての要素型が元の[`tuple`](../tuple.md)の全ての要素型にコピー代入可能であること
-- (10) : C++23 : 元の[`tuple`](../tuple.md)の要素数が2であり、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T0&amp;amp;, U1&amp;gt; &amp;amp;&amp;amp;` [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, U2&amp;gt;`であること
+- (10) : C++23 : 元の[`tuple`](../tuple.md)の要素数が2であり、[`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T0&amp;amp;, U1&amp;gt; &amp;amp;&amp;amp;` [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, U2&amp;gt;`であること
 - (11) : 元の[`tuple`](../tuple.md)の要素型が2であり、パラメータの[`pair`](/reference/utility/pair.md)の全ての要素型が元の[`tuple`](../tuple.md)の全ての要素型にムーブ代入可能であること
-- (12) : C++23 : 元の[`tuple`](../tuple.md)の要素数が2であり、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T0&amp;amp;, U1&amp;gt; &amp;amp;&amp;amp;` [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, U2&amp;gt;`であること
+- (12) : C++23 : 元の[`tuple`](../tuple.md)の要素数が2であり、[`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T0&amp;amp;, U1&amp;gt; &amp;amp;&amp;amp;` [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, U2&amp;gt;`であること
 - (13) : 要素数が同じかつ、次を全て満たすこと
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`
-    - C++23 : [`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
-    - C++23 : 全ての`i`について、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
+    - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
+    - C++23 : 全ての`i`について、[`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
 - (14) : 要素数が同じかつ、次をすべて満たすこと
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`
-    - C++23 : [`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
-    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
+    - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;=&gt; -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_compare_3way.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/tuple/op_compare_3way.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_compare_3way.md b/reference/tuple/tuple/op_compare_3way.md
index 91e768b7e..1a6c4b76a 100644
--- a/reference/tuple/tuple/op_compare_3way.md
+++ b/reference/tuple/tuple/op_compare_3way.md
@@ -15,8 +15,8 @@ namespace std {
     operator&amp;lt;=&amp;gt;(const tuple&amp;lt;TTypes...&amp;gt;&amp;amp; t, const UTuple&amp;amp; u);           // (2) C++23
   
   // (2) の Elems は 型パラメータパック 
-  //   tuple_­element_­t&amp;lt;0, UTuple&amp;gt;, tuple_­element_­t&amp;lt;1, UTuple&amp;gt;, ...,
-  //   tuple_­element_­t&amp;lt;tuple_­size_­v&amp;lt;UTuple&amp;gt; - 1, UTuple&amp;gt;
+  //   tuple_element_t&amp;lt;0, UTuple&amp;gt;, tuple_element_t&amp;lt;1, UTuple&amp;gt;, ...,
+  //   tuple_element_t&amp;lt;tuple_size_v&amp;lt;UTuple&amp;gt; - 1, UTuple&amp;gt;
   // を表す。
 }
 ```
@@ -24,8 +24,8 @@ namespace std {
 * common_comparison_category_t[link /reference/compare/common_comparison_category.md]
 * synth-three-way-result[link /reference/exposition-only/synth-three-way-result.md]
 * tuple-like[link ../tuple-like.md]
-* tuple_­element_­t[link ../tuple_element.md]
-* tuple_­size_­v[link ../tuple_size.md]
+* tuple_element_t[link ../tuple_element.md]
+* tuple_size_v[link ../tuple_size.md]
 
 ## 概要
 2つの[`tuple`](../tuple.md)オブジェクトの三方比較を行う。また、[`tuple-like`](../tuple-like.md)なオブジェクトとの三方比較を行う。（C++23以降）
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_constructor.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/tuple/op_constructor.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_constructor.md b/reference/tuple/tuple/op_constructor.md
index 69b191ee4..2bf4e9eeb 100644
--- a/reference/tuple/tuple/op_constructor.md
+++ b/reference/tuple/tuple/op_constructor.md
@@ -260,18 +260,18 @@ explicit(see below) constexpr
     - C++20まで : `Types...`の全ての型`Ti`と、`UTypes...`の全ての型`Ui`について、[`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value == true`であること
     - C++17 : `sizeof...(Types) &amp;gt;= 1`であること
     - C++23 : `disambiguating-constraint`を次のように定義して、
-        - `sizeof...(Types) == 1`の時、[`negation`](/reference/type_traits/negation.md)`&amp;lt;`[`is_­same`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;U0&amp;gt;,` [`tuple`](../tuple.md)`&amp;gt;&amp;gt;`
-        - `sizeof...(Types) == 2 || sizeof...(Types) == 3`の時、[`bool_­constant`](/reference/type_traits/bool_constant.md)`&amp;lt;!`[`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;U0&amp;gt;,` [`allocator_­arg_­t`](/reference/memory/allocator_arg_t.md)`&amp;gt; ||` [`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;T0&amp;gt;,` [`allocator_­arg_­t`](/reference/memory/allocator_arg_t.md)`&amp;gt;&amp;gt;`
+        - `sizeof...(Types) == 1`の時、[`negation`](/reference/type_traits/negation.md)`&amp;lt;`[`is_same`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;U0&amp;gt;,` [`tuple`](../tuple.md)`&amp;gt;&amp;gt;`
+        - `sizeof...(Types) == 2 || sizeof...(Types) == 3`の時、[`bool_constant`](/reference/type_traits/bool_constant.md)`&amp;lt;!`[`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;U0&amp;gt;,` [`allocator_arg_t`](/reference/memory/allocator_arg_t.md)`&amp;gt; ||` [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;T0&amp;gt;,` [`allocator_arg_t`](/reference/memory/allocator_arg_t.md)`&amp;gt;&amp;gt;`
         - 以上に該当しなければ、[`true_type`](/reference/type_traits/true_type.md)
-    - C++23 : [`conjunction_­v`](/reference/type_traits/conjunction.md)`&amp;lt;disambiguating-constraint,` [`is_­constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, UTypes&amp;gt;...&amp;gt;`であること
+    - C++23 : [`conjunction_v`](/reference/type_traits/conjunction.md)`&amp;lt;disambiguating-constraint,` [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, UTypes&amp;gt;...&amp;gt;`であること
 - (4), (18) :
     - `Types...`の全ての型`Ti`について、[`is_copy_constructible`](/reference/type_traits/is_copy_constructible.md)`&amp;lt;Ti&amp;gt;::value == true`であること
 - (5), (19) :
     - `Types...`の全ての型`Ti`について、[`is_move_constructible`](/reference/type_traits/is_move_constructible.md)`&amp;lt;Ti&amp;gt;::value == true`であること
 - (6)-(9), (20)-(23) :
-    - `I`をパラメータパック`0, 1, ..., (sizeof...(Types) - 1)`、`FWD(u)`を`static_­cast&amp;lt;decltype(u)&amp;gt;(u)`、`sizeof...(Types) == 1`の場合は、`Types...`を`T`へ、`UTypes...`を`U`へ展開したと定義して
-    - C++23 : `sizeof...(Types) == sizeof...(UTypes) &amp;amp;&amp;amp; (`[`is_­constructible_­v`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, decltype(`[`get`](/reference/tuple/tuple/get.md)`&amp;lt;I&amp;gt;(FWD(u)))&amp;gt; &amp;amp;&amp;amp; ...) == true`であること
-    - C++23 : 更に、`sizeof...(Types) != 1`または、[`is_­convertible_v­`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(u), T&amp;gt; == false &amp;amp;&amp;amp;` [`is_­constructible_­v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, decltype(u)&amp;gt; == false &amp;amp;&amp;amp;` [`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;T, U&amp;gt; == false`であること
+    - `I`をパラメータパック`0, 1, ..., (sizeof...(Types) - 1)`、`FWD(u)`を`static_cast&amp;lt;decltype(u)&amp;gt;(u)`、`sizeof...(Types) == 1`の場合は、`Types...`を`T`へ、`UTypes...`を`U`へ展開したと定義して
+    - C++23 : `sizeof...(Types) == sizeof...(UTypes) &amp;amp;&amp;amp; (`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, decltype(`[`get`](/reference/tuple/tuple/get.md)`&amp;lt;I&amp;gt;(FWD(u)))&amp;gt; &amp;amp;&amp;amp; ...) == true`であること
+    - C++23 : 更に、`sizeof...(Types) != 1`または、[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(u), T&amp;gt; == false &amp;amp;&amp;amp;` [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, decltype(u)&amp;gt; == false &amp;amp;&amp;amp;` [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;T, U&amp;gt; == false`であること
 - (7), (21) :
     - `sizeof...(Types) == sizeof...(UTypes)`であること
     - `Types...`の全ての型`Ti`と、`UTypes...`の全ての型`Ui`について、[`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Ti, const Ui&amp;amp;&amp;gt;::value == true`であること
@@ -285,7 +285,7 @@ explicit(see below) constexpr
         - ムーブコンストラクタとのオーバーロードが成立することを意図している
     - C++23 : (6)-(9), (20)-(23) の定義参照
 - (10)-(13), (24)-(27) :
-    - `FWD(u)`を`static_­cast&amp;lt;decltype(u)&amp;gt;(u)`、`Types...`の0番目の型を`T0`、1番目の型を`T1`であるとして、
+    - `FWD(u)`を`static_cast&amp;lt;decltype(u)&amp;gt;(u)`、`Types...`の0番目の型を`T0`、1番目の型を`T1`であるとして、
     - C++23 : `sizeof...(Types) == 2`であること
     - C++23 : [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T0, decltype(get&amp;lt;0&amp;gt;(FWD(u))) == true`であること
     - C++23 : [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T1, decltype(get&amp;lt;1&amp;gt;(FWD(u))) == true`であること
@@ -304,8 +304,8 @@ explicit(see below) constexpr
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`であること
     - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
     - C++23 : `sizeof...(Types) ==` [`tuple_size_v`](../tuple_size.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;&amp;gt;`であること
-    - C++23 : `(`[`is_­constructible_­v`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, decltype(get&amp;lt;I&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt; &amp;amp;&amp;amp; ...) == true`であること
-    - C++23 : `sizeof...(Types) != 1`であるか、または`Types...`を`T`に展開したとして[`is_­convertible_­v`](/reference/type_traits/is_convertible.md)`&amp;lt;UTuple, T&amp;gt; == false &amp;amp;&amp;amp;` [`is_­constructible_­v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, UTuple&amp;gt; == false`であること
+    - C++23 : `(`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, decltype(get&amp;lt;I&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt; &amp;amp;&amp;amp; ...) == true`であること
+    - C++23 : `sizeof...(Types) != 1`であるか、または`Types...`を`T`に展開したとして[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;UTuple, T&amp;gt; == false &amp;amp;&amp;amp;` [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, UTuple&amp;gt; == false`であること
 
 
 ## 備考
@@ -319,7 +319,7 @@ explicit(see below) constexpr
     - C++17から : `!`[`conjunction_v`](/reference/type_traits/conjunction.md)`&amp;lt;`[`is_convertible`](/reference/type_traits/is_convertible.md)`&amp;lt;UTypes, Types&amp;gt;...&amp;gt;`である場合、この関数は`explicit`となる
     - C++23から : `(`[`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;Types, UTypes&amp;amp;&amp;amp;&amp;gt; || ...)`である場合、この関数は削除定義される
 - (6)-(9) :
-    - `I`をパラメータパック`0, 1, ..., (sizeof...(Types) - 1)`、`FWD(u)`を`static_­cast&amp;lt;decltype(u)&amp;gt;(u)`と定義して、
+    - `I`をパラメータパック`0, 1, ..., (sizeof...(Types) - 1)`、`FWD(u)`を`static_cast&amp;lt;decltype(u)&amp;gt;(u)`と定義して、
     - C++23 : `!(`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](../tuple/get.md)`&amp;lt;I&amp;gt;(FWD(u))), Types&amp;gt; &amp;amp;&amp;amp; ...)`である場合、この関数は`explicit`となる
     - C++23 : `(`[`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;Types, decltype(`[`get`](../tuple/get.md)`&amp;lt;I&amp;gt;(FWD(u)))&amp;gt; || ...)`である場合、この関数は削除定義される
 - (7) :
@@ -329,7 +329,7 @@ explicit(see below) constexpr
     - C++17 : `!`[`conjunction_v`](/reference/type_traits/conjunction.md)`&amp;lt;`[`is_convertible`](/reference/type_traits/is_convertible.md)`&amp;lt;UTypes&amp;amp;&amp;amp;, Types&amp;gt;...&amp;gt;`である場合、この関数は`explicit`となる
     - C++23 : (6)-(9) の定義参照
 - (10)-(13) :
-    - `FWD(u)`を`static_­cast&amp;lt;decltype(u)&amp;gt;(u)`、`Types...`の0番目の型を`T0`、1番目の型を`T1`であるとして、
+    - `FWD(u)`を`static_cast&amp;lt;decltype(u)&amp;gt;(u)`、`Types...`の0番目の型を`T0`、1番目の型を`T1`であるとして、
     - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(u))), T0&amp;gt; ||!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(u))), T1&amp;gt;`である場合、この関数は`explicit`となる
     - C++23 : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T0, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(u)))&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T1, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(u)))&amp;gt;`である場合、この関数は削除定義される
 - (11) :
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_equal.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/tuple/op_equal.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_equal.md b/reference/tuple/tuple/op_equal.md
index b0cb55f2f..567726a2b 100644
--- a/reference/tuple/tuple/op_equal.md
+++ b/reference/tuple/tuple/op_equal.md
@@ -31,7 +31,7 @@ namespace std {
     - 2つの[`tuple`](../tuple.md)オブジェクトの要素数が同じであること。（具体的には`sizeof...(TTypes) == sizeof...(UTypes)`であること。）
     - [`tuple`](../tuple.md)の要素`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t)`と`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)`において、すべての要素の比較 `std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t) == std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)` の比較結果が`bool`に変換可能な型（C++23 以降は[`boolean-testable`](/reference/concepts/boolean-testable.md)を満たせばよい）であること。
 - (2) :
-    - C++23 : 2つの[`tuple-like`](../tuple-like.md)なオブジェクトの要素数が同じであること。（正確には、`sizeof...(TTypes) ==` [`tuple_­size_­v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。）
+    - C++23 : 2つの[`tuple-like`](../tuple-like.md)なオブジェクトの要素数が同じであること。（正確には、`sizeof...(TTypes) ==` [`tuple_size_v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。）
     - C++23 : [`tuple`](../tuple.md)の要素`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t)`と[`tuple-like`](../tuple-like.md)なオブジェクトの要素`std::get&amp;lt;i&amp;gt;(u)`において、すべての要素の比較 `std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t) == std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)` の比較結果が[`boolean-testable`](/reference/concepts/boolean-testable.md)を満たす型（`bool`へ変換可能な型）であること。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_cat -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_cat.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/tuple/tuple_cat.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_cat.md b/reference/tuple/tuple_cat.md
index 1f7f18b28..5827bea6e 100644
--- a/reference/tuple/tuple_cat.md
+++ b/reference/tuple/tuple_cat.md
@@ -29,7 +29,7 @@ namespace std {
     - `Args...`の各型が左辺値参照であればコピー構築可能、そうでなければムーブ構築可能であること。
 - C++23から :
     - 本関数の返り値の[`tuple`](tuple.md)のテンプレートパラメーターパックを`Ctypes`とし、`Ctypes`の全ての要素について、引数`tpls`において対応する要素の型から構築可能であること。
-    - より厳密には、次のように定義を行い、`(`[`is_­constructible_v­`](/reference/type_traits/is_constructible.md)`&amp;lt;CTypes, decltype(celems)&amp;gt; &amp;amp;&amp;amp; ...) == true`であること。
+    - より厳密には、次のように定義を行い、`(`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;CTypes, decltype(celems)&amp;gt; &amp;amp;&amp;amp; ...) == true`であること。
         - `n`を`sizeof...(Tuples)`とし、`i`を範囲`[0, n)`における整数値とする
         - `T(i)`を`Tuples`の`i`番目とする
         - `U(i)`を[`remove_cvref_t&amp;lt;T(i)&amp;gt;`](/reference/type_traits/remove_cvref.md) とする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_invocable_r -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_invocable_r.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/type_traits/is_invocable_r.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_invocable_r.md b/reference/type_traits/is_invocable_r.md
index a5b907ce7..f32c28aba 100644
--- a/reference/type_traits/is_invocable_r.md
+++ b/reference/type_traits/is_invocable_r.md
@@ -35,11 +35,11 @@ std::is_convertible_v&amp;lt;std::invoke_result_t&amp;lt;F, ArgsTypes...&amp;gt;, R&amp;gt;
 
 // C++23
 std::is_convertible_v&amp;lt;std::invoke_result_t&amp;lt;F, ArgsTypes...&amp;gt;, R&amp;gt; &amp;amp;&amp;amp; 
-std::reference_­converts_­from_­temporary_­v&amp;lt;R, std::invoke_result_t&amp;lt;F, ArgsTypes...&amp;gt;&amp;gt; == false
+std::reference_converts_from_temporary_v&amp;lt;R, std::invoke_result_t&amp;lt;F, ArgsTypes...&amp;gt;&amp;gt; == false
 ```
 * std::is_convertible_v[link is_convertible.md]
 * std::invoke_result_t[link invoke_result.md]
-* std::reference_­converts_­from_­temporary_­v[link /reference/type_traits/reference_converts_from_temporary.md]
+* std::reference_converts_from_temporary_v[link /reference/type_traits/reference_converts_from_temporary.md]
 
 
 ## 寿命の延長とダングリング参照
@@ -49,7 +49,7 @@ std::reference_­converts_­from_­temporary_­v&amp;lt;R, std::invoke_result_t&amp;lt;F, Args
 
 `R`が`const T&amp;amp;`または`T&amp;amp;&amp;amp;`で、かつ`S`が`rvalue`であれば、`S`を`R`へ暗黙変換する際に`S`の寿命は`R`の寿命に合わせて延長されることがある。しかしこの場合、`R`は[*INVOKE*](/reference/concepts/Invoke.md)が行われる文を寿命とするので、`S`も同様に[*INVOKE*](/reference/concepts/Invoke.md)が行われる文が終了すると同時に寿命が終了する。参照による寿命の延長は2度適用されることはないため、このような場合には常にダングリング参照が生じてしまう。
 
-これを検出し、不適格とするために[`reference_­converts_­from_­temporary_­v`](/reference/type_traits/reference_converts_from_temporary.md)を使用しているというわけなのである。
+これを検出し、不適格とするために[`reference_converts_from_temporary_v`](/reference/type_traits/reference_converts_from_temporary.md)を使用しているというわけなのである。
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_assign.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/utility/pair/op_assign.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_assign.md b/reference/utility/pair/op_assign.md
index b7ec890c1..9c1e43341 100644
--- a/reference/utility/pair/op_assign.md
+++ b/reference/utility/pair/op_assign.md
@@ -66,13 +66,13 @@ template&amp;lt;pair-like P&amp;gt;
 - (9) : 次を全て満たすこと
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;P, pair&amp;gt;`
     - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;P&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
-    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
-    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
 - (10) : 次を全て満たすこと
     - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;P, pair&amp;gt;`
     - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;P&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
-    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
-    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- ソフトハイフン除去</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_constructor.html"/>
      <id>8cc4361ae1ba943d065a624d866ae3f526a48894:reference/utility/pair/op_constructor.md</id>
      <updated>2023-02-01T09:56:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_constructor.md b/reference/utility/pair/op_constructor.md
index ad0ad1de4..84bb25ebc 100644
--- a/reference/utility/pair/op_constructor.md
+++ b/reference/utility/pair/op_constructor.md
@@ -116,11 +116,11 @@ constexpr pair(piecewise_construct_t,
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const first_type&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const second_type&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
 - (5) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
-    - C++23 : [`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_­type, U1&amp;amp;&amp;amp;&amp;gt; ||` [`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_­type, U2&amp;amp;&amp;amp;&amp;gt;`である場合、このコンストラクタは削除定義される
+    - C++23 : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;`である場合、このコンストラクタは削除定義される
 - (6)-(10) :
     - `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して
     - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p))), T1&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p))), T2&amp;gt;`である場合、`explicit`指定される
-    - C++23 : [`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_­type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p)))&amp;gt; ||` [`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_­type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p)))&amp;gt;`である場合、このコンストラクタは削除定義される
+    - C++23 : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p)))&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p)))&amp;gt;`である場合、このコンストラクタは削除定義される
 - (7) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U1&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U2&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
     - C++23 : (6)-(10) での定義参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_common_reference -- リンク修正など - リンク修正 - ハイライト修正 - 何故か消してしまったものを復帰</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/basic_common_reference.html"/>
      <id>d9d912ab5e77403cbdf5d93d51b2b66e887d4b8f:reference/utility/pair/basic_common_reference.md</id>
      <updated>2023-02-01T09:17:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/basic_common_reference.md b/reference/utility/pair/basic_common_reference.md
index 068a924d8..47a9a594a 100644
--- a/reference/utility/pair/basic_common_reference.md
+++ b/reference/utility/pair/basic_common_reference.md
@@ -15,6 +15,8 @@ namespace std {
 }
 ```
 * basic_common_reference[link /reference/type_traits/basic_common_reference.md]
+* pair[link ../pair.md]
+* common_reference_t[link /reference/type_traits/common_reference.md]
 
 ## 概要
 [`pair`](../pair.md)について、[`common_reference`](/reference/type_traits/common_reference.md)で共通の参照型を取得できるようにアダプトする[`basic_common_reference`](/reference/type_traits/common_reference.md)の特殊化である。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- リンク修正など - リンク修正 - ハイライト修正 - 何故か消してしまったものを復帰</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/common_type.html"/>
      <id>d9d912ab5e77403cbdf5d93d51b2b66e887d4b8f:reference/utility/pair/common_type.md</id>
      <updated>2023-02-01T09:17:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/common_type.md b/reference/utility/pair/common_type.md
index eb8656a05..d71b1ec73 100644
--- a/reference/utility/pair/common_type.md
+++ b/reference/utility/pair/common_type.md
@@ -14,7 +14,9 @@ namespace std {
 }
 ```
 * common_type[link /reference/type_traits/common_type.md]
-* tuple-like[link ../tuple-like.md]
+* pair[link ../pair.md]
+* common_type_t[link /reference/type_traits/common_type.md]
+* tuple-like[link /reference/tuple/tuple-like.md]
 
 ## 概要
 [`pair`](../pair.md)について、どちらからも変換可能な共通の型を取得できるようにする[`common_type`](/reference/type_traits/common_type.md)の特殊化である。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>vector -- リンク修正など - リンク修正 - ハイライト修正 - 何故か消してしまったものを復帰</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector.html"/>
      <id>d9d912ab5e77403cbdf5d93d51b2b66e887d4b8f:reference/vector/vector.md</id>
      <updated>2023-02-01T09:17:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector.md b/reference/vector/vector.md
index 058a58211..725ca5847 100644
--- a/reference/vector/vector.md
+++ b/reference/vector/vector.md
@@ -442,4 +442,5 @@ int main()
 - 可変長のビット配列の実装としては、Boost C++ Librariesの[`dynamic_bitset`](http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html)がある。
 - [N2669 Thread-Safety in the Standard Library (Rev 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2669.htm)
 - [N4510 Minimal incomplete type support for standard containers, revision 4](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html)
-
+- [P2286R8 Formatting Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html)
+    - C++23から、Range・コンテナ、`pair`、`tuple`のフォーマット出力、および文字・文字列のデバッグ指定 (`&amp;#34;?&amp;#34;`) が追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ポインタから`bool`への変換を縮小変換とする -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.md b/lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.md
index d4d04cede..2df22bf8c 100644
--- a/lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.md
+++ b/lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.md
@@ -40,7 +40,7 @@ std::variant&amp;lt;bool, int&amp;gt; v = b[1]; // intを保持して構築されてしまう
 * bitset[link /reference/bitset/bitset.md]
 * variant[link /reference/variant/variant.md]
 
-`std::bitset`の非`const`な[`operator[]`](/reference/bitset/bitset/op_at.md)は`bool`型へ暗黙変換可能なプロクシオブジェクトを返す。
+`std::bitset`の非`const`な[`operator[]`](/reference/bitset/bitset/op_at.md)は`bool`型へ暗黙変換可能なプロキシオブジェクトを返す。
 
 `std::variant`の構築・代入時に縮小変換が起こることを検出して防止することはライブラリレベルで可能だったが、ポインタ型から`bool`への変換を縮小変換として扱うということはライブラリレベルでは実装できなかったため`bool`への変換全体を禁止せざるを得ず、このような問題が発生していた。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++23 -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/lang/cpp23.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:lang/cpp23.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++23&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++23とは、2023年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中のためC++2bと呼ばれることがある。「(C++20である2020年の次の) 202b年にリリースされる」という伏せ字として「b」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/literal_suffix_for_signed_size_t.html&#34;&gt;(符号付き)&lt;code&gt;size_t&lt;/code&gt;リテラルのためのサフィックス&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;42z&lt;/code&gt;/&lt;code&gt;42Z&lt;/code&gt;とすることで&lt;code&gt;size_t&lt;/code&gt;に対応する符号付き整数型のリテラルとする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/delimited_escape_sequences.md.nolink&#34;&gt;エスケープシーケンスの区切り&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エスケープシーケンスの範囲を明確にする構文を追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.md.nolink&#34;&gt;暗黙的なムーブを簡略化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;参照を返す関数の&lt;code&gt;return&lt;/code&gt;文で暗黙的にムーブされない問題を修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/extended_floating_point_types_and_standard_names.md.nolink&#34;&gt;浮動小数点数型の拡張&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;実装による拡張浮動小数点型の定義を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/declarations_and_where_to_find_them.md.nolink&#34;&gt;スコープと名前ルックアップの仕様整理&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;複雑で不完全になっているスコープと名前ルックアップの仕様を整理し、一部の問題を解決する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/meaningful_exports.md.nolink&#34;&gt;無意味なexport宣言を禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;制御構文&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/extend_init_statement_to_allow_alias_declaration.md.nolink&#34;&gt;初期化文での型の別名宣言を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;for (using T = int; T e : v) {}&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/lifetime_extension_in_range_based_for_loop.md.nolink&#34;&gt;範囲for文が範囲への参照を延命することを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/labels_at_the_end_of_compound_statements.md.nolink&#34;&gt;関数末尾のラベルを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C互換のため、関数末尾でのgoto文のラベルを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/deducing_this.md.nolink&#34;&gt;自身のオブジェクトを明示的にパラメータとして指定する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ関数が&lt;code&gt;*this&lt;/code&gt;の型・オブジェクトをパラメータとしてとり、&lt;code&gt;*this&lt;/code&gt;オブジェクトがconst/非const、左辺値/右辺値であるかをメンバ関数内で識別できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/make_declaration_order_layout_mandated.md.nolink&#34;&gt;アクセス制御の異なるメンバ変数のレイアウトを宣言順に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;アクセス制御の異なるメンバ変数のレイアウトが実装によって異なっていたため仕様を規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/multidimensional_subscript_operator.nd.nolink&#34;&gt;添字演算子の多次元サポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator[](int x, int y, int z)&lt;/code&gt;のように添字演算子のオーバーロードで複数のパラメータをとることを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/static_operator.md.nolink&#34;&gt;&lt;code&gt;this&lt;/code&gt;ポインタをもつ必要のない演算子を&lt;code&gt;static&lt;/code&gt;として宣言できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/mixed_string_literal_concatenation.md.nolink&#34;&gt;異なる文字エンコーディングをもつ文字列リテラルの連結を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto a = u8&#34;&#34; L&#34;&#34;;&lt;/code&gt;のような異なる文字エンコーディング同士での文字列リテラルを連結を禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/numeric_and_universal_character_escapes_in_character_and_string_literals.md.nolink&#34;&gt;文字・文字列リテラル中の数値・ユニバーサルキャラクタのエスケープに関する問題解決&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/remove_non_encodable_wide_character_literals_and_multicharacter_wide_character_literals.md.nolink&#34;&gt;1ワイド文字に収まらないワイド文字リテラルを禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エンコード結果として&lt;code&gt;wchar_t&lt;/code&gt;の大きさに収まらないワイド文字リテラルを禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/named_universal_character_escapes.md.nolink&#34;&gt;名前付きユニバーサルキャラクタ名&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;16進数のユニバーサルキャラクタだけでなく、その文字の名前を入力できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/generalized_wording_for_partial_specializations.md.nolink&#34;&gt;部分特殊化の汎用化仕様&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数テンプレートの部分特殊化を許可するために部分特殊化の仕様を汎用化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/class_template_argument_deduction_from_inherited.md.nolink&#34;&gt;継承コンストラクタからのクラステンプレート引数の推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/if_consteval.md.nolink&#34;&gt;if consteval&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時の文脈かどうかで分岐させる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/narrowing_contextual_conversions_to_bool.md.nolink&#34;&gt;定数式の文脈での&lt;code&gt;bool&lt;/code&gt;への縮小変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if constexpr(flags &amp;amp; Flags::Exec)&lt;/code&gt;や&lt;code&gt;static_assert(N);&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/non_literal_variables_in_constexpr_functions.md.nolink&#34;&gt;定数式内での非リテラル変数の使用を含められないようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式内で静的変数・スレッドローカル変数およびgoto文とラベルを含められない制限を設ける&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/character_encoding_of_diagnostic_text.md.nolink&#34;&gt;静的な診断メッセージの文字エンコーディング&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static_assert&lt;/code&gt;や&lt;code&gt;[[deprecated]]&lt;/code&gt;などの診断メッセージの文字集合に関する要件をなくす&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/relaxing_some_constexpr_restrictions.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;関数のすべての引数が定数実行できない場合でも適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/permitting_static_constexpr_variables_in_constexpr_functions.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;関数内での&lt;code&gt;static constexpr&lt;/code&gt;変数を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/consteval_needs_to_propagate_up.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;関数内で&lt;code&gt;consteval&lt;/code&gt;関数を呼び出せない問題を緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ラムダ式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/down_with_lambda_parens.md.nolink&#34;&gt;ラムダ式で&lt;code&gt;()&lt;/code&gt;を省略できる条件を緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャや修飾をともなってもパラメータリストが空であれば&lt;code&gt;()&lt;/code&gt;を省略できる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/attributes_on_lambda_expressions.md.nolink&#34;&gt;ラムダ式に対する属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式のいくつかの箇所に属性を記述できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;属性&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/portable_assumptions.html&#34;&gt;コード内容の仮定をコンパイラに伝えるassume属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;最適化のために、コードの仮定をコンパイラに伝える属性を標準化する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;プリプロセッサ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/consistent_character_literal_encoding.md.nolink&#34;&gt;文字リテラルエンコーディングを一貫させる&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサの条件式での文字リテラルの扱いをC++式と同様にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/add_support_for_preprocessing_directives_elifdef_and_elifndef.md.nolink&#34;&gt;&lt;code&gt;elif&lt;/code&gt;/&lt;code&gt;elifdef&lt;/code&gt;/&lt;code&gt;elifndef&lt;/code&gt;のサポートを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;#if&lt;/code&gt;/&lt;code&gt;#ifdef&lt;/code&gt;/&lt;code&gt;#ifndef&lt;/code&gt;に対応する複数条件命令のサポートを追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/warning.md.nolink&#34;&gt;&lt;code&gt;#warning&lt;/code&gt;のサポートを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;多くのC++コンパイラが実装していたプリプロセス時の警告&lt;code&gt;#warning message&lt;/code&gt;を正式サポート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/support_for_utf8_as_a_portable_source_file_encoding.md.nolink&#34;&gt;汎用的なソースコードのエンコーディングとしてUTF-8をサポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/update_normative_reference_to_posix.html&#34;&gt;参照するPOSIX規格を更新&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;新しいPOSIX規格の機能を標準C++が参照していたため、参照するPOSIX規格のバージョンを更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/trimming_whitespaces_before_line_splicing.md.nolink&#34;&gt;行末スペースを無視するよう規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;行末が&lt;code&gt;\&lt;/code&gt;でおわっていた場合にMSVCは行の継続をしない実装になっていたため動作を共通化するため仕様を規定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++標準ライブラリ全体のモジュールとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/module/std.html&#34;&gt;std&lt;/a&gt;&lt;/code&gt;、C互換ライブラリ全体のモジュールとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/module/std.compat.html&#34;&gt;std.compat&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スタックトレースを取得するためのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stacktrace.html&#34;&gt;&amp;lt;stacktrace&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;CとC++の間でのアトミック操作の相互運用のため、C互換ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdatomic.h.html&#34;&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;外部から提供されるメモリバッファでストリーム処理を行うライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/spanstream.md.nolink&#34;&gt;&amp;lt;spanstream&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;正常値とエラー値のどちらかを持つクラスおよびライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/expected.html&#34;&gt;&amp;lt;expected&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;多次元配列ビューのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan.md.nolink&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ノードベースではないソート済みキーによる順序付き連想コンテナのライブラリとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/flat_map.md.nolink&#34;&gt;&amp;lt;flat_map&amp;gt;&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/flat_set.md.nolink&#34;&gt;&amp;lt;flat_set&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;書式指定で出力するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/print.html&#34;&gt;&amp;lt;print&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;コルーチンによるRangeの生成をサポートする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/generator.html&#34;&gt;&amp;lt;generator&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stack/stack.html&#34;&gt;std::stack&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/queue/queue.html&#34;&gt;std::queue&lt;/a&gt;&lt;/code&gt;に、イテレータのペアをとるコンストラクタを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto v = std::vector(v, alloc);&lt;/code&gt;のようなアロケータ引数をともなう場合のクラステンプレートのテンプレート引数推論が動作しなかったため、各コンテナクラスのコンストラクタにおけるアロケータパラメータの型を&lt;code&gt;const Allocator&amp;amp;&lt;/code&gt;から&lt;code&gt;const &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/type_identity.html&#34;&gt;std::type_identity_t&lt;/a&gt;&amp;lt;Allocator&amp;gt;&amp;amp;&lt;/code&gt;に修正&lt;/li&gt;
&lt;li&gt;N要素のメモリアロケート時にアロケータが実際にどれくらいのメモリを確保したかを得られるインタフェースとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;クラスに、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/allocate_at_least.md.nolink&#34;&gt;allocate_at_least()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;の転送コンストラクタにデフォルトテンプレート引数を追加することで、&lt;code&gt;{}&lt;/code&gt;のような型推論ができない引数を渡した場合でも完全転送が行われるよう修正&lt;/li&gt;
&lt;li&gt;順序付き連想コンテナの要素削除の処理について、一時オブジェクトのコストを抑える拡張が行われた&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/erase.html&#34;&gt;std::map::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/extract.html&#34;&gt;std::map::extract()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、複数の範囲を綴じ合わせる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/zip_view.md.nolink&#34;&gt;std::views::zip&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、複数の範囲の直積をとる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/cartesian_product_view.md.nolink&#34;&gt;std::views::cartesian_product&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;Rangeから任意のコンテナに変換するRangeアダプタ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/to.md.nolink&#34;&gt;std::ranges::to()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;Rangeから任意のコンテナに変換するために、可変長のコンテナ (&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;以外) に、以下の機能を追加：&lt;ul&gt;
&lt;li&gt;Rangeから変換するコンストラクタ&lt;/li&gt;
&lt;li&gt;Rangeを挿入する&lt;code&gt;insert_range()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;Rangeを先頭に追加する&lt;code&gt;prepend_range()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;Rangeを末尾に追加する&lt;code&gt;append_range()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;Rangeを代入する&lt;code&gt;assign_range()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ユーザー定義のRangeアダプタがパイプライン演算子 &lt;code&gt;|&lt;/code&gt; をサポートしやすくするために、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/range_adaptor_closure.md.nolink&#34;&gt;std::range::range_adaptor_closure&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Rangeを連結させる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/join_with.md.nolink&#34;&gt;join_with&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;Rangeを指定の大きさで分割する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/chunk_view.md.nolink&#34;&gt;std::views::chunk&lt;/a&gt;&lt;/code&gt;と、Rangeを指定の大きさの隣接要素で分割する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/slide_view.md.nolink&#34;&gt;std::views::slide&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;Rangeを条件一致する間の要素で分割する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/chunk_by_view.md.nolink&#34;&gt;std::views::chunk_by&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Rangeを等間隔からなるRangeに変換する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/stride_view.md.nolink&#34;&gt;std::views::stride&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Rangeをムーブするための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/as_rvalue.md.nolink&#34;&gt;std::views::as_rvalue&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、指定した値をN回繰り返すRangeを生成する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/repeat.md.nolink&#34;&gt;std::views::repeat&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、範囲の先頭が指定した範囲と合致するかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/starts_with.md.nolink&#34;&gt;std::starts_with()&lt;/a&gt;&lt;/code&gt;、範囲の末尾が指定した範囲と合致するかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ends_with.md.nolink&#34;&gt;std::ends_with()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素を左シフトさせるRangeアルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_shift_left.html&#34;&gt;std::ranges::shift_left()&lt;/a&gt;&lt;/code&gt;、要素を右シフトさせるRangeアルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_shift_right.html&#34;&gt;std::ranges::shift_right()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、範囲の末尾から要素を検索する以下のアルゴリズムを追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_find_last.md.nolink&#34;&gt;std::ranges::find_last()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/find_last_if.md.nolink&#34;&gt;std::ranges::find_last_if()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/find_last_if_not.md.nolink&#34;&gt;std::ranges::find_last_if_not()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、範囲に特定の値が含まれているかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_contains.md.nolink&#34;&gt;std::ranges::contains()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_contains_subrange.md.nolink&#34;&gt;std::ranges::contains_subrange&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、数値に限定しない汎用的な畳み込みアルゴリズムとして、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.md.nolink&#34;&gt;std::ranges::fold_left()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_first.md.nolink&#34;&gt;std::ranges::fold_left_first()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.md.nolink&#34;&gt;std::ranges::fold_right()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_right_last.md.nolink&#34;&gt;std::ranges::fold_right_last()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_with_iter.md.nolink&#34;&gt;std::ranges::fold_left_with_iter()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_first_with_iter.md.nolink&#34;&gt;std::ranges::fold_left_first_with_iter()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に、連番を生成するRangeアルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/ranges_iota.html&#34;&gt;std::ranges::iota()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;クラスに、文字列内に指定した文字・文字列が含まれているかを判定するメンバ関数&lt;code&gt;contains()&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;のコンストラクタに、範囲をとるオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::string s = nullptr;&lt;/code&gt;のような文字列オブジェクトに&lt;code&gt;nullptr&lt;/code&gt;を代入するようなコードはバグの元であるため、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/nullptr_t.html&#34;&gt;nullptr_t&lt;/a&gt;&lt;/code&gt;をとるコンストラクタをdelete定義として追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスに、resize時に任意の初期化を行う&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/resize_and_overwrite.md.nolink&#34;&gt;resize_and_overwrite()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスのコンストラクタと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/substr.html&#34;&gt;substr()&lt;/a&gt;&lt;/code&gt;メンバ関数に一時オブジェクトのオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;関数でRange・コンテナ、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;を出力できるよう、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/formatter.html&#34;&gt;std::formatter&lt;/a&gt;&lt;/code&gt;に特殊化を追加&lt;ul&gt;
&lt;li&gt;Range・シーケンスコンテナは&lt;code&gt;[1, 2, 3]&lt;/code&gt;、&lt;code&gt;[&#34;hello&#34;, &#34;world&#34;]&lt;/code&gt;、&lt;code&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&lt;/code&gt;のように出力される&lt;/li&gt;
&lt;li&gt;連想コンテナの場合、&lt;code&gt;std::map&amp;lt;int, int&amp;gt;{{1, 2}, {3, 4}}&lt;/code&gt;は&lt;code&gt;{1: 2, 3: 4}&lt;/code&gt;のように出力され、&lt;code&gt;std::set&amp;lt;int&amp;gt;{1, 2, 3}&lt;/code&gt;は&lt;code&gt;{1, 2, 3}&lt;/code&gt;のように出力される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;は&lt;code&gt;(1, 2)&lt;/code&gt;のように出力される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;関数のフォーマット指定子としてデバッグ指定「&lt;code&gt;&#34;?&#34;&lt;/code&gt;」を追加。これは文字・文字列を引用符で囲み、エスケープシーケンスをエスケープする&lt;ul&gt;
&lt;li&gt;ただし、Range・コンテナ中の文字・文字列はデフォルトでエスケープされる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;format(&#34;{:?}&#34;, &#34;h\tello&#34;)&lt;/code&gt;は&lt;code&gt;&#34;h\tello&#34;&lt;/code&gt;のように出力される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream/basic_ostream.html&#34;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream/basic_ostream/op_ostream.html&#34;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;const volatile void*&lt;/code&gt;をとるオーバーロードを追加&lt;/li&gt;
&lt;li&gt;ファイルを開く際のオプションとして、排他モードを表す&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/ios_base/type-openmode.html&#34;&gt;noreplace&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke()&lt;/a&gt;&lt;/code&gt;の戻り値型を指定するバージョンである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke_r.html&#34;&gt;std::invoke_r()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスと等価な機能をもつ、ムーブのみ可能な&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/move_only_function.html&#34;&gt;std::move_only_function&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;ユーザー定義のRangeアダプタがパイプライン演算子 &lt;code&gt;|&lt;/code&gt; をサポートしやすくするために、末尾から引数を束縛する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind_back.md.nolink&#34;&gt;std::bind_back()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、レガシーC関数からスマートポインタへの直接出力をサポートする、スマートポインタアダプタ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/out_ptr.html&#34;&gt;std::out_ptr&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/inout_ptr.html&#34;&gt;std::inout_ptr&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/unique_ptr.html&#34;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;クラスを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、オブジェクトの生存期間を開始することを明示する関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/start_lifetime_as.md.nolink&#34;&gt;std::start_lifetime_as()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/start_lifetime_as_array.md.nolink&#34;&gt;std::start_lifetime_as_array()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit.html&#34;&gt;&amp;lt;bit&amp;gt;&lt;/a&gt;&lt;/code&gt;に、値のバイト入れ替え (エンディアン変換) を行う&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/byteswap.html&#34;&gt;std::byteswap()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/visit.html&#34;&gt;std::visit()&lt;/a&gt;&lt;/code&gt;に指定できるバリアントオブジェクトを、直接的な「&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant.html&#34;&gt;std::variant&lt;/a&gt;&lt;/code&gt;型の特殊化であること」という制約を緩和し、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant.html&#34;&gt;std::variant&lt;/a&gt;&lt;/code&gt;から派生した型も許可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、列挙値を基底型に変換する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/to_underlying.html&#34;&gt;std::to_underlying()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、 (主に) メンバ変数を転送するため、指定された型の&lt;code&gt;const&lt;/code&gt;性と参照修飾で引数を転送する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward_like.html&#34;&gt;std::forward_like()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/optional/optional.html&#34;&gt;std::optional&lt;/a&gt;&lt;/code&gt;クラスにモナド操作としてメンバ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/optional/optional/and_then.html&#34;&gt;and_then()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/optional/optional/transform.html&#34;&gt;transform()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/optional/optional/or_else.html&#34;&gt;or_else()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;到達しないパスであることを表明する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/unreachable.html&#34;&gt;std::unreachable()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bitset/bitset.html&#34;&gt;std::bitset&lt;/a&gt;&lt;/code&gt;クラスをさらに&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型情報&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/typeinfo/type_info.html&#34;&gt;std::type_info&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/typeinfo/type_info/op_equal.html&#34;&gt;operator==&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、スコープ付き列挙型かを判定する型特性&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_scoped_enum.html&#34;&gt;std::is_scoped_enum&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、第1テンプレート引数についている型修飾を外す型特性として、以下を追加：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、一時オブジェクトの参照への束縛を検出するための型特性として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/reference_constructs_from_temporary.html&#34;&gt;std::reference_constructs_from_temporary&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html&#34;&gt;std::reference_converts_from_temporary&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C互換ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstdlib.html&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの多くの関数を&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;std::aligned_storage&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;std::aligned_union&lt;/a&gt;&lt;/code&gt;を非推奨化。これらの機能は未定義動作を引き起こし、間違った保証が行われ、よくないAPI設計が行われていたため、非推奨となる。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;std::aligned_storage&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;alignas(T) &lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;[sizeof(T)];&lt;/code&gt;を使用することを推奨する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;std::aligned_union&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;alignas(Ts...) &lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;[&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/max.html&#34;&gt;std::max&lt;/a&gt;({sizeof(Ts)...})];&lt;/code&gt;を使用することを推奨する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ガベージコレクションの実装にうまく役立てられなかった、ガベージコレクション実装のサポートをする以下の機能を削除する：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/declare_reachable.html&#34;&gt;std::declare_reachable()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/undeclare_reachable.html&#34;&gt;std::undeclare_reachable()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/declare_no_pointers.html&#34;&gt;std::declare_no_pointers()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/undeclare_no_pointers.html&#34;&gt;std::undeclare_no_pointers()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/get_pointer_safety.html&#34;&gt;std::get_pointer_safety()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_safety.html&#34;&gt;std::pointer_safety&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/predefined_macros.html&#34;&gt;&lt;code&gt;__STDCPP_STRICT_POINTER_SAFETY__&lt;/code&gt;マクロ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;取り決め&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以下のヘッダの一部機能をフリースタンディングライブラリとして追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple.html&#34;&gt;&amp;lt;tuple&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ratio.html&#34;&gt;&amp;lt;ratio&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>INVOKE -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/concepts/Invoke.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/concepts/Invoke.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;named requirement&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace &#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;INVOKE&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;C++における関数呼び出しという性質を抽象化しまとめた、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt; を定義する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++17からは、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt; を実体化した&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;関数テンプレートが提供される。&lt;/li&gt;
&lt;li&gt;C++23からは、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;&lt;/code&gt; を実体化した&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke_r.html&#34;&gt;std::invoke_r&lt;/a&gt;&lt;/code&gt;関数テンプレートが提供される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;用語定義&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;call-signature&lt;/em&gt; とは、戻り値型に続けて丸括弧の中に0個以上の引数型を並べたものである。 &lt;em&gt;cf.&lt;/em&gt; &lt;code&gt;int ( std::string, int )&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-type&lt;/em&gt; とは、関数呼び出し演算子を適用できる型 ( 関数、関数への参照、関数へのポインタ、&lt;code&gt;operator ()&lt;/code&gt; をオーバーロードした型もしくはそれを(直接または間接的に) &lt;code&gt;public&lt;/code&gt; 継承した型 ) もしくはメンバへのポインタ型を指す。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-object&lt;/em&gt; は、 &lt;em&gt;callable-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper-type&lt;/em&gt; は、 &lt;em&gt;callable-object&lt;/em&gt; を保持し、自身に対する関数呼び出し操作が行われたとき、保持しているオブジェクトに委譲する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; は、 &lt;em&gt;call-wrapper-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;target-object&lt;/em&gt; とは、 &lt;em&gt;callable-object&lt;/em&gt; に保持されているオブジェクトのことである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;要件（C++14まで）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が T 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN, R)&lt;/code&gt; を、 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること、と定義する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; が &lt;em&gt;weak-result-type&lt;/em&gt; を用意している場合、メンバ型 &lt;code&gt;result_type&lt;/code&gt; は&lt;em&gt;target-object&lt;/em&gt; の型 &lt;code&gt;T&lt;/code&gt; に応じて次のように定義される。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; がメンバ関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;result_type&lt;/code&gt; という名前のメンバ型を持つとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T::result_type&lt;/code&gt; と等しい。&lt;/li&gt;
&lt;li&gt;どの条件にも当てはまらない場合、 &lt;code&gt;result_type&lt;/code&gt; は定義されない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveAssignable&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++17）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveConstructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++20）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;Cpp17MoveConstructible&lt;/em&gt; かつ &lt;em&gt;Cpp17Destructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++23差分）&lt;/h2&gt;
&lt;p&gt;C++20 における 2. について、次の文言を項目の最後に追加する。この変更は、&lt;code&gt;R&lt;/code&gt;が参照かつ&lt;em&gt;INVOKE&lt;/em&gt;の実行結果が&lt;code&gt;R&lt;/code&gt;に束縛されることで寿命が延長される場合にダングリング参照が作成されてしまう事例を検出するための要件である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html&#34;&gt;reference_­converts_­from_­temporary_­v&lt;/a&gt;&amp;lt;R, decltype(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, …, tN))&amp;gt; == true&lt;/code&gt;の場合、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, …, tN)&lt;/code&gt;は&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/Cryolite/status/216814363221303296&#34; target=&#34;_blank&#34;&gt;第1引数がメンバ関数へのポインタの場合でも非静的メンバデータへのポインタの場合でも，第2引数がクラスオブジェクトへの参照の場合でもポインタの場合でもポインタっぽいものの場合でも，なんか知らんけどそれっぽく上手くいく&lt;/a&gt; ように取り計らった操作のことである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;function&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;bind&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/thread.html&#34;&gt;thread&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/async.html&#34;&gt;async&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/packaged_task.html&#34;&gt;packaged_task&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/call_once.html&#34;&gt;call_once&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf&#34; target=&#34;_blank&#34;&gt;P0777R1 Treating Unnecessary &lt;code&gt;decay&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++20から&lt;code&gt;decay_t&lt;/code&gt;を&lt;code&gt;remove_cvref_t&lt;/code&gt;へ変更。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2136r3.html&#34; target=&#34;_blank&#34;&gt;P2136R3 &lt;code&gt;invoke_r&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>説明専用ライブラリ -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/exposition-only.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/exposition-only.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;exposition-only&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;説明専用ライブラリ&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このページでは、説明専用のライブラリをまとめる。
これらはC++規格の文章中に現れる説明のためのものであり、実際に使うことはできない。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exposition-only/decay-copy.html&#34;&gt;decay-copy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay&lt;/a&gt;&lt;/code&gt;した型にコピーまたはムーブする (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exposition-only/synth-three-way-result.html&#34;&gt;synth-three-way&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;三方比較可能であればそれを行い、そうでなければ三方比較を実装して比較を行う (variable)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exposition-only/synth-three-way-result.html&#34;&gt;synth-three-way-result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;synth-three-way&lt;/code&gt;関数オブジェクトでの比較結果の型 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;concepts&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts/boolean-testable.html&#34;&gt;boolean-testable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真理値型 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/dereferenceable.html&#34;&gt;with-reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型&lt;code&gt;T&lt;/code&gt;に参照を付加する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/dereferenceable.html&#34;&gt;can-reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/dereferenceable.html&#34;&gt;with-reference&lt;/a&gt;&lt;/code&gt;可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/dereferenceable.html&#34;&gt;dereferenceable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;単純な間接参照が可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/is_integer_like.html&#34;&gt;is-integer-like&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号付整数型と同等の型か否かを表す (variable template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/is_integer_like.html&#34;&gt;is-signed-integer-like&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号なし整数型と同等の型か否かを表す (variable template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;ranges&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/copyable_box.html&#34;&gt;copyable-box&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピー可能、または例外なしでムーブ可能な場合のみ値を保持する型 (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/simple-view.html&#34;&gt;simple-view&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;単純なビューを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/has-arrow.html&#34;&gt;has-arrow&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/input_iterator.html&#34;&gt;std::input_iterator&lt;/a&gt;&lt;/code&gt;を満たし、アロー演算子が使用できる型かを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/different-from.html&#34;&gt;different-from&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;const&lt;/code&gt;/&lt;code&gt;volatile&lt;/code&gt;修飾を無視して、2つの型が同じでないことを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/subrange/uses-nonqualification-pointer-conversion.html&#34;&gt;uses-nonqualification-pointer-conversion&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;直接変換できない型同士のポインタの変換が必要かどうかを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/subrange/convertible-to-non-slicing.html&#34;&gt;convertible-to-non-slicing&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スライシングを起こさずに変換できるかどうかを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/subrange/pair-like-convertible-from.html&#34;&gt;pair-like-convertible-from&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある2つの型から構築出来る&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/pair-like.html&#34;&gt;pair-like&lt;/a&gt;&lt;/code&gt;な型を表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;tuple&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple-like.html&#34;&gt;tuple-like&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;tuple&lt;/a&gt;&lt;/code&gt;のような型を表す (concept)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/pair-like.html&#34;&gt;pair-like&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;pair&lt;/a&gt;&lt;/code&gt;のような型を表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://timsong-cpp.github.io/cppwp/n4861/expos.only.func&#34; target=&#34;_blank&#34;&gt;N4861 16.4.2.1 Exposition-only functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cplusplus.github.io/LWG/issue3404&#34; target=&#34;_blank&#34;&gt;LWG 3404 Finish removing &lt;code&gt;subrange&lt;/code&gt;&#39;s conversions from &lt;code&gt;pair-like&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>indirectly_writable -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirectly_writable.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/iterator/indirectly_writable.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirectly_writable.md b/reference/iterator/indirectly_writable.md
index 2a78cad5f..c8e64a86c 100644
--- a/reference/iterator/indirectly_writable.md
+++ b/reference/iterator/indirectly_writable.md
@@ -29,7 +29,30 @@ namespace std {
 
 このコンセプトを構成する4つの制約式は全て、[等しさを保持](/reference/concepts.md)することを要求しない。
 
-`const_cast`を用いる制約式は、右辺値に対しても代入できるが`const`な右辺値では代入できなくなる非プロキシイテレータの*prvalue*（例えば`std::string`そのものなど）を返すイテレータを弾くためにある。これによって、間接参照が*prvalue*を返すようなイテレータ型は`indirectly_writable`のモデルとならないが、出力可能なプロキシオブジェクトを返すイテレータは`indirectly_writable`のモデルとなる事ができる。
+### 制約式について
+
+`const_cast`を用いる制約式は、非プロキシオブジェクト（値を所有するオブジェクトのことである。[`std::string`](/reference/string/basic_string.md)などが該当）を弾くために存在する。
+
+まず前提として、非プロキシオブジェクトは[メンバ関数の左辺値／右辺値修飾](https://cpprefjp.github.io/lang/cpp11/ref_qualifier_for_this.html)が追加される以前からの慣習により、*pvalue*であっても代入が可能である。また、値を所有するために`const`が付与されれば代入は不可能となる。
+
+```cpp example
+#include &amp;lt;string&amp;gt;
+
+int main()
+{ 
+  std::string()  = &amp;#34;string&amp;#34;; // pvalueに代入
+}
+```
+
+このような非プロキシオブジェクトの*pvalue*がイテレータの間接参照結果として返された場合、それに書き込んだとしても、その*pvalue*のオブジェクトが所有する値を書き換えるのみであり、正しく出力されるとは言えない。
+
+一方で、プロキシオブジェクト（所有権を持たず、他のオブジェクトを参照するオブジェクト）がイテレータの間接参照結果として返された場合は、*pvalue*の場合も代入された値を「参照する先のオブジェクトが所有する値」へ書き込むことによって、正しく出力を完了することが出来る。
+
+更に、プロキシオブジェクトは値を所有しないため「`const`な参照先」でなければ、プロキシオブジェクトそれ自体が`const`であっても代入は可能であるべきである。しかしながら、従来のプロキシオブジェクトは`const`を付与された場合代入が不可能になる実装が殆どであり、変更が必要である。例としては[`std::vector&amp;lt;bool&amp;gt;::reference`](/reference/vector/vector.md)がある。
+
+プロキシオブジェクトの他にも、参照（右辺値参照/左辺値参照問わず）も正しく出力が可能である。このことから、「`const`を付与した上でも代入が可能であるようなプロキシオブジェクト」と「参照」を合わせて「プロキシ参照（proxy reference）」と呼称することがある。
+
+以上のことから、`const`を付与した際にも代入が可能であればプロキシ参照、不可能であれば非プロキシ参照と区別することが可能となる。したがって、間接参照が非プロキシ参照（プロキシオブジェクトでない*pvalue*など）を返すイテレータ型は本コンセプトのモデルとならず、プロキシ参照を返すイテレータは本コンセプトのモデルとなる事ができる。
 
 ## モデル
 
@@ -51,6 +74,8 @@ indirectly_readable&amp;lt;Out&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;iter_value_t&amp;lt;Out&amp;gt;, decay_t&amp;lt;T&amp;gt;&amp;gt;
 `indirectly_writable`のモデルとなる`Out`の`operator*`は出力（上記式による代入文の左辺に来ること）だけが唯一有効な使用法であり、[`indirectly_readable`](indirectly_readable.md)である必要はない。
 
 ## 例
+
+### C++20
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;concepts&amp;gt;
@@ -96,7 +121,7 @@ int main() {
 ```
 * std::indirectly_writable[color ff0000]
 
-### 出力
+#### 出力
 ```
 int* is indirectly writable int
 std::unique_ptr&amp;lt;int&amp;gt; is indirectly writable int&amp;amp;
@@ -109,6 +134,60 @@ std::optional&amp;lt;int&amp;gt; is not indirectly writable int
 not_writable is not indirectly writable int
 ```
 
+
+### C++23 で満たすようになった型
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;tuple&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+template &amp;lt;typename Out, typename T&amp;gt;
+requires std::indirectly_writable&amp;lt;Out, T&amp;gt;
+void f(const char* out, const char* t)
+{
+	std::cout &amp;lt;&amp;lt; out &amp;lt;&amp;lt; &amp;#34; is indirectly writable &amp;#34; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; std::endl;
+}
+
+template &amp;lt;typename Out, typename T&amp;gt;
+void f(const char* out, const char* t)
+{
+	std::cout &amp;lt;&amp;lt; out &amp;lt;&amp;lt; &amp;#34; is not indirectly writable &amp;#34; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; std::endl;
+}
+
+struct ret_proxy_pair
+{
+  // 全ての要素がプロキシ参照である pair はプロキシ参照
+	std::pair&amp;lt;int&amp;amp;, std::pair&amp;lt;int&amp;amp;, int&amp;amp;&amp;gt;&amp;gt; operator*();
+};
+
+struct ret_proxy_tuple
+{
+  // 全ての要素がプロキシ参照である tuple はプロキシ参照
+	std::tuple&amp;lt;int&amp;amp;, std::tuple&amp;lt;int&amp;amp;&amp;gt;&amp;gt; operator*();
+};
+
+
+int main()
+{
+	f&amp;lt;std::vector&amp;lt;bool&amp;gt;::iterator, bool&amp;gt;(&amp;#34;std::vector&amp;lt;bool&amp;gt;::iterator&amp;#34;, &amp;#34;bool&amp;#34;);
+	f&amp;lt;ret_proxy_pair, std::pair&amp;lt;int, std::pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;(&amp;#34;ret_proxy_pair&amp;#34;, &amp;#34;std::pair&amp;lt;int, std::pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;#34;);
+	f&amp;lt;ret_proxy_tuple, std::tuple&amp;lt;int, std::tuple&amp;lt;int&amp;gt;&amp;gt;&amp;gt;(&amp;#34;ret_proxy_tuple&amp;#34;, &amp;#34;std::tuple&amp;lt;int, std::tuple&amp;lt;int&amp;gt;&amp;gt;&amp;#34;);
+}
+```
+* std::indirectly_writable[color ff0000]
+
+#### 出力
+```
+std::vector&amp;lt;bool&amp;gt;::iterator is indirectly writable bool
+ret_proxy_pair is indirectly writable std::pair&amp;lt;int, std::pair&amp;lt;int, int&amp;gt;&amp;gt;
+ret_proxy_tuple is indirectly writable std::tuple&amp;lt;int, std::tuple&amp;lt;int&amp;gt;&amp;gt;
+
+```
+
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>different-from -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/different-from.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/different-from.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/different-from.md b/reference/ranges/different-from.md
new file mode 100644
index 000000000..d821b67cc
--- /dev/null
+++ b/reference/ranges/different-from.md
@@ -0,0 +1,30 @@
+# different-from
+* ranges[meta header]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+template&amp;lt;class T, class U&amp;gt;
+  concept different-from = // 説明専用コンセプト
+    !same_as&amp;lt;remove_cvref_t&amp;lt;T&amp;gt;, remove_cvref_t&amp;lt;U&amp;gt;&amp;gt;;
+```
+* same_as[link /reference/concepts/same_as.md]
+* remove_cvref_t[link /reference/type_traits/remove_cvref.md]
+
+## 概要
+`different-from`は、型`T`、`U`について`const`/`volatile`修飾を無視して、同じ型でないことを表す説明専用コンセプトである。
+
+
+## 備考
+N4885 までは`not-same-as`という名称だったが、実際には[`same_as`](/reference/concepts/same_as.md)の否定とは等価ではない（本説明専用コンセプトが`const`/`volatile`修飾を無視していることによる）ため、N4892（C++23 のドラフトの1つ）からは`different-from`という現行の名称に変更された。
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>elements_view -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/elements_view.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/elements_view.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/elements_view.md b/reference/ranges/elements_view.md
index bb6cc5924..d71cbb8d3 100644
--- a/reference/ranges/elements_view.md
+++ b/reference/ranges/elements_view.md
@@ -60,6 +60,7 @@ namespace std::ranges {
 説明専用コンセプト`has-tuple-element`を次のように定義する。
 
 ```cpp
+// C++20
 template&amp;lt;class T, size_t N&amp;gt;
 concept has-tuple-element =
   requires(T t) {
@@ -68,12 +69,19 @@ concept has-tuple-element =
     typename tuple_element_t&amp;lt;N, T&amp;gt;;
     { get&amp;lt;N&amp;gt;(t) } -&amp;gt; convertible_to&amp;lt;const tuple_element_t&amp;lt;N, T&amp;gt;&amp;amp;&amp;gt;;
   };
+
+// C++23
+template&amp;lt;class T, size_t N&amp;gt;
+concept has-tuple-element =
+  tuple-like&amp;lt;T&amp;gt; &amp;amp;&amp;amp; N &amp;lt; tuple_size_v&amp;lt;T&amp;gt;;
 ```
 * tuple_size[link /reference/tuple/tuple_size.md]
 * tuple_element_t[link /reference/tuple/tuple_element.md]
 * get[link /reference/tuple/tuple/get.md]
 * convertible_to[link /reference/concepts/convertible_to.md]
 * remove_reference_t[link /reference/type_traits/remove_reference.md]
+* tuple-like[link /reference/tuple/tuple-like.md]
+* tuple_size_v[link /reference/tuple/tuple_size.md]
 
 これを用いて、
 
@@ -161,3 +169,4 @@ three
 ## 参照
 - [N4861 24 Ranges library](https://timsong-cpp.github.io/cppwp/n4861/ranges)
 - [C++20 ranges](https://techbookfest.org/product/5134506308665344)
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>has-arrow -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/has-arrow.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/has-arrow.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/has-arrow.md b/reference/ranges/has-arrow.md
new file mode 100644
index 000000000..fbb4ec5f5
--- /dev/null
+++ b/reference/ranges/has-arrow.md
@@ -0,0 +1,28 @@
+# has-arrow
+* ranges[meta header]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+template&amp;lt;class I&amp;gt;
+  concept has-arrow = // 説明専用コンセプト
+    input_iterator&amp;lt;I&amp;gt; &amp;amp;&amp;amp; (is_pointer_v&amp;lt;I&amp;gt; || requires(I i) { i.operator-&amp;gt;(); });
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* is_pointer_v[link /reference/type_traits/is_pointer.md]
+
+## 概要
+`has-arrow`は、型`I`について[`std::input_iterator`](/reference/iterator/input_iterator.md)を満たす上で、アロー演算子が使用可能であることを表す説明専用コンセプトである。
+
+C++20 のイテレータ定義であるコンセプトたちではアロー演算子を提供することを要求していないため、別途用意されていると考えられる。
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>simple-view -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/simple-view.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/simple-view.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/simple-view.md b/reference/ranges/simple-view.md
new file mode 100644
index 000000000..7b2c01bbd
--- /dev/null
+++ b/reference/ranges/simple-view.md
@@ -0,0 +1,38 @@
+# simple-view
+* ranges[meta header]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+template&amp;lt;class R&amp;gt;
+  concept simple-view = // 説明専用コンセプト
+    view&amp;lt;R&amp;gt; &amp;amp;&amp;amp; range&amp;lt;const R&amp;gt; &amp;amp;&amp;amp;
+    same_­as&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;const R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+    same_­as&amp;lt;sentinel_t&amp;lt;R&amp;gt;, sentinel_t&amp;lt;const R&amp;gt;&amp;gt;;
+```
+* same-as[link /reference/concepts/same_as.md]
+* view[link view.md]
+* range[link range.md]
+* iterator_t[link iterator_t.md]
+* sentinel_t[link sentinel_t.md]
+
+## 概要
+`simple-view`は型`R`が単純（`R`は`const`であっても Range である（`const-iterable`である）上で、`R`が使用するイテレータ/センチネルと読み取り専用のイテレータ/センチネルが同じ型である）となるビューな Range を表す説明専用コンセプトである。
+
+`const-iterable`が要件にあることは、`const-iterable`ではない Range は内部でキャッシュ等の複雑度が高い仕様となることで、`const-iterable`では無くならざるを得なくなることが背景であると考えられる。`const-iterable`でないビューとしては、[`ranges::filter_view`](filter_view.md)などが挙げられる。
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参考
+- [filter_viewがconst-iterableではない理由](https://zenn.dev/onihusube/scraps/40a95c8f769414)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>subrange -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/subrange.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange.md b/reference/ranges/subrange.md
index 816694692..7aacf4c5b 100644
--- a/reference/ranges/subrange.md
+++ b/reference/ranges/subrange.md
@@ -33,7 +33,7 @@ namespace std::ranges {
 | 名前                                           | 説明                             | 対応バージョン |
 |------------------------------------------------|----------------------------------|----------------|
 | [`(constructor)`](subrange/op_constructor.md)  | コンストラクタ                   | C++20          |
-| [`operator PairLike`](subrange/op_pairlike.md) | pair-likeな型に変換する          | C++20          |
+| [`operator PairLike`](subrange/op_pairlike.md) | [`pair-like`](/reference/tuple/pair-like.md)な型に変換する          | C++20          |
 | [`begin`](subrange/begin.md)                   | 先頭を指すイテレータを取得する   | C++20          |
 | [`end`](subrange/end.md)                       | 番兵を取得する                   | C++20          |
 | [`empty`](subrange/empty.md)                   | Rangeが空かどうかを判定する      | C++20          |
@@ -73,60 +73,6 @@ namespace std::ranges {
 | [`tuple_element`](subrange/tuple_element.md) | 静的な要素の型取得(class template) | C++20          |
 | [`get`](subrange/get.md)                     | 要素を取得する(function template)  | C++20          |
 
-## 説明専用コンセプト
-
-このクラスの説明では以下のコンセプトを用いる。
-
-```cpp
-// uses-nonqualification-pointer-conversion: 直接変換できない型同士のポインタの変換が必要
-template&amp;lt;class From, class To&amp;gt;
-concept uses-nonqualification-pointer-conversion =
-  is_pointer_v&amp;lt;From&amp;gt; &amp;amp;&amp;amp; is_pointer_v&amp;lt;To&amp;gt; &amp;amp;&amp;amp;
-  !convertible_to&amp;lt;remove_pointer_t&amp;lt;From&amp;gt;(*)[], remove_pointer_t&amp;lt;To&amp;gt;(*)[]&amp;gt;;
-
-// convertible-to-non-slicing: スライシングを起こさずに変換できる
-template&amp;lt;class From, class To&amp;gt;
-concept convertible-to-non-slicing =
-  convertible_to&amp;lt;From, To&amp;gt; &amp;amp;&amp;amp;
-  !uses-nonqualification-pointer-conversion&amp;lt;decay_t&amp;lt;From&amp;gt;, decay_t&amp;lt;To&amp;gt;&amp;gt;;
-
-// pair-like: 大きさ2のtuple-likeな型である
-template&amp;lt;class T&amp;gt;
-concept pair-like =
-  !is_reference_v&amp;lt;T&amp;gt; &amp;amp;&amp;amp; requires(T t) {
-    typename tuple_size&amp;lt;T&amp;gt;::type;
-    requires derived_from&amp;lt;tuple_size&amp;lt;T&amp;gt;, integral_constant&amp;lt;size_t, 2&amp;gt;&amp;gt;;
-    typename tuple_element_t&amp;lt;0, remove_const_t&amp;lt;T&amp;gt;&amp;gt;;
-    typename tuple_element_t&amp;lt;1, remove_const_t&amp;lt;T&amp;gt;&amp;gt;;
-    { get&amp;lt;0&amp;gt;(t) } -&amp;gt; convertible_to&amp;lt;const tuple_element_t&amp;lt;0, T&amp;gt;&amp;amp;&amp;gt;;
-    { get&amp;lt;1&amp;gt;(t) } -&amp;gt; convertible_to&amp;lt;const tuple_element_t&amp;lt;1, T&amp;gt;&amp;amp;&amp;gt;;
-  };
-
-// pair-like-convertible-from: U, Vから構築できるpair-likeである (その際、Uはスライシングを起こさない)
-template&amp;lt;class T, class U, class V&amp;gt;
-concept pair-like-convertible-from =
-  !range&amp;lt;T&amp;gt; &amp;amp;&amp;amp; pair-like&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
-  constructible_from&amp;lt;T, U, V&amp;gt; &amp;amp;&amp;amp;
-  convertible-to-non-slicing&amp;lt;U, tuple_element_t&amp;lt;0, T&amp;gt;&amp;gt; &amp;amp;&amp;amp;
-  convertible_to&amp;lt;V, tuple_element_t&amp;lt;1, T&amp;gt;&amp;gt;;
-```
-* convertible_to[link /reference/concepts/convertible_to.md]
-* constructible_from[link /reference/concepts/derived_from.md]
-* derived_from[link /reference/concepts/derived_from.md]
-* is_pointer_v[link /reference/type_traits/is_pointer.md]
-* decay_t[link /reference/type_traits/decay.md]
-* integral_constant[link /reference/type_traits/integral_constant.md]
-* remove_pointer_t[link /reference/type_traits/remove_pointer.md]
-* remove_const_t[link /reference/type_traits/remove_const.md]
-* range[link /reference/ranges/range.md]
-* tuple_element_t[link /reference/tuple/tuple_element.md]
-* not-same-as[italic][link /reference/concepts/same_as.md]
-* uses-nonqualification-pointer-conversion[italic]
-* convertible-to-non-slicing[italic]
-* pair-like[italic]
-* pair-like-convertible-from[italic]
-* make-unsigned-like-t[italic][link /reference/type_traits/make_unsigned.md]
-
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>convertible-to-non-slicing -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/convertible-to-non-slicing.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/subrange/convertible-to-non-slicing.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/convertible-to-non-slicing.md b/reference/ranges/subrange/convertible-to-non-slicing.md
new file mode 100644
index 000000000..2b7b38698
--- /dev/null
+++ b/reference/ranges/subrange/convertible-to-non-slicing.md
@@ -0,0 +1,45 @@
+# convertible-to-non-slicing
+* ranges[meta header]
+* concept[meta id-type]
+* std::ranges[meta namespace]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class From, class To&amp;gt;
+    concept convertible-to-non-slicing = // 説明専用コンセプト
+      convertible_to&amp;lt;From, To&amp;gt; &amp;amp;&amp;amp;
+      !uses-nonqualification-pointer-conversion&amp;lt;decay_t&amp;lt;From&amp;gt;, decay_t&amp;lt;To&amp;gt;&amp;gt;;
+}
+```
+* convertible_to[link /reference/concepts/convertible_to.md]
+* uses-nonqualification-pointer-conversion[link uses-nonqualification-pointer-conversion.md]
+* decay_t[link /reference/type_traits/decay.md]
+* convertible-to-non-slicing[italic]
+* uses-nonqualification-pointer-conversion[italic]
+
+## 概要
+`convertible-to-non-slicing`は、型`From`から型`To`へ、スライシングを起こさずに変換できることを表す説明専用コンセプトである。[`ranges::subrange`](../subrange.md)での定義に使用され、`From`と`To`にはイテレータの型が渡される。
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`ranges::subrange`](../subrange.md)
+- [`uses-nonqualification-pointer-conversion`](uses-nonqualification-pointer-conversion.md)
+- [`pair-like-convertible-from`](pair-like-convertible-from.md)
+
+
+## 参照
+- [LWG 3282 `subrange` converting constructor should disallow derived to base conversions](https://cplusplus.github.io/LWG/issue3282)
+- [LWG 3470 `convertible-to-non-slicing` seems to reject valid case](https://cplusplus.github.io/LWG/issue3470)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/op_constructor.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/subrange/op_constructor.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/op_constructor.md b/reference/ranges/subrange/op_constructor.md
index 6abc563de..86a51709c 100644
--- a/reference/ranges/subrange/op_constructor.md
+++ b/reference/ranges/subrange/op_constructor.md
@@ -17,7 +17,7 @@ constexpr subrange(convertible-to-non-slicing&amp;lt;I&amp;gt; auto i, S s, make-unsigned-like
   requires (K == subrange_kind::sized);
 
 // (4)
-template&amp;lt;not-same-as&amp;lt;subrange&amp;gt; R&amp;gt;
+template&amp;lt;different-from&amp;lt;subrange&amp;gt; R&amp;gt;
   requires borrowed_range&amp;lt;R&amp;gt; &amp;amp;&amp;amp; convertible-to-non-slicing&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt; &amp;amp;&amp;amp; convertible_to&amp;lt;sentinel_t&amp;lt;R&amp;gt;, S&amp;gt;
 constexpr subrange(R&amp;amp;&amp;amp; r) requires (!StoreSize || sized_range&amp;lt;R&amp;gt;);
 
@@ -33,10 +33,13 @@ constexpr subrange(R&amp;amp;&amp;amp; r, make-unsigned-like-t&amp;lt;iter_difference_t&amp;lt;I&amp;gt;&amp;gt; n)
 * sized_range[link /reference/ranges/sized_range.md]
 * convertible_to[link /reference/concepts/convertible_to.md]
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* different-from[link ../different-from.md]
+* convertible-to-non-slicing[link convertible-to-non-slicing.md]
+* make-unsigned-like-t[link /reference/type_traits/make_unsigned.md]
 * StoreSize[italic]
-* not-same-as[italic][link ../subrange.md]
-* convertible-to-non-slicing[italic][link ../subrange.md]
-* make-unsigned-like-t[italic][link /reference/type_traits/make_unsigned.md]
+* different-from[italic]
+* convertible-to-non-slicing[italic]
+* make-unsigned-like-t[italic]
 
 ## 概要
 - (1) : 空の`subrange`を構築する(デフォルトコンストラクタ)
@@ -66,7 +69,7 @@ static constexpr bool StoreSize = (K == subrange_kind::sized &amp;amp;&amp;amp; !sized_sentinel_
 ## 事前条件
 
 - (2): `[i, s)`は有効なイテレータ範囲であること
-- (3): `[i, s)`は有効なイテレータ範囲であり、`n`はその範囲の長さ([`ranges::distance](/reference/iterator/ranges_distance.md)`(i, s)`)と等しいこと
+- (3): `[i, s)`は有効なイテレータ範囲であり、`n`はその範囲の長さ([`ranges::distance`](/reference/iterator/ranges_distance.md)`(i, s)`)と等しいこと
 - (4): `r`は有効な範囲であること
 - (5): `r`は有効な範囲であり、`n`はその範囲の長さと等しいこと
 
@@ -128,3 +131,5 @@ int main()
 - [N4861 24 Ranges library](https://timsong-cpp.github.io/cppwp/n4861/ranges)
 - [C++20 ranges](https://techbookfest.org/product/5134506308665344)
 - [P2367R0 Remove misuses of list-initialization from Clause 24](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2367r0.html) (本提案文書はC++20に遡って適用されている)
+- [LWG 3281 Conversion from `pair-like` types to `subrange` is a silent semantic promotion](https://cplusplus.github.io/LWG/issue3281)
+- [LWG 3282 `subrange` converting constructor should disallow derived to base conversions](https://cplusplus.github.io/LWG/issue3282)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/op_deduction_guide.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/subrange/op_deduction_guide.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/op_deduction_guide.md b/reference/ranges/subrange/op_deduction_guide.md
index 3de916059..af57c5962 100644
--- a/reference/ranges/subrange/op_deduction_guide.md
+++ b/reference/ranges/subrange/op_deduction_guide.md
@@ -36,8 +36,7 @@ namespace std::ranges {
 * tuple_element_t[link /reference/tuple/tuple_element.md]
 * StoreSize[italic][link op_constructor.md]
 * iterator-sentinel-pair[italic][link ../subrange.md]
-* not-same-as[italic][link ../subrange.md]
-* convertible-to-non-slicing[italic][link ../subrange.md]
+* convertible-to-non-slicing[italic][link convertible-to-non-slicing.md]
 * make-unsigned-like-t[italic][link /reference/type_traits/make_unsigned.md]
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator PairLike -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/op_pairlike.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/subrange/op_pairlike.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/op_pairlike.md b/reference/ranges/subrange/op_pairlike.md
index 1e2d68483..7f17e9929 100644
--- a/reference/ranges/subrange/op_pairlike.md
+++ b/reference/ranges/subrange/op_pairlike.md
@@ -6,15 +6,17 @@
 * cpp20[meta cpp]
 
 ```cpp
-template&amp;lt;not-same-as&amp;lt;subrange&amp;gt; PairLike&amp;gt;
+template&amp;lt;different-from&amp;lt;subrange&amp;gt; PairLike&amp;gt;
   requires pair-like-convertible-from&amp;lt;PairLike, const I&amp;amp;, const S&amp;amp;&amp;gt;
 constexpr operator PairLike() const;
 ```
-* not-same-as[italic][link /reference/concepts/same_as.md]
-* pair-like-convertible-from[italic][link ../subrange.md]
+* different-from[link /reference/ranges/different-from.md]
+* pair-like-convertible-from[link pair-like-convertible-from.md]
+* different-from[italic]
+* pair-like-convertible-from[italic]
 
 ## 概要
-pair-like (大きさ2のtuple-like) な型への変換演算子。
+[`pair-like`](/reference/tuple/pair-like.md) (大きさ2の[`tuple-like`](/reference/tuple/tuple-like.md)) な型への変換演算子。
 
 ## 効果
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pair-like-convertible-from -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/pair-like-convertible-from.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/subrange/pair-like-convertible-from.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/pair-like-convertible-from.md b/reference/ranges/subrange/pair-like-convertible-from.md
new file mode 100644
index 000000000..a700da03a
--- /dev/null
+++ b/reference/ranges/subrange/pair-like-convertible-from.md
@@ -0,0 +1,58 @@
+# pair-like-convertible-from
+* ranges[meta header]
+* concept[meta id-type]
+* std::ranges[meta namespace]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // C++20
+  template&amp;lt;class T, class U, class V&amp;gt;
+    concept pair-like-convertible-from = // 説明専用コンセプト
+      !range&amp;lt;T&amp;gt; &amp;amp;&amp;amp; pair-like&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
+      constructible_from&amp;lt;T, U, V&amp;gt; &amp;amp;&amp;amp;
+      convertible-to-non-slicing&amp;lt;U, tuple_element_t&amp;lt;0, T&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+      convertible_to&amp;lt;V, tuple_element_t&amp;lt;1, T&amp;gt;&amp;gt;;
+
+  // C++23
+  template&amp;lt;class T, class U, class V&amp;gt;
+    concept pair-like-convertible-from = // 説明専用コンセプト
+      !range&amp;lt;T&amp;gt; &amp;amp;&amp;amp; !is_reference_v&amp;lt;T&amp;gt; &amp;amp;&amp;amp; pair-like&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
+      constructible_from&amp;lt;T, U, V&amp;gt; &amp;amp;&amp;amp;
+      convertible-to-non-slicing&amp;lt;U, tuple_element_t&amp;lt;0, T&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+      convertible_to&amp;lt;V, tuple_element_t&amp;lt;1, T&amp;gt;&amp;gt;;
+}
+```
+* range[link ../range.md]
+* pair-like[link /reference/tuple/pair-like.md]
+* convertible-to-non-slicing[link convertible-to-non-slicing.md]
+* constructible_from[link /reference/concepts/constructible_from.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* tuple_element_t[link /reference/tuple/tuple_element.md]
+* is_reference_v[link /reference/type_traits/is_reference.md]
+* convertible-to-non-slicing[italic]
+* pair-like[italic]
+* pair-like-convertible-from[italic]
+
+## 概要
+`pair-like-convertible-from`は、型`T`が型`U`と`V`から構築出来る[`pair-like`](/reference/tuple/pair-like.md)であり、かつ`U`がスライシングを起こさないということを表す説明専用コンセプトである。[`ranges::subrange`](../subrange.md)での定義に使用され、`U`にはイテレータの型が、`V`にはセンチネルの型が渡される。
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`ranges::subrange`](../subrange.md)
+- [`uses-nonqualification-pointer-conversion`](uses-nonqualification-pointer-conversion.md)
+- [`convertible-to-non-slicing`](convertible-to-non-slicing.md)
+
+## 参照
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uses-nonqualification-pointer-conversion -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/uses-nonqualification-pointer-conversion.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/ranges/subrange/uses-nonqualification-pointer-conversion.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/uses-nonqualification-pointer-conversion.md b/reference/ranges/subrange/uses-nonqualification-pointer-conversion.md
new file mode 100644
index 000000000..390f4236f
--- /dev/null
+++ b/reference/ranges/subrange/uses-nonqualification-pointer-conversion.md
@@ -0,0 +1,42 @@
+# uses-nonqualification-pointer-conversion
+* ranges[meta header]
+* concept[meta id-type]
+* std::ranges[meta namespace]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class From, class To&amp;gt;
+    concept uses-nonqualification-pointer-conversion =  // 説明専用コンセプト
+      is_pointer_v&amp;lt;From&amp;gt; &amp;amp;&amp;amp; is_pointer_v&amp;lt;To&amp;gt; &amp;amp;&amp;amp;
+      !convertible_to&amp;lt;remove_pointer_t&amp;lt;From&amp;gt;(*)[], remove_pointer_t&amp;lt;To&amp;gt;(*)[]&amp;gt;;
+}
+```
+* convertible_to[link /reference/concepts/convertible_to.md]
+* is_pointer_v[link /reference/type_traits/is_pointer.md]
+* remove_pointer_t[link /reference/type_traits/remove_pointer.md]
+* uses-nonqualification-pointer-conversion[italic]
+
+## 概要
+`uses-nonqualification-pointer-conversion`は、直接変換できない型同士のポインタの変換が必要かどうかを表す。[`ranges::subrange`](../subrange.md)の定義において、`ranges::subrange&amp;lt;const T* const*&amp;gt;`を`T*[]`から構築するなどの時に必要になるポインタの変換を許容するために使用される。
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`ranges::subrange`](../subrange.md)
+- [`convertible-to-non-slicing`](convertible-to-non-slicing.md)
+- [`pair-like-convertible-from`](pair-like-convertible-from.md)
+
+
+## 参照
+- [LWG 3470 `convertible-to-non-slicing` seems to reject valid case](https://cplusplus.github.io/LWG/issue3470)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>apply -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/apply.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/apply.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/apply.md b/reference/tuple/apply.md
index 3b00168b8..cd65bab1b 100644
--- a/reference/tuple/apply.md
+++ b/reference/tuple/apply.md
@@ -10,29 +10,41 @@ namespace std {
   constexpr decltype(auto)
     apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t);                     // (1) C++20
 
-  template&amp;lt;class F, class Tuple&amp;gt;
+  template&amp;lt;class F, tuple-like Tuple&amp;gt;
   constexpr decltype(auto)
     apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t) noexcept(see below); // (1) C++23
 }
 ```
+* tuple-like[link tuple-like.md]
+* tuple-like[link tuple-like.md]
+&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; Updated upstream
 * see below[italic]
+=======
+&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Stashed changes
 
 ## 概要
 タプルを展開し、関数の引数に適用してその関数を実行する。
 
 
 ## 要件
-適用先の関数は[`Callable`](/reference/concepts/Callable.md)要件を満たす（[INVOKE](/reference/concepts/Invoke.md)操作が可能）。展開される`Tuple`型は[`std::tuple`](../tuple.md)に限定されず、[`std::array`](/reference/array/array.md)または[`std::pair`](/reference/utility/pair.md)のように、[`std::get`](/reference/array/array/get.md)と[`std::tuple_size`](/reference/array/array/tuple_size.md)をサポートする型であればよい。
+適用先の関数は[`Callable`](/reference/concepts/Callable.md)要件を満たす（[INVOKE](/reference/concepts/Invoke.md)操作が可能）。展開される`Tuple`型は[`std::tuple`](../tuple.md)に限定されず、[`std::array`](/reference/array/array.md)または[`std::pair`](/reference/utility/pair.md)のように、[`std::get`](/reference/array/array/get.md)と[`std::tuple_size`](/reference/array/array/tuple_size.md)をサポートする型であればよい。（C++20 まで。）C++23 では[`tuple-like`](tuple-like.md)による制約が追加されたため、使用できる型は狭まった。（[`tuple-like`](tuple-like.md)参照）
 
 
 ## 効果
 次のような関数があるとき、
 
 ```cpp
+// C++17
 template&amp;lt;class F, class Tuple, size_t... I&amp;gt;
 constexpr decltype(auto) apply-impl(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t, std::index_sequence&amp;lt;I...&amp;gt;) {
   return std::invoke(std::forward&amp;lt;F&amp;gt;(f), std::get&amp;lt;I&amp;gt;(std::forward&amp;lt;Tuple&amp;gt;(t))...);
 }
+
+// C++23
+template&amp;lt;class F, tuple-like Tuple, size_t... I&amp;gt;
+constexpr decltype(auto) apply-impl(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t, std::index_sequence&amp;lt;I...&amp;gt;) {
+  return std::invoke(std::forward&amp;lt;F&amp;gt;(f), std::get&amp;lt;I&amp;gt;(std::forward&amp;lt;Tuple&amp;gt;(t))...);
+}
 ```
 * std::get[link tuple/get.md]
 * std::index_sequence[link /reference/utility/index_sequence.md]
@@ -59,6 +71,7 @@ return apply-impl(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Tuple&amp;gt;(t),
 * std::forward[link /reference/utility/forward.md]
 * std::remove_reference_t[link /reference/type_traits/remove_reference.md]
 
+
 ## 戻り値
 適用した関数呼び出しの戻り値
 
@@ -111,6 +124,7 @@ hello
 - [`make_from_tuple`](make_from_tuple.md)
 - [`std::tuple`](../tuple.md)
 - [INVOKE](/reference/concepts/Invoke.md)
+- [`tuple-like`](tuple-like.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_from_tuple -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/make_from_tuple.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/make_from_tuple.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/make_from_tuple.md b/reference/tuple/make_from_tuple.md
index c8bb8ed53..e175fecd8 100644
--- a/reference/tuple/make_from_tuple.md
+++ b/reference/tuple/make_from_tuple.md
@@ -6,23 +6,33 @@
 
 ```cpp
 namespace std {
+  // C++17
   template &amp;lt;class T, class Tuple&amp;gt;
   constexpr T make_from_tuple(Tuple&amp;amp;&amp;amp; t);
+
+  // C++23
+  template &amp;lt;class T, tuple-like Tuple&amp;gt;
+  constexpr T make_from_tuple(Tuple&amp;amp;&amp;amp; t);
 }
 ```
+* tuple-like[link tuple-like.md]
 
 ## 概要
-tuple-likeな型`Tuple`のオブジェクトに含まれる値から型`T`のオブジェクトを構築する。
+[`tuple-like`](tuple-like.md)な型`Tuple`のオブジェクトに含まれる値から型`T`のオブジェクトを構築する。
 
 ## 要件
-型`T`のコンストラクタの内のいずれか一つが、型`Tuple`に含まれる全ての型の値をその順番通りに受け入れ可能であること。それができない場合はコンパイルエラーとなる。  
+型`T`のコンストラクタの内のいずれか一つが、型`Tuple`に含まれる全ての型の値をその順番通りに受け入れ可能であること。それができない場合はコンパイルエラーとなる。
+
 また、型`T`の初期化はそのコンストラクタで行われ集成体初期化は考慮されない。つまり、`Tuple`に含まれる型が空かただ一つの`T`でない場合、型`T`は集成体（aggregate）であってはならない（C++17のみ、C++20以降はok）。
 
+更に、C++23以降は`make_from_tuple`の返り値が参照である場合でダングリング参照を生成しないために、`make_from_tuple`の内部で`T`が構築される際に、`Tuple`から取得されるオブジェクト（参照の初期化であるので、`Tuple`のサイズは1である必要がある）の寿命が延長されないことも要求され、これを満たさない場合はコンパイルエラーとなる。
+正確には、[`tuple_­size_­v`](tuple_size.md)`&amp;lt;`[`remove_­reference_­t`](/reference/type_traits/remove_reference.md)`&amp;lt;Tuple&amp;gt;&amp;gt; == 1`である場合、[`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T, decltype(get&amp;lt;0&amp;gt;(`[`declval`](/reference/utility/declval.md)`&amp;lt;Tuple&amp;gt;()))&amp;gt; == false`であること。
+
 ## 引数
-- `t` -- tuple-likeな型`Tuple`のオブジェクト
+- `t` -- [`tuple-like`](tuple-like.md)な型`Tuple`のオブジェクト
 
-tuple-likeな型とは主に[`std::tuple`](../tuple.md)の事であるが、[`std::pair`](/reference/utility/pair.md)や[`std::array`](/reference/array/array.md)のように[`std::tuple`](../tuple.md)と同じような扱いができる型も含んでいる。  
-より詳細には、[`std::get`](/reference/array/array/get.md)（インデックス指定）と[`std::tuple_size`](/reference/array/array/tuple_size.md)が適用可能な型である。
+[`tuple-like`](tuple-like.md)な型とは主に[`std::tuple`](../tuple.md)の事であるが、[`std::pair`](/reference/utility/pair.md)や[`std::array`](/reference/array/array.md)のように[`std::tuple`](../tuple.md)と同じような扱いができる型も含んでいる。  
+より詳細には、[`std::get`](/reference/array/array/get.md)（インデックス指定）と[`std::tuple_size`](/reference/array/array/tuple_size.md)が適用可能な型である。（C++20まで。）C++23 では[`tuple-like`](tuple-like.md)による制約が追加されたため、使用できる型は狭まった。（[`tuple-like`](tuple-like.md)を参照）
 
 ## 戻り値
 `Tuple`に含まれる型の値をその順番通りに型`T`のコンストラクタに[`std::forward`](/reference/utility/forward.md)して構築された`T`のオブジェクト。
@@ -125,6 +135,7 @@ int main()
 
 ## 関連項目
 - [apply](../tuple/apply.md)
+- [`tuple-like`](tuple-like.md)
 
 ## 参照
 - [C++1z タプルを任意の型のオブジェクトに変換するmake_from_tuple関数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/08/19/173946)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pair-like -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/pair-like.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/pair-like.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/pair-like.md b/reference/tuple/pair-like.md
new file mode 100644
index 000000000..7a15efbca
--- /dev/null
+++ b/reference/tuple/pair-like.md
@@ -0,0 +1,63 @@
+# pair-like
+* tuple[meta header]
+* concept[meta id-type]
+* std[meta namespace]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  namespace ranges {
+    // C++20
+    template&amp;lt;class T&amp;gt;
+    concept pair-like = // 説明専用コンセプト
+      !is_reference_v&amp;lt;T&amp;gt; &amp;amp;&amp;amp; requires(T t) {
+        typename tuple_size&amp;lt;T&amp;gt;::type; // tuple_­size&amp;lt;T&amp;gt; が完全型であることを明確にする
+        requires derived_from&amp;lt;tuple_size&amp;lt;T&amp;gt;, integral_constant&amp;lt;size_t, 2&amp;gt;&amp;gt;;
+        typename tuple_element_t&amp;lt;0, remove_const_t&amp;lt;T&amp;gt;&amp;gt;;
+        typename tuple_element_t&amp;lt;1, remove_const_t&amp;lt;T&amp;gt;&amp;gt;;
+        { get&amp;lt;0&amp;gt;(t) } -&amp;gt; convertible_to&amp;lt;const tuple_element_t&amp;lt;0, T&amp;gt;&amp;amp;&amp;gt;;
+        { get&amp;lt;1&amp;gt;(t) } -&amp;gt; convertible_to&amp;lt;const tuple_element_t&amp;lt;1, T&amp;gt;&amp;amp;&amp;gt;;
+      };
+  }
+
+  // C++23 以降
+  template &amp;lt;typename T&amp;gt;
+  concept pair-like // 説明専用コンセプト
+    = tuple-like&amp;lt;T&amp;gt; &amp;amp;&amp;amp; tuple_size_v&amp;lt;remove_cvref_t&amp;lt;T&amp;gt;&amp;gt; == 2;
+}
+```
+* tuple_element_t[link tuple_element.md]
+* tuple_size[link tuple_size.md]
+* tuple_size_v[link tuple_size.md]
+* is_reference_v[link /reference/type_traits/is_reference.md]
+* integral_constant[link /reference/type_traits/integral_constant.md]
+* remove_const_t[link /reference/type_traits/remove_const.md]
+* remove_cvref_t[link /reference/type_traits/remove_cvref.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* tuple-like[link tuple-like.md]
+
+## 概要
+`pair-like`は型`T`が[`pair`](/reference/utility/pair.md)のような型であることを表現する説明専用コンセプトである。C++23 では[`tuple-like`](tuple-like.md)の追加に伴って定義が変更された。
+
+[`ranges::subrange`](/reference/ranges/subrange.md)での[`operator PairLike`](/reference/ranges/subrange/op_pairlike.md)の定義など、[`&amp;lt;ranges&amp;gt;`](/reference/ranges.md)での定義に使用されている。
+
+C++23 以降では[`array`](/reference/array/array.md)、[`pair`](/reference/utility/pair.md)、[`tuple`](tuple.md)、[`ranges::subrange`](/reference/ranges/subrange.md)らの互換性を高める（相互に構築・比較などが出来るようにする）ためにも使用される。
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`tuple-like`](tuple-like.md)
+
+
+## 参照
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple-like -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple-like.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple-like.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple-like.md b/reference/tuple/tuple-like.md
new file mode 100644
index 000000000..3728e0bba
--- /dev/null
+++ b/reference/tuple/tuple-like.md
@@ -0,0 +1,50 @@
+# tuple-like
+* tuple[meta header]
+* concept[meta id-type]
+* std[meta namespace]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;typename T&amp;gt;
+  concept tuple-like = /*see below*/; // 説明専用コンセプト
+}
+```
+
+
+## 概要
+`tuple-like`は型`T`が[`tuple`](tuple.md)のような型であることを表現する説明専用コンセプトである。なお、[`pair`](/reference/utility/pair.md)のような型を表現する[`pair-like`](pair-like.md)も存在する。
+
+[`array`](/reference/array/array.md)、[`pair`](/reference/utility/pair.md)、[`tuple`](tuple.md)、[`ranges::subrange`](/reference/ranges/subrange.md)らの互換性を高める（相互に構築・比較などが出来るようにする）ためなどに使用される。
+
+
+## 要件
+[`std::remove_cvref_t&amp;lt;T&amp;gt;`](/reference/type_traits/remove_cvref.md)が次の特殊化であること。
+
+- [`array`](/reference/array/array.md)
+- [`pair`](/reference/utility/pair.md)
+- [`tuple`](tuple.md)
+- [`ranges::subrange`](/reference/ranges/subrange.md)
+
+
+## 備考
+将来的に`std::get()`やそれに近しいカスタマイゼーションポイントオブジェクト（CPO）が定義されれば、`tuple-like`のモデルになる型は広がる可能性があるとされている。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`pair-like`](pair-like.md)
+
+
+## 参照
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple.md b/reference/tuple/tuple.md
index a4a196ca8..517715021 100644
--- a/reference/tuple/tuple.md
+++ b/reference/tuple/tuple.md
@@ -72,6 +72,15 @@ namespace std {
 | [`(deduction_guide)`](tuple/op_deduction_guide.md) | クラステンプレートの推論補助 | C++17 |
 
 
+## tuple-like とのユーティリティ
+| 名前                                                        | 説明                                                                   | 対応バージョン |
+|-------------------------------------------------------------|----------------------------------------------------------------------|-----------|
+| [`operator==`](tuple/op_equal.md)                           | [`tuple-like`](tuple-like.md)なオブジェクトとの等値比較を行う                     | C++23     |
+| [`operator&amp;lt;=&amp;gt;`](tuple/op_compare_3way.md)                   | [`tuple-like`](tuple-like.md)なオブジェクトとの三方比較を行う                     | C++23     |
+| [`common_type`](tuple/common_type.md)                       | [`tuple-like`](tuple-like.md)なオブジェクトとの共通型を取得できるようにする特殊化        | C++23     |
+| [`basic_common_reference`](tuple/basic_common_reference.md) | [`tuple-like`](tuple-like.md)なオブジェクトとの共通の参照型を取得出来るようにする特殊化 | C++23     |
+
+
 ## 例
 ### 基本的な使い方 (C++11)
 ```cpp example
@@ -102,6 +111,7 @@ int main()
 hello
 ```
 
+
 ### 基本的な使い方 (C++17)
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -134,6 +144,110 @@ a
 hello
 ```
 
+
+### プロキシ参照としての使い方（C++23）
+C++23 で[`zip_view`](/reference/ranges/zip_view.md.nolink)などが追加されたことに伴い、すべての要素がプロキシ参照であるような`tuple`は[プロキシ参照](/reference/iterator/indirectly_writable.md)として使用することが出来るようになった。
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;tuple&amp;gt;
+#include &amp;lt;string_view&amp;gt;
+#include &amp;lt;format&amp;gt;
+
+struct A
+{
+	A(int i, double d)
+		: i(i)
+		, d(d)
+	{}
+
+	std::tuple&amp;lt;int&amp;amp;, double&amp;amp;&amp;gt; f()
+	{
+		// this が A* なので
+		// i: int
+		// d: double
+		// ということと同じ
+		return {i, d};
+	}
+
+	std::tuple&amp;lt;const int&amp;amp;, const double&amp;amp;&amp;gt; f() const
+	{
+		// this が const A* なので
+		// i: const int
+		// d: const double
+		// ということと同じ
+		return {i, d};
+	}
+
+private:
+	int    i;
+	double d;
+};
+
+int main()
+{
+	// プロキシ参照である tuple の性質
+	{
+		A a{0, 0.0};
+
+		// std::tuple&amp;lt;int&amp;amp;, double&amp;amp;&amp;gt;
+		/***/ auto /***/ proxy = a.f();
+
+		// const std::tuple&amp;lt;int&amp;amp;, double&amp;amp;&amp;gt;
+		const auto const_proxy = a.f();
+
+		// std::tuple&amp;lt;const int&amp;amp;, const double&amp;amp;&amp;gt;
+		/***/ auto /***/ proxy_to_const = std::as_const(a).f();
+
+		// const std::tuple&amp;lt;const int&amp;amp;, const double&amp;amp;&amp;gt;
+		const auto const_proxy_to_const = std::as_const(a).f();
+
+		// OK（各要素が指すオブジェクトの値について、代入操作がなされる）
+		proxy       = a.f();
+		const_proxy = a.f();
+
+		// NG（各要素が指すオブジェクトを変更できない！）
+		// proxy_to_const       = a.f();
+		// const_proxy_to_const = a.f();
+	}
+
+	// 使い方
+	{
+		auto print = [](std::string_view prefix, A&amp;amp; a) {
+
+			// 構造化束縛で分解
+			// i: int&amp;amp;
+			// d: double&amp;amp;
+			auto [i, d] = a.f();
+
+			std::cout &amp;lt;&amp;lt; std::format(&amp;#34;{}: i={}, d={}\n&amp;#34;, prefix, i, d);
+		};
+
+		A a{0, 0.0}, b{1, 1.0};
+
+		print(&amp;#34;before a&amp;#34;, a);
+		print(&amp;#34;before b&amp;#34;, b);
+
+		// プロキシ参照として使える tuple 同士の swap 操作で
+		// 問題なく各要素が指す先のオブジェクトについて swap 操作が行える
+		std::ranges::swap(a.f(), b.f());
+
+		print(&amp;#34;after  a&amp;#34;, a);
+		print(&amp;#34;after  b&amp;#34;, b);
+	}
+}
+
+```
+
+#### 出力
+```
+before a: i=0, d=0
+before b: i=1, d=1
+after  a: i=1, d=1
+after  b: i=0, d=0
+
+```
+
 ## バージョン
 ### 言語
 - C++11
@@ -151,4 +265,4 @@ hello
 
 ## 参照
 - [タプル - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%BF%E3%83%97%E3%83%AB)
-
+- [P2321R2 `zip`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_common_reference -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/basic_common_reference.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple/basic_common_reference.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/basic_common_reference.md b/reference/tuple/tuple/basic_common_reference.md
new file mode 100644
index 000000000..637303d80
--- /dev/null
+++ b/reference/tuple/tuple/basic_common_reference.md
@@ -0,0 +1,52 @@
+# basic_common_reference
+* tuple[meta header]
+* std[meta namespace]
+* class template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+template&amp;lt;tuple-like TTuple, tuple-like UTuple,
+    template&amp;lt;class&amp;gt; class TQual, template&amp;lt;class&amp;gt; class UQual&amp;gt;
+  struct basic_common_reference&amp;lt;TTuple, UTuple, TQual, UQual&amp;gt;;
+}
+```
+* basic_common_reference[link /reference/type_traits/basic_common_reference.md]
+* tuple-like[link ../tuple-like.md]
+
+## 概要
+[`tuple`](../tuple.md)と[`tuple-like`](../tuple-like.md)なオブジェクについて、[`common_reference`](/reference/type_traits/common_reference.md)で共通の参照型を取得できるようにアダプトする[`basic_common_reference`](/reference/type_traits/common_reference.md)の特殊化である。
+
+ユーザーが直接この特殊化を利用する必要はない。[`common_reference`](/reference/type_traits/common_reference.md)を使用すること。
+
+
+## 効果
+[`tuple`](../tuple.md)`&amp;lt;`[`common_­reference_­t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;TTypes&amp;gt;, UQual&amp;lt;UTypes&amp;gt;&amp;gt;...&amp;gt;`によって得られた型をメンバ型`type`として定義する。
+
+
+## 要件
+- `TTuple`か`UTuple`のどちらかが[`tuple`](../tuple.md)の特殊化であること。
+- `TTuple`と`UTuple`のそれぞれについて、（次の`T`を置き換える形で）[`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;T, `[`decay_­t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;&amp;gt;`であること。
+    - 実質的には`TTuple`と`Utuple`について、参照型ではなく、最上位の`const`/`volatile`修飾も持っていないこと要求する。
+- `TTuple`と`UTuple`の要素数が一致していること。
+    - 具体的には、[`tuple_­size_­v`](../tuple_size.md)`&amp;lt;TTuple&amp;gt; ==` [`tuple_­size_­v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。
+- [`tuple`](../tuple.md)`&amp;lt;`[`common_­reference_­t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;TTypes&amp;gt;, UQual&amp;lt;UTypes&amp;gt;&amp;gt;...&amp;gt;`が正しく型を表すこと。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ???
+- [GCC](/implementation.md#gcc): ???
+- [ICC](/implementation.md#icc): ???
+- [Visual C++](/implementation.md#visual_cpp): ???
+
+
+## 関連項目
+- [`basic_common_reference`](/reference/type_traits/basic_common_reference.md)
+
+
+## 参照
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/common_type.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple/common_type.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/common_type.md b/reference/tuple/tuple/common_type.md
new file mode 100644
index 000000000..b8ffd1e73
--- /dev/null
+++ b/reference/tuple/tuple/common_type.md
@@ -0,0 +1,46 @@
+# common_type
+* tuple[meta header]
+* std[meta namespace]
+* class template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;tuple-like TTuple, tuple-like UTuple&amp;gt;
+  struct common_type&amp;lt;TTuple, UTuple&amp;gt;;
+}
+```
+* common_type[link /reference/type_traits/common_type.md]
+* tuple-like[link ../tuple-like.md]
+
+## 概要
+[`tuple`](../tuple.md)と[`tuple-like`](../tuple-like.md)なオブジェクについて、どちらからも変換可能な共通の型を取得できるようにする[`common_type`](/reference/type_traits/common_type.md)の特殊化である。
+
+
+## 効果
+[`tuple`](../tuple.md)`&amp;lt;`[`common_­type_­t`](/reference/type_traits/common_type.md)`&amp;lt;TTypes, UTypes&amp;gt;...&amp;gt;`によって得られた型をメンバ型`type`として定義する。
+
+
+## 備考
+- `TTuple`か`UTuple`のどちらかが[`tuple`](../tuple.md)の特殊化であること。
+- `TTuple`と`UTuple`のそれぞれについて、（次の`T`を置き換える形で）[`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;T,` [`decay_­t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;&amp;gt;`であること。
+    - 実質的には`TTuple`と`Utuple`について、参照型ではなく、最上位の`const`/`volatile`修飾も持っていないこと要求する。
+- `TTuple`と`UTuple`の要素数が一致していること。
+    - 具体的には、[`tuple_­size_­v`](../tuple_size.md)`&amp;lt;TTuple&amp;gt; ==` [`tuple_­size_­v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。
+- [`tuple`](../tuple.md)`&amp;lt;`[`common_­type_­t`](/reference/type_traits/common_type.md)`&amp;lt;TTypes, UTypes&amp;gt;...&amp;gt;`が正しく型を表すこと。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): 3.0
+- [GCC](/implementation.md#gcc): 4.6.1
+- [Visual C++](/implementation.md#visual_cpp): 2012
+
+## 関連項目
+- [common_type](/reference/type_traits/common_type.md)
+
+## 参照
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_assign.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple/op_assign.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_assign.md b/reference/tuple/tuple/op_assign.md
index 6a594bb1e..67c8ba00a 100644
--- a/reference/tuple/tuple/op_assign.md
+++ b/reference/tuple/tuple/op_assign.md
@@ -9,53 +9,102 @@
 tuple&amp;amp; operator=(const tuple&amp;amp;);                          // (1) C++11
 constexpr tuple&amp;amp; operator=(const tuple&amp;amp;);                // (1) C++20
 
-tuple&amp;amp; operator=(tuple&amp;amp;&amp;amp;) noexcept(see below);           // (2) C++11
-constexpr tuple&amp;amp; operator=(tuple&amp;amp;&amp;amp;) noexcept(see below); // (2) C++20
+constexpr const tuple&amp;amp; operator=(const tuple&amp;amp;) const;    // (2) C++23
+
+tuple&amp;amp; operator=(tuple&amp;amp;&amp;amp;) noexcept(see below);           // (3) C++11
+constexpr tuple&amp;amp; operator=(tuple&amp;amp;&amp;amp;) noexcept(see below); // (3) C++20
+
+constexpr const tuple&amp;amp; operator=(tuple&amp;amp;&amp;amp;) const;         // (4) C++23
 
 template &amp;lt;class... UTypes&amp;gt;
-tuple&amp;amp; operator=(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);               // (3) C++11
+tuple&amp;amp; operator=(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);               // (5) C++11
 template &amp;lt;class... UTypes&amp;gt;
-constexpr tuple&amp;amp; operator=(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);     // (3) C++20
+constexpr tuple&amp;amp; operator=(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);     // (5) C++20
+
+template&amp;lt;class... UTypes&amp;gt;
+constexpr const tuple&amp;amp;
+  operator=(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;) const;              // (6) C++23
 
 template &amp;lt;class... UTypes&amp;gt;
-tuple&amp;amp; operator=(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                    // (4) C++11
+tuple&amp;amp; operator=(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                    // (7) C++11
 template &amp;lt;class... UTypes&amp;gt;
-constexpr tuple&amp;amp; operator=(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);          // (4) C++20
+constexpr tuple&amp;amp; operator=(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);          // (7) C++20
+
+template&amp;lt;class... UTypes&amp;gt;
+constexpr const tuple&amp;amp;
+  operator=(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;) const;                   // (8) C++23
 
 template &amp;lt;class U1, class U2&amp;gt;
-tuple&amp;amp; operator=(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                   // (5) C++11
+tuple&amp;amp; operator=(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                   // (9) C++11
 template &amp;lt;class U1, class U2&amp;gt;
-constexpr tuple&amp;amp; operator=(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);         // (5) C++20
+constexpr tuple&amp;amp; operator=(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);         // (9) C++20
+
+template&amp;lt;class U1, class U2&amp;gt;
+constexpr const tuple&amp;amp;
+  operator=(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;) const;                  // (10) C++23
 
 template &amp;lt;class U1, class U2&amp;gt;
-tuple&amp;amp; operator=(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                        // (6) C++11
+tuple&amp;amp; operator=(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                        // (11) C++11
 template &amp;lt;class U1, class U2&amp;gt;
-constexpr tuple&amp;amp; operator=(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);              // (6) C++20
+constexpr tuple&amp;amp; operator=(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);              // (11) C++20
+
+template&amp;lt;class U1, class U2&amp;gt;
+constexpr const tuple&amp;amp; operator=(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;) const;  // (12) C++23
+
+template&amp;lt;tuple-like UTuple&amp;gt;
+constexpr tuple&amp;amp; operator=(UTuple&amp;amp;&amp;amp;);                    // (13) C++23
+template&amp;lt;tuple-like UTuple&amp;gt;
+constexpr const tuple&amp;amp; operator=(UTuple&amp;amp;&amp;amp;) const;        // (14) C++23
 ```
 * see below[italic]
 * pair[link /reference/utility/pair.md]
+* tuple-like[link ../tuple-like.md]
 
 ## 概要
 - (1) : コピー代入を行う
-- (2) : ムーブ代入を行う
-- (3) : 変換可能な`tuple`からのコピー代入を行う
-- (4) : 変換可能な`tuple`からのムーブ代入を行う
-- (5) : 変換可能な`pair`からのコピー代入を行う
-- (6) : 変換可能な`pair`からのムーブ代入を行う
-
+- (2) : (1) のプロキシ参照版
+- (3) : ムーブ代入を行う
+- (4) : (3) のプロキシ参照版
+- (5) : 変換可能な[`tuple`](../tuple.md)からのコピー代入を行う
+- (6) : (5) のプロキシ参照版
+- (7) : 変換可能な[`tuple`](../tuple.md)からのムーブ代入を行う
+- (8) : (7) のプロキシ参照版
+- (9) : 変換可能な[`pair`](/reference/utility/pair.md)からのコピー代入を行う
+- (10) : (9) のプロキシ参照版
+- (11) : 変換可能な[`pair`](/reference/utility/pair.md)からのムーブ代入を行う
+- (12) : (11) のプロキシ参照版
+- (13) : [`tuple-like`](../tuple-like.md)なオブジェクトを代入
+- (14) : (13) のプロキシ参照版
+
+[プロキシ参照](/reference/iterator/indirectly_writable.md)版とは、[プロキシ参照](/reference/iterator/indirectly_writable.md)である（要素が全て[プロキシ参照](/reference/iterator/indirectly_writable.md)である）[`tuple`](../tuple.md)が持つ各要素について、その要素の参照先へ、他の[`tuple`](../tuple.md)又は[`tuple-like`](../tuple-like.md)なオブジェクトの対応する値を代入する動作を行う版である。
 
 ## 要件
-- (1) : `tuple`の全ての要素型`i`が[`is_copy_assignable`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;i&amp;gt;::value == true`であること
-- (2) : `tuple`の全ての要素型`i`が[`is_move_assignable`](/reference/type_traits/is_move_assignable.md)`&amp;lt;i&amp;gt;::value == true`であること
-- (3) : パラメータの`tuple`の全ての要素型が、元の`tuple`の全ての要素型にコピー代入可能であり、要素数が同じであること
-- (4) : パラメータの`tuple`の全ての要素型が、元の`tuple`の全ての要素型にムーブ代入可能であり、要素数が同じであること
-- (5) : 元の`tuple`の要素数が2であり、パラメータの`pair`の全ての要素型が元の`tuple`の全ての要素型にコピー代入可能であること
-- (6) : 元の`tuple`の要素型が2であり、パラメータの`pair`の全ての要素型が元の`tuple`の全ての要素型にムーブ代入可能であること
+`Ti`（`i`は`[0, sizeof...(Types))`を範囲とする）が以下で現れた場合、元の[`tuple`](../tuple.md)のテンプレートパラメーターパックの`i`番目とする。また、`Ui`については、パラメーターの[`tuple`](../tuple.md)についてのテンプレートパラメーターパックの`i`番目とする。
+
+- (1) : 全ての`i`について、[`is_copy_assignable`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;Ti&amp;gt;::value == true`であること
+- (2) : C++23 : 全ての`i`について、[`is_copy_assignable_v`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;const Ti&amp;gt; == true`であること
+- (3) : 全ての`i`について、[`is_move_assignable`](/reference/type_traits/is_move_assignable.md)`&amp;lt;Ti&amp;gt;::value == true`であること
+- (4) : C++23 : 全ての`i`について、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, Ti&amp;gt; == true`であること
+- (5) : 要素数が同じかつ、パラメータの[`tuple`](../tuple.md)の全ての要素型が、元の[`tuple`](../tuple.md)の全ての要素型にコピー代入可能であること
+- (6) : C++23 : 要素数が同じかつ、全ての`i`について、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, const Ui&amp;amp;&amp;gt; == true`であること
+- (7) : 要素数が同じかつ、パラメータの[`tuple`](../tuple.md)の全ての要素型が、元の[`tuple`](../tuple.md)の全ての要素型にムーブ代入可能であること
+- (8) : C++23 : 要素数が同じかつ、全ての`i`について、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, Ui&amp;gt; = true`であること
+- (9) : 元の[`tuple`](../tuple.md)の要素数が2であり、パラメータの[`pair`](/reference/utility/pair.md)の全ての要素型が元の[`tuple`](../tuple.md)の全ての要素型にコピー代入可能であること
+- (10) : C++23 : 元の[`tuple`](../tuple.md)の要素数が2であり、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T0&amp;amp;, U1&amp;gt; &amp;amp;&amp;amp;` [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, U2&amp;gt;`であること
+- (11) : 元の[`tuple`](../tuple.md)の要素型が2であり、パラメータの[`pair`](/reference/utility/pair.md)の全ての要素型が元の[`tuple`](../tuple.md)の全ての要素型にムーブ代入可能であること
+- (12) : C++23 : 元の[`tuple`](../tuple.md)の要素数が2であり、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T0&amp;amp;, U1&amp;gt; &amp;amp;&amp;amp;` [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, U2&amp;gt;`であること
+- (13) : 要素数が同じかつ、次を全て満たすこと
+    - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`
+    - C++23 : [`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
+    - C++23 : 全ての`i`について、[`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
+- (14) : 要素数が同じかつ、次をすべて満たすこと
+    - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`
+    - C++23 : [`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
+    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const Ti&amp;amp;, decltype(get&amp;lt;i&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt;`
 
 
 ## 例外
-- (2) : `tuple`の全ての要素型`i`が`is_nothrow_move_assignable&amp;lt;i&amp;gt;::value == true`の場合、決して例外を投げない。
-- (4) : パラメータの`tuple`の全ての要素型が、元の`tuple`の全ての要素型にムーブ代入可能であり、要素数が同じであること
+- (3) : 全ての`i`について、[`is_nothrow_move_assignable`](/reference/type_traits/is_nothrow_move_assignable.md)`&amp;lt;Ti&amp;gt;::value == true`の場合、決して例外を投げない。
 
 
 ## 例
@@ -117,3 +166,4 @@ int main()
 
 ## 参照
 - [P1032R1 Misc constexpr bits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1032r1.html)
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;=&gt; -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_compare_3way.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple/op_compare_3way.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_compare_3way.md b/reference/tuple/tuple/op_compare_3way.md
index 58a1663e0..91e768b7e 100644
--- a/reference/tuple/tuple/op_compare_3way.md
+++ b/reference/tuple/tuple/op_compare_3way.md
@@ -9,13 +9,26 @@ namespace std {
   template&amp;lt;class... TTypes, class... UTypes&amp;gt;
   constexpr common_comparison_category_t&amp;lt;synth-three-way-result&amp;lt;TTypes, UTypes&amp;gt;...&amp;gt;
     operator&amp;lt;=&amp;gt;(const tuple&amp;lt;TTypes...&amp;gt;&amp;amp; t, const tuple&amp;lt;UTypes...&amp;gt;&amp;amp; u); // (1) C++20
+
+  template&amp;lt;class... TTypes, tuple-like UTuple&amp;gt;
+  constexpr common_comparison_category_t&amp;lt;synth-three-way-result&amp;lt;TTypes, Elems&amp;gt;...&amp;gt;
+    operator&amp;lt;=&amp;gt;(const tuple&amp;lt;TTypes...&amp;gt;&amp;amp; t, const UTuple&amp;amp; u);           // (2) C++23
+  
+  // (2) の Elems は 型パラメータパック 
+  //   tuple_­element_­t&amp;lt;0, UTuple&amp;gt;, tuple_­element_­t&amp;lt;1, UTuple&amp;gt;, ...,
+  //   tuple_­element_­t&amp;lt;tuple_­size_­v&amp;lt;UTuple&amp;gt; - 1, UTuple&amp;gt;
+  // を表す。
 }
 ```
 * tuple[link ../tuple.md]
 * common_comparison_category_t[link /reference/compare/common_comparison_category.md]
+* synth-three-way-result[link /reference/exposition-only/synth-three-way-result.md]
+* tuple-like[link ../tuple-like.md]
+* tuple_­element_­t[link ../tuple_element.md]
+* tuple_­size_­v[link ../tuple_size.md]
 
 ## 概要
-2つの[`tuple`](../tuple.md)オブジェクトの三方比較を行う。
+2つの[`tuple`](../tuple.md)オブジェクトの三方比較を行う。また、[`tuple-like`](../tuple-like.md)なオブジェクトとの三方比較を行う。（C++23以降）
 
 
 ## 効果
@@ -30,6 +43,7 @@ return t tail &amp;lt;=&amp;gt; u tail;
 ```
 * tail[italic]
 * get[link get.md]
+* synth-three-way[link /reference/exposition-only/synth-three-way-result.md]
 
 ここで`r`&amp;lt;sub&amp;gt;tail&amp;lt;/sub&amp;gt;は、`r`の最初の要素以外のすべてを含む`tuple`である。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_constructor.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple/op_constructor.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_constructor.md b/reference/tuple/tuple/op_constructor.md
index 6198cf8a9..69b191ee4 100644
--- a/reference/tuple/tuple/op_constructor.md
+++ b/reference/tuple/tuple/op_constructor.md
@@ -27,206 +27,285 @@ explicit(see below) constexpr tuple(UTypes&amp;amp;&amp;amp;...);         // (3) C++20
 tuple(const tuple&amp;amp;) = default;                            // (4) C++11
 tuple(tuple&amp;amp;&amp;amp;) = default;                                 // (5) C++11
 
+template&amp;lt;class... UTypes&amp;gt;
+explicit(see below) constexpr tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);   // (6) C++23
+
 template &amp;lt;class... UTypes&amp;gt;
-tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                           // (6) C++11
+tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                           // (7) C++11
 template &amp;lt;class... UTypes&amp;gt;
-constexpr tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                 // (6) C++14
+constexpr tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                 // (7) C++14
 template &amp;lt;class... UTypes&amp;gt;
-EXPLICIT constexpr tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);        // (6) C++17
+EXPLICIT constexpr tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);        // (7) C++17
 template &amp;lt;class... UTypes&amp;gt;
 explicit(see below) constexpr
-  tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                         // (6) C++20
+  tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                         // (7) C++20
 
 template &amp;lt;class... UTypes&amp;gt;
-tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                                // (7) C++11
+tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                                // (8) C++11
 template &amp;lt;class... UTypes&amp;gt;
-constexpr tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                      // (7) C++14
+constexpr tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                      // (8) C++14
 template &amp;lt;class... UTypes&amp;gt;
-EXPLICIT constexpr tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);             // (7) C++17
+EXPLICIT constexpr tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);             // (8) C++17
 template &amp;lt;class... UTypes&amp;gt;
-explicit(see below) constexpr tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);  // (7) C++20
+explicit(see below) constexpr tuple(tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);  // (8) C++20
+
+template&amp;lt;class... UTypes&amp;gt;
+explicit(see below) constexpr 
+  tuple(const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                        // (9) C++23
+
+template&amp;lt;class U1, class U2&amp;gt;
+explicit(see below) constexpr tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;);       // (10) C++23
 
 template &amp;lt;class U1, class U2&amp;gt;
-tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                               // (8) C++11
+tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                               // (11) C++11
 template &amp;lt;class U1, class U2&amp;gt;
-constexpr tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                     // (8) C++14
+constexpr tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                     // (11) C++14
 template &amp;lt;class U1, class U2&amp;gt;
-EXPLICIT constexpr tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);            // (8) C++17
+EXPLICIT constexpr tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);            // (11) C++17
 template &amp;lt;class U1, class U2&amp;gt;
-explicit(see below) constexpr tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;); // (8) C++20
+explicit(see below) constexpr tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;); // (11) C++20
 
 template &amp;lt;class U1, class U2&amp;gt;
-tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                                    // (9) C++11
+tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                                    // (12) C++11
 template &amp;lt;class U1, class U2&amp;gt;
-constexpr tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                          // (9) C++14
+constexpr tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                          // (12) C++14
 template &amp;lt;class U1, class U2&amp;gt;
-EXPLICIT constexpr tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                 // (9) C++17
+EXPLICIT constexpr tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                 // (12) C++17
 template &amp;lt;class U1, class U2&amp;gt;
-explicit(see below) constexpr tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);      // (9) C++20
+explicit(see below) constexpr tuple(pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);      // (12) C++20
+
+template&amp;lt;class U1, class U2&amp;gt;
+explicit(see below) constexpr
+  tuple(const pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                            // (13) C++23
+
+template&amp;lt;tuple-like UTuple&amp;gt;
+  explicit(see below) constexpr tuple(UTuple&amp;amp;&amp;amp;);          // (14) C++23
 
-// アロケータによる構築
+
+// 以下アロケータを指定する構築
 template &amp;lt;class Alloc&amp;gt;
-tuple(allocator_arg_t, const Alloc&amp;amp; a);                   // (10) C++11
+tuple(allocator_arg_t, const Alloc&amp;amp; a);                   // (15) C++11
 template &amp;lt;class Alloc&amp;gt;
-constexpr tuple(allocator_arg_t, const Alloc&amp;amp; a);         // (10) C++20
+explicit(see below) constexpr 
+  tuple(allocator_arg_t, const Alloc&amp;amp; a);                 // (15) C++20
 
 template &amp;lt;class Alloc&amp;gt;
 tuple(allocator_arg_t,
       const Alloc&amp;amp; a,
-      const Types&amp;amp;...);                                   // (11) C++11
+      const Types&amp;amp;...);                                   // (16) C++11
 template &amp;lt;class Alloc&amp;gt;
 EXPLICIT tuple(allocator_arg_t,
                const Alloc&amp;amp; a,
-               const Types&amp;amp;...);                          // (11) C++17
+               const Types&amp;amp;...);                          // (16) C++17
 template &amp;lt;class Alloc&amp;gt;
 explicit(see below) constexpr tuple(allocator_arg_t,
                                     const Alloc&amp;amp; a,
-                                    const Types&amp;amp;...);     // (11) C++20
+                                    const Types&amp;amp;...);     // (16) C++20
 
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 tuple(allocator_arg_t,
       const Alloc&amp;amp; a,
-      UTypes&amp;amp;&amp;amp;...);                                       // (12) C++11
+      UTypes&amp;amp;&amp;amp;...);                                       // (17) C++11
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 EXPLICIT tuple(allocator_arg_t,
                const Alloc&amp;amp; a,
-               UTypes&amp;amp;&amp;amp;...);                              // (12) C++17
+               UTypes&amp;amp;&amp;amp;...);                              // (17) C++17
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 explicit(see below) constexpr tuple(allocator_arg_t,
                                     const Alloc&amp;amp; a,
-                                    UTypes&amp;amp;&amp;amp;...);         // (12) C++20
+                                    UTypes&amp;amp;&amp;amp;...);         // (17) C++20
 
 template &amp;lt;class Alloc&amp;gt;
 tuple(allocator_arg_t,
       const Alloc&amp;amp; a,
-      const tuple&amp;amp;);                                      // (13) C++11
+      const tuple&amp;amp;);                                      // (18) C++11
 template &amp;lt;class Alloc&amp;gt;
 constexpr tuple(allocator_arg_t,
                 const Alloc&amp;amp; a,
-                const tuple&amp;amp;);                            // (13) C++20
+                const tuple&amp;amp;);                            // (18) C++20
 
 template &amp;lt;class Alloc&amp;gt;
 tuple(allocator_arg_t,
       const Alloc&amp;amp; a,
-      tuple&amp;amp;&amp;amp;);                                           // (14) C++11
+      tuple&amp;amp;&amp;amp;);                                           // (19) C++11
 template &amp;lt;class Alloc&amp;gt;
 constexpr tuple(allocator_arg_t,
                 const Alloc&amp;amp; a,
-                tuple&amp;amp;&amp;amp;);                                 // (14) C++20
+                tuple&amp;amp;&amp;amp;);                                 // (19) C++20
+
+template&amp;lt;class Alloc, class... UTypes&amp;gt;
+explicit(see below) constexpr
+  tuple(allocator_arg_t,
+        const Alloc&amp;amp; a, 
+        tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                               // (20) C++23
 
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 tuple(allocator_arg_t,
       const Alloc&amp;amp; a,
-      const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                           // (15) C++11
+      const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                           // (21) C++11
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 EXPLICIT tuple(allocator_arg_t,
                const Alloc&amp;amp; a,
-               const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                  // (15) C++17
+               const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                  // (21) C++17
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 explicit(see below) constexpr
   tuple(allocator_arg_t,
         const Alloc&amp;amp; a,
-        const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                         // (15) C++20
+        const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;);                         // (21) C++20
 
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 tuple(allocator_arg_t,
       const Alloc&amp;amp; a,
-      tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                                // (16) C++11
+      tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                                // (22) C++11
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 EXPLICIT tuple(allocator_arg_t,
                const Alloc&amp;amp; a,
-               tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                       // (16) C++17
+               tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                       // (22) C++17
 template &amp;lt;class Alloc, class... UTypes&amp;gt;
 explicit(see below) constexpr
   tuple(allocator_arg_t,
         const Alloc&amp;amp; a,
-        tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                              // (16) C++20
+        tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                              // (22) C++20
+
+template&amp;lt;class Alloc, class... UTypes&amp;gt;
+explicit(see below) constexpr
+  tuple(allocator_arg_t,
+        const Alloc&amp;amp; a,
+        const tuple&amp;lt;UTypes...&amp;gt;&amp;amp;&amp;amp;);                        // (23) C++23
+
+template&amp;lt;class Alloc, class U1, class U2&amp;gt;
+explicit(see below) constexpr
+  tuple(allocator_arg_t,
+        const Alloc&amp;amp; a, 
+        pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                                   // (24) C++23
 
 template &amp;lt;class Alloc, class U1, class U2&amp;gt;
 tuple(allocator_arg_t,
       const Alloc&amp;amp; a,
-      const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                               // (17) C++11
+      const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                               // (25) C++11
 template &amp;lt;class Alloc, class U1, class U2&amp;gt;
 EXPLICIT tuple(allocator_arg_t,
                const Alloc&amp;amp; a,
-               const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                      // (17) C++17
+               const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                      // (25) C++17
 template &amp;lt;class Alloc, class U1, class U2&amp;gt;
 explicit(see below) constexpr
   tuple(allocator_arg_t,
         const Alloc&amp;amp; a,
-        const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                             // (17) C++20
+        const pair&amp;lt;U1, U2&amp;gt;&amp;amp;);                             // (25) C++20
 
 template &amp;lt;class Alloc, class U1, class U2&amp;gt;
 tuple(allocator_arg_t,
       const Alloc&amp;amp; a,
-      pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                                    // (18) C++11
+      pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                                    // (26) C++11
 template &amp;lt;class Alloc, class U1, class U2&amp;gt;
 EXPLICIT tuple(allocator_arg_t,
                const Alloc&amp;amp; a,
-               pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                           // (18) C++17
+               pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                           // (26) C++17
 template &amp;lt;class Alloc, class U1, class U2&amp;gt;
 explicit(see below) constexpr
   tuple(allocator_arg_t,
         const Alloc&amp;amp; a,
-        pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                                  // (18) C++20
+        pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                                  // (26) C++20
+
+template&amp;lt;class Alloc, class U1, class U2&amp;gt;
+explicit(see below) constexpr
+  tuple(allocator_arg_t,
+        const Alloc&amp;amp; a, 
+        const pair&amp;lt;U1, U2&amp;gt;&amp;amp;&amp;amp;);                            // (27) C++23
+
+template&amp;lt;class Alloc, tuple-like UTuple&amp;gt;
+explicit(see below) constexpr
+  tuple(allocator_arg_t, const Alloc&amp;amp; a, UTuple&amp;amp;&amp;amp;);       // (28) C++23
 ```
 * see below[italic]
 * EXPLICIT[italic]
 * pair[link /reference/utility/pair.md]
 * allocator_arg_t[link /reference/memory/allocator_arg_t.md]
+* tuple-like[link ../tuple-like.md]
+* see below[italic]
 
 ## tupleオブジェクトの構築
-- (1) : すべての要素を初期化して構築
+- (1) : デフォルトコンストラクタ（すべての要素を初期化して構築）
 - (2) : 可変テンプレートパラメータの型の値によるコピー構築
 - (3) : 可変テンプレートパラメータの型に変換可能な値によるムーブ構築
 - (4) : コピーコンストラクタ
 - (5) : ムーブコンストラクタ
-- (6) : 変換可能な型からのコピーコンストラクタ
-- (7) : 変換可能な型からのムーブコンストラクタ
-- (8) : テンプレートパラメータ数が2の場合に、`std::pair`オブジェクトからコピー構築する
-- (9) : テンプレートパラメータ数が2の場合に、`std::pair`オブジェクトからムーブ構築する
-- (10) : アロケータを指定してデフォルト構築する
-- (11) : アロケータを指定して可変テンプレートパラメータの型の値によってコピー構築する
-- (12) : アロケータを指定して可変テンプレートパラメータの型の値によってムーブ構築する
-- (13) : アロケータを指定してコピー構築
-- (14) : アロケータを指定してムーブ構築
-- (15) : アロケータを指定して変換可能な他の`tuple`オブジェクトからコピー構築
-- (16) : アロケータを指定して変換可能な他の`tuple`オブジェクトからムーブ構築
-- (17) : テンプレートパラメータ数が2の場合、アロケータを指定して`std::pair`オブジェクトからコピー構築する
-- (18) : テンプレートパラメータ数が2の場合、アロケータを指定して`std::pair`オブジェクトからムーブ構築する
+- (6)-(9) : 変換可能な他の[`tuple`](../tuple.md)オブジェクトから構築
+    - (6), (7), (9) はコピー構築、(8) はムーブ構築される
+- (10)-(13) : テンプレートパラメータ数が2の場合、[`std::pair`](/reference/utility/pair.md)オブジェクトから構築する
+    - (10), (11), (13) はコピー構築、(12) はムーブ構築される
+- (14) : [`tuple-like`](../tuple-like.md)なオブジェクトから構築する
+
+以下 (15)-(28) は (1)-(14) のアロケータ指定版であり、アロケータを指定する事以外は (1)-(14) と等価である。
+
+- (15) : アロケータを指定してデフォルト構築する
+- (16) : アロケータを指定して可変テンプレートパラメータの型の値によってコピー構築する
+- (17) : アロケータを指定して可変テンプレートパラメータの型の値によってムーブ構築する
+- (18) : アロケータを指定してコピー構築
+- (19) : アロケータを指定してムーブ構築
+- (20)-(23) : アロケータを指定して変換可能な他の[`tuple`](../tuple.md)オブジェクトから構築
+    - (20), (21), (23) はコピー構築、(22) はムーブ構築される
+- (24)-(27) : テンプレートパラメータ数が2の場合、アロケータを指定して[`std::pair`](/reference/utility/pair.md)オブジェクトから構築する
+    - (24), (25), (27) はコピー構築、(26) はムーブ構築される
+- (28) : アロケータを指定して[`tuple-like`](../tuple-like.md)なオブジェクトから構築する
 
 
 ## テンプレートパラメータ制約
-- (1), (10) :
+- (1), (15) :
     - `Types...`の全ての型`Ti`について、[`is_default_constructible`](/reference/type_traits/is_default_constructible.md)`&amp;lt;Ti&amp;gt;::value == true`であること
-- (2), (11) :
+- (2), (16) :
     - `Types...`の全ての型`Ti`について、[`is_copy_constructible`](/reference/type_traits/is_copy_constructible.md)`&amp;lt;Ti&amp;gt;::value == true`であること
-- (3), (12) :
+- (3), (17) :
     - `sizeof...(Types) == sizeof...(UTypes)`であること
+    - C++20まで : `Types...`の全ての型`Ti`と、`UTypes...`の全ての型`Ui`について、[`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value == true`であること
     - C++17 : `sizeof...(Types) &amp;gt;= 1`であること
-    - `Types...`の全ての型`Ti`と、`UTypes...`の全ての型`Ui`について、[`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value == true`であること
-- (4), (13) :
+    - C++23 : `disambiguating-constraint`を次のように定義して、
+        - `sizeof...(Types) == 1`の時、[`negation`](/reference/type_traits/negation.md)`&amp;lt;`[`is_­same`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;U0&amp;gt;,` [`tuple`](../tuple.md)`&amp;gt;&amp;gt;`
+        - `sizeof...(Types) == 2 || sizeof...(Types) == 3`の時、[`bool_­constant`](/reference/type_traits/bool_constant.md)`&amp;lt;!`[`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;U0&amp;gt;,` [`allocator_­arg_­t`](/reference/memory/allocator_arg_t.md)`&amp;gt; ||` [`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_­cvref_­t`](/reference/type_traits/remove_cvref.md)`&amp;lt;T0&amp;gt;,` [`allocator_­arg_­t`](/reference/memory/allocator_arg_t.md)`&amp;gt;&amp;gt;`
+        - 以上に該当しなければ、[`true_type`](/reference/type_traits/true_type.md)
+    - C++23 : [`conjunction_­v`](/reference/type_traits/conjunction.md)`&amp;lt;disambiguating-constraint,` [`is_­constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, UTypes&amp;gt;...&amp;gt;`であること
+- (4), (18) :
     - `Types...`の全ての型`Ti`について、[`is_copy_constructible`](/reference/type_traits/is_copy_constructible.md)`&amp;lt;Ti&amp;gt;::value == true`であること
-- (5), (14) :
+- (5), (19) :
     - `Types...`の全ての型`Ti`について、[`is_move_constructible`](/reference/type_traits/is_move_constructible.md)`&amp;lt;Ti&amp;gt;::value == true`であること
-- (6), (15) :
+- (6)-(9), (20)-(23) :
+    - `I`をパラメータパック`0, 1, ..., (sizeof...(Types) - 1)`、`FWD(u)`を`static_­cast&amp;lt;decltype(u)&amp;gt;(u)`、`sizeof...(Types) == 1`の場合は、`Types...`を`T`へ、`UTypes...`を`U`へ展開したと定義して
+    - C++23 : `sizeof...(Types) == sizeof...(UTypes) &amp;amp;&amp;amp; (`[`is_­constructible_­v`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, decltype(`[`get`](/reference/tuple/tuple/get.md)`&amp;lt;I&amp;gt;(FWD(u)))&amp;gt; &amp;amp;&amp;amp; ...) == true`であること
+    - C++23 : 更に、`sizeof...(Types) != 1`または、[`is_­convertible_v­`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(u), T&amp;gt; == false &amp;amp;&amp;amp;` [`is_­constructible_­v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, decltype(u)&amp;gt; == false &amp;amp;&amp;amp;` [`is_­same_­v`](/reference/type_traits/is_same.md)`&amp;lt;T, U&amp;gt; == false`であること
+- (7), (21) :
     - `sizeof...(Types) == sizeof...(UTypes)`であること
     - `Types...`の全ての型`Ti`と、`UTypes...`の全ての型`Ui`について、[`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Ti, const Ui&amp;amp;&amp;gt;::value == true`であること
-    - C++17 : `sizeof(Types...) != 1`であるか、そうでなければ`Types...`の先頭を`T`、`UTypes...`の先頭をUとして、`!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const tuple&amp;lt;U&amp;gt;&amp;amp;, T&amp;gt; &amp;amp;&amp;amp; !`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, const tuple&amp;lt;U&amp;gt;&amp;amp;&amp;gt; &amp;amp;&amp;amp; !`[`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;T, U&amp;gt;`が`true`であること
+    - C++17 : `sizeof(Types...) != 1`であるか、そうでなければ`Types...`の先頭を`T`、`UTypes...`の先頭を`U`として、`!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const tuple&amp;lt;U&amp;gt;&amp;amp;, T&amp;gt; &amp;amp;&amp;amp; !`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, const tuple&amp;lt;U&amp;gt;&amp;amp;&amp;gt; &amp;amp;&amp;amp; !`[`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;T, U&amp;gt;`が`true`であること
         - コピーコンストラクタとのオーバーロードが成立することを意図している
-- (7), (16) :
+    - C++23 : (6)-(9), (20)-(23) の定義参照
+- (8), (22) :
     - `sizeof...(Types) == sizeof...(UTypes)`であること
     - `Types...`の全ての型`Ti`と、`UTypes...`の全ての型`Ui`について、[`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value == true`であること
     - C++17 : `sizeof(Types...) != 1`であるか、そうでなければ`Types...`の先頭を`T`、`UTypes...`の先頭をUとして、`!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;tuple&amp;lt;U&amp;gt;, T&amp;gt; &amp;amp;&amp;amp; !`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, tuple&amp;lt;U&amp;gt;&amp;gt; &amp;amp;&amp;amp; !`[`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;T, U&amp;gt;`が`true`であること
         - ムーブコンストラクタとのオーバーロードが成立することを意図している
-- (8), (17) :
+    - C++23 : (6)-(9), (20)-(23) の定義参照
+- (10)-(13), (24)-(27) :
+    - `FWD(u)`を`static_­cast&amp;lt;decltype(u)&amp;gt;(u)`、`Types...`の0番目の型を`T0`、1番目の型を`T1`であるとして、
+    - C++23 : `sizeof...(Types) == 2`であること
+    - C++23 : [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T0, decltype(get&amp;lt;0&amp;gt;(FWD(u))) == true`であること
+    - C++23 : [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;T1, decltype(get&amp;lt;1&amp;gt;(FWD(u))) == true`であること
+- (11), (25) :
     - `Types...`の0番目の型を`T0`、1番目の型を`T1`であるとする
     - `sizeof...(Types) == 2`であること
     - [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;T0, const U1&amp;amp;&amp;gt;::value == true`かつ[`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;T1, const U2&amp;amp;&amp;gt;::value == true`であること
-- (9), (18) :
+    - C++23 : (10)-(13), (24)-(27) の定義参照
+- (12), (26) :
     - `Types...`の0番目の型を`T0`、1番目の型を`T1`であるとする
     - `sizeof...(Types) == 2`であること
     - [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value == true`かつ[`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value == true`であること
+    - C++23 : (10)-(13), (24)-(27) の定義参照
+- (14), (28) :
+    - C++23 : [`tuple-like`](../tuple-like.md)`&amp;lt;UTuple&amp;gt;`であること
+    - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;UTuple, tuple&amp;gt;`であること
+    - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
+    - C++23 : `sizeof...(Types) ==` [`tuple_size_v`](../tuple_size.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;UTuple&amp;gt;&amp;gt;`であること
+    - C++23 : `(`[`is_­constructible_­v`](/reference/type_traits/is_constructible.md)`&amp;lt;Types, decltype(get&amp;lt;I&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u)))&amp;gt; &amp;amp;&amp;amp; ...) == true`であること
+    - C++23 : `sizeof...(Types) != 1`であるか、または`Types...`を`T`に展開したとして[`is_­convertible_­v`](/reference/type_traits/is_convertible.md)`&amp;lt;UTuple, T&amp;gt; == false &amp;amp;&amp;amp;` [`is_­constructible_­v`](/reference/type_traits/is_constructible.md)`&amp;lt;T, UTuple&amp;gt; == false`であること
 
 
 ## 備考
@@ -238,25 +317,54 @@ explicit(see below) constexpr
 - (3) :
     - C++11からC++14まで : 無条件で`explicit`となる
     - C++17から : `!`[`conjunction_v`](/reference/type_traits/conjunction.md)`&amp;lt;`[`is_convertible`](/reference/type_traits/is_convertible.md)`&amp;lt;UTypes, Types&amp;gt;...&amp;gt;`である場合、この関数は`explicit`となる
-- (6) :
-    - C++17 : `!`[`conjunction_v`](/reference/type_traits/conjunction.md)`&amp;lt;`[`is_convertible`](/reference/type_traits/is_convertible.md)`&amp;lt;const Types&amp;amp;, Types&amp;gt;...&amp;gt;`である場合、この関数は`explicit`となる
+    - C++23から : `(`[`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;Types, UTypes&amp;amp;&amp;amp;&amp;gt; || ...)`である場合、この関数は削除定義される
+- (6)-(9) :
+    - `I`をパラメータパック`0, 1, ..., (sizeof...(Types) - 1)`、`FWD(u)`を`static_­cast&amp;lt;decltype(u)&amp;gt;(u)`と定義して、
+    - C++23 : `!(`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](../tuple/get.md)`&amp;lt;I&amp;gt;(FWD(u))), Types&amp;gt; &amp;amp;&amp;amp; ...)`である場合、この関数は`explicit`となる
+    - C++23 : `(`[`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;Types, decltype(`[`get`](../tuple/get.md)`&amp;lt;I&amp;gt;(FWD(u)))&amp;gt; || ...)`である場合、この関数は削除定義される
 - (7) :
-    - C++17 : `!`[`conjunction_v`](/reference/type_traits/conjunction.md)`&amp;lt;`[`is_convertible`](/reference/type_traits/is_convertible.md)`&amp;lt;UTypes, Types&amp;gt;...&amp;gt;`である場合、この関数は`explicit`となる
+    - C++17 : `!`[`conjunction_v`](/reference/type_traits/conjunction.md)`&amp;lt;`[`is_convertible`](/reference/type_traits/is_convertible.md)`&amp;lt;const Types&amp;amp;, Types&amp;gt;...&amp;gt;`である場合、この関数は`explicit`となる
+    - C++23 : (6)-(9) の定義参照
 - (8) :
-    - `Types...`の0番目の型を`T0`、1番目の型を`T1`であるとする
-    - `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, T0&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, T1&amp;gt;`である場合、この関数は`explicit`となる
+    - C++17 : `!`[`conjunction_v`](/reference/type_traits/conjunction.md)`&amp;lt;`[`is_convertible`](/reference/type_traits/is_convertible.md)`&amp;lt;UTypes&amp;amp;&amp;amp;, Types&amp;gt;...&amp;gt;`である場合、この関数は`explicit`となる
+    - C++23 : (6)-(9) の定義参照
+- (10)-(13) :
+    - `FWD(u)`を`static_­cast&amp;lt;decltype(u)&amp;gt;(u)`、`Types...`の0番目の型を`T0`、1番目の型を`T1`であるとして、
+    - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(u))), T0&amp;gt; ||!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(u))), T1&amp;gt;`である場合、この関数は`explicit`となる
+    - C++23 : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T0, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(u)))&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T1, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(u)))&amp;gt;`である場合、この関数は削除定義される
 - (11) :
-    - C++17 : (2)と同じ条件で`explicit`となる
+    - `Types...`の0番目の型を`T0`、1番目の型を`T1`であるとする
+    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U1&amp;amp;, T0&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U2&amp;amp;, T1&amp;gt;`である場合、この関数は`explicit`となる
+    - C++23 : (10)-(13) の定義参照
 - (12) :
-    - C++17 : (3)と同じ条件で`explicit`となる
+    - `Types...`の0番目の型を`T0`、1番目の型を`T1`であるとする
+    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1&amp;amp;&amp;amp;, T0&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2&amp;amp;&amp;amp;, T1&amp;gt;`である場合、この関数は`explicit`となる
+    - C++23 : (10)-(13) の定義参照
+- (14) :
+    - `I`をパラメータパック`0, 1, ..., (sizeof...(Types) - 1)`と定義して、
+    - C++23 : `!(`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(get&amp;lt;I&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;UTuple&amp;gt;(u))), Types&amp;gt; &amp;amp;&amp;amp; ...)`である場合、この関数は`explicit`となる
 - (15) :
-    - C++17 : (6)と同じ条件で`explicit`となる
+    - C++20 : 対応するコンストラクタ (1) と同じ条件で`explicit`となる
 - (16) :
-    - C++17 : (7)と同じ条件で`explicit`となる
+    - C++17 : 対応するコンストラクタ (2) と同じ条件で`explicit`となる
 - (17) :
-    - C++17 : (8)と同じ条件で`explicit`となる
-- (18) :
-    - C++17 : (9)と同じ条件で`explicit`となる
+    - C++17 : 対応するコンストラクタ (3) と同じ条件で`explicit`となる
+    - C++23 : 対応するコンストラクタ (3) と同じ条件で削除定義される
+- (20), (23) : 
+    - C++23 : それぞれ対応するコンストラクタ (6), (9) と同じ条件で`explicit`となる
+    - C++23 : それぞれ対応するコンストラクタ (6), (9) と同じ条件で削除定義される
+- (21), (22) : 
+    - C++17 : それぞれ対応するコンストラクタ (7), (8) と同じ条件で`explicit`となる
+    - C++23 : それぞれ対応するコンストラクタ (7), (8) と同じ条件で削除定義される
+- (24), (27) :
+    - C++23 : それぞれ対応するコンストラクタ (10), (13) と同じ条件で`explicit`となる
+    - C++23 : それぞれ対応するコンストラクタ (10), (13) と同じ条件で削除定義される
+- (25), (26) :
+    - C++17 : それぞれ対応するコンストラクタ (11), (12) と同じ条件で`explicit`となる
+    - C++23 : それぞれ対応するコンストラクタ (11), (12) と同じ条件で削除定義される
+- (28) :
+    - C++23 : それぞれ対応するコンストラクタ (14) と同じ条件で`explicit`となる
+
 - C++17では、コンストラクタの各オーバーロードが条件付きで`explicit`となるよう規定された。これは、以下のような初期化子リストを使用したC++17での初期化が不適格になっていたため、適格になるようにするための変更である：
     ```cpp
     std::tuple&amp;lt;int, int&amp;gt; pixel_coordinates()
@@ -270,6 +378,13 @@ explicit(see below) constexpr
 
     - この変更はC++17に対するものであるが、コンパイラが早期に対応していたため、一部処理系ではC++14の段階から適格となっていた
 
+- C++23 では、ダングリング参照の作成が簡単にできていた状態を改善するべく、[`reference_constructs_from_temporary`](/reference/type_traits/reference_constructs_from_temporary.md)が追加され、ダングリング参照が作成される場合には不適格とするようになった :
+    ```cpp
+    // コンストラクタ引数で std::string が構築され
+    // その一時オブジェクトが束縛されるため、ダングリング参照となっていた
+    // C++23 からは不適格であり、コンパイルエラー等で未然に防がれる
+    std::tuple&amp;lt;const std::string&amp;amp;, const std::string&amp;amp;&amp;gt; x(&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;);
+    ```
 
 ## 例
 ```cpp example
@@ -332,3 +447,11 @@ int main()
 - [P1032R1 Misc constexpr bits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1032r1.html)
 - [P0892R2 `explicit(bool)`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0892r2.html)
     - C++20での`explicit(bool)`構文への対応
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
+    - [`tuple-like`](/reference/tuple/tuple-like.md)なオブジェクトからの構築
+- [P2255R2 A type trait to detect reference binding to temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r2.html)
+    - 参照型を要素に持つ場合にダングリング参照が容易に作成できていたのを不適格にする
+- [LWG 3121 tuple constructor constraints for UTypes&amp;amp;&amp;amp;... overloads](https://cplusplus.github.io/LWG/issue3121)
+    - C++23 での (3) のコンストラクタの制約の変更（`disambiguating-constraint`等）について
+- [P2321R2 `zip`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html#tuple)
+    - すべての要素が[プロキシ参照](/reference/iterator/indirectly_writable.md)の場合、[プロキシ参照](/reference/iterator/indirectly_writable.md)として使用できるようにする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/op_equal.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple/op_equal.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/op_equal.md b/reference/tuple/tuple/op_equal.md
index ba77831b5..b0cb55f2f 100644
--- a/reference/tuple/tuple/op_equal.md
+++ b/reference/tuple/tuple/op_equal.md
@@ -13,17 +13,26 @@ namespace std {
   template&amp;lt;class... TTypes, class... UTypes&amp;gt;
   constexpr bool operator==(const tuple&amp;lt;TTypes...&amp;gt;&amp;amp; t,
                             const tuple&amp;lt;UTypes...&amp;gt;&amp;amp; u); // (1) C++14
+
+  template&amp;lt;class... TTypes, tuple-like UTuple&amp;gt;
+  constexpr bool operator==(const tuple&amp;lt;TTypes...&amp;gt;&amp;amp; t,
+                            const UTuple&amp;amp; u);           // (2) C++23
 }
 ```
 * tuple[link ../tuple.md]
+* tuple-like[link ../tuple-like.md]
 
 ## 概要
-2つの[`tuple`](../tuple.md)オブジェクトの等値比較を行う。
+2つの[`tuple`](../tuple.md)オブジェクトの等値比較を行う。また、[`tuple-like`](../tuple-like.md)なオブジェクトとの等値比較を行う。（C++23以降）
 
 
 ## 要件
-- 2つの[`tuple`](../tuple.md)オブジェクトの要素数が同じであること。
-- [`tuple`](../tuple.md)の要素`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t)`と`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)`において、すべての要素の比較 `std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t) == std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)` の比較結果が`bool`に変換可能な型であること。
+- (1) : 
+    - 2つの[`tuple`](../tuple.md)オブジェクトの要素数が同じであること。（具体的には`sizeof...(TTypes) == sizeof...(UTypes)`であること。）
+    - [`tuple`](../tuple.md)の要素`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t)`と`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)`において、すべての要素の比較 `std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t) == std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)` の比較結果が`bool`に変換可能な型（C++23 以降は[`boolean-testable`](/reference/concepts/boolean-testable.md)を満たせばよい）であること。
+- (2) :
+    - C++23 : 2つの[`tuple-like`](../tuple-like.md)なオブジェクトの要素数が同じであること。（正確には、`sizeof...(TTypes) ==` [`tuple_­size_­v`](../tuple_size.md)`&amp;lt;UTuple&amp;gt;`であること。）
+    - C++23 : [`tuple`](../tuple.md)の要素`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t)`と[`tuple-like`](../tuple-like.md)なオブジェクトの要素`std::get&amp;lt;i&amp;gt;(u)`において、すべての要素の比較 `std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t) == std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)` の比較結果が[`boolean-testable`](/reference/concepts/boolean-testable.md)を満たす型（`bool`へ変換可能な型）であること。
 
 
 ## 効果
@@ -31,7 +40,7 @@ namespace std {
 
 
 ## 戻り値
-[`tuple`](../tuple.md)の全ての要素を`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t) ==std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)` した結果が`true`である場合`true`を返し、そうでなければ`false`を返す。
+[`tuple`](../tuple.md)の全ての要素を`std::`[`get`](get.md)`&amp;lt;i&amp;gt;(t) == std::`[`get`](get.md)`&amp;lt;i&amp;gt;(u)`した結果が`true`である場合`true`を返し、そうでなければ`false`を返す。
 
 
 ## 備考
@@ -84,3 +93,4 @@ false
 - [N3471 Constexpr Library Additions: utilities, v3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html)
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/swap.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple/swap.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/swap.md b/reference/tuple/tuple/swap.md
index 4467d18b2..d361d7fb2 100644
--- a/reference/tuple/tuple/swap.md
+++ b/reference/tuple/tuple/swap.md
@@ -8,19 +8,26 @@
 ```cpp
 void swap(tuple&amp;amp; rhs) noexcept(see below);           // (1) C++11
 constexpr void swap(tuple&amp;amp; rhs) noexcept(see below); // (1) C++20
+
+constexpr void
+  swap(const tuple&amp;amp; rhs) const noexcept(see below);  // (2) C++23
 ```
+* tuple[link ../tuple.md]
 * see below[italic]
 
 ## 概要
-他の`tuple`オブジェクトと中身を入れ替える。
+- (1) : 他の[`tuple`](../tuple.md)オブジェクトと中身を入れ替える。
+- (2) : [プロキシ参照](/reference/iterator/indirectly_writable.md)である[`tuple`](../tuple.md)同士で、参照先の値を入れ替える。
 
 
 ## 要件
-`tuple`の全ての要素型が`swap`可能であること。
+- (1) : [`tuple`](../tuple.md)の全ての要素型が`swap`可能であること。
+- (2) : C++23 : `(`[`is_swappable_v`](/reference/type_traits/is_swappable.md)`&amp;lt;const Types&amp;gt; &amp;amp;&amp;amp; ...) == true`であること。
 
 
 ## 効果
-自身のインスタンスの全ての要素を、`rhs`の全ての要素と入れ替える
+- (1) : 自身のインスタンスの全ての要素を、`rhs`の全ての要素と入れ替える
+- (2) : 自身のインスタンスの各要素の参照先の値と、他の[プロキシ参照](/reference/iterator/indirectly_writable.md)な[`tuple`](../tuple.md)の各要素の参照先の値とを入れ替える。
 
 
 ## 戻り値
@@ -28,7 +35,8 @@ constexpr void swap(tuple&amp;amp; rhs) noexcept(see below); // (1) C++20
 
 
 ## 例外
-`tuple`の全ての要素型が、例外を投げない`swap`を持っている場合、この関数は例外を投げない
+- (1) : [`tuple`](../tuple.md)の全ての要素型が、例外を投げない`swap`を持っている場合、この関数は例外を投げない
+- (2) : C++23 : `(`[`is_nothrow_swappable_v`](/reference/type_traits/is_nothrow_swappable.md)`&amp;lt;const Types&amp;gt; &amp;amp;&amp;amp; ...) == true`であること。
 
 
 ## 例
@@ -68,3 +76,4 @@ int main()
 
 ## 参照
 - [P1032R1 Misc constexpr bits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1032r1.html)
+- [P2321R2 `zip`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap (非メンバ関数) -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/swap_free.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple/swap_free.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/swap_free.md b/reference/tuple/tuple/swap_free.md
index e9636a9d8..8f26bbd29 100644
--- a/reference/tuple/tuple/swap_free.md
+++ b/reference/tuple/tuple/swap_free.md
@@ -12,11 +12,21 @@ namespace std {
   template &amp;lt;class... Types&amp;gt;
   constexpr void swap(tuple&amp;lt;Types...&amp;gt;&amp;amp; x, tuple&amp;lt;Types...&amp;gt;&amp;amp; y)
     noexcept(noexcept(x.swap(y)));                            // (1) C++20
+
+  template&amp;lt;class... Types&amp;gt;
+  constexpr void swap(const tuple&amp;lt;Types...&amp;gt;&amp;amp; x, 
+                      const tuple&amp;lt;Types...&amp;gt;&amp;amp; y) 
+    noexcept(see below);                                      // (2) C++23
 }
 ```
 
 ## 概要
-2つの`tuple`オブジェクトを入れ替える。
+- (1) : 2つの`tuple`オブジェクトを入れ替える。
+- (2) : 2つの[プロキシ参照](/reference/iterator/indirectly_writable.md)である`tuple`オブジェクトについて、対応する要素毎に参照先の値を入れ替える。
+
+
+## 要件
+効果の式に現れている、[`tuple::swap`](swap.md)に準じる。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_cat -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_cat.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/tuple/tuple_cat.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_cat.md b/reference/tuple/tuple_cat.md
index f1a557365..1f7f18b28 100644
--- a/reference/tuple/tuple_cat.md
+++ b/reference/tuple/tuple_cat.md
@@ -7,28 +7,48 @@
 ```cpp
 namespace std {
   template &amp;lt;class... Tuples&amp;gt;
-  tuple&amp;lt;Ctypes ...&amp;gt; tuple_cat(Tuples&amp;amp;&amp;amp;...);           // C++11
+  tuple&amp;lt;Ctypes ...&amp;gt; tuple_cat(Tuples&amp;amp;&amp;amp;...);                // C++11
 
   template &amp;lt;class... Tuples&amp;gt;
-  constexpr tuple&amp;lt;Ctypes ...&amp;gt; tuple_cat(Tuples&amp;amp;&amp;amp;...); // C++14
+  constexpr tuple&amp;lt;Ctypes ...&amp;gt; tuple_cat(Tuples&amp;amp;&amp;amp;...);      // C++14
+
+  template &amp;lt;tuple-like... Tuples&amp;gt;
+  constexpr tuple&amp;lt;Ctypes ...&amp;gt; tuple_cat(Tuples&amp;amp;&amp;amp;... tpls); // C++23
 }
 ```
+* tuple[link tuple.md]
+* tuple-like[link tuple-like.md]
 
 ## 概要
-複数の[`tuple`](../tuple.md)を繋ぎ合わせ、1つの[`tuple`](../tuple.md)にする。
+複数の[`tuple`](tuple.md)を繋ぎ合わせ、1つの[`tuple`](tuple.md)にする。C++23 からは[`tuple-like`](tuple-like.md)である型を対象に繋ぎ合わせることが可能。
 
 
 ## 要件
-- `Tuples...`の全ての型が`std::tuple&amp;lt;Args...&amp;gt;`であること。
-- `Args...`の各型が左辺値参照であればコピー構築可能、そうでなければムーブ構築可能であること。
+- C++20まで :
+    - `Tuples...`の全ての型が[`std::tuple`](tuple.md)`&amp;lt;Args...&amp;gt;`であること。
+    - `Args...`の各型が左辺値参照であればコピー構築可能、そうでなければムーブ構築可能であること。
+- C++23から :
+    - 本関数の返り値の[`tuple`](tuple.md)のテンプレートパラメーターパックを`Ctypes`とし、`Ctypes`の全ての要素について、引数`tpls`において対応する要素の型から構築可能であること。
+    - より厳密には、次のように定義を行い、`(`[`is_­constructible_v­`](/reference/type_traits/is_constructible.md)`&amp;lt;CTypes, decltype(celems)&amp;gt; &amp;amp;&amp;amp; ...) == true`であること。
+        - `n`を`sizeof...(Tuples)`とし、`i`を範囲`[0, n)`における整数値とする
+        - `T(i)`を`Tuples`の`i`番目とする
+        - `U(i)`を[`remove_cvref_t&amp;lt;T(i)&amp;gt;`](/reference/type_traits/remove_cvref.md) とする
+        - `tp(i)`をパラメータパック`tpls`の`i`番目とする
+        - `S(i)`を[`tuple_size_v&amp;lt;U(i)&amp;gt;`](/reference/tuple/tuple_size.md)とする
+        - `E(i,k)`を[`tuple_element_t&amp;lt;k, U(i)&amp;gt;`](/reference/tuple/tuple_element.md)とする
+        - `e(i,k)`を`get&amp;lt;k&amp;gt;(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T(i)&amp;gt;(tp(i)))`とする
+        - `Elems(i)`を型パラメータパック`E(i,0), ..., E(i,Si-1)`とする
+        - `elems(i)`をパラメータパック`e(i,0), ..., e(i,Si-1)`とする
+        - `Ctypes`を型パラメーターパック`Elems(0)..., Elems(1)..., ..., Elems(n-1)...`とする
+        - `celems`をパラメーターパック`elems(0)..., elems(1), ..., elems(n-1)...`とする
 
 
 ## 戻り値
-`Tuples...`の全ての`tuple`型の要素型全てを取り出し、`std::`[`forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(x)`して構築される1つの`tuple`オブジェクト。
+`Tuples...`の全ての`tuple`型の要素型全てを取り出し、`std::`[`forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(x)`して構築される1つの[`tuple`](tuple.md)`オブジェクト。
 
 
 ## 備考
-実装によっては、`Tuples...` パラメータパックに含めることのできる型として、他のタプルライクな型（[`pair`](/reference/utility/pair.md)や[`array`](/reference/array/array.md)のような）を追加的にサポートする可能性がある。
+実装によっては、`Tuples...` パラメータパックに含めることのできる型として、他のタプルライクな型（[`pair`](/reference/utility/pair.md)や[`array`](/reference/array/array.md)のような）を追加的にサポートする可能性がある。（C++23からは[`tuple-like`](tuple-like.md)を満たす型をサポートする。）
 
 
 ## 例
@@ -79,4 +99,4 @@ World
 
 ## 参照
 - [N3471 Constexpr Library Additions: utilities, v3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html)
-
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>type_traits -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/type_traits.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/type_traits.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;type_traits&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt;ヘッダでは、型の特性を判定、操作するためのクラスを定義する。&lt;/p&gt;
&lt;p&gt;このライブラリに含まれるクラステンプレートは、メタ関数(meta function)と呼ばれている。&lt;/p&gt;
&lt;p&gt;本ヘッダはフリースタンディング環境でも提供される。&lt;/p&gt;
&lt;h2&gt;ヘルパークラス&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/integral_constant.html&#34;&gt;integral_constant&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定数を表す型 (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/bool_constant.html&#34;&gt;bool_constant&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真理値型の定数を表す型 (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/true_type.html&#34;&gt;true_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;を表す型 (type-alias)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/false_type.html&#34;&gt;false_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;を表す型 (type-alias)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;基本的な型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_void.html&#34;&gt;is_void&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が&lt;code&gt;void&lt;/code&gt;型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_null_pointer.html&#34;&gt;is_null_pointer&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が&lt;code&gt;nullptr_t&lt;/code&gt;型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_integral.html&#34;&gt;is_integral&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が整数型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_floating_point.html&#34;&gt;is_floating_point&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が浮動小数点型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_array.html&#34;&gt;is_array&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が配列型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer.html&#34;&gt;is_pointer&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がポインタ型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_lvalue_reference.html&#34;&gt;is_lvalue_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が左辺値参照型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_rvalue_reference.html&#34;&gt;is_rvalue_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が右辺値参照型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_member_object_pointer.html&#34;&gt;is_member_object_pointer&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がメンバ変数へのポインタ型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_member_function_pointer.html&#34;&gt;is_member_function_pointer&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がメンバ関数へのポインタ型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_enum.html&#34;&gt;is_enum&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が列挙型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_union.html&#34;&gt;is_union&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が共用型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_class.html&#34;&gt;is_class&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がクラス型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_function.html&#34;&gt;is_function&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が関数型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;組み合わせた型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_reference.html&#34;&gt;is_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が参照型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_arithmetic.html&#34;&gt;is_arithmetic&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が算術型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_fundamental.html&#34;&gt;is_fundamental&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が単純型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_object.html&#34;&gt;is_object&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がオブジェクト型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_scalar.html&#34;&gt;is_scalar&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がスカラ型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_compound.html&#34;&gt;is_compound&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が複合型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_member_pointer.html&#34;&gt;is_member_pointer&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がメンバポインタ型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_scoped_enum.html&#34;&gt;is_scoped_enum&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がスコープ付きの列挙型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;型の特性&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_const.html&#34;&gt;is_const&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が&lt;code&gt;const&lt;/code&gt;修飾型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_volatile.html&#34;&gt;is_volatile&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が&lt;code&gt;volatile&lt;/code&gt;修飾型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivial.html&#34;&gt;is_trivial&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアル型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_copyable.html&#34;&gt;is_trivially_copyable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルコピー可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_standard_layout.html&#34;&gt;is_standard_layout&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がスタンダードレイアウト型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pod.html&#34;&gt;is_pod&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がPOD型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;br /&gt;C++20から非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_literal_type.html&#34;&gt;is_literal_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がリテラル型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;br /&gt; C++17から非推奨&lt;br /&gt; C++20で削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_empty.html&#34;&gt;is_empty&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が空のクラスか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_polymorphic.html&#34;&gt;is_polymorphic&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が多相的クラスか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_abstract.html&#34;&gt;is_abstract&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が抽象クラスか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_final.html&#34;&gt;is_final&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型に&lt;code&gt;final&lt;/code&gt;が付いているかを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_aggregate.html&#34;&gt;is_aggregate&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が集成体かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_signed.html&#34;&gt;is_signed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が符号付き算術型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_unsigned.html&#34;&gt;is_unsigned&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が符号無し算術型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_bounded_array.html&#34;&gt;is_bounded_array&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が要素数の判明している配列型かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_unbounded_array.html&#34;&gt;is_unbounded_array&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が要素数の不明な配列型かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_constructible.html&#34;&gt;is_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型のコンストラクタ呼出しが適格か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_default_constructible.html&#34;&gt;is_default_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がデフォルト構築可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_copy_constructible.html&#34;&gt;is_copy_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がコピー構築可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_move_constructible.html&#34;&gt;is_move_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がムーブ構築可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_assignable.html&#34;&gt;is_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が代入可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_copy_assignable.html&#34;&gt;is_copy_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がコピー代入可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_move_assignable.html&#34;&gt;is_move_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がムーブ代入可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_destructible.html&#34;&gt;is_destructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が破棄可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_constructible.html&#34;&gt;is_trivially_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルに構築可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_default_constructible.html&#34;&gt;is_trivially_default_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルにデフォルト構築可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_copy_constructible.html&#34;&gt;is_trivially_copy_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルにコピー構築可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_move_constructible.html&#34;&gt;is_trivially_move_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルにムーブ構築可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_assignable.html&#34;&gt;is_trivially_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルに代入可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_copy_assignable.html&#34;&gt;is_trivially_copy_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルにコピー代入可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_move_assignable.html&#34;&gt;is_trivially_move_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルにムーブ代入可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_destructible.html&#34;&gt;is_trivially_destructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がトリビアルに破棄可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_constructible.html&#34;&gt;is_nothrow_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型のコンストラクタ呼出しが適格であり、かつそのコンストラクタが例外を投げないか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_default_constructible.html&#34;&gt;is_nothrow_default_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がデフォルト構築でき、かつそのデフォルトコンストラクタが例外を投げないか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_copy_constructible.html&#34;&gt;is_nothrow_copy_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がコピー構築でき、かつそのコピーコンストラクタが例外を投げないか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_constructible.html&#34;&gt;is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がムーブ構築でき、かつそのムーブコンストラクタが例外を投げないか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_assignable.html&#34;&gt;is_nothrow_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型の代入演算子呼び出しが適格であり、かつその代入演算子が例外を投げないか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_copy_assignable.html&#34;&gt;is_nothrow_copy_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がコピー代入でき、かつそのコピー代入演算子が例外を投げないか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_assignable.html&#34;&gt;is_nothrow_move_assignable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型がムーブ代入でき、かつそのムーブ代入演算子が例外を投げないか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_destructible.html&#34;&gt;is_nothrow_destructible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が破棄でき、かつそのデストラクタが例外を投げないか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/has_virtual_destructor.html&#34;&gt;has_virtual_destructor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が仮想デストラクタを持っているか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_swappable_with.html&#34;&gt;is_swappable_with&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある型とほかの型の値とがswap関数で入れ替え可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_swappable.html&#34;&gt;is_swappable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある型の値がswap関数で入れ替え可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_swappable_with.html&#34;&gt;is_nothrow_swappable_with&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある型とほかの型の値とが例外を投げずにswap関数で入れ替え可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_swappable.html&#34;&gt;is_nothrow_swappable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある型の値が例外を投げずにswap関数で入れ替え可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/has_unique_object_representations.html&#34;&gt;has_unique_object_representations&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある型のバイト表現をそのままハッシュとして利用できるかを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;型の特性についての問い合わせ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/alignment_of.html&#34;&gt;alignment_of&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型のアライメントを取得する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/rank.html&#34;&gt;rank&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;配列型の次元数を取得する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/extent.html&#34;&gt;extent&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;配列型の&lt;code&gt;i&lt;/code&gt;番目の次元の要素数を取得する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;型の関係&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_same.html&#34;&gt;is_same&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;二つの型が同じ型か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_base_of&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある型が別の型の基底クラスか調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_convertible.html&#34;&gt;is_convertible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある型から別の型へ変換可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_convertible.html&#34;&gt;is_nothrow_convertible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある型から別の型へ、例外を投げずに変換可能か調べる (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_layout_compatible.html&#34;&gt;is_layout_compatible&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つの型にレイアウト互換があるかを判定する (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_base_of.html&#34;&gt;is_pointer_interconvertible_base_of&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基底クラスと派生クラスの間でポインタ相互交換可能かを判定する (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/reference_constructs_from_temporary.html&#34;&gt;reference_constructs_from_temporary&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;参照が一時オブジェクトを直接初期化（丸括弧による初期化）で束縛した時、一時オブジェクトの寿命が延長されているかを判定する (class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html&#34;&gt;reference_converts_from_temporary&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;参照が一時オブジェクトをコピー初期化（代入形式による初期化）で束縛した時、一時オブジェクトの寿命が延長されているかを判定する (class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;const-volatile の変更&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_const.html&#34;&gt;remove_const&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型の&lt;code&gt;const&lt;/code&gt;修飾を除去する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_volatile.html&#34;&gt;remove_volatile&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型の&lt;code&gt;volatile&lt;/code&gt;修飾を除去する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cv.html&#34;&gt;remove_cv&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型の&lt;code&gt;const-volatile&lt;/code&gt;修飾を除去する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/add_const.html&#34;&gt;add_const&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型を&lt;code&gt;const&lt;/code&gt;修飾する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/add_volatile.html&#34;&gt;add_volatile&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型を&lt;code&gt;volatile&lt;/code&gt;修飾する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/add_cv.html&#34;&gt;add_cv&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型を&lt;code&gt;const-volatile&lt;/code&gt;修飾する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;参照の変更&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_reference.html&#34;&gt;remove_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型から参照を除去する(class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/add_lvalue_reference.html&#34;&gt;add_lvalue_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型に左辺値参照を追加する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/add_rvalue_reference.html&#34;&gt;add_rvalue_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型に右辺値参照を追加する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;符号の変更&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/make_signed.html&#34;&gt;make_signed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;整数型を符号付きにする (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/make_unsigned.html&#34;&gt;make_unsigned&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;整数型を符号なしにする (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;配列の変更&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_extent.html&#34;&gt;remove_extent&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;配列型から次元を除去する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_all_extents.html&#34;&gt;remove_all_extents&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;配列型から全ての次元を除去する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ポインタの変更&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/add_pointer.html&#34;&gt;add_pointer&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型にポインタを追加する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_pointer.html&#34;&gt;remove_pointer&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型からポインタを除去する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関数呼び出しに関連した特性&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_invocable.html&#34;&gt;is_invocable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数呼び出し可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_invocable_r.html&#34;&gt;is_invocable_r&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数呼び出し可能でその戻り値型がある型へ変換可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_invocable.html&#34;&gt;is_nothrow_invocable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例外を投げずに関数呼び出し可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_invocable_r.html&#34;&gt;is_nothrow_invocable_r&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例外を投げずに関数呼び出し可能でその戻り値型がある型へ変換可能かを調べる (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;その他の変換&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/type_identity.html&#34;&gt;type_identity&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;受け取った型を返す (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;aligned_storage&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメント調整された領域を作る (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;aligned_union&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメント調整された共用体領域を作る (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型の&lt;code&gt;const-volatile&lt;/code&gt;修飾と参照を除去する (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;配列と関数ポインタに関して、関数テンプレートと同様に推論された型を取得する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/enable_if.html&#34;&gt;enable_if&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時条件式が真の場合のみ有効な型 (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/conditional.html&#34;&gt;conditional&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時条件式 (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/common_type.html&#34;&gt;common_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変換可能な共通の型を取得する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/void_t.html&#34;&gt;void_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意の型をvoidへ変換する (type-alias)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/basic_common_reference.html&#34;&gt;basic_common_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;common_reference&lt;/code&gt;へアダプトする (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/common_reference.html&#34;&gt;common_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;共通の参照型を取得する (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/underlying_type.html&#34;&gt;underlying_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列挙型の基底型を取得する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/result_of.html&#34;&gt;result_of&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値の型を取得する (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/invoke_result.html&#34;&gt;invoke_result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値の型を取得する (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_reference.html&#34;&gt;unwrap_reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;型を&lt;code&gt;T&amp;amp;&lt;/code&gt;型に展開する (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_ref_decay.html&#34;&gt;unwrap_ref_decay&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;型を&lt;code&gt;T&amp;amp;&lt;/code&gt;型に展開し、型推論規則による型変換を行う (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;論理演算&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/conjunction.html&#34;&gt;conjunction&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;特性の論理積を求める (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/disjunction.html&#34;&gt;disjunction&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;特性の論理和を求める (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/negation.html&#34;&gt;negation&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;特性の論理否定を求める (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;メンバの関係性&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_with_class.html&#34;&gt;is_pointer_interconvertible_with_class&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メンバポインタとクラスの間でポインタ相互交換可能かを判定する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_corresponding_member.html&#34;&gt;is_corresponding_member&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのメンバポインタが互換な共通位置にあるかを判定する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;コンパイル時評価&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_constant_evaluated.html&#34;&gt;is_constant_evaluated&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;呼び出された時、その呼び出しがコンパイル時に行われているかを判定する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;備考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;このヘッダで定義されるテンプレートは、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/common_type.html&#34;&gt;std::common_type&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/basic_common_reference.html&#34;&gt;std::basic_common_reference&lt;/a&gt;&lt;/code&gt;を除いて、ユーザーが特殊化を追加することを禁止している&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1345.html&#34; target=&#34;_blank&#34;&gt;N1345 A Proposal to add Type Traits to the Standard Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1424.htm&#34; target=&#34;_blank&#34;&gt;N1424 A Proposal to add Type Traits to the Standard Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/type_traits/doc/html/index.html&#34; target=&#34;_blank&#34;&gt;Boost Type Traits Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/tips/type_traits.html&#34; target=&#34;_blank&#34;&gt;型特性 - Boost逆引きリファレンス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wg21.cmeerw.net/lwg/issue2581&#34; target=&#34;_blank&#34;&gt;LWG Issue 2581. Specialization of &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; variable templates should be prohibited&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++14までは&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt;で定義されるクラステンプレートの特殊化を禁止していたが、C++17で定義される変数テンプレートも特殊化の禁止対象とされた&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_reference -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/common_reference.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/type_traits/common_reference.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/common_reference.md b/reference/type_traits/common_reference.md
index 7663b85ff..5e118dda0 100644
--- a/reference/type_traits/common_reference.md
+++ b/reference/type_traits/common_reference.md
@@ -71,7 +71,7 @@ namespace std {
 
 ポインタ型やC++17までの標準ライブラリにおける普通のイテレータ型では、その`reference`型は`value_type&amp;amp;`の別名として定義されるという関係性がある。そのため、`value_type`と`reference`はどちらも`const`左辺値参照を付加することで`const value_type&amp;amp;`に変換できる（ことが期待される）。
 
-しかし、C++20から追加される`range`ライブラリの元となった`range-v3`ライブラリにおける`zip_view`（C++20には導入されていない）のプロクシイテレータのように、特殊なイテレータではそのような関係性が必ずしも成り立つとは限らない。
+しかし、C++20から追加される`range`ライブラリの元となった`range-v3`ライブラリにおける`zip_view`（標準ライブラリへはC++23で導入される）のプロキシイテレータのように、特殊なイテレータではそのような関係性が必ずしも成り立つとは限らない。
 
 このような関係性を持つ型があるとジェネリックなアルゴリズムをより簡易に書くことができるようになるなどメリットがあるため、そのような型を求めるために`common_reference`が導入された。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_invocable_r -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_invocable_r.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/type_traits/is_invocable_r.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_invocable_r.md b/reference/type_traits/is_invocable_r.md
index c207f4fcb..a5b907ce7 100644
--- a/reference/type_traits/is_invocable_r.md
+++ b/reference/type_traits/is_invocable_r.md
@@ -23,15 +23,58 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。（C++20まで。）
+
+C++23 では、型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、その結果となる戻り値の型を`S`とすると、`S`は`R`に変換可能かつ、`S`は`R`に束縛されて寿命が延長されないのであれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 結果は以下と等価である：
 
 ```cpp
+// C++17
 std::is_convertible_v&amp;lt;std::invoke_result_t&amp;lt;F, ArgsTypes...&amp;gt;, R&amp;gt;
+
+// C++23
+std::is_convertible_v&amp;lt;std::invoke_result_t&amp;lt;F, ArgsTypes...&amp;gt;, R&amp;gt; &amp;amp;&amp;amp; 
+std::reference_­converts_­from_­temporary_­v&amp;lt;R, std::invoke_result_t&amp;lt;F, ArgsTypes...&amp;gt;&amp;gt; == false
 ```
 * std::is_convertible_v[link is_convertible.md]
 * std::invoke_result_t[link invoke_result.md]
+* std::reference_­converts_­from_­temporary_­v[link /reference/type_traits/reference_converts_from_temporary.md]
+
+
+## 寿命の延長とダングリング参照
+前項での`S`を継続して使用する。以下では`S`/`R`を`S`の値/`R`の値の意味で用いる場合がある。
+
+`S`が`R`に束縛されて寿命が延長されるとは、`R`が参照、特に`const T&amp;amp;`や`T&amp;amp;&amp;amp;`である場合に発生する`S`の値に対する寿命の延長のことである。本メタ関数は実際に[*INVOKE*](/reference/concepts/Invoke.md)と`R`への変換を行う訳では無いが、本メタ関数に渡された型の値を使用して[*INVOKE*](/reference/concepts/Invoke.md)と`S`から`R`への変換が行われる場合（つまり[`invoke_r`](/reference/functional/invoke_r.md)の中）について考えてみよう。
+
+`R`が`const T&amp;amp;`または`T&amp;amp;&amp;amp;`で、かつ`S`が`rvalue`であれば、`S`を`R`へ暗黙変換する際に`S`の寿命は`R`の寿命に合わせて延長されることがある。しかしこの場合、`R`は[*INVOKE*](/reference/concepts/Invoke.md)が行われる文を寿命とするので、`S`も同様に[*INVOKE*](/reference/concepts/Invoke.md)が行われる文が終了すると同時に寿命が終了する。参照による寿命の延長は2度適用されることはないため、このような場合には常にダングリング参照が生じてしまう。
+
+これを検出し、不適格とするために[`reference_­converts_­from_­temporary_­v`](/reference/type_traits/reference_converts_from_temporary.md)を使用しているというわけなのである。
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+struct S {
+  S() { std::cout &amp;lt;&amp;lt; &amp;#34;S construct&amp;#34; &amp;lt;&amp;lt; std::endl; }
+  ~S() { std::cout &amp;lt;&amp;lt; &amp;#34;S destruct&amp;#34; &amp;lt;&amp;lt; std::endl; }
+};
+
+int main()
+{
+	using R = const S&amp;amp;;
+
+	std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
+
+	// INVOKE、つまり std::invoke の返り値である S が
+	// R に束縛されて R の寿命と同じ寿命に延長された上で std::invoke_r の返り値となる
+	// しかし R の寿命はこの1文の間だけなので、S もこの1文が終了する際に破棄される
+	const S&amp;amp; a = std::invoke_r&amp;lt;R&amp;gt;([]() { return S{}; });
+	
+	std::cout &amp;lt;&amp;lt; &amp;#34;2&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::is_invocable_r[color ff0000]
 
 
 ## 例
@@ -84,3 +127,4 @@ false
 ## 参照
 - [C++1z 関数が呼び出し可能かを判定する型特性 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/05/13/183857)
 - [Resolving GB 55, US 84, US 85, US 86](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html)
+- [P2255R2 A type trait to detect reference binding to temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reference_constructs_from_temporary -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/reference_constructs_from_temporary.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/type_traits/reference_constructs_from_temporary.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/reference_constructs_from_temporary.md b/reference/type_traits/reference_constructs_from_temporary.md
new file mode 100644
index 000000000..c02a78c88
--- /dev/null
+++ b/reference/type_traits/reference_constructs_from_temporary.md
@@ -0,0 +1,156 @@
+# reference_constructs_from_temporary
+* type_traits[meta header]
+* class template[meta id-type]
+* std[meta namespace]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class T, class U&amp;gt;
+  struct reference_constructs_from_temporary;
+
+  template&amp;lt;class T, class U&amp;gt;
+    inline constexpr bool reference_constructs_from_temporary_v
+       = reference_constructs_from_temporary&amp;lt;T, U&amp;gt;::value;
+}
+```
+
+## 概要
+参照`T`が一時オブジェクト`U`を直接初期化（丸括弧による初期化）で束縛した時、その一時オブジェクトの寿命を延長するかを判定する。
+
+[`tuple`](/reference/tuple/tuple.md)や[`pair`](/reference/utility/pair.md)のコンストラクタなど、`explicit`なコンストラクタ・変換関数におけるダングリング参照の生成を回避するために使用される。
+
+なお、コピー初期化（代入形式による初期化）における文脈では[`reference_converts_from_temporary`](reference_converts_from_temporary.md)が使用される。
+
+
+## 要件
+`T`と`U`のどちらも、完全型、`const`/`volatile`修飾された（あるいはされていない）`void`、要素数不明の配列型であること。
+
+
+## 効果
+`VAL&amp;lt;U&amp;gt;`を次のように定義する。
+
+- `U`が参照型や関数型の場合、[`declval`](/reference/utility/declval.md)`&amp;lt;U&amp;gt;()`と同じ型と値カテゴリを持つ式
+- `U`が参照型や関数型でない場合、型`U`である`pvalue`（ただし、`U`に`const`/`volatile`修飾があれば調整される）
+
+[`conjunction_v`](conjunction.md)`&amp;lt;`[`is_reference`](is_reference.md)`&amp;lt;T&amp;gt;,` [`is_constructible`](is_constructible.md)`&amp;lt;T, U&amp;gt;&amp;gt;`が`true`かつ、`T t(VAL&amp;lt;U&amp;gt;)`において`t`が一時オブジェクトの寿命を延長する場合に[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+
+
+## 備考
+多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「返り値の型が右辺値参照である関数」の返り値を束縛することを考える。（再現コードは、説明の最後に付す）
+
+この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は返り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
+
+このような場面においては、本メタ関数が`pvalue`と`xvalue`を、`pvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+
+struct S {
+  S() { std::cout &amp;lt;&amp;lt; &amp;#34;S construct&amp;#34; &amp;lt;&amp;lt; std::endl; }
+  ~S() { std::cout &amp;lt;&amp;lt; &amp;#34;S destruct&amp;#34; &amp;lt;&amp;lt; std::endl; }
+};
+
+S&amp;amp;&amp;amp; f() { return S{}; }
+
+int main() {
+  std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
+  
+  // f の返り値は s に束縛されて寿命が延長されたか？
+  // 実際にはこの宣言の1文が終了した際に f の返り値は破棄されている
+  S&amp;amp;&amp;amp; s(f());
+  
+  std::cout &amp;lt;&amp;lt; &amp;#34;2&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+```
+
+### 出力
+```
+1
+S construct
+S destruct
+2
+
+```
+
+## 例
+```cpp example
+#include &amp;lt;type_traits&amp;gt;
+
+struct A {
+	A() = default;
+	A(int) {}
+};
+
+struct B : A {
+	explicit B(int) {}
+};
+
+struct C {
+	operator struct A() { return A{}; }
+	explicit operator struct B() { return B{0}; }
+};
+
+int main()
+{
+	// OK: わかりやすく寿命が延長されるタイプ
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, int&amp;gt;);
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;const int&amp;amp;, int&amp;gt;);
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, B&amp;gt;);
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;const A&amp;amp;&amp;amp;, B&amp;gt;);
+
+	// OK: 変換されて rvalue になってから束縛されて寿命が延長されるタイプ
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, long&amp;gt;);
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, long&amp;amp;&amp;gt;);
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, long&amp;amp;&amp;amp;&amp;gt;);
+
+	// OK: explicit ではないので変換されて rvalue になってから束縛されて寿命が延長されるタイプ
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, C&amp;gt;);
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, C&amp;amp;&amp;gt;);
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, C&amp;amp;&amp;amp;&amp;gt;);
+	static_assert(std::reference_constructs_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, int&amp;gt;);
+
+
+	// NG: const ではない左辺値参照は寿命を延長しないんですタイプ
+	//     1つ目3つ目はそもそも参照そのものが構築出来ない
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;, int&amp;gt;);
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;, int&amp;amp;&amp;gt;);
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;, int&amp;amp;&amp;amp;&amp;gt;);
+
+	// NG: 構築できないパターンと右辺値参照は区別するパターン
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, int&amp;amp;&amp;gt;);
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, int&amp;amp;&amp;amp;&amp;gt;);
+
+	// NG: explicit なので変換出来ずに詰むパターン
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;B&amp;amp;&amp;amp;, C&amp;gt;);
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;B&amp;amp;&amp;amp;, C&amp;amp;&amp;gt;);
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;B&amp;amp;&amp;amp;, C&amp;amp;&amp;amp;&amp;gt;);
+	static_assert(false == std::reference_constructs_from_temporary_v&amp;lt;B&amp;amp;&amp;amp;, int&amp;gt;);
+}
+
+```
+* std::reference_constructs_from_temporary[color ff0000]
+
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ???
+- [GCC](/implementation.md#gcc): ???
+- [ICC](/implementation.md#icc): ???
+- [Visual C++](/implementation.md#visual_cpp): ???
+
+
+## 関連項目
+- [`reference_converts_from_temporary`](reference_converts_from_temporary.md)
+
+
+## 参照
+- [P2252R2 A type trait to detect reference binding to temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reference_converts_from_temporary -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/type_traits/reference_converts_from_temporary.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/reference_converts_from_temporary.md b/reference/type_traits/reference_converts_from_temporary.md
new file mode 100644
index 000000000..0cff142fc
--- /dev/null
+++ b/reference/type_traits/reference_converts_from_temporary.md
@@ -0,0 +1,152 @@
+# reference_converts_from_temporary
+* type_traits[meta header]
+* class template[meta id-type]
+* std[meta namespace]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class T, class U&amp;gt;
+  struct reference_converts_from_temporary;
+}
+```
+
+## 概要
+参照`T`が一時オブジェクト`U`をコピー初期化（代入形式による初期化）で束縛した時、その一時オブジェクトの寿命を延長するかを判定する。
+
+[*INVOKE*](/reference/concepts/Invoke.md)`&amp;lt;R&amp;gt;`など、暗黙的な型変換のみが考慮される文脈におけるダングリング参照の生成を回避するために使用される。
+
+なお、直接初期化（丸括弧による初期化）における文脈では[`reference_constructs_from_temporary`](reference_constructs_from_temporary.md)が使用される。
+
+
+## 要件
+`T`と`U`のどちらも、完全型、`const`/`volatile`修飾された（あるいはされていない）`void`、要素数不明の配列型であること。
+
+
+## 効果
+`VAL&amp;lt;U&amp;gt;`を次のように定義する。
+
+- `U`が参照型や関数型の場合、[`declval`](/reference/utility/declval.md)`&amp;lt;U&amp;gt;()`と同じ型と値カテゴリを持つ式
+- `U`が参照型や関数型でない場合、型`U`である`pvalue`（ただし、`U`に`const`/`volatile`修飾があれば調整される）
+
+[`conjunction_v`](conjunction.md)`&amp;lt;`[`is_reference`](is_reference.md)`&amp;lt;T&amp;gt;,` [`is_convertible`](is_convertible.md)`&amp;lt;U, T&amp;gt;&amp;gt;`が`true`かつ、`T t(VAL&amp;lt;U&amp;gt;)`において`t`が一時オブジェクトの寿命を延長する場合に[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+
+
+## 備考
+多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「返り値の型が右辺値参照である関数」の返り値を束縛することを考える。（再現コードは、説明の最後に付す）
+
+この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は返り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
+
+このような場面においては、本メタ関数が`pvalue`と`xvalue`を、`pvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+
+struct S {
+  S() { std::cout &amp;lt;&amp;lt; &amp;#34;S construct&amp;#34; &amp;lt;&amp;lt; std::endl; }
+  ~S() { std::cout &amp;lt;&amp;lt; &amp;#34;S destruct&amp;#34; &amp;lt;&amp;lt; std::endl; }
+};
+
+S&amp;amp;&amp;amp; f() { return S{}; }
+
+int main() {
+  std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
+  
+  // f の返り値は s に束縛されて寿命が延長されたか？
+  // 実際にはこの宣言の1文が終了した際に f の返り値は破棄されている
+  S&amp;amp;&amp;amp; s = f();
+  
+  std::cout &amp;lt;&amp;lt; &amp;#34;2&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+```
+
+### 出力
+```
+1
+S construct
+S destruct
+2
+
+```
+
+
+## 例
+```cpp example
+#include &amp;lt;type_traits&amp;gt;
+
+struct A {
+	A() = default;
+	A(int) {}
+};
+
+struct B : A {
+	explicit B(int) {}
+};
+
+struct C {
+	operator struct A() { return A{}; }
+	explicit operator struct B() { return B{0}; }
+};
+
+int main()
+{
+	// OK: わかりやすく寿命が延長されるタイプ
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, int&amp;gt;);
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;const int&amp;amp;, int&amp;gt;);
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, B&amp;gt;);
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;const A&amp;amp;&amp;amp;, B&amp;gt;);
+
+	// OK: 変換されて rvalue になってから束縛されて寿命が延長されるタイプ
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, long&amp;gt;);
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, long&amp;amp;&amp;gt;);
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, long&amp;amp;&amp;amp;&amp;gt;);
+
+	// OK: explicit ではないので変換されて rvalue になってから束縛されて寿命が延長されるタイプ
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, C&amp;gt;);
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, C&amp;amp;&amp;gt;);
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, C&amp;amp;&amp;amp;&amp;gt;);
+	static_assert(std::reference_converts_from_temporary_v&amp;lt;A&amp;amp;&amp;amp;, int&amp;gt;);
+
+
+	// NG: const ではない左辺値参照は寿命を延長しないんですタイプ
+	//     1つ目3つ目はそもそも参照そのものが構築出来ない
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;, int&amp;gt;);
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;, int&amp;amp;&amp;gt;);
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;, int&amp;amp;&amp;amp;&amp;gt;);
+
+	// NG: 構築できないパターンと右辺値参照は区別するパターン
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, int&amp;amp;&amp;gt;);
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;int&amp;amp;&amp;amp;, int&amp;amp;&amp;amp;&amp;gt;);
+
+	// NG: explicit なので変換出来ずに詰むパターン
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;B&amp;amp;&amp;amp;, C&amp;gt;);
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;B&amp;amp;&amp;amp;, C&amp;amp;&amp;gt;);
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;B&amp;amp;&amp;amp;, C&amp;amp;&amp;amp;&amp;gt;);
+	static_assert(false == std::reference_converts_from_temporary_v&amp;lt;B&amp;amp;&amp;amp;, int&amp;gt;);
+}
+
+```
+* std::reference_converts_from_temporary[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ???
+- [GCC](/implementation.md#gcc): ???
+- [ICC](/implementation.md#icc): ???
+- [Visual C++](/implementation.md#visual_cpp): ???
+
+
+## 関連項目
+- [`reference_constructs_from_temporary`](reference_constructs_from_temporary.md)
+
+
+## 参照
+- [P2252R2 A type trait to detect reference binding to temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pair -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/utility/pair.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair.md b/reference/utility/pair.md
index 23ca91554..5963f9161 100644
--- a/reference/utility/pair.md
+++ b/reference/utility/pair.md
@@ -87,6 +87,14 @@ namespace std {
 | [`(deduction_guide)`](pair/op_deduction_guide.md) | クラステンプレートの推論補助 | C++17 |
 
 
+## 特殊化
+
+| 名前                                                       | 説明                                                     | 対応バージョン |
+|------------------------------------------------------------|--------------------------------------------------------|-----------|
+| [`common_type`](pair/common_type.md)                       | 異なる[`pair`](pair.md)間の共通型を取得できるようにする特殊化        | C++23     |
+| [`basic_common_reference`](pair/basic_common_reference.md) | 異なる[`pair`](pair.md)間の共通の参照型を取得出来るようにする特殊化 | C++23     |
+
+
 ## 例
 ### 基本的な使い方 (C++03)
 ```cpp example
@@ -143,6 +151,110 @@ hello
 ```
 
 
+### プロキシ参照としての使い方（C++23）
+C++23 で[`zip_view`](/reference/ranges/zip_view.md.nolink)などが追加されたことに伴い、どちらの要素も[プロキシ参照](/reference/iterator/indirectly_writable.md)であるような`pair`は[プロキシ参照](/reference/iterator/indirectly_writable.md)として使用することが出来るようになった。
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;string_view&amp;gt;
+#include &amp;lt;format&amp;gt;
+
+struct A
+{
+	A(int i, double d)
+		: i(i)
+		, d(d)
+	{}
+
+	std::pair&amp;lt;int&amp;amp;, double&amp;amp;&amp;gt; f()
+	{
+		// this が A* なので
+		// i: int
+		// d: double
+		// ということと同じ
+		return {i, d};
+	}
+
+	std::pair&amp;lt;const int&amp;amp;, const double&amp;amp;&amp;gt; f() const
+	{
+		// this が const A* なので
+		// i: const int
+		// d: const double
+		// ということと同じ
+		return {i, d};
+	}
+
+private:
+	int    i;
+	double d;
+};
+
+int main()
+{
+	// プロキシ参照である pair の性質
+	{
+		A a{0, 0.0};
+
+		// std::pair&amp;lt;int&amp;amp;, double&amp;amp;&amp;gt;
+		/***/ auto /***/ proxy = a.f();
+
+		// const std::pair&amp;lt;int&amp;amp;, double&amp;amp;&amp;gt;
+		const auto const_proxy = a.f();
+
+		// std::pair&amp;lt;const int&amp;amp;, const double&amp;amp;&amp;gt;
+		/***/ auto /***/ proxy_to_const = std::as_const(a).f();
+
+		// const std::pair&amp;lt;const int&amp;amp;, const double&amp;amp;&amp;gt;
+		const auto const_proxy_to_const = std::as_const(a).f();
+
+		// OK（各要素が指すオブジェクトの値について、代入操作がなされる）
+		proxy       = a.f();
+		const_proxy = a.f();
+
+		// NG（各要素が指すオブジェクトを変更できない！）
+		// proxy_to_const       = a.f();
+		// const_proxy_to_const = a.f();
+	}
+
+	// 使い方
+	{
+		auto print = [](std::string_view prefix, A&amp;amp; a) {
+
+			// 構造化束縛で分解
+			// i: int&amp;amp;
+			// d: double&amp;amp;
+			auto [i, d] = a.f();
+
+			std::cout &amp;lt;&amp;lt; std::format(&amp;#34;{}: i={}, d={}\n&amp;#34;, prefix, i, d);
+		};
+
+		A a{0, 0.0}, b{1, 1.0};
+
+		print(&amp;#34;before a&amp;#34;, a);
+		print(&amp;#34;before b&amp;#34;, b);
+
+		// プロキシ参照として使える pair 同士の swap 操作で
+		// 問題なく各要素が指す先のオブジェクトについて swap 操作が行える
+		std::ranges::swap(a.f(), b.f());
+
+		print(&amp;#34;after  a&amp;#34;, a);
+		print(&amp;#34;after  b&amp;#34;, b);
+	}
+}
+
+```
+
+#### 出力
+```
+before a: i=0, d=0
+before b: i=1, d=1
+after  a: i=1, d=1
+after  b: i=0, d=0
+
+```
+
+
 ## 関連項目
 - [`std::tuple`](/reference/tuple/tuple.md)
 - [C++17 構造化束縛](/lang/cpp17/structured_bindings.md)
@@ -150,4 +262,4 @@ hello
 
 ## 参照
 - [タプル - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%BF%E3%83%97%E3%83%AB)
-
+- [P2321R2 zip](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_common_reference -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/basic_common_reference.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/utility/pair/basic_common_reference.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/basic_common_reference.md b/reference/utility/pair/basic_common_reference.md
new file mode 100644
index 000000000..068a924d8
--- /dev/null
+++ b/reference/utility/pair/basic_common_reference.md
@@ -0,0 +1,49 @@
+# basic_common_reference
+* utility[meta header]
+* std[meta namespace]
+* class template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class T1, class T2, class U1, class U2,
+    template&amp;lt;class&amp;gt; class TQual, template&amp;lt;class&amp;gt; class UQual&amp;gt;
+  struct basic_common_reference&amp;lt;pair&amp;lt;T1, T2&amp;gt;, pair&amp;lt;U1, U2&amp;gt;, TQual, UQual&amp;gt; {
+    using type = pair&amp;lt;common_reference_t&amp;lt;TQual&amp;lt;T1&amp;gt;, UQual&amp;lt;U1&amp;gt;&amp;gt;,
+                      common_reference_t&amp;lt;TQual&amp;lt;T2&amp;gt;, UQual&amp;lt;U2&amp;gt;&amp;gt;&amp;gt;;
+  };
+}
+```
+* basic_common_reference[link /reference/type_traits/basic_common_reference.md]
+
+## 概要
+[`pair`](../pair.md)について、[`common_reference`](/reference/type_traits/common_reference.md)で共通の参照型を取得できるようにアダプトする[`basic_common_reference`](/reference/type_traits/common_reference.md)の特殊化である。
+
+ユーザーが直接この特殊化を利用する必要はない。[`common_reference`](/reference/type_traits/common_reference.md)を使用すること。
+
+
+## 効果
+[`pair`](../pair.md)`&amp;lt;`[`common_reference_t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;T1&amp;gt;, UQual&amp;lt;U1&amp;gt;&amp;gt;,` [`common_reference_t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;T2&amp;gt;, UQual&amp;lt;U2&amp;gt;&amp;gt;&amp;gt;`によって得られた型をメンバ型`type`として定義する。
+
+
+## 要件
+- [`pair`](../pair.md)`&amp;lt;`[`common_reference_t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;T1&amp;gt;, UQual&amp;lt;U1&amp;gt;&amp;gt;,` [`common_reference_t`](/reference/type_traits/common_reference.md)`&amp;lt;TQual&amp;lt;T2&amp;gt;, UQual&amp;lt;U2&amp;gt;&amp;gt;&amp;gt;`が型を表すこと。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ???
+- [GCC](/implementation.md#gcc): ???
+- [ICC](/implementation.md#icc): ???
+- [Visual C++](/implementation.md#visual_cpp): ???
+
+
+## 関連項目
+- [`basic_common_reference`](/reference/type_traits/basic_common_reference.md)
+
+
+## 参照
+- [P2321R2 `zip`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/common_type.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/utility/pair/common_type.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/common_type.md b/reference/utility/pair/common_type.md
new file mode 100644
index 000000000..eb8656a05
--- /dev/null
+++ b/reference/utility/pair/common_type.md
@@ -0,0 +1,44 @@
+# common_type
+* utility[meta header]
+* std[meta namespace]
+* class template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class T1, class T2, class U1, class U2&amp;gt;
+    requires requires { typename pair&amp;lt;common_type_t&amp;lt;T1, U1&amp;gt;, common_type_t&amp;lt;T2, U2&amp;gt;&amp;gt;; }
+  struct common_type&amp;lt;pair&amp;lt;T1, T2&amp;gt;, pair&amp;lt;U1, U2&amp;gt;&amp;gt; {
+    using type = pair&amp;lt;common_type_t&amp;lt;T1, U1&amp;gt;, common_type_t&amp;lt;T2, U2&amp;gt;&amp;gt;;
+  };
+}
+```
+* common_type[link /reference/type_traits/common_type.md]
+* tuple-like[link ../tuple-like.md]
+
+## 概要
+[`pair`](../pair.md)について、どちらからも変換可能な共通の型を取得できるようにする[`common_type`](/reference/type_traits/common_type.md)の特殊化である。
+
+
+## 効果
+[`pair`](../pair.md)`&amp;lt;`[`common_type_t`](/reference/type_traits/common_type.md)`&amp;lt;T1, U1&amp;gt;,` [`common_type_t`](/reference/type_traits/common_type.md)`&amp;lt;T2, U2&amp;gt;&amp;gt;`によって得られた型をメンバ型`type`として定義する。
+
+
+## 備考
+- [`pair`](../pair.md)`&amp;lt;`[`common_type_t`](/reference/type_traits/common_type.md)`&amp;lt;T1, U1&amp;gt;,` [`common_type_t`](/reference/type_traits/common_type.md)`&amp;lt;T2, U2&amp;gt;&amp;gt;`が型を表すこと。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): 3.0
+- [GCC](/implementation.md#gcc): 4.6.1
+- [Visual C++](/implementation.md#visual_cpp): 2012
+
+## 関連項目
+- [common_type](/reference/type_traits/common_type.md)
+
+## 参照
+- [P2321R2 `zip`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_assign.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/utility/pair/op_assign.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_assign.md b/reference/utility/pair/op_assign.md
index cfb99733f..b7ec890c1 100644
--- a/reference/utility/pair/op_assign.md
+++ b/reference/utility/pair/op_assign.md
@@ -5,40 +5,80 @@
 * function[meta id-type]
 
 ```cpp
-pair&amp;amp; operator=(const pair&amp;amp; p);                          // (1) C++03
-constexpr pair&amp;amp; operator=(const pair&amp;amp; p);                // (1) C++20
+pair&amp;amp; operator=(const pair&amp;amp; p);                             // (1) C++03
+constexpr pair&amp;amp; operator=(const pair&amp;amp; p);                   // (1) C++20
+
+constexpr const pair&amp;amp; operator=(const pair&amp;amp; p) const;       // (2) C++23
 
 template &amp;lt;class U, class V&amp;gt;
-pair&amp;amp; operator=(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);                    // (2) C++03
+  pair&amp;amp; operator=(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);                     // (3) C++03
 template &amp;lt;class U, class V&amp;gt;
-constexpr pair&amp;amp; operator=(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);          // (2) C++20
+  constexpr pair&amp;amp; operator=(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);           // (3) C++20
+
+template&amp;lt;class U, class V&amp;gt;
+constexpr const pair&amp;amp; operator=(const pair&amp;lt;U, V&amp;gt;&amp;amp; p) const; // (4) C++23
+
+pair&amp;amp; operator=(pair&amp;amp;&amp;amp; p) noexcept(see below);              // (5) C++11
+constexpr pair&amp;amp; operator=(pair&amp;amp;&amp;amp; p) noexcept(see below);    // (5) C++20
 
-pair&amp;amp; operator=(pair&amp;amp;&amp;amp; p) noexcept(see below);           // (3) C++11
-constexpr pair&amp;amp; operator=(pair&amp;amp;&amp;amp; p) noexcept(see below); // (3) C++20
+constexpr const pair&amp;amp; operator=(pair&amp;amp;&amp;amp; p) const;            // (6) C++23
 
 template &amp;lt;class U, class V&amp;gt;
-pair&amp;amp; operator=(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                         // (4) C++11
+  pair&amp;amp; operator=(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                          // (7) C++11
 template &amp;lt;class U, class V&amp;gt;
-constexpr pair&amp;amp; operator=(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);               // (4) C++20
+  constexpr pair&amp;amp; operator=(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                // (7) C++20
+
+template&amp;lt;class U, class V&amp;gt;
+  constexpr const pair&amp;amp; operator=(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p) const;    // (8) C++23
+
+template&amp;lt;pair-like P&amp;gt;
+  constexpr pair&amp;amp; operator=(P&amp;amp;&amp;amp; p);                         // (9) C++23
+template&amp;lt;pair-like P&amp;gt;
+  constexpr const pair&amp;amp; operator=(P&amp;amp;&amp;amp; p) const;             // (10) C++23
 ```
+* see below[italic]
+* pair-like[link /reference/tuple/pair-like.md]
 
 ## 概要
-- (1) : 同じ型の`pair`をコピー代入する
-- (2) : 変換可能な`pair`をコピー代入する
-- (3) : 同じ型の`pair`をムーブ代入する
-- (4) : 変換可能な`pair`をムーブ代入する
+- (1) : 同じ型の[`pair`](../pair.md)をコピー代入する
+- (2) : (1) のプロキシ参照版
+- (3) : 変換可能な[`pair`](../pair.md)をコピー代入する
+- (4) : (3) のプロキシ参照版
+- (5) : 同じ型の[`pair`](../pair.md)をムーブ代入する
+- (6) : (5) のプロキシ参照版
+- (7) : 変換可能な[`pair`](../pair.md)をムーブ代入する
+- (8) : (6) のプロキシ参照版
+- (9) : [`pair-like`](/reference/tuple/pair-like.md)なオブジェクトを代入
+- (10) : (9) のプロキシ参照版
+
+[プロキシ参照](/reference/iterator/indirectly_writable.md)版とは、[プロキシ参照](/reference/iterator/indirectly_writable.md)である（要素がどちらも[プロキシ参照](/reference/iterator/indirectly_writable.md)である）[`pair`](../pair.md)が持つ各要素について、その要素の参照先へ、他の[`pair`](../pair.md)又は[`pair-like`](/reference/tuple/pair-like.md)なオブジェクトの対応する値を代入する動作を行う版である。
 
 
 ## 要件
-- (1) : [`is_copy_assignable`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;first_type&amp;gt;::value &amp;amp;&amp;amp;` [`is_copy_assignable`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;second_type&amp;gt;::value`であること
-- (2) : [`is_assignable`](/reference/type_traits/is_assignable.md)`&amp;lt;first_type&amp;amp;, const U&amp;amp;&amp;gt;::value &amp;amp;&amp;amp;` [`is_assignable`](/reference/type_traits/is_assignable.md)`&amp;lt;second_type&amp;amp;, const V&amp;amp;&amp;gt;::value`であること
-- (3) : [`is_move_assignable`](/reference/type_traits/is_move_assignable.md)`&amp;lt;first_type&amp;gt;::value &amp;amp;&amp;amp;` [`is_move_assignable`](/reference/type_traits/is_move_assignable.md)`&amp;lt;second_type&amp;gt;::value`であること
-- (4) : [`is_assignable`](/reference/type_traits/is_assignable.md)`&amp;lt;first_type&amp;amp;, U&amp;amp;&amp;amp;&amp;gt;::value &amp;amp;&amp;amp;` [`is_assignable`](/reference/type_traits/is_assignable.md)`&amp;lt;second_type&amp;amp;, V&amp;amp;&amp;amp;&amp;gt;::value`であること
+- (1) : [`is_copy_assignable`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;T1&amp;gt;::value &amp;amp;&amp;amp;` [`is_copy_assignable`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;T2&amp;gt;::value`であること
+- (2) : C++23 : [`is_copy_assignable_v`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;const T1&amp;gt; &amp;amp;&amp;amp;` [`is_copy_assignable_v`](/reference/type_traits/is_copy_assignable.md)`&amp;lt;const T2&amp;gt;`であること
+- (3) : [`is_assignable`](/reference/type_traits/is_assignable.md)`&amp;lt;T1&amp;amp;, const U&amp;amp;&amp;gt;::value &amp;amp;&amp;amp;` [`is_assignable`](/reference/type_traits/is_assignable.md)`&amp;lt;T2&amp;amp;, const V&amp;amp;&amp;gt;::value`であること
+- (4) : C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, const U&amp;amp;&amp;gt; &amp;amp;&amp;amp;` [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T2&amp;amp;, const V&amp;amp;&amp;gt;`であること
+- (5) : [`is_move_assignable`](/reference/type_traits/is_move_assignable.md)`&amp;lt;T1&amp;gt;::value &amp;amp;&amp;amp;` [`is_move_assignable`](/reference/type_traits/is_move_assignable.md)`&amp;lt;T2&amp;gt;::value`であること
+- (6) : C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, T1&amp;gt; &amp;amp;&amp;amp;` [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T2&amp;amp;, T2&amp;gt;`であること
+- (7) : [`is_assignable`](/reference/type_traits/is_assignable.md)`&amp;lt;T1&amp;amp;, U&amp;gt;::value &amp;amp;&amp;amp;` [`is_assignable`](/reference/type_traits/is_assignable.md)`&amp;lt;T2&amp;amp;, V&amp;gt;::value`であること
+- (8) : C++23 : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, U&amp;gt; &amp;amp;&amp;amp;` [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T2&amp;amp;, V&amp;gt;`であること
+- (9) : 次を全て満たすこと
+    - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;P, pair&amp;gt;`
+    - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;P&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
+    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+- (10) : 次を全て満たすこと
+    - C++23 : [`different-from`](/reference/ranges/different-from.md)`&amp;lt;P, pair&amp;gt;`
+    - C++23 : [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;P&amp;gt;`が[`ranges::subrange`](/reference/ranges/subrange.md)の特殊化でないこと
+    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T1&amp;amp;, decltype(get&amp;lt;0&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
+    - C++23 : [`is_­assignable_­v`](/reference/type_traits/is_assignable.md)`&amp;lt;const T2&amp;amp;, decltype(get&amp;lt;1&amp;gt;(`[`std​::​forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(p)))&amp;gt;`
 
 
 ## 効果
-- (1), (2) : `p.first`を`this-&amp;gt;first`に、`p.second`を`this-&amp;gt;second`にコピー代入する
-- (3), (4) : `p.first`を`this-&amp;gt;first`に、`p.second`を`this-&amp;gt;second`にムーブ代入する
+- (1), (2), (3), (4) : `p.first`を`this-&amp;gt;first`に、`p.second`を`this-&amp;gt;second`にコピー代入する
+- (5), (6), (7), (8) : `p.first`を`this-&amp;gt;first`に、`p.second`を`this-&amp;gt;second`にムーブ代入する
+- (9), (10) : `get&amp;lt;0&amp;gt;(p)`を`p.first`に、`get&amp;lt;1&amp;gt;(p)`を`p.second`に代入する
 
 
 ## 戻り値
@@ -46,7 +86,7 @@ constexpr pair&amp;amp; operator=(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);               // (4) C++20
 
 
 ## 例外
-- (3) : `is_nothrow_move_assignable&amp;lt;first_type&amp;gt;::value &amp;amp;&amp;amp; is_nothrow_move_assignable&amp;lt;second_type&amp;gt;::value`である場合、この関数は例外を決して投げない
+- (5) : [`is_nothrow_move_assignable`](/reference/type_traits/is_nothrow_move_assignable.md)`&amp;lt;T1&amp;gt;::value &amp;amp;&amp;amp;` [`is_nothrow_move_assignable`](/reference/type_traits/is_nothrow_move_assignable.md)`&amp;lt;T2&amp;gt;::value`である場合、この関数は例外を決して投げない
 
 
 ## 例
@@ -108,14 +148,14 @@ p4 : (1,abc)
 
 ## バージョン
 ### 言語
-- C++11 : (3), (4)
+- C++11 : (5), (7)
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
 - [GCC](/implementation.md#gcc): 4.6.1
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2010, 2012, 2013, 2015
-	- (1), (2)はそれより前から実装されている。
+	- (1), (3)はそれより前から実装されている。
 
 ## 参照
 - [P1032R1 Misc constexpr bits](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1032r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_constructor.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/utility/pair/op_constructor.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_constructor.md b/reference/utility/pair/op_constructor.md
index 66369277a..ad0ad1de4 100644
--- a/reference/utility/pair/op_constructor.md
+++ b/reference/utility/pair/op_constructor.md
@@ -11,7 +11,6 @@ EXPLICIT constexpr pair();                                    // (1) C++17
 explicit(see below) constexpr pair();                         // (1) C++20
 
 pair(const pair&amp;amp;) = default;                                  // (2)
-
 pair(pair&amp;amp;&amp;amp;) = default;                                       // (3) C++11
 
 pair(const T1&amp;amp; x, const T2&amp;amp; y);                               // (4) C++03
@@ -30,80 +29,105 @@ explicit(see below) constexpr pair(U&amp;amp;&amp;amp; x, V&amp;amp;&amp;amp; y);             // (5) C++20
 template &amp;lt;class U = T1, class V = T2&amp;gt;
 explicit(see below) constexpr pair(U&amp;amp;&amp;amp; x, V&amp;amp;&amp;amp; y);             // (5) C++23
 
+template&amp;lt;class U, class V&amp;gt;
+explicit(see below) constexpr pair(pair&amp;lt;U, V&amp;gt;&amp;amp; p);            // (6) C++23
+
 template &amp;lt;class U, class V&amp;gt;
-pair(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);                                    // (6) C++03
+pair(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);                                    // (7) C++03
 template &amp;lt;class U, class V&amp;gt;
-constexpr pair(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);                          // (6) C++14
+constexpr pair(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);                          // (7) C++14
 template &amp;lt;class U, class V&amp;gt;
-EXPLICIT constexpr pair(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);                 // (6) C++17
+EXPLICIT constexpr pair(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);                 // (7) C++17
 template &amp;lt;class U, class V&amp;gt;
-explicit(see below) constexpr pair(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);      // (6) C++20
+explicit(see below) constexpr pair(const pair&amp;lt;U, V&amp;gt;&amp;amp; p);      // (7) C++20
 
 template &amp;lt;class U, class V&amp;gt;
-pair(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                                         // (7) C++11
+pair(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                                         // (8) C++11
 template &amp;lt;class U, class V&amp;gt;
-constexpr pair(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                               // (7) C++14
+constexpr pair(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                               // (8) C++14
 template &amp;lt;class U, class V&amp;gt;
-EXPLICIT constexpr pair(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                      // (7) C++17
+EXPLICIT constexpr pair(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);                      // (8) C++17
 template &amp;lt;class U, class V&amp;gt;
-explicit(see below) constexpr pair(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);           // (7) C++20
+explicit(see below) constexpr pair(pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);           // (8) C++20
+
+template&amp;lt;class U, class V&amp;gt;
+explicit(see below) constexpr pair(const pair&amp;lt;U, V&amp;gt;&amp;amp;&amp;amp; p);     // (9) C++23
+
+template&amp;lt;pair-like P&amp;gt;
+explicit(see below) constexpr pair(P&amp;amp;&amp;amp; p);                    // (10) C++23
 
 template &amp;lt;class... Args1, class... Args2&amp;gt;
 pair(piecewise_construct_t,
      tuple&amp;lt;Args1...&amp;gt; first_args,
-     tuple&amp;lt;Args2...&amp;gt; second_args);                            // (8) C++11
+     tuple&amp;lt;Args2...&amp;gt; second_args);                            // (11) C++11
 template &amp;lt;class... Args1, class... Args2&amp;gt;
 constexpr pair(piecewise_construct_t,
                tuple&amp;lt;Args1...&amp;gt; first_args,
-               tuple&amp;lt;Args2...&amp;gt; second_args);                  // (8) C++20
+               tuple&amp;lt;Args2...&amp;gt; second_args);                  // (11) C++20
 ```
 * EXPLICIT[italic]
 * piecewise_construct_t[link /reference/utility/piecewise_construct_t.md]
 * tuple[link /reference/tuple/tuple.md]
+* pair-like[link /reference/tuple/tuple-like.md]
 * see below[italic]
 
 ## 概要
-`pair`オブジェクトを構築する。
+[`pair`](../pair.md)オブジェクトを構築する。
 
-- (1) : `first`と`second`を初期化して構築
+- (1) : デフォルトコンストラクタ（`first`と`second`を初期化して構築）
 - (2) : コピーコンストラクタ
 - (3) : ムーブコンストラクタ
-- (4) : `first`と`second`の初期値を受け取って構築
-- (5) : `first`と`second`に変換可能な型の値を受け取ってムーブ構築
-- (6) : `first`と`second`に変換可能な`pair`型の値を受け取って構築
-- (7) : `first`と`second`に変換可能なpair型の右辺値を受け取って構築
-- (8) : `first`と`second`のコンストラクタ引数を受け取り、`first_args`と`second_args`それぞれの要素から`first`と`second`をムーブ構築
+- (4) : `first`と`second`の変換可能な型の値から構築
+- (5) : `first`と`second`に変換可能な型の値からムーブ構築
+- (6) : 変換可能な他の[`pair`](../pair.md)オブジェクトから構築
+- (7) : 変換可能な他の[`pair`](../pair.md)オブジェクトから構築
+- (8) : 変換可能な他の[`pair`](../pair.md)オブジェクトからムーブ構築
+- (9) : 変換可能な他の[`pair`](../pair.md)オブジェクトから構築
+- (10) : [`pair-like`](/reference/tuple/tuple-like.md)なオブジェクトから構築
+- (11) : `first`と`second`のコンストラクタ引数を受け取り、`first_args`と`second_args`それぞれの要素から`first`と`second`をムーブ構築
 
 
 ## テンプレートパラメータ制約
 - (1) :
-    - `first_type`と`second_type`が[`is_default_constructible`](/reference/type_traits/is_default_constructible.md)`&amp;lt;T&amp;gt;::value == true`であること
+    - `first_type`と`second_type`がどちらも[`is_default_constructible`](/reference/type_traits/is_default_constructible.md)`&amp;lt;T&amp;gt;::value == true`であること
 - (4) :
-    - `first_type`と`second_type`が[`is_copy_constructible`](/reference/type_traits/is_copy_constructible.md)`&amp;lt;T&amp;gt;::value == true`であること
+    - `first_type`と`second_type`がどちらも[`is_copy_constructible`](/reference/type_traits/is_copy_constructible.md)`&amp;lt;T&amp;gt;::value == true`であること
 - (5) :
     - [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;first_type, U&amp;amp;&amp;amp;&amp;gt;::value &amp;amp;&amp;amp;` [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;second_type, V&amp;amp;&amp;amp;&amp;gt;::value`であること
     - C++14まで : `U`が`first_type`に暗黙変換可能でない場合、もしくは`V`が`second_type`に暗黙変換可能でない場合、この関数はオーバーロード解決から除外される
-- (6) :
+- (6)-(10) :
+    - C++23 : `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して、[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;first_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p)))&amp;gt; &amp;amp;&amp;amp;` [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;second_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p)))&amp;gt;`であること
+- (7) :
     - [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;first_type, const U&amp;amp;&amp;gt;::value &amp;amp;&amp;amp;` [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;second_type, const V&amp;amp;&amp;gt;::value`であること
     - C++14まで : `const U&amp;amp;`が`first_type`に暗黙変換可能でない場合、もしくは`const V&amp;amp;`が`second_type`に暗黙変換可能でない場合、この関数はオーバーロード解決から除外される
-- (7) :
+    - C++23 : (6)-(10) での定義参照
+- (8) :
     - [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;first_type, U&amp;amp;&amp;amp;&amp;gt;::value &amp;amp;&amp;amp;` [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;second_type, V&amp;amp;&amp;amp;&amp;gt;::value`であること
     - C++14まで : `U`が`first_type`に暗黙変換可能でない場合、もしくは`V`が`second_type`に暗黙変換可能でない場合、この関数はオーバーロード解決から除外される
-- (8) :
-    - `is_constructible&amp;lt;first_type, Args1&amp;amp;&amp;amp;...&amp;gt;::value &amp;amp;&amp;amp; is_constructible&amp;lt;second_type, Args2&amp;amp;&amp;amp;...&amp;gt;::value`であること
+    - C++23 : (6)-(10) での定義参照
+- (11) :
+    - [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;first_type, Args1&amp;amp;&amp;amp;...&amp;gt;::value &amp;amp;&amp;amp;` [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;second_type, Args2&amp;amp;&amp;amp;...&amp;gt;::value`であること
 
 
 ## 備考
 - (1) :
-    - C++17 : `first_type`と`second_type`のどちらかが非暗黙にデフォルト構築できる場合、この関数は`explicit`となる
+    - C++17 : `first_type`と`second_type`のどちらかが非暗黙にデフォルト構築できない場合、`explicit`指定される
 - (4) :
-    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const first_type&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const second_type&amp;amp;, second_type&amp;gt;`である場合、この関数は`explicit`となる
+    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const first_type&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const second_type&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
 - (5) :
-    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、この関数は`explicit`になる
-- (6) :
-    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U1&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U2&amp;amp;, second_type&amp;gt;`である場合、この関数は`explicit`となる
+    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
+    - C++23 : [`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_­type, U1&amp;amp;&amp;amp;&amp;gt; ||` [`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_­type, U2&amp;amp;&amp;amp;&amp;gt;`である場合、このコンストラクタは削除定義される
+- (6)-(10) :
+    - `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して
+    - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p))), T1&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p))), T2&amp;gt;`である場合、`explicit`指定される
+    - C++23 : [`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_­type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p)))&amp;gt; ||` [`reference_­constructs_­from_­temporary_­v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_­type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p)))&amp;gt;`である場合、このコンストラクタは削除定義される
 - (7) :
-    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、この関数は`explicit`となる
+    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U1&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U2&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
+    - C++23 : (6)-(10) での定義参照
+- (8) :
+    - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
+    - C++23 : (6)-(10) での定義参照
+
 - C++17では、コンストラクタの各オーバーロードが条件付きで`explicit`となるよう規定された。これは、以下のような初期化子リストを使用したC++17での初期化が不適格になっていたため、適格になるようにするための変更である：
     ```cpp
     std::tuple&amp;lt;int, int&amp;gt; pixel_coordinates()
@@ -117,6 +141,13 @@ constexpr pair(piecewise_construct_t,
 
     - この変更はC++17に対するものであるが、コンパイラが早期に対応していたため、一部処理系ではC++14の段階から適格となっていた
 
+- C++23 では、ダングリング参照の作成が簡単にできていた状態を改善するべく、[`reference_constructs_from_temporary`](/reference/type_traits/reference_constructs_from_temporary.md)が追加され、ダングリング参照が作成される場合には不適格とするようになった :
+    ```cpp
+    // コンストラクタ引数で std::string が構築され
+    // その一時オブジェクトが束縛されるため、ダングリング参照となっていた
+    // C++23 からは不適格であり、コンパイルエラー等で未然に防がれる
+    std::pair&amp;lt;const std::string&amp;amp;, const std::string&amp;amp;&amp;gt; x(&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;);
+    ```
 
 ## 例
 ```cpp example
@@ -177,13 +208,13 @@ int main()
     print(&amp;#34;p3&amp;#34;, p3);
   }
 
-  // (4) firstとsecondの初期値を受け取って構築
+  // (4) firstとsecondの初期値から構築
   {
     std::pair&amp;lt;int, std::string&amp;gt; p4(1, std::string(&amp;#34;abc&amp;#34;));
     print(&amp;#34;p4&amp;#34;, p4);
   }
 
-  // (5) firstとsecondの右辺値を受け取ってムーブ構築
+  // (5) firstとsecondの右辺値からムーブ構築
   {
     int x = 1;
     std::string s = &amp;#34;abc&amp;#34;;
@@ -191,21 +222,21 @@ int main()
     print(&amp;#34;p5&amp;#34;, p5);
   }
 
-  // (6) 変換可能なpairから構築
+  // (7) 変換可能なpairから構築
   {
     std::pair&amp;lt;int, const char*&amp;gt; p(1, &amp;#34;abc&amp;#34;);
     std::pair&amp;lt;int, std::string&amp;gt; p6 = p;
     print(&amp;#34;p6&amp;#34;, p6);
   }
 
-  // (7) 変換可能なpairからムーブ構築
+  // (8) 変換可能なpairからムーブ構築
   {
     std::pair&amp;lt;int, const char*&amp;gt; p(1, &amp;#34;abc&amp;#34;);
     std::pair&amp;lt;int, std::string&amp;gt; p7 = std::move(p);
     print(&amp;#34;p7&amp;#34;, p7);
   }
 
-  // (8) first_typeとsecond_typeのコンストラクタ引数を受け取って構築
+  // (11) first_typeとsecond_typeのコンストラクタ引数から構築
   {
     std::pair&amp;lt;X, Y&amp;gt; p8(std::piecewise_construct,
                        std::make_tuple(1, 2, 3),
@@ -241,7 +272,7 @@ p8 : (X(1 2 3),Y(4 5))
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2010, 2012, 2013, 2015
 	- C++03で規定されていたものは、2010より前のバージョンから実装されている。
-	- 2010までは、(8) `std::piecewise_construct`版が実装されていない。
+	- 2010までは、(11) `std::piecewise_construct`版が実装されていない。
 	- 2013までは、デフォルトコンストラクタに`constexpr`が付与されていない。
 
 
@@ -251,7 +282,7 @@ p8 : (X(1 2 3),Y(4 5))
 
 ## 参照
 - [N2345 Placement Insert for Containers (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2345.pdf)
-    - (8)の最初の提案
+    - (11)の最初の提案
 - [N3471 Constexpr Library Additions: utilities, v3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html)
 - [N4387 Improving Pair and Tuple (Revision 3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387)
     - C++17での条件付き`explicit`の導入
@@ -260,3 +291,9 @@ p8 : (X(1 2 3),Y(4 5))
     - C++20での`explicit(bool)`構文への対応
 - [P1951R1 Default Arguments for `pair`&amp;#39;s Forwarding Constructor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1951r1.html)
     - C++23での`{}`完全転送への対応
+- [P2165R4 Compatibility between `tuple`, `pair` and *tuple-like* objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
+    - [`pair-like`](/reference/tuple/tuple-like.md)なオブジェクトからの構築
+- [P2255R2 A type trait to detect reference binding to temporary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r2.html)
+    - 参照型を要素に持つ場合にダングリング参照が容易に作成できていたのを不適格にする
+- [P2321R2 `zip`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html#pair)
+    - すべての要素が[プロキシ参照](/reference/iterator/indirectly_writable.md)の場合、[プロキシ参照](/reference/iterator/indirectly_writable.md)として使用できるようにする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>vector -- P2165R4(#1083), P2255R2(#1070), P2321R2(#1063) - P2165R4, P2255R2: 全対応 - P2321R2: `pair`/`tuple`/`vector&lt;bool&gt;::reference`について対応 - 一部説明専用コンセプトを独立ページへ - `not-same-as`を`different-from`へ変更</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector.html"/>
      <id>b2f6285e94de2248a57d9dedff0fb64677e15227:reference/vector/vector.md</id>
      <updated>2023-02-01T09:02:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector.md b/reference/vector/vector.md
index d29357f07..058a58211 100644
--- a/reference/vector/vector.md
+++ b/reference/vector/vector.md
@@ -174,18 +174,22 @@ namespace std {
 
 この特殊化はメモリ領域を最小化するために提供されていて、各要素は1bitの領域のみを必要とする。
 
-`vector&amp;lt;bool&amp;gt;::reference`は`bool`への参照ではなく、領域内の1bitを指す型であり、以下のようなインタフェースである (`constexpr`はC++20から付加される)。
+`vector&amp;lt;bool&amp;gt;::reference`は`bool`への参照ではなく、領域内の1bitを指す型であり、以下のようなインタフェースである (`noexcept`はC++11から、`constexpr`はC++20から付加される)。
+
+C++23には`vector&amp;lt;bool&amp;gt;::iterator`が出力イテレータとなるために、`vector&amp;lt;bool&amp;gt;::reference`が`const`修飾を持つ`bool`からの代入演算子が追加され、[`indirectly_writable&amp;lt;vector&amp;lt;bool&amp;gt;::iterator,` `bool&amp;gt;`](/reference/iterator/indirectly_writable.md)がモデルを満たすようになった。
 
 ```cpp
 class vector&amp;lt;bool&amp;gt;::reference {
   friend class vector;
-  constexpr reference();                              // コンストラクタは非公開
+  constexpr reference();                                       // コンストラクタは非公開
 public:
+  constexpr reference(const reference&amp;amp;) = default;             // コピーコンストラクタ（C++17）
   constexpr ~reference();
-  constexpr operator bool() const;                    // boolへの暗黙変換
-  constexpr reference&amp;amp; operator=(const bool x);       // boolからの代入
-  constexpr reference&amp;amp; operator=(const reference&amp;amp; x); // vector&amp;lt;bool&amp;gt;のビットからの代入
-  constexpr void flip();                              // ビットの反転
+  constexpr operator bool() const noexcept;                    // boolへの暗黙変換
+  constexpr reference&amp;amp; operator=(const bool x) noexcept;       // boolからの代入
+  constexpr reference&amp;amp; operator=(const reference&amp;amp; x) noexcept; // vector&amp;lt;bool&amp;gt;のビットからの代入
+  constexpr const reference&amp;amp; operator=(bool x) const noexcept; // *thisがconst時のboolからの代入（C++23）
+  constexpr void flip() noexcept;                              // ビットの反転
 }
 ```
 
@@ -390,6 +394,7 @@ v[3] : 0
 ```
 
 `vector&amp;lt;bool&amp;gt;`の要素は参照するとプロキシオブジェクトのコピーが返ってくるため、RandomAccessIteratorの要件を満たさない。
+ただし、C++20以降のランダムアクセスイテレータの定義である[`random_access_iterator`](/reference/iterator/random_access_iterator.md)のモデルは満たす。
 
 
 ### 定数式内でvectorを使用する (C++20)
@@ -437,5 +442,4 @@ int main()
 - 可変長のビット配列の実装としては、Boost C++ Librariesの[`dynamic_bitset`](http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html)がある。
 - [N2669 Thread-Safety in the Standard Library (Rev 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2669.htm)
 - [N4510 Minimal incomplete type support for standard containers, revision 4](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4510.html)
-- [P2286R8 Formatting Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html)
-    - C++23から、Range・コンテナ、`pair`、`tuple`のフォーマット出力、および文字・文字列のデバッグ指定 (`&amp;#34;?&amp;#34;`) が追加された
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tomolatoon</name>
        <email>tomo2000tomo170@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>expected -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected.md b/reference/expected/expected.md
index 990f3020f..e002aae20 100644
--- a/reference/expected/expected.md
+++ b/reference/expected/expected.md
@@ -49,11 +49,12 @@ namespace std {
 |-----------------|----------------|-------|
 | [`operator-&amp;gt;`](expected/op_arrow.md) | 正常値へのメンバアクセス | C++23 |
 | [`operator*`](expected/op_deref.md) | 正常値への間接参照 | C++23 |
-| [`operator bool`](expected/op_bool.md.nolink) | 正常値を保持しているかを判定する | C++23 |
-| [`has_value`](expected/has_value.md.nolink) | 正常値を保持しているかを判定する | C++23 |
-| [`value`](expected/value.md.nolink) | 正常値を取得する | C++23 |
-| [`error`](expected/error.md.nolink) | エラー値を取得する | C++23 |
+| [`operator bool`](expected/op_bool.md) | 正常値を保持しているかを判定する | C++23 |
+| [`has_value`](expected/has_value.md) | 正常値を保持しているかを判定する | C++23 |
+| [`value`](expected/value.md) | 正常値を取得する | C++23 |
+| [`error`](expected/error.md) | エラー値を取得する | C++23 |
 | [`value_or`](expected/value_or.md.nolink) | 正常値もしくは指定された値を取得する | C++23 |
+| [`error_or`](expected/error_or.md.nolink) | エラー値もしくは指定された値を取得する | C++23 |
 
 ### モナド操作
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>error -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/error.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected/error.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/error.md b/reference/expected/expected/error.md
new file mode 100644
index 000000000..5ac4883f9
--- /dev/null
+++ b/reference/expected/expected/error.md
@@ -0,0 +1,70 @@
+# error
+* expected[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* expected[meta class]
+* cpp23[meta cpp]
+
+```cpp
+constexpr const E&amp;amp; error() const &amp;amp; noexcept;   // (1)
+constexpr E&amp;amp; error() &amp;amp; noexcept;               // (2)
+constexpr const E&amp;amp;&amp;amp; error() const &amp;amp;&amp;amp; noexcept; // (3)
+constexpr E&amp;amp;&amp;amp; error() &amp;amp;&amp;amp; noexcept;             // (4)
+```
+
+## 概要
+エラー値を取得する。
+
+
+## 戻り値
+動作説明用のメンバ変数として、エラー値を保持する`unex`を導入する。
+
+- (1), (2) : [`has_value()`](has_value.md) `== false`ならば、`unex`
+- (3), (4) : [`has_value()`](has_value.md) `== false`ならば、[`std::move`](/reference/utility/move.md)`(unex)`
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;expected&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  std::expected&amp;lt;int, std::string&amp;gt; x = std::unexpected{&amp;#34;ERR&amp;#34;};
+  assert(not x.has_value());
+  std::cout &amp;lt;&amp;lt; x.error() &amp;lt;&amp;lt; std::endl;
+}
+```
+* error()[color ff0000]
+* has_value()[link has_value.md]
+* std::unexpected[link ../unexpected.md]
+
+### 出力
+```
+ERR
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): 16.0
+- [GCC](/implementation.md#gcc): 12.1
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`error_or`](error_or.md.nolink)
+
+
+## 参照
+- [P0323R12 std::expected](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0323r12.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>has_value -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/has_value.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected/has_value.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/has_value.md b/reference/expected/expected/has_value.md
new file mode 100644
index 000000000..a828c2a92
--- /dev/null
+++ b/reference/expected/expected/has_value.md
@@ -0,0 +1,65 @@
+# has_value
+* expected[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* expected[meta class]
+* cpp23[meta cpp]
+
+```cpp
+constexpr bool has_value() const noexcept;
+```
+
+## 概要
+正常値を保持しているかを判定する。
+
+
+## 戻り値
+正常値を保持しているなら`true`を返し、エラー値を保持しているなら`false`を返す。
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;expected&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  std::expected&amp;lt;std::string, int&amp;gt; x = &amp;#34;Hello&amp;#34;;
+  std::cout &amp;lt;&amp;lt; x.has_value() &amp;lt;&amp;lt; std::endl;
+
+  std::expected&amp;lt;std::string, int&amp;gt; y = std::unexpected{42};
+  std::cout &amp;lt;&amp;lt; y.has_value() &amp;lt;&amp;lt; std::endl;
+}
+```
+* has_value[color ff0000]
+* std::unexpected[link ../unexpected.md]
+
+### 出力
+```
+1
+0
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): 16.0
+- [GCC](/implementation.md#gcc): 12.1
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`operator bool`](op_bool.md)
+
+
+## 参照
+- [P0323R12 std::expected](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0323r12.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-&gt; -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/op_arrow.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected/op_arrow.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/op_arrow.md b/reference/expected/expected/op_arrow.md
index 8ee18c8a0..dc0a82aa5 100644
--- a/reference/expected/expected/op_arrow.md
+++ b/reference/expected/expected/op_arrow.md
@@ -15,7 +15,7 @@ constexpr T* operator-&amp;gt;() noexcept;              // (2)
 
 
 ## 事前条件
-[`has_value()`](has_value.md.nolink) `== true`
+[`has_value()`](has_value.md) `== true`
 
 
 ## 戻り値
@@ -64,7 +64,8 @@ int main()
 
 ## 関連項目
 - [`operator*`](op_deref.md)
-- [`value`](value.md.nolink)
+- [`value()`](value.md)
+- [`value_or()`](value_or.md.nolink)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/op_assign.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected/op_assign.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/op_assign.md b/reference/expected/expected/op_assign.md
index 0f9011829..3b1023df3 100644
--- a/reference/expected/expected/op_assign.md
+++ b/reference/expected/expected/op_assign.md
@@ -93,27 +93,27 @@ constexpr void reinit-expected(T&amp;amp; newval, U&amp;amp; oldval, Args&amp;amp;&amp;amp;... args) {
 
 
 ## 効果
-- (1) : 次の処理を行ったのち、例外が送出されなければ、`has_val = rhs.`[`has_value()`](has_value.md.nolink)`; return *this;`
+- (1) : 次の処理を行ったのち、例外が送出されなければ、`has_val = rhs.`[`has_value()`](has_value.md)`; return *this;`
     - `this`と`rhs`が共に正常値を保持していたら、`val =` [`*rhs`](op_deref.md)
-    - `this`が正常値を保持し、`rhs`がエラー値を保持していたら、`reinit-expected(unex, val, rhs.`[`error()`](error.md.nolink)`)`
+    - `this`が正常値を保持し、`rhs`がエラー値を保持していたら、`reinit-expected(unex, val, rhs.`[`error()`](error.md)`)`
     - `this`がエラーを保持し、`rhs`が正常値を保持していたら、`reinit-expected(val, unex,` [`*rhs`](op_deref.md)`)`
-    - `this`と`rhs`が共にエラー値を保持していたら、`unex = rhs.`[`error()`](error.md.nolink)
-- (2) : 次の処理を行ったのち、例外が送出されなければ、`has_val = rhs.`[`has_value()`](has_value.md.nolink)`; return *this;`
+    - `this`と`rhs`が共にエラー値を保持していたら、`unex = rhs.`[`error()`](error.md)
+- (2) : 次の処理を行ったのち、例外が送出されなければ、`has_val = rhs.`[`has_value()`](has_value.md)`; return *this;`
     - `this`と`rhs`が共に正常値を保持していたら、`val =` [`std::move`](/reference/utility/move.md)`(`[`*rhs`](op_deref.md)`)`
-    - `this`が正常値を保持し、`rhs`がエラー値を保持していたら、`reinit-expected(unex, val,` [`std::move`](/reference/utility/move.md)`(rhs.`[`error()`](error.md.nolink)`))`
+    - `this`が正常値を保持し、`rhs`がエラー値を保持していたら、`reinit-expected(unex, val,` [`std::move`](/reference/utility/move.md)`(rhs.`[`error()`](error.md)`))`
     - `this`がエラーを保持し、`rhs`が正常値を保持していたら、`reinit-expected(val, unex,` [`std::move`](/reference/utility/move.md)`(`[`*rhs`](op_deref.md)`))`
-    - `this`と`rhs`が共にエラー値を保持していたら、`unex` [`std::move`](/reference/utility/move.md)`(rhs.`[`error()`](error.md.nolink)`)`
+    - `this`と`rhs`が共にエラー値を保持していたら、`unex` [`std::move`](/reference/utility/move.md)`(rhs.`[`error()`](error.md)`)`
 - (3) : 次の処理と等価
     - `this`が正常値を保持していたら、`val =` [`std::forward`](/reference/utility/forward.md)`&amp;lt;U&amp;gt;(v)`
     - `this`がエラー値を保持していたら、`reinit-expected(val, unex,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;U&amp;gt;(v)); has_val = true;`
 - (4) : 次の処理と等価
-    - `this`が正常値を保持していたら、`reinit-expected(unex, val,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;const G&amp;amp;&amp;gt;(e.`[`error()`](../unexpectederror.md.nolink)`));
+    - `this`が正常値を保持していたら、`reinit-expected(unex, val,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;const G&amp;amp;&amp;gt;(e.`[`error()`](../unexpected/error.md.nolink)`));
 has_val = false;`
     - `this`がエラー値を保持していたら、`unex =` [`std::forward`](/reference/utility/forward.md)`&amp;lt;const G&amp;amp;&amp;gt;(e.`[`error()`](../unexpected/error.md.nolink)`);`
 - (5) : 次の処理と等価
-    - `this`が正常値を保持していたら、`reinit-expected(unex, val,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;G&amp;gt;(e.`[`error()`](../unexpectederror.md.nolink)`));
+    - `this`が正常値を保持していたら、`reinit-expected(unex, val,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;G&amp;gt;(e.`[`error()`](../unexpected/error.md.nolink)`));
 has_val = false;`
-    - `this`がエラー値を保持していたら、`unex =` [`std::forward`](/reference/utility/forward.md)`&amp;lt;G&amp;gt;(e.`[`error()`](../unexpectederror.md.nolink)`);`
+    - `this`がエラー値を保持していたら、`unex =` [`std::forward`](/reference/utility/forward.md)`&amp;lt;G&amp;gt;(e.`[`error()`](../unexpected/error.md.nolink)`);`
 
 
 ## 戻り値
@@ -221,9 +221,9 @@ int main()
   }
 }
 ```
-* has_value[link has_value.md.nolink]
-* value[link value.md.nolink]
-* error[link error.md.nolink]
+* has_value[link has_value.md]
+* value[link value.md]
+* error[link error.md]
 * std::unexpected[link ../unexpected.md]
 * std::make_unique[link /reference/memory/make_unique.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator bool -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/op_bool.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected/op_bool.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/op_bool.md b/reference/expected/expected/op_bool.md
new file mode 100644
index 000000000..684f32e4b
--- /dev/null
+++ b/reference/expected/expected/op_bool.md
@@ -0,0 +1,77 @@
+# operator bool
+* expected[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* expected[meta class]
+* cpp23[meta cpp]
+
+```cpp
+constexpr explicit operator bool() const noexcept;
+```
+
+## 概要
+正常値を保持しているかを判定する。
+
+
+## 戻り値
+正常値を保持しているなら`true`を返し、エラー値を保持しているなら`false`を返す。
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;expected&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  std::expected&amp;lt;std::string, int&amp;gt; x = &amp;#34;Hello&amp;#34;;
+  if (x) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;val=&amp;#34; &amp;lt;&amp;lt; *x &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;unex=&amp;#34; &amp;lt;&amp;lt; x.error() &amp;lt;&amp;lt; std::endl;
+  }
+
+  std::expected&amp;lt;std::string, int&amp;gt; y = std::unexpected{42};
+  if (y) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;val=&amp;#34; &amp;lt;&amp;lt; *y &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;unex=&amp;#34; &amp;lt;&amp;lt; y.error() &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* (x)[color ff0000]
+* (y)[color ff0000]
+* *x[link op_deref.md]
+* *y[link op_deref.md]
+* error()[link error.md]
+* std::unexpected[link ../unexpected.md]
+
+### 出力
+```
+val=Hello
+unex=42
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): 16.0
+- [GCC](/implementation.md#gcc): 12.1
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`operator bool`](op_bool.md)
+
+
+## 参照
+- [P0323R12 std::expected](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0323r12.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/op_constructor.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected/op_constructor.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/op_constructor.md b/reference/expected/expected/op_constructor.md
index b2994975d..564f2e7f3 100644
--- a/reference/expected/expected/op_constructor.md
+++ b/reference/expected/expected/op_constructor.md
@@ -103,10 +103,10 @@ constexpr bool converts-from-any-cvref =
 
 ## 効果
 - (1) : 正常値を値初期化して保持する。
-- (2) : `rhs`が正常値を保持していれば、[`*rhs`](op_deref.md)で正常値を直接非リスト初期化する。そうでなければ、`rhs.`[`error()`](error.md.nolink)でエラー値を直接非リスト初期化する。
-- (3) : `rhs`が正常値を保持していれば、[`std::move`](/reference/utility/move.md)`(`[`*rhs`](op_deref.md)`)`で正常値を直接非リスト初期化する。そうでなければ、[`std::move`](/reference/utility/move.md)`(rhs.`[`error()`](error.md.nolink)`)`でエラー値を直接非リスト初期化する。
-- (4) : `rhs`が正常値を保持していれば、[`std::forward`](/reference/utility/forward.md)`&amp;lt;const U&amp;amp;&amp;gt;(`[`*rhs`](op_deref.md)`)`で正常値を直接非リスト初期化する。そうでなければ、[`std::forward`](/reference/utility/forward.md)`&amp;lt;const G&amp;amp;&amp;gt;(rhs.`[`error()`](error.md.nolink)`)`でエラー値を直接非リスト初期化する。
-- (5) : `rhs`が正常値を保持していれば、[`std::forward`](/reference/utility/forward.md)`&amp;lt;U&amp;gt;(`[`*rhs`](op_deref.md)`)`で正常値を直接非リスト初期化する。そうでなければ、[`std::forward`](/reference/utility/forward.md)`&amp;lt;G&amp;gt;(rhs.`[`error()`](error.md.nolink)`)`でエラー値を直接非リスト初期化する。
+- (2) : `rhs`が正常値を保持していれば、[`*rhs`](op_deref.md)で正常値を直接非リスト初期化する。そうでなければ、`rhs.`[`error()`](error.md)でエラー値を直接非リスト初期化する。
+- (3) : `rhs`が正常値を保持していれば、[`std::move`](/reference/utility/move.md)`(`[`*rhs`](op_deref.md)`)`で正常値を直接非リスト初期化する。そうでなければ、[`std::move`](/reference/utility/move.md)`(rhs.`[`error()`](error.md)`)`でエラー値を直接非リスト初期化する。
+- (4) : `rhs`が正常値を保持していれば、[`std::forward`](/reference/utility/forward.md)`&amp;lt;const U&amp;amp;&amp;gt;(`[`*rhs`](op_deref.md)`)`で正常値を直接非リスト初期化する。そうでなければ、[`std::forward`](/reference/utility/forward.md)`&amp;lt;const G&amp;amp;&amp;gt;(rhs.`[`error()`](error.md)`)`でエラー値を直接非リスト初期化する。
+- (5) : `rhs`が正常値を保持していれば、[`std::forward`](/reference/utility/forward.md)`&amp;lt;U&amp;gt;(`[`*rhs`](op_deref.md)`)`で正常値を直接非リスト初期化する。そうでなければ、[`std::forward`](/reference/utility/forward.md)`&amp;lt;G&amp;gt;(rhs.`[`error()`](error.md)`)`でエラー値を直接非リスト初期化する。
 - (6) : [`std::forward`](/reference/utility/forward.md)`&amp;lt;U&amp;gt;(v)`で正常値を直接非リスト初期化する。
 - (7) : [`std::forward`](/reference/utility/forward.md)`&amp;lt;const G&amp;amp;&amp;gt;(e.`[`error()`](../unexpected/error.md.nolink)`)`でエラー値を直接非リスト初期化する。
 - (8) : [`std::forward`](/reference/utility/forward.md)`&amp;lt;G&amp;gt;(e.`[`error()`](../unexpected/error.md.nolink)`)`でエラー値を直接非リスト初期化する。
@@ -119,8 +119,8 @@ constexpr bool converts-from-any-cvref =
 ## 事後条件
 - (1) : 正常値を保持している。
 - (2) : `rhs`が正常値を保持する場合は`*this`も正常値を保持し、`rhs`がエラー値を保持する場合は`*this`もエラー値を保持する。
-- (3) : `rhs`が正常値を保持する場合は`*this`も正常値を保持し、`rhs`がエラー値を保持する場合は`*this`もエラー値を保持する。`rhs.`[`has_value()`](has_value.md.nolink)は変化しない。
-- (4), (5) : `rhs`が正常値を保持する場合は`*this`も正常値を保持し、`rhs`がエラー値を保持する場合は`*this`もエラー値を保持する。`rhs.`[`has_value()`](has_value.md.nolink)は変化しない。
+- (3) : `rhs`が正常値を保持する場合は`*this`も正常値を保持し、`rhs`がエラー値を保持する場合は`*this`もエラー値を保持する。`rhs.`[`has_value()`](has_value.md)は変化しない。
+- (4), (5) : `rhs`が正常値を保持する場合は`*this`も正常値を保持し、`rhs`がエラー値を保持する場合は`*this`もエラー値を保持する。`rhs.`[`has_value()`](has_value.md)は変化しない。
 - (6) : 正常値を保持している。
 - (7), (8) : エラー値を保持している。
 - (9), (10) : 正常値を保持している。
@@ -294,9 +294,9 @@ int main()
   }
 }
 ```
-* has_value[link has_value.md.nolink]
-* value[link value.md.nolink]
-* error[link error.md.nolink]
+* has_value()[link has_value.md]
+* value()[link value.md]
+* error()[link error.md]
 * std::unexpected[link ../unexpected.md]
 * std::unexpect[link ../unexpect_t.md]
 * std::in_place[link /reference/utility/in_place_t.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator* -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/op_deref.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected/op_deref.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/op_deref.md b/reference/expected/expected/op_deref.md
index bbe444512..02ef3b9be 100644
--- a/reference/expected/expected/op_deref.md
+++ b/reference/expected/expected/op_deref.md
@@ -17,7 +17,7 @@ constexpr const T&amp;amp;&amp;amp; operator*() const &amp;amp;&amp;amp; noexcept; // (4)
 
 
 ## 事前条件
-[`has_value()`](has_value.md.nolink) `== true`
+[`has_value()`](has_value.md) `== true`
 
 
 ## 戻り値
@@ -69,7 +69,8 @@ int main()
 
 ## 関連項目
 - [`operator-&amp;gt;`](op_arrow.md)
-- [`value`](value.md.nolink)
+- [`value()`](value.md)
+- [`value_or()`](value_or.md.nolink)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>value -- expected/expected: operator bool,has_value,value,error(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/value.html"/>
      <id>bc23c7365769749001533e451b3b02d8b53c3ee8:reference/expected/expected/value.md</id>
      <updated>2023-01-31T15:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/value.md b/reference/expected/expected/value.md
new file mode 100644
index 000000000..c7da83954
--- /dev/null
+++ b/reference/expected/expected/value.md
@@ -0,0 +1,80 @@
+# value
+* expected[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* expected[meta class]
+* cpp23[meta cpp]
+
+```cpp
+constexpr const T&amp;amp; value() const &amp;amp;;   // (1)
+constexpr T&amp;amp; value() &amp;amp;;               // (2)
+constexpr const T&amp;amp;&amp;amp; value() const &amp;amp;&amp;amp;; // (3)
+constexpr T&amp;amp;&amp;amp; value() &amp;amp;&amp;amp;;             // (4)
+```
+
+## 概要
+正常値を取得する。
+
+
+## 戻り値
+動作説明用のメンバ変数として、正常値を保持する`val`を導入する。
+
+- (1), (2) : [`has_value()`](has_value.md) `== true`ならば、`val`
+- (3), (4) : [`has_value()`](has_value.md) `== true`ならば、[`std::move`](/reference/utility/move.md)`(val)`
+
+
+## 例外
+- (1), (2) : [`has_value()`](has_value.md) `== false`ならば、例外[`bad_expected_access`](../bad_expected_access.md)`(`[`error()`](error.md)`)`をスローする
+- (3), (4) : [`has_value()`](has_value.md) `== false`ならば、例外[`bad_expected_access`](../bad_expected_access.md)`(`[`std::move`](/reference/utility/move.md)`(`[`error()`](error.md)`))`をスローする
+
+
+## 例
+```cpp example
+#include &amp;lt;expected&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  std::expected&amp;lt;int, std::string&amp;gt; x = 1;
+  std::cout &amp;lt;&amp;lt; x.value() &amp;lt;&amp;lt; std::endl;
+
+  std::expected&amp;lt;int, std::string&amp;gt; y = std::unexpected{&amp;#34;ERR&amp;#34;};
+  try {
+    std::cout &amp;lt;&amp;lt; y.value() &amp;lt;&amp;lt; std::endl;
+  } catch (const std::bad_expected_access&amp;lt;std::string&amp;gt;&amp;amp; ex) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;throw:&amp;#34; &amp;lt;&amp;lt; ex.error() &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* value()[color ff0000]
+* error()[link ../unexpected/error.md.nolink]
+* std::unexpected[link ../unexpected.md]
+* std::bad_expected_access[link ../bad_expected_access.md]
+
+### 出力
+```
+1
+throw:ERR
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): 16.0
+- [GCC](/implementation.md#gcc): 12.1
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`operator-&amp;gt;`](op_arrow.md)
+- [`operator*`](op_deref.md)
+- [`value_or()`](value_or.md.nolink)
+
+
+## 参照
+- [P0323R12 std::expected](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0323r12.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>