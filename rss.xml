<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-06-08T14:48:13.158145</updated>
  <id>a7d5e2e8-b672-48f5-aedf-44ad875be9b0</id>

  
    <entry>
      <title>invocable -- invocable: 例示コードstd::regular_invocable動作へのコメント補足</title>
      <link href="https://cpprefjp.github.io/reference/concepts/invocable.html"/>
      <id>7605b9cb624af37d15f238e6167f2eff3425136b:reference/concepts/invocable.md</id>
      <updated>2021-06-07T18:09:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/invocable.md b/reference/concepts/invocable.md
index 6da8359d9..a3dc2b4f9 100644
--- a/reference/concepts/invocable.md
+++ b/reference/concepts/invocable.md
@@ -144,7 +144,10 @@ int main() {
   // 内部状態を保ち、等しさを保持しない呼び出し可能な型
   f&amp;lt;decltype(mut_lambda), int&amp;gt;(&amp;#34;mut_lambda(int)&amp;#34;);
   f&amp;lt;std::mt19937&amp;gt;(&amp;#34;std::mt19937()&amp;#34;);
-  
+  // これらの型は std::regular_invocable コンセプトのモデルではないが
+  // C++構文上では std::invocable との差異を区別しない／できないため
+  // それぞれ「XXX is regular_invocable」と出力される。
+
   std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
   f&amp;lt;decltype(func), int*&amp;gt;(&amp;#34;func(int*)&amp;#34;);
   f&amp;lt;not_invocable&amp;gt;(&amp;#34;not_invocable()&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>右辺値参照・ムーブセマンティクス -- Merge pull request #874 from cpprefjp/fix-perfect-forwarding</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html"/>
      <id>21813e4a9a121fb6b7eeb8af0383be06fe89510e:lang/cpp11/rvalue_ref_and_move_semantics.md</id>
      <updated>2021-06-06T22:27:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/rvalue_ref_and_move_semantics.md b/lang/cpp11/rvalue_ref_and_move_semantics.md
index 63e2555cc..fa0bcb4d6 100644
--- a/lang/cpp11/rvalue_ref_and_move_semantics.md
+++ b/lang/cpp11/rvalue_ref_and_move_semantics.md
@@ -276,33 +276,44 @@ public:
 
 
 ### ユニヴァーサル参照
-テンプレート変数や`auto`に`&amp;amp;&amp;amp;`をつけた場合には、通常の右辺値参照とは異なる動作をする。
+関数テンプレートの型パラメータ`T`や[型推論プレースホルダ`auto`](auto.md)に参照修飾子`&amp;amp;&amp;amp;`をつけて宣言したものはユニヴァーサル参照と呼ばれ、通常の右辺値参照とは異なる動作をする。
+なお「ユニヴァーサル参照(Universal Reference)」は[Scott Mayers氏による解説](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)由来の俗称であり、後にC++17仕様において「転送参照(Fowarding Reference)」という正式名称が与えられた。
 
 ```cpp
+// ユニヴァーサル参照
 template &amp;lt;typename T&amp;gt;
 void f(T&amp;amp;&amp;amp; x) {}
 ```
 
-とした場合、`f()`に渡された実引数が左辺値の場合には左辺値参照となり、右辺値の場合は右辺値参照となる。  
+関数テンプレート`f()`の型パラメータ`T`はユニヴァーサル参照であり、
+`f()`に渡された実引数が左辺値の場合には左辺値参照となり、右辺値の場合は右辺値参照となる。  
 これは、次で説明する完全転送に関わる。
 
 ### 完全転送（Perfect Forwarding）
 
-ある関数内で引数を別の関数に渡したいことがある。  
-引数を右辺値参照した場合は別の関数に渡すときにも右辺値として渡すことが自然である。  
-一度右辺値参照すると、変数は左辺値であるのでもう一度ムーブする必要がある。  
-しかし、引数をユニヴァーサル参照で宣言した場合安易にムーブできない。  
-引数は右辺値参照の場合と左辺値参照の場合両方があり得るからである。  
-左辺値参照の場合はムーブせず、右辺値参照の場合はムーブして渡す機能が必要となる。  
-そのような機能として、[`std::forward()`](/reference/utility/forward.md)関数が用意されている。  
+あるが関数が受け取ったパラメータを別の関数へそのまま渡したいとき、
+右辺値は右辺値として、左辺値は左辺値として別の関数へ転送したいことがある（完全転送）。  
+ユニヴァーサル参照を用いると、呼び出し元における右辺値／左辺値という情報が、受け取り側で右辺値参照／左辺値参照という型情報によって区別可能となる。  
+しかし右辺値を右辺値参照で受け取った場合、その引数をそのまま使うと左辺値になるため再び右辺値へ変換する必要が生じる。  
 
+つまり左辺値参照の場合は左辺値として、右辺値参照の場合は右辺値に変換して渡す機能が必要となる。  
+そのような機能として、[`std::forward()`](/reference/utility/forward.md)関数が用意されている。  
+利用時には `std::forward&amp;lt;T&amp;gt;(a)` のように、テンプレートパラメータとしてユニヴァーサル参照宣言時の型パラメータ名を明示する必要がある。
 
 ```cpp
+#include &amp;lt;utility&amp;gt;
+
+template &amp;lt;typename T&amp;gt; void g(T);
+
 template &amp;lt;typename T&amp;gt;
 void f(T&amp;amp;&amp;amp; a)
 {
-  // 実引数が右辺値参照型の場合のみムーブされる
+  // 引数 a が左辺値参照の場合は 左辺値 に
+  // 右辺値参照の場合は 右辺値 に変換してから
+  // 別関数 g() の実引数として渡す。
   g( std::forward&amp;lt;T&amp;gt;(a) ) ;
+  // 関数 g() は値型 T としてパラメータを取るため
+  // 左辺値ではコピーが、右辺値ではムーブが行われる。
 }
 ```
 * std::forward[link /reference/utility/forward.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Hidden Friends -- Hidden Friends : 定義を追加した</title>
      <link href="https://cpprefjp.github.io/article/lib/hidden_friends.html"/>
      <id>2e1fce53de48ab7be25c5a9b19eebf0539f0f303:article/lib/hidden_friends.md</id>
      <updated>2021-06-06T17:05:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/article/lib/hidden_friends.md b/article/lib/hidden_friends.md
index e6a6ff895..1da63417a 100644
--- a/article/lib/hidden_friends.md
+++ b/article/lib/hidden_friends.md
@@ -7,14 +7,14 @@ namespace NS {
   struct C {
 
     // メンバ関数
-    void mem_func();
+    void mem_func() {}
 
     // Hidden Friends
-    friend void hidden_friend(C&amp;amp; self);
+    friend void hidden_friend(C&amp;amp; self) {}
   };
 
   // 普通の非メンバ関数
-  void free_func(C&amp;amp; c);
+  void free_func(C&amp;amp; c) {}
 }
 
 int main() {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンパイル時初期化を強制する`constinit`キーワードを追加 -- constinit: 静的変数の動的初期化タイミングに関する記述を一旦削除</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/constinit.html"/>
      <id>47e0186912cfb6aa2992bc92ee2e653c5d046998:lang/cpp20/constinit.md</id>
      <updated>2021-06-04T23:18:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/constinit.md b/lang/cpp20/constinit.md
index e89b6be0f..8d9a370fa 100644
--- a/lang/cpp20/constinit.md
+++ b/lang/cpp20/constinit.md
@@ -95,7 +95,7 @@ int S::M = 12;  // NG、constinitはこちらに必要、おそらく警告が
 
 動的初期化は実行時に行われる初期化であり、静的初期化はコンパイル時に行われる初期化である。全ての静的変数はコンパイル完了時点で静的初期化されており、その中で動的初期化が必要となる変数だけが動的初期化される。
 
-定数初期化は静的変数に対して最初に試みられる初期化で、初期化式が定数式として実行可能である時に行われる。定数初期化できない残りの変数は全てゼロ初期化される。ゼロ初期化された変数のうち、初期化式を持つものについては実行時（プログラム開始時）に動的初期化される。
+定数初期化は静的変数に対して最初に試みられる初期化で、初期化式が定数式として実行可能である時に行われる。定数初期化できない残りの変数は全てゼロ初期化される。ゼロ初期化された変数のうち、初期化式を持つものについては実行時に動的初期化される。
 
 定数初期化は非リテラル型のクラス型であっても、対応するコンストラクタが`constexpr`コンストラクタであり、そのコンストラクタを通して全てのメンバが定数式で初期化される場合に、クラス型のオブジェクトに対しても実行可能となる（下の例ではこのコンストラクタのことを定数初期化コンストラクタと呼んでいる）。
 
@@ -160,7 +160,7 @@ int main() {
 
 ## この機能が必要になった背景・経緯
 
-静的変数の動的初期化は関数ローカルスコープのものを除いて`main()`の実行よりも前に行われる。そこではコンストラクタ呼び出しを介して通常のC++コードの実行をほぼ自由に行うことができる一方で、各変数の動的初期化順序がどうなるのかはほとんど不定である。
+静的変数の動的初期化ではコンストラクタ呼び出しを介して通常のC++コードの実行をほぼ自由に行うことができる一方で、各変数の動的初期化順序がどうなるのかはほとんど不定である。
 
 同じ翻訳単位にある静的変数の動的初期化順序はその定義の現れる順番と規定されてはいるが、テンプレートや外部リンケージを持つ変数（`extern/inline`など）およびそれらとの間には順序が規定されておらず、動的初期化の順序に依存したコードは多くの場合未定義動作に陥っている（データ競合や未初期化変数の読み取りなど）。この問題は*static initialization order fiasco*として知られている。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>右辺値参照・ムーブセマンティクス -- rvalue_ref_and_move_semantics: ユニヴァーサル参照,完全転送 説明修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html"/>
      <id>99dd4eb6e5e9441b7a5e9b8e4108eec6873718bc:lang/cpp11/rvalue_ref_and_move_semantics.md</id>
      <updated>2021-06-04T10:39:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/rvalue_ref_and_move_semantics.md b/lang/cpp11/rvalue_ref_and_move_semantics.md
index 63e2555cc..fa0bcb4d6 100644
--- a/lang/cpp11/rvalue_ref_and_move_semantics.md
+++ b/lang/cpp11/rvalue_ref_and_move_semantics.md
@@ -276,33 +276,44 @@ public:
 
 
 ### ユニヴァーサル参照
-テンプレート変数や`auto`に`&amp;amp;&amp;amp;`をつけた場合には、通常の右辺値参照とは異なる動作をする。
+関数テンプレートの型パラメータ`T`や[型推論プレースホルダ`auto`](auto.md)に参照修飾子`&amp;amp;&amp;amp;`をつけて宣言したものはユニヴァーサル参照と呼ばれ、通常の右辺値参照とは異なる動作をする。
+なお「ユニヴァーサル参照(Universal Reference)」は[Scott Mayers氏による解説](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)由来の俗称であり、後にC++17仕様において「転送参照(Fowarding Reference)」という正式名称が与えられた。
 
 ```cpp
+// ユニヴァーサル参照
 template &amp;lt;typename T&amp;gt;
 void f(T&amp;amp;&amp;amp; x) {}
 ```
 
-とした場合、`f()`に渡された実引数が左辺値の場合には左辺値参照となり、右辺値の場合は右辺値参照となる。  
+関数テンプレート`f()`の型パラメータ`T`はユニヴァーサル参照であり、
+`f()`に渡された実引数が左辺値の場合には左辺値参照となり、右辺値の場合は右辺値参照となる。  
 これは、次で説明する完全転送に関わる。
 
 ### 完全転送（Perfect Forwarding）
 
-ある関数内で引数を別の関数に渡したいことがある。  
-引数を右辺値参照した場合は別の関数に渡すときにも右辺値として渡すことが自然である。  
-一度右辺値参照すると、変数は左辺値であるのでもう一度ムーブする必要がある。  
-しかし、引数をユニヴァーサル参照で宣言した場合安易にムーブできない。  
-引数は右辺値参照の場合と左辺値参照の場合両方があり得るからである。  
-左辺値参照の場合はムーブせず、右辺値参照の場合はムーブして渡す機能が必要となる。  
-そのような機能として、[`std::forward()`](/reference/utility/forward.md)関数が用意されている。  
+あるが関数が受け取ったパラメータを別の関数へそのまま渡したいとき、
+右辺値は右辺値として、左辺値は左辺値として別の関数へ転送したいことがある（完全転送）。  
+ユニヴァーサル参照を用いると、呼び出し元における右辺値／左辺値という情報が、受け取り側で右辺値参照／左辺値参照という型情報によって区別可能となる。  
+しかし右辺値を右辺値参照で受け取った場合、その引数をそのまま使うと左辺値になるため再び右辺値へ変換する必要が生じる。  
 
+つまり左辺値参照の場合は左辺値として、右辺値参照の場合は右辺値に変換して渡す機能が必要となる。  
+そのような機能として、[`std::forward()`](/reference/utility/forward.md)関数が用意されている。  
+利用時には `std::forward&amp;lt;T&amp;gt;(a)` のように、テンプレートパラメータとしてユニヴァーサル参照宣言時の型パラメータ名を明示する必要がある。
 
 ```cpp
+#include &amp;lt;utility&amp;gt;
+
+template &amp;lt;typename T&amp;gt; void g(T);
+
 template &amp;lt;typename T&amp;gt;
 void f(T&amp;amp;&amp;amp; a)
 {
-  // 実引数が右辺値参照型の場合のみムーブされる
+  // 引数 a が左辺値参照の場合は 左辺値 に
+  // 右辺値参照の場合は 右辺値 に変換してから
+  // 別関数 g() の実引数として渡す。
   g( std::forward&amp;lt;T&amp;gt;(a) ) ;
+  // 関数 g() は値型 T としてパラメータを取るため
+  // 左辺値ではコピーが、右辺値ではムーブが行われる。
 }
 ```
 * std::forward[link /reference/utility/forward.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>