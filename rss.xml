<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-19T14:40:14.796009</updated>
  <id>bbc50d3a-289e-4a67-bf49-f5895a55afd9</id>

  
    <entry>
      <title>acos -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/acos.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/acos.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/acos.md b/reference/cmath/acos.md
index 46f0a5c89..6ae027aec 100644
--- a/reference/cmath/acos.md
+++ b/reference/cmath/acos.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float acos(float x);
-  double acos(double x);
-  long double acos(long double x);
+  float acos(float x);              // (1) C++03からC++20まで
+  double acos(double x);            // (2) C++03からC++20まで
+  long double acos(long double x);  // (3) C++03からC++20まで
 
-  double acos(Integral x);          // C++11 から
+  floating-point-type
+    acos(floating-point-type x);    // (4) C++23
 
-  float acosf(float x);             // C++17 から
-  long double acosl(long double x); // C++17 から
+  double acos(Integral x);          // (5) C++11
+
+  float acosf(float x);             // (6) C++17
+  long double acosl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -23,6 +26,14 @@ namespace std {
 
 `acos()`は、余弦を表す[`cos()`](cos.md)の逆関数である。$\cos(\mathrm{Arccos}~x) = x$、$\mathrm{Arccos}~(\cos x) = x ~ (x \in [0, \pi])$である。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の逆余弦を主値 `[0, π]` の範囲で返す。（単位はラジアン）
@@ -34,8 +45,9 @@ namespace std {
 - $$ f(x) = \mathrm{Arccos}~ x $$
 - 定義域エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = 1` の場合、戻り値は `+0` となる。
-	- `x &amp;gt; |1|` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = 1` の場合、戻り値は `+0` となる。
+    - `x &amp;gt; |1|` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -94,3 +106,8 @@ $$ \mathrm{Arccos}~x = \frac{\pi}{2} - \sum_{n = 0}^{\infty}\frac{\left(2n\right
 また、逆正接関数と逆余接関数の和は π / 2 なので [`asin`](asin.md) から求めることができる。
 
 $$ \mathrm{Arccos}~x = \frac{\pi}{2} - \mathrm{Arcsin}~x \quad \mathrm{for} \; |x| &amp;amp;lt; 1 $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>acosh -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/acosh.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/acosh.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/acosh.md b/reference/cmath/acosh.md
index a87928624..8e072d9bf 100644
--- a/reference/cmath/acosh.md
+++ b/reference/cmath/acosh.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float acosh(float x);
-  double acosh(double x);
-  long double acosh(long double x);
+  float acosh(float x);              // (1) C++11からC++20まで
+  double acosh(double x);            // (2) C++11からC++20まで
+  long double acosh(long double x);  // (3) C++11からC++20まで
 
-  double acosh(Integral x);          // C++11 から
+  floating-point-type
+    acosh(floating-point-type x);    // (4) C++23
 
-  float acoshf(float x);             // C++17 から
-  long double acoshl(long double x); // C++17 から
+  double acosh(Integral x);          // (5) C++11
+
+  float acoshf(float x);             // (6) C++17
+  long double acoshl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 算術型の逆双曲線余弦（エリアハイパボリックコサイン、area hyperbolic cosine）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の逆双曲線余弦を `[0, +∞]` の範囲で返す。
@@ -33,9 +44,10 @@ namespace std {
 - $$ f(x) = \mathrm{arcosh}~x $$
 - 定義域エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = 1` の場合、戻り値は `+0` となる。
-	- `x &amp;lt; 1` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-	- `x = +∞` の場合、戻り値は `+∞` となる。
+    - `x = 1` の場合、戻り値は `+0` となる。
+    - `x &amp;lt; 1` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = +∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -79,3 +91,8 @@ acosh(∞)  = inf
 対数に変換して求めることができる。
 
 $$ \mathrm{arcosh}~x = \log_e \left(x + \sqrt{x^2-1}\right) \quad \mathrm{for} \; 1 &amp;amp;lt; x $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>asin -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/asin.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/asin.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/asin.md b/reference/cmath/asin.md
index 6cda0510f..132bd53a1 100644
--- a/reference/cmath/asin.md
+++ b/reference/cmath/asin.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float asin(float x);
-  double asin(double x);
-  long double asin(long double x);
+  float asin(float x);                // (1) C++03からC++20まで
+  double asin(double x);              // (2) C++03からC++20まで
+  long double asin(long double x);    // (3) C++03からC++20まで
 
-  double asin(Integral x);          // C++11
+  floating-point-type
+    asin(floating-point-type x);      // (4) C++23
 
-  float asinf(float x);             // C++17 から
-  long double asinl(long double x); // C++17 から
+  double asin(Integral x);            // (5) C++11
+
+  float asinf(float x);               // (6) C++17
+  long double asinl(long double x);   // (7) C++17
 }
 ```
 * Integral[italic]
@@ -23,6 +26,14 @@ namespace std {
 
 `asin()`は、正弦を表す[`sin()`](sin.md)の逆関数である。$\sin(\mathrm{Arcsin}~x) = x$、$\mathrm{Arcsin}~(\sin x) = x ~ (x \in [-\pi/2, \pi/2])$である。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の逆正弦を主値 `[-π/2, π/2]` の範囲で返す。（単位はラジアン）
@@ -34,8 +45,9 @@ namespace std {
 - $$ f(x) = \mathrm{Arcsin}~x $$
 - 定義域エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
-	- `x &amp;gt; |1|` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
+    - `x &amp;gt; |1|` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -90,3 +102,8 @@ $$ \mathrm{Arcsin}~x = \sum_{n = 0}^{\infty} \frac{(2n)!}{4^n (n!)^2 (2n+1)} x^{
 $|x| = 1$ 近傍の精度低下する領域（特に $1 / \sqrt{2} &amp;amp;lt; |x| \le 1$）においては、以下の公式による変換で精度向上を図れる。
 
 $$ \mathrm{Arcsin}~x = \frac{\pi}{2} - \mathrm{Arccos}~x = \frac{\pi}{2} - \mathrm{Arcsin}~\sqrt{1 - x^2} \quad \mathrm{for} \; 0 \le x \le 1 $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>asinh -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/asinh.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/asinh.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/asinh.md b/reference/cmath/asinh.md
index 94543b7c5..c18b0fa46 100644
--- a/reference/cmath/asinh.md
+++ b/reference/cmath/asinh.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float asinh(float x);
-  double asinh(double x);
-  long double asinh(long double x);
+  float asinh(float x);              // (1) C++11からC++20まで
+  double asinh(double x);            // (2) C++11からC++20まで
+  long double asinh(long double x);  // (3) C++11からC++20まで
 
-  double asinh(Integral x);          // C++11 から
+  floating-point-type
+    asinh(floating-point-type x);    // (4) C++23
 
-  float asinhf(float x);             // C++17 から
-  long double asinhl(long double x); // C++17 から
+  double asinh(Integral x);          // (5) C++11
+
+  float asinhf(float x);             // (6) C++17
+  long double asinhl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 算術型の逆双曲線正弦（エリアハイパボリックサイン、area hyperbolic sine）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の逆双曲線正弦を返す。
@@ -30,8 +41,9 @@ namespace std {
 ## 備考
 - $$ f(x) = \mathrm{arsinh}~x $$
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `x = ±0` の場合、戻り値は `±0` となる。
-	- `x = ±∞` の場合、戻り値は `±∞` となる。
+    - `x = ±0` の場合、戻り値は `±0` となる。
+    - `x = ±∞` の場合、戻り値は `±∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -80,3 +92,8 @@ $$ \mathrm{arsinh}~x = \sum_{n = 0}^{\infty} \frac{(-1)^n (2n)!}{4^n (n!)^2 (2n
 または対数に変換して求めることができる。
 
 $$ \mathrm{arsinh}~x = \log_e \left(x + \sqrt{x^2+1}\right) \quad \mathrm{for~all} \; x $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assoc_laguerre -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/assoc_laguerre.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/assoc_laguerre.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/assoc_laguerre.md b/reference/cmath/assoc_laguerre.md
index 0a30b9b7a..2effc09d6 100644
--- a/reference/cmath/assoc_laguerre.md
+++ b/reference/cmath/assoc_laguerre.md
@@ -7,15 +7,44 @@
 
 ```cpp
 namespace std {
-float assoc_laguerref(unsigned n, unsigned m, float x);
-double assoc_laguerre(unsigned n, unsigned m, double x);
-long double assoc_laguerrel(unsigned n, unsigned m, long double x);
+  double
+    assoc_laguerre(unsigned int n,
+                   unsigned int m,
+                   double x);              // (1) C++17
+  floating-point-type
+    assoc_laguerre(unsigned int n,
+                   unsigned int m,
+                   floating-point-type x); // (1) C++23
+
+  Promoted
+    assoc_laguerre(unsigned int n,
+                   unsigned int m,
+                   Arithmetic x);          // (2) C++17
+
+  float
+    assoc_laguerref(unsigned int n,
+                    unsigned int m,
+                    float x);              // (3) C++17
+
+  long double
+    assoc_laguerrel(unsigned int n,
+                    unsigned int m,
+                    long double x);        // (4) C++17
 }
 ```
+* Promoted[italic]
+* Arithmetic[italic]
 
 ## 概要
 ラゲール陪多項式 (associated Laguerre polynomials) を計算する。
 
+- (1) :
+    - C++17 : `double`に対するオーバーロード
+    - C++23 : 浮動小数点数型に対するオーバーロード
+- (2) : 算術型に対するオーバーロード (対応する精度の浮動小数点数型にキャストして計算される)
+- (3) : `float`型規定
+- (4) : `long double`型規定
+
 
 ## 戻り値
 引数 `n`, `m`, `x` のラゲール陪多項式
@@ -28,7 +57,8 @@ $$
 
 
 ## 備考
-`n &amp;gt;= 128 || m &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である。
+- `n &amp;gt;= 128 || m &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -93,16 +123,6 @@ assoc_laguerre(2, 1, 2) = -1
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
-## 関連項目
-* ラゲール多項式 [`laguerre`](laguerre.md)
-
-
-## 参照
-- [N3060 JTC1.22.29124 Programming Language C++ — Special Math Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf)
-- [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
-- [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
-
-
 ## 実装例
 ### 閉形式
 $$
@@ -114,3 +134,15 @@ $$
 L_n^m(x) = \frac{(2n + m - 1 - x)L_{n-1}^m(x) - (n + m - 1) L_{n-2}^m(x)}{n};
 L_0^m(x) = 1, L_1^m(x) = -x + m + 1
 $$
+
+
+## 関連項目
+- ラゲール多項式 [`laguerre`](laguerre.md)
+
+
+## 参照
+- [N3060 JTC1.22.29124 Programming Language C++ — Special Math Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf)
+- [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
+- [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assoc_legendre -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/assoc_legendre.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/assoc_legendre.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/assoc_legendre.md b/reference/cmath/assoc_legendre.md
index caf8d7941..b36db5ea0 100644
--- a/reference/cmath/assoc_legendre.md
+++ b/reference/cmath/assoc_legendre.md
@@ -7,15 +7,44 @@
 
 ```cpp
 namespace std {
-float assoc_legendref(unsigned l, unsigned m, float x);
-double assoc_legendre(unsigned l, unsigned m, double x);
-long double assoc_legendrel(unsigned l, unsigned m, long double x);
+  double
+    assoc_legendre(unsigned int l,
+                   unsigned int m,
+                   double x);              // (1) C++17
+  floating-point-type
+    assoc_legendre(unsigned int l,
+                   unsigned int m,
+                   floating-point-type x); // (1) C++23
+
+  Promoted
+    assoc_legendre(unsigned int l,
+                   unsigned int m,
+                   Arithmetic x);          // (2) C++17
+
+  float
+    assoc_legendref(unsigned int l,
+                    unsigned int m,
+                    float x);              // (2) C++17
+
+  long double
+    assoc_legendrel(unsigned int l,
+                    unsigned int m,
+                    long double x);        // (3) C++17
 }
 ```
+* Promoted[italic]
+* Arithmetic[italic]
 
 ## 概要
 ルジャンドル陪関数 (associated Legendre functions) を計算する。
 
+- (1) :
+    - C++17 : `double`に対するオーバーロード
+    - C++23 : 浮動小数点数型に対するオーバーロード
+- (2) : 算術型に対するオーバーロード (対応する精度の浮動小数点数型にキャストして計算される)
+- (3) : `float`型規定
+- (4) : `long double`型規定
+
 
 ## 戻り値
 引数 `l`, `m`, `x` のルジャンドル陪関数
@@ -27,7 +56,8 @@ $$
 
 
 ## 備考
-`l &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である。
+- `l &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -98,17 +128,6 @@ GCC 7.1.0–8.0.0 では `l &amp;lt; m` の場合 ($P_l^m = 0$) [`std::domain_error`](/
 GCC 7.1.0–8.0.0 では $(-1)^m$ 倍された値を返す。
 
 
-## 関連項目
-* ルジャンドル多項式 [`legendre`](legendre.md)
-* 球面調和関数の *θ* 成分 [`sph_legendre`](sph_legendre.md)
-
-
-## 参照
-- [N3060 JTC1.22.29124 Programming Language C++ — Special Math Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf)
-- [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
-- [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
-
-
 ## 実装例
 ### 閉形式
 $$
@@ -121,3 +140,17 @@ $$
 P_l^m(x) = \frac{(2l-1) x P_{l-1}^m(x) - (l+m-1) P_{l-2}^m(x)}{l-m};
 \quad P_{m-1}^m(x) = 0, \quad P_m^m(x) = (2m-1)!! (1 - x^2)^{m/2}
 $$
+
+
+## 関連項目
+- ルジャンドル多項式 [`legendre`](legendre.md)
+- 球面調和関数の *θ* 成分 [`sph_legendre`](sph_legendre.md)
+
+
+## 参照
+- [N3060 JTC1.22.29124 Programming Language C++ — Special Math Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf)
+- [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
+- [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atan -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/atan.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/atan.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/atan.md b/reference/cmath/atan.md
index 85488a317..a82f0ba13 100644
--- a/reference/cmath/atan.md
+++ b/reference/cmath/atan.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float atan(float x);
-  double atan(double x);
-  long double atan(long double x);
+  float atan(float x);                // (1) C++03からC++20まで
+  double atan(double x);              // (2) C++03からC++20まで
+  long double atan(long double x);    // (3) C++03からC++20まで
 
-  double atan(Integral x);          // C++11 から
+  floating-point-type
+    atan(floating-point-type x);      // (4) C++23
 
-  float atanf(float x);             // C++17 から
-  long double atanl(long double x); // C++17 から
+  double atan(Integral x);            // (5) C++11
+
+  float atanf(float x);               // (6) C++17
+  long double atanl(long double x);   // (7) C++17
 }
 ```
 * Integral[italic]
@@ -23,6 +26,14 @@ namespace std {
 
 `atan()`は、正接を表す[`tan()`](tan.md)の逆関数である。$\tan(\mathrm{Arctan}~x) = x$、$\mathrm{Arctan}~(\tan x) = x ~ (x \in [-\pi/2, \pi/2])$である。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の逆正接を主値 `[-π/2, π/2]` の範囲で返す。（単位はラジアン）
@@ -31,8 +42,9 @@ namespace std {
 ## 備考
 - $$ f(x) = \mathrm{Arctan}~x $$
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
-	- `x = ±∞` の場合、戻り値は `±π/2` となる。（複号同順）
+    - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
+    - `x = ±∞` の場合、戻り値は `±π/2` となる。（複号同順）
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -98,3 +110,8 @@ $$ \mathrm{Arctan}~x = \frac{\pi}{2} - \mathrm{Arctan}~\frac{1}{x} \quad \mathrm
 （特に $ \sqrt{2} - 1 &amp;amp;lt; |x| \le \sqrt{2} + 1 $ の場合）
 
 $$ \mathrm{Arctan}~x = \frac{\pi}{4} + \mathrm{Arctan}~\frac{x - 1}{x + 1} \quad \mathrm{for} \; x \ne -1 $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atan2 -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/atan2.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/atan2.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/atan2.md b/reference/cmath/atan2.md
index 9d45bc3fc..4878498a1 100644
--- a/reference/cmath/atan2.md
+++ b/reference/cmath/atan2.md
@@ -6,14 +6,23 @@
 
 ```cpp
 namespace std {
-  float atan2(float y, float x);
-  double atan2(double y, double x);
-  long double atan2(long double y, long double x);
-
-  Promoted atan2(Arithmetic1 y, Arithmetic2 x);     // C++11 から
-
-  float atan2f(float y, float x);                   // C++17 から
-  long double atan2l(long double y, long double x); // C++17 から
+  float atan2(float y, float x);          // (1) C++03からC++20まで
+  double atan2(double y, double x);       // (2) C++03からC++20まで
+  long double
+    atan2(long double y, long double x);  // (3) C++03からC++20まで
+
+  floating-point-type
+    atan2(floating-point-type y,
+          floating-point-type x);         // (4) C++23
+
+  Promoted
+    atan2(Arithmetic1 y,
+          Arithmetic2 x);                 // (5) C++11
+
+  float
+    atan2f(float y, float x);             // (6) C++17
+  long double
+    atan2l(long double y, long double x); // (7) C++17
 }
 ```
 * Promoted[italic]
@@ -27,6 +36,14 @@ namespace std {
 
 このような三角形があった場合、辺`y`の長さと辺`x`の長さを`atan2()`関数に与えることで、角度θがラジアン単位として求まる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `y / x` の逆正接を `[-π, π]` の範囲で返す。（単位はラジアン）
@@ -38,21 +55,22 @@ namespace std {
 ## 備考
 - $$ f(y, x) = \mathrm{Arctan}~\frac{y}{x} $$
 
-	引数の順番に注意されたし。
+    引数の順番に注意されたし。
 
 - 定義域エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `y = ±0` で `x &amp;lt; 0` または `x = -0` の場合、戻り値は `±π` となる。
-	- `y = ±0` で `x &amp;gt; 0` または `x = +0` の場合、戻り値は `±0` となる。
-	- `y &amp;gt; 0` で `x = ±0` の場合、戻り値は `+π/2` となる。
-	- `y &amp;lt; 0` で `x = ±0` の場合、戻り値は `-π/2` となる。
-	- `0 &amp;lt; z &amp;lt; +∞` とすると、`y = ±z` で `x = -∞` の場合、戻り値は `±π` となる。
-	- `0 &amp;lt; z &amp;lt; +∞` とすると、`y = ±z` で `x = +∞` の場合、戻り値は `±0` となる。
-	- `y = ±∞` で `x` が有限の値の場合、戻り値は `±π/2` となる。
-	- `y = ±∞` で `x = -∞` の場合、戻り値は `±3π/4` となる。
-	- `y = ±∞` で `x = +∞` の場合、戻り値は `±π/4` となる。
+    - `y = ±0` で `x &amp;lt; 0` または `x = -0` の場合、戻り値は `±π` となる。
+    - `y = ±0` で `x &amp;gt; 0` または `x = +0` の場合、戻り値は `±0` となる。
+    - `y &amp;gt; 0` で `x = ±0` の場合、戻り値は `+π/2` となる。
+    - `y &amp;lt; 0` で `x = ±0` の場合、戻り値は `-π/2` となる。
+    - `0 &amp;lt; z &amp;lt; +∞` とすると、`y = ±z` で `x = -∞` の場合、戻り値は `±π` となる。
+    - `0 &amp;lt; z &amp;lt; +∞` とすると、`y = ±z` で `x = +∞` の場合、戻り値は `±0` となる。
+    - `y = ±∞` で `x` が有限の値の場合、戻り値は `±π/2` となる。
+    - `y = ±∞` で `x = -∞` の場合、戻り値は `±3π/4` となる。
+    - `y = ±∞` で `x = +∞` の場合、戻り値は `±π/4` となる。
 
-	特に、`y` と `x` の両方がゼロの場合に定義域エラー（[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外））となったり、`y` が非ゼロで `x` がゼロの場合に極エラー（[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外））となったりは**しない**事に注意。
+    特に、`y` と `x` の両方がゼロの場合に定義域エラー（[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外））となったり、`y` が非ゼロで `x` がゼロの場合に極エラー（[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外））となったりは**しない**事に注意。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -114,3 +132,7 @@ $$
 \displaystyle \mathrm{Arctan}~\frac{y}{x} - \pi &amp;amp;amp; \quad \mathrm{for} \; x &amp;amp;lt; 0, \; y &amp;amp;lt; 0
 \end{cases}
 $$
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atanh -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/atanh.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/atanh.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/atanh.md b/reference/cmath/atanh.md
index c09d4bdd1..78e3a266d 100644
--- a/reference/cmath/atanh.md
+++ b/reference/cmath/atanh.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float atanh(float x);
-  double atanh(double x);
-  long double atanh(long double x);
+  float atanh(float x);              // (1) C++11からC++20まで
+  double atanh(double x);            // (2) C++11からC++20まで
+  long double atanh(long double x);  // (3) C++11からC++20まで
 
-  double atanh(Integral x);          // C++17 から
+  floating-point-type
+    atanh(floating-point-type x);    // (4) C++23
 
-  float atanhf(float x);             // C++17 から
-  long double atanhl(long double x); // C++17 から
+  double atanh(Integral x);          // (5) C++11
+
+  float atanhf(float x);             // (6) C++17
+  long double atanhl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 算術型の逆双曲線正接（エリアハイパボリックタンジェント、area hyperbolic tangent）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の逆双曲線正接を返す。
@@ -33,9 +44,10 @@ namespace std {
 - $$ f(x) = \mathrm{artanh}~x $$
 - 定義域エラー、あるいは、極エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `x = ±0` の場合、戻り値は `±0` となる。
-	- `x = ±1` の場合、戻り値は `±∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
-	- `|x| &amp;gt; 1` の場合、戻り値は NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = ±0` の場合、戻り値は `±0` となる。
+    - `x = ±1` の場合、戻り値は `±∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
+    - `|x| &amp;gt; 1` の場合、戻り値は NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -87,3 +99,8 @@ $$ \mathrm{artanh}~x = \sum_{n = 0}^{\infty} \frac{1}{2n + 1} x^{2n + 1} \quad \
 または対数に変換して求めることができる。
 
 $$ \mathrm{artanh}~x = \frac{1}{2} \log_e \frac{1 + x}{1 - x} \quad \mathrm{for} \; |x| &amp;amp;lt; 1 $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>beta -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/beta.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/beta.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/beta.md b/reference/cmath/beta.md
index ef26eca01..16ca1ded5 100644
--- a/reference/cmath/beta.md
+++ b/reference/cmath/beta.md
@@ -7,15 +7,40 @@
 
 ```cpp
 namespace std {
-float betaf(float x, float y);
-double beta(double x, double y);
-long double betal(long double x, long double y);
+  double
+    beta(double x,
+         double y);              // (1) C++17
+  floating-point-type
+    beta(floating-point-type x,
+         floating-point-type y); // (1) C++23
+
+  Promoted
+    beta(Arithmetic1 x,
+         Arithmetic2 y);         // (2) C++17
+
+  float
+    betaf(float x,
+          float y);              // (3) C++17
+
+  long double
+    betal(long double x,
+          long double y);        // (4) C++17
 }
 ```
+* Promoted[italic]
+* Arithmetic1[italic]
+* Arithmetic2[italic]
 
 ## 概要
 ベータ関数 (beta function) を求める。
 
+- (1) :
+    - C++17 : `double`に対するオーバーロード
+    - C++23 : 浮動小数点数型に対するオーバーロード
+- (2) : 算術型に対するオーバーロード (対応する大きい方の精度の浮動小数点数型にキャストして計算される)
+- (3) : `float`型規定
+- (4) : `long double`型規定
+
 
 ## 戻り値
 引数 `x`, `y` のベータ関数
@@ -26,6 +51,10 @@ $$
 を返す。$\Gamma$ はガンマ関数 ([`tgamma`](tgamma.md))。
 
 
+## 備考
+- (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;cmath&amp;gt;
@@ -71,3 +100,6 @@ $ |\mathrm{B}(x, y)| = \exp(\ln |\Gamma(x) \Gamma(y) / \Gamma(x + y)|)) $
 - [N3060 JTC1.22.29124 Programming Language C++ — Special Math Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf)
 - [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
 - [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cbrt -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cbrt.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/cbrt.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cbrt.md b/reference/cmath/cbrt.md
index c6c171a6d..f5c879de3 100644
--- a/reference/cmath/cbrt.md
+++ b/reference/cmath/cbrt.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float cbrt(float x);
-  double cbrt(double x);
-  long double cbrt(long double x);
+  float cbrt(float x);              // (1) C++11からC++20まで
+  double cbrt(double x);            // (2) C++11からC++20まで
+  long double cbrt(long double x);  // (3) C++11からC++20まで
 
-  double cbrt(Integral x);
+  floating-point-type
+    cbrt(floating-point-type x);    // (4) C++23
 
-  float cbrtf(float x);             // C++17 から
-  long double cbrtl(long double x); // C++17 から
+  double cbrt(Integral x);          // (5) C++11
+
+  float cbrtf(float x);             // (6) C++17
+  long double cbrtl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 算術型の実数の立方根を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の実数の立方根を返す。
@@ -30,8 +41,9 @@ namespace std {
 ## 備考
 - $$ f(x) = \sqrt[3] x $$
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `x = ±0` の場合、戻り値は `±0` となる。
-	- `x = ±∞` の場合、戻り値は `±∞` となる。
+    - `x = ±0` の場合、戻り値は `±0` となる。
+    - `x = ±∞` の場合、戻り値は `±∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -78,3 +90,6 @@ cbrt(-1.0) = -1.000000
 - GCC 4.6.1 以上
 
 
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>comp_ellint_1 -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/comp_ellint_1.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/comp_ellint_1.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/comp_ellint_1.md b/reference/cmath/comp_ellint_1.md
index 96c669a22..8969a506b 100644
--- a/reference/cmath/comp_ellint_1.md
+++ b/reference/cmath/comp_ellint_1.md
@@ -7,15 +7,35 @@
 
 ```cpp
 namespace std {
-  float comp_ellint_1f(float k);
-  double comp_ellint_1(double k);
-  long double comp_ellint_1l(long double k);
+  double
+    comp_ellint_1(double k);              // (1) C++17
+  floating-point-type
+    comp_ellint_1(floating-point-type k); // (1) C++23
+
+  Promoted
+    comp_ellint_1(Arithmetic k);          // (1) C++17
+
+  float
+    comp_ellint_1f(float k);              // (2) C++17
+
+  long double
+    comp_ellint_1l(long double k);        // (3) C++17
 }
 ```
+* Promoted[italic]
+* Arithmetic[italic]
+
 
 ## 概要
 第一種完全楕円積分 (complete elliptic integral of the first kind) を計算する。
 
+- (1) :
+    - C++17 : `double`に対するオーバーロード
+    - C++23 : 浮動小数点数型に対するオーバーロード
+- (2) : 算術型に対するオーバーロード (対応する精度の浮動小数点数型にキャストして計算される)
+- (3) : `float`型規定
+- (4) : `long double`型規定
+
 
 ## 戻り値
 引数 `k` の第一種完全楕円積分
@@ -27,6 +47,10 @@ $$
 $ F(k, \phi) $ は第一種不完全楕円積分 ([`ellint_1`](ellint_1.md))。
 
 
+## 備考
+- (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;cmath&amp;gt;
@@ -69,7 +93,7 @@ double pendulum_period_shift(double theta) {
 
 int main() {
   std::cout &amp;lt;&amp;lt; std::setprecision(16);
-  
+
   for (const auto theta : {15.0, 30.0, 45.0, 60.0}) {
     const auto angle = theta * pi / 180.0;
     std::cout &amp;lt;&amp;lt; theta &amp;lt;&amp;lt; &amp;#34; [°] : &amp;#34;;
@@ -104,8 +128,15 @@ int main() {
 GCC 7.1.0–8.0.0 では定義域エラーが発生したときに [`std::numeric_limits::quiet_NaN`](/reference/limits/numeric_limits/quiet_nan.md) を返す。
 
 
+## 実装例
+### 級数
+$$
+K(k) = \frac{\pi}{2} \sum_{n=0}^\infty \left[ \frac{(2n-1)!!}{(2n)!!} \right]^2 k^{2n}
+$$
+
+
 ## 関連項目
-* 第一種不完全楕円積分 [`ellint_1`](ellint_1.md)
+- 第一種不完全楕円積分 [`ellint_1`](ellint_1.md)
 
 
 ## 参照
@@ -113,9 +144,5 @@ GCC 7.1.0–8.0.0 では定義域エラーが発生したときに [`std::numeri
 - [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
 - [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
 - [振り子 - Wikipedia](https://ja.wikipedia.org/wiki/振り子)
-
-## 実装例
-### 級数
-$$
-K(k) = \frac{\pi}{2} \sum_{n=0}^\infty \left[ \frac{(2n-1)!!}{(2n)!!} \right]^2 k^{2n}
-$$
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>comp_ellint_2 -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/comp_ellint_2.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/comp_ellint_2.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/comp_ellint_2.md b/reference/cmath/comp_ellint_2.md
index 5cfcb4551..8768d2306 100644
--- a/reference/cmath/comp_ellint_2.md
+++ b/reference/cmath/comp_ellint_2.md
@@ -7,15 +7,34 @@
 
 ```cpp
 namespace std {
-float comp_ellint_2f(float k);
-double comp_ellint_2(double k);
-long double comp_ellint_2l(long double k);
+  double
+    comp_ellint_2(double k);              // (1) C++17
+  floating-point-type
+    comp_ellint_2(floating-point-type k); // (1) C++23
+
+  Promoted
+    comp_ellint_2(Arithmetic k);          // (2) C++17
+
+  float
+    comp_ellint_2f(float k);              // (3) C++17
+
+  long double
+    comp_ellint_2l(long double k);        // (4) C++17
 }
 ```
+* Promoted[italic]
+* Arithmetic[italic]
 
 ## 概要
 第二種完全楕円積分 (complete elliptic integral of the second kind) を計算する。
 
+- (1) :
+    - C++17 : `double`に対するオーバーロード
+    - C++23 : 浮動小数点数型に対するオーバーロード
+- (2) : 算術型に対するオーバーロード (対応する精度の浮動小数点数型にキャストして計算される)
+- (3) : `float`型規定
+- (4) : `long double`型規定
+
 
 ## 戻り値
 引数 `k` の第二種完全楕円積分
@@ -27,6 +46,10 @@ $$
 $ E(k, \phi) $ は第二種不完全楕円積分 ([`ellint_2`](ellint_2.md))。
 
 
+## 備考
+- (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;cmath&amp;gt;
@@ -59,18 +82,20 @@ comp_ellint_2(1)   = 1
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 実装例
+### 級数
+$$
+E(k) = - \frac{\pi}{2} \sum_{n=0}^\infty \frac{1}{2n-1} \left[ \frac{(2n-1)!!}{(2n)!!} \right]^2 k^{2n}
+$$
+
+
 ## 関連項目
-* 第二種不完全楕円積分 [`ellint_2`](ellint_2.md)
+- 第二種不完全楕円積分 [`ellint_2`](ellint_2.md)
 
 
 ## 参照
 - [N3060 JTC1.22.29124 Programming Language C++ — Special Math Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf)
 - [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
 - [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
-
-
-## 実装例
-### 級数
-$$
-E(k) = - \frac{\pi}{2} \sum_{n=0}^\infty \frac{1}{2n-1} \left[ \frac{(2n-1)!!}{(2n)!!} \right]^2 k^{2n}
-$$
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>comp_ellint_3 -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/comp_ellint_3.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/comp_ellint_3.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/comp_ellint_3.md b/reference/cmath/comp_ellint_3.md
index fa89db92e..3a234e503 100644
--- a/reference/cmath/comp_ellint_3.md
+++ b/reference/cmath/comp_ellint_3.md
@@ -7,15 +7,40 @@
 
 ```cpp
 namespace std {
-float comp_ellint_3f(float k, float nu);
-double comp_ellint_3(double k, double nu);
-long double comp_ellint_3l(long double k, long double nu);
+  double
+    comp_ellint_3(double k,
+                  double nu);              // (1) C++17
+  floating-point-type
+    comp_ellint_3(floating-point-type k,
+                  floating-point-type nu); // (1) C++23
+
+  Promoted
+    comp_ellint_3(Arithmetic1 k,
+                  Arithmetic2 nu);         // (2) C++17
+
+  float
+    comp_ellint_3f(float k,
+                   float nu);              // (3) C++17
+
+  long double
+    comp_ellint_3l(long double k,
+                   long double nu);        // (4) C++17
 }
 ```
+* Promoted[italic]
+* Arithmetic1[italic]
+* Arithmetic2[italic]
 
 ## 概要
 第三種完全楕円積分 (complete elliptic integral of the third kind) を計算する。
 
+- (1) :
+    - C++17 : `double`に対するオーバーロード
+    - C++23 : 浮動小数点数型に対するオーバーロード
+- (2) : 算術型に対するオーバーロード (対応する大きい方の精度の浮動小数点数型にキャストして計算される)
+- (3) : `float`型規定
+- (4) : `long double`型規定
+
 
 ## 戻り値
 引数 `k`, `nu` の第三種完全楕円積分
@@ -25,11 +50,13 @@ $$
 \quad \text{for } |k| \le 1
 $$
 を返す。
+
 $ \Pi(\nu, k) $ は第三種不完全楕円積分 ([`ellint_3`](ellint_3.md))。
 
 
 ## 備考
-$\Pi(0, k) = K(k)$ (第一種完全楕円積分 [`comp_ellint_1`](comp_ellint_1.md))。
+- $\Pi(0, k) = K(k)$ (第一種完全楕円積分 [`comp_ellint_1`](comp_ellint_1.md))
+- (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -100,3 +127,5 @@ GCC 7.1.0–8.0.0 では
 - [N3060 JTC1.22.29124 Programming Language C++ — Special Math Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf)
 - [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
 - [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cos -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cos.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/cos.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cos.md b/reference/cmath/cos.md
index 2f8306873..0f68b806d 100644
--- a/reference/cmath/cos.md
+++ b/reference/cmath/cos.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float cos(float x);
-  double cos(double x);
-  long double cos(long double x);
+  float cos(float x);              // (1) C++03からC++20まで
+  double cos(double x);            // (2) C++03からC++20まで
+  long double cos(long double x);  // (3) C++03からC++20まで
 
-  double cos(Integral x);          // C++11 から
+  floating-point-type
+    cos(floating-point-type x);    // (4) C++23
 
-  float cosf(float x);             // C++17 から
-  long double cosl(long double x); // C++17 から
+  double cos(Integral x);          // (5) C++11
+
+  float cosf(float x);             // (6) C++17
+  long double cosl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 算術型の余弦（コサイン）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の余弦を返す(`x`の単位はラジアン)。
@@ -29,8 +40,9 @@ namespace std {
 ## 備考
 - $$ f(x) = \cos x $$
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `1` となる。
-	- `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = ±0` の場合、戻り値は `1` となる。
+    - `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -109,3 +121,8 @@ $$ \cos x = \sum_{n = 0}^{\infty} \frac{(-1)^n}{(2n)!} x^{2n} \quad \mathrm{for~
 
 ## 関連項目
 - [`std::numbers::pi`](/reference/numbers/pi.md)
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cosh -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cosh.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/cosh.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cosh.md b/reference/cmath/cosh.md
index 0cb1d97bf..3218f93c7 100644
--- a/reference/cmath/cosh.md
+++ b/reference/cmath/cosh.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float cosh(float x);
-  double cosh(double x);
-  long double cosh(long double x);
+  float cosh(float x);              // (1) C++03からC++20まで
+  double cosh(double x);            // (2) C++03からC++20まで
+  long double cosh(long double x);  // (3) C++03からC++20まで
 
-  double cosh(Integral x);          // C++11 から
+  floating-point-type
+    cosh(floating-point-type x);    // (4) C++23
 
-  float coshf(float x);             // C++17 から
-  long double coshl(long double x); // C++17 から
+  double cosh(Integral x);          // (5) C++11
+
+  float coshf(float x);             // (6) C++17
+  long double coshl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 算術型の双曲線余弦（ハイパボリックコサイン）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の双曲線余弦を返す。
@@ -32,8 +43,9 @@ namespace std {
 - $$ f(x) = \cosh x $$
 - オーバーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `1` となる。
-	- `x = ±∞` の場合、戻り値は `+∞` となる。
+    - `x = ±0` の場合、戻り値は `1` となる。
+    - `x = ±∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -78,3 +90,8 @@ cosh(1.0)  = 1.543081
 以下のマクローリン級数を適当な次数で打ち切ることで近似的に求めることができる。
 
 $$ \cosh x = \sum_{n = 0}^{\infty} \frac{1}{(2n)!} x^{2n} \quad \mathrm{for~all} \; x $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erf -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/erf.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/erf.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/erf.md b/reference/cmath/erf.md
index 215c0bdfc..138fa4d5f 100644
--- a/reference/cmath/erf.md
+++ b/reference/cmath/erf.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float erf(float x);
-  double erf(double x);
-  long double erf(long double x);
+  float erf(float x);              // (1) C++11からC++20まで
+  double erf(double x);            // (2) C++11からC++20まで
+  long double erf(long double x);  // (3) C++11からC++20まで
 
-  double erf(Integral x);
+  floating-point-type
+    erf(floating-point-type x);    // (4) C++23
 
-  float erff(float x);             // C++17 から
-  long double erfl(long double x); // C++17 から
+  double erf(Integral x);          // (5) C++11
+
+  float erff(float x);             // (6) C++17
+  long double erfl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 算術型の誤差関数 (error function) を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の誤差関数を返す。
@@ -33,6 +44,7 @@ namespace std {
     - `x = ±0` の場合、戻り値は `±0` となる。
     - `x = ±∞` の場合、戻り値は `±1` となる。
 - 平均μ, 標準偏差σの正規分布の累積分布関数は $$\frac{1}{2} \left( 1 + \mathrm{erf} ~ \frac{x - \mu}{\sqrt{2} \sigma} \right)$$ で与えられる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -75,3 +87,8 @@ erf(+∞) = 1.000000
 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
 
 - GCC 4.6.1 以上
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erfc -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/erfc.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/erfc.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/erfc.md b/reference/cmath/erfc.md
index 4effef62c..8f1698870 100644
--- a/reference/cmath/erfc.md
+++ b/reference/cmath/erfc.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float erfc(float x);
-  double erfc(double x);
-  long double erfc(long double x);
+  float erfc(float x);              // (1) C++11からC++20まで
+  double erfc(double x);            // (2) C++11からC++20まで
+  long double erfc(long double x);  // (3) C++11からC++20まで
 
-  double erfc(Integral x);
+  floating-point-type
+    erfc(floating-point-type x);    // (4) C++23
 
-  float erfcf(float x);             // C++17 から
-  long double erfcl(long double x); // C++17 から
+  double erfc(Integral x);          // (5) C++11
+
+  float erfcf(float x);             // (6) C++17
+  long double erfcl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 算術型の相補誤差関数 (complementary error function) を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の相補誤差関数を返す。
@@ -33,6 +44,7 @@ namespace std {
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = -∞` の場合、戻り値は `2` となる。
     - `x = +∞` の場合、戻り値は `+0` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -75,3 +87,8 @@ erfc(+∞) = 0.000000
 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
 
 - GCC 4.6.1 以上
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exp -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/exp.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/exp.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/exp.md b/reference/cmath/exp.md
index b24bb110e..1d080b751 100644
--- a/reference/cmath/exp.md
+++ b/reference/cmath/exp.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float exp(float x);
-  double exp(double x);
-  long double exp(long double x);
+  float exp(float x);              // (1) C++03からC++20まで
+  double exp(double x);            // (2) C++03からC++20まで
+  long double exp(long double x);  // (3) C++03からC++20まで
 
-  double exp(Integral x);          // C++11 から
+  floating-point-type
+    exp(floating-point-type x);    // (4) C++23
 
-  float expf(float x);             // C++17 から
-  long double expl(long double x); // C++17 から
+  double exp(Integral x);          // (5) C++11
+
+  float expf(float x);             // (6) C++17
+  long double expl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 `e` (ネイピア数) を底とする指数関数を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `e` (ネイピア数) の `x` 乗を返す。
@@ -32,9 +43,10 @@ namespace std {
 - $$ f(x) = e^x $$
 - オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `1` となる。
-	- `x = -∞` の場合、戻り値は `+0` となる。
-	- `x = +∞` の場合、戻り値は `+∞` となる。
+    - `x = ±0` の場合、戻り値は `1` となる。
+    - `x = -∞` の場合、戻り値は `+0` となる。
+    - `x = +∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -83,3 +95,8 @@ exp(-∞) = 0.000000
 以下のマクローリン級数を適当な次数で打ち切ることで近似的に求めることができる。
 
 $$ e^x = \sum_{n = 0}^{\infty} \frac{x^n}{n!} \quad \mathrm{for~all} \; x $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exp2 -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/exp2.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/exp2.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/exp2.md b/reference/cmath/exp2.md
index 1819fe338..44b28dc80 100644
--- a/reference/cmath/exp2.md
+++ b/reference/cmath/exp2.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float exp2(float x);
-  double exp2(double x);
-  long double exp2(long double x);
+  float exp2(float x);              // (1) C++11からC++20まで
+  double exp2(double x);            // (2) C++11からC++20まで
+  long double exp2(long double x);  // (3) C++11からC++20まで
 
-  double exp2(Integral x);          // C++11 から
+  floating-point-type
+    exp2(floating-point-type x);    // (4) C++23
 
-  float exp2f(float x);             // C++17 から
-  long double exp2l(long double x); // C++17 から
+  double exp2(Integral x);          // (5) C++11
+
+  float exp2f(float x);             // (6) C++17
+  long double exp2l(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 2 を底とする指数関数を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 2 の `x` 乗を返す。
@@ -33,9 +44,10 @@ namespace std {
 - $$ f(x) = 2^x $$
 - オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `1` となる。
-	- `x = -∞` の場合、戻り値は `+0` となる。
-	- `x = +∞` の場合、戻り値は `+∞` となる。
+    - `x = ±0` の場合、戻り値は `1` となる。
+    - `x = -∞` の場合、戻り値は `+0` となる。
+    - `x = +∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -104,3 +116,8 @@ namespace std {
 `exp` があれば、以下のように変換することで求められる。
 
 $$ 2^x = e^{x \log_e 2} \quad \mathrm{for~all} \; x $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>expm1 -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/expm1.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/expm1.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/expm1.md b/reference/cmath/expm1.md
index b9624739b..cf40c790d 100644
--- a/reference/cmath/expm1.md
+++ b/reference/cmath/expm1.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float expm1(float x);
-  double expm1(double x);
-  long double expm1(long double x);
+  float expm1(float x);              // (1) C++11からC++20まで
+  double expm1(double x);            // (2) C++11からC++20まで
+  long double expm1(long double x);  // (3) C++11からC++20まで
 
-  double expm1(Integral x);          // C++11 から
+  floating-point-type
+    expm1(floating-point-type x);    // (4) C++23
 
-  float expm1f(float x);             // C++17 から
-  long double expm1l(long double x); // C++17 から
+  double expm1(Integral x);          // (5) C++11
+
+  float expm1f(float x);             // (6) C++17
+  long double expm1l(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -24,6 +27,14 @@ namespace std {
 
 引数が 0 近傍において `exp(x)-1` より高精度な計算になる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `e` (ネイピア数) の `x` 乗から 1 を引いた値を返す。
@@ -35,9 +46,9 @@ namespace std {
 - $$ f(x) = e^x - 1 $$
 - オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
-	- `x = -∞` の場合、戻り値は `-1` となる。
-	- `x = +∞` の場合、戻り値は `+∞` となる。
+    - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
+    - `x = -∞` の場合、戻り値は `-1` となる。
+    - `x = +∞` の場合、戻り値は `+∞` となる。
 
 
 ## 例
@@ -81,3 +92,7 @@ expm1(-∞)  = -1.000000
 
 - GCC 4.6.1 以上
 
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hypot -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/hypot.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/hypot.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/hypot.md b/reference/cmath/hypot.md
index 041d83f2c..340bddcd1 100644
--- a/reference/cmath/hypot.md
+++ b/reference/cmath/hypot.md
@@ -7,20 +7,35 @@
 
 ```cpp
 namespace std {
-  float hypot(float x, float y);                                  // (1)
-  double hypot(double x, double y);                               // (2)
-  long double hypot(long double x, long double y);                // (3)
-
-  Promoted hypot(Arithmetic1 x, Arithmetic2 y);                   // (4)
-
-  float hypotf(float x, float y);                                 // (5) C++17 から
-  long double hypotl(long double x, long double y);               // (6) C++17 から
-
-  double hypot(double x, double y, double z);                     // (7) C++17 から
-  float hypot(float x, float y, float z);                         // (8) C++17 から
-  long double hypot(long double x, long double y, long double z); // (9) C++17 から
-
-  Promoted hypot(Arithmetic1 x, Arithmetic2 y, Arithmetic3 z);    // (10) C++17 から
+  float hypot(float x, float y);                    // (1) C++11からC++20まで
+  double hypot(double x, double y);                 // (2) C++11からC++20まで
+  long double hypot(long double x, long double y);  // (3) C++11からC++20まで
+
+  floating-point-type
+    hypot(floating-point-type x,
+          floating-point-type y);                   // (4) C++23
+
+  Promoted hypot(Arithmetic1 x, Arithmetic2 y);     // (5) C++11
+
+  float hypotf(float x, float y);                   // (6) C++17
+  long double hypotl(long double x, long double y); // (7) C++17
+
+  float hypot(float x, float y, float z);           // (8) C++17からC++20まで
+  double hypot(double x, double y, double z);       // (9) C++17からC++20まで
+  long double
+    hypot(long double x,
+          long double y,
+          long double z);                           // (10) C++17からC++20まで
+
+  floating-point-type
+    hypot(floating-point-type x,
+          floating-point-type y,
+          floating-point-type z);                   // (11) C++23
+
+  Promoted
+    hypot(Arithmetic1 x,
+          Arithmetic2 y,
+          Arithmetic3 z);                           // (12) C++17
 }
 ```
 * Promoted[italic]
@@ -43,34 +58,37 @@ $$ f(x, y) = \sqrt{x^2 + y^2} $$
 
 各オーバーロードの概要は、以下の通りである：
 
-- (1) : `double`型について、2引数の平方和の平方根を求める
-- (2) : `float`型について、2引数の平方和の平方根を求める
-- (3) : `long double`型について、2引数の平方和の平方根を求める
-- (4) : 浮動小数点数型以外の算術型について、2引数の平方和の平方根を求める
-- (5) : `float`型について、2引数の平方和の平方根を求める
-- (6) : `long double`型について、2引数の平方和の平方根を求める
-- (7) : `double`型について、3引数の平方和の平方根を求める
-- (8) : `float`型について、3引数の平方和の平方根を求める
-- (9) : `long double`型について、3引数の平方和の平方根を求める
-- (10) : 浮動小数点数型以外の算術型について、3引数の平方和の平方根を求める
+- (1) : 2引数版の`float`に対するオーバーロード
+- (2) : 2引数版の`double`に対するオーバーロード
+- (3) : 2引数版の`long double`に対するオーバーロード
+- (4) : 2引数版の浮動小数点数型に対するオーバーロード
+- (5) : 2引数版の算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : 2引数版の`float`型規定
+- (7) : 2引数版の`long double`型規定
+- (8) : 3引数版の`float`に対するオーバーロード
+- (9) : 3引数版の`double`に対するオーバーロード
+- (10) : 3引数版の`long double`に対するオーバーロード
+- (11) : 3引数版の浮動小数点数型に対するオーバーロード
+- (12) : 3引数版の算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
 
 
 ## 戻り値
-- (1)-(6) : 引数 `x` と引数 `y` の平方和の平方根を返す。
-- (7)-(10) : 引数 `x` 、引数 `y` 、引数 `z` の平方和の平方根を返す。
+- (1)-(7) : 引数 `x` と引数 `y` の平方和の平方根を返す。
+- (8)-(12) : 引数 `x` 、引数 `y` 、引数 `z` の平方和の平方根を返す。
 
 オーバーフローエラー、アンダーフローエラーが発生する可能性がある。
 
 
 ## 備考
-- (1)-(6) : $$ f(x, y) = \sqrt{x^2 + y^2} $$
-- (7)-(10) : $$ f(x, y, z) = \sqrt{x^2 + y^2 + z^2} $$
+- (1)-(7) : $$ f(x, y) = \sqrt{x^2 + y^2} $$
+- (8)-(12) : $$ f(x, y, z) = \sqrt{x^2 + y^2 + z^2} $$
 - 概要の「余計なオーバーフロー、アンダーフローを起こさない」とは、たとえ &amp;lt;code&amp;gt;x&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt; が戻り値型の範囲を超えていても、結果が戻り値型の範囲に収まるのであればオーバーフローしないで正しい結果を返す、と言う事である。
 - オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `hypot(x, y)` と `hypot(y, x)` と `hypot(x, -y)` は等価である。
-	- `hypot(x, ±0)` は、[`fabs`](fabs.md)`(x)` と等価である。
-	- `hypot(±∞, y)` の戻り値は、たとえ `y` が NaN の場合でも `+∞` となる。
+    - `hypot(x, y)` と `hypot(y, x)` と `hypot(x, -y)` は等価である。
+    - `hypot(x, ±0)` は、[`fabs`](fabs.md)`(x)` と等価である。
+    - `hypot(±∞, y)` の戻り値は、たとえ `y` が NaN の場合でも `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合、(8)、(9)、(10)が(11)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -161,14 +179,14 @@ int main()
 - [Clang](/implementation.md#clang): 2.9, 3.1
 - [GCC](/implementation.md#gcc): 4.3.4, 4.4.5, 4.5.2, 4.6.1, 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013, 2015, 2017
-	- 2002, 2003, 2005, 2008, 2010およびそれ以降では、`&amp;lt;math.h&amp;gt;`でグローバル名前空間に以下が定義されている。
-		- 仮引数・戻り値が`float`型の`_hypotf`関数が定義されている。
-		- 仮引数・戻り値が`double`型の`hypot`関数と`_hypot`関数が定義されている。
-		- 仮引数・戻り値が`long double`型の`_hypotl`マクロが定義されている。
-	- 2010, 2012およびそれ以降では、上記に加え`&amp;lt;math.h&amp;gt;`でグローバル名前空間に以下が定義されている。
-		- 仮引数・戻り値が`float`型の`hypotf`関数が定義されている。
-		- 仮引数・戻り値が`long double`型の`hypotl`マクロが定義されている。
-	- 2013以降、`_hypotl`と`hypotl`は関数として定義されている。
+    - 2002, 2003, 2005, 2008, 2010およびそれ以降では、`&amp;lt;math.h&amp;gt;`でグローバル名前空間に以下が定義されている。
+        - 仮引数・戻り値が`float`型の`_hypotf`関数が定義されている。
+        - 仮引数・戻り値が`double`型の`hypot`関数と`_hypot`関数が定義されている。
+        - 仮引数・戻り値が`long double`型の`_hypotl`マクロが定義されている。
+    - 2010, 2012およびそれ以降では、上記に加え`&amp;lt;math.h&amp;gt;`でグローバル名前空間に以下が定義されている。
+        - 仮引数・戻り値が`float`型の`hypotf`関数が定義されている。
+        - 仮引数・戻り値が`long double`型の`hypotl`マクロが定義されている。
+    - 2013以降、`_hypotl`と`hypotl`は関数として定義されている。
 
 #### 備考
 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
@@ -184,3 +202,5 @@ $$ \sqrt{x^2 + y^2} = \left| u \right| \sqrt{1 + \left( \frac{v}{u} \right)^2} \
 
 ## 参照
 - [P0030R1 Proposal to Introduce a 3-Argument Overload to `std::hypot`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0030r1.pdf)
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lgamma -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lgamma.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/lgamma.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lgamma.md b/reference/cmath/lgamma.md
index fbbfd3d71..ace61255b 100644
--- a/reference/cmath/lgamma.md
+++ b/reference/cmath/lgamma.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float lgamma(float x);
-  double lgamma(double x);
-  long double lgamma(long double x);
+  float lgamma(float x);              // (1) C++11からC++20まで
+  double lgamma(double x);            // (2) C++11からC++20まで
+  long double lgamma(long double x);  // (3) C++11からC++20まで
 
-  double lgamma(Integral x);
+  floating-point-type
+    lgamma(floating-point-type x);    // (4) C++23
 
-  float lgammaf(float x);             // C++17 から
-  long double lgammal(long double x); // C++17 から
+  double lgamma(Integral x);          // (5) C++11
+
+  float lgammaf(float x);             // (6) C++17
+  long double lgammal(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 ガンマ関数の絶対値の自然対数を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` のガンマ関数の絶対値の自然対数を返す。
@@ -36,6 +47,7 @@ namespace std {
     [`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
     - `x = -∞` の場合、戻り値は `+∞` となる。
     - `x = +∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -82,3 +94,8 @@ lgamma(+∞)  = inf
 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
 
 - GCC 4.6.1 以上
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>llrint -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/llrint.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/llrint.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/llrint.md b/reference/cmath/llrint.md
index d193710de..ad4bfdedf 100644
--- a/reference/cmath/llrint.md
+++ b/reference/cmath/llrint.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  long long llrint(float x);
-  long long llrint(double x);
-  long long llrint(long double x);
+  long long llrint(float x);        // (1) C++11からC++20まで
+  long long llrint(double x);       // (2) C++11からC++20まで
+  long long llrint(long double x);  // (3) C++11からC++20まで
 
-  long long llrint(Integral x);
+  long long
+    llrint(floating-point-type x);  // (4) C++23
 
-  long long llrintf(float x);       // C++17 から
-  long long llrintl(long double x); // C++17 から
+  long long llrint(Integral x);     // (5) C++11
+
+  long long llrintf(float x);       // (6) C++17
+  long long llrintl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 引数 `x` を現在の丸めモードで `long long` に丸めた値を得る。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を現在の丸めモードで `long long` に丸めた値
@@ -29,12 +40,13 @@ namespace std {
 ## 備考
 - 本関数は、C99 の規格にある `llrint`（より正確には `math.h` ヘッダの `llrint`、`llrintf`、`llrintl` の 3 つ。それぞれ C++ の `double`、`float`、`long double` バージョンに相当）と等価である。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- 丸めの結果が `long long` で表現不可能な場合、無効演算の浮動小数点例外（[`FE_INVALID`](../cfenv/fe_invalid.md)）が発生する。
-	- 他の例外が発生しておらず、引数 `x` が戻り値と異なってる場合、不正確結果の浮動小数点例外（[`FE_INEXACT`](../cfenv/fe_inexact.md)）が発生する。
+    - 丸めの結果が `long long` で表現不可能な場合、無効演算の浮動小数点例外（[`FE_INVALID`](../cfenv/fe_invalid.md)）が発生する。
+    - 他の例外が発生しておらず、引数 `x` が戻り値と異なってる場合、不正確結果の浮動小数点例外（[`FE_INEXACT`](../cfenv/fe_inexact.md)）が発生する。
 - C99 では、丸めモードや浮動小数点例外へのアクセスには `#pragma STDC FENV_ACCESS ON` でなければなければならないと記載されているが、C++ には該当する記載を見つけることができなかった。  
-	なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
+    なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
 - 丸めモード [`FE_TONEAREST`](../cfenv/fe_tonearest.md) は四捨五入ではなく、最近接偶数への丸めであることに注意。（例を参照）  
-	四捨五入が必要であれば、[`lround`](lround.md) を使用すること。（ただし、[`lround`](lround.md) は本関数と異なり、ISO IEC 60559 に準拠していても [`FE_INEXACT`](../cfenv/fe_inexact.md) が発生するか否かは処理系定義である）  
+    四捨五入が必要であれば、[`lround`](lround.md) を使用すること。（ただし、[`lround`](lround.md) は本関数と異なり、ISO IEC 60559 に準拠していても [`FE_INEXACT`](../cfenv/fe_inexact.md) が発生するか否かは処理系定義である）  
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -149,3 +161,8 @@ llrint(9.22337e+18) = -9223372036854775808, FE_INEXACT = false, FE_INVALID = tru
 - [GCC](/implementation.md#gcc): 4.3.6, 4.4.7, 4.5.4, 4.6.4, 4.7.3, 4.8.1, 4.8.2, 4.9.0, 4.9.1, 4.9.2, 5.1.0, 5.2.0, 6.0.0
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2013, 2015
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>log -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/log.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/log.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/log.md b/reference/cmath/log.md
index b0546b9bb..de3f1ebe7 100644
--- a/reference/cmath/log.md
+++ b/reference/cmath/log.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float log(float x);
-  double log(double x);
-  long double log(long double x);
+  float log(float x);              // (1) C++03からC++20まで
+  double log(double x);            // (2) C++03からC++20まで
+  long double log(long double x);  // (3) C++03からC++20まで
 
-  double log(Integral x);          // C++11 から
+  floating-point-type
+    log(floating-point-type x);    // (4) C++23
 
-  float logf(float x);             // C++17 から
-  long double logl(long double x); // C++17 から
+  double log(Integral x);          // (5) C++11
+
+  float logf(float x);             // (6) C++17
+  long double logl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 `e` (ネイピア数) を底とする自然対数を求める。logは「logarithm (対数)」の略である。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の `e` (ネイピア数) を底とする自然対数を返す。
@@ -32,10 +43,11 @@ namespace std {
 - $$ f(x) = \log_e x $$
 - 定義域エラー、極エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
-	- `x = 1` の場合、戻り値は `+0` となる。
-	- `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-	- `x = +∞` の場合、戻り値は `+∞` となる。
+    - `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
+    - `x = 1` の場合、戻り値は `+0` となる。
+    - `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = +∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -85,3 +97,8 @@ log(-1.0) = nan
 以下のマクローリン級数を適当な次数で打ち切ることで近似的に求めることができる。
 
 $$ \log_e (1 + x) = \sum_{n = 1}^{\infty} \frac{(-1)^{n + 1}}{n} x^n \quad \mathrm{for} \; -1 &amp;amp;lt; x \le 1 $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>log10 -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/log10.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/log10.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/log10.md b/reference/cmath/log10.md
index b50a95280..b2abb65ab 100644
--- a/reference/cmath/log10.md
+++ b/reference/cmath/log10.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float log10(float x);
-  double log10(double x);
-  long double log10(long double x);
+  float log10(float x);              // (1) C++03からC++20まで
+  double log10(double x);            // (2) C++03からC++20まで
+  long double log10(long double x);  // (3) C++03からC++20まで
 
-  double log10(Integral x);          // C++11 から
+  floating-point-type
+    log10(floating-point-type x);    // (4) C++23
 
-  float log10f(float x);             // C++17 から
-  long double log10l(long double x); // C++17 から
+  double log10(Integral x);          // (5) C++11
+
+  float log10f(float x);             // (6) C++17
+  long double log10l(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 10 を底とする常用対数を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の 10 を底とする常用対数を返す。
@@ -32,10 +43,11 @@ namespace std {
 - $$ f(x) = \log_{10} x $$
 - 定義域エラー、極エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
-	- `x = 1` の場合、戻り値は `+0` となる。
-	- `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-	- `x = +∞` の場合、戻り値は `+∞` となる。
+    - `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
+    - `x = 1` の場合、戻り値は `+0` となる。
+    - `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = +∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -118,3 +130,8 @@ log10(100000000.000000) : 8.000000
 [`log`](log.md) があれば、以下のように変換することで求められる。
 
 $$ \log_{10} x = \frac{\log_e x}{\log_e 10}$$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>log1p -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/log1p.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/log1p.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/log1p.md b/reference/cmath/log1p.md
index cbd9e8120..4cabef440 100644
--- a/reference/cmath/log1p.md
+++ b/reference/cmath/log1p.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float log1p(float x);
-  double log1p(double x);
-  long double log1p(long double x);
+  float log1p(float x);              // (1) C++11からC++20まで
+  double log1p(double x);            // (2) C++11からC++20まで
+  long double log1p(long double x);  // (3) C++11からC++20まで
 
-  double log1p(Integral x);
+  floating-point-type
+    log1p(floating-point-type x);    // (4) C++23
 
-  float log1pf(float x);             // C++17 から
-  long double log1pl(long double x); // C++17 から
+  double log1p(Integral x);          // (5) C++11
+
+  float log1pf(float x);             // (6) C++17
+  long double log1pl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -24,6 +27,14 @@ namespace std {
 
 引数が 0 近傍において [`log`](log.md)`(1 + x)` より高精度な計算になる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` に対して `1 + x` の `e` (ネイピア数) を底とする自然対数を返す。
@@ -35,10 +46,11 @@ namespace std {
 - $$ f(x) = \log_e (1 + x) $$
 - 定義域エラー、極エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `±0` となる。
-	- `x = -1` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
-	- `x &amp;lt; -1` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-	- `x = +∞` の場合、戻り値は `+∞` となる。
+    - `x = ±0` の場合、戻り値は `±0` となる。
+    - `x = -1` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
+    - `x &amp;lt; -1` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = +∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -85,3 +97,8 @@ log1p(-2.0) = -nan
 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
 
 - GCC 4.6.1 以上
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>log2 -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/log2.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/log2.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/log2.md b/reference/cmath/log2.md
index 082925fd5..a2e051fce 100644
--- a/reference/cmath/log2.md
+++ b/reference/cmath/log2.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float log2(float x);
-  double log2(double x);
-  long double log2(long double x);
+  float log2(float x);              // (1) C++11からC++20まで
+  double log2(double x);            // (2) C++11からC++20まで
+  long double log2(long double x);  // (3) C++11からC++20まで
 
-  double log2(Integral x);
+  floating-point-type
+    log2(floating-point-type x);    // (4) C++23
 
-  float log2f(float x);             // C++17 から
-  long double log2l(long double x); // C++17 から
+  double log2(Integral x);          // (5) C++11
+
+  float log2f(float x);             // (6) C++17
+  long double log2l(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 2 を底とする二進対数を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の 2 を底とする二進対数を返す。
@@ -33,10 +44,11 @@ namespace std {
 - $$ f(x) = \log_2 x $$
 - 定義域エラー、極エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
-	- `x = 1` の場合、戻り値は `+0` となる。
-	- `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
-	- `x = +∞` の場合、戻り値は `+∞` となる。
+    - `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
+    - `x = 1` の場合、戻り値は `+0` となる。
+    - `x &amp;lt; 0` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = +∞` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -145,3 +157,8 @@ log2(32) : 5, power of 2
 [`log`](log.md) があれば、以下のように変換することで求められる。
 
 $$ \log_2 x = \frac{\log_e x}{\log_e 2}$$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lrint -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lrint.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/lrint.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lrint.md b/reference/cmath/lrint.md
index dbcb5393e..f81ec4664 100644
--- a/reference/cmath/lrint.md
+++ b/reference/cmath/lrint.md
@@ -6,14 +6,16 @@
 
 ```cpp
 namespace std {
-  long lrint(float x);
-  long lrint(double x);
-  long lrint(long double x);
+  long lrint(float x);               // (1) C++11からC++20まで
+  long lrint(double x);              // (2) C++11からC++20まで
+  long lrint(long double x);         // (3) C++11からC++20まで
 
-  long lrint(Integral x);
+  long lrint(floating-point-type x); // (4) C++23
 
-  long int lrintf(float x);       // C++17 から
-  long int lrintl(long double x); // C++17 から
+  long lrint(Integral x);            // (5) C++11
+
+  long int lrintf(float x);          // (6) C++17
+  long int lrintl(long double x);    // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +23,14 @@ namespace std {
 ## 概要
 引数 `x` を現在の丸めモードで `long` に丸めた値を得る。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を現在の丸めモードで `long` に丸めた値
@@ -29,12 +39,13 @@ namespace std {
 ## 備考
 - 本関数は、C99 の規格にある `lrint`（より正確には `math.h` ヘッダの `lrint`、`lrintf`、`lrintl` の 3 つ。それぞれ C++ の `double`、`float`、`long double` バージョンに相当）と等価である。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- 丸めの結果が `long` で表現不可能な場合、無効演算の浮動小数点例外（[`FE_INVALID`](../cfenv/fe_invalid.md)）が発生する。
-	- 他の例外が発生しておらず、引数 `x` が戻り値と異なってる場合、不正確結果の浮動小数点例外（[`FE_INEXACT`](../cfenv/fe_inexact.md)）が発生する。
+    - 丸めの結果が `long` で表現不可能な場合、無効演算の浮動小数点例外（[`FE_INVALID`](../cfenv/fe_invalid.md)）が発生する。
+    - 他の例外が発生しておらず、引数 `x` が戻り値と異なってる場合、不正確結果の浮動小数点例外（[`FE_INEXACT`](../cfenv/fe_inexact.md)）が発生する。
 - C99 では、丸めモードや浮動小数点例外へのアクセスには `#pragma STDC FENV_ACCESS ON` でなければなければならないと記載されているが、C++ には該当する記載を見つけることができなかった。  
-	なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
+    なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
 - 丸めモード [`FE_TONEAREST`](../cfenv/fe_tonearest.md) は単なる四捨五入ではないことに注意。  
-	四捨五入が必要であれば、[`lround`](lround.md) を使用すること。（ただし、[`lround`](lround.md) は本関数と異なり、ISO IEC 60559 に準拠していても [`FE_INEXACT`](../cfenv/fe_inexact.md) が発生するか否かは処理系定義である）  
+    四捨五入が必要であれば、[`lround`](lround.md) を使用すること。（ただし、[`lround`](lround.md) は本関数と異なり、ISO IEC 60559 に準拠していても [`FE_INEXACT`](../cfenv/fe_inexact.md) が発生するか否かは処理系定義である）  
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -151,4 +162,9 @@ lrint(9.22337e+18) = -9223372036854775808, FE_INEXACT = false, FE_INVALID = true
 - [Visual C++](/implementation.md#visual_cpp): 2013, 2015
 
 ### 備考
-本関数は C++11 で追加されたが、Clang(libc++) では C++11 モードでなくても使用可能である。
+- 本関数は C++11 で追加されたが、Clang(libc++) では C++11 モードでなくても使用可能である
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nearbyint -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/nearbyint.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/nearbyint.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/nearbyint.md b/reference/cmath/nearbyint.md
index 8c0b6f9b9..f5d3a067b 100644
--- a/reference/cmath/nearbyint.md
+++ b/reference/cmath/nearbyint.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float nearbyint(float x);
-  double nearbyint(double x);
-  long double nearbyint(long double x);
+  float nearbyint(float x);              // (1) C++11からC++20まで
+  double nearbyint(double x);            // (2) C++11からC++20まで
+  long double nearbyint(long double x);  // (3) C++11からC++20まで
 
-  double nearbyint(Integral x);
+  floating-point-type
+    nearbyint(floating-point-type x);    // (4) C++23
 
-  float nearbyintf(float x);             // C++17 から
-  long double nearbyintl(long double x); // C++17 から
+  double nearbyint(Integral x);          // (5) C++11
+
+  float nearbyintf(float x);             // (6) C++17
+  long double nearbyintl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 引数 `x` を現在の丸めモードで整数値に丸めた値を得る。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を現在の丸めモードで整数値に丸めた値
@@ -30,11 +41,12 @@ namespace std {
 - 本関数と [`rint`](rint.md) は戻り値は同一であるが、本関数は引数 `x` が戻り値と異なっていても [`FE_INEXACT`](../cfenv/fe_invalid.md) は発生しないが、[`rint`](rint.md) は発生する可能性がある点のみ動作が異なる。
 - 本関数は、C99 の規格にある `nearbyint`（より正確には `math.h` ヘッダの `nearbyint`、`nearbyintf`、`nearbyintl` の 3 つ。それぞれ C++ の `double`、`float`、`long double` バージョンに相当）と等価である。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、`±0` を返す。
-	- `x = ±∞` の場合、`±∞` を返す。
+    - `x = ±0` の場合、`±0` を返す。
+    - `x = ±∞` の場合、`±∞` を返す。
 - C99 では、丸めモードの設定時には `#pragma STDC FENV_ACCESS ON` でなければなければならないと記載されているが、C++ には該当する記載を見つけることができなかった。  
-	なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
+    なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
 - 丸めモード [`FE_TONEAREST`](../cfenv/fe_tonearest.md) は単なる四捨五入ではないことに注意。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -120,4 +132,9 @@ FE_INEXACT = false
 - [Visual C++](/implementation.md#visual_cpp): 2013, 2015
 
 ### 備考
-本関数は C++11 で追加されたが、Clang(libc++) では C++11 モードでなくても使用可能である。
+- 本関数は C++11 で追加されたが、Clang(libc++) では C++11 モードでなくても使用可能である。
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pow -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/pow.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/pow.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/pow.md b/reference/cmath/pow.md
index 17d6a244b..2fc052767 100644
--- a/reference/cmath/pow.md
+++ b/reference/cmath/pow.md
@@ -6,18 +6,22 @@
 
 ```cpp
 namespace std {
-  float pow(float x, float y);
-  double pow(double x, double y);
-  long double pow(long double x, long double y);
+  float pow(float x, float y);                    // (1) C++03からC++20まで
+  double pow(double x, double y);                 // (2) C++03からC++20まで
+  long double pow(long double x, long double y);  // (3) C++03からC++20まで
 
-  float pow(float x, int y);                      // C++03 まで
-  double pow(double x, int y);                    // C++03 まで
-  long double pow(long double x, int y);          // C++03 まで
+  float pow(float x, int y);                      // (4) C++03まで
+  double pow(double x, int y);                    // (5) C++03まで
+  long double pow(long double x, int y);          // (6) C++03まで
 
-  Promoted pow(Arithmetic1 x, Arithmetic2 y);     // C++11 から
+  floating-point-type
+    pow(floating-point-type x,
+        floating-point-type y);                   // (7) C++23
 
-  float powf(float x, float y);                   // C++17 から
-  long double powl(long double x, long double y); // C++17 から
+  Promoted pow(Arithmetic1 x, Arithmetic2 y);     // (8) C++11
+
+  float powf(float x, float y);                   // (9) C++17
+  long double powl(long double x, long double y); // (10) C++17
 }
 ```
 * Promoted[italic]
@@ -27,6 +31,17 @@ namespace std {
 ## 概要
 `x` の `y` 乗を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : `float`に対するオーバーロードで、`int`型の`y`をとる
+- (5) : `double`に対するオーバーロードで、`int`型の`y`をとる
+- (6) : `long double`に対するオーバーロードで、`int`型の`y`をとる
+- (7) : 浮動小数点数型に対するオーバーロード
+- (8) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (9) : `float`型規定
+- (10) : `long double`型規定
+
 
 ## 戻り値
 `x` を `y` 乗した値を返す。
@@ -38,24 +53,25 @@ namespace std {
 - $$ f(x, y) = x^y $$
 - 定義域エラー、極エラー、オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `x = ±0` で `y` が負の奇数の場合、戻り値は `±∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
-	- `x = ±0` で `y` が有限でかつ負の奇数ではない場合、戻り値は `+∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
-	- `x = ±0` で `y = -∞` の場合、戻り値は `+∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する可能性がある。
-	- `x = ±0` で `y` が正の奇数の場合、戻り値は `±0` となる。
-	- `x = ±0` で `y` が正でかつ奇数ではない場合、戻り値は `+0` となる。
-	- `x = -1` で `y = ±∞` の場合、戻り値は `1` となる。
-	- `x = 1` の場合、`y` にかかわらず戻り値は `1` となる（`y` が quiet NaN の場合を含む）。
-	- `y = ±0` の場合、`x` にかかわらず戻り値は `1` となる（`x` が quiet NaN の場合を含む）。
-	- `|x| &amp;lt; 1` で `y = -∞` の場合、戻り値は `+∞` となる。
-	- `|x| &amp;gt; 1` で `y = -∞` の場合、戻り値は `+0` となる。
-	- `|x| &amp;lt; 1` で `y = +∞` の場合、戻り値は `+0` となる。
-	- `|x| &amp;gt; 1` で `y = +∞` の場合、戻り値は `+∞` となる。
-	- `x = -∞` で `y` が負の奇数の場合、戻り値は `-0` となる。
-	- `x = -∞` で `y` が負でかつ奇数ではない場合、戻り値は `+0` となる。
-	- `x = -∞` で `y` が正の奇数の場合、戻り値は `-∞` となる。
-	- `x = -∞` で `y` が正でかつ奇数ではない場合、戻り値は `+∞` となる。
-	- `x = +∞` で `y &amp;lt; 0` の場合、戻り値は `+0` となる。
-	- `x = +∞` で `y &amp;gt; 0` の場合、戻り値は `+∞` となる。
+    - `x = ±0` で `y` が負の奇数の場合、戻り値は `±∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
+    - `x = ±0` で `y` が有限でかつ負の奇数ではない場合、戻り値は `+∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
+    - `x = ±0` で `y = -∞` の場合、戻り値は `+∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する可能性がある。
+    - `x = ±0` で `y` が正の奇数の場合、戻り値は `±0` となる。
+    - `x = ±0` で `y` が正でかつ奇数ではない場合、戻り値は `+0` となる。
+    - `x = -1` で `y = ±∞` の場合、戻り値は `1` となる。
+    - `x = 1` の場合、`y` にかかわらず戻り値は `1` となる（`y` が quiet NaN の場合を含む）。
+    - `y = ±0` の場合、`x` にかかわらず戻り値は `1` となる（`x` が quiet NaN の場合を含む）。
+    - `|x| &amp;lt; 1` で `y = -∞` の場合、戻り値は `+∞` となる。
+    - `|x| &amp;gt; 1` で `y = -∞` の場合、戻り値は `+0` となる。
+    - `|x| &amp;lt; 1` で `y = +∞` の場合、戻り値は `+0` となる。
+    - `|x| &amp;gt; 1` で `y = +∞` の場合、戻り値は `+∞` となる。
+    - `x = -∞` で `y` が負の奇数の場合、戻り値は `-0` となる。
+    - `x = -∞` で `y` が負でかつ奇数ではない場合、戻り値は `+0` となる。
+    - `x = -∞` で `y` が正の奇数の場合、戻り値は `-∞` となる。
+    - `x = -∞` で `y` が正でかつ奇数ではない場合、戻り値は `+∞` となる。
+    - `x = +∞` で `y &amp;lt; 0` の場合、戻り値は `+0` となる。
+    - `x = +∞` で `y &amp;gt; 0` の場合、戻り値は `+∞` となる。
+- C++23では、(1)、(2)、(3)が(7)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -121,3 +137,6 @@ $$ x^y = e^{y \log_e x} $$
 
 ただし `x` が負数かつ `y` が整数に等しい場合などについては、別に計算する必要がある。
 
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rint -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/rint.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/rint.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/rint.md b/reference/cmath/rint.md
index 3568f563d..85e053f49 100644
--- a/reference/cmath/rint.md
+++ b/reference/cmath/rint.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float rint(float x);
-  double rint(double x);
-  long double rint(long double x);
+  float rint(float x);              // (1) C++11からC++20まで
+  double rint(double x);            // (2) C++11からC++20まで
+  long double rint(long double x);  // (3) C++11からC++20まで
 
-  double rint(Integral x);
+  floating-point-type
+    rint(floating-point-type x);    // (4) C++23
 
-  float rintf(float x);             // C++17 から
-  long double rintl(long double x); // C++17 から
+  double rint(Integral x);          // (5) C++11
+
+  float rintf(float x);             // (6) C++17
+  long double rintl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 引数 `x` を現在の丸めモードで整数値に丸めた値を得る。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を現在の丸めモードで整数値に丸めた値
@@ -30,12 +41,13 @@ namespace std {
 - 本関数と [`nearbyint`](nearbyint.md) は戻り値は同一であるが、本関数は引数 `x` が戻り値と異なってる場合 [`FE_INEXACT`](../cfenv/fe_inexact.md) が発生する可能性があるが、[`nearbyint`](nearbyint.md) は発生しない点のみ動作が異なる。
 - 本関数は、C99 の規格にある `rint`（より正確には `math.h` ヘッダの `rint`、`rintf`、`rintl` の 3 つ。それぞれ C++ の `double`、`float`、`long double` バージョンに相当）と等価である。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、`±0` を返す。
-	- `x = ±∞` の場合、`±∞` を返す。
-	- 引数 `x` が戻り値と異なってる場合、[`FE_INEXACT`](../cfenv/fe_inexact.md) が発生する。
+    - `x = ±0` の場合、`±0` を返す。
+    - `x = ±∞` の場合、`±∞` を返す。
+    - 引数 `x` が戻り値と異なってる場合、[`FE_INEXACT`](../cfenv/fe_inexact.md) が発生する。
 - C99 では、丸めモードの設定時には `#pragma STDC FENV_ACCESS ON` でなければなければならないと記載されているが、C++ には該当する記載を見つけることができなかった。  
-	なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
+    なお、C99 でも `FENV_ACCESS` のデフォルトは処理系定義である。
 - 丸めモード [`FE_TONEAREST`](../cfenv/fe_tonearest.md) は単なる四捨五入ではないことに注意。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -122,4 +134,9 @@ FE_INEXACT = true
 - [Visual C++](/implementation.md#visual_cpp): 2013, 2015
 
 ### 備考
-本関数は C++11 で追加されたが、Clang(libc++) では C++11 モードでなくても使用可能である。
+- 本関数は C++11 で追加されたが、Clang(libc++) では C++11 モードでなくても使用可能である。
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sin -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sin.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/sin.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sin.md b/reference/cmath/sin.md
index e26f6e35b..3b9d23e24 100644
--- a/reference/cmath/sin.md
+++ b/reference/cmath/sin.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float sin(float x);
-  double sin(double x);
-  long double sin(long double x);
+  float sin(float x);              // (1) C++03からC++20まで
+  double sin(double x);            // (2) C++03からC++20まで
+  long double sin(long double x);  // (3) C++03からC++20まで
 
-  double sin(Integral x);          // C++11 から
+  floating-point-type
+    sin(floating-point-type x);    // (4) C++23
 
-  float sinf(float x);             // C++17 から
-  long double sinl(long double x); // C++17 から
+  double sin(Integral x);          // (5) C++11
+
+  float sinf(float x);             // (6) C++17
+  long double sinl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 算術型の正弦（サイン）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の正弦を返す(`x`の単位はラジアン)。
@@ -29,8 +40,9 @@ namespace std {
 ## 備考
 - $$ f(x) = \sin x $$
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
-	- `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
+    - `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -109,3 +121,8 @@ $$ \sin x = \sum_{n = 0}^{\infty} \frac{(-1)^n}{(2n + 1)!} x^{2n + 1} \quad \mat
 
 ## 関連項目
 - [`std::numbers::pi`](/reference/numbers/pi.md)
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sinh -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sinh.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/sinh.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sinh.md b/reference/cmath/sinh.md
index fabccedce..48337b7b6 100644
--- a/reference/cmath/sinh.md
+++ b/reference/cmath/sinh.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float sinh(float x);
-  double sinh(double x);
-  long double sinh(long double x);
+  float sinh(float x);              // (1) C++03からC++20まで
+  double sinh(double x);            // (2) C++03からC++20まで
+  long double sinh(long double x);  // (3) C++03からC++20まで
 
-  double sinh(Integral x);          // C++11 から
+  floating-point-type
+    sinh(floating-point-type x);    // (4) C++23
 
-  float sinhf(float x);             // C++17 から
-  long double sinhl(long double x); // C++17 から
+  double sinh(Integral x);          // (5) C++11
+
+  float sinhf(float x);             // (6) C++17
+  long double sinhl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 算術型の双曲線正弦（ハイパボリックサイン）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の双曲線正弦を返す。
@@ -32,8 +43,9 @@ namespace std {
 - $$ f(x) = \sinh x $$
 - オーバーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `x = ±0` の場合、戻り値は `±0` となる。
-	- `x = ±∞` の場合、戻り値は `±∞` となる。
+    - `x = ±0` の場合、戻り値は `±0` となる。
+    - `x = ±∞` の場合、戻り値は `±∞` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -70,6 +82,7 @@ sinh(1.0)  = 1.175201
 
 #### 備考
 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+
 - GCC 4.6.1 以上
 
 
@@ -77,3 +90,8 @@ sinh(1.0)  = 1.175201
 以下のマクローリン級数を適当な次数で打ち切ることで近似的に求めることができる。
 
 $$ \sinh x = \sum_{n = 0}^{\infty} \frac{1}{(2n + 1)!} x^{2n + 1} \quad \mathrm{for~all} \; x $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sqrt -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sqrt.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/sqrt.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sqrt.md b/reference/cmath/sqrt.md
index d091d8a0a..b46859851 100644
--- a/reference/cmath/sqrt.md
+++ b/reference/cmath/sqrt.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float sqrt(float x);
-  double sqrt(double x);
-  long double sqrt(long double x);
+  float sqrt(float x);              // (1) C++03からC++20まで
+  double sqrt(double x);            // (2) C++03からC++20まで
+  long double sqrt(long double x);  // (3) C++03からC++20まで
 
-  double sqrt(Integral x);          // C++11 から
+  floating-point-type
+    sqrt(floating-point-type x);    // (4) C++23
 
-  float sqrtf(float x);             // C++17 から
-  long double sqrtl(long double x); // C++17 から
+  double sqrt(Integral x);          // (5) C++11
+
+  float sqrtf(float x);             // (6) C++17
+  long double sqrtl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 算術型の非負の平方根を求める。sqrtは square root (平方根) の略。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の非負の平方根を返す。
@@ -33,8 +44,9 @@ namespace std {
 - $$ f(x) = \sqrt{x} $$
 - 定義域エラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `x = ±0` の場合、戻り値は `±0` となる。
+    - `x = ±0` の場合、戻り値は `±0` となる。
 - `-0.0`は`0.0`と等しいため、定義域エラーにはならず、`-0.0`が返る
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -95,3 +107,8 @@ sqrt(-1.0) = -nan
 $$ a_{n + 1} = \frac{\frac{x}{a_n} + a_n}{2} \quad \mathrm{for} \; x \geq 0 $$
 
 ただし `x` は引数、`a` の初期値は適当な値を選ぶものとする。
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tan -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tan.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/tan.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tan.md b/reference/cmath/tan.md
index 0cb997396..18b7e1e63 100644
--- a/reference/cmath/tan.md
+++ b/reference/cmath/tan.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float tan(float x);
-  double tan(double x);
-  long double tan(long double x);
+  float tan(float x);              // (1) C++03からC++20まで
+  double tan(double x);            // (2) C++03からC++20まで
+  long double tan(long double x);  // (3) C++03からC++20まで
 
-  double tan(Integral x);          // C++11 から
+  floating-point-type
+    tan(floating-point-type x);    // (4) C++23
 
-  float tanf(float x);             // C++17 から
-  long double tanl(long double x); // C++17 から
+  double tan(Integral x);          // (5) C++11
+
+  float tanf(float x);             // (6) C++17
+  long double tanl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 算術型の正接（タンジェント）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の正接を返す(`x`の単位はラジアン)。
@@ -29,8 +40,9 @@ namespace std {
 ## 備考
 - $$ f(x) = \tan x $$
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
-	- `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
-	- `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+    - `x = ±0` の場合、戻り値は `±0` となる。（複号同順）
+    - `x = ±∞` の場合、戻り値は quiet NaN となり、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -72,6 +84,7 @@ tan(pi/2) = 16331239353195370.000000
 
 #### 備考
 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+
 - GCC 4.6.1 以上
 
 
@@ -83,3 +96,8 @@ $$ \tan x = \sum_{n = 1}^{\infty} \frac{B_{2n}(-4)^n(1-4^n)}{(2n)!} x^{2n - 1} \
 以下の公式から求めることができる。
 
 $$ \tan x = \frac{\sin x}{\cos x} $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tanh -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tanh.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/tanh.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tanh.md b/reference/cmath/tanh.md
index 487a1d1ae..d2ae4edd8 100644
--- a/reference/cmath/tanh.md
+++ b/reference/cmath/tanh.md
@@ -6,14 +6,17 @@
 
 ```cpp
 namespace std {
-  float tanh(float x);
-  double tanh(double x);
-  long double tanh(long double x);
+  float tanh(float x);              // (1) C++03からC++20まで
+  double tanh(double x);            // (2) C++03からC++20まで
+  long double tanh(long double x);  // (3) C++03からC++20まで
 
-  double tanh(Integral x);          // C++11 から
+  floating-point-type
+    tanh(floating-point-type x);    // (4) C++23
 
-  float tanhf(float x);             // C++17 から
-  long double tanhl(long double x); // C++17 から
+  double tanh(Integral x);          // (5) C++11
+
+  float tanhf(float x);             // (6) C++17
+  long double tanhl(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +24,14 @@ namespace std {
 ## 概要
 算術型の双曲線正接（ハイパボリックタンジェント）を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の双曲線正接を返す。
@@ -29,8 +40,9 @@ namespace std {
 ## 備考
 - $$ f(x) = \tanh x $$
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `x = ±0` の場合、戻り値は `±0` となる。
-	- `x = ±∞` の場合、戻り値は `±1` となる。
+    - `x = ±0` の場合、戻り値は `±0` となる。
+    - `x = ±∞` の場合、戻り値は `±1` となる。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -77,3 +89,8 @@ $$ \tanh x = \sum_{n = 1}^{\infty} \frac{B_{2n}4^n(4^n - 1)}{(2n)!} x^{2n - 1} \
 以下の公式から求めることができる。
 
 $$ \tanh x = \frac{\sinh x}{\cosh x} $$
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tgamma -- &lt;cmath&gt; : 拡張浮動小数点数型への対応続き。途中で力尽きた #1022</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tgamma.html"/>
      <id>ace1860c41772f23dc20e50b11b68c5890c2d430:reference/cmath/tgamma.md</id>
      <updated>2023-02-17T18:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tgamma.md b/reference/cmath/tgamma.md
index e085208c7..0ed6c691b 100644
--- a/reference/cmath/tgamma.md
+++ b/reference/cmath/tgamma.md
@@ -7,14 +7,17 @@
 
 ```cpp
 namespace std {
-  float tgamma(float x);
-  double tgamma(double x);
-  long double tgamma(long double x);
+  float tgamma(float x);              // (1) C++11からC++20まで
+  double tgamma(double x);            // (2) C++11からC++20まで
+  long double tgamma(long double x);  // (3) C++11からC++20まで
 
-  double tgamma(Integral x);
+  floating-point-type
+    tgamma(floating-point-type x);    // (4) C++23
 
-  float tgammaf(float x);             // C++17 から
-  long double tgammal(long double x); // C++17 から
+  double tgamma(Integral x);          // (5) C++11
+
+  float tgammaf(float x);             // (6) C++17
+  long double tgammal(long double x); // (7) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +25,14 @@ namespace std {
 ## 概要
 ガンマ関数を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` のガンマ関数を返す。
@@ -39,6 +50,7 @@ namespace std {
     [`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
     - `x = +∞` の場合、戻り値は `+∞` となる。
 - `gamma` という関数は既にあったが処理系によって定義が違ったため、本当の (true) ガンマ関数 `tgamma` と名付けられた。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -85,3 +97,8 @@ tgamma(+∞)  = inf
 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
 
 - GCC 4.6.1 以上
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++20 -- P0593R6初稿 #117</title>
      <link href="https://cpprefjp.github.io/lang/cpp20.html"/>
      <id>88c08cc878fdca30b520859de47d8367e91b0e35:lang/cpp20.md</id>
      <updated>2023-02-17T18:09:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++20&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20とは、2020年中に改訂され、ISO/IEC 14882:2020で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++2aと呼ばれることがあった。「202a年にリリースされる」という伏せ字として「a」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;クラス&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html&#34;&gt;一貫比較&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;三方比較演算子によって比較演算子の自動生成を行うようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_member_initializers_for_bit_fields.html&#34;&gt;ビットフィールドのメンバ変数初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ビットフィールドメンバ変数のデフォルト値を設定する構文を追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/explicit_bool.html&#34;&gt;関数を条件付きで&lt;code&gt;explicit&lt;/code&gt;にする構文を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;explicit(true)&lt;/code&gt;のように&lt;code&gt;explicit&lt;/code&gt;に真理値パラメータを指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/fixing_const_qualified_pointers_to_members.html&#34;&gt;&lt;code&gt;const&lt;/code&gt;修飾されたメンバポインタの制限を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.*&lt;/code&gt;演算子での左辺値の&lt;code&gt;const&lt;/code&gt;メンバ関数呼び出しを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/resolving_const_mismatch_with_defaulted_copy_constructor.html&#34;&gt;デフォルトのコピーコンストラクタと非&lt;code&gt;const&lt;/code&gt;なコンストラクタが衝突する問題を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非&lt;code&gt;const&lt;/code&gt;なオブジェクトをとるコンストラクタを定義すると、そのクラスをラップしたクラスのコピーコンストラクタが&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;になってしまう問題を修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/access_checking_on_specializations.html&#34;&gt;特殊化のアクセスチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/language_support_for_empty_objects.html&#34;&gt;空オブジェクトに対する最適化を支援する属性&lt;code&gt;[[no_unique_address]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[no_unique_address]]&lt;/code&gt;属性を導入し、空の型のオブジェクトをほかのオブジェクトと共有する最適化を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_structured_bindings_to_accessible_members.html&#34;&gt;friend指定された関数内から構造化束縛を使用して非公開メンバ変数にアクセスすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛の仕様として公開メンバ変数のみを取り出せるようになっていたが、friend指定された関数からは非公開メンバ変数にもアクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_structured_bindings_customization_point_finding_rules.html&#34;&gt;構造化束縛がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非テンプレートの&lt;code&gt;get()&lt;/code&gt;メンバ関数が見つかった場合は、非メンバ関数の&lt;code&gt;get()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/checking_for_abstract_class_types.html&#34;&gt;抽象型のチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の宣言段階では、パラメータおよび戻り値型が抽象型かどうかをチェックしないようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.html&#34;&gt;可変長データを扱うクラスの効率的な&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラスの&lt;code&gt;delete&lt;/code&gt;演算子が呼び出される前にデストラクタが呼ばれないようにするオプションを追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/conditionally_trivial_special_member_functions.md.nolink&#34;&gt;条件付きで特殊メンバ関数をトリビアルに定義するように&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;制約によってトリビアルな特殊メンバ関数と非トリビアルな特殊メンバ関数をオーバーロードできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html&#34;&gt;未初期化領域への暗黙的なオブジェクト構築&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;未初期化領域の利用時に自動的にトリビアルな型のオブジェクトを構築する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;列挙型&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/using_enum.html&#34;&gt;スコープ付き列挙型のusing宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;using enum EnumType;&lt;/code&gt;もしくは&lt;code&gt;using EnumType::enumerator&lt;/code&gt;とすることで、列挙値のスコープ指定を省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/designated_initialization.html&#34;&gt;指示付き初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波カッコによる集成体初期化でメンバ名を指定して初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/extending_structured_bindings_to_be_more_like_variable_declarations.html&#34;&gt;構造化束縛を拡張して通常の変数宣言のように使用できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;記憶域指定子として&lt;code&gt;static&lt;/code&gt;と&lt;code&gt;thread_local&lt;/code&gt;の指定を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html&#34;&gt;丸カッコの値リストからの集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T x{1, 2, 3};&lt;/code&gt;と同様に&lt;code&gt;T x(1, 2, 3);&lt;/code&gt;でも集成体初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/array_size_deduction_in_new-expressions.html&#34;&gt;&lt;code&gt;new&lt;/code&gt;式での配列要素数の推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double* p = new double[]{1,2,3};&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.html&#34;&gt;要素数不明の配列への変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;要素数が判明している配列から、要素数が不明の配列への変換を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html&#34;&gt;ほとんどの&lt;code&gt;volatile&lt;/code&gt;を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;volatile&lt;/code&gt;の有用な機能のみを残し、効果が疑わしい、または壊れている機能を非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.html&#34;&gt;ポインタから&lt;code&gt;bool&lt;/code&gt;への変換を縮小変換とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ポインタから&lt;code&gt;bool&lt;/code&gt;値への変換を縮小変換と規定することで、意図しない変換を防止する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;整数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html&#34;&gt;符号付き整数型が2の補数表現であることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;符号付き整数型のビット表現を2の補数に規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/char8_t.html&#34;&gt;UTF-8エンコーディングされた文字の型として&lt;code&gt;char8_t&lt;/code&gt;を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-8エンコードされた文字かどうかでオーバーロード・特殊化をできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/make_char16t_char32t_string_literals_be_utf16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;の文字・文字列リテラルを、文字コードUTF-16/32に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__STDC_UTF_16__&lt;/code&gt;、&lt;code&gt;__STDC_UTF_32__&lt;/code&gt;の定義に関係なく、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のリテラルをUTF-16/32文字コードに規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nodiscard_should_have_a_reason.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性に理由となる文字列を付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値を無視してはならない理由を関数宣言に持たせ、警告メッセージに役立てる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nodiscard_for_constructors.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;をコンストラクタのオーバーロードごとに付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リソース確保するコンストラクタにのみ&lt;code&gt;[[nodisacrd]]&lt;/code&gt;を付加できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;制御構文&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/range-based_for_statements_with_initializer.html&#34;&gt;初期化式をともなう範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;範囲for文スコープで使用する変数の初期化のための構文を追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.html&#34;&gt;範囲for文がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;メンバ関数のどちらかが見つからなかった場合に非メンバ関数の&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/likely_and_unlikely_attributes.html&#34;&gt;確率が高い分岐と低い分岐を伝える属性 &lt;code&gt;[[likely]]&lt;/code&gt;, &lt;code&gt;[[unlikely]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;条件分岐の最適化ヒントを与える属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/concepts.html&#34;&gt;コンセプト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータに対する制約を行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/function_templates_with_auto_parameters.html&#34;&gt;autoパラメータによる関数テンプレートの簡易定義&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダと同様、関数パラメータをの型を&lt;code&gt;auto&lt;/code&gt;にすることで簡易的に関数テンプレートを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/down_with_typename.html&#34;&gt;型の文脈で&lt;code&gt;typename&lt;/code&gt;の省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型しか現れない文脈では、依存名を解決するための&lt;code&gt;typename&lt;/code&gt;キーワードを省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_types_in_non-type_template_parameters.html&#34;&gt;非型テンプレートパラメータとしてクラス型を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式として使用できる型を広く非型テンプレートパラメータとして使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/adl_and_function_templates_that_are_not_visible.html&#34;&gt;関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;名前空間内の関数テンプレートをテンプレート引数指定かつ非修飾・ADLで正しく呼び出せるよう修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_aggregates.html&#34;&gt;集成体クラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートのテンプレート引数推論はコンストラクタ引数から推論されるが、集成体初期化からも推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_alias_templates.html&#34;&gt;エイリアステンプレート経由でのクラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エイリアステンプレートからクラステンプレートのテンプレート引数を推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/less_eager_instantiation_of_constexpr_functions.html&#34;&gt;評価されない文脈での定数式評価によって特殊メンバ関数がインスタンス化されることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof&lt;/code&gt;や&lt;code&gt;decltype&lt;/code&gt;などの評価されない文脈において定数式評価を行った場合に、ムーブコンストラクタのような特殊メンバ関数が定義されることを規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_virtual_function_calls_in_constant_expressions.html&#34;&gt;定数式からの仮想関数の呼び出しを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;仮想関数に&lt;code&gt;constexpr&lt;/code&gt;を付けられない制限を解除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allowing_dynamic_cast_polymorphic_typeid_in_constant_expressions.html&#34;&gt;定数式での&lt;code&gt;dynamic_cast&lt;/code&gt;、多態的な&lt;code&gt;typeid&lt;/code&gt;を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式での動的多態を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/try-catch_blocks_in_constexpr_functions.html&#34;&gt;constexpr関数内でのtry-catchブロックを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内で&lt;code&gt;try-catch&lt;/code&gt;ブロックを書けるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/immediate_functions.html&#34;&gt;即時関数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;consteval&lt;/code&gt;キーワードを追加し、常に定数式評価されるよう指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/changing_the_active_member_of_a_union_inside_constexpr.html&#34;&gt;定数式内での共用体のアクティブメンバの変更を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体メンバの書き換えを定数式内で行えるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.html&#34;&gt;constexpr関数内でのトリビアルなデフォルト初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内でのデフォルト初期化を許可し、未初期化値を読むことのみ禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.html&#34;&gt;constexpr関数内で未評価のインラインアセンブリを許可することによる組み込み関数のconstexpr有効化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に評価されない場合にconstexpr関数にasm定義を含めることを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/constinit.html&#34;&gt;コンパイル時初期化を強制する&lt;code&gt;constinit&lt;/code&gt;キーワードを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化のみコンパイル時におわらせたい場合に使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html&#34;&gt;可変サイズをもつコンテナの&lt;code&gt;constexpr&lt;/code&gt;化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;記憶域をもつメモリアロケータの存在を考慮することで、可変サイズをもつコンテナをコンパイル時に使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ラムダ式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/familiar_template_syntax_for_generic_lambdas.html&#34;&gt;ジェネリックラムダのテンプレート構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダでテンプレートパラメータを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_lambda_capture_equal_this.html&#34;&gt;ラムダ式のキャプチャとして&lt;code&gt;[=, this]&lt;/code&gt;を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトコピーキャプチャと&lt;code&gt;this&lt;/code&gt;ポインタのコピーキャプチャを両方指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタをキャプチャされなくする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/simplifying_implicit_lambda_capture.html&#34;&gt;暗黙のラムダキャプチャを簡略化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式のキャプチャに関する仕様整理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_constructible_and_assignable_stateless_lambdas.html&#34;&gt;状態を持たないラムダ式を、デフォルト構築可能、代入可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャしていないラムダ式をデフォルト構築・代入可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html&#34;&gt;評価されない文脈でのラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;評価されない文脈でもラムダ式を書くことができるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_pack_expansion_in_lambda_init_capture.html&#34;&gt;ラムダ式の初期化キャプチャでのパック展開を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[...args = std::move(args)]&lt;/code&gt;のようなキャプチャを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reference_capture_of_structured_bindings.html&#34;&gt;構造化束縛した変数の参照キャプチャを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛をした変数は特殊な扱いのためラムダ式で参照キャプチャできない規定となっていたがこれを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;名前空間&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nested_inline_mamespaces.html&#34;&gt;入れ子名前空間定義でのインライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;namespace ns1::inline ns2::ns3 {}&lt;/code&gt;のように、入れ子名前空間を定義する式にインライン名前空間の指定を含められるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;モジュール化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/modules.html&#34;&gt;モジュール&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ヘッダファイル・ソースファイル、インクルードに変わる仕組みとしてモジュールを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/coroutines.html&#34;&gt;コルーチン&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数実行を中断・再開する仕組みとしてコルーチンを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;プリプロセッサ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/va_opt.html&#34;&gt;可変引数が空でない場合のトークン置換&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサの置換で可変引数が空の場合に余計なカンマが付いてしまう問題に対処&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_pod.html&#34;&gt;PODを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PODという用語を非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタのキャプチャを非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_uses_of_the_comma_operator_in_subscripting_expressions.html&#34;&gt;添字演算子内でのカンマ演算子の使用を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ar[i, j]&lt;/code&gt;を非推奨化。&lt;code&gt;ar[(i, j)]&lt;/code&gt;はOK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/remove_deprecated_nothrow_exception_specification.html&#34;&gt;&lt;code&gt;throw()&lt;/code&gt;による例外送出しない指定を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;代わりに&lt;code&gt;noexcept&lt;/code&gt;を使用すること&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/prohibit_aggregates_with_user-declared_constructors.html&#34;&gt;ユーザー宣言したコンストラクタを持つクラスの集成体初期化を禁止&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタが&lt;code&gt;delete&lt;/code&gt;／&lt;code&gt;default&lt;/code&gt;宣言されているクラスを、集成体初期化によってコンストラクタ呼び出しを回避して構築できてしまっていた技法を禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/update_the_reference_to_the_unicode_standard.html&#34;&gt;Unicode標準への参照を更新&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準C++からISO/IEC 10646への参照を更新する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reserving_attribute_namespaces_for_future_use.html&#34;&gt;属性の名前空間を予約&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将来の使用のために属性の名前空間を予約&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;バージョン情報ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/version.html&#34;&gt;&amp;lt;version&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。ここでは、実装依存の情報 (バージョンやリリース日付など) が標準ライブラリの実装によって定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;ライブラリに、カレンダーとタイムゾーンの機能を拡張&lt;/li&gt;
&lt;li&gt;任意のシーケンスの部分シーケンスを参照するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/span.html&#34;&gt;&amp;lt;span&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;文字列フォーマットライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format.html&#34;&gt;&amp;lt;format&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;出力ストリームを同期するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/syncstream.html&#34;&gt;&amp;lt;syncstream&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;三方比較ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numbers.html&#34;&gt;&amp;lt;numbers&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。数学定数が定義される&lt;/li&gt;
&lt;li&gt;ビット操作ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit.html&#34;&gt;&amp;lt;bit&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;Strict Aliasing規則に抵触しないビットレベルの再解釈キャストである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_cast.html&#34;&gt;std::bit_cast()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;1ビットだけ立っている値をもっているかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/has_single_bit.html&#34;&gt;std::has_single_bit()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;整数値を2の累乗値に切り上げる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_ceil.html&#34;&gt;std::bit_ceil()&lt;/a&gt;&lt;/code&gt;関数、整数値を2の累乗値に切り下げる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_floor.html&#34;&gt;std::bit_floor()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;値を表現するために必要なビット幅を求める&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_width.html&#34;&gt;std::bit_width()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;循環ビットシフトを行う&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/rotl.html&#34;&gt;std::rotl()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/rotr.html&#34;&gt;std::rotr()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;連続した0もしくは1のビットを数える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countl_zero.html&#34;&gt;std::countl_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countl_one.html&#34;&gt;std::countl_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countr_zero.html&#34;&gt;std::countr_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countr_one.html&#34;&gt;std::countr_one()&lt;/a&gt;&lt;/code&gt;、および立っているビットを数える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/popcount.html&#34;&gt;std::popcount()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;エンディアンを表す列挙型として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/endian.html&#34;&gt;std::endian&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;型制約のための要件ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts.html&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;言語機能であるコルーチンを制御するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/coroutine.html&#34;&gt;&amp;lt;coroutine&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッドの実行を停止させるメカニズムとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stop_token.html&#34;&gt;&amp;lt;stop_token&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加し、停止に対応したスレッドクラスとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread.html&#34;&gt;&amp;lt;thread&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/jthread.html&#34;&gt;std::jthread&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;軽量な同期プリミティブであるセマフォのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/semaphore.html&#34;&gt;&amp;lt;semaphore&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッド調整メカニズムとして、ラッチライブラリの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/latch.html&#34;&gt;&amp;lt;latch&amp;gt;&lt;/a&gt;&lt;/code&gt;、バリアライブラリの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/barrier.html&#34;&gt;&amp;lt;barrier&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータの組ではなく、コンテナや配列、部分的なコンテナなどを扱う範囲ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;既存のイテレータの組を扱うアルゴリズムは、&lt;code&gt;std::ranges&lt;/code&gt;名前空間に範囲版アルゴリズムが追加される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ソースコードの位置を取得するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/source_location.html&#34;&gt;&amp;lt;source_location&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;取り決め&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std&lt;/code&gt;名前空間以下の関数テンプレートをユーザーが特殊化することを禁止する (参照 : &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf&#34; target=&#34;_blank&#34;&gt;P0551R3&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;連想コンテナに、要素がコンテナに含まれているかを判定する&lt;code&gt;contains()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;順序付き連想コンテナと同様に、非順序連想コンテナの検索処理で、一時オブジェクトが生成されるコストを抑える拡張を追加。キー等値比較を行う関数オブジェクトとハッシュ計算を行う関数オブジェクトの両方に&lt;code&gt;is_transparent&lt;/code&gt;が定義されていれば、透過的な検索が使用できる。&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;クラスのページを参照&lt;/li&gt;
&lt;li&gt;各コンテナの非メンバ関数として、要素を削除する&lt;code&gt;std::erase()&lt;/code&gt;関数と&lt;code&gt;std::erase_if()&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;のメンバ関数&lt;code&gt;remove()&lt;/code&gt;、&lt;code&gt;remove_if()&lt;/code&gt;、&lt;code&gt;unique()&lt;/code&gt;の戻り値型を、&lt;code&gt;void&lt;/code&gt;から&lt;code&gt;Container::size_type&lt;/code&gt;に変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;クラスの比較演算子、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/fill.html&#34;&gt;fill()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;組み込み配列を&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;に変換する関数として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/to_array.html&#34;&gt;std::to_array()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数としてコンテナの要素数を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ssize.html&#34;&gt;std::ssize()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;、および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/vector/vector.html&#34;&gt;std::vector&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;の多くの関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素位置をシフトする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shift_left.html&#34;&gt;std::shift_left()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shift_right.html&#34;&gt;std::shift_right()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に三方比較による辞書順比較アルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/lexicographical_compare_three_way.html&#34;&gt;std::lexicographical_compare_three_way()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値とポインタの中点を求める関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/midpoint.html&#34;&gt;std::midpoint()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;浮動小数点数を線形補間する関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/lerp.html&#34;&gt;std::lerp()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムをムーブに対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムに&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_insert_iterator.html&#34;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_insert_iterator.html&#34;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/insert_iterator.html&#34;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt;クラスのコンストラクタ、代入演算子、間接参照演算子、インクリメント演算子、および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_inserter.html&#34;&gt;std::back_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_inserter.html&#34;&gt;std::front_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/inserter.html&#34;&gt;std::inserter()&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;constexpr&lt;/code&gt;を追加。これらのクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/ref.html&#34;&gt;std::ref()&lt;/a&gt;&lt;/code&gt;関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/cref.html&#34;&gt;std::cref()&lt;/a&gt;&lt;/code&gt;関数のテンプレートパラメータ&lt;code&gt;T&lt;/code&gt;型に不完全型を指定することを許可&lt;/li&gt;
&lt;li&gt;メンバ関数の部分適用を簡単にするために、プレースホルダーの指定なく引数を先頭から順に束縛する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;の各操作、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;std::not_fn()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;std::bind()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;std::mem_fn()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;li&gt;コンセプトの導入にともない、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った値をそのまま返す関数オブジェクト&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/identity.html&#34;&gt;std::identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;クラスに、先頭の部分文字列を判定する&lt;code&gt;starts_with()&lt;/code&gt;メンバ関数、末尾の部分文字列を判定する&lt;code&gt;ends_with()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数の、メモリの縮小機能を削除し、伸長のみとする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits.html&#34;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/move.html&#34;&gt;move()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/copy.html&#34;&gt;copy()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/assign.html&#34;&gt;assign()&lt;/a&gt;&lt;/code&gt;静的メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが、値初期化するよう動作変更。これまではC言語との互換性のために未初期化となっていた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの浮動小数点数型に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;アトミッククラスに対するブロッキング同期の機能として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/wait.html&#34;&gt;wait()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html&#34;&gt;notify_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/notify_all.html&#34;&gt;notify_all()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ロックフリーであることが保証されたアトミック整数型の別名として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;atomic_signed_lock_free&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;atomic_unsigned_lock_free&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/memory_order.html&#34;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;の列挙子にスコープをもたせた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスに、&lt;code&gt;bool&lt;/code&gt;値を読み込むメンバ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag/test.html&#34;&gt;test()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;非アトミックなオブジェクトにアトミック操作を適用するためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ベクトル化の実行ポリシーとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unsequenced_policy&lt;/a&gt;&lt;/code&gt;型と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unseq&lt;/a&gt;&lt;/code&gt;タグを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同期ストリームの追加にともなって、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream.html&#34;&gt;&amp;lt;ostream&amp;gt;&lt;/a&gt;&lt;/code&gt;に、同期ストリーム関係の出力マニピュレータを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/istream/basic_istream/op_istream_free.html&#34;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;(basic_istream&amp;amp;, CharT*)&lt;/code&gt;を&lt;code&gt;operator&amp;gt;&amp;gt;(basic_istream&amp;amp;, CharT (&amp;amp;)[N])&lt;/code&gt;に修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream/basic_ostream/op_ostream_free.html&#34;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;wchar_t&lt;/code&gt; (&lt;code&gt;char&lt;/code&gt;版のみ)、&lt;code&gt;char8_t&lt;/code&gt;、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のdelete宣言を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/istream_iterator.html&#34;&gt;std::istream_iterator&lt;/a&gt;&lt;/code&gt;について、要件の書き方を整理し、振る舞いをより明確化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::basic_stringbuf&lt;/code&gt;、&lt;code&gt;std::basic_istringstream&lt;/code&gt;、&lt;code&gt;std::basic_ostringstream&lt;/code&gt;クラスに、アロケータを伝播させるためのインタフェースを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_shared.html&#34;&gt;std::make_shared()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocate_shared.html&#34;&gt;std::allocate_shared()&lt;/a&gt;&lt;/code&gt;を配列に対応&lt;/li&gt;
&lt;li&gt;スマートポインタをデフォルト初期化で構築するヘルパ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_unique_for_overwrite.html&#34;&gt;std::make_unique_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_shared_for_overwrite.html&#34;&gt;std::make_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocate_shared_for_overwrite.html&#34;&gt;std::allocate_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ポインタを生ポインタに変換する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/to_address.html&#34;&gt;std::to_address()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_traits.html&#34;&gt;std::pointer_traits&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_traits/pointer_to.html&#34;&gt;pointer_to()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Nバイトアライメントされたポインタであることをコンパイラに伝える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/assume_aligned.html&#34;&gt;std::assume_aligned()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、uses allocator構築をサポートするユーティリティ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/uses_allocator_construction_args.html&#34;&gt;std::uses_allocator_construction_args()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_obj_using_allocator.html&#34;&gt;std::make_obj_using_allocator()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/uninitialized_construct_using_allocator.html&#34;&gt;std::uninitialized_construct_using_allocator()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator.html&#34;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;に、以下の変更を追加：&lt;ul&gt;
&lt;li&gt;クラステンプレートのデフォルトテンプレート引数を&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;&lt;/code&gt;型とした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt;のバイト列をメモリ確保する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/allocate_bytes.html&#34;&gt;allocate_bytes()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/deallocate_bytes.html&#34;&gt;deallocate_bytes()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリを確保する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/allocate_object.html&#34;&gt;allocate_object()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/deallocate_object.html&#34;&gt;deallocate_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリ確保と構築をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/new_object.html&#34;&gt;new_object()&lt;/a&gt;&lt;/code&gt;、破棄と解放をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/delete_object.html&#34;&gt;delete_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数と符号なし整数の安全な比較関数として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_equal.html&#34;&gt;std::cmp_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_not_equal.html&#34;&gt;std::cmp_not_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less.html&#34;&gt;std::cmp_less()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less_equal.html&#34;&gt;std::cmp_less_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater.html&#34;&gt;std::cmp_greater()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater_equal.html&#34;&gt;std::cmp_greater_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_range.html&#34;&gt;std::in_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/swap.html&#34;&gt;std::swap()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/exchange.html&#34;&gt;std::exchange()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;クラスを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイルシステム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/filesystem/create_directory.html&#34;&gt;std::filesystem::create_directory()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/filesystem/create_directories.html&#34;&gt;std::filesystem::create_directories()&lt;/a&gt;&lt;/code&gt;の仕様が直感的ではなく、すでにディレクトリが存在している場合にエラーとなっていた。C++20ではその状況ではエラーにならないようにする (エラーではなく&lt;code&gt;false&lt;/code&gt;が返る)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、constexpr関数が定数式評価されたかを判定する特殊な関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_constant_evaluated.html&#34;&gt;std::is_constant_evaluated()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、型のCV修飾と参照を除去する型特性クラスとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;std::remove_cvref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った型をそのまま返す&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/type_identity.html&#34;&gt;std::type_identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、例外送出せずに暗黙の型変換が可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_convertible.html&#34;&gt;std::is_nothrow_convertible&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素数が判明している配列型かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_bounded_array.html&#34;&gt;std::is_bounded_array&lt;/a&gt;&lt;/code&gt;、要素数が不明な配列型かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_unbounded_array.html&#34;&gt;std::is_unbounded_array&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、レイアウト互換性、ポインタ相互交換可能性を判定する以下の型特性を追加：&lt;ul&gt;
&lt;li&gt;2つの型にレイアウト互換があるかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_layout_compatible.html&#34;&gt;std::is_layout_compatible&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2つのメンバポインタが互換な共通位置にあるかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_corresponding_member.html&#34;&gt;std::is_corresponding_member()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基底クラスと派生クラスの間でポインタ相互交換可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_base_of.html&#34;&gt;std::is_pointer_interconvertible_base_of&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メンバポインタとクラスの間でポインタ相互交換可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_with_class.html&#34;&gt;is_pointer_interconvertible_with_class()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型を&lt;code&gt;T&amp;amp;&lt;/code&gt;型に展開する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_reference.html&#34;&gt;std::unwrap_reference&lt;/a&gt;&lt;/code&gt;型特性、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;std::decay&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型の展開をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_ref_decay.html&#34;&gt;std::unwrap_ref_decay&lt;/a&gt;&lt;/code&gt;型特性を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一貫比較機能によって比較演算子の定義が容易になったため、不要になった演算子の簡潔定義機能である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/rel_ops.html&#34;&gt;std::rel_ops&lt;/a&gt;&lt;/code&gt;を非推奨化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数が、メモリの縮小をしなくなったため、デフォルト引数&lt;code&gt;0&lt;/code&gt;を非推奨化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが値初期化するようになったため、不要になった以下のアトミックオブジェクトの初期化機能を非推奨化：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_init.html&#34;&gt;std::atomic_init()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_var_init.html&#34;&gt;ATOMIC_VAR_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag_init.html&#34;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;allocator&lt;/a&gt;&lt;/code&gt;の以下のメンバを削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;difference_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rebind&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/address.html&#34;&gt;address()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/allocate.html&#34;&gt;allocate()&lt;/a&gt;&lt;/code&gt;メンバ関数の&lt;code&gt;hint&lt;/code&gt;パラメータ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/max_size.html&#34;&gt;max_size()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/construct.html&#34;&gt;construct()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/destroy.html&#34;&gt;destroy()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、要素型を再束縛するための&lt;code&gt;allocator&amp;lt;void&amp;gt;&lt;/code&gt;特殊化を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、&lt;code&gt;constexpr&lt;/code&gt;で扱える型の分類である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_literal_type.html&#34;&gt;is_literal_type&lt;/a&gt;&lt;/code&gt;型特性を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、一時的なメモリ確保のための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/get_temporary_buffer.html&#34;&gt;std::get_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/return_temporary_buffer.html&#34;&gt;std::return_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/raw_storage_iterator.html&#34;&gt;raw_storage_iterator&lt;/a&gt;&lt;/code&gt;クラスを削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた以下の機能を削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;not1()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;not2()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;unary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;binary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;標準関数オブジェクトの&lt;code&gt;result_type&lt;/code&gt;、&lt;code&gt;argument_type&lt;/code&gt;、&lt;code&gt;first_argument_type&lt;/code&gt;、&lt;code&gt;second_argument_type&lt;/code&gt;型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;shared_ptr&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr/unique.html&#34;&gt;unique()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/invoke_result.html&#34;&gt;invoke_result&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/result_of.html&#34;&gt;result_of&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17での&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exception/uncaught_exceptions.html&#34;&gt;uncaught_exceptions()&lt;/a&gt;&lt;/code&gt;の追加にともない、非推奨化していた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exception/uncaught_exception.html&#34;&gt;uncaught_exception()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていたC互換ライブラリ&lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt;を削除。また、C++ではなにも定義されないC互換ライブラリ&lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2131r0.html&#34; target=&#34;_blank&#34;&gt;P2131R0 Changes between C++17 and C++20 DIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- P0593R6初稿 #117</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>88c08cc878fdca30b520859de47d8367e91b0e35:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-17T18:09:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
new file mode 100644
index 000000000..0050b30fb
--- /dev/null
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -0,0 +1,245 @@
+# 未初期化領域への暗黙的なオブジェクト構築
+* cpp20[meta cpp]
+
+## 概要
+
+`new`式ではなく`malloc()`等他の方法で確保されたメモリ領域には、明示的にオブジェクトの構築を行うまで想定する型のオブジェクトは生存期間内になく、そのアクセス（読み書き）は未定義動作となる。
+
+```cpp
+struct X {
+  int a;
+  int b;
+};
+
+X *make_x() {
+  // malloc()はメモリの確保だけを行う
+  X *p = (X*)malloc(sizeof(struct X));
+  
+  // pの領域にはオブジェクトが構築されていない
+  p-&amp;gt;a = 1; // 💀 UB
+  p-&amp;gt;b = 2; // 💀 UB
+
+  return p;
+}
+```
+
+この様なコードは純粋なC++コードでは`new`式を用いることになるため、その場合は問題ない。
+
+```cpp
+// new式を使用する場合
+X *make_x() {
+  // new式はメモリの確保とオブジェクト構築を行う
+  X *p = new X;
+  
+  // pの領域にはオブジェクトが構築済
+  p-&amp;gt;a = 1; // ✅ ok
+  p-&amp;gt;b = 2; // ✅ ok
+
+  return p;
+}
+```
+
+一番最初の`malloc()`を用いるコードは主にCのコードと共有する部分で現れることがあり、Cでは問題ないもののC++コードとしてコンパイルした場合にのみ未定義動作となる。C++20からは、この様なコードのC/C++相互運用性向上のために、明示的にオブジェクトを構築する必要がないとみなすことのできる一部の型（*implicit-lifetime types*）に限って、未初期化領域へのアクセス時に暗黙的に（自動的に）オブジェクトが構築される様になり、未定義動作を回避できる様になる。
+
+## 問題となる他の例
+
+以下の例はこの変更によって解決される例であり、C++17以前は未定義動作となるものである。
+
+### `operator new`
+
+`new`式ではなく`operator new()`を直接使用する場合は同様の問題がある。
+
+```cpp
+// new式を使用する場合
+X *make_x() {
+  // operator new()はメモリの確保だけを行う
+  X *p = (X*)::operator new(sizeof(struct X));
+  
+  // pの領域にはオブジェクトが構築されていない
+  p-&amp;gt;a = 1; // 💀 UB
+  p-&amp;gt;b = 2; // 💀 UB
+
+  return p;
+}
+```
+
+### 共用体のコピー
+
+```cpp
+union U {
+  int n;
+  float f;
+};
+
+float pun(int n) {
+  // U::nの生存期間が開始
+  U u = {.n = n};
+  
+  // このコピーではunオブジェクト表現がコピーされるものの、メンバの生存期間は開始されない
+  // そのため、アクティブメンバが無い状態となる
+  U u2 = u;
+  
+  // u2.fは非アクティブ
+  return u2.f; // 💀 UB
+}
+```
+
+### バイト配列の読み込み
+
+```cpp
+// 何かバイト列ストリームを受け取って処理する関数とする
+void process(Stream *stream) {
+  // バイト配列の読み出し
+  std::unique_ptr&amp;lt;char[]&amp;gt; buffer = stream-&amp;gt;read();
+
+  // 先頭バイトの状態によって分岐
+  if (buffer[0] == FOO) {
+    process_foo(reinterpret_cast&amp;lt;Foo*&amp;gt;(buffer.get())); // #1
+  } else {
+    process_bar(reinterpret_cast&amp;lt;Bar*&amp;gt;(buffer.get())); // #2
+  }
+}
+```
+
+1つの領域に複数の型のオブジェクトが同時に生存期間内にあることはないため、`stream-&amp;gt;read()`が内部で`Foo, Bar`どちらかのオブジェクトを構築していたとしても、`#1`と`#2`のどちらかのパスは未定義動作となる。そして、この様なコードでは多くの場合、明示的にオブジェクトが構築されることはない。
+
+### 動的配列の実装
+
+```cpp
+// std::vectorの様な動的配列型を実装したい
+template&amp;lt;typename T&amp;gt;
+struct Vec {
+  char *buf = nullptr;
+  char *buf_end_size = nullptr;
+  char *buf_end_capacity = nullptr;
+
+  void reserve(std::size_t n) {
+    char *newbuf = (char*)::operator new(n * sizeof(T), std::align_val_t(alignof(T)));
+    std::uninitialized_copy(begin(), end(), (T*)newbuf); // #a 💀 UB
+
+    ::operator delete(buf, std::align_val_t(alignof(T)));
+    buf_end_size = newbuf + sizeof(T) * size(); // #b 💀 UB
+    buf_end_capacity = newbuf + sizeof(T) * n;  // #c 💀 UB
+    buf = newbuf;
+  }
+
+  void push_back(T t) {
+    if (buf_end_size == buf_end_capacity)
+      reserve(std::max&amp;lt;std::size_t&amp;gt;(size() * 2, 1));
+    new (buf_end_size) T(t);
+    buf_end_size += sizeof(T); // #d 💀 UB
+  }
+
+  T *begin() { return (T*)buf; }
+
+  T *end() { return (T*)buf_end_size; }
+
+  std::size_t size() { return end() - begin(); } // #e 💀 UB
+};
+
+int main() {
+  Vec&amp;lt;int&amp;gt; v;
+  v.push_back(1);
+  v.push_back(2);
+  v.push_back(3);
+  for (int n : v) { /*...*/ } // #f 💀 UB
+}
+```
+
+C++においては、ポインタに対する演算（`+ -`など）はそのポインタが配列オブジェクトを指している場合にのみ有効となるが、例中の`#a #b #c #d #e #f`で使用されるポインタの指す領域にはいずれも配列オブジェクトが生存期間にない（正確には、非配列オブジェクトのポインタの場合は要素数1の配列として扱われるが、この例の場合はそれを満たすことはほぼなく、満たさないものとする）。そのため、そのポインタをイテレータの様に使用することは未定義動作となる。
+
+## 仕様
+
+### implicit-lifetime types
+
+明示的にオブジェクトを構築する必要がないとみなすことのできる一部の型は*implicit-lifetime types*と呼ばれる次のいずれかに該当する型である
+
+1. [スカラ型](/reference/type_traits/is_scalar.md)
+2. 配列型
+    - 要素型は問わない
+3. *implicit-lifetime class types*
+    - デストラクタがユーザー定義されていない集成体型、もしくは
+    - 少なくとも1つの資格のあるトリビアルコンストラクタと、トリビアルで削除されていないデストラクタを持つ型
+4. 1~3のCV修飾された型
+
+### オブジェクトを暗黙的に構築する操作
+
+標準ライブラリ中の次の関数は、*implicit-lifetime types*に対して使用した場合に、その振る舞いの一環としてそのオブジェクトを暗黙的に構築する
+
+- `new`演算子
+    - `opreator new`
+    - `opreator new[]`
+- アロケータ
+    - [`std::allocator::allocate`](/reference/memory/allocator/allocate.md)
+- Cライブラリ関数
+    - `std::aligned_alloc`
+    - `std::calloc`
+    - `std::malloc`
+    - `std::realloc`
+    - `std::memcpy`
+    - `std::memmove`
+- [`std::bit_cast`](/reference/bit/bit_cast.md)
+
+これらの操作はそれぞれ、次のようにオブジェクトを暗黙的に構築する
+
+- `new`演算子とCのメモリ確保関数
+    - 返された領域にオブジェクトを構築し、構築された適切なオブジェクトへのポインタを返す
+        - `calloc/realloc`の場合、暗黙的なオブジェクト構築はゼロ埋め/コピーが行われる前に行われる
+- [`std::allocator::allocate`](/reference/memory/allocator/allocate.md)
+    - 返された配列型の領域にその配列型のオブジェクトを構築するが、配列要素は構築されない
+- `std::memcpy/std::memmove`
+    - コピー先領域への暗黙的なオブジェクト構築は、コピー先領域にコピーをする前に行われる
+- [`std::bit_cast`](/reference/bit/bit_cast.md)
+    - ネストしたものも含めて、結果領域に暗黙にオブジェクトを構築する
+        - ネストしたもの、とは例えばクラスメンバや配列の要素のこと
+
+### デストラクタ呼び出しによる生存期間の終了
+(執筆中)
+
+## 例
+(執筆中)
+```cpp example
+// (ここには、言語機能の使い方を解説するための、サンプルコードを記述します。)
+// (インクルードとmain()関数を含む、実行可能なサンプルコードを記述してください。そのようなコードブロックにはexampleタグを付けます。)
+
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  int variable = 0;
+  std::cout &amp;lt;&amp;lt; variable &amp;lt;&amp;lt; std::endl;
+}
+```
+* variable[color ff0000]
+
+(コードブロック中の識別子に、文字色を付ける例です。)
+
+### 出力
+```
+0
+```
+
+(ここには、サンプルコードの実行結果を記述します。何も出力がない場合は、項目を削除せず、空の出力にしてください。)  
+(実行結果が処理系・実行環境によって異なる場合は、項目名を「出力例」に変更し、可能であればその理由も併記してください。)
+
+
+## この機能が必要になった背景・経緯
+(執筆中)
+
+
+## 検討されたほかの選択肢
+(執筆中)
+
+
+## 関連項目
+
+- [`start_lifetime_as()`](/reference/memory/start_lifetime_as.md.nolink)
+- [`start_lifetime_as_array()`](/reference/memory/start_lifetime_as_array.md.nolink)
+- [`is_implicit_lifetime`](/reference/type_traits/is_implicit_lifetime.md.nolink)
+
+## 参照
+
+- [P0593R6 Implicit creation of objects for low-level object manipulation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0593r6.html)
+- [CWG Issue 2325. `std::launder` and reuse of character buffers](https://cplusplus.github.io/CWG/issues/2325.html)
+- [CWG Issue 2605. Implicit-lifetime aggregates](https://cplusplus.github.io/CWG/issues/2605.html)
+- [P1839R5 Accessing Object Representations](https://wg21.link/p1839r5)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ディレクトリ構造 -- Merge pull request #1128 from cpprefjp/dict-struct</title>
      <link href="https://cpprefjp.github.io/start_editing/directory_structure.html"/>
      <id>c6827281ccfc04ced709ccdf398f9058f43c5469:start_editing/directory_structure.md</id>
      <updated>2023-02-17T18:04:42+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;ディレクトリ構造&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;lang&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cpp{version}.mdの形式で、各C++バージョンの言語機能ページを作る&lt;/li&gt;
&lt;li&gt;future.mdは、将来のC++で検討されている言語機能を記載するところである。導入予定だった機能が再検討になった場合などに使用する&lt;/li&gt;
&lt;li&gt;archive.mdは、廃案になったC++機能だが解説として残す価値のあるものがある場合に、記載するところである&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;reference / module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;reference階層は、ヘッダベースのライブラリリファレンスで、その階層直下にはヘッダページを置く&lt;/li&gt;
&lt;li&gt;module階層は、モジュールベースのライブラリリファレンスで、その階層直下にはモジュールページを置く&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reference階層とmodule階層は上記以外は同じであるため、以下、共通のルールを書きます。&lt;/p&gt;
&lt;h3&gt;ヘッダ・モジュール階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ヘッダ・モジュール階層以下に、それに所属している機能のページを置く&lt;/li&gt;
&lt;li&gt;どのヘッダ・モジュールにも属さない機能の場合は、以下のように対応する&lt;ul&gt;
&lt;li&gt;全体で使用する説明専用の機能は、仮のヘッダ&lt;code&gt;&amp;lt;exposition-only&amp;gt;&lt;/code&gt;に属するものとして記載する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;クラス階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;クラスに属するメンバ関数と型は、クラス階層の下に置く&lt;/li&gt;
&lt;li&gt;オーバーロードを意図している関数、そのクラス向けに特殊化した機能も、クラス階層の下に置き、機能の列挙としてもクラスページで行う&lt;ul&gt;
&lt;li&gt;オーバーロードを意図している関数の例は以下：&lt;ul&gt;
&lt;li&gt;非メンバ関数の演算子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::get()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::begin()&lt;/code&gt;/&lt;code&gt;std::end()&lt;/code&gt;/&lt;code&gt;std::data()&lt;/code&gt;/&lt;code&gt;std::size()&lt;/code&gt;およびそれに類するもの&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::swap()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::erase()&lt;/code&gt;/&lt;code&gt;std::erase_if()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor()&lt;/code&gt;/&lt;code&gt;ceil()&lt;/code&gt;/&lt;code&gt;round()&lt;/code&gt; (chrono)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/expected/expected.html&#34;&gt;std::expected&lt;/a&gt;&lt;/code&gt;では&lt;a href=&#34;https://cpprefjp.github.io/reference/expected/expected.void.html&#34;&gt;`部分特殊化&lt;/a&gt;のためにクラス階層を分離している。これは各メンバ説明の差分が大きいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;演算子オーバーロードは、&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; (出力ストリームへの出力) と &lt;code&gt;std::operator&amp;gt;&amp;gt;&lt;/code&gt; (入力ストリームからの入力) を除き、左辺のクラスに属するものとする&lt;ul&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error/error_code.html&#34;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error/error_condition.html&#34;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;の比較演算子は、クラス階層ではなくヘッダ階層としている。これは所属関係がむずかしいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンセプト階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;コンセプトによってオーバーロード・特殊化されている場合は、コンセプトの階層を作って、その下に置く。機能の列挙としてはヘッダページで行う&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;名前空間階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;名前空間の階層は基本的に導入しない。例外は以下：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/this_thread.html&#34;&gt;std::this_thread&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;名前空間に特殊な意味をもたせている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ディレクトリ構造 -- ディレクトリ構造: クラス階層expected/expected.void特例を明記(#1066)</title>
      <link href="https://cpprefjp.github.io/start_editing/directory_structure.html"/>
      <id>910ec8ffb3fc83359cb2515e37f3230fd992090b:start_editing/directory_structure.md</id>
      <updated>2023-02-17T16:54:31+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;ディレクトリ構造&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;lang&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cpp{version}.mdの形式で、各C++バージョンの言語機能ページを作る&lt;/li&gt;
&lt;li&gt;future.mdは、将来のC++で検討されている言語機能を記載するところである。導入予定だった機能が再検討になった場合などに使用する&lt;/li&gt;
&lt;li&gt;archive.mdは、廃案になったC++機能だが解説として残す価値のあるものがある場合に、記載するところである&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;reference / module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;reference階層は、ヘッダベースのライブラリリファレンスで、その階層直下にはヘッダページを置く&lt;/li&gt;
&lt;li&gt;module階層は、モジュールベースのライブラリリファレンスで、その階層直下にはモジュールページを置く&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reference階層とmodule階層は上記以外は同じであるため、以下、共通のルールを書きます。&lt;/p&gt;
&lt;h3&gt;ヘッダ・モジュール階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ヘッダ・モジュール階層以下に、それに所属している機能のページを置く&lt;/li&gt;
&lt;li&gt;どのヘッダ・モジュールにも属さない機能の場合は、以下のように対応する&lt;ul&gt;
&lt;li&gt;全体で使用する説明専用の機能は、仮のヘッダ&lt;code&gt;&amp;lt;exposition-only&amp;gt;&lt;/code&gt;に属するものとして記載する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;クラス階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;クラスに属するメンバ関数と型は、クラス階層の下に置く&lt;/li&gt;
&lt;li&gt;オーバーロードを意図している関数、そのクラス向けに特殊化した機能も、クラス階層の下に置き、機能の列挙としてもクラスページで行う&lt;ul&gt;
&lt;li&gt;オーバーロードを意図している関数の例は以下：&lt;ul&gt;
&lt;li&gt;非メンバ関数の演算子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::get()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::begin()&lt;/code&gt;/&lt;code&gt;std::end()&lt;/code&gt;/&lt;code&gt;std::data()&lt;/code&gt;/&lt;code&gt;std::size()&lt;/code&gt;およびそれに類するもの&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::swap()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::erase()&lt;/code&gt;/&lt;code&gt;std::erase_if()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor()&lt;/code&gt;/&lt;code&gt;ceil()&lt;/code&gt;/&lt;code&gt;round()&lt;/code&gt; (chrono)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/expected/expected.html&#34;&gt;std::expected&lt;/a&gt;&lt;/code&gt;では&lt;a href=&#34;https://cpprefjp.github.io/reference/expected/expected.void.html&#34;&gt;`部分特殊化&lt;/a&gt;のためにクラス階層を分離している。これは各メンバ説明の差分が大きいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;演算子オーバーロードは、&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; (出力ストリームへの出力) と &lt;code&gt;std::operator&amp;gt;&amp;gt;&lt;/code&gt; (入力ストリームからの入力) を除き、左辺のクラスに属するものとする&lt;ul&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error/error_code.html&#34;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error/error_condition.html&#34;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;の比較演算子は、クラス階層ではなくヘッダ階層としている。これは所属関係がむずかしいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンセプト階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;コンセプトによってオーバーロード・特殊化されている場合は、コンセプトの階層を作って、その下に置く。機能の列挙としてはヘッダページで行う&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;名前空間階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;名前空間の階層は基本的に導入しない。例外は以下：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/this_thread.html&#34;&gt;std::this_thread&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;名前空間に特殊な意味をもたせている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functinoal/hash: 関連項目に特殊化版へのリンク列挙</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>bc842eccb3ea7ec2195a7d339994b4d9af21d4ea:reference/functional/hash.md</id>
      <updated>2023-02-17T16:25:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index f2bcb7730..f1b626178 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -38,7 +38,7 @@ namespace std {
 
 このクラスはそのものにデフォルトの定義は存在せず、ユーザーが任意の型で特殊化する際の要件を定義する。`hash`クラステンプレートを特殊化する場合、以下に記述するメンバ関数を持たせる必要がある。
 
-なお、`&amp;lt;functional&amp;gt;`ヘッダでは、以下の特殊化を提供する：
+`&amp;lt;functional&amp;gt;`ヘッダでは、以下の特殊化を提供する。これ以外の特殊化は、対象型を定義する各種ヘッダファイルにて提供される：
 
 | 型                   | 対応バージョン |
 |----------------------|----------------|
@@ -167,6 +167,26 @@ found : 3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+
+## 関連項目
+
+| ヘッダ | 特殊化対象 |
+|--------|------------|
+| [`&amp;lt;coroutine&amp;gt;`](/reference/coroutine.md) | [`std::coroutine_handle`](/reference/coroutine/coroutine_handle.md) |
+| [`&amp;lt;bitset&amp;gt;`](/reference/bitset.md) | [`std::bitset`](/reference/bitset/bitset.md) |
+| [`&amp;lt;filesystem&amp;gt;`](/reference/filesystem.md) | [`std::filesystem::path`](/reference/filesystem/path.md) |
+| [`&amp;lt;optional&amp;gt;`](/reference/optional.md) | [`std::optional`](/reference/optional/optional.md) |
+| [`&amp;lt;memory&amp;gt;`](/reference/memory.md) | [`std::shared_ptr`](/reference/memory/shared_ptr.md), [`std::unique_ptr`](/reference/memory/unique_ptr.md) |
+| [`&amp;lt;stacktrace&amp;gt;`](/reference/stacktrace.md) | [`std::basic_backtrace`](/reference/stacktrace/basic_stacktrace.md), [`std::stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md) |
+| [`&amp;lt;string&amp;gt;`](/reference/string.md) | `std::string`など |
+| [`&amp;lt;string_view&amp;gt;`](/reference/string_view.md) | `std::string_view`など |
+| [`&amp;lt;system_error&amp;gt;`](/reference/system_error.md) | [`std::error_code`](/reference/system_error/error_code.md), [`std::error_condition`](/reference/system_error/error_condition.md) |
+| [`&amp;lt;thread&amp;gt;`](/reference/thread.md) | [`std::thread:id`](/reference/thread/thread.md) |
+| [`&amp;lt;typeindex&amp;gt;`](/reference/typeindex.md) | [`std::type_index`](/reference/typeindex/type_index.md) |
+| [`&amp;lt;variant&amp;gt;`](/reference/variant.md) | [`std::variant`](/reference/variant/variant.md), [`std::monostate`](/reference/variant/monostate.md) |
+| [`&amp;lt;vector&amp;gt;`](/reference/vector.md) | [`std::vector&amp;lt;bool&amp;gt;`](/reference/vector/vector.md) |
+
+
 ## 参照
 - [ハッシュ関数 - Wikipedia](https://ja.wikipedia.org/wiki/ハッシュ関数)
 - [LWG 2148 - Hashing enums should be supported directly by std::hash](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>