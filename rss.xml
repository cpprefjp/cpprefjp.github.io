<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-03-20T14:12:12.783292</updated>
  <id>3a4b187d-92f0-4985-901f-2a1fb9b9d58e</id>

  
    <entry>
      <title>max_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>1befcbdc598b49e8652bb8b32f0947dcad9ae03b:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-03-20T23:07:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
index e95211c11..fdcacd74e 100644
--- a/reference/algorithm/ranges_max_element.md
+++ b/reference/algorithm/ranges_max_element.md
@@ -15,7 +15,7 @@ namespace std::ranges {
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; max_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
 }
 ```
-* forward_iterator[link /reference/ranges/forward_iterator.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
 * identity[link /reference/functional/identity.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * projected[link /reference/iterator/projected.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>1befcbdc598b49e8652bb8b32f0947dcad9ae03b:reference/algorithm/ranges_min_element.md</id>
      <updated>2022-03-20T23:07:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
index d0cc89f93..1ce557869 100644
--- a/reference/algorithm/ranges_min_element.md
+++ b/reference/algorithm/ranges_min_element.md
@@ -15,7 +15,7 @@ namespace std::ranges {
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; min_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
 }
 ```
-* forward_iterator[link /reference/ranges/forward_iterator.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
 * identity[link /reference/functional/identity.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * projected[link /reference/iterator/projected.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>1befcbdc598b49e8652bb8b32f0947dcad9ae03b:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2022-03-20T23:07:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
index 6c8cf95aa..5914791fd 100644
--- a/reference/algorithm/ranges_minmax_element.md
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -19,7 +19,7 @@ namespace std::ranges {
 }
 ```
 * min_max_result[link min_max_result.md.nolink]
-* forward_iterator[link /reference/ranges/forward_iterator.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
 * identity[link /reference/functional/identity.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * projected[link /reference/iterator/projected.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::lexicographical_compareの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>152c2d99d70287f1c8c34835817d4b908ff89ba8:reference/algorithm.md</id>
      <updated>2022-03-20T14:23:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 23c58e9d0..d70adabd9 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -384,7 +384,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------------------------------|---------------------------------|-------|
 | [`lexicographical_compare`](algorithm/lexicographical_compare.md) | 2つの範囲を辞書式順序で比較する | |
-| [`ranges::lexicographical_compare`](algorithm/ranges_lexicographical_compare.md.nolink) | 2つの範囲を辞書式順序で比較する | C++20 |
+| [`ranges::lexicographical_compare`](algorithm/ranges_lexicographical_compare.md) | 2つの範囲を辞書式順序で比較する | C++20 |
 
 ### 三方比較アルゴリズム
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- ranges::lexicographical_compareの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lexicographical_compare.html"/>
      <id>152c2d99d70287f1c8c34835817d4b908ff89ba8:reference/algorithm/ranges_lexicographical_compare.md</id>
      <updated>2022-03-20T14:23:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lexicographical_compare.md b/reference/algorithm/ranges_lexicographical_compare.md
new file mode 100644
index 000000000..9cca180fe
--- /dev/null
+++ b/reference/algorithm/ranges_lexicographical_compare.md
@@ -0,0 +1,130 @@
+# lexicographical_compare
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;input_range R1, input_range R2, class Proj1 = identity, class Proj2 = identity,
+          indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool lexicographical_compare(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+`[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+```cpp
+for ( ; first1 != last1 &amp;amp;&amp;amp; first2 != last2 ; ++first1, ++first2) {
+  if (*first1 &amp;lt; *first2) return true;
+  if (*first2 &amp;lt; *first1) return false;
+}
+return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
+```
+
+
+## 戻り値
+範囲`[first1, last1)`が、辞書式比較で範囲`[first2, last2)`より小さい場合`true`を返し、そうでなければ`false`を返す。
+
+
+## 計算量
+高々`2*min((last1 - first1), (last2 - first2))`回の比較が行われる。
+
+
+## 備考
+空のシーケンスは、空でないシーケンスより小さいと判断されるが、空のシーケンスに対しては小さくないと判断される。
+
+どちらかのシーケンスの横断が先に終わる場合(つまり、範囲の長さが合わない場合)、先に終わった方が小さいと判断される。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+template &amp;lt;class X, class Y&amp;gt;
+void compare_test(const X&amp;amp; x, const Y&amp;amp; y)
+{
+  if (std::ranges::lexicographical_compare(x, y)) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;x less than y&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;x not less than y&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 比較演算のカスタマイズバージョン
+  if (std::ranges::lexicographical_compare(x, y, std::ranges::greater())) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;x less than y&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;x not less than y&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+
+int main()
+{
+  // 同じ長さの文字列比較
+  {
+    std::string x = &amp;#34;heilo&amp;#34;;
+    std::string y = &amp;#34;hello&amp;#34;;
+
+    std::cout &amp;lt;&amp;lt; &amp;#34;same length string compare:&amp;#34; &amp;lt;&amp;lt; std::endl;
+    compare_test(x, y);
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  // 異なる長さの文字列比較
+  {
+    std::string x = &amp;#34;hell&amp;#34;;
+    std::string y = &amp;#34;hello&amp;#34;;
+
+    std::cout &amp;lt;&amp;lt; &amp;#34;not same length string compare:&amp;#34; &amp;lt;&amp;lt; std::endl;
+    compare_test(x, y);
+  }
+}
+```
+* std::ranges::lexicographical_compare[color ff0000]
+* std::ranges::greater[link /reference/functional/ranges_greater.md]
+
+### 出力
+```
+same length string compare:
+x less than y
+x not less than y
+
+not same length string compare:
+x less than y
+x less than y
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- 順列関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>de01d499d90a0acc828e92125fb7e8700820b462:reference/algorithm.md</id>
      <updated>2022-03-20T14:15:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index d0052caaf..23c58e9d0 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -400,9 +400,9 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`next_permutation`](algorithm/next_permutation.md) | 次の順列を生成する     | |
 | [`prev_permutation`](algorithm/prev_permutation.md) | 前の順列を生成する     | |
 | [`is_permutation`](algorithm/is_permutation.md)     | 範囲が順列かを判定する | C++11 |
-| [`ranges::next_permutation`](algorithm/ranges_next_permutation.md.nolink) | 次の順列を生成する     | C++20 |
-| [`ranges::prev_permutation`](algorithm/ranges_prev_permutation.md.nolink) | 前の順列を生成する     | C++20 |
-| [`ranges::is_permutation`](algorithm/ranges_is_permutation.md.nolink)     | 範囲が順列かを判定する | C++20 |
+| [`ranges::next_permutation`](algorithm/ranges_next_permutation.md) | 次の順列を生成する     | C++20 |
+| [`ranges::prev_permutation`](algorithm/ranges_prev_permutation.md) | 前の順列を生成する     | C++20 |
+| [`ranges::is_permutation`](algorithm/ranges_is_permutation.md)     | 範囲が順列かを判定する | C++20 |
 
 ### 戻り値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_permutation -- 順列関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_permutation.html"/>
      <id>de01d499d90a0acc828e92125fb7e8700820b462:reference/algorithm/ranges_is_permutation.md</id>
      <updated>2022-03-20T14:15:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_permutation.md b/reference/algorithm/ranges_is_permutation.md
new file mode 100644
index 000000000..09dc08b8a
--- /dev/null
+++ b/reference/algorithm/ranges_is_permutation.md
@@ -0,0 +1,82 @@
+# is_permutation
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
+           indirect_equivalence_relation&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;forward_range R1, forward_range R2, class Proj1 = identity, class Proj2 = identity,
+           indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr bool is_permutation(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::equal_to[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_equivalence_relation[link /reference/iterator/indirect_equivalence_relation.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+範囲 `[first2, last2)` を並べ替えたものが、`[first1, last1)` の範囲と一致するか判定する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 戻り値
+`last2` が与えられている形式の場合、`last1 - first1 != last2 - first2` であれば `false` を返す。  
+そうでなければ、`[first1, last1)` の範囲と `[first2, first2 + (last1 - first1))` の範囲を並び変えたもので、[`equal`](equal.md)`(first1, last1, first2)`、あるいは [`equal`](equal.md)`(first1, last1, first2, pred)` が `true` を返すようなものがあれば `true` を、そうでなければ `false` を返す。  
+なお、実際に並べ替えが行われるわけではない。
+
+
+## 計算量
+`last2` が与えられている形式の場合、`ForwardIterator1` と `ForwardIterator2` がどちらもランダムアクセスイテレータの要件を満たし、かつ `last1 - first1 != last2 - first2` であれば 1 度も述語の適用を行わない。  
+そうでなければ、[`equal`](/reference/algorithm/equal.md)`(first1, last1, first2, last2) == true` もしくは [`equal`](/reference/algorithm/equal.md)`(first1, last1, first2, last2, pred) == true` の場合（`last2` が無い形式の場合、[`equal`](/reference/algorithm/equal.md) も `last2` の無い形式で置き換える）、[`distance`](/reference/iterator/distance.md)`(first1, last1)` 回の述語適用で完了する。  
+そうでなければ、[`distance`](/reference/iterator/distance.md)`(first1, last1)` をNとした場合に最悪O(N^2)回の述語適用で完了する。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main ()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  std::vector&amp;lt;int&amp;gt; good = {2, 3, 1};
+  std::vector&amp;lt;int&amp;gt; bad = {2, 3, 4};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; std::ranges::is_permutation(v, good) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::is_permutation(v, bad) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_permutation[color ff0000]
+
+### 出力
+```
+true
+false
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>next_permutation -- 順列関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_next_permutation.html"/>
      <id>de01d499d90a0acc828e92125fb7e8700820b462:reference/algorithm/ranges_next_permutation.md</id>
      <updated>2022-03-20T14:15:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_next_permutation.md b/reference/algorithm/ranges_next_permutation.md
new file mode 100644
index 000000000..94a95dbda
--- /dev/null
+++ b/reference/algorithm/ranges_next_permutation.md
@@ -0,0 +1,110 @@
+# next_permutation
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I&amp;gt;
+  using next_permutation_result = in_found_result&amp;lt;I&amp;gt;;
+
+  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr next_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
+
+  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr next_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
+}
+```
+* in_found_result[link in_found_result.md.nolink]
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* bidirectional_range[link /reference/ranges/bidirectional_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその次の順列を生成する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+`[first, last)`の範囲を次の順列に変換する。
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって辞書順に並んでいる全ての順列の集合があると仮定すると、次の順列が発見される。
+
+順列の辞書順とは、同じ長さ`N`の順列`a, b`があった時、その最上位の項から見た時に`ai != bi`となる最初の`i`番目の項について、`ai &amp;lt; bi`（もしくは`comp(ai, bi) == true`）となる時に`a &amp;lt; b`とするように定めた順序のことである。例えばこれは、各項（`ai, bi`）が`0 ~ 9`の数であるとすれば、それらをそのまま並べて構成した数の通常の大小関係に等しい。
+
+辞書順による次の順列とは、現在の順列（`[first, last)`）よりも（上記の意味の順序で）大きい順列のうち取り得る最小のもののことである。
+
+## 戻り値
+次のメンバをもつtuple-lileオブジェクト。
+
+1. `in`: `last`
+2. `found`: 次の順列が存在する場合は`true`、そうでなければ`false`
+
+## 計算量
+高々`(last - first)/2`回の要素の交換
+
+
+## 備考
+全ての順列を取得したい場合は、この関数に最初に与える範囲が、昇順にソート済みになっていること。  
+順列の長さを`N`（`N = last - first`）とすれば、そのような順列は`N!`個存在する。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+void print(const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
+{
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34; &amp;#34;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+int main ()
+{
+  // 昇順にソート済みの入力
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  do {
+    print(v);
+  } while (std::ranges::next_permutation(v).found);
+}
+```
+* std::ranges::next_permutation[color ff0000]
+
+### 出力
+```
+1 2 3 
+1 3 2 
+2 1 3 
+2 3 1 
+3 1 2 
+3 2 1 
+```
+
+## 関連項目
+- [`std::ranges::prev_permutation()`](ranges_prev_permutation.md)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>prev_permutation -- 順列関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_prev_permutation.html"/>
      <id>de01d499d90a0acc828e92125fb7e8700820b462:reference/algorithm/ranges_prev_permutation.md</id>
      <updated>2022-03-20T14:15:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_prev_permutation.md b/reference/algorithm/ranges_prev_permutation.md
new file mode 100644
index 000000000..73dd7d9d1
--- /dev/null
+++ b/reference/algorithm/ranges_prev_permutation.md
@@ -0,0 +1,107 @@
+# prev_permutation
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I&amp;gt;
+  using prev_permutation_result = in_found_result&amp;lt;I&amp;gt;;
+
+  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr prev_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
+
+  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr prev_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
+}
+```
+* in_found_result[link in_found_result.md.nolink]
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* bidirectional_range[link /reference/ranges/bidirectional_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその前の順列を生成する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+`[first, last)`の範囲を前の順列に変換する。
+
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって辞書順に並んでいる全ての順列の集合があると仮定すると、前の順列が発見される。
+
+## 戻り値
+次のメンバをもつtuple-lileオブジェクト。
+
+1. `in`: `last`
+2. `found`: 前の順列が存在する場合は`true`、そうでなければ`false`
+
+
+## 計算量
+高々`(last - first)/2`回の要素の交換
+
+
+## 備考
+全ての順列を取得したい場合は、この関数に最初に与える範囲が、降順にソート済みになっていること。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+void print(const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
+{
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34; &amp;#34;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+int main ()
+{
+  // 降順にソート済みの入力
+  std::vector&amp;lt;int&amp;gt; v = {3, 2, 1};
+
+  do {
+    print(v);
+  } while (std::ranges::prev_permutation(v).found);
+}
+```
+* std::prev_permutation[color ff0000]
+
+### 出力
+```
+3 2 1 
+3 1 2 
+2 3 1 
+2 1 3 
+1 3 2 
+1 2 3 
+```
+
+## 関連項目
+- [`std::ranges::next_permutation()`](ranges_next_permutation.md)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 名前空間を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>9fae6f9d5a26f6b554a74ce3bc25896b867c4b69:reference/algorithm/ranges_equal_range.md</id>
      <updated>2022-03-20T11:47:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index 7e3f762e6..83e73b1a4 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -5,7 +5,7 @@
 * cpp20[meta cpp]
 
 ```cpp
-namespace std {
+namespace std::ranges {
   template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
   constexpr subrange&amp;lt;I&amp;gt; equal_range(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index eff40d509..d0052caaf 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -371,13 +371,13 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`max_element`](algorithm/max_element.md)       | 範囲内の最大要素へのイテレータを取得する | |
 | [`minmax_element`](algorithm/minmax_element.md) | 範囲内の最小要素と最大要素へのイテレータを取得する | C++11 |
 | [`clamp`](algorithm/clamp.md)                   | 値を範囲内に収める | C++17 |
-| [`ranges::min`](algorithm/ranges_min.md.nolink)                       | 最小値を取得する                                   | C++20 |
-| [`ranges::max`](algorithm/ranges_max.md.nolink)                       | 最大値を取得する                                   | C++20 |
-| [`ranges::minmax`](algorithm/ranges_minmax.md.nolink)                 | 最小値と最大値を取得する                           | C++20 |
-| [`ranges::min_element`](algorithm/ranges_min_element.md.nolink)       | 範囲内の最小要素へのイテレータを取得する           | C++20 |
-| [`ranges::max_element`](algorithm/ranges_max_element.md.nolink)       | 範囲内の最大要素へのイテレータを取得する           | C++20 |
-| [`ranges::minmax_element`](algorithm/ranges_minmax_element.md.nolink) | 範囲内の最小要素と最大要素へのイテレータを取得する | C++20 |
-| [`ranges::clamp`](algorithm/ranges_clamp.md.nolink)                   | 値を範囲内に収める                                 | C++20 |
+| [`ranges::min`](algorithm/ranges_min.md)                       | 最小値を取得する                                   | C++20 |
+| [`ranges::max`](algorithm/ranges_max.md)                       | 最大値を取得する                                   | C++20 |
+| [`ranges::minmax`](algorithm/ranges_minmax.md)                 | 最小値と最大値を取得する                           | C++20 |
+| [`ranges::min_element`](algorithm/ranges_min_element.md)       | 範囲内の最小要素へのイテレータを取得する           | C++20 |
+| [`ranges::max_element`](algorithm/ranges_max_element.md)       | 範囲内の最大要素へのイテレータを取得する           | C++20 |
+| [`ranges::minmax_element`](algorithm/ranges_minmax_element.md) | 範囲内の最小要素と最大要素へのイテレータを取得する | C++20 |
+| [`ranges::clamp`](algorithm/ranges_clamp.md)                   | 値を範囲内に収める                                 | C++20 |
 
 ### 辞書式比較
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clamp -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_clamp.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_clamp.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_clamp.md b/reference/algorithm/ranges_clamp.md
new file mode 100644
index 000000000..732d1e6da
--- /dev/null
+++ b/reference/algorithm/ranges_clamp.md
@@ -0,0 +1,73 @@
+# clamp
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp; clamp(const T&amp;amp; v, const T&amp;amp; lo, const T&amp;amp; hi, Comp comp = {}, Proj proj = {});
+}
+```
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+
+## 概要
+値を範囲内に収める。
+
+この関数は、`v`の値を範囲`[low, high]`に収める。
+
+## 事前条件
+- `low`の値は`high`の値より大きくなってはならない
+
+## 戻り値
+- `v`の値が`low`より小さければ`low`を返す
+- `v`の値が`high`より大きければ`high`を返す
+- そうでなければ`v`を返す
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  for (int i = 0; i &amp;lt; 10; ++i) {
+    // iの値を範囲[2, 7]に収める
+    int result = std::ranges::clamp(i, 2, 7);
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::clamp[color ff0000]
+
+### 出力
+```
+0 : 2
+1 : 2
+2 : 2
+3 : 3
+4 : 4
+5 : 5
+6 : 6
+7 : 7
+8 : 7
+9 : 7
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_max.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max.md b/reference/algorithm/ranges_max.md
new file mode 100644
index 000000000..3c18d2a68
--- /dev/null
+++ b/reference/algorithm/ranges_max.md
@@ -0,0 +1,91 @@
+# max
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp; max(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {}); // (1)
+
+  template&amp;lt;copyable T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr T max(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});         // (2)
+
+  template&amp;lt;input_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  constexpr range_value_t&amp;lt;R&amp;gt; max(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});          // (3)
+}
+```
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* input_range[link /reference/ranges/input_range.md]
+* indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* range_value_t[link /reference/ranges/range_value_t.md]
+
+## 概要
+同じ型の2つの値、もしくは範囲によるN個の値のうち、最大値を取得する。
+
+## 戻り値
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最大と判断された最初の値
+
+## 備考
+- 等価な要素が 2 つ以上あった場合には、最も左の要素を返す。
+
+## 例
+```cpp example
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  constexpr int result1 = std::ranges::max(2, 3);
+  static_assert(result1 == 3);
+
+  constexpr int result2 = std::ranges::max(2, 3, std::ranges::greater());
+  static_assert(result2 == 2);
+
+  constexpr int result3 = std::ranges::max({1, 2, 3});
+  static_assert(result3 == 3);
+
+  constexpr std::array&amp;lt;int, 3&amp;gt; a = {1, 2, 3};
+
+  constexpr int result4 = std::ranges::max(a, std::ranges::greater());
+  static_assert(result4 == 1);
+}
+```
+* std::ranges::max[color ff0000]
+* std::ranges::greater[link /reference/functional/greater.md]
+
+### 出力
+```
+```
+
+### 備考
+Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`max`という名前の関数マクロが定義され、`std::ranges::max()`と衝突してしまうという問題がある。
+
+この解決策として以下の2つの方法がある：
+
+- `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`max`マクロが定義されなくなる。
+- `std::ranges::max()`を呼び出す際に、`(std::ranges::max)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::max()`関数が必ず使用される。
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
new file mode 100644
index 000000000..e95211c11
--- /dev/null
+++ b/reference/algorithm/ranges_max_element.md
@@ -0,0 +1,77 @@
+# max_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; max_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/ranges/forward_iterator.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+`[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
+
+
+## 戻り値
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最大と判断された最初の要素を指すイテレータ
+
+## 計算量
+[`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v1 = {3, 1, 4};
+
+  auto v1_max_element = std::ranges::max_element(v1);
+  assert(*v1_max_element == 4);
+
+
+  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; v2 = {{0, 3}, {1, 1}, {2, 4}};
+
+  auto v2_max_element = std::ranges::max_element(v2, {}, &amp;amp;std::pair&amp;lt;int, int&amp;gt;::second);
+  assert(v2_max_element-&amp;gt;first == 2);
+  assert(v2_max_element-&amp;gt;second == 4);
+}
+```
+* std::ranges::max_element[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_min.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min.md b/reference/algorithm/ranges_min.md
new file mode 100644
index 000000000..254a4e8b3
--- /dev/null
+++ b/reference/algorithm/ranges_min.md
@@ -0,0 +1,92 @@
+# min
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp; min(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {}); // (1)
+
+  template&amp;lt;copyable T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr T min(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});         // (2)
+
+  template&amp;lt;input_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  constexpr range_value_t&amp;lt;R&amp;gt; min(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});          // (3)
+}
+```
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* input_range[link /reference/ranges/input_range.md]
+* indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* range_value_t[link /reference/ranges/range_value_t.md]
+
+## 概要
+同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値を取得する。
+
+## 戻り値
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最小と判断された最初の値
+
+## 備考
+- 等価な要素が 2 つ以上あった場合には、最も左の要素を返す。
+
+
+## 例
+```cpp example
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  constexpr int result1 = std::ranges::min(2, 3);
+  static_assert(result1 == 2);
+
+  constexpr int result2 = std::ranges::min(2, 3, std::ranges::greater());
+  static_assert(result2 == 3);
+
+  constexpr int result3 = std::ranges::min({1, 2, 3});
+  static_assert(result3 == 1);
+
+  constexpr std::array&amp;lt;int, 3&amp;gt; a = {1, 2, 3};
+
+  constexpr int result4 = std::ranges::min(a, std::ranges::greater());
+  static_assert(result4 == 3);
+}
+```
+* std::ranges::min[color ff0000]
+* std::ranges::greater[link /reference/functional/ranges_greater.md]
+
+### 出力
+```
+```
+
+### 備考
+Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`min`という名前の関数マクロが定義され、`std::ranges::min()`と衝突してしまうという問題がある。
+
+この解決策として以下の2つの方法がある：
+
+- `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`min`マクロが定義されなくなる。
+- `std::ranges::min()`を呼び出す際に、`(std::ranges::min)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::min()`が必ず使用される。
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_min_element.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
new file mode 100644
index 000000000..d0cc89f93
--- /dev/null
+++ b/reference/algorithm/ranges_min_element.md
@@ -0,0 +1,80 @@
+# min_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; min_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/ranges/forward_iterator.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+
+## 概要
+`[first, last)`の範囲において、最小要素を指す最初のイテレータを取得する。
+
+
+## 戻り値
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最小と判断された最初の要素を指すイテレータ
+
+
+## 計算量
+[`max`](/reference/algorithm/max.md)`((last - first) - 1, 0)`回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v1 = {3, 1, 4};
+
+  auto v1_min_element = std::ranges::min_element(v1);
+  assert(*v1_min_element == 1);
+
+
+  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; v2 = {{0, 3}, {1, 1}, {2, 4}};
+
+  auto v2_min_element = std::ranges::min_element(v2, {}, &amp;amp;std::pair&amp;lt;int, int&amp;gt;::second);
+  assert(v2_min_element-&amp;gt;first == 1);
+  assert(v2_min_element-&amp;gt;second == 1);
+}
+```
+* std::ranges::min_element[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_minmax.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax.md b/reference/algorithm/ranges_minmax.md
new file mode 100644
index 000000000..ab8178e25
--- /dev/null
+++ b/reference/algorithm/ranges_minmax.md
@@ -0,0 +1,93 @@
+# minmax
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+* cpp11[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T&amp;gt;
+  using minmax_result = min_max_result&amp;lt;T&amp;gt;;
+
+  template&amp;lt;class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;const T&amp;amp;&amp;gt; minmax(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;copyable T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;T&amp;gt; minmax(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;input_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  constexpr minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt; minmax(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* min_max_result[link min_max_result.md.nolink]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* input_range[link /reference/ranges/input_range.md]
+* indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* range_value_t[link /reference/ranges/range_value_t.md]
+
+## 概要
+同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値と最大値の組を取得する。
+
+## 戻り値
+第1メンバ`min`が最小値、第2メンバ`max`が最大値となるtuple-likeオブジェクト([`min_max_result`](min_max_result.md.nolink))
+
+それぞれ、比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって判断された最初の値となる。
+
+## 計算量
+- 2値比較バージョンは1操作。
+- 範囲バージョンは高々`(3/2) * t.size()`回の述語適用。
+
+## 例
+```cpp example
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  const auto result1 = std::ranges::minmax(2, 3);
+  assert(result1.min == 2 &amp;amp;&amp;amp; result1.max == 3);
+
+  const auto result2 = std::ranges::minmax(2, 3, std::ranges::greater());
+  assert(result2.min == 3 &amp;amp;&amp;amp; result2.max == 2);
+
+  constexpr auto result3 = std::ranges::minmax({1, 2, 3});
+  static_assert(result3.min == 1 &amp;amp;&amp;amp; result3.max == 3);
+
+  constexpr std::array&amp;lt;int, 3&amp;gt; a = {1, 2, 3};
+
+  constexpr auto result4 = std::ranges::minmax(a, std::ranges::greater());
+  static_assert(result4.min == 3 &amp;amp;&amp;amp; result4.max == 1);
+}
+```
+* std::ranges::minmax[color ff0000]
+* std::ranges::greater[link /reference/functional/ranges_greater.md]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
new file mode 100644
index 000000000..6c8cf95aa
--- /dev/null
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -0,0 +1,82 @@
+# minmax_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T&amp;gt;
+  using minmax_result = min_max_result&amp;lt;T&amp;gt;;
+
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;I&amp;gt; minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; minmax_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* min_max_result[link min_max_result.md.nolink]
+* forward_iterator[link /reference/ranges/forward_iterator.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+
+## 概要
+`[first, last)` の範囲において、最小要素を指すイテレータと最大要素を指すイテレータの組を取得する。
+
+
+## 戻り値
+
+第1メンバ`min`が最小の要素、第2メンバ`max`が最大の要素をそれぞれ指すイテレータとなるtuple-likeオブジェクト([`min_max_result`](min_max_result.md.nolink))
+
+それぞれ、比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって判断し、同じ値の要素が複数ある場合は、最小の要素は最初の要素、最大の要素は最後の要素となる。
+
+## 計算量
+`n` を範囲の要素数とする場合、[`max`](max.md)`(floor(3(n - 1) / 2), 0)` 回の述語適用を行う。
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
+
+  auto [min1, max1] = std::ranges::minmax_element(v);
+  assert(*min1 == 1);
+  assert(*max1 == 4);
+
+  auto [min2, max2] = std::ranges::minmax_element(v, std::ranges::greater());
+  assert(*min2 == 4);
+  assert(*max2 == 1);
+}
+```
+* std::ranges::minmax_element[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>