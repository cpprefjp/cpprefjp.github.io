<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-06-13T07:05:33.785038</updated>
  <id>b8ec552f-207f-4823-af8f-73ea4c3e895b</id>

  
    <entry>
      <title>flat_map -- flat_map : emplace_hintを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map.html"/>
      <id>fb295e5dead94487ffcc86042b541ab62e3cb068:reference/flat_map/flat_map.md</id>
      <updated>2023-06-13T16:00:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map.md b/reference/flat_map/flat_map.md
index 18628ef35..779e4536b 100644
--- a/reference/flat_map/flat_map.md
+++ b/reference/flat_map/flat_map.md
@@ -62,7 +62,7 @@ namespace std {
 | [`insert_or_assign`](flat_map/insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               | C++23 |
 | [`insert_range`](flat_map/insert_range.md.nolink)         | Rangeを挿入する                            | C++23 |
 | [`emplace`](flat_map/emplace.md)                   | 要素を直接構築する                         | C++23 |
-| [`emplace_hint`](flat_map/emplace_hint.md.nolink)         | ヒントを使って要素を直接構築する           | C++23 |
+| [`emplace_hint`](flat_map/emplace_hint.md)         | ヒントを使って要素を直接構築する           | C++23 |
 | [`try_emplace`](flat_map/try_emplace.md.nolink)           | キーが存在しない場合のみ要素を直接構築する | C++23 |
 | [`erase`](flaflat_maptmap/erase.md.nolink)                | 要素を削除する                             | C++23 |
 | [`swap`](flat_map/swap.md.nolink)                         | コンテンツを交換する                       | C++23 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace -- flat_map : emplace_hintを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/emplace.html"/>
      <id>fb295e5dead94487ffcc86042b541ab62e3cb068:reference/flat_map/flat_map/emplace.md</id>
      <updated>2023-06-13T16:00:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/emplace.md b/reference/flat_map/flat_map/emplace.md
index f822e8ec7..398b43084 100644
--- a/reference/flat_map/flat_map/emplace.md
+++ b/reference/flat_map/flat_map/emplace.md
@@ -134,6 +134,6 @@ CCC : (1, 2)
 |------------------------------------------------|--------------------------------------------|
 | [`flat_map::insert`](insert.md.nolink)                     | 要素を挿入する                             |
 | [`flat_map::insert_or_assign`](insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               |
-| [`flat_map::emplace_hint`](emplace_hint.md.nolink)         | ヒントを使って要素を直接構築する           |
+| [`flat_map::emplace_hint`](emplace_hint.md)         | ヒントを使って要素を直接構築する           |
 | [`flat_map::try_emplace`](try_emplace.md.nolink)           | キーが存在しない場合のみ要素を直接構築する |
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace_hint -- flat_map : emplace_hintを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/emplace_hint.html"/>
      <id>fb295e5dead94487ffcc86042b541ab62e3cb068:reference/flat_map/flat_map/emplace_hint.md</id>
      <updated>2023-06-13T16:00:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/emplace_hint.md b/reference/flat_map/flat_map/emplace_hint.md
new file mode 100644
index 000000000..113abdf27
--- /dev/null
+++ b/reference/flat_map/flat_map/emplace_hint.md
@@ -0,0 +1,82 @@
+# emplace_hint
+* flat_map[meta header]
+* std[meta namespace]
+* flat_map[meta class]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+template &amp;lt;class... Args&amp;gt;
+iterator emplace_hint(const_iterator hint, Args&amp;amp;&amp;amp;... args);
+```
+
+## 概要
+要素が配置されるべき場所を示唆するパラメータ `hint` を使って、コンテナに新しい要素を挿入する。要素は直接構築される（コピーもムーブもされない）。要素のコンストラクタはこの関数に渡された引数と同じ引数で呼ばれる。
+
+
+## パラメータ
+- `hint` : 新しい要素をどこへ挿入するかを示唆するために使われるイテレータ
+- `args...` : 要素のコンストラクタへ転送される引数パック
+
+
+## 戻り値
+新たな要素が追加された場合、その追加された要素を指すイテレータ。新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
+
+
+## 計算量
+一般にコンテナのサイズについて対数時間だが、新しい要素が `hint` の前に挿入された場合は償却定数時間。
+
+
+## 備考
+- [`try_emplace`](try_emplace.md.nolink) と異なり、たとえ要素が挿入されなかった場合でも `value_type` 型のオブジェクトが構築される可能性があり、結果として引数 `args` が [`move`](/reference/utility/move.md) の対象となって変更されてしまっている可能性があるため、注意が必要である。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+
+int main()
+{
+  std::flat_map&amp;lt;int, char&amp;gt; fm;
+
+  fm.emplace(1, &amp;#39;A&amp;#39;);
+
+  // キー2の要素が最後尾に追加されることが事前にわかっているので、fm.end()をヒントとして与える
+  fm.emplace_hint(fm.end(), 2, &amp;#39;B&amp;#39;);
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* emplace_hint[color ff0000]
+* fm.emplace[link emplace.md]
+* fm.end()[link end.md.nolink]
+
+### 出力
+```
+1 : A
+2 : B
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前                                           | 説明                                       |
+|------------------------------------------------|--------------------------------------------|
+| [`flat_map::insert`](insert.md.nolink)                     | 要素を挿入する                             |
+| [`flat_map::insert_or_assign`](insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               |
+| [`flat_map::emplace`](emplace.md)                   | 要素を直接構築する                         |
+| [`flat_map::try_emplace`](try_emplace.md.nolink)           | キーが存在しない場合のみ要素を直接構築する |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shared_ptr -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr.md b/reference/memory/shared_ptr.md
index e997226fc..796eb02a7 100644
--- a/reference/memory/shared_ptr.md
+++ b/reference/memory/shared_ptr.md
@@ -81,17 +81,17 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |-------------------------------------------|--------------------------------------------------|-------|
-| [`atomic_is_lock_free`][is_lock_free]     | 指定されたオブジェクトがロックフリーに振る舞えるかを調べる | C++11 |
-| [`atomic_store`][store]                   | 値を書き込む | C++11 |
-| [`atomic_store_explicit`][store_ex]       | メモリオーダーを指定して値を書き込む | C++11 |
-| [`atomic_load`][load]                     | 値を読み込む | C++11 |
-| [`atomic_load_explicit`][load_ex]         | メモリオーダーを指定して値を読み込む | C++11 |
-| [`atomic_exchange`][exchange]             | 値を入れ替える | C++11 |
-| [`atomic_exchange_explicit`][exchange_ex] | メモリオーダーを指定して値を入れ替える | C++11 |
-| [`atomic_compare_exchange_weak`][exchange_weak] | 弱い比較で値の入れ替えを行う | C++11 |
-| [`atomic_compare_exchange_strong`][exchange_strong] | 強い比較で値の入れ替えを行う | C++11 |
-| [`atomic_compare_exchange_weak_explicit`][exchange_weak_ex] | 弱い比較でメモリオーダーを指定して値の入れ替えを行う | C++11 |
-| [`atomic_compare_exchange_strong_explicit`][exchange_strong_ex] | 強い比較でメモリオーダーを指定して値の入れ替えを行う | C++11 |
+| [`atomic_is_lock_free`][is_lock_free]     | 指定されたオブジェクトがロックフリーに振る舞えるかを調べる | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_store`][store]                   | 値を書き込む | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_store_explicit`][store_ex]       | メモリオーダーを指定して値を書き込む | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_load`][load]                     | 値を読み込む | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_load_explicit`][load_ex]         | メモリオーダーを指定して値を読み込む | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_exchange`][exchange]             | 値を入れ替える | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_exchange_explicit`][exchange_ex] | メモリオーダーを指定して値を入れ替える | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_compare_exchange_weak`][exchange_weak] | 弱い比較で値の入れ替えを行う | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_compare_exchange_strong`][exchange_strong] | 強い比較で値の入れ替えを行う | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_compare_exchange_weak_explicit`][exchange_weak_ex] | 弱い比較でメモリオーダーを指定して値の入れ替えを行う | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
+| [`atomic_compare_exchange_strong_explicit`][exchange_strong_ex] | 強い比較でメモリオーダーを指定して値の入れ替えを行う | C++11&amp;lt;br/&amp;gt; C++20から非推奨 |
 
 [is_lock_free]: shared_ptr/atomic_is_lock_free.md
 [store]: shared_ptr/atomic_store.md
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_compare_exchange_strong -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_compare_exchange_strong.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_compare_exchange_strong.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_compare_exchange_strong.md b/reference/memory/shared_ptr/atomic_compare_exchange_strong.md
index 8a5f0cd78..34571b12c 100644
--- a/reference/memory/shared_ptr/atomic_compare_exchange_strong.md
+++ b/reference/memory/shared_ptr/atomic_compare_exchange_strong.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -12,6 +13,8 @@ namespace std {
 }
 ```
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 強い比較で、アトミックに`shared_ptr`オブジェクトを入れ替える。
 
@@ -37,6 +40,15 @@ atomic_compare_exchange_strong_explicit(
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -81,5 +93,4 @@ int main()
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
 - [LWG Issue 2172. Does `atomic_compare_exchange_*` accept `v == nullptr` arguments?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2172)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_compare_exchange_strong_explicit -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.md b/reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.md
index 83a83f9af..d87cd9c12 100644
--- a/reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.md
+++ b/reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -14,6 +15,8 @@ namespace std {
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 メモリオーダーを指定して、強い比較で、アトミックに`shared_ptr`オブジェクトを入れ替える。
 
@@ -43,6 +46,15 @@ namespace std {
 ## 備考
 等値比較は、2つの`shared_ptr`オブジェクトが同じポインタを保持し、リソースを共有していれば`true`となる。
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -93,5 +105,4 @@ int main()
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
 - [LWG Issue 2172. Does `atomic_compare_exchange_*` accept `v == nullptr` arguments?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2172)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_compare_exchange_weak -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_compare_exchange_weak.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_compare_exchange_weak.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_compare_exchange_weak.md b/reference/memory/shared_ptr/atomic_compare_exchange_weak.md
index fafe20cb2..8a8d5d53c 100644
--- a/reference/memory/shared_ptr/atomic_compare_exchange_weak.md
+++ b/reference/memory/shared_ptr/atomic_compare_exchange_weak.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -12,6 +13,8 @@ namespace std {
 }
 ```
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 弱い比較で、アトミックに`shared_ptr`オブジェクトを入れ替える。
 
@@ -37,6 +40,15 @@ atomic_compare_exchange_weak_explicit(
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -80,4 +92,4 @@ int main()
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
 - [LWG Issue 2172. Does `atomic_compare_exchange_*` accept `v == nullptr` arguments?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2172)
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_compare_exchange_weak_explicit -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.md b/reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.md
index 910f866cb..665cd6186 100644
--- a/reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.md
+++ b/reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -14,6 +15,8 @@ namespace std {
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 メモリオーダーを指定して、弱い比較で、アトミックに`shared_ptr`オブジェクトを入れ替える。
 
@@ -43,6 +46,15 @@ namespace std {
 ## 備考
 等値比較は、2つの`shared_ptr`オブジェクトが同じポインタを保持し、リソースを共有していれば`true`となる。
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -91,5 +103,4 @@ int main()
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
 - [LWG Issue 2172. Does `atomic_compare_exchange_*` accept `v == nullptr` arguments?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2172)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_exchange -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_exchange.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_exchange.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_exchange.md b/reference/memory/shared_ptr/atomic_exchange.md
index 3a1591c7b..0397fea06 100644
--- a/reference/memory/shared_ptr/atomic_exchange.md
+++ b/reference/memory/shared_ptr/atomic_exchange.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -11,6 +12,8 @@ namespace std {
 }
 ```
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 `shared_ptr`オブジェクトを、アトミックに入れ替える。
 
@@ -30,6 +33,15 @@ atomic_exchange_explicit(p, r, memory_order_seq_cst)
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -71,5 +83,4 @@ int main()
 - [`atomic_exchange() - &amp;lt;atomic&amp;gt;`](/reference/atomic/atomic_exchange.md)
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_exchange_explicit -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_exchange_explicit.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_exchange_explicit.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_exchange_explicit.md b/reference/memory/shared_ptr/atomic_exchange_explicit.md
index 5a8533931..574fc8856 100644
--- a/reference/memory/shared_ptr/atomic_exchange_explicit.md
+++ b/reference/memory/shared_ptr/atomic_exchange_explicit.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -13,6 +14,8 @@ namespace std {
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 メモリオーダーを指定して、`shared_ptr`オブジェクトを、アトミックに入れ替える。
 
@@ -32,6 +35,15 @@ namespace std {
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -75,5 +87,4 @@ int main()
 - [`atomic_exchange_explicit() - &amp;lt;atomic&amp;gt;`](/reference/atomic/atomic_exchange_explicit.md)
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_is_lock_free -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_is_lock_free.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_is_lock_free.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_is_lock_free.md b/reference/memory/shared_ptr/atomic_is_lock_free.md
index 48f99c08d..281dafdfd 100644
--- a/reference/memory/shared_ptr/atomic_is_lock_free.md
+++ b/reference/memory/shared_ptr/atomic_is_lock_free.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -11,6 +12,7 @@ namespace std {
 }
 ```
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
 
 ## 概要
 `shared_ptr`オブジェクトがロックフリーに振る舞えるかを判定する。
@@ -29,6 +31,15 @@ namespace std {
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -71,4 +82,4 @@ shared_ptr&amp;lt;int&amp;gt; isn&amp;#39;t lock-free
 - [`atomic_is_lock_free() - &amp;lt;atomic&amp;gt;`](/reference/atomic/atomic_is_lock_free.md)
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_load -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_load.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_load.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_load.md b/reference/memory/shared_ptr/atomic_load.md
index 54deb6bb7..94b1b3ef1 100644
--- a/reference/memory/shared_ptr/atomic_load.md
+++ b/reference/memory/shared_ptr/atomic_load.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -11,6 +12,8 @@ namespace std {
 }
 ```
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 `shared_ptr`オブジェクトを、アトミックに読み込む。
 
@@ -30,6 +33,15 @@ atomic_load_explicit(p, memory_order_seq_cst)
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -73,5 +85,4 @@ int main()
 - [`atomic_load() - &amp;lt;atomic&amp;gt;`](/reference/atomic/atomic_load.md)
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_load_explicit -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_load_explicit.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_load_explicit.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_load_explicit.md b/reference/memory/shared_ptr/atomic_load_explicit.md
index 57cd1d6bd..12b91bdaa 100644
--- a/reference/memory/shared_ptr/atomic_load_explicit.md
+++ b/reference/memory/shared_ptr/atomic_load_explicit.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -12,6 +13,8 @@ namespace std {
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 メモリオーダーを指定して、`shared_ptr`オブジェクトを、アトミックに読み込む。
 
@@ -32,6 +35,15 @@ namespace std {
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -77,5 +89,4 @@ int main()
 - [`atomic_load_explicit() - &amp;lt;atomic&amp;gt;`](/reference/atomic/atomic_load.md)
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_store -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_store.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_store.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_store.md b/reference/memory/shared_ptr/atomic_store.md
index 96158d354..fa00e9399 100644
--- a/reference/memory/shared_ptr/atomic_store.md
+++ b/reference/memory/shared_ptr/atomic_store.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -11,6 +12,8 @@ namespace std {
 }
 ```
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 `shared_ptr`オブジェクトに、アトミックに値を書き込む。
 
@@ -34,6 +37,15 @@ atomic_store_explicit(p, r, memory_order_seq_cst)
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -77,5 +89,4 @@ int main()
 - [`atomic_store() - &amp;lt;atomic&amp;gt;`](/reference/atomic/atomic_store.md)
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_store_explicit -- P0718R2のshared_ptrのアトミックフリー関数非推奨を適用</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/atomic_store_explicit.html"/>
      <id>90927bc3454740d33a8e2933e23ebbc8f3d96ea5:reference/memory/shared_ptr/atomic_store_explicit.md</id>
      <updated>2023-06-13T14:47:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/atomic_store_explicit.md b/reference/memory/shared_ptr/atomic_store_explicit.md
index e70914eca..bc1e5c5f0 100644
--- a/reference/memory/shared_ptr/atomic_store_explicit.md
+++ b/reference/memory/shared_ptr/atomic_store_explicit.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * function template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -12,6 +13,8 @@ namespace std {
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
+この関数は、C++20から非推奨となった。アトミックアクセスの対象としている`shared_ptr`を[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)で置き換えることで同等の機能を使用できる。
+
 ## 概要
 メモリオーダーを指定して、`shared_ptr`オブジェクトに、アトミックに値を書き込む。
 
@@ -36,6 +39,15 @@ namespace std {
 ## 例外
 投げない
 
+## 非推奨・削除の詳細
+
+この関数はフリー関数であるため、この関数によってアトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものはどこかに配置されている非アトミックオブジェクトである。そのため、アトミックアクセスしたい文脈の外側から通常のアクセスが可能であり、もし別のスレッドからそのようなアクセスが行われているとこの関数を用いていてもデータ競合を引き起こし未定義動作となる。
+
+すなわち、アトミックにアクセスしたい`shared_ptr`オブジェクトに対する全てのアクセスをプログラマがきちんと管理しなければこの関数の使用は安全ではなく、それはかなり困難であったためこの関数は危険な利用がデフォルトとなっていた。
+
+そのため、この関数（とそのファミリ）は非推奨とされ、代わりに[`shared_ptr`に対する`atomic`特殊化](/reference/memory/atomic.md)が追加された。`shared_ptr`に対する`atomic`特殊化を利用すれば、アトミックにアクセスする対象となる`shared_ptr`オブジェクトそのものをアトミックオブジェクトとすることができるため、どこからアクセスしたとしても全てのアクセスは自動的にアトミックアクセスとなり、前述の問題は回避できる。
+
+この関数から`shared_ptr`に対する`atomic`特殊化に移行する場合は、元のコードでアトミックアクセス対象となっていた`shared_ptr`オブジェクトの型を`std::atomic&amp;lt;std::shared_ptr&amp;gt;`に変更することで移行でき、その場合は`atomic`のために用意されているフリー関数が代わりに使用される（宣言されているヘッダが異なるため、`&amp;lt;atomic&amp;gt;`ヘッダのインクルードが必要となるかもしれない）。
 
 ## 例
 ```cpp example
@@ -81,5 +93,4 @@ int main()
 - [`atomic_store_explicit() - &amp;lt;atomic&amp;gt;`](/reference/atomic/atomic_store_explicit.md)
 - [N2674 Shared_ptr atomic access, revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2674.htm)
 - [C++0x Shared_ptr atomic access - Faith and Brave - C++で遊ぼう](http://faithandbrave.hateblo.jp/entry/20081015/1224066366)
-
-
+- [P0718R2 Revising `atomic_shared_ptr` for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0718r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>indirectly_writable -- NGワードとしてpvalue (prvalueのtypo) を追加</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirectly_writable.html"/>
      <id>5ae2c39abd2fa04018b5ee8add2a054c25079f4c:reference/iterator/indirectly_writable.md</id>
      <updated>2023-06-12T19:14:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirectly_writable.md b/reference/iterator/indirectly_writable.md
index c8e64a86c..f0974db85 100644
--- a/reference/iterator/indirectly_writable.md
+++ b/reference/iterator/indirectly_writable.md
@@ -33,26 +33,26 @@ namespace std {
 
 `const_cast`を用いる制約式は、非プロキシオブジェクト（値を所有するオブジェクトのことである。[`std::string`](/reference/string/basic_string.md)などが該当）を弾くために存在する。
 
-まず前提として、非プロキシオブジェクトは[メンバ関数の左辺値／右辺値修飾](https://cpprefjp.github.io/lang/cpp11/ref_qualifier_for_this.html)が追加される以前からの慣習により、*pvalue*であっても代入が可能である。また、値を所有するために`const`が付与されれば代入は不可能となる。
+まず前提として、非プロキシオブジェクトは[メンバ関数の左辺値／右辺値修飾](https://cpprefjp.github.io/lang/cpp11/ref_qualifier_for_this.html)が追加される以前からの慣習により、*prvalue*であっても代入が可能である。また、値を所有するために`const`が付与されれば代入は不可能となる。
 
 ```cpp example
 #include &amp;lt;string&amp;gt;
 
 int main()
 { 
-  std::string()  = &amp;#34;string&amp;#34;; // pvalueに代入
+  std::string()  = &amp;#34;string&amp;#34;; // prvalueに代入
 }
 ```
 
-このような非プロキシオブジェクトの*pvalue*がイテレータの間接参照結果として返された場合、それに書き込んだとしても、その*pvalue*のオブジェクトが所有する値を書き換えるのみであり、正しく出力されるとは言えない。
+このような非プロキシオブジェクトの*prvalue*がイテレータの間接参照結果として返された場合、それに書き込んだとしても、その*prvalue*のオブジェクトが所有する値を書き換えるのみであり、正しく出力されるとは言えない。
 
-一方で、プロキシオブジェクト（所有権を持たず、他のオブジェクトを参照するオブジェクト）がイテレータの間接参照結果として返された場合は、*pvalue*の場合も代入された値を「参照する先のオブジェクトが所有する値」へ書き込むことによって、正しく出力を完了することが出来る。
+一方で、プロキシオブジェクト（所有権を持たず、他のオブジェクトを参照するオブジェクト）がイテレータの間接参照結果として返された場合は、*prvalue*の場合も代入された値を「参照する先のオブジェクトが所有する値」へ書き込むことによって、正しく出力を完了することが出来る。
 
 更に、プロキシオブジェクトは値を所有しないため「`const`な参照先」でなければ、プロキシオブジェクトそれ自体が`const`であっても代入は可能であるべきである。しかしながら、従来のプロキシオブジェクトは`const`を付与された場合代入が不可能になる実装が殆どであり、変更が必要である。例としては[`std::vector&amp;lt;bool&amp;gt;::reference`](/reference/vector/vector.md)がある。
 
 プロキシオブジェクトの他にも、参照（右辺値参照/左辺値参照問わず）も正しく出力が可能である。このことから、「`const`を付与した上でも代入が可能であるようなプロキシオブジェクト」と「参照」を合わせて「プロキシ参照（proxy reference）」と呼称することがある。
 
-以上のことから、`const`を付与した際にも代入が可能であればプロキシ参照、不可能であれば非プロキシ参照と区別することが可能となる。したがって、間接参照が非プロキシ参照（プロキシオブジェクトでない*pvalue*など）を返すイテレータ型は本コンセプトのモデルとならず、プロキシ参照を返すイテレータは本コンセプトのモデルとなる事ができる。
+以上のことから、`const`を付与した際にも代入が可能であればプロキシ参照、不可能であれば非プロキシ参照と区別することが可能となる。したがって、間接参照が非プロキシ参照（プロキシオブジェクトでない*prvalue*など）を返すイテレータ型は本コンセプトのモデルとならず、プロキシ参照を返すイテレータは本コンセプトのモデルとなる事ができる。
 
 ## モデル
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reference_constructs_from_temporary -- NGワードとしてpvalue (prvalueのtypo) を追加</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/reference_constructs_from_temporary.html"/>
      <id>5ae2c39abd2fa04018b5ee8add2a054c25079f4c:reference/type_traits/reference_constructs_from_temporary.md</id>
      <updated>2023-06-12T19:14:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/reference_constructs_from_temporary.md b/reference/type_traits/reference_constructs_from_temporary.md
index 05d91676b..1e50abada 100644
--- a/reference/type_traits/reference_constructs_from_temporary.md
+++ b/reference/type_traits/reference_constructs_from_temporary.md
@@ -31,17 +31,17 @@ namespace std {
 `VAL&amp;lt;U&amp;gt;`を次のように定義する。
 
 - `U`が参照型や関数型の場合、[`declval`](/reference/utility/declval.md)`&amp;lt;U&amp;gt;()`と同じ型と値カテゴリを持つ式
-- `U`が参照型や関数型でない場合、型`U`である`pvalue`（ただし、`U`に`const`/`volatile`修飾があれば調整される）
+- `U`が参照型や関数型でない場合、型`U`である`prvalue`（ただし、`U`に`const`/`volatile`修飾があれば調整される）
 
 [`conjunction_v`](conjunction.md)`&amp;lt;`[`is_reference`](is_reference.md)`&amp;lt;T&amp;gt;,` [`is_constructible`](is_constructible.md)`&amp;lt;T, U&amp;gt;&amp;gt;`が`true`かつ、`T t(VAL&amp;lt;U&amp;gt;)`において`t`が一時オブジェクトの寿命を延長する場合に[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 
 ## 備考
-多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「戻り値の型が右辺値参照である関数」の戻り値を束縛することを考える。（再現コードは、説明の最後に付す）
+多くのメタ関数は`prvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「戻り値の型が右辺値参照である関数」の戻り値を束縛することを考える。（再現コードは、説明の最後に付す）
 
-この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は戻り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
+この事自体は即座に不適格とはならない。しかし、その関数が実際には`prvalue`を返しているとすれば、その`prvalue`は戻り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
 
-このような場面においては、本メタ関数が`pvalue`と`xvalue`を、`pvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
+このような場面においては、本メタ関数が`prvalue`と`xvalue`を、`prvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reference_converts_from_temporary -- NGワードとしてpvalue (prvalueのtypo) を追加</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html"/>
      <id>5ae2c39abd2fa04018b5ee8add2a054c25079f4c:reference/type_traits/reference_converts_from_temporary.md</id>
      <updated>2023-06-12T19:14:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/reference_converts_from_temporary.md b/reference/type_traits/reference_converts_from_temporary.md
index 63ea01dea..35cde01c5 100644
--- a/reference/type_traits/reference_converts_from_temporary.md
+++ b/reference/type_traits/reference_converts_from_temporary.md
@@ -27,17 +27,17 @@ namespace std {
 `VAL&amp;lt;U&amp;gt;`を次のように定義する。
 
 - `U`が参照型や関数型の場合、[`declval`](/reference/utility/declval.md)`&amp;lt;U&amp;gt;()`と同じ型と値カテゴリを持つ式
-- `U`が参照型や関数型でない場合、型`U`である`pvalue`（ただし、`U`に`const`/`volatile`修飾があれば調整される）
+- `U`が参照型や関数型でない場合、型`U`である`prvalue`（ただし、`U`に`const`/`volatile`修飾があれば調整される）
 
 [`conjunction_v`](conjunction.md)`&amp;lt;`[`is_reference`](is_reference.md)`&amp;lt;T&amp;gt;,` [`is_convertible`](is_convertible.md)`&amp;lt;U, T&amp;gt;&amp;gt;`が`true`かつ、`T t(VAL&amp;lt;U&amp;gt;)`において`t`が一時オブジェクトの寿命を延長する場合に[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 
 ## 備考
-多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「戻り値の型が右辺値参照である関数」の戻り値を束縛することを考える。（再現コードは、説明の最後に付す）
+多くのメタ関数は`prvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「戻り値の型が右辺値参照である関数」の戻り値を束縛することを考える。（再現コードは、説明の最後に付す）
 
-この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は戻り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
+この事自体は即座に不適格とはならない。しかし、その関数が実際には`prvalue`を返しているとすれば、その`prvalue`は戻り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
 
-このような場面においては、本メタ関数が`pvalue`と`xvalue`を、`pvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
+このような場面においては、本メタ関数が`prvalue`と`xvalue`を、`prvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コルーチン -- コルーチン : pvalue -&gt; prvalue</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/coroutines.html"/>
      <id>5e2017d1eb229b78d1ae16d99c4afef381682a58:lang/cpp20/coroutines.md</id>
      <updated>2023-06-12T17:53:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/coroutines.md b/lang/cpp20/coroutines.md
index 89de2759f..4796f99c3 100644
--- a/lang/cpp20/coroutines.md
+++ b/lang/cpp20/coroutines.md
@@ -434,8 +434,8 @@ _p_ をコルーチンPromiseオブジェクトのlvalue名とすると、`co_re
 
 ここで _final-suspend_ はコルーチン動作説明用の最終サスペンドポイントラベル名であり、_S_ は次の通り定義される：
 
-- オペランドが _braced-init-list_ または非`void`型の式の場合、_S_ を _p_`.return_value(` _expr-or-braced-init-list_ `)`とする。式 _S_ は `void`型のpvalueであるべき。
-- そうでなければ、_S_ を複合文 `{` _expression_ _opt_ `;` _p_`.return_void(); }`とする。式 _p_`.return_void()`は`void`型のpvalueであるべき。
+- オペランドが _braced-init-list_ または非`void`型の式の場合、_S_ を _p_`.return_value(` _expr-or-braced-init-list_ `)`とする。式 _S_ は `void`型のprvalueであるべき。
+- そうでなければ、_S_ を複合文 `{` _expression_ _opt_ `;` _p_`.return_void(); }`とする。式 _p_`.return_void()`は`void`型のprvalueであるべき。
 
 _p_`.return_void()`が有効な式のとき、コルーチン本体の終端到達はオペランド無し`co_return`と等価である。
 そうでなければ、コルーチン本体の終端到達は未定義の動作を引き起こす。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace -- flat_map::emplace : インクルードミスを修正 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/emplace.html"/>
      <id>83dd89cb38bbc23df68cf8b6372ea0a7010a2385:reference/flat_map/flat_map/emplace.md</id>
      <updated>2023-06-12T14:29:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/emplace.md b/reference/flat_map/flat_map/emplace.md
index e69100dbb..f822e8ec7 100644
--- a/reference/flat_map/flat_map/emplace.md
+++ b/reference/flat_map/flat_map/emplace.md
@@ -49,7 +49,7 @@ c.values.insert(value_it, std::move(t.second));
 ### 単純なキー・値を挿入する例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
-#include &amp;lt;map&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
 
 int main()
 {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>