<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-24T08:47:04.584676</updated>
  <id>e7129f3b-5053-47a1-a6f2-f11882feaf75</id>

  
    <entry>
      <title>span -- span,basic_string_view: P2251対応(#1062)</title>
      <link href="https://cpprefjp.github.io/reference/span/span.html"/>
      <id>020145072fe3f0b3552760fd3de229fc084fe5dc:reference/span/span.md</id>
      <updated>2023-01-24T17:41:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span.md b/reference/span/span.md
index f65f8daf0..c4fe25ad3 100644
--- a/reference/span/span.md
+++ b/reference/span/span.md
@@ -31,6 +31,8 @@ namespace std {
 
 文字列操作に特化したクラスとして[`std::basic_string_view`](/reference/string_view/basic_string_view.md)が定義されているが、こちらはメモリ連続性をもつあらゆるコンテナに適用できる。
 
+このクラスは、[トリビアルコピー可能](/reference/type_traits/is_trivially_copyable.md)である（C++23）
+
 
 ### メモリ連続性
 このクラスの対象は、メモリの連続性を持つシーケンスである。例として、以下は対象のシーケンスである：
@@ -276,3 +278,5 @@ int main()
 - [P2116R0 Remove tuple-like protocol support from fixed-extent `span`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2116r0.html)
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P2325R3 Views should not be required to be default constructible](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html)
+- [Require `span` &amp;amp; `basic_string_view` to be Trivially Copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf)
+    - C++23から、トリビアルコピー可能が保証される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_string_view -- span,basic_string_view: P2251対応(#1062)</title>
      <link href="https://cpprefjp.github.io/reference/string_view/basic_string_view.html"/>
      <id>020145072fe3f0b3552760fd3de229fc084fe5dc:reference/string_view/basic_string_view.md</id>
      <updated>2023-01-24T17:41:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string_view/basic_string_view.md b/reference/string_view/basic_string_view.md
index 5e7bc85b2..2c3484d7f 100644
--- a/reference/string_view/basic_string_view.md
+++ b/reference/string_view/basic_string_view.md
@@ -31,6 +31,8 @@ string_view hello = sv.substr(0, 5); // 先頭5文字を抽出する
 
 このクラスの実装としては、文字配列の参照する先頭文字へのポインタと、文字数の2つをメンバ変数として持つ。これらの変数を変動させることによって、部分文字列の抽出や、限定された範囲内での検索といったことを実現する。
 
+このクラスは、[トリビアルコピー可能](/reference/type_traits/is_trivially_copyable.md)である（C++23）
+
 
 ## メンバ関数
 ### 構築・破棄
@@ -321,3 +323,5 @@ C
 - [P0254R2 Integrating `std::string_view` and `std::string`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0254r2.pdf)
 - [P0403R0 Literal suffixes for `basic_string_view`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0403r0.html)
 - [String literals make bad ranges - Andrzej&amp;#39;s C++ blog](https://akrzemi1.wordpress.com/2019/09/25/string-literals-make-bad-ranges/)
+- [Require `span` &amp;amp; `basic_string_view` to be Trivially Copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf)
+    - C++23から、トリビアルコピー可能が保証される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_only_function -- move_only_funciton : std::functionとの違いについて追記</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function.html"/>
      <id>6e6d1c530a1e90c052394a44d9e1e4a64a6c419b:reference/functional/move_only_function.md</id>
      <updated>2023-01-24T17:29:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function.md b/reference/functional/move_only_function.md
index 3e189c013..448d26961 100644
--- a/reference/functional/move_only_function.md
+++ b/reference/functional/move_only_function.md
@@ -29,7 +29,9 @@ namespace std {
 - const性を正しく伝搬する。
 - 関数型のCV修飾／参照修飾／noexcept例外指定をサポートする。
 - [`target_type`](function/target_type.md)型と[`target()`](function/target.md)を提供しない。
-- [関数呼び出し](move_only_function/op_call.md)は強い前提条件を持つ。
+    - 実行時型情報（RTTI）非依存
+- [関数呼び出し](move_only_function/op_call.md)は強い事前条件を持つ。
+    - 関数呼び出し時のnullチェックが要求されない
 
 
 ## メンバ関数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_only_function -- move_only_function: 従来functionと対比した例示コードを拡充(#1056)</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function.html"/>
      <id>f85391077c46ea79afc2a1a5792bf3d7ac44b4e6:reference/functional/move_only_function.md</id>
      <updated>2023-01-24T15:06:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function.md b/reference/functional/move_only_function.md
index ebd0db201..3e189c013 100644
--- a/reference/functional/move_only_function.md
+++ b/reference/functional/move_only_function.md
@@ -16,12 +16,21 @@ namespace std {
 ## 概要
 `move_only_function`クラステンプレートは、パラメータの型リスト`ArgTypes...`、戻り値の型`R`に合致する、あらゆる関数ポインタ、関数オブジェクト、メンバ関数ポインタ、メンバ変数ポインタを保持できるクラスである。
 
-下記全ての組み合わせ（12種類）についてクラステンプレートの部分特殊化が提供される。
+下記全ての組み合わせ（12種類）に対して、クラステンプレートの部分特殊化が提供される。
 
 - CV修飾子 *cv* : `const`, CV修飾無し
 - 参照修飾子 *ref* : `&amp;amp;`, `&amp;amp;&amp;amp;`, 参照修飾無し
 - noexcept例外指定 *noex* : `true`, `false`
 
+### `function`との比較
+[`std::function`](function.md)と比べて、`std::move_only_function`は下記の特徴をもつ。
+
+- ムーブのみ対応。コピー不可。
+- const性を正しく伝搬する。
+- 関数型のCV修飾／参照修飾／noexcept例外指定をサポートする。
+- [`target_type`](function/target_type.md)型と[`target()`](function/target.md)を提供しない。
+- [関数呼び出し](move_only_function/op_call.md)は強い前提条件を持つ。
+
 
 ## メンバ関数
 ### 構築・破棄
@@ -52,9 +61,10 @@ namespace std {
 
 
 ## 例
+### 例1: 基本の使い方
 ```cpp example
-#include &amp;lt;iostream&amp;gt;
 #include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
 
 int add(int x) { return x + 1; }
 
@@ -74,9 +84,139 @@ int main()
 * std::move_only_function[color ff0000]
 * f(1)[link move_only_function/op_call.md]
 
-### 出力
+#### 出力
+```
+2
+```
+
+### 例2: const性の伝搬
+```cpp
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+struct Functor {
+  std::string operator()() {
+    return &amp;#34;non-const&amp;#34;;
+  }
+  std::string operator()() const {
+    return &amp;#34;const&amp;#34;;
+  }
+};
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; &amp;#34;-- move_only_function&amp;#34; &amp;lt;&amp;lt; std::endl;
+        std::move_only_function&amp;lt;std::string(void)&amp;gt;       mof1 = Functor{};
+  const std::move_only_function&amp;lt;std::string(void)&amp;gt;       mof2 = Functor{}; // (呼び出し時に不適格)
+        std::move_only_function&amp;lt;std::string(void) const&amp;gt; mof3 = Functor{};
+  const std::move_only_function&amp;lt;std::string(void) const&amp;gt; mof4 = Functor{};
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof1: &amp;#34; &amp;lt;&amp;lt; mof1() &amp;lt;&amp;lt; std::endl;
+//std::cout &amp;lt;&amp;lt; &amp;#34;mof2: &amp;#34; &amp;lt;&amp;lt; mof2() &amp;lt;&amp;lt; std::endl; // 不適格
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof3: &amp;#34; &amp;lt;&amp;lt; mof3() &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof4: &amp;#34; &amp;lt;&amp;lt; mof4() &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;-- function&amp;#34; &amp;lt;&amp;lt; std::endl;
+        std::function&amp;lt;std::string(void)&amp;gt;       fn1 = Functor{};
+  const std::function&amp;lt;std::string(void)&amp;gt;       fn2 = Functor{};
+//      std::function&amp;lt;std::string(void) const&amp;gt; fn3 = Functor{}; // 不適格
+//const std::function&amp;lt;std::string(void) const&amp;gt; fn4 = Functor{}; // 不適格
+  std::cout &amp;lt;&amp;lt; &amp;#34;fn1: &amp;#34; &amp;lt;&amp;lt; fn1() &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;fn2: &amp;#34; &amp;lt;&amp;lt; fn2() &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::move_only_function[color ff0000]
+* std::function[link function.md]
+
+#### 出力
+```
+-- move_only_function
+mof1: non-const
+mof3: const
+mof4: const
+-- function
+fn1: non-const
+fn2: non-const
+```
+
+### 例3: 左辺値/右辺値の伝搬
+```cpp example
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+struct Functor {
+  std::string operator()() &amp;amp; {
+    return &amp;#34;L-val&amp;#34;;
+  }
+  std::string operator()() &amp;amp;&amp;amp; {
+    return &amp;#34;R-val&amp;#34;;
+  }
+};
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; &amp;#34;-- move_only_function&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::move_only_function&amp;lt;std::string(void)&amp;gt;    mof1 = Functor{};
+  std::move_only_function&amp;lt;std::string(void) &amp;amp;&amp;amp;&amp;gt; mof2 = Functor{};
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof1/L-val: &amp;#34; &amp;lt;&amp;lt; mof1()            &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof1/R-val: &amp;#34; &amp;lt;&amp;lt; std::move(mof1)() &amp;lt;&amp;lt; std::endl;
+//std::cout &amp;lt;&amp;lt; &amp;#34;mof2/L-val: &amp;#34; &amp;lt;&amp;lt; mof2()            &amp;lt;&amp;lt; std::endl; // 不適格
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof2/R-val: &amp;#34; &amp;lt;&amp;lt; std::move(mof2)() &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;-- function&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::function&amp;lt;std::string(void)&amp;gt;    fn1 = Functor{};
+//std::function&amp;lt;std::string(void) &amp;amp;&amp;amp;&amp;gt; fn2 = Functor{}; // 不適格
+  std::cout &amp;lt;&amp;lt; &amp;#34;fn1/L-val: &amp;#34; &amp;lt;&amp;lt; fn1()            &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;fn1/R-val: &amp;#34; &amp;lt;&amp;lt; std::move(fn1)() &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::move_only_function[color ff0000]
+* std::function[link function.md]
+
+#### 出力
+```
+-- move_only_function
+mof1/L-val: L-val
+mof1/R-val: L-val
+mof2/R-val: R-val
+-- function
+fn1/L-val: L-val
+fn1/R-val: L-val
+```
+
+### 例4: noexcept指定の伝搬
+```cpp example
+#include &amp;lt;functional&amp;gt;
+
+void func() {}
+void func_noex() noexcept {}
+
+int main()
+{
+  std::move_only_function&amp;lt;void(void)&amp;gt;          mof1 = func;
+  std::move_only_function&amp;lt;void(void)&amp;gt;          mof2 = func_noex;
+//std::move_only_function&amp;lt;void(void) noexcept&amp;gt; mof3 = func; // 不適格
+  std::move_only_function&amp;lt;void(void) noexcept&amp;gt; mof4 = func_noex;
+  static_assert(not noexcept(mof1()));
+  static_assert(not noexcept(mof2()));
+  static_assert(    noexcept(mof4()));
+
+  std::function&amp;lt;void(void)&amp;gt;          fn1 = func;
+  std::function&amp;lt;void(void)&amp;gt;          fn2 = func_noex;
+//std::function&amp;lt;void(void) noexcept&amp;gt; fn3 = func;      // 不適格
+//std::function&amp;lt;void(void) noexcept&amp;gt; fn4 = func_noex; // 不適格
+  static_assert(not noexcept(fn1()));
+  static_assert(not noexcept(fn2()));
+}
+```
+* std::move_only_function[color ff0000]
+* std::function[link function.md]
+
+#### 出力
 ```
-1
 ```
 
 
@@ -86,7 +226,7 @@ int main()
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): ??
+- [GCC](/implementation.md#gcc): 12.1
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
@@ -97,3 +237,5 @@ int main()
 
 ## 参照
 - [P0288R9 move_only_function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0288r9.html)
+- [N4348 Making `std::function` safe for concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html)
+    - `std::function`のconst性伝搬に関して、スレッドセーフ保証の観点からの問題指摘。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- move_only_function: 従来functionと対比した例示コードを拡充(#1056)</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function/op_call.html"/>
      <id>f85391077c46ea79afc2a1a5792bf3d7ac44b4e6:reference/functional/move_only_function/op_call.md</id>
      <updated>2023-01-24T15:06:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function/op_call.md b/reference/functional/move_only_function/op_call.md
index e72ca0069..fcc09a5ff 100644
--- a/reference/functional/move_only_function/op_call.md
+++ b/reference/functional/move_only_function/op_call.md
@@ -12,7 +12,12 @@ R operator()(ArgTypes... args) /*cv*/ /*ref*/ noexcept(/*noex*/);
 ## 概要
 関数を呼び出す。
 
-CV修飾子 *cv*, 参照修飾子 *ref*, noexcept例外指定 *noex* は[`move_only_function`](../move_only_function.md)に指定するテンプレートパラメータ`R(ArgTypes...)`部と等しい。
+`operator()`のCV修飾子 *cv*, 参照修飾子 *ref*, noexcept例外指定 *noex* は、[`move_only_function`](../move_only_function.md)に指定するテンプレートパラメータ`R(ArgTypes...)`部のものと等しい。
+
+説明用のプレースホルダ *inv-quals* を次のように定義する :
+
+- *ref* が空（参照修飾無し）ならば、*cv*`&amp;amp;`
+- そうでなければ、*cv* *ref*
 
 
 ## 事前条件
@@ -20,7 +25,7 @@ CV修飾子 *cv*, 参照修飾子 *ref*, noexcept例外指定 *noex* は[`move_o
 
 
 ## 効果
-`*this`が保持している`F`型の関数ポインタまたは関数オブジェクト`f`に対して、[`INVOKE&amp;lt;R&amp;gt;`](/reference/concepts/Invoke.md)`(static_cast&amp;lt;F inv-quals&amp;gt;(f),` [`std::forward`](/reference/utility/forward.md)`&amp;lt;ArgTypes&amp;gt;(args)...)`を行う。
+`*this`が保持している`F`型の関数ポインタまたは関数オブジェクト`f`に対して、[`INVOKE&amp;lt;R&amp;gt;`](/reference/concepts/Invoke.md)`(static_cast&amp;lt;F /*inv-quals*/&amp;gt;(f),` [`std::forward`](/reference/utility/forward.md)`&amp;lt;ArgTypes&amp;gt;(args)...)`を行う。
 
 
 ## 戻り値
@@ -58,7 +63,7 @@ int main()
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): ??
+- [GCC](/implementation.md#gcc): 12.1
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>convertible_to -- 訳語表: &#34;program-defiend type&#34;を追加</title>
      <link href="https://cpprefjp.github.io/reference/concepts/convertible_to.html"/>
      <id>04e52ed81dd8ee331331170a6f67a548fc195e6b:reference/concepts/convertible_to.md</id>
      <updated>2023-01-24T00:47:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/convertible_to.md b/reference/concepts/convertible_to.md
index b6be42623..cd446206b 100644
--- a/reference/concepts/convertible_to.md
+++ b/reference/concepts/convertible_to.md
@@ -86,7 +86,7 @@ int main()
   std::cout &amp;lt;&amp;lt; std::convertible_to&amp;lt;int*, const int*&amp;gt; &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; std::convertible_to&amp;lt;const int*, int*&amp;gt; &amp;lt;&amp;lt; std::endl;
 
-  std::cout &amp;lt;&amp;lt; &amp;#34;\n--- program defined type ---\n&amp;#34;;
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n--- program-defined type ---\n&amp;#34;;
   std::cout &amp;lt;&amp;lt; std::convertible_to&amp;lt;convert_int, int&amp;gt; &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; std::convertible_to&amp;lt;int, convert_int&amp;gt; &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; std::convertible_to&amp;lt;convert_double, double&amp;gt; &amp;lt;&amp;lt; std::endl;
@@ -113,7 +113,7 @@ true
 true
 false
 
---- program defined type ---
+--- program-defined type ---
 true
 true
 false
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>スタイル -- 訳語表: &#34;program-defiend type&#34;を追加</title>
      <link href="https://cpprefjp.github.io/working_style.html"/>
      <id>04e52ed81dd8ee331331170a6f67a548fc195e6b:working_style.md</id>
      <updated>2023-01-24T00:47:28+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;スタイル&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本サイトで作業を行う上でのスタイルです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「である」調&lt;/li&gt;
&lt;li&gt;句読点は「、」「。」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型修飾のスタイル：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A) const T &amp;amp;v&lt;/li&gt;
&lt;li&gt;B) const T&amp;amp; v&lt;/li&gt;
&lt;li&gt;C) const T &amp;amp; v&lt;/li&gt;
&lt;li&gt;D) T const &amp;amp;v&lt;/li&gt;
&lt;li&gt;E) T const&amp;amp; v&lt;/li&gt;
&lt;li&gt;F) T const &amp;amp; v&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本サイトでは、Bのスタイルで型修飾を行います。&lt;/p&gt;
&lt;h2&gt;バージョンの表記&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;p&gt;C++11以降対応については対応バージョンを明記します。バージョン表記が省略されている場合、C++03、C++98対応であることを表します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;li&gt;C++14&lt;/li&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;li&gt;C++03&lt;/li&gt;
&lt;li&gt;C++98&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;p&gt;開発環境の表記がない場合は、C++98対応のあらゆる環境で使用できるものとします。 
処理系の記載は、作業者が確認できたものを記載します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Clang: 2.1, 2.8&lt;/li&gt;
&lt;li&gt;GCC: 4.3.4, 4.4.3, 4.4.4, 4.5.2&lt;/li&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1, 12.0&lt;/li&gt;
&lt;li&gt;PathScale: 3.2&lt;/li&gt;
&lt;li&gt;QCC&lt;/li&gt;
&lt;li&gt;Visual C++: 2003, 2008, 2010&lt;/li&gt;
&lt;li&gt;pgCC: 11.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それと、訳語表を随時更新していってください。&lt;/p&gt;
&lt;h3&gt;訳語表&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英語&lt;/th&gt;
&lt;th&gt;日本語&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abstract class&lt;/td&gt;
&lt;td&gt;抽象クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;aggregate&lt;/td&gt;
&lt;td&gt;集成体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alignment&lt;/td&gt;
&lt;td&gt;アライメント (表示位置ではなくメモリの文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;apply, application&lt;/td&gt;
&lt;td&gt;適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arithmetic type&lt;/td&gt;
&lt;td&gt;算術型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;associative container(s)&lt;/td&gt;
&lt;td&gt;連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;base class&lt;/td&gt;
&lt;td&gt;基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bidirectional iterator&lt;/td&gt;
&lt;td&gt;双方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bucket&lt;/td&gt;
&lt;td&gt;バケット&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;complexity&lt;/td&gt;
&lt;td&gt;計算量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compound type&lt;/td&gt;
&lt;td&gt;複合型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const iterator&lt;/td&gt;
&lt;td&gt;読み取り専用イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const reverse iterator&lt;/td&gt;
&lt;td&gt;読み取り専用逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;covariant&lt;/td&gt;
&lt;td&gt;共変的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data member&lt;/td&gt;
&lt;td&gt;メンバ変数 (ユーザー視点ではデータメンバより一般的のため)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereference&lt;/td&gt;
&lt;td&gt;間接参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereferenceable&lt;/td&gt;
&lt;td&gt;間接参照可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;derived class&lt;/td&gt;
&lt;td&gt;派生クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;direct base class&lt;/td&gt;
&lt;td&gt;直接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delegate&lt;/td&gt;
&lt;td&gt;委譲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;effects&lt;/td&gt;
&lt;td&gt;効果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emplace&lt;/td&gt;
&lt;td&gt;直接構築&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equal&lt;/td&gt;
&lt;td&gt;等値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence class&lt;/td&gt;
&lt;td&gt;同値分類 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence relation&lt;/td&gt;
&lt;td&gt;同値関係 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalent&lt;/td&gt;
&lt;td&gt;同値 (数学的文脈)、等価 (その他文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forward iterator&lt;/td&gt;
&lt;td&gt;前方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fundamental type&lt;/td&gt;
&lt;td&gt;単純型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ill-formed&lt;/td&gt;
&lt;td&gt;&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;implementation-defined&lt;/td&gt;
&lt;td&gt;処理系定義&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indirect base class&lt;/td&gt;
&lt;td&gt;間接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;inherited&lt;/td&gt;
&lt;td&gt;継承&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input iterator&lt;/td&gt;
&lt;td&gt;入力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;literal type&lt;/td&gt;
&lt;td&gt;リテラル型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load factor&lt;/td&gt;
&lt;td&gt;負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lvalue reference&lt;/td&gt;
&lt;td&gt;左辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max load factor&lt;/td&gt;
&lt;td&gt;最大負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;member&lt;/td&gt;
&lt;td&gt;メンバ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move&lt;/td&gt;
&lt;td&gt;(std::move 的な意味で)ムーブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move assignment&lt;/td&gt;
&lt;td&gt;ムーブ代入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move constructor&lt;/td&gt;
&lt;td&gt;ムーブコンストラクタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mutable iterator&lt;/td&gt;
&lt;td&gt;可変イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;non-virtual base class&lt;/td&gt;
&lt;td&gt;非仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;note&lt;/td&gt;
&lt;td&gt;注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output iterator&lt;/td&gt;
&lt;td&gt;出力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overload&lt;/td&gt;
&lt;td&gt;オーバーロード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(proposal) paper&lt;/td&gt;
&lt;td&gt;提案文書&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partial ordering&lt;/td&gt;
&lt;td&gt;半順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partition&lt;/td&gt;
&lt;td&gt;区分化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ポインタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;polymorphic&lt;/td&gt;
&lt;td&gt;多相的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;power of N&lt;/td&gt;
&lt;td&gt;Nの累乗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;predicate&lt;/td&gt;
&lt;td&gt;述語&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;propagation, propagate&lt;/td&gt;
&lt;td&gt;伝播&lt;br /&gt; (伝搬は誤用が広まったものなので使わない)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pure virtual function&lt;/td&gt;
&lt;td&gt;純粋仮想関数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;random access iterator&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;一般用途の場合：範囲&lt;br /&gt; Rangeアルゴリズム・Rangeアダプタ・Rangeオブジェクトの場合：Range&lt;br /&gt; range-based for：範囲for文&lt;br /&gt; 2つのイテレータによる範囲：イテレータ範囲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;remarks&lt;/td&gt;
&lt;td&gt;備考&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;requires&lt;/td&gt;
&lt;td&gt;要件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;returns&lt;/td&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reverse iterator&lt;/td&gt;
&lt;td&gt;逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rvalue reference&lt;/td&gt;
&lt;td&gt;右辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sequence container(s)&lt;/td&gt;
&lt;td&gt;シーケンスコンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;signed&lt;/td&gt;
&lt;td&gt;符号付き&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop request&lt;/td&gt;
&lt;td&gt;停止要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop state&lt;/td&gt;
&lt;td&gt;停止状態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spurious Failure&lt;/td&gt;
&lt;td&gt;見かけ上の失敗&lt;br /&gt; &lt;a href=&#34;https://togetter.com/li/430770&#34; target=&#34;_blank&#34;&gt;https://togetter.com/li/430770&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strict weak ordering&lt;/td&gt;
&lt;td&gt;狭義の弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strong ordering&lt;/td&gt;
&lt;td&gt;全順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;structural type&lt;/td&gt;
&lt;td&gt;構造的型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;synchronization&lt;/td&gt;
&lt;td&gt;同期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;total ordering relationalship&lt;/td&gt;
&lt;td&gt;全順序関係&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trailing return type&lt;/td&gt;
&lt;td&gt;後置戻り値型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trait&lt;/td&gt;
&lt;td&gt;トレイト&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trivial&lt;/td&gt;
&lt;td&gt;トリビアル (逆は非トリビアル)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underlying type&lt;/td&gt;
&lt;td&gt;基底型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unordered associative container(s)&lt;/td&gt;
&lt;td&gt;非順序連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unspecified&lt;/td&gt;
&lt;td&gt;未規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;program-defined type&lt;/td&gt;
&lt;td&gt;プログラム定義型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;virtual base class&lt;/td&gt;
&lt;td&gt;仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;weak ordering&lt;/td&gt;
&lt;td&gt;弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;well-formed&lt;/td&gt;
&lt;td&gt;適格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eligible&lt;/td&gt;
&lt;td&gt;資格のある&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inout_ptr_t -- memory/(in)out_ptr_t: 特殊化可能なことを追記(#1050)</title>
      <link href="https://cpprefjp.github.io/reference/memory/inout_ptr_t.html"/>
      <id>731e1ea31aaf0eb0022d342263e3d4b8c359e55a:reference/memory/inout_ptr_t.md</id>
      <updated>2023-01-24T00:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/inout_ptr_t.md b/reference/memory/inout_ptr_t.md
index 4dffa9e67..1dc0927b3 100644
--- a/reference/memory/inout_ptr_t.md
+++ b/reference/memory/inout_ptr_t.md
@@ -15,7 +15,10 @@ namespace std {
 2重ポインタ`T**`(=`Pointer*`)引数経由で既存リソースを解放してから新規確保リソースへのポインタを返すレガシーC関数に対して、取得されたポインタ値をスマートポインタに格納するアダプタクラス。
 アダプタオブジェクトの生成には、[`std::inout_ptr()`](inout_ptr.md)ヘルパ関数を利用する。
 
-C++標準スマートポインタ[`std::unique_ptr`](unique_ptr.md)を始め、互換インタフェースをもつ任意のスマートポインタ型`Smart`を取り扱える。
+リソース占有管理セマンティクスを提供するC++標準スマートポインタ[`std::unique_ptr`](unique_ptr.md)を始め、互換インタフェースをもつ任意のスマートポインタ型`Smart`を取り扱える。
+
+プログラマは`inout_ptr_t`クラステンプレートの特殊化を定義してもよい。
+このとき1つ以上のプログラム定義型に依存していれば、プライマリテンプレートにおける要件を満たす必要はない。
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>out_ptr_t -- memory/(in)out_ptr_t: 特殊化可能なことを追記(#1050)</title>
      <link href="https://cpprefjp.github.io/reference/memory/out_ptr_t.html"/>
      <id>731e1ea31aaf0eb0022d342263e3d4b8c359e55a:reference/memory/out_ptr_t.md</id>
      <updated>2023-01-24T00:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/out_ptr_t.md b/reference/memory/out_ptr_t.md
index 5a2dee0b0..6e0994a0c 100644
--- a/reference/memory/out_ptr_t.md
+++ b/reference/memory/out_ptr_t.md
@@ -17,6 +17,9 @@ namespace std {
 
 C++標準スマートポインタ[`std::shared_ptr`](shared_ptr.md)や[`std::unique_ptr`](unique_ptr.md)を始め、互換インタフェースをもつ任意のスマートポインタ型`Smart`を取り扱える。
 
+プログラマは`out_ptr_t`クラステンプレートの特殊化を定義してもよい。
+このとき1つ以上のプログラム定義型に依存していれば、プライマリテンプレートにおける要件を満たす必要はない。
+
 
 ## テンプレートパラメータ制約
 `Pointer`はCpp17NullablePointer要件を満たすこと
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>