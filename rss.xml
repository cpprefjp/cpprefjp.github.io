<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-09-07T04:09:45.768263</updated>
  <id>b14a8c92-52de-4a17-a82a-e6e8fe02c0dc</id>

  
    <entry>
      <title>contiguous_iterator -- contiguous_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/contiguous_iterator.html"/>
      <id>4d7e68a979437ee27c122bae6bd83cd1d97fc892:reference/iterator/contiguous_iterator.md</id>
      <updated>2020-09-07T13:05:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/contiguous_iterator.md b/reference/iterator/contiguous_iterator.md
index 696e5bc6b..0e30cc556 100644
--- a/reference/iterator/contiguous_iterator.md
+++ b/reference/iterator/contiguous_iterator.md
@@ -8,30 +8,51 @@
 namespace std {
   template&amp;lt;class I&amp;gt;
   concept contiguous_iterator =
-    input_or_output_iterator&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
-    indirectly_readable&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
-    requires { typename ITER_CONCEPT(I); } &amp;amp;&amp;amp;
-    derived_from&amp;lt;ITER_CONCEPT(I), contiguous_iterator_tag&amp;gt;;
+    random_access_iterator&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+    derived_from&amp;lt;ITER_CONCEPT(I), contiguous_iterator_tag&amp;gt; &amp;amp;&amp;amp;
+    is_lvalue_reference_v&amp;lt;iter_reference_t&amp;lt;I&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+    same_as&amp;lt;iter_value_t&amp;lt;I&amp;gt;, remove_cvref_t&amp;lt;iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+    requires(const I&amp;amp; i) {
+      { to_address(i) } -&amp;gt; same_as&amp;lt;add_pointer_t&amp;lt;iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
+    };
 }
 ```
-* input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
-* indirectly_readable[link /reference/iterator/indirectly_readable.md]
-* contiguous_iterator_tag[link /reference/iterator/contiguous_iterator_tag.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 * derived_from[link /reference/concepts/derived_from.md]
+* ITER_CONCEPT[link /reference/iterator/input_iterator.md#iter_concept]
+* contiguous_iterator_tag[link /reference/iterator/iterator_tag.md]
+* is_lvalue_reference_v[link /reference/type_traits/is_lvalue_reference.md]
+* iter_reference_t[link /reference/iterator/iter_reference_t.md]
+* same_as[link /reference/concepts/same_as.md]
+* iter_value_t[link /reference/iterator/iter_value_t.md]
+* remove_cvref_t[link /reference/type_traits/remove_cvref.md]
+* to_address[link /reference/memory/to_address.md]
+* add_pointer_t[link /reference/type_traits/add_pointer_t.md]
 
 ## 概要
 
-`contiguous_iterator`は、イテレータ型`I`が入力イテレータであることを表すコンセプトである。
+`contiguous_iterator`は、イテレータ型`I`が隣接イテレータであることを表すコンセプトである。
 
-`contiguous_iterator`となるイテレータは、`operator*`による読み出しと前置/後置インクリメントによる進行が可能である。
+`contiguous_iterator`となるイテレータは、[ランダムアクセスイテレータ](random_access_iterator.md)であり、参照する要素列がメモリ上で連続していることが保証される。
+
+## モデル
+
+`a, b`を間接参照可能なイテレータ、`c`を間接参照不可能なイテレータとし、`b`は`a`から、`c`は`b`からそれぞれ到達可能であるとする。そのような型`I`のイテレータ`a, b, c`と`iter_reference_t&amp;lt;I&amp;gt;`の示す型`D`について次の条件を満たす場合に限って、型`I`は`contiguous_iterator`のモデルである。
+
+- `to_address(a) == addressof(*a)`
+- `to_address(b) == to_address(a) + D(b - a)`
+- `to_address(c) == to_address(a) + D(c - a)`
 
 ## 例
 ```cpp example
+
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;concepts&amp;gt;
 #include &amp;lt;iterator&amp;gt;
-#include &amp;lt;memory&amp;gt;
 #include &amp;lt;vector&amp;gt;
+#include &amp;lt;forward_list&amp;gt;
+#include &amp;lt;list&amp;gt;
+#include &amp;lt;deque&amp;gt;
 
 template&amp;lt;std::contiguous_iterator I&amp;gt;
 void f(const char* name) {
@@ -43,28 +64,17 @@ void f(const char* name) {
   std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not contiguous_iterator&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 
-
-struct sample_contiguous_iterator {
-  friend auto operator++(sample_contiguous_iterator&amp;amp;) -&amp;gt; sample_contiguous_iterator&amp;amp;;
-  friend auto operator++(sample_contiguous_iterator&amp;amp;, int) -&amp;gt; sample_contiguous_iterator;
-
-  friend auto operator*(const sample_contiguous_iterator&amp;amp;) -&amp;gt; int&amp;amp;;
-
-  using difference_type = int;
-  using value_type = int;
-  using iterator_concept = std::contiguous_iterator_tag;
-};
-
-
 int main() {
   f&amp;lt;int*&amp;gt;(&amp;#34;int*&amp;#34;);
   f&amp;lt;const int*&amp;gt;(&amp;#34;const int*&amp;#34;);
   f&amp;lt;std::vector&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::vector&amp;lt;int&amp;gt;::iterator&amp;#34;);
-  f&amp;lt;std::istream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::istream_iterator&amp;lt;double&amp;gt;&amp;#34;);
-  f&amp;lt;sample_contiguous_iterator&amp;gt;(&amp;#34;sample_contiguous_iterator&amp;#34;);
   
   std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
   f&amp;lt;int* const&amp;gt;(&amp;#34;int* const&amp;#34;);
+  f&amp;lt;std::forward_list&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::forward_list&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;std::list&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::list&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;std::deque&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::deque&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;std::istream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::istream_iterator&amp;lt;double&amp;gt;&amp;#34;);
   f&amp;lt;std::ostream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::ostream_iterator&amp;lt;double&amp;gt;&amp;#34;);
 }
 ```
@@ -75,10 +85,12 @@ int main() {
 int* is contiguous_iterator
 const int* is contiguous_iterator
 std::vector&amp;lt;int&amp;gt;::iterator is contiguous_iterator
-std::istream_iterator&amp;lt;double&amp;gt; is contiguous_iterator
-sample_contiguous_iterator is contiguous_iterator
 
 int* const is not contiguous_iterator
+std::forward_list&amp;lt;int&amp;gt;::iterator is not contiguous_iterator
+std::list&amp;lt;int&amp;gt;::iterator is not contiguous_iterator
+std::deque&amp;lt;int&amp;gt;::iterator is not contiguous_iterator
+std::istream_iterator&amp;lt;double&amp;gt; is not contiguous_iterator
 std::ostream_iterator&amp;lt;double&amp;gt; is not contiguous_iterator
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>forward_iterator -- contiguous_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/forward_iterator.html"/>
      <id>4d7e68a979437ee27c122bae6bd83cd1d97fc892:reference/iterator/forward_iterator.md</id>
      <updated>2020-09-07T13:05:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/forward_iterator.md b/reference/iterator/forward_iterator.md
index 1aed9fe3c..e9d41d3a4 100644
--- a/reference/iterator/forward_iterator.md
+++ b/reference/iterator/forward_iterator.md
@@ -42,7 +42,7 @@ namespace std {
 - `((void)[](X x){++x;}(a), *a)`は`*a`と等しい
     - イテレータをコピーしてから何かをしても、元のイテレータに影響はない
 
-この保証によって、前方向イテレータは一方向マルチパスのアルゴリズでの利用が可能になる。
+この保証によって、前方向イテレータは一方向マルチパス（2回以上の走査）のアルゴリズムでの利用が可能になる。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>output_iterator -- contiguous_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/output_iterator.html"/>
      <id>4d7e68a979437ee27c122bae6bd83cd1d97fc892:reference/iterator/output_iterator.md</id>
      <updated>2020-09-07T13:05:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/output_iterator.md b/reference/iterator/output_iterator.md
index f6bd5c703..168601072 100644
--- a/reference/iterator/output_iterator.md
+++ b/reference/iterator/output_iterator.md
@@ -28,13 +28,13 @@ namespace std {
 
 ``decltype((E))`が型`T`を示す式`E`、間接参照可能な型`I`のオブジェクト`i`について次の条件を満たす場合に限って、型`I, T`は`output_iterator`のモデルである。
 
-- `*i++ = E;`は次の式と同じ効果を持つ
+- `*i++ = E;`は次の式と等価となる
   ```cpp
   *i = E;
   ++i;
   ```
 
-出力イテレータを用いるアルゴリズムは、同じイテレータ範囲を2回以上イテレートしてはならない。そのようなアルゴリズムはシングルパスでなければならない。
+出力イテレータを用いるアルゴリズムは、同じイテレータ範囲を2回以上イテレートしてはならない。そのようなアルゴリズムはシングルパス（一回だけ走査する）でなければならない。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>random_access_iterator -- contiguous_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/random_access_iterator.html"/>
      <id>4d7e68a979437ee27c122bae6bd83cd1d97fc892:reference/iterator/random_access_iterator.md</id>
      <updated>2020-09-07T13:05:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/random_access_iterator.md b/reference/iterator/random_access_iterator.md
index 9c03ca599..79e13dbdc 100644
--- a/reference/iterator/random_access_iterator.md
+++ b/reference/iterator/random_access_iterator.md
@@ -36,7 +36,7 @@ namespace std {
 
 `random_access_iterator`は、イテレータ型`I`がランダムアクセスイテレータであることを表すコンセプトである。
 
-`random_access_iterator`となるイテレータは、[双方向イテレータ](bidirectional_iterator.md)であり、`+= + -= -`による定数時間での進行と、`-`による定数時間での距離の計算が可能である、
+`random_access_iterator`となるイテレータは、[双方向イテレータ](bidirectional_iterator.md)であり、`+= + -= -`による定数時間での進行と、`-`による定数時間での距離の計算が可能である。
 
 ## モデル
 
@@ -91,12 +91,12 @@ struct sample_random_access_iterator {
   friend auto operator-(const sample_random_access_iterator&amp;amp;, int) -&amp;gt; sample_random_access_iterator;
   friend auto operator-=(sample_random_access_iterator&amp;amp;, int) -&amp;gt; sample_random_access_iterator&amp;amp;;
   
-  friend auto operator-(const sample_random_access_iterator&amp;amp;, const sample_random_access_iterator&amp;amp;) -&amp;gt; i;
+  friend auto operator-(const sample_random_access_iterator&amp;amp;, const sample_random_access_iterator&amp;amp;) -&amp;gt; int;
 
   friend auto operator*(const sample_random_access_iterator&amp;amp;) -&amp;gt; int&amp;amp;;
   auto operator[](int) const -&amp;gt; int&amp;amp;;
 
-  friend bool operator&amp;lt;=&amp;gt;(const sample_random_access_iterator&amp;amp;, const sample_random_access_iterator&amp;amp;);
+  friend std::strong_ordering operator&amp;lt;=&amp;gt;(const sample_random_access_iterator&amp;amp;, const sample_random_access_iterator&amp;amp;);
   friend bool operator==(const sample_random_access_iterator&amp;amp;, const sample_random_access_iterator&amp;amp;);
 
   using difference_type = int;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bidirectional_iterator -- random_access_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/bidirectional_iterator.html"/>
      <id>28fa1af23ea0e40893e4991a8e1908736cbdf64f:reference/iterator/bidirectional_iterator.md</id>
      <updated>2020-09-07T12:28:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/bidirectional_iterator.md b/reference/iterator/bidirectional_iterator.md
index 7cd275d24..b280311ff 100644
--- a/reference/iterator/bidirectional_iterator.md
+++ b/reference/iterator/bidirectional_iterator.md
@@ -18,8 +18,8 @@ namespace std {
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
 * derived_from[link /reference/concepts/derived_from.md]
-* ITER_CONCEPT[link /reference/concepts/input_iterator.md#iter_concept]
-* bidirectional_iterator_tag[link /reference/iterator/bidirectional_iterator_tag.md]
+* ITER_CONCEPT[link /reference/iterator/input_iterator.md#iter_concept]
+* bidirectional_iterator_tag[link /reference/iterator/iterator_tag.md]
 * same_as[link /reference/concepts/same_as.md]
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contiguous_iterator -- random_access_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/contiguous_iterator.html"/>
      <id>28fa1af23ea0e40893e4991a8e1908736cbdf64f:reference/iterator/contiguous_iterator.md</id>
      <updated>2020-09-07T12:28:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/contiguous_iterator.md b/reference/iterator/contiguous_iterator.md
new file mode 100644
index 000000000..696e5bc6b
--- /dev/null
+++ b/reference/iterator/contiguous_iterator.md
@@ -0,0 +1,100 @@
+# contiguous_iterator
+* iterator[meta header]
+* std[meta namespace]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class I&amp;gt;
+  concept contiguous_iterator =
+    input_or_output_iterator&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+    indirectly_readable&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+    requires { typename ITER_CONCEPT(I); } &amp;amp;&amp;amp;
+    derived_from&amp;lt;ITER_CONCEPT(I), contiguous_iterator_tag&amp;gt;;
+}
+```
+* input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
+* indirectly_readable[link /reference/iterator/indirectly_readable.md]
+* contiguous_iterator_tag[link /reference/iterator/contiguous_iterator_tag.md]
+* derived_from[link /reference/concepts/derived_from.md]
+
+## 概要
+
+`contiguous_iterator`は、イテレータ型`I`が入力イテレータであることを表すコンセプトである。
+
+`contiguous_iterator`となるイテレータは、`operator*`による読み出しと前置/後置インクリメントによる進行が可能である。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+template&amp;lt;std::contiguous_iterator I&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is contiguous_iterator&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename I&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not contiguous_iterator&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+
+struct sample_contiguous_iterator {
+  friend auto operator++(sample_contiguous_iterator&amp;amp;) -&amp;gt; sample_contiguous_iterator&amp;amp;;
+  friend auto operator++(sample_contiguous_iterator&amp;amp;, int) -&amp;gt; sample_contiguous_iterator;
+
+  friend auto operator*(const sample_contiguous_iterator&amp;amp;) -&amp;gt; int&amp;amp;;
+
+  using difference_type = int;
+  using value_type = int;
+  using iterator_concept = std::contiguous_iterator_tag;
+};
+
+
+int main() {
+  f&amp;lt;int*&amp;gt;(&amp;#34;int*&amp;#34;);
+  f&amp;lt;const int*&amp;gt;(&amp;#34;const int*&amp;#34;);
+  f&amp;lt;std::vector&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::vector&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;std::istream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::istream_iterator&amp;lt;double&amp;gt;&amp;#34;);
+  f&amp;lt;sample_contiguous_iterator&amp;gt;(&amp;#34;sample_contiguous_iterator&amp;#34;);
+  
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  f&amp;lt;int* const&amp;gt;(&amp;#34;int* const&amp;#34;);
+  f&amp;lt;std::ostream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::ostream_iterator&amp;lt;double&amp;gt;&amp;#34;);
+}
+```
+* std::contiguous_iterator[color ff0000]
+
+### 出力
+```
+int* is contiguous_iterator
+const int* is contiguous_iterator
+std::vector&amp;lt;int&amp;gt;::iterator is contiguous_iterator
+std::istream_iterator&amp;lt;double&amp;gt; is contiguous_iterator
+sample_contiguous_iterator is contiguous_iterator
+
+int* const is not contiguous_iterator
+std::ostream_iterator&amp;lt;double&amp;gt; is not contiguous_iterator
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 6
+
+## 関連項目
+
+- [C++20 コンセプト](/lang/cpp20/concepts.md)
+
+## 参照
+
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>forward_iterator -- random_access_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/forward_iterator.html"/>
      <id>28fa1af23ea0e40893e4991a8e1908736cbdf64f:reference/iterator/forward_iterator.md</id>
      <updated>2020-09-07T12:28:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/forward_iterator.md b/reference/iterator/forward_iterator.md
index 0f3f12305..1aed9fe3c 100644
--- a/reference/iterator/forward_iterator.md
+++ b/reference/iterator/forward_iterator.md
@@ -15,8 +15,9 @@ namespace std {
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
+* forward_iterator_tag[link /reference/iterator/iterator_tag.md]
 * derived_from[link /reference/concepts/derived_from.md]
-* ITER_CONCEPT[link /reference/concepts/input_iterator.md#iter_concept]
+* ITER_CONCEPT[link /reference/iterator/input_iterator.md#iter_concept]
 * incrementable[link /reference/iterator/incrementable.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>input_iterator -- random_access_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/input_iterator.html"/>
      <id>28fa1af23ea0e40893e4991a8e1908736cbdf64f:reference/iterator/input_iterator.md</id>
      <updated>2020-09-07T12:28:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/input_iterator.md b/reference/iterator/input_iterator.md
index a7c42b277..afadea4d5 100644
--- a/reference/iterator/input_iterator.md
+++ b/reference/iterator/input_iterator.md
@@ -16,7 +16,7 @@ namespace std {
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * indirectly_readable[link /reference/iterator/indirectly_readable.md]
-* input_iterator_tag[link /reference/iterator/input_iterator_tag.md]
+* input_iterator_tag[link /reference/iterator/iterator_tag.md]
 * derived_from[link /reference/concepts/derived_from.md]
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>random_access_iterator -- random_access_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/random_access_iterator.html"/>
      <id>28fa1af23ea0e40893e4991a8e1908736cbdf64f:reference/iterator/random_access_iterator.md</id>
      <updated>2020-09-07T12:28:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/random_access_iterator.md b/reference/iterator/random_access_iterator.md
new file mode 100644
index 000000000..9c03ca599
--- /dev/null
+++ b/reference/iterator/random_access_iterator.md
@@ -0,0 +1,153 @@
+# random_access_iterator
+* iterator[meta header]
+* std[meta namespace]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class I&amp;gt;
+  concept random_access_iterator =
+    bidirectional_iterator&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+    derived_from&amp;lt;ITER_CONCEPT(I), random_access_iterator_tag&amp;gt; &amp;amp;&amp;amp;
+    totally_ordered&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+    sized_sentinel_for&amp;lt;I, I&amp;gt; &amp;amp;&amp;amp;
+    requires(I i, const I j, const iter_difference_t&amp;lt;I&amp;gt; n) {
+      { i += n } -&amp;gt; same_as&amp;lt;I&amp;amp;&amp;gt;;
+      { j +  n } -&amp;gt; same_as&amp;lt;I&amp;gt;;
+      { n +  j } -&amp;gt; same_as&amp;lt;I&amp;gt;;
+      { i -= n } -&amp;gt; same_as&amp;lt;I&amp;amp;&amp;gt;;
+      { j -  n } -&amp;gt; same_as&amp;lt;I&amp;gt;;
+      {  j[n]  } -&amp;gt; same_as&amp;lt;iter_reference_t&amp;lt;I&amp;gt;&amp;gt;;
+    };
+}
+```
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* derived_from[link /reference/concepts/derived_from.md]
+* ITER_CONCEPT[link /reference/iterator/input_iterator.md#iter_concept]
+* random_access_iterator_tag[link /reference/iterator/iterator_tag.md]
+* totally_ordered[link /reference/concepts/totally_ordered.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* iter_reference_t[link /reference/iterator/iter_reference_t.md]
+* same_as[link /reference/concepts/same_as.md]
+
+## 概要
+
+`random_access_iterator`は、イテレータ型`I`がランダムアクセスイテレータであることを表すコンセプトである。
+
+`random_access_iterator`となるイテレータは、[双方向イテレータ](bidirectional_iterator.md)であり、`+= + -= -`による定数時間での進行と、`-`による定数時間での距離の計算が可能である、
+
+## モデル
+
+`iter_reference_t&amp;lt;I&amp;gt;`の示す型`D`、`D`の値`n`、型`I`の有効なイテレータ`a`と`++a`を`n`回適用したイテレータ`b`について次の条件を満たす場合に限って、型`I`は`random_access_iterator`のモデルである。
+
+- `(a += n)`は`b`と等値（*equal*）
+- `addressof(a += n)`は`addressof(a)`と等値
+    - `+=`は`*this`を返す
+- `(a + n)`は`(a += n)`と等値
+- `D`の2つの正の値`x, y`について`(a + D(x + y))`が有効ならば、`(a + D(x + y))`は`((a + x) + y)`と等値
+    - 結合則
+- `(a + D(0))`は`a`と等値
+- `(a + D(n - 1))`が有効ならば、`(a + n) `は`[](I c){ return ++c; }(a + D(n - 1))`と等値
+- `(b += D(-n))`は`a`と等値
+- `(b -= n)`は`a`と等値
+- `addressof(b -= n)`は`addressof(b)`と等値
+    - `-=`は`*this`を返す
+- `(b - n)`は`(b -= n)`と等値
+- `b`が間接参照可能ならば、`a[n]`は有効であり`*b`と等値
+- `bool(a &amp;lt;= b) == true`
+
+## 例
+```cpp example
+
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;forward_list&amp;gt;
+#include &amp;lt;list&amp;gt;
+
+template&amp;lt;std::random_access_iterator I&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is random_access_iterator&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename I&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not random_access_iterator&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+struct sample_random_access_iterator {
+  friend auto operator++(sample_random_access_iterator&amp;amp;) -&amp;gt; sample_random_access_iterator&amp;amp;;
+  friend auto operator++(sample_random_access_iterator&amp;amp;, int) -&amp;gt; sample_random_access_iterator;
+
+  friend auto operator--(sample_random_access_iterator&amp;amp;) -&amp;gt; sample_random_access_iterator&amp;amp;;
+  friend auto operator--(sample_random_access_iterator&amp;amp;, int) -&amp;gt; sample_random_access_iterator;
+  
+  friend auto operator+(const sample_random_access_iterator&amp;amp;, int) -&amp;gt; sample_random_access_iterator;
+  friend auto operator+(int, const sample_random_access_iterator&amp;amp;) -&amp;gt; sample_random_access_iterator;
+  friend auto operator+=(sample_random_access_iterator&amp;amp;, int) -&amp;gt; sample_random_access_iterator&amp;amp;;
+  friend auto operator-(const sample_random_access_iterator&amp;amp;, int) -&amp;gt; sample_random_access_iterator;
+  friend auto operator-=(sample_random_access_iterator&amp;amp;, int) -&amp;gt; sample_random_access_iterator&amp;amp;;
+  
+  friend auto operator-(const sample_random_access_iterator&amp;amp;, const sample_random_access_iterator&amp;amp;) -&amp;gt; i;
+
+  friend auto operator*(const sample_random_access_iterator&amp;amp;) -&amp;gt; int&amp;amp;;
+  auto operator[](int) const -&amp;gt; int&amp;amp;;
+
+  friend bool operator&amp;lt;=&amp;gt;(const sample_random_access_iterator&amp;amp;, const sample_random_access_iterator&amp;amp;);
+  friend bool operator==(const sample_random_access_iterator&amp;amp;, const sample_random_access_iterator&amp;amp;);
+
+  using difference_type = int;
+  using value_type = int;
+  using iterator_category = std::random_access_iterator_tag;
+};
+
+
+int main() {
+  f&amp;lt;int*&amp;gt;(&amp;#34;int*&amp;#34;);
+  f&amp;lt;const int*&amp;gt;(&amp;#34;const int*&amp;#34;);
+  f&amp;lt;std::vector&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::vector&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;sample_random_access_iterator&amp;gt;(&amp;#34;sample_random_access_iterator&amp;#34;);
+  
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  f&amp;lt;int* const&amp;gt;(&amp;#34;int* const&amp;#34;);
+  f&amp;lt;std::forward_list&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::forward_list&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;std::list&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::list&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;std::istream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::istream_iterator&amp;lt;double&amp;gt;&amp;#34;);
+  f&amp;lt;std::ostream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::ostream_iterator&amp;lt;double&amp;gt;&amp;#34;);
+}
+```
+* std::random_access_iterator[color ff0000]
+
+### 出力
+```
+int* is random_access_iterator
+const int* is random_access_iterator
+std::vector&amp;lt;int&amp;gt;::iterator is random_access_iterator
+sample_random_access_iterator is random_access_iterator
+
+int* const is not random_access_iterator
+std::forward_list&amp;lt;int&amp;gt;::iterator is not random_access_iterator
+std::list&amp;lt;int&amp;gt;::iterator is not random_access_iterator
+std::istream_iterator&amp;lt;double&amp;gt; is not random_access_iterator
+std::ostream_iterator&amp;lt;double&amp;gt; is not random_access_iterator
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 6
+
+## 関連項目
+
+- [C++20 コンセプト](/lang/cpp20/concepts.md)
+
+## 参照
+
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bidirectional_iterator -- bidirectional_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/bidirectional_iterator.html"/>
      <id>ab14d4d6b895c0707ad91d2e21196c35931ce119:reference/iterator/bidirectional_iterator.md</id>
      <updated>2020-09-04T18:12:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/bidirectional_iterator.md b/reference/iterator/bidirectional_iterator.md
new file mode 100644
index 000000000..7cd275d24
--- /dev/null
+++ b/reference/iterator/bidirectional_iterator.md
@@ -0,0 +1,128 @@
+# bidirectional_iterator
+* iterator[meta header]
+* std[meta namespace]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class I&amp;gt;
+  concept bidirectional_iterator =
+    forward_iterator&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+    derived_from&amp;lt;ITER_CONCEPT(I), bidirectional_iterator_tag&amp;gt; &amp;amp;&amp;amp;
+    requires(I i) {
+      { --i } -&amp;gt; same_as&amp;lt;I&amp;amp;&amp;gt;;
+      { i-- } -&amp;gt; same_as&amp;lt;I&amp;gt;;
+    };
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* derived_from[link /reference/concepts/derived_from.md]
+* ITER_CONCEPT[link /reference/concepts/input_iterator.md#iter_concept]
+* bidirectional_iterator_tag[link /reference/iterator/bidirectional_iterator_tag.md]
+* same_as[link /reference/concepts/same_as.md]
+
+## 概要
+
+`bidirectional_iterator`は、イテレータ型`I`が双方向イテレータであることを表すコンセプトである。
+
+`bidirectional_iterator`となるイテレータは、[前方向イテレータ](forward_iterator.md)であり、後方にも進むことのできるイテレータである。
+
+## 要件
+
+ある`bidirectional_iterator`を`r`とすると、`r`は`++q == r`となるようなイテレータ`q`が存在する場合にのみデクリメント（`--`）可能である。そのようなデクリメント可能なイテレータは、`--r`と`r--`（デクリメント演算子）の[定義域](/reference/concepts.md)にある。
+
+## モデル
+
+型`I`の等しい2つのオブジェクト`a, b`について次の条件を満たす場合に限って、型`I`は`bidirectional_iterator`のモデルである。
+
+- `a, b`がデクリメント可能ならば、次の4つの条件を全て満たす
+    - `addressof(--a) == addressof(a)`
+    - `bool(a-- == b)`
+    - `a--, --b`の評価の後でも、`bool(a == b)`は`true`となる
+    - `bool(++(--a) == b)`
+- `a, b`がインクリメント可能ならば、`bool(--(++a) == b)`
+
+## 例
+```cpp example
+
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;forward_list&amp;gt;
+#include &amp;lt;list&amp;gt;
+
+template&amp;lt;std::bidirectional_iterator I&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is bidirectional_iterator&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename I&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not bidirectional_iterator&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+struct sample_bidirectional_iterator {
+  friend auto operator++(sample_bidirectional_iterator&amp;amp;) -&amp;gt; sample_bidirectional_iterator&amp;amp;;
+  friend auto operator++(sample_bidirectional_iterator&amp;amp;, int) -&amp;gt; sample_bidirectional_iterator;
+
+  friend auto operator--(sample_bidirectional_iterator&amp;amp;) -&amp;gt; sample_bidirectional_iterator&amp;amp;;
+  friend auto operator--(sample_bidirectional_iterator&amp;amp;, int) -&amp;gt; sample_bidirectional_iterator;
+
+  friend auto operator*(const sample_bidirectional_iterator&amp;amp;) -&amp;gt; int&amp;amp;;
+
+  friend bool operator==(const sample_bidirectional_iterator&amp;amp;, const sample_bidirectional_iterator&amp;amp;);
+
+  using difference_type = int;
+  using value_type = int;
+  using iterator_concept = std::bidirectional_iterator_tag;
+};
+
+
+int main() {
+  f&amp;lt;int*&amp;gt;(&amp;#34;int*&amp;#34;);
+  f&amp;lt;const int*&amp;gt;(&amp;#34;const int*&amp;#34;);
+  f&amp;lt;std::list&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::list&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;std::vector&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::vector&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;sample_bidirectional_iterator&amp;gt;(&amp;#34;sample_bidirectional_iterator&amp;#34;);
+  
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  f&amp;lt;int* const&amp;gt;(&amp;#34;int* const&amp;#34;);
+  f&amp;lt;std::forward_list&amp;lt;int&amp;gt;::iterator&amp;gt;(&amp;#34;std::forward_list&amp;lt;int&amp;gt;::iterator&amp;#34;);
+  f&amp;lt;std::istream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::istream_iterator&amp;lt;double&amp;gt;&amp;#34;);
+  f&amp;lt;std::ostream_iterator&amp;lt;double&amp;gt;&amp;gt;(&amp;#34;std::ostream_iterator&amp;lt;double&amp;gt;&amp;#34;);
+}
+```
+* std::bidirectional_iterator[color ff0000]
+
+### 出力
+```
+int* is bidirectional_iterator
+const int* is bidirectional_iterator
+std::list&amp;lt;int&amp;gt;::iterator is bidirectional_iterator
+std::vector&amp;lt;int&amp;gt;::iterator is bidirectional_iterator
+sample_bidirectional_iterator is bidirectional_iterator
+
+int* const is not bidirectional_iterator
+std::forward_list&amp;lt;int&amp;gt;::iterator is not bidirectional_iterator
+std::istream_iterator&amp;lt;double&amp;gt; is not bidirectional_iterator
+std::ostream_iterator&amp;lt;double&amp;gt; is not bidirectional_iterator
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 6
+
+## 関連項目
+
+- [C++20 コンセプト](/lang/cpp20/concepts.md)
+
+## 参照
+
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>forward_iterator -- bidirectional_iterator追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/forward_iterator.html"/>
      <id>ab14d4d6b895c0707ad91d2e21196c35931ce119:reference/iterator/forward_iterator.md</id>
      <updated>2020-09-04T18:12:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/forward_iterator.md b/reference/iterator/forward_iterator.md
index 62d9c44b1..0f3f12305 100644
--- a/reference/iterator/forward_iterator.md
+++ b/reference/iterator/forward_iterator.md
@@ -26,7 +26,7 @@ namespace std {
 
 `forward_iterator`となるイテレータは、[入力イテレータ](input_iterator.md)であり、コピーと等値比較が可能になり、マルチパス保証があるイテレータである
 
-## 備考
+## 要件
 
 `forward_iterator`に対する`==`の[定義域](/reference/concepts.md)はそのイテレータが参照する範囲と同じ範囲を参照するイテレータ全体である。ただし、同じイテレータ型の間ではデフォルト構築（値初期化）されたイテレータとの比較が可能であり、そのようなデフォルト構築されたイテレータ同士の等値比較は常に`true`とならなければならない（それらのデフォルト構築されたイテレータは同じ空の範囲の終端を参照しているかのように振る舞う）。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>