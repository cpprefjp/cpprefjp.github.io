<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-12-09T10:19:37.262656</updated>
  <id>89583481-21c3-455d-8d74-da441353a329</id>

  
    <entry>
      <title>swap -- stop_source/swap: fix typo</title>
      <link href="https://cpprefjp.github.io/reference/stop_token/stop_source/swap.html"/>
      <id>9a8dcaa8c1dbd0061eec280999e0f207e170df33:reference/stop_token/stop_source/swap.md</id>
      <updated>2020-12-09T19:14:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stop_token/stop_source/swap.md b/reference/stop_token/stop_source/swap.md
index 00a2b2010..93ee3b766 100644
--- a/reference/stop_token/stop_source/swap.md
+++ b/reference/stop_token/stop_source/swap.md
@@ -6,7 +6,7 @@
 * cpp20[meta cpp]
 
 ```cpp
-void swap(stop_token&amp;amp;) noexcept;
+void swap(stop_source&amp;amp;) noexcept;
 ```
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- hash: メンバ型result_type, argument_typeを削除</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>97b2eeab1cc766c1c0252fd32b96039ab6801c22:reference/functional/hash.md</id>
      <updated>2020-12-09T18:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index 24e22a6c4..09717118b 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -80,8 +80,6 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| `result_type`           | 戻り値の型([`size_t`](/reference/cstddef/size_t.md)) | C++11 |
-| `argument_type`         | 引数の型(キーの型`T`) | C++11 |
 | `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt; 標準ライブラリの`hash`クラスの特殊化がこの型を持つかは未規定。&amp;lt;br/&amp;gt; この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++20 -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/lang/cpp20.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:lang/cpp20.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++20&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20とは、2020年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++2aと呼ばれることがあった。「202a年にリリースされる」という伏せ字として「a」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;クラス&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html&#34;&gt;一貫比較&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;三方比較演算子によって比較演算子の自動生成を行うようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_member_initializers_for_bit_fields.html&#34;&gt;ビットフィールドのメンバ変数初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ビットフィールドメンバ変数のデフォルト値を設定する構文を追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/explicit_bool.html&#34;&gt;関数を条件付きで&lt;code&gt;explicit&lt;/code&gt;にする構文を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;explicit(true)&lt;/code&gt;のように&lt;code&gt;explicit&lt;/code&gt;に真理値パラメータを指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/fixing_const_qualified_pointers_to_members.html&#34;&gt;&lt;code&gt;const&lt;/code&gt;修飾されたメンバポインタの制限を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.*&lt;/code&gt;演算子での左辺値の&lt;code&gt;const&lt;/code&gt;メンバ関数呼び出しを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;デフォルトのコピーコンストラクタと非&lt;code&gt;const&lt;/code&gt;なコンストラクタが衝突する問題を修正&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;特殊化のアクセスチェック&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/language_support_for_empty_objects.html&#34;&gt;空オブジェクトに対する最適化を支援する属性&lt;code&gt;[[no_unique_address]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[no_unique_address]]&lt;/code&gt;属性を導入し、空の型のオブジェクトをほかのオブジェクトと共有する最適化を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_structured_bindings_to_accessible_members.html&#34;&gt;friend指定された関数内から構造化束縛を使用して非公開メンバ変数にアクセスすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛の仕様として公開メンバ変数のみを取り出せるようになっていたが、friend指定された関数からは非公開メンバ変数にもアクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_structured_bindings_customization_point_finding_rules.html&#34;&gt;構造化束縛がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非テンプレートの&lt;code&gt;get()&lt;/code&gt;メンバ関数が見つかった場合は、非メンバ関数の&lt;code&gt;get()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/checking_for_abstract_class_types.md.nolink&#34;&gt;抽象型のチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の宣言段階では、パラメータおよび戻り値型が抽象型かどうかをチェックしないようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md.nolink&#34;&gt;可変長データを扱うクラスの効率的な&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラスの&lt;code&gt;delete&lt;/code&gt;演算子が呼び出される前にデストラクタが呼ばれないようにするオプションを追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/conditionally_trivial_special_member_functions.md.nolink&#34;&gt;条件付きで特殊メンバ関数をトリビアルに定義するように&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;制約によってトリビアルな特殊メンバ関数と非トリビアルな特殊メンバ関数をオーバーロードできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;列挙型&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/using_enum.html&#34;&gt;スコープ付き列挙型のusing宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;using enum EnumType;&lt;/code&gt;もしくは&lt;code&gt;using EnumType::enumerator&lt;/code&gt;とすることで、列挙値のスコープ指定を省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/designated_initialization.html&#34;&gt;指示付き初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波カッコによる集成体初期化でメンバ名を指定して初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/extending_structured_bindings_to_be_more_like_variable_declarations.html&#34;&gt;構造化束縛を拡張して通常の変数宣言のように使用できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;記憶域指定子として&lt;code&gt;static&lt;/code&gt;と&lt;code&gt;thread_local&lt;/code&gt;の指定を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html&#34;&gt;丸カッコの値リストからの集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T x{1, 2, 3};&lt;/code&gt;と同様に&lt;code&gt;T x(1, 2, 3);&lt;/code&gt;でも集成体初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/array_size_deduction_in_new-expressions.md.nolink&#34;&gt;&lt;code&gt;new&lt;/code&gt;式での配列要素数の推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double* p = new double[]{1,2,3};&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md.nolink&#34;&gt;要素数不明の配列への変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;要素数が判明している配列から、要素数が不明の配列への変換を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.md.nolink&#34;&gt;ほとんどの&lt;code&gt;volatile&lt;/code&gt;を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;volatile&lt;/code&gt;の有用な機能のみを残し、効果が疑わしい、または壊れている機能を非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;整数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html&#34;&gt;符号付き整数型が2の補数表現であることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;符号付き整数型のビット表現を2の補数に規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/char8_t.html&#34;&gt;UTF-8エンコーディングされた文字の型として&lt;code&gt;char8_t&lt;/code&gt;を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-8エンコードされた文字かどうかでオーバーロード・特殊化をできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/make_char16t_char32t_string_literals_be_utf16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;の文字・文字列リテラルを、文字コードUTF-16/32に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__STDC_UTF_16__&lt;/code&gt;、&lt;code&gt;__STDC_UTF_32__&lt;/code&gt;の定義に関係なく、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のリテラルをUTF-16/32文字コードに規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nodiscard_should_have_a_reason.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性に理由となる文字列を付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値を無視してはならない理由を関数宣言に持たせ、警告メッセージに役立てる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nodiscard_for_constructors.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;をコンストラクタのオーバーロードごとに付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リソース確保するコンストラクタにのみ&lt;code&gt;[[nodisacrd]]&lt;/code&gt;を付加できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;制御構文&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/range-based_for_statements_with_initializer.html&#34;&gt;初期化式をともなう範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;範囲for文スコープで使用する変数の初期化のための構文を追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.html&#34;&gt;範囲for文がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;メンバ関数のどちらかが見つからなかった場合に非メンバ関数の&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/likely_and_unlikely_attributes.html&#34;&gt;確率が高い分岐と低い分岐を伝える属性 &lt;code&gt;[[likely]]&lt;/code&gt;, &lt;code&gt;[[unlikely]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;条件分岐の最適化ヒントを与える属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/concepts.html&#34;&gt;コンセプト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータに対する制約を行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/function_templates_with_auto_parameters.html&#34;&gt;autoパラメータによる関数テンプレートの簡易定義&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダと同様、関数パラメータをの型を&lt;code&gt;auto&lt;/code&gt;にすることで簡易的に関数テンプレートを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/down_with_typename.html&#34;&gt;型の文脈で&lt;code&gt;typename&lt;/code&gt;の省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型しか現れない文脈では、依存名を解決するための&lt;code&gt;typename&lt;/code&gt;キーワードを省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_types_in_non-type_template_parameters.md.nolink&#34;&gt;非型テンプレートパラメータとしてクラス型を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;に変換可能な非メンバ関数&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;をもつ型を、非型テンプレートパラメータとして使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_aggregates.md.nolink&#34;&gt;集成体クラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートのテンプレート引数推論はコンストラクタ引数から推論されるが、集成体初期化からも推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_alias_templates.md.nolink&#34;&gt;エイリアステンプレートに対するクラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エイリアステンプレートからクラステンプレートのテンプレート引数を推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;評価されない文脈で&lt;code&gt;constexpr&lt;/code&gt;関数が定数式評価されることを規定&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_virtual_function_calls_in_constant_expressions.html&#34;&gt;定数式からの仮想関数の呼び出しを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;仮想関数に&lt;code&gt;constexpr&lt;/code&gt;を付けられない制限を解除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allowing_dynamic_cast_polymorphic_typeid_in_constant_expressions.md.nolink&#34;&gt;定数式での&lt;code&gt;dynamic_cast&lt;/code&gt;、多態的な&lt;code&gt;typeid&lt;/code&gt;を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式での動的多態を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/try-catch_blocks_in_constexpr_functions.md.nolink&#34;&gt;constexpr関数内でのtry-catchブロックを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内での例外の捕捉を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/immediate_functions.md.nolink&#34;&gt;即時関数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;consteval&lt;/code&gt;キーワードを追加し、常に定数式評価されるよう指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/changing_the_active_member_of_a_union_inside_constexpr.md.nolink&#34;&gt;定数式内での共用体のアクティブメンバの変更を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体メンバの書き換えを定数式内で行えるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.md.nolink&#34;&gt;constexprの文脈でのトリビアルなデフォルト初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内でのデフォルト初期化を許可し、未初期化値を読むことのみ禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.md.nolink&#34;&gt;constexpr関数内で未評価のインラインアセンブリを許可することによる組み込み関数のconstexpr有効化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に評価されない場合にconstexpr関数にasm定義を含めることを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/constinit.md.nolink&#34;&gt;コンパイル時初期化を強制する&lt;code&gt;constinit&lt;/code&gt;キーワードを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化のみコンパイル時におわらせたい場合に使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.md.nolink&#34;&gt;可変サイズをもつコンテナの&lt;code&gt;constexpr&lt;/code&gt;化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;記憶域をもつメモリアロケータの存在を考慮することで、可変サイズをもつコンテナをコンパイル時に使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ラムダ式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/familiar_template_syntax_for_generic_lambdas.html&#34;&gt;ジェネリックラムダのテンプレート構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダでテンプレートパラメータを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_lambda_capture_equal_this.html&#34;&gt;ラムダ式のキャプチャとして&lt;code&gt;[=, this]&lt;/code&gt;を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトコピーキャプチャと&lt;code&gt;this&lt;/code&gt;ポインタのコピーキャプチャを両方指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタをキャプチャされなくする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ラムダ式の制約&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;暗黙のラムダキャプチャを簡略化&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_constructible_and_assignable_stateless_lambdas.html&#34;&gt;状態を持たないラムダ式を、デフォルト構築可能、代入可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャしていないラムダ式をデフォルト構築・代入可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html&#34;&gt;評価されない文脈でのラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;評価されない文脈でもラムダ式を書くことができるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_pack_expansion_in_lambda_init_capture.html&#34;&gt;ラムダ式の初期化キャプチャでのパック展開を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[...args = std::move(args)]&lt;/code&gt;のようなキャプチャを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reference_capture_of_structured_bindings.md.nolink&#34;&gt;構造化束縛したビットフィールドの参照キャプチャ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ビットフィールドを含む構造化束縛をした場合にラムダ式で参照キャプチャできない規定を緩和し、ビットフィールドを直接参照キャプチャ、もしくはデフォルト参照キャプチャして使用しなければ適格とする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;名前空間&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nested_inline_mamespaces.md.nolink&#34;&gt;入れ子名前空間定義でのインライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;namespace ns1::inline ns2::ns3 {}&lt;/code&gt;のように、入れ子名前空間を定義する式にインライン名前空間の指定を含められるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;モジュール化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/modules.html&#34;&gt;モジュール&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ヘッダファイル・ソースファイル、インクルードに変わる仕組みとしてモジュールを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/coroutines.html&#34;&gt;コルーチン&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数実行を中断・再開する仕組みとしてコルーチンを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;プリプロセッサ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/va_opt.html&#34;&gt;可変引数が空でない場合のトークン置換&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサの置換で可変引数が空の場合に余計なカンマが付いてしまう問題に対処&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PODを非推奨化&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタをキャプチャされなくする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_uses_of_the_comma_operator_in_subscripting_expressions.md.nolink&#34;&gt;添字演算子内でのカンマ演算子の使用を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ar[i, j]&lt;/code&gt;を非推奨化。&lt;code&gt;ar[(i, j)]&lt;/code&gt;はOK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;throw()&lt;/code&gt;による例外送出しない指定を削除&lt;/td&gt;
&lt;td&gt;代わりに&lt;code&gt;noexcept&lt;/code&gt;を使用すること&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/prohibit_aggregates_with_user-declared_constructors.md.nolink&#34;&gt;ユーザー宣言したコンストラクタを持つクラスの集成体初期化を禁止&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタが&lt;code&gt;delete&lt;/code&gt;宣言されているクラスを、集成体初期化によってコンストラクタ呼び出しを回避して構築できてしまっていた技法を禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/update_the_reference_to_the_unicode_standard.md.nolink&#34;&gt;Unicode標準への参照を更新&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準C++からISO/IEC 10646への参照を更新し、古い固定バージョンへの参照をやめる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reserving_attribute_namespaces_for_future_use.html&#34;&gt;属性の名前空間を予約&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将来の使用のために属性の名前空間を予約&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;バージョン情報ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/version.html&#34;&gt;&amp;lt;version&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。ここでは、実装依存の情報 (バージョンやリリース日付など) が標準ライブラリの実装によって定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;ライブラリに、カレンダーとタイムゾーンの機能を拡張&lt;/li&gt;
&lt;li&gt;任意のシーケンスの部分シーケンスを参照するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/span.html&#34;&gt;&amp;lt;span&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;文字列フォーマットライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format.html&#34;&gt;&amp;lt;format&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;出力ストリームを同期するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/syncstream.html&#34;&gt;&amp;lt;syncstream&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;三方比較ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numbers.html&#34;&gt;&amp;lt;numbers&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。数学定数が定義される&lt;/li&gt;
&lt;li&gt;ビット操作ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit.html&#34;&gt;&amp;lt;bit&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;Strict Aliasing規則に抵触しないビットレベルの再解釈キャストである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_cast.html&#34;&gt;std::bit_cast()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;1ビットだけ立っている値をもっているかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/has_single_bit.html&#34;&gt;std::has_single_bit()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;整数値を2の累乗値に切り上げる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_ceil.html&#34;&gt;std::bit_ceil()&lt;/a&gt;&lt;/code&gt;関数、整数値を2の累乗値に切り下げる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_floor.html&#34;&gt;std::bit_floor()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;値を表現するために必要なビット幅を求める&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_width.html&#34;&gt;std::bit_width()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;循環ビットシフトを行う&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/rotl.html&#34;&gt;std::rotl()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/rotr.html&#34;&gt;std::rotr()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;連続した0もしくは1のビットを数える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countl_zero.html&#34;&gt;std::countl_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countl_one.html&#34;&gt;std::countl_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countr_zero.html&#34;&gt;std::countr_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countr_one.html&#34;&gt;std::countr_one()&lt;/a&gt;&lt;/code&gt;、および立っているビットを数える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/popcount.html&#34;&gt;std::popcount()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;エンディアンを表す列挙型として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/endian.html&#34;&gt;std::endian&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;型制約のための要件ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts.html&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;言語機能であるコルーチンを制御するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/coroutine.html&#34;&gt;&amp;lt;coroutine&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッドの実行を停止させるメカニズムとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stop_token.html&#34;&gt;&amp;lt;stop_token&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加し、停止に対応したスレッドクラスとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread.html&#34;&gt;&amp;lt;thread&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/jthread.html&#34;&gt;std::jthread&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;軽量な同期プリミティブであるセマフォのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/semaphore.html&#34;&gt;&amp;lt;semaphore&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッド調整メカニズムとして、ラッチライブラリの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/latch.html&#34;&gt;&amp;lt;latch&amp;gt;&lt;/a&gt;&lt;/code&gt;、バリアライブラリの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/barrier.html&#34;&gt;&amp;lt;barrier&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータの組ではなく、コンテナや配列、部分的なコンテナなどを扱う範囲ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.md.nolink&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;既存のイテレータの組を扱うアルゴリズムは、&lt;code&gt;std::ranges&lt;/code&gt;名前空間に範囲版アルゴリズムが追加される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ソースコードの位置を取得するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/source_location.html&#34;&gt;&amp;lt;source_location&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;取り決め&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std&lt;/code&gt;名前空間以下の関数テンプレートをユーザーが特殊化することを禁止する (参照 : &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf&#34; target=&#34;_blank&#34;&gt;P0551R3&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;連想コンテナに、要素がコンテナに含まれているかを判定する&lt;code&gt;contains()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;順序付き連想コンテナと同様に、非順序連想コンテナの検索処理で、一時オブジェクトが生成されるコストを抑える拡張を追加。キー等値比較を行う関数オブジェクトとハッシュ計算を行う関数オブジェクトの両方に&lt;code&gt;is_transparent&lt;/code&gt;が定義されていれば、透過的な検索が使用できる。&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;クラスのページを参照&lt;/li&gt;
&lt;li&gt;各コンテナの非メンバ関数として、要素を削除する&lt;code&gt;std::erase()&lt;/code&gt;関数と&lt;code&gt;std::erase_if()&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;のメンバ関数&lt;code&gt;remove()&lt;/code&gt;、&lt;code&gt;remove_if()&lt;/code&gt;、&lt;code&gt;unique()&lt;/code&gt;の戻り値型を、&lt;code&gt;void&lt;/code&gt;から&lt;code&gt;Container::size_type&lt;/code&gt;に変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;クラスの比較演算子、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/fill.html&#34;&gt;fill()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;組み込み配列を&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;に変換する関数として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/to_array.html&#34;&gt;std::to_array()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数としてコンテナの要素数を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ssize.html&#34;&gt;std::ssize()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;、および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/vector/vector.html&#34;&gt;std::vector&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;の多くの関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素位置をシフトする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shift_left.html&#34;&gt;std::shift_left()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shift_right.html&#34;&gt;std::shift_right()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に三方比較による辞書順比較アルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/lexicographical_compare_three_way.html&#34;&gt;std::lexicographical_compare_three_way()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値とポインタの中点を求める関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/midpoint.html&#34;&gt;std::midpoint()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;浮動小数点数を線形補間する関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/lerp.html&#34;&gt;std::lerp()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムをムーブに対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムに&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_insert_iterator.html&#34;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_insert_iterator.html&#34;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/insert_iterator.html&#34;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt;クラスのコンストラクタ、代入演算子、間接参照演算子、インクリメント演算子、および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_inserter.html&#34;&gt;std::back_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_inserter.html&#34;&gt;std::front_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/inserter.html&#34;&gt;std::inserter()&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;constexpr&lt;/code&gt;を追加。これらのクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/ref.html&#34;&gt;std::ref()&lt;/a&gt;&lt;/code&gt;関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/cref.html&#34;&gt;std::cref()&lt;/a&gt;&lt;/code&gt;関数のテンプレートパラメータ&lt;code&gt;T&lt;/code&gt;型に不完全型を指定することを許可&lt;/li&gt;
&lt;li&gt;メンバ関数の部分適用をかんたんにするために、プレースホルダーの指定なく引数を先頭から順に束縛する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;の各操作、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;std::not_fn()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;std::bind()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;std::mem_fn()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;li&gt;コンセプトの導入にともない、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った値をそのまま返す関数オブジェクト&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/identity.html&#34;&gt;std::identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;クラスに、先頭の部分文字列を判定する&lt;code&gt;starts_with()&lt;/code&gt;メンバ関数、末尾の部分文字列を判定する&lt;code&gt;ends_with()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数の、メモリの縮小機能を削除し、伸長のみとする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits.html&#34;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/move.html&#34;&gt;move()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/copy.html&#34;&gt;copy()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/assign.html&#34;&gt;assign()&lt;/a&gt;&lt;/code&gt;静的メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが、値初期化するよう動作変更。これまではC言語との互換性のために未初期化となっていた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの浮動小数点数型に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;アトミッククラスに対するブロッキング同期の機能として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/wait.html&#34;&gt;wait()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html&#34;&gt;notify_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/notify_all.html&#34;&gt;notify_all()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ロックフリーであることが保証されたアトミック整数型の別名として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;atomic_signed_lock_free&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;atomic_unsigned_lock_free&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/memory_order.html&#34;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;の列挙子にスコープをもたせた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスに、&lt;code&gt;bool&lt;/code&gt;値を読み込むメンバ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag/test.html&#34;&gt;test()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;非アトミックなオブジェクトにアトミック操作を適用するためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ベクトル化の実行ポリシーとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unsequenced_policy&lt;/a&gt;&lt;/code&gt;型と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unseq&lt;/a&gt;&lt;/code&gt;タグを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同期ストリームの追加にともなって、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream.html&#34;&gt;&amp;lt;ostream&amp;gt;&lt;/a&gt;&lt;/code&gt;に、同期ストリーム関係の出力マニピュレータを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/istream/basic_istream/op_istream_free.html&#34;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;(basic_istream&amp;amp;, CharT*)&lt;/code&gt;を&lt;code&gt;operator&amp;gt;&amp;gt;(basic_istream&amp;amp;, CharT (&amp;amp;)[N])&lt;/code&gt;に修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream/basic_ostream/op_ostream_free.html&#34;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;wchar_t&lt;/code&gt; (&lt;code&gt;char&lt;/code&gt;版のみ)、&lt;code&gt;char8_t&lt;/code&gt;、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のdelete宣言を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/istream_iterator.html&#34;&gt;std::istream_iterator&lt;/a&gt;&lt;/code&gt;について、要件の書き方を整理し、振る舞いをより明確化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::basic_stringbuf&lt;/code&gt;、&lt;code&gt;std::basic_istringstream&lt;/code&gt;、&lt;code&gt;std::basic_ostringstream&lt;/code&gt;クラスに、アロケータを伝播させるためのインタフェースを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_shared.html&#34;&gt;std::make_shared()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocate_shared.html&#34;&gt;std::allocate_shared()&lt;/a&gt;&lt;/code&gt;を配列に対応&lt;/li&gt;
&lt;li&gt;スマートポインタをデフォルト初期化で構築するヘルパ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_unique_for_overwrite.html&#34;&gt;std::make_unique_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_shared_for_overwrite.html&#34;&gt;std::make_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocate_shared_for_overwrite.html&#34;&gt;std::allocate_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ポインタを生ポインタに変換する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/to_address.html&#34;&gt;std::to_address()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_traits.html&#34;&gt;std::pointer_traits&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_traits/pointer_to.html&#34;&gt;pointer_to()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Nバイトアライメントされたポインタであることをコンパイラに伝える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/assume_aligned.html&#34;&gt;std::assume_aligned()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、uses allocator構築をサポートするユーティリティ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/uses_allocator_construction_args.html&#34;&gt;std::uses_allocator_construction_args()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_obj_using_allocator.html&#34;&gt;std::make_obj_using_allocator()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/uninitialized_construct_using_allocator.html&#34;&gt;std::uninitialized_construct_using_allocator()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator.html&#34;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;に、以下の変更を追加：&lt;ul&gt;
&lt;li&gt;クラステンプレートのデフォルトテンプレート引数を&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;&lt;/code&gt;型とした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt;のバイト列をメモリ確保する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/allocate_bytes.html&#34;&gt;allocate_bytes()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/deallocate_bytes.html&#34;&gt;deallocate_bytes()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリを確保する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/allocate_object.html&#34;&gt;allocate_object()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/deallocate_object.html&#34;&gt;deallocate_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリ確保と構築をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/new_object.html&#34;&gt;new_object()&lt;/a&gt;&lt;/code&gt;、破棄と解放をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/delete_object.html&#34;&gt;delete_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数と符号なし整数の安全な比較関数として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_equal.html&#34;&gt;std::cmp_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_not_equal.html&#34;&gt;std::cmp_not_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less.html&#34;&gt;std::cmp_less()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less_equal.html&#34;&gt;std::cmp_less_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater.html&#34;&gt;std::cmp_greater()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater_equal.html&#34;&gt;std::cmp_greater_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_range.html&#34;&gt;std::in_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/swap.html&#34;&gt;std::swap()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/exchange.html&#34;&gt;std::exchange()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;クラスを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイルシステム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/filesystem/create_directory.html&#34;&gt;std::filesystem::create_directory()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/filesystem/create_directories.html&#34;&gt;std::filesystem::create_directories()&lt;/a&gt;&lt;/code&gt;の仕様が直感的ではなく、すでにディレクトリが存在している場合にエラーとなっていた。C++20ではその状況ではエラーにならないようにする (エラーではなく&lt;code&gt;false&lt;/code&gt;が返る)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、constexpr関数が定数式評価されたかを判定する特殊な関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_constant_evaluated.html&#34;&gt;std::is_constant_evaluated()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、型のCV修飾と参照を除去する型特性クラスとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;std::remove_cvref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った型をそのまま返す&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/type_identity.html&#34;&gt;std::type_identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、例外送出せずに暗黙の型変換が可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_convertible.html&#34;&gt;std::is_nothrow_convertible&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素数が判明している配列型かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_bounded_array.html&#34;&gt;std::is_bounded_array&lt;/a&gt;&lt;/code&gt;、要素数が不明な配列型かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_unbounded_array.html&#34;&gt;std::is_unbounded_array&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、レイアウト互換性、ポインタ相互交換可能性を判定する以下の型特性を追加：&lt;ul&gt;
&lt;li&gt;2つの型にレイアウト互換があるかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_layout_compatible.html&#34;&gt;std::is_layout_compatible&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2つのメンバポインタが互換な共通位置にあるかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_corresponding_member.html&#34;&gt;std::is_corresponding_member()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基底クラスと派生クラスの間でポインタ相互交換可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_base_of.html&#34;&gt;std::is_pointer_interconvertible_base_of&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メンバポインタとクラスの間でポインタ相互交換可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_with_class.html&#34;&gt;is_pointer_interconvertible_with_class()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型を&lt;code&gt;T&amp;amp;&lt;/code&gt;型に展開する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_reference.html&#34;&gt;std::unwrap_reference&lt;/a&gt;&lt;/code&gt;型特性、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;std::decay&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型の展開をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_ref_decay.html&#34;&gt;std::unwrap_ref_decay&lt;/a&gt;&lt;/code&gt;型特性を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一貫比較機能によって比較演算子の定義が容易になったため、不要になった演算子の簡潔定義機能である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/rel_ops.html&#34;&gt;std::rel_ops&lt;/a&gt;&lt;/code&gt;を非推奨化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数が、メモリの縮小をしなくなったため、デフォルト引数&lt;code&gt;0&lt;/code&gt;を非推奨可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが値初期化するようになったため、不要になった以下のアトミックオブジェクトの初期化機能を非推奨化：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_init.html&#34;&gt;std::atomic_init()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_var_init.html&#34;&gt;ATOMIC_VAR_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag_init.html&#34;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;allocator&lt;/a&gt;&lt;/code&gt;の以下のメンバを削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;difference_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rebind&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/address.html&#34;&gt;address()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/allocate.html&#34;&gt;allocate()&lt;/a&gt;&lt;/code&gt;メンバ関数の&lt;code&gt;hint&lt;/code&gt;パラメータ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/max_size.html&#34;&gt;max_size()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/construct.html&#34;&gt;construct()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/destroy.html&#34;&gt;destroy()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、要素型を再束縛するための&lt;code&gt;allocator&amp;lt;void&amp;gt;&lt;/code&gt;特殊化を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、&lt;code&gt;constexpr&lt;/code&gt;で扱える型の分類である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_literal_type.html&#34;&gt;is_literal_type&lt;/a&gt;&lt;/code&gt;型特性を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、一時的なメモリ確保のための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/get_temporary_buffer.html&#34;&gt;std::get_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/return_temporary_buffer.html&#34;&gt;std::return_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/raw_storage_iterator.html&#34;&gt;raw_storage_iterator&lt;/a&gt;&lt;/code&gt;クラスを削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた以下の機能を削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;not1()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;not2()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;unary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;binary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;標準関数オブジェクトの&lt;code&gt;result_type&lt;/code&gt;、&lt;code&gt;argument_type&lt;/code&gt;、&lt;code&gt;first_argument_type&lt;/code&gt;、&lt;code&gt;second_argument_type&lt;/code&gt;型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;shared_ptr&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr/unique.html&#34;&gt;unique()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/invoke_result.html&#34;&gt;invoke_result&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/result_of.html&#34;&gt;result_of&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17での&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exception/uncaught_exceptions.html&#34;&gt;uncaught_exceptions()&lt;/a&gt;&lt;/code&gt;の追加にともない、非推奨化していた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exception/uncaught_exception.html&#34;&gt;uncaught_exception()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていたC互換ライブラリ&lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt;を削除。また、C++ではなにも定義されないC互換ライブラリ&lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2131r0.html&#34; target=&#34;_blank&#34;&gt;P2131R0 Changes between C++17 and C++20 DIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/functional/hash.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index 0ee22d676..24e22a6c4 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -82,7 +82,7 @@ namespace std {
 |------|------|----------------|
 | `result_type`           | 戻り値の型([`size_t`](/reference/cstddef/size_t.md)) | C++11 |
 | `argument_type`         | 引数の型(キーの型`T`) | C++11 |
-| `transparent_key_equal` | 省略可。[`std::equal_to&amp;lt;void&amp;gt;`](equal_to.md)のような、`is_transparent`型を持ち、透過的な比較ができる関数オブジェクト型を指定する。&amp;lt;br/&amp;gt; ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt; 標準ライブラリの`hash`クラスの特殊化がこの型を持つかは未規定。&amp;lt;br/&amp;gt; この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
+| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt; 標準ライブラリの`hash`クラスの特殊化がこの型を持つかは未規定。&amp;lt;br/&amp;gt; この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
 
 
 ## 例
@@ -119,7 +119,7 @@ int main()
 ```
 
 ### 透過的にハッシュ値を計算できる場合 (C++20)
-`transparent_key_equal`が定義される場合、以下のようなコードにおいて、`find()`メンバ関数に文字列リテラルを指定しても、一時的な[`string`](/reference/string/basic_string.md)オブジェクトが作成されず、パフォーマンス向上が期待できる。
+`is_transparent`が定義される場合、以下のようなコードにおいて、`find()`メンバ関数に文字列リテラルを指定しても、一時的な[`string`](/reference/string/basic_string.md)オブジェクトが作成されず、パフォーマンス向上が期待できる。
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -134,7 +134,7 @@ int main()
     {&amp;#34;Carol&amp;#34;, 4}
   };
 
-  // std::hash&amp;lt;std::string&amp;gt;がtransparent_key_equal型を持つ場合、
+  // std::equal_to&amp;lt;std::string&amp;gt;とstd::hash&amp;lt;std::string&amp;gt;がis_transparent型を持つ場合、
   // find()などの検索関数に引数を渡す場合に、std::string一時オブジェクトが作られない
   auto it = um.find(&amp;#34;Alice&amp;#34;);
   if (it != um.end()) {
@@ -165,3 +165,4 @@ found : 3
 - [LWG 2148 - Hashing enums should be supported directly by std::hash](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148)
 - [LWG 2291 - std::hash is vulnerable to collision DoS attack](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2291)
 - [P0919R3 Heterogeneous lookup for unordered containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0919r3.html)
+- [P1690R1 Refinement Proposal for P0919 Heterogeneous lookup for unordered containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1690r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unordered_map -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_map.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map.md b/reference/unordered_map/unordered_map.md
index 4ae65fbf8..ff3163428 100644
--- a/reference/unordered_map/unordered_map.md
+++ b/reference/unordered_map/unordered_map.md
@@ -162,7 +162,7 @@ namespace std {
 | `value_type`           | 要素の型。`std::`[`pair`](/reference/utility/pair.md)`&amp;lt;const Key, T&amp;gt;`。 | C++11 |
 | `mapped_type`          | 値の型。テンプレートパラメータ `T`。 | C++11 |
 | `hasher`               | キーのハッシュ関数の型。テンプレートパラメータ `Hash`。 | C++11 |
-| `key_equal`            | キーが等値か否かを判断するための二項述語の型。&amp;lt;br/&amp;gt; C++11 : テンプレートパラメータ `Pred`。&amp;lt;br/&amp;gt; C++20 : `Hash::transparent_key_equal`が定義されていたらその別名、そうでなければテンプレートパラメータ`Pred`を使用する。`Hash::transparent_key_equal`が定義されている場合、`Hash::transparent_key_equal::is_transparent`が定義されていなければプログラムは不適格となる | C++11 |
+| `key_equal`            | キーが等値か否かを判断するための二項述語の型。テンプレートパラメータ `Pred`。 | C++11 |
 | `allocator_type`       | アロケータの型。テンプレートパラメータ `Allocator`。 | C++11 |
 | `pointer`              | 要素 `value_type`（`= std::`[`pair`](/reference/utility/pair.md)`&amp;lt;const Key, T&amp;gt;`）へのポインタ。スマートポインタも可であるが、通常は `value_type*`。&amp;lt;br/&amp;gt;規格書では、`allocator_type::pointer` となっているが、これは規格書の誤りで、ドラフト [N3376](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf) で既に `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::pointer` に修正されている。&amp;lt;br/&amp;gt;（さもないと、必須である `allocator_type::value_type` のみを定義したユーザ定義のアロケータを使用することができないため） | C++11 |
 | `const_pointer`        | 要素 `value_type`（`= std::`[`pair`](/reference/utility/pair.md)`&amp;lt;const Key, T&amp;gt;`）へのコンストポインタ。スマートポインタも可であるが、通常は `const value_type*`。&amp;lt;br/&amp;gt;規格書では、`allocator_type::const_pointer` となっているが、これは規格書の誤りで、ドラフト [N3376](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf) で既に `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::const_pointer` に修正されている。&amp;lt;br/&amp;gt;（さもないと、必須である `allocator_type::value_type` のみを定義したユーザ定義のアロケータを使用することができないため） | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/contains.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_map/contains.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/contains.md b/reference/unordered_map/unordered_map/contains.md
index 4802fec04..4cc60fa56 100644
--- a/reference/unordered_map/unordered_map/contains.md
+++ b/reference/unordered_map/unordered_map/contains.md
@@ -19,11 +19,11 @@ bool contains(const K&amp;amp; k) const;        // (2)
 - (1) : キー`x`を検索し、合致する要素が含まれるかを判定する
 - (2) : キー`k`を透過的に検索し、合致する要素が含まれるかを判定する
 
-(2)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.contains(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(2)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.contains(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (2) : `Hash::transparent_key_equal`型が定義されていること
+- (2) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/count.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_map/count.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/count.md b/reference/unordered_map/unordered_map/count.md
index 1a0da215a..e22638aa1 100644
--- a/reference/unordered_map/unordered_map/count.md
+++ b/reference/unordered_map/unordered_map/count.md
@@ -18,7 +18,7 @@ size_type count(const K&amp;amp; k) const;                     // (2) C++20
 - (1) : キー`x`を検索し、合致する要素数を取得する
 - (2) : キー`k`を透過的に検索し、合致する要素数を取得する
 
-(2)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.count(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(2)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.count(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
@@ -27,7 +27,7 @@ size_type count(const K&amp;amp; k) const;                     // (2) C++20
 
 
 ## テンプレートパラメータ制約
-- (2) : `Hash::transparent_key_equal`型が定義されていること
+- (2) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/equal_range.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_map/equal_range.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/equal_range.md b/reference/unordered_map/unordered_map/equal_range.md
index 8a630d386..43a2c9b73 100644
--- a/reference/unordered_map/unordered_map/equal_range.md
+++ b/reference/unordered_map/unordered_map/equal_range.md
@@ -30,7 +30,7 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 - (3) : 非`const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 - (4) : `const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 
-(3)、(4)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
@@ -39,7 +39,7 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 
 
 ## テンプレートパラメータ制約
-- (3), (4) : `Hash::transparent_key_equal`型が定義されていること
+- (3), (4) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/find.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_map/find.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/find.md b/reference/unordered_map/unordered_map/find.md
index 21f2f58a8..d8c66af5d 100644
--- a/reference/unordered_map/unordered_map/find.md
+++ b/reference/unordered_map/unordered_map/find.md
@@ -21,7 +21,7 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 - (3) : 非`const`な`*this`オブジェクトに対する透過的な検索
 - (4) : `const`な`*this`オブジェクトに対する透過的な検索
 
-(3)、(4)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`型が定義される場合に有効になる機能であり、例として`unordered_map&amp;lt;string, int&amp;gt; m;`に対して`m.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
@@ -30,7 +30,7 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 
 
 ## テンプレートパラメータ制約
-- (3), (4) : これらのオーバーロードは、`Hash::transparent_key_equal`型が定義される場合にのみ、オーバーロード解決に参加する
+- (3), (4) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unordered_multimap -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_multimap.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap.md b/reference/unordered_map/unordered_multimap.md
index 3fab84b8e..bc30583d1 100644
--- a/reference/unordered_map/unordered_multimap.md
+++ b/reference/unordered_map/unordered_multimap.md
@@ -158,7 +158,7 @@ namespace std {
 | `value_type`           | 要素の型。`std::`[`pair`](/reference/utility/pair.md)`&amp;lt;const Key, T&amp;gt;`。 | C++11 |
 | `mapped_type`          | 値の型。テンプレートパラメータ `T`。 | C++11 |
 | `hasher`               | キーのハッシュ関数の型。テンプレートパラメータ `Hash`。 | C++11 |
-| `key_equal`            | キーが等値か否かを判断するための二項述語の型。&amp;lt;br/&amp;gt; C++11 : テンプレートパラメータ `Pred`。&amp;lt;br/&amp;gt; C++20 : `Hash::transparent_key_equal`が定義されていたらその別名、そうでなければテンプレートパラメータ`Pred`を使用する。`Hash::transparent_key_equal`が定義されている場合、`Hash::transparent_key_equal::is_transparent`が定義されていなければプログラムは不適格となる | C++11 |
+| `key_equal`            | キーが等値か否かを判断するための二項述語の型。テンプレートパラメータ `Pred`。 | C++11 |
 | `allocator_type`       | アロケータの型。テンプレートパラメータ `Allocator`。 | C++11 |
 | `pointer`              | 要素 `value_type`（`= std::`[`pair`](/reference/utility/pair.md)`&amp;lt;const Key, T&amp;gt;`）へのポインタ。スマートポインタも可であるが、通常は `value_type*`。&amp;lt;br/&amp;gt;規格書では、`allocator_type::pointer` となっているが、これは規格書の誤りで、ドラフト [N3376](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf) で既に `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::pointer` に修正されている。&amp;lt;br/&amp;gt;（さもないと、必須である `allocator_type::value_type` のみを定義したユーザ定義のアロケータを使用することができないため） | C++11 |
 | `const_pointer`        | 要素 `value_type`（`= std::`[`pair`](/reference/utility/pair.md)`&amp;lt;const Key, T&amp;gt;`）へのコンストポインタ。スマートポインタも可であるが、通常は `const value_type*`。&amp;lt;br/&amp;gt;規格書では、`allocator_type::const_pointer` となっているが、これは規格書の誤りで、ドラフト [N3376](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf) で既に `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::const_pointer` に修正されている。&amp;lt;br/&amp;gt;（さもないと、必須である `allocator_type::value_type` のみを定義したユーザ定義のアロケータを使用することができないため） | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/contains.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_multimap/contains.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/contains.md b/reference/unordered_map/unordered_multimap/contains.md
index 8cf492dd5..18c531596 100644
--- a/reference/unordered_map/unordered_multimap/contains.md
+++ b/reference/unordered_map/unordered_multimap/contains.md
@@ -18,11 +18,11 @@ bool contains(const K&amp;amp; k) const;        // (2)
 - (1) : キー`x`を検索し、合致する要素が含まれるかを判定する
 - (2) : キー`k`を透過的に検索し、合致する要素が含まれるかを判定する
 
-(2)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.contains(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(2)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.contains(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (2) : `Hash::transparent_key_equal`型が定義されていること
+- (2) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/count.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_multimap/count.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/count.md b/reference/unordered_map/unordered_multimap/count.md
index 90649b163..8e6b3a2be 100644
--- a/reference/unordered_map/unordered_multimap/count.md
+++ b/reference/unordered_map/unordered_multimap/count.md
@@ -18,7 +18,7 @@ size_type count(const K&amp;amp; k) const;        // (2) C++20
 - (1) : キー`x`を検索し、合致する要素数を取得する
 - (2) : キー`k`を透過的に検索し、合致する要素数を取得する
 
-(2)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.count(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(2)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.count(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
@@ -27,7 +27,7 @@ size_type count(const K&amp;amp; k) const;        // (2) C++20
 
 
 ## テンプレートパラメータ制約
-- (2) : `Hash::transparent_key_equal`型が定義されていること
+- (2) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/equal_range.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_multimap/equal_range.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/equal_range.md b/reference/unordered_map/unordered_multimap/equal_range.md
index e3b310d27..ed5e4be65 100644
--- a/reference/unordered_map/unordered_multimap/equal_range.md
+++ b/reference/unordered_map/unordered_multimap/equal_range.md
@@ -30,7 +30,7 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 - (3) : 非`const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 - (4) : `const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 
-(3)、(4)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
@@ -39,7 +39,7 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 
 
 ## テンプレートパラメータ制約
-- (3), (4) : `Hash::transparent_key_equal`型が定義されていること
+- (3), (4) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/find.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_map/unordered_multimap/find.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/find.md b/reference/unordered_map/unordered_multimap/find.md
index e2776b180..98c1c2309 100644
--- a/reference/unordered_map/unordered_multimap/find.md
+++ b/reference/unordered_map/unordered_multimap/find.md
@@ -23,7 +23,7 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 - (3) : 非`const`な`*this`オブジェクトに対する透過的な検索
 - (4) : `const`な`*this`オブジェクトに対する透過的な検索
 
-(3)、(4)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multimap&amp;lt;string, int&amp;gt; m;`に対して`m.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## パラメータ
@@ -32,7 +32,7 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 
 
 ## テンプレートパラメータ制約
-- (3), (4) : `Hash::transparent_key_equal`型が定義されていること
+- (3), (4) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unordered_multiset -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_multiset.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset.md b/reference/unordered_set/unordered_multiset.md
index bfe13c8df..60ba88209 100644
--- a/reference/unordered_set/unordered_multiset.md
+++ b/reference/unordered_set/unordered_multiset.md
@@ -155,7 +155,7 @@ namespace std {
 | `key_type`             | キーの型。テンプレートパラメータ `Key`。 | C++11 |
 | `value_type`           | 要素の型。テンプレートパラメータ `Key`。 | C++11 |
 | `hasher`               | キーのハッシュ関数の型。テンプレートパラメータ `Hash`。 | C++11 |
-| `key_equal`            | キーが等値か否かを判断するための二項述語の型。&amp;lt;br/&amp;gt; C++11 : テンプレートパラメータ `Pred`。&amp;lt;br/&amp;gt; C++20 : `Hash::transparent_key_equal`が定義されていたらその別名、そうでなければテンプレートパラメータ`Pred`を使用する。`Hash::transparent_key_equal`が定義されている場合、`Hash::transparent_key_equal::is_transparent`が定義されていなければプログラムは不適格となる | C++11 |
+| `key_equal`            | キーが等値か否かを判断するための二項述語の型。テンプレートパラメータ `Pred`。 | C++11 |
 | `allocator_type`       | アロケータの型。テンプレートパラメータ `Allocator`。 | C++11 |
 | `pointer`              | 要素 `value_type`（`= Key`） へのポインタ。スマートポインタも可であるが、通常は `value_type*`。&amp;lt;br/&amp;gt;規格書では、`allocator_type::pointer` となっているが、これは規格書の誤りで、ドラフト [N3376](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf) で既に `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::pointer` に修正されている。&amp;lt;br/&amp;gt;（さもないと、必須である `allocator_type::value_type` のみを定義したユーザ定義のアロケータを使用することができないため） | C++11 |
 | `const_pointer`        | 要素 `value_type`（`= Key`） へのコンストポインタ。スマートポインタも可であるが、通常は `const value_type*`。&amp;lt;br/&amp;gt;規格書では、`allocator_type::const_pointer` となっているが、これは規格書の誤りで、ドラフト [N3376](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf) で既に `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::const_pointer` に修正されている。&amp;lt;br/&amp;gt;（さもないと、必須である `allocator_type::value_type` のみを定義したユーザ定義のアロケータを使用することができないため） | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/contains.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_multiset/contains.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/contains.md b/reference/unordered_set/unordered_multiset/contains.md
index 8e3ff9cda..1c7689611 100644
--- a/reference/unordered_set/unordered_multiset/contains.md
+++ b/reference/unordered_set/unordered_multiset/contains.md
@@ -18,11 +18,13 @@ bool contains(const K&amp;amp; k) const;        // (2)
 - (1) : キー`x`を検索し、合致する要素が含まれるかを判定する
 - (2) : キー`k`を透過的に検索し、合致する要素が含まれるかを判定する
 
-(2)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.contains(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(2)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.contains(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+
+
 
 
 ## テンプレートパラメータ制約
-- (2) : `Hash::transparent_key_equal`型が定義されていること
+- (2) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/count.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_multiset/count.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/count.md b/reference/unordered_set/unordered_multiset/count.md
index a2c6500b1..fa8bd48cb 100644
--- a/reference/unordered_set/unordered_multiset/count.md
+++ b/reference/unordered_set/unordered_multiset/count.md
@@ -18,11 +18,11 @@ size_type count(const K&amp;amp; k) const;        // (2) C++20
 - (1) : キー`x`を検索し、合致する要素数を取得する
 - (2) : キー`k`を透過的に検索し、合致する要素数を取得する
 
-(2)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.count(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(2)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.count(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (2) : `Hash::transparent_key_equal`型が定義されていること
+- (2) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/equal_range.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_multiset/equal_range.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/equal_range.md b/reference/unordered_set/unordered_multiset/equal_range.md
index 55da174a0..0f605f7eb 100644
--- a/reference/unordered_set/unordered_multiset/equal_range.md
+++ b/reference/unordered_set/unordered_multiset/equal_range.md
@@ -30,11 +30,11 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 - (3) : 非`const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 - (4) : `const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 
-(3)、(4)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (3), (4) : `Hash::transparent_key_equal`型が定義されていること
+- (3), (4) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/find.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_multiset/find.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/find.md b/reference/unordered_set/unordered_multiset/find.md
index 6eee43d35..e6aa9a0f4 100644
--- a/reference/unordered_set/unordered_multiset/find.md
+++ b/reference/unordered_set/unordered_multiset/find.md
@@ -23,11 +23,11 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 - (3) : 非`const`な`*this`オブジェクトに対する透過的な検索
 - (4) : `const`な`*this`オブジェクトに対する透過的な検索
 
-(3)、(4)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_multiset&amp;lt;string&amp;gt; s;`に対して`s.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (3), (4) : `Hash::transparent_key_equal`型が定義されていること
+- (3), (4) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unordered_set -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_set.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set.md b/reference/unordered_set/unordered_set.md
index 049cf934a..b5913aff7 100644
--- a/reference/unordered_set/unordered_set.md
+++ b/reference/unordered_set/unordered_set.md
@@ -153,7 +153,7 @@ namespace std {
 | `key_type`             | キーの型。テンプレートパラメータ `Key`。 | C++11 |
 | `value_type`           | 要素の型。テンプレートパラメータ `Key`。 | C++11 |
 | `hasher`               | キーのハッシュ関数の型。テンプレートパラメータ `Hash`。 | C++11 |
-| `key_equal`            | キーが等値か否かを判断するための二項述語の型。&amp;lt;br/&amp;gt; C++11 : テンプレートパラメータ `Pred`。&amp;lt;br/&amp;gt; C++20 : `Hash::transparent_key_equal`が定義されていたらその別名、そうでなければテンプレートパラメータ`Pred`を使用する。`Hash::transparent_key_equal`が定義されている場合、`Hash::transparent_key_equal::is_transparent`が定義されていなければプログラムは不適格となる | C++11 |
+| `key_equal`            | キーが等値か否かを判断するための二項述語の型。C++11 : テンプレートパラメータ `Pred`。 | C++11 |
 | `allocator_type`       | アロケータの型。テンプレートパラメータ `Allocator`。 | C++11 |
 | `pointer`              | 要素 `value_type`（`= Key`） へのポインタ。スマートポインタも可であるが、通常は `value_type*`。&amp;lt;br/&amp;gt;規格書では、`allocator_type::pointer` となっているが、これは規格書の誤りで、ドラフト [N3376](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf) で既に `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::pointer` に修正されている。&amp;lt;br/&amp;gt;（さもないと、必須である `allocator_type::value_type` のみを定義したユーザ定義のアロケータを使用することができないため） | C++11 |
 | `const_pointer`        | 要素 `value_type`（`= Key`） へのコンストポインタ。スマートポインタも可であるが、通常は `const value_type*`。&amp;lt;br/&amp;gt;規格書では、`allocator_type::const_pointer` となっているが、これは規格書の誤りで、ドラフト [N3376](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf) で既に `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::const_pointer` に修正されている。&amp;lt;br/&amp;gt;（さもないと、必須である `allocator_type::value_type` のみを定義したユーザ定義のアロケータを使用することができないため） | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/contains.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_set/contains.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/contains.md b/reference/unordered_set/unordered_set/contains.md
index f588f375a..d79dc3f4a 100644
--- a/reference/unordered_set/unordered_set/contains.md
+++ b/reference/unordered_set/unordered_set/contains.md
@@ -18,11 +18,11 @@ bool contains(const K&amp;amp; k) const;        // (2)
 - (1) : キー`x`を検索し、合致する要素が含まれるかを判定する
 - (2) : キー`k`を透過的に検索し、合致する要素が含まれるかを判定する
 
-(2)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.contains(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(2)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.contains(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (2) : `Hash::transparent_key_equal`型が定義されていること
+- (2) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/count.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_set/count.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/count.md b/reference/unordered_set/unordered_set/count.md
index d6563b196..7109aeedc 100644
--- a/reference/unordered_set/unordered_set/count.md
+++ b/reference/unordered_set/unordered_set/count.md
@@ -18,11 +18,11 @@ size_type count(const K&amp;amp; k) const;        // (2) C++20
 - (1) : キー`x`を検索し、合致する要素数を取得する
 - (2) : キー`k`を透過的に検索し、合致する要素数を取得する
 
-(2)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.count(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(2)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.count(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (2) : `Hash::transparent_key_equal`型が定義されていること
+- (2) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/equal_range.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_set/equal_range.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/equal_range.md b/reference/unordered_set/unordered_set/equal_range.md
index a85873199..910b173dc 100644
--- a/reference/unordered_set/unordered_set/equal_range.md
+++ b/reference/unordered_set/unordered_set/equal_range.md
@@ -30,11 +30,11 @@ pair&amp;lt;const_iterator, const_iterator&amp;gt;
 - (3) : 非`const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 - (4) : `const`な`this`に対してキー`k`を透過的に検索し、合致する全ての要素を含む範囲を取得する
 
-(3)、(4)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.equal_range(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (3), (4) : `Hash::transparent_key_equal`型が定義されていること
+- (3), (4) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- P1690R1に対応 #770</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/find.html"/>
      <id>7338e60d2c288f1a061b10a3bd6b53352381c0d5:reference/unordered_set/unordered_set/find.md</id>
      <updated>2020-12-09T18:32:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/find.md b/reference/unordered_set/unordered_set/find.md
index 58cd4967a..33da83733 100644
--- a/reference/unordered_set/unordered_set/find.md
+++ b/reference/unordered_set/unordered_set/find.md
@@ -21,11 +21,11 @@ template &amp;lt;class K&amp;gt; const_iterator find(const K&amp;amp; k) const;  // (4) C++20
 - (3) : 非`const`な`*this`オブジェクトに対する透過的な検索
 - (4) : `const`な`*this`オブジェクトに対する透過的な検索
 
-(3)、(4)の透過的な検索は、`Hash::transparent_key_equal`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
+(3)、(4)の透過的な検索は、`Pred::is_transparent`および`Hash::is_transparent`が定義される場合に有効になる機能であり、例として`unordered_set&amp;lt;string&amp;gt; s;`に対して`s.find(&amp;#34;key&amp;#34;);`のように`string`型のキーを持つ連想コンテナの検索インタフェースに文字列リテラルを渡した際、`string`の一時オブジェクトが作られないようにできる。詳細は[`std::hash`](/reference/functional/hash.md)クラスのページを参照。
 
 
 ## テンプレートパラメータ制約
-- (3), (4) : `Hash::transparent_key_equal`型が定義されていること
+- (3), (4) : `Pred::is_transparent`型および`Hash::is_transparent`型が定義されていること
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>[[nodiscard]]属性に理由となる文字列を付加できるようにする -- C++20 nodiscard(reason) : 関連項目を追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/nodiscard_should_have_a_reason.html"/>
      <id>55b12b824e661bbd2bbe8741f9e4f28dcb481256:lang/cpp20/nodiscard_should_have_a_reason.md</id>
      <updated>2020-12-09T17:19:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/nodiscard_should_have_a_reason.md b/lang/cpp20/nodiscard_should_have_a_reason.md
index 4769b0ab2..b75f36f97 100644
--- a/lang/cpp20/nodiscard_should_have_a_reason.md
+++ b/lang/cpp20/nodiscard_should_have_a_reason.md
@@ -86,6 +86,7 @@ prog.cc:26:8: note: declared here
 
 ## 関連項目
 - [C++17 `[[nodiscard]]`属性](/lang/cpp17/nodiscard.md)
+- [C++20 `[[nodiscard]]`をコンストラクタのオーバーロードごとに付加できるようにする](nodiscard_for_constructors.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>[[nodiscard]]属性に理由となる文字列を付加できるようにする -- C++20 nodiscard(reason) : コード修飾が間違っていたのを修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/nodiscard_should_have_a_reason.html"/>
      <id>6b7a3734428050b4779c21f63ccb019e56b26869:lang/cpp20/nodiscard_should_have_a_reason.md</id>
      <updated>2020-12-09T17:17:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/nodiscard_should_have_a_reason.md b/lang/cpp20/nodiscard_should_have_a_reason.md
index aad05b2ec..4769b0ab2 100644
--- a/lang/cpp20/nodiscard_should_have_a_reason.md
+++ b/lang/cpp20/nodiscard_should_have_a_reason.md
@@ -64,7 +64,7 @@ int main() {
 * indices.clear()[link /reference/vector/vector/clear.md]
 * indices.empty()[link /reference/vector/vector/empty.md]
 * ptr.release()[link /reference/memory/unique_ptr/release.md]
-* ptr.reset()[link /reference/memory/unique_ptr/reset.md]
+* ptr.reset[link /reference/memory/unique_ptr/reset.md]
 
 ### 出力例
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>