<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-02-19T14:38:33.562249</updated>
  <id>0c4381c2-5d4d-4826-9bad-69a72a2093f4</id>

  
    <entry>
      <title>allocator -- Merge pull request #1251 from cpprefjp/change-description-about-deprecation-of-allocator</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator.html"/>
      <id>580255077ea8e5a432a5eb35d89b7d04ca5f229c:reference/memory/allocator.md</id>
      <updated>2024-02-19T21:43:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator.md b/reference/memory/allocator.md
index b13fc7f28..2c78db321 100644
--- a/reference/memory/allocator.md
+++ b/reference/memory/allocator.md
@@ -75,9 +75,17 @@ C++11から：
 
 
 ## 非推奨・削除の詳細
-C++17から`void`の特殊化版が非推奨となり、C++20で削除された。代わりに[`std::allocator_traits`](allocator_traits.md)クラスの`rebind`機能を使用すること。
+- `address`/`max_size`/`construct`/`destroy`/`pointer`/`const_pointer`/`reference`/`const_reference`/`rebind&amp;lt;U&amp;gt;`メンバがC++17から非推奨となり、C++20で削除された。
+    - これらは特殊なアロケータの実装でない限り共通に定義できるものであるため、アロケータの中間インタフェースである[`std::allocator_traits`](/reference/memory/allocator_traits.md)クラスに、共通のデフォルト実装を定義することとなった。
+    - 以後は[`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;T&amp;gt;&amp;gt;`クラスの各機能を代替として使用すること。
 
-メンバ型の`size_type`と`difference_type`は、C++17で非推奨となったがC++20で非推奨が取り消された。
+- C++17から`void`の特殊化版が非推奨となり、C++20で削除された。
+    - 従来`void`の特殊化版は`allocate`/`deallocate`メンバ関数が存在せず、実際に確保するオブジェクトの型(`R`とする)を隠蔽しつつメモリアロケータとしては`std::allocator`を使うことを表明するためにのみ用いられた。
+      この際`typename std::allocator&amp;lt;void&amp;gt;::template rebind&amp;lt;R&amp;gt;::other`型から実際に確保するオブジェクト型の`std::allocator&amp;lt;R&amp;gt;`を再束縛していた。
+    - この非推奨・削除は`std::allocator&amp;lt;void&amp;gt;`もプライマリテンプレートからインスタンス化されるようになったことを意味し、C++20以降も`std::allocator&amp;lt;void&amp;gt;`の使用自体は問題なく可能であることに注意。
+        - なお、プライマリテンプレートからインスタンス化されるようになっても`allocate`/`deallocate`メンバは内部で`sizeof(void)`を要求するため引き続き使用不可能であり、`std::allocator&amp;lt;void&amp;gt;`の使用用途としては従来と同じく再束縛を目的とすることになる(上述のように[`std::allocator_traits`](allocator_traits.md)の代替機能を用いて`typename` [`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;void&amp;gt;&amp;gt;::template rebind_alloc&amp;lt;R&amp;gt;`のようにする)。
+
+- メンバ型の`size_type`と`difference_type`は、C++17で非推奨となったがC++20で非推奨が取り消された。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator -- itemize</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator.html"/>
      <id>1d65e5e89f7bbbe8d45288ede2c6d7e7b059f53d:reference/memory/allocator.md</id>
      <updated>2024-02-19T21:18:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator.md b/reference/memory/allocator.md
index 81a64b3e5..2c78db321 100644
--- a/reference/memory/allocator.md
+++ b/reference/memory/allocator.md
@@ -75,16 +75,17 @@ C++11から：
 
 
 ## 非推奨・削除の詳細
-`address`/`max_size`/`construct`/`destroy`/`pointer`/`const_pointer`/`reference`/`const_reference`/`rebind&amp;lt;U&amp;gt;`メンバがC++17から非推奨となり、C++20で削除された。
-これらは特殊なアロケータの実装でない限り共通に定義できるものであるため、アロケータの中間インタフェースである[`std::allocator_traits`](/reference/memory/allocator_traits.md)クラスに、共通のデフォルト実装を定義することとなった。
-以後は[`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;T&amp;gt;&amp;gt;`クラスの各機能を代替として使用すること。
+- `address`/`max_size`/`construct`/`destroy`/`pointer`/`const_pointer`/`reference`/`const_reference`/`rebind&amp;lt;U&amp;gt;`メンバがC++17から非推奨となり、C++20で削除された。
+    - これらは特殊なアロケータの実装でない限り共通に定義できるものであるため、アロケータの中間インタフェースである[`std::allocator_traits`](/reference/memory/allocator_traits.md)クラスに、共通のデフォルト実装を定義することとなった。
+    - 以後は[`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;T&amp;gt;&amp;gt;`クラスの各機能を代替として使用すること。
 
-従来`void`の特殊化版は`allocate`/`deallocate`メンバ関数が存在せず、実際に確保するオブジェクトの型(`R`とする)を隠蔽しつつメモリアロケータとしては`std::allocator`を使うことを表明するためにのみ用いられた。
-この際`typename std::allocator&amp;lt;void&amp;gt;::template rebind&amp;lt;R&amp;gt;::other`型から実際に確保するオブジェクト型の`std::allocator&amp;lt;R&amp;gt;`を再束縛していた。
-C++17から`void`の特殊化版が非推奨となり、C++20で削除されたが、これは`std::allocator&amp;lt;void&amp;gt;`もプライマリテンプレートからインスタンス化されるようになったことを意味し、C++20以降も`std::allocator&amp;lt;void&amp;gt;`の使用自体は問題なく可能であることに注意。
-なお、`allocate`/`deallocate`メンバは内部で`sizeof(void)`を要求するため引き続き使用不可能であり、`std::allocator&amp;lt;void&amp;gt;`の使用用途としては従来と同じく再束縛を目的とすることになる(上述のように[`std::allocator_traits`](allocator_traits.md)の代替機能を用いて`typename` [`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;void&amp;gt;&amp;gt;::template rebind_alloc&amp;lt;R&amp;gt;`のようにする)。
+- C++17から`void`の特殊化版が非推奨となり、C++20で削除された。
+    - 従来`void`の特殊化版は`allocate`/`deallocate`メンバ関数が存在せず、実際に確保するオブジェクトの型(`R`とする)を隠蔽しつつメモリアロケータとしては`std::allocator`を使うことを表明するためにのみ用いられた。
+      この際`typename std::allocator&amp;lt;void&amp;gt;::template rebind&amp;lt;R&amp;gt;::other`型から実際に確保するオブジェクト型の`std::allocator&amp;lt;R&amp;gt;`を再束縛していた。
+    - この非推奨・削除は`std::allocator&amp;lt;void&amp;gt;`もプライマリテンプレートからインスタンス化されるようになったことを意味し、C++20以降も`std::allocator&amp;lt;void&amp;gt;`の使用自体は問題なく可能であることに注意。
+        - なお、プライマリテンプレートからインスタンス化されるようになっても`allocate`/`deallocate`メンバは内部で`sizeof(void)`を要求するため引き続き使用不可能であり、`std::allocator&amp;lt;void&amp;gt;`の使用用途としては従来と同じく再束縛を目的とすることになる(上述のように[`std::allocator_traits`](allocator_traits.md)の代替機能を用いて`typename` [`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;void&amp;gt;&amp;gt;::template rebind_alloc&amp;lt;R&amp;gt;`のようにする)。
 
-メンバ型の`size_type`と`difference_type`は、C++17で非推奨となったがC++20で非推奨が取り消された。
+- メンバ型の`size_type`と`difference_type`は、C++17で非推奨となったがC++20で非推奨が取り消された。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator -- change description about deprecation of std::allocator</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator.html"/>
      <id>5dd1e3f12ed326f1f9800013d804ab21fd09ad2e:reference/memory/allocator.md</id>
      <updated>2024-02-19T20:48:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator.md b/reference/memory/allocator.md
index b13fc7f28..81a64b3e5 100644
--- a/reference/memory/allocator.md
+++ b/reference/memory/allocator.md
@@ -75,7 +75,14 @@ C++11から：
 
 
 ## 非推奨・削除の詳細
-C++17から`void`の特殊化版が非推奨となり、C++20で削除された。代わりに[`std::allocator_traits`](allocator_traits.md)クラスの`rebind`機能を使用すること。
+`address`/`max_size`/`construct`/`destroy`/`pointer`/`const_pointer`/`reference`/`const_reference`/`rebind&amp;lt;U&amp;gt;`メンバがC++17から非推奨となり、C++20で削除された。
+これらは特殊なアロケータの実装でない限り共通に定義できるものであるため、アロケータの中間インタフェースである[`std::allocator_traits`](/reference/memory/allocator_traits.md)クラスに、共通のデフォルト実装を定義することとなった。
+以後は[`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;T&amp;gt;&amp;gt;`クラスの各機能を代替として使用すること。
+
+従来`void`の特殊化版は`allocate`/`deallocate`メンバ関数が存在せず、実際に確保するオブジェクトの型(`R`とする)を隠蔽しつつメモリアロケータとしては`std::allocator`を使うことを表明するためにのみ用いられた。
+この際`typename std::allocator&amp;lt;void&amp;gt;::template rebind&amp;lt;R&amp;gt;::other`型から実際に確保するオブジェクト型の`std::allocator&amp;lt;R&amp;gt;`を再束縛していた。
+C++17から`void`の特殊化版が非推奨となり、C++20で削除されたが、これは`std::allocator&amp;lt;void&amp;gt;`もプライマリテンプレートからインスタンス化されるようになったことを意味し、C++20以降も`std::allocator&amp;lt;void&amp;gt;`の使用自体は問題なく可能であることに注意。
+なお、`allocate`/`deallocate`メンバは内部で`sizeof(void)`を要求するため引き続き使用不可能であり、`std::allocator&amp;lt;void&amp;gt;`の使用用途としては従来と同じく再束縛を目的とすることになる(上述のように[`std::allocator_traits`](allocator_traits.md)の代替機能を用いて`typename` [`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;void&amp;gt;&amp;gt;::template rebind_alloc&amp;lt;R&amp;gt;`のようにする)。
 
 メンバ型の`size_type`と`difference_type`は、C++17で非推奨となったがC++20で非推奨が取り消された。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>外部ライブラリ -- MPIRへの言及を削除</title>
      <link href="https://cpprefjp.github.io/third_party_library.html"/>
      <id>227e7c3a7e1169e4dd753381aa5f6238b10e3ec0:third_party_library.md</id>
      <updated>2024-02-19T19:10:19+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;外部ライブラリ&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;C++での開発に使用できる有用なライブラリを以下に例示する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/&#34; target=&#34;_blank&#34;&gt;Boost C++ Libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の準標準と呼ばれているライブラリ。C++標準化委員会のメンバも多く関わっており、Boostに含まれるライブラリの中から次期標準ライブラリとして採用されたものも多数ある。Intel(Boost.Polygon), Adobe(Boost.GIL)も開発に関わっている。スレッド、ネットワーク、ファイルシステム、構文解析器、正規表現、グラフ、線形代数、分散処理、区間計算、計算幾何、多倍長整数など、現在ではだいたい揃ってる。&lt;br /&gt;
ライセンス：Boost Software License 1.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://opencv.org/&#34; target=&#34;_blank&#34;&gt;OpenCV&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;クロスプラットフォームな画像処理、画像認識のためのC++の高水準なクラスライブラリが提供されている。Boostとも連携しやすい。最近ではCUDAなどにも対応している。&lt;a href=&#34;http://opencv.jp/&#34; target=&#34;_blank&#34;&gt;日本語版マニュアル&lt;/a&gt;はバージョン2.3相当まで。&lt;br /&gt;
ライセンス：Apache 2 License（バージョン4.4までは 三条項BSD License）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.qt.io/&#34; target=&#34;_blank&#34;&gt;Qt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;クロスプラットフォームなGUIライブラリ。最近ではStackOverflowでも「C++でGUIライブラリと言えば？」と質問が上がると9割は「Qt」という答えが返ってくる。&lt;br /&gt;
ライセンス：LGPL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://glm.g-truc.net/&#34; target=&#34;_blank&#34;&gt;GLM(OpenGL Mathematics)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3Dグラフィクスのためのヘッダオンリーライブラリ。OpenGLの生のAPIを使うよりこちらの方が扱いやすい。&lt;br /&gt;
ライセンス：MIT License&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mongodb.com/&#34; target=&#34;_blank&#34;&gt;MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;データベースライブラリ。&lt;br /&gt;
ライセンス：Creative Commons, CC BY-NC-SA 3.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/msgpack/msgpack-c&#34; target=&#34;_blank&#34;&gt;MessagePack implementation for C and C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通信などで使用できるデータの圧縮形式、シリアライズ／デシリアライズ、通信のライブラリ。&lt;br /&gt;
ライセンス：Boost Software License, Version 1.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/herumi/xbyak/blob/master/readme.txt&#34; target=&#34;_blank&#34;&gt;Xbyak&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;x86(IA32), x64(AMD64, x86-64)のマシン語命令を実行時に生成するC++のクラスライブラリ。&lt;br /&gt;
ライセンス：修正BSDライセンス&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/googletest&#34; target=&#34;_blank&#34;&gt;Google Test&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++コードの自動テストを行うフレームワーク。&lt;br /&gt;
ライセンス：BSD Version 2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fmtlib/fmt&#34; target=&#34;_blank&#34;&gt;fmtlib&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文字列フォーマットのライブラリ。&lt;br /&gt;
ライセンス：BSD&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>