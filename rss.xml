<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-06-03T08:38:43.044883</updated>
  <id>dddbda7f-ea04-4a39-bc8b-8c77f75634f3</id>

  
    <entry>
      <title>右辺値参照・ムーブセマンティクス -- rvalue_ref_and_move_semantics: 右辺値参照の説明改善</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html"/>
      <id>dd053e4719c9fe3ccaf4ce12d566ce802a8bd4bb:lang/cpp11/rvalue_ref_and_move_semantics.md</id>
      <updated>2021-06-03T17:28:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/rvalue_ref_and_move_semantics.md b/lang/cpp11/rvalue_ref_and_move_semantics.md
index 13a1d44c8..dfc5bfe93 100644
--- a/lang/cpp11/rvalue_ref_and_move_semantics.md
+++ b/lang/cpp11/rvalue_ref_and_move_semantics.md
@@ -34,10 +34,11 @@ int main()
 
 ### 右辺値参照
 
-右辺値参照は、右辺値を束縛する参照である。  
-C++11からは、`&amp;amp;` で宣言される参照型を左辺値参照と呼ぶのに対して、`&amp;amp;&amp;amp;` で宣言される参照型を右辺値参照と呼ぶ。  
-C++03までは、右辺値参照と左辺値参照を区別せず、右辺値はconst左辺値参照 (`const&amp;amp;`) に束縛するよう扱われていた。  
-そのため、右辺値のみに対して特別な処理を記述することができなかった。  
+右辺値参照は、右辺値のみを束縛する参照である。  
+C++11からは、型`T`に対して `T&amp;amp;` で宣言される参照型を左辺値参照と呼ぶのに対して、`T&amp;amp;&amp;amp;` で宣言される参照型を右辺値参照と呼ぶ。
+
+C++03までは、右辺値のみを扱う右辺値参照は存在せず、右辺値はconst左辺値参照 `const T&amp;amp;` に束縛するよう扱われていた。  
+このconst左辺値参照では左辺値も束縛できるため、左辺値／右辺値の区別情報が失われてしまい、右辺値のみに対して特別な処理を記述することができなかった。  
 
 ```cpp
 std::vector&amp;lt;int&amp;gt; v, vv;
@@ -45,14 +46,14 @@ v = vv;                  // 代入式1
 v = std::vector&amp;lt;int&amp;gt;(100, 0); // 代入式2
 ```
 
-上記コードはC++03では、代入式1,2とも右辺の型は `vector&amp;lt;int&amp;gt; const&amp;amp;` になる。  
+上記コードはC++03では、代入式1,2ともに右辺は `vector&amp;lt;int&amp;gt; const&amp;amp;` 型に束縛される。  
 代入処理の中では、右辺の値をコピーし、左辺の値と置き換えられる。  
 しかし代入式2の右辺は一時オブジェクトであり、直後に破棄されるため、一時オブジェクトをコピーすることは無駄といえる。  
-右辺値と左辺値が型として区別できるのであれば、右辺値の場合はコピーせず単に左辺と置き換えるといった処理が記述できる。  
-  
+もし右辺値と左辺値を型を用いて区別できれば、右辺値の場合はコピーせず単に左辺と置き換えるといった処理が記述できる。  
+
 右辺値参照は、右辺値と左辺値を型として区別するために導入された。  
-C++11 以降では、代入式2の右辺の型は右辺値参照 `vector&amp;lt;int&amp;gt;&amp;amp;&amp;amp;` になり、左辺値参照とは区別して処理される。  
-また、こうした処理のことを「ムーブ」と呼ぶ。  
+C++11 以降では、代入式2の右辺は右辺値参照 `vector&amp;lt;int&amp;gt;&amp;amp;&amp;amp;` に束縛されるため、代入演算子オーバーロードにより左辺値参照とは区別して処理される。  
+また、代入式2で行われる処理のことを「ムーブ」と呼ぶ。  
 
 右辺値参照と左辺値参照の挙動をまとめると以下のようになる
 
@@ -61,17 +62,17 @@ int main()
 {
   int x = 0;
 
-  // lvalue reference
+  // 左辺値参照
   int&amp;amp; lvalue_ref_1 = x;              // OK
   // int&amp;amp; lvalue_ref_2 = 0;           // Error 右辺値を左辺値参照で束縛している
 
-  // rvalue reference
+  // 右辺値参照
   // int&amp;amp;&amp;amp; rvalue_ref_1 = x;          // Error 左辺値を右辺値参照で束縛している
   int&amp;amp;&amp;amp; rvalue_ref_2 = 0;             // OK
 
-  // const lvalue reference
+  // const左辺値参照
   const int&amp;amp; const_lvalue_ref_1 = x;    // OK
-  const int&amp;amp; const_lvalue_ref_2 = 0;    // OK constな左辺値参照は右辺値を束縛できる
+  const int&amp;amp; const_lvalue_ref_2 = 0;    // OK const左辺値参照は右辺値を束縛できる
 }
 ```
 
@@ -90,7 +91,6 @@ int main()
   // xは左辺値なので右辺値参照できない！
   //int&amp;amp;&amp;amp; y = x; // Error!
 }
-
 ```
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>右辺値参照・ムーブセマンティクス -- rvalue_ref_and_move_semantics: 右辺値参照の概要調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html"/>
      <id>c793455485b35e8943f54fb5a4730d956dac08af:lang/cpp11/rvalue_ref_and_move_semantics.md</id>
      <updated>2021-06-03T17:10:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/rvalue_ref_and_move_semantics.md b/lang/cpp11/rvalue_ref_and_move_semantics.md
index 3f8abc72a..13a1d44c8 100644
--- a/lang/cpp11/rvalue_ref_and_move_semantics.md
+++ b/lang/cpp11/rvalue_ref_and_move_semantics.md
@@ -3,7 +3,7 @@
 
 ## 概要
 ムーブセマンティクスはコピーコストの削減を主な目的としており、また所有権の移動を実現する。  
-右辺値参照はムーブされたオブジェクト（右辺値）を束縛するための言語機能である。
+右辺値参照はムーブ元のオブジェクト（右辺値）を束縛するための言語機能である。
 
 ### 右辺値（Rvalues）と左辺値（Lvalues）について
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>厳密な式の評価順 -- Merge pull request #873 from cpprefjp/refine-exp-eval-order</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/expression_evaluation_order.html"/>
      <id>b9c72f2bed1c1b35cafa0ac155b26ee4752e6add:lang/cpp17/expression_evaluation_order.md</id>
      <updated>2021-06-03T00:07:20+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/expression_evaluation_order.md b/lang/cpp17/expression_evaluation_order.md
index ba082317b..0bdd87213 100644
--- a/lang/cpp17/expression_evaluation_order.md
+++ b/lang/cpp17/expression_evaluation_order.md
@@ -3,8 +3,9 @@
 
 ## 概要
 
-C++14までは式の評価順序が未規定（unspecified）であったが、
-C++17では次の式は全て`a`, `b`の順で評価されるように定義された。
+C++14までは演算子オペランドにあたる部分式の評価順序は未規定（unspecified）であったが、
+C++17では下記リストの演算子に関しては`a`, `b`の順で評価されることが規定された。
+`@=`は代入演算子`=`や任意の複合代入演算子（`+=`, `-=`など）を表す。
 
 1. `a.b`
 1. `a-&amp;gt;b`
@@ -15,67 +16,71 @@ C++17では次の式は全て`a`, `b`の順で評価されるように定義さ
 1. `a &amp;lt;&amp;lt; b`
 1. `a &amp;gt;&amp;gt; b`
 
-関数の引数リスト内の式（上記例で言えば`b1`, `b2`, `b3`）の評価順序は未規定である。
-`@=`は代入演算子`=`や任意の複合代入演算子（`+=`, `-=`など）を表す。
+関数呼び出し実引数リストの部分式（上記例では`b1`, `b2`, `b3`）間の評価順序は、不定順で序列化(indeterminately sequenced)される。
+つまり`b1`, `b2`, `b3`の順序とは限らず`b3`, `b2`, `b1`や`b2`, `b3`, `b1`などの順序で評価される可能性がある。
+その一方で、例えば`b1`, `b2`, `b3`の順に評価が開始する場合には、`b1`評価完了より前に`b2`や`b3`の評価が開始する（インターリーブ実行される）ことは決して無い。
+
+上記以外の演算子オペランド（例えば`x + y`の両項`x`, `y`）間の評価順序は、C++17でも従来どおり未規定(unspecified)のままである。
 
 
 ## 仕様
 
-C++17では式の評価順序が下記の通りに定められた。
+C++17では演算子オペランドにあたる部分式の評価順序が下記の通りに定められた。
 
-- 左から右に評価される。
+1. 左から右に評価される。
     - メンバへのポインタ演算子 (`.*`, `-&amp;gt;*`)
     - 関数呼び出し演算子、および`T(...)`による初期化
     - 添え字演算子
     - シフト演算子
-- 右から左に評価される。
+2. 右から左に評価される。
     - 代入演算子
     - 複合代入演算子（代入と演算を同時に行う`+=`, `-=`, `|=`などのこと）
-- オーバーロードされた演算子の場合、同様の組み込み演算子の評価順序によって決定される。
-    - オーバーロードされた演算子の実際の動作はメンバ関数呼び出しだが、わざとメンバ関数呼び出しの規則を適用しない。
-- `new`式（メモリ確保を初期化子の評価順序の前に規定した）
+3. オーバーロードされた演算子の場合、言語組み込み演算子の評価順序に従う。
+    - オーバーロードされた演算子の実際の動作はメンバ関数呼び出しとなるが、関数呼び出しの順序規則を適用しない。
+    - ただし演算子オーバーロードをメンバ関数呼び出し形式で行った場合（例えば`x.operator=(y)`）は、関数呼び出しの評価順序（`x`, `y`）が適用される。
+4. `new`式：メモリ確保関数の呼び出しは初期化子の評価より前と規定する。
 
 3番目の規則については、
-代入演算子`operator=`をオーバーロードした場合を考えるとわかりやすいと思う。
-代入演算子は右から左の順、つまり`a`, `b`の順で評価される。
+代入演算子`operator=`をオーバーロードした場合を考えると理解しやすい。
+言語組み込み代入演算子`=`のオペランドは右から左の順、つまり`a()`, `b()`の順で評価される。
 
 ```cpp
-struct Hoge {
-};
+int  a();
+int&amp;amp; b();
 
 int main()
 {
-  Hoge a, b;
-  b = a; // a, bの順で評価される
+  b() = a(); // 部分式a(), b()の順で評価される
 }
 ```
 
-Hogeクラスの代入演算子をオーバーロードすると、
-`b = a;`は`b.operator=(a);`となりメンバ関数呼び出しと等価になる。
-このとき3番目の規則が存在しなかったとすると、メンバ関数呼び出しの規則が適用される。
-メンバ関数呼び出しの評価順序は左から右の順、つまり`b`, `a`の順で評価され、
-代入式の評価順序と逆になってしまう。
+`Hoge`クラスの代入演算子オーバーロードによって、
+式`b() = a()`は`b().operator=(a())`という関数呼び出しが行われる。
+このとき3番目の規則が存在しなかったとすると、1番目の関数呼び出しに関する規則が適用される。
+関数呼び出しの評価順序は左から右の順、つまり`b()`, `a()`の順で評価されるため、
+言語組み込み代入演算子オペランドの評価順序と逆になってしまう。
 
 ```cpp
 struct Hoge {
-  Hoge&amp;amp; operator=(const Hoge&amp;amp; a) {
-    return *this;
-  };
+  // 代入演算子オーバーロード
+  Hoge&amp;amp; operator=(const Hoge&amp;amp;);
 };
 
+Hoge  a();
+Hoge&amp;amp; b();
+
 int main()
 {
-  Hoge a, b;
-  // b.operator=(a); と等価
+  // 実際には b().operator=(a()); が呼び出されるため
   // 仮に3番目の規則が存在しなかったら...
-  b = a; // b, aの順で評価される（逆になってしまう！）
+  b() = a(); // b(), a()の順で評価される（逆になってしまう！）
 }
 ```
 
 プログラムの見た目は全く同じ代入式にも関わらず、
 代入演算子オーバーロードの有無によって評価順序が逆になってしまう。
 このような振る舞いはプログラマを混乱させるだけだろう。
-3番目の規則は「演算子オーバーロードにわざとメンバ関数呼び出しの規則を当てはめない」ことで、
+3番目の規則は「演算子オーバーロードにわざと関数呼び出しの規則を当てはめない」ことで、
 演算子オーバーロードの有無に関わらず自然な動作を実現するための規則である。
 
 
@@ -102,7 +107,7 @@ int main() {
 
 ## この機能が必要になった背景・経緯
 
-C++規格の策定以来、式の評価順序は厳密に定められていなかった。
+C++規格の策定以来、演算子オペランドの評価順序は厳密に定められていなかった。
 
 例に出てきたプログラムは非常に単純だが、
 C++14やそれ以前のC++の規格では動作が不定であった。
@@ -118,12 +123,12 @@ int main() {
 ```
 
 下記のプログラムの動作を考える。
-`std::cout`, `f`, `g`, `h`が互いに作用する
-（例えば`f`, `g`, `h`内で`std::cout`に何か出力するなど）場合、
+`std::cout`, `f()`, `g()`, `h()`が互いに作用する
+（例えば`f()`, `g()`, `h()`内で`std::cout`に何か出力するなど）場合、
 このプログラムの動作は不定であった。
 
-シフト演算子は左結合なので`(((std::cout &amp;lt;&amp;lt; f) &amp;lt;&amp;lt; g) &amp;lt;&amp;lt; h)`の順に評価されそうだが、
-残念ながらそうならない。
+シフト演算子は左結合なので`std::cout`, `f()`, `g()`, `h()`の順に評価されそうだが、
+演算子の結合と評価順には直接的な関係はなく、C++プログラマが期待する評価順は保証されなかった。
 
 ```cpp
 std::cout &amp;lt;&amp;lt; f() &amp;lt;&amp;lt; g() &amp;lt;&amp;lt; h();
@@ -137,11 +142,11 @@ std::cout.operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g()).operator&amp;lt;&amp;lt;(h());
 ```
 
 このとき`operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g())`のように、
-メンバ関数呼び出しの連鎖が発生するが、この評価順は未規定であり、
-右から左、すなわち`g`, `f`の順で評価されるかも知れないし、
-左から右、すなわち`f`, `g`の順に評価されるかも知れない。
+メンバ関数呼び出しの連鎖が発生するが、`f()`を含む部分式と`g()`の評価順は未規定とされていた。
+つまり右から左`g()`, `f()`の順で評価されるかも知れないし、
+左から右`f()`, `g()`の順に評価されるかも知れない。
 
-以上のように、シンプルな代入演算やメンバ関数の連鎖などC++で広く使われている手法でさえ、
+以上のように、シンプルな代入演算やメンバ関数呼び出し連鎖などC++で広く使われている手法でさえ、
 動作結果が不定となってしまう問題がある。
 この問題はプログラミング作法が悪いのではなく、
 C++規格が現代のプログラミング作法に合わなくなっていることが原因である。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>厳密な式の評価順 -- expression_evaluation_order: レビューコメント反映(#873)</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/expression_evaluation_order.html"/>
      <id>0a23db24cc62ee7e4de012030608aea163e1ab02:lang/cpp17/expression_evaluation_order.md</id>
      <updated>2021-06-02T10:21:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/expression_evaluation_order.md b/lang/cpp17/expression_evaluation_order.md
index 2c7cfbcde..0bdd87213 100644
--- a/lang/cpp17/expression_evaluation_order.md
+++ b/lang/cpp17/expression_evaluation_order.md
@@ -17,7 +17,8 @@ C++17では下記リストの演算子に関しては`a`, `b`の順で評価さ
 1. `a &amp;gt;&amp;gt; b`
 
 関数呼び出し実引数リストの部分式（上記例では`b1`, `b2`, `b3`）間の評価順序は、不定順で序列化(indeterminately sequenced)される。
-つまり`b1`評価完了より前に`b2`や`b3`評価が開始する（インターリーブ）ことは決して無いが、部分式の評価順は不定であり`b2`, `b3`, `b1`順なども許容される。
+つまり`b1`, `b2`, `b3`の順序とは限らず`b3`, `b2`, `b1`や`b2`, `b3`, `b1`などの順序で評価される可能性がある。
+その一方で、例えば`b1`, `b2`, `b3`の順に評価が開始する場合には、`b1`評価完了より前に`b2`や`b3`の評価が開始する（インターリーブ実行される）ことは決して無い。
 
 上記以外の演算子オペランド（例えば`x + y`の両項`x`, `y`）間の評価順序は、C++17でも従来どおり未規定(unspecified)のままである。
 
@@ -26,18 +27,18 @@ C++17では下記リストの演算子に関しては`a`, `b`の順で評価さ
 
 C++17では演算子オペランドにあたる部分式の評価順序が下記の通りに定められた。
 
-- 左から右に評価される。
+1. 左から右に評価される。
     - メンバへのポインタ演算子 (`.*`, `-&amp;gt;*`)
     - 関数呼び出し演算子、および`T(...)`による初期化
     - 添え字演算子
     - シフト演算子
-- 右から左に評価される。
+2. 右から左に評価される。
     - 代入演算子
     - 複合代入演算子（代入と演算を同時に行う`+=`, `-=`, `|=`などのこと）
-- オーバーロードされた演算子の場合、言語組み込み演算子の評価順序に従う。
+3. オーバーロードされた演算子の場合、言語組み込み演算子の評価順序に従う。
     - オーバーロードされた演算子の実際の動作はメンバ関数呼び出しとなるが、関数呼び出しの順序規則を適用しない。
     - ただし演算子オーバーロードをメンバ関数呼び出し形式で行った場合（例えば`x.operator=(y)`）は、関数呼び出しの評価順序（`x`, `y`）が適用される。
-- `new`式：メモリ確保関数の呼び出しは初期化子の評価より前と規定する。
+4. `new`式：メモリ確保関数の呼び出しは初期化子の評価より前と規定する。
 
 3番目の規則については、
 代入演算子`operator=`をオーバーロードした場合を考えると理解しやすい。
@@ -54,7 +55,7 @@ int main()
 ```
 
 `Hoge`クラスの代入演算子オーバーロードによって、
-式`b() = a()`は`b().operator=(a())`という関数呼び出しが粉われる。
+式`b() = a()`は`b().operator=(a())`という関数呼び出しが行われる。
 このとき3番目の規則が存在しなかったとすると、1番目の関数呼び出しに関する規則が適用される。
 関数呼び出しの評価順序は左から右の順、つまり`b()`, `a()`の順で評価されるため、
 言語組み込み代入演算子オペランドの評価順序と逆になってしまう。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>厳密な式の評価順 -- expression_evaluation_order: 評価順規定の対象を明確化</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/expression_evaluation_order.html"/>
      <id>c1a52e349dcd8739b254e2f1f5005694ac5ebed5:lang/cpp17/expression_evaluation_order.md</id>
      <updated>2021-06-01T09:50:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/expression_evaluation_order.md b/lang/cpp17/expression_evaluation_order.md
index ba082317b..2c7cfbcde 100644
--- a/lang/cpp17/expression_evaluation_order.md
+++ b/lang/cpp17/expression_evaluation_order.md
@@ -3,8 +3,9 @@
 
 ## 概要
 
-C++14までは式の評価順序が未規定（unspecified）であったが、
-C++17では次の式は全て`a`, `b`の順で評価されるように定義された。
+C++14までは演算子オペランドにあたる部分式の評価順序は未規定（unspecified）であったが、
+C++17では下記リストの演算子に関しては`a`, `b`の順で評価されることが規定された。
+`@=`は代入演算子`=`や任意の複合代入演算子（`+=`, `-=`など）を表す。
 
 1. `a.b`
 1. `a-&amp;gt;b`
@@ -15,13 +16,15 @@ C++17では次の式は全て`a`, `b`の順で評価されるように定義さ
 1. `a &amp;lt;&amp;lt; b`
 1. `a &amp;gt;&amp;gt; b`
 
-関数の引数リスト内の式（上記例で言えば`b1`, `b2`, `b3`）の評価順序は未規定である。
-`@=`は代入演算子`=`や任意の複合代入演算子（`+=`, `-=`など）を表す。
+関数呼び出し実引数リストの部分式（上記例では`b1`, `b2`, `b3`）間の評価順序は、不定順で序列化(indeterminately sequenced)される。
+つまり`b1`評価完了より前に`b2`や`b3`評価が開始する（インターリーブ）ことは決して無いが、部分式の評価順は不定であり`b2`, `b3`, `b1`順なども許容される。
+
+上記以外の演算子オペランド（例えば`x + y`の両項`x`, `y`）間の評価順序は、C++17でも従来どおり未規定(unspecified)のままである。
 
 
 ## 仕様
 
-C++17では式の評価順序が下記の通りに定められた。
+C++17では演算子オペランドにあたる部分式の評価順序が下記の通りに定められた。
 
 - 左から右に評価される。
     - メンバへのポインタ演算子 (`.*`, `-&amp;gt;*`)
@@ -31,51 +34,52 @@ C++17では式の評価順序が下記の通りに定められた。
 - 右から左に評価される。
     - 代入演算子
     - 複合代入演算子（代入と演算を同時に行う`+=`, `-=`, `|=`などのこと）
-- オーバーロードされた演算子の場合、同様の組み込み演算子の評価順序によって決定される。
-    - オーバーロードされた演算子の実際の動作はメンバ関数呼び出しだが、わざとメンバ関数呼び出しの規則を適用しない。
-- `new`式（メモリ確保を初期化子の評価順序の前に規定した）
+- オーバーロードされた演算子の場合、言語組み込み演算子の評価順序に従う。
+    - オーバーロードされた演算子の実際の動作はメンバ関数呼び出しとなるが、関数呼び出しの順序規則を適用しない。
+    - ただし演算子オーバーロードをメンバ関数呼び出し形式で行った場合（例えば`x.operator=(y)`）は、関数呼び出しの評価順序（`x`, `y`）が適用される。
+- `new`式：メモリ確保関数の呼び出しは初期化子の評価より前と規定する。
 
 3番目の規則については、
-代入演算子`operator=`をオーバーロードした場合を考えるとわかりやすいと思う。
-代入演算子は右から左の順、つまり`a`, `b`の順で評価される。
+代入演算子`operator=`をオーバーロードした場合を考えると理解しやすい。
+言語組み込み代入演算子`=`のオペランドは右から左の順、つまり`a()`, `b()`の順で評価される。
 
 ```cpp
-struct Hoge {
-};
+int  a();
+int&amp;amp; b();
 
 int main()
 {
-  Hoge a, b;
-  b = a; // a, bの順で評価される
+  b() = a(); // 部分式a(), b()の順で評価される
 }
 ```
 
-Hogeクラスの代入演算子をオーバーロードすると、
-`b = a;`は`b.operator=(a);`となりメンバ関数呼び出しと等価になる。
-このとき3番目の規則が存在しなかったとすると、メンバ関数呼び出しの規則が適用される。
-メンバ関数呼び出しの評価順序は左から右の順、つまり`b`, `a`の順で評価され、
-代入式の評価順序と逆になってしまう。
+`Hoge`クラスの代入演算子オーバーロードによって、
+式`b() = a()`は`b().operator=(a())`という関数呼び出しが粉われる。
+このとき3番目の規則が存在しなかったとすると、1番目の関数呼び出しに関する規則が適用される。
+関数呼び出しの評価順序は左から右の順、つまり`b()`, `a()`の順で評価されるため、
+言語組み込み代入演算子オペランドの評価順序と逆になってしまう。
 
 ```cpp
 struct Hoge {
-  Hoge&amp;amp; operator=(const Hoge&amp;amp; a) {
-    return *this;
-  };
+  // 代入演算子オーバーロード
+  Hoge&amp;amp; operator=(const Hoge&amp;amp;);
 };
 
+Hoge  a();
+Hoge&amp;amp; b();
+
 int main()
 {
-  Hoge a, b;
-  // b.operator=(a); と等価
+  // 実際には b().operator=(a()); が呼び出されるため
   // 仮に3番目の規則が存在しなかったら...
-  b = a; // b, aの順で評価される（逆になってしまう！）
+  b() = a(); // b(), a()の順で評価される（逆になってしまう！）
 }
 ```
 
 プログラムの見た目は全く同じ代入式にも関わらず、
 代入演算子オーバーロードの有無によって評価順序が逆になってしまう。
 このような振る舞いはプログラマを混乱させるだけだろう。
-3番目の規則は「演算子オーバーロードにわざとメンバ関数呼び出しの規則を当てはめない」ことで、
+3番目の規則は「演算子オーバーロードにわざと関数呼び出しの規則を当てはめない」ことで、
 演算子オーバーロードの有無に関わらず自然な動作を実現するための規則である。
 
 
@@ -102,7 +106,7 @@ int main() {
 
 ## この機能が必要になった背景・経緯
 
-C++規格の策定以来、式の評価順序は厳密に定められていなかった。
+C++規格の策定以来、演算子オペランドの評価順序は厳密に定められていなかった。
 
 例に出てきたプログラムは非常に単純だが、
 C++14やそれ以前のC++の規格では動作が不定であった。
@@ -118,12 +122,12 @@ int main() {
 ```
 
 下記のプログラムの動作を考える。
-`std::cout`, `f`, `g`, `h`が互いに作用する
-（例えば`f`, `g`, `h`内で`std::cout`に何か出力するなど）場合、
+`std::cout`, `f()`, `g()`, `h()`が互いに作用する
+（例えば`f()`, `g()`, `h()`内で`std::cout`に何か出力するなど）場合、
 このプログラムの動作は不定であった。
 
-シフト演算子は左結合なので`(((std::cout &amp;lt;&amp;lt; f) &amp;lt;&amp;lt; g) &amp;lt;&amp;lt; h)`の順に評価されそうだが、
-残念ながらそうならない。
+シフト演算子は左結合なので`std::cout`, `f()`, `g()`, `h()`の順に評価されそうだが、
+演算子の結合と評価順には直接的な関係はなく、C++プログラマが期待する評価順は保証されなかった。
 
 ```cpp
 std::cout &amp;lt;&amp;lt; f() &amp;lt;&amp;lt; g() &amp;lt;&amp;lt; h();
@@ -137,11 +141,11 @@ std::cout.operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g()).operator&amp;lt;&amp;lt;(h());
 ```
 
 このとき`operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g())`のように、
-メンバ関数呼び出しの連鎖が発生するが、この評価順は未規定であり、
-右から左、すなわち`g`, `f`の順で評価されるかも知れないし、
-左から右、すなわち`f`, `g`の順に評価されるかも知れない。
+メンバ関数呼び出しの連鎖が発生するが、`f()`を含む部分式と`g()`の評価順は未規定とされていた。
+つまり右から左`g()`, `f()`の順で評価されるかも知れないし、
+左から右`f()`, `g()`の順に評価されるかも知れない。
 
-以上のように、シンプルな代入演算やメンバ関数の連鎖などC++で広く使われている手法でさえ、
+以上のように、シンプルな代入演算やメンバ関数呼び出し連鎖などC++で広く使われている手法でさえ、
 動作結果が不定となってしまう問題がある。
 この問題はプログラミング作法が悪いのではなく、
 C++規格が現代のプログラミング作法に合わなくなっていることが原因である。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>