<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-06-04T15:17:57.657811</updated>
  <id>ea6ed89f-23ff-48c8-afa0-f71e37c38d34</id>

  
    <entry>
      <title>コンパイル時初期化を強制する`constinit`キーワードを追加 -- constinit: 静的変数の動的初期化タイミングに関する記述を一旦削除</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/constinit.html"/>
      <id>47e0186912cfb6aa2992bc92ee2e653c5d046998:lang/cpp20/constinit.md</id>
      <updated>2021-06-04T23:18:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/constinit.md b/lang/cpp20/constinit.md
index e89b6be0f..8d9a370fa 100644
--- a/lang/cpp20/constinit.md
+++ b/lang/cpp20/constinit.md
@@ -95,7 +95,7 @@ int S::M = 12;  // NG、constinitはこちらに必要、おそらく警告が
 
 動的初期化は実行時に行われる初期化であり、静的初期化はコンパイル時に行われる初期化である。全ての静的変数はコンパイル完了時点で静的初期化されており、その中で動的初期化が必要となる変数だけが動的初期化される。
 
-定数初期化は静的変数に対して最初に試みられる初期化で、初期化式が定数式として実行可能である時に行われる。定数初期化できない残りの変数は全てゼロ初期化される。ゼロ初期化された変数のうち、初期化式を持つものについては実行時（プログラム開始時）に動的初期化される。
+定数初期化は静的変数に対して最初に試みられる初期化で、初期化式が定数式として実行可能である時に行われる。定数初期化できない残りの変数は全てゼロ初期化される。ゼロ初期化された変数のうち、初期化式を持つものについては実行時に動的初期化される。
 
 定数初期化は非リテラル型のクラス型であっても、対応するコンストラクタが`constexpr`コンストラクタであり、そのコンストラクタを通して全てのメンバが定数式で初期化される場合に、クラス型のオブジェクトに対しても実行可能となる（下の例ではこのコンストラクタのことを定数初期化コンストラクタと呼んでいる）。
 
@@ -160,7 +160,7 @@ int main() {
 
 ## この機能が必要になった背景・経緯
 
-静的変数の動的初期化は関数ローカルスコープのものを除いて`main()`の実行よりも前に行われる。そこではコンストラクタ呼び出しを介して通常のC++コードの実行をほぼ自由に行うことができる一方で、各変数の動的初期化順序がどうなるのかはほとんど不定である。
+静的変数の動的初期化ではコンストラクタ呼び出しを介して通常のC++コードの実行をほぼ自由に行うことができる一方で、各変数の動的初期化順序がどうなるのかはほとんど不定である。
 
 同じ翻訳単位にある静的変数の動的初期化順序はその定義の現れる順番と規定されてはいるが、テンプレートや外部リンケージを持つ変数（`extern/inline`など）およびそれらとの間には順序が規定されておらず、動的初期化の順序に依存したコードは多くの場合未定義動作に陥っている（データ競合や未初期化変数の読み取りなど）。この問題は*static initialization order fiasco*として知られている。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- map / set : mergeの右辺値参照バージョンについての説明を追記</title>
      <link href="https://cpprefjp.github.io/reference/map/map/merge.html"/>
      <id>c49beb32f76e2952cf35a24c6dc462bec008533e:reference/map/map/merge.md</id>
      <updated>2021-06-03T18:01:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/merge.md b/reference/map/map/merge.md
index e904eaa87..55e7205aa 100644
--- a/reference/map/map/merge.md
+++ b/reference/map/map/merge.md
@@ -36,7 +36,8 @@ template&amp;lt;class C2&amp;gt;
 
 
 ## 備考
-`source` の転送された要素へのポインタおよび参照は、それらと同じ要素を参照するが、`*this` のメンバとして参照する。また、転送された要素を参照する反復子は、引き続きその要素を参照するが、転送後は `source` ではなく `*this` への反復子として動作する。
+- `source` の転送された要素へのポインタおよび参照は、それらと同じ要素を参照するが、`*this` のメンバとして参照する。また、転送された要素を参照する反復子は、引き続きその要素を参照するが、転送後は `source` ではなく `*this` への反復子として動作する。
+- (2), (4) : これらの右辺値参照オーバーロードは、一時オブジェクトを受け取った場合にコピーを発生させないためだけのものである。パラメータのオブジェクト内のポインタを破壊したり、高速なmerge処理が行われるわけではない
 
 
 ## 例外 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- map / set : mergeの右辺値参照バージョンについての説明を追記</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/merge.html"/>
      <id>c49beb32f76e2952cf35a24c6dc462bec008533e:reference/map/multimap/merge.md</id>
      <updated>2021-06-03T18:01:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/merge.md b/reference/map/multimap/merge.md
index c476e706c..62577ede8 100644
--- a/reference/map/multimap/merge.md
+++ b/reference/map/multimap/merge.md
@@ -36,7 +36,8 @@ template&amp;lt;class C2&amp;gt;
 
 
 ## 備考
-`source` の転送された要素へのポインタおよび参照は、それらと同じ要素を参照するが、`*this` のメンバとして参照する。また、転送された要素を参照する反復子は、引き続きその要素を参照するが、転送後は `source` ではなく `*this` への反復子として動作する。
+- `source` の転送された要素へのポインタおよび参照は、それらと同じ要素を参照するが、`*this` のメンバとして参照する。また、転送された要素を参照する反復子は、引き続きその要素を参照するが、転送後は `source` ではなく `*this` への反復子として動作する
+- (2), (4) : これらの右辺値参照オーバーロードは、一時オブジェクトを受け取った場合にコピーを発生させないためだけのものである。パラメータのオブジェクト内のポインタを破壊したり、高速なmerge処理が行われるわけではない
 
 
 ## 例外 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- map / set : mergeの右辺値参照バージョンについての説明を追記</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/merge.html"/>
      <id>c49beb32f76e2952cf35a24c6dc462bec008533e:reference/set/multiset/merge.md</id>
      <updated>2021-06-03T18:01:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/merge.md b/reference/set/multiset/merge.md
index 89d70b14d..dd72f2d03 100644
--- a/reference/set/multiset/merge.md
+++ b/reference/set/multiset/merge.md
@@ -36,7 +36,8 @@ template&amp;lt;class C2&amp;gt;
 
 
 ## 備考
-`source` の転送された要素へのポインタおよび参照は、それらと同じ要素を参照するが、`*this` のメンバとして参照する。また、転送された要素を参照するイテレータは、引き続きその要素を参照するが、転送後は `source` ではなく `*this` へのイテレータとして動作する。
+- `source` の転送された要素へのポインタおよび参照は、それらと同じ要素を参照するが、`*this` のメンバとして参照する。また、転送された要素を参照するイテレータは、引き続きその要素を参照するが、転送後は `source` ではなく `*this` へのイテレータとして動作する
+- (2), (4) : これらの右辺値参照オーバーロードは、一時オブジェクトを受け取った場合にコピーを発生させないためだけのものである。パラメータのオブジェクト内のポインタを破壊したり、高速なmerge処理が行われるわけではない
 
 
 ## 例外 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- map / set : mergeの右辺値参照バージョンについての説明を追記</title>
      <link href="https://cpprefjp.github.io/reference/set/set/merge.html"/>
      <id>c49beb32f76e2952cf35a24c6dc462bec008533e:reference/set/set/merge.md</id>
      <updated>2021-06-03T18:01:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/merge.md b/reference/set/set/merge.md
index 1787c7fc2..128345222 100644
--- a/reference/set/set/merge.md
+++ b/reference/set/set/merge.md
@@ -36,7 +36,8 @@ template&amp;lt;class C2&amp;gt;
 
 
 ## 備考
-`source` の転送された要素へのポインタおよび参照は、それらと同じ要素を参照するが、`*this` のメンバとして参照する。また、転送された要素を参照する反復子は、引き続きその要素を参照するが、転送後は `source` ではなく `*this` への反復子として動作する。
+- `source` の転送された要素へのポインタおよび参照は、それらと同じ要素を参照するが、`*this` のメンバとして参照する。また、転送された要素を参照する反復子は、引き続きその要素を参照するが、転送後は `source` ではなく `*this` への反復子として動作する
+- (2), (4) : これらの右辺値参照オーバーロードは、一時オブジェクトを受け取った場合にコピーを発生させないためだけのものである。パラメータのオブジェクト内のポインタを破壊したり、高速なmerge処理が行われるわけではない
 
 
 ## 例外 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>右辺値参照・ムーブセマンティクス -- rvalue_ref_and_move_semantics: ムーブ,所有権の移動 説明調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html"/>
      <id>c9ea8d681894a64aad8de30faf89573ff5ffe837:lang/cpp11/rvalue_ref_and_move_semantics.md</id>
      <updated>2021-06-03T17:50:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/rvalue_ref_and_move_semantics.md b/lang/cpp11/rvalue_ref_and_move_semantics.md
index dfc5bfe93..63e2555cc 100644
--- a/lang/cpp11/rvalue_ref_and_move_semantics.md
+++ b/lang/cpp11/rvalue_ref_and_move_semantics.md
@@ -96,17 +96,17 @@ int main()
 
 ### ムーブ
 ムーブとはあるオブジェクトから他のオブジェクトにリソースを明け渡すということである。  
-コピーが遅い場合、より高速に値を別の変数に移すことができる。  
-リソースを明け渡した後のオブジェクトにはなにが入っているのか不明であり、値を参照した時の動作は対象オブジェクトの型に依存する。
+値のコピーではコストが高くつく場合は、より高速に値を別の変数へ移すことができる。  
+リソース明け渡し後のオブジェクトには何が入っているのか不明となり、値を参照した時の動作は対象オブジェクトの型に依存する。
 後述する所有権の移動を除けば、一般にはムーブ後オブジェクトの状態は明確に規定されない事が多い。 
 
 あるオブジェクトをムーブしたいときには、
-[`std::move()`](/reference/utility/move.md)関数を使うことができる。
+[`std::move()`](/reference/utility/move.md)関数を利用する。
 ムーブされた変数は右辺値となり、それ以降使える保証はなくなる。  
-注意すべきことは[`std::move()`](/reference/utility/move.md)しただけでは  
-「このオブジェクトはこれ以降使わないので好きに書き換えていい」  
-ということを明示したにすぎないということである。  
-ムーブは実際に[`std::move()`](/reference/utility/move.md)した変数を、後述するムーブコンストラクタ・ムーブ代入演算子に渡した際に行われる。
+注意すべきことは[`std::move()`](/reference/utility/move.md)関数の呼び出しは  
+「このオブジェクトはこれ以降使わないので好きに書き換えて良い」  
+という明示にすぎない。  
+実際のムーブは変数を[`std::move()`](/reference/utility/move.md)関数に通し、後述するムーブコンストラクタ・ムーブ代入演算子に渡した際に行われる。
 
 ```cpp example
 #include &amp;lt;string&amp;gt;
@@ -118,16 +118,16 @@ int main()
   // 何も起こらない
   std::move(x);
 
-  // 実際に y に x がムーブされる
+  // 実際に x から y へ文字列がムーブされる
   std::string y = std::move(x);
 }
 ```
 * std::move[link /reference/utility/move.md]
 
 #### 所有権の移動
-クラスによってはコピーは禁止されているが、ムーブはできるということがある。  
+クラスによってはコピーは禁止されるが、ムーブならば可能ということがある。  
 そういったクラスではムーブが所有権の移動を表す。  
-同じものが２つ存在してはいけないものが所有権の移動に対応しており、ムーブされた変数は無効値（例えばスマートポインタなら`nullptr`）であることが保証される。  
+同じものが複数存在してはいけないという制約を持つクラスが所有権の移動に対応しており、ムーブ後の変数は無効値（例えばスマートポインタなら`nullptr`）となることが保証される。  
 例を挙げると、[`std::unique_ptr`](/reference/memory/unique_ptr.md)がそれに当たる。
 [`std::unique_ptr`](/reference/memory/unique_ptr.md)はあるオブジェクトの唯一の所有権を持つことを表すスマートポインタである。
 所有権は唯一であるので、コピーが禁止されている。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>右辺値参照・ムーブセマンティクス -- rvalue_ref_and_move_semantics: 右辺値参照の説明改善</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html"/>
      <id>dd053e4719c9fe3ccaf4ce12d566ce802a8bd4bb:lang/cpp11/rvalue_ref_and_move_semantics.md</id>
      <updated>2021-06-03T17:28:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/rvalue_ref_and_move_semantics.md b/lang/cpp11/rvalue_ref_and_move_semantics.md
index 13a1d44c8..dfc5bfe93 100644
--- a/lang/cpp11/rvalue_ref_and_move_semantics.md
+++ b/lang/cpp11/rvalue_ref_and_move_semantics.md
@@ -34,10 +34,11 @@ int main()
 
 ### 右辺値参照
 
-右辺値参照は、右辺値を束縛する参照である。  
-C++11からは、`&amp;amp;` で宣言される参照型を左辺値参照と呼ぶのに対して、`&amp;amp;&amp;amp;` で宣言される参照型を右辺値参照と呼ぶ。  
-C++03までは、右辺値参照と左辺値参照を区別せず、右辺値はconst左辺値参照 (`const&amp;amp;`) に束縛するよう扱われていた。  
-そのため、右辺値のみに対して特別な処理を記述することができなかった。  
+右辺値参照は、右辺値のみを束縛する参照である。  
+C++11からは、型`T`に対して `T&amp;amp;` で宣言される参照型を左辺値参照と呼ぶのに対して、`T&amp;amp;&amp;amp;` で宣言される参照型を右辺値参照と呼ぶ。
+
+C++03までは、右辺値のみを扱う右辺値参照は存在せず、右辺値はconst左辺値参照 `const T&amp;amp;` に束縛するよう扱われていた。  
+このconst左辺値参照では左辺値も束縛できるため、左辺値／右辺値の区別情報が失われてしまい、右辺値のみに対して特別な処理を記述することができなかった。  
 
 ```cpp
 std::vector&amp;lt;int&amp;gt; v, vv;
@@ -45,14 +46,14 @@ v = vv;                  // 代入式1
 v = std::vector&amp;lt;int&amp;gt;(100, 0); // 代入式2
 ```
 
-上記コードはC++03では、代入式1,2とも右辺の型は `vector&amp;lt;int&amp;gt; const&amp;amp;` になる。  
+上記コードはC++03では、代入式1,2ともに右辺は `vector&amp;lt;int&amp;gt; const&amp;amp;` 型に束縛される。  
 代入処理の中では、右辺の値をコピーし、左辺の値と置き換えられる。  
 しかし代入式2の右辺は一時オブジェクトであり、直後に破棄されるため、一時オブジェクトをコピーすることは無駄といえる。  
-右辺値と左辺値が型として区別できるのであれば、右辺値の場合はコピーせず単に左辺と置き換えるといった処理が記述できる。  
-  
+もし右辺値と左辺値を型を用いて区別できれば、右辺値の場合はコピーせず単に左辺と置き換えるといった処理が記述できる。  
+
 右辺値参照は、右辺値と左辺値を型として区別するために導入された。  
-C++11 以降では、代入式2の右辺の型は右辺値参照 `vector&amp;lt;int&amp;gt;&amp;amp;&amp;amp;` になり、左辺値参照とは区別して処理される。  
-また、こうした処理のことを「ムーブ」と呼ぶ。  
+C++11 以降では、代入式2の右辺は右辺値参照 `vector&amp;lt;int&amp;gt;&amp;amp;&amp;amp;` に束縛されるため、代入演算子オーバーロードにより左辺値参照とは区別して処理される。  
+また、代入式2で行われる処理のことを「ムーブ」と呼ぶ。  
 
 右辺値参照と左辺値参照の挙動をまとめると以下のようになる
 
@@ -61,17 +62,17 @@ int main()
 {
   int x = 0;
 
-  // lvalue reference
+  // 左辺値参照
   int&amp;amp; lvalue_ref_1 = x;              // OK
   // int&amp;amp; lvalue_ref_2 = 0;           // Error 右辺値を左辺値参照で束縛している
 
-  // rvalue reference
+  // 右辺値参照
   // int&amp;amp;&amp;amp; rvalue_ref_1 = x;          // Error 左辺値を右辺値参照で束縛している
   int&amp;amp;&amp;amp; rvalue_ref_2 = 0;             // OK
 
-  // const lvalue reference
+  // const左辺値参照
   const int&amp;amp; const_lvalue_ref_1 = x;    // OK
-  const int&amp;amp; const_lvalue_ref_2 = 0;    // OK constな左辺値参照は右辺値を束縛できる
+  const int&amp;amp; const_lvalue_ref_2 = 0;    // OK const左辺値参照は右辺値を束縛できる
 }
 ```
 
@@ -90,7 +91,6 @@ int main()
   // xは左辺値なので右辺値参照できない！
   //int&amp;amp;&amp;amp; y = x; // Error!
 }
-
 ```
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>右辺値参照・ムーブセマンティクス -- rvalue_ref_and_move_semantics: 右辺値参照の概要調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html"/>
      <id>c793455485b35e8943f54fb5a4730d956dac08af:lang/cpp11/rvalue_ref_and_move_semantics.md</id>
      <updated>2021-06-03T17:10:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/rvalue_ref_and_move_semantics.md b/lang/cpp11/rvalue_ref_and_move_semantics.md
index 3f8abc72a..13a1d44c8 100644
--- a/lang/cpp11/rvalue_ref_and_move_semantics.md
+++ b/lang/cpp11/rvalue_ref_and_move_semantics.md
@@ -3,7 +3,7 @@
 
 ## 概要
 ムーブセマンティクスはコピーコストの削減を主な目的としており、また所有権の移動を実現する。  
-右辺値参照はムーブされたオブジェクト（右辺値）を束縛するための言語機能である。
+右辺値参照はムーブ元のオブジェクト（右辺値）を束縛するための言語機能である。
 
 ### 右辺値（Rvalues）と左辺値（Lvalues）について
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>