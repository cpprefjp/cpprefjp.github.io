<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-27T07:39:37.755999</updated>
  <id>a50a47ad-6f6f-447e-b34a-c1f6b86783e6</id>

  
    <entry>
      <title>fold_left -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_left.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left.md b/reference/algorithm/ranges_fold_left.md
index 3477c8c6d..8c7651f38 100644
--- a/reference/algorithm/ranges_fold_left.md
+++ b/reference/algorithm/ranges_fold_left.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_left(I first, S last, T init, F f);       // (1)
-
-  template&amp;lt;input_range R, class T, 
-           indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_left(R&amp;amp;&amp;amp; r, T init, F f);                 // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(I first,
+              S last,
+              T init,
+              F f);   // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(I first,
+              S last,
+              T init,
+              F f);   // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T, 
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(R&amp;amp;&amp;amp; r,
+              T init,
+              F f);   // (2) C++23
+  template &amp;lt;input_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;, 
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(R&amp;amp;&amp;amp; r,
+              T init,
+              F f);   // (2) C++26
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -116,19 +142,22 @@ concept indirectly-binary-left-foldable =
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
-
-この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
-
-```cpp
-using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, T, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
-```
-* decay_t[link /reference/type_traits/decay.md]
-* invoke_result_t[link /reference/type_traits/invoke_result.md]
-* iter_reference_t[link /reference/iterator/iter_reference_t.md]
-
-すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
-
-また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
+    ```cpp
+    using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, T, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
+    ```
+    * decay_t[link /reference/type_traits/decay.md]
+    * invoke_result_t[link /reference/type_traits/invoke_result.md]
+    * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+
+    - すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
+    - また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        T sum = std::ranges::fold_left(v, {a, b}, op);
+        ```
 
 ## 例
 
@@ -172,7 +201,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 55
 1.125
@@ -217,12 +246,36 @@ int main() {
 * println[link /reference/print/println.md]
 * fold_right[link ranges_fold_right.md]
 
-### 出力
+#### 出力
 ```
 init -&amp;gt; a -&amp;gt; b -&amp;gt; c -&amp;gt; d -&amp;gt; e -&amp;gt; f
 init -&amp;gt; f -&amp;gt; e -&amp;gt; d -&amp;gt; c -&amp;gt; b -&amp;gt; a
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  int sum = std::ranges::fold_left(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{}&amp;#34;, sum);
+}
+```
+* std::ranges::fold_left[color ff0000]
+
+#### 出力
+```
+6
+```
+
 ## 実装例
 
 ```cpp
@@ -273,3 +326,5 @@ constexpr auto fold_left(I first, S last, T init, F f) {
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
 - [プログラミングHaskellのfoldr, foldlの説明が秀逸だった件 - あと味](https://taiju.hatenablog.com/entry/20130202/1359773888)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left_with_iter -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_with_iter.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_left_with_iter.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left_with_iter.md b/reference/algorithm/ranges_fold_left_with_iter.md
index a1e264bbc..1646732ec 100644
--- a/reference/algorithm/ranges_fold_left_with_iter.md
+++ b/reference/algorithm/ranges_fold_left_with_iter.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_left_with_iter(I first, S last, T init, F f); // (1)
-
-  template&amp;lt;input_range R, class T,
-           indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_left_with_iter(R&amp;amp;&amp;amp; r, T init, F f);           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(I first,
+                        S last,
+                        T init,
+                        F f); // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(I first,
+                        S last,
+                        T init,
+                        F f); // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(R&amp;amp;&amp;amp; r,
+                        T init,
+                        F f); // (2) C++23
+  template &amp;lt;input_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(R&amp;amp;&amp;amp; r,
+                        T init,
+                        F f); // (2) C++26
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -96,10 +122,15 @@ constexpr fold_left_with_iter_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, U&amp;gt;
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
+- 戻り値の項で使用している`U`は、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型であり、`fold_left_with_iter()`の処理内部で積算値の型として使用されるものでもある。
+- `fold_left`同様に、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto [end, sum] = std::ranges::fold_left_with_iter(v, {a, b}, op);
+        ```
 
-戻り値の項で使用している`U`は、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型であり、`fold_left_with_iter()`の処理内部で積算値の型として使用されるものでもある。
-
-`fold_left`同様に、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
 
 ## 例
 
@@ -141,7 +172,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 { true, 55 }
 { true, 1.125 }
@@ -178,7 +209,7 @@ int main() {
 * println[link /reference/print/println.md]
 * value_or[link /reference/optional/optional/value_or.md]
 
-### 出力
+#### 出力
 ```
 -1
 -1
@@ -222,13 +253,37 @@ int main() {
 * subrange[link /reference/ranges/subrange.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 
 ```
 sum = 36
 mul = 36288, 36288
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  auto [end, sum] = std::ranges::fold_left_with_iter(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{} {}&amp;#34;, end == v.end(), sum);
+}
+```
+* std::ranges::fold_left_with_iter[color ff0000]
+
+#### 出力
+```
+true 6
+```
+
 ## 実装例
 
 ```cpp
@@ -282,3 +337,5 @@ constexpr auto fold_left_with_iter(I first, S last, T init, F f) -&amp;gt; fold_left_wi
 ## 参照
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_right -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_right.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_right.md b/reference/algorithm/ranges_fold_right.md
index 96a13edc2..2c418690b 100644
--- a/reference/algorithm/ranges_fold_right.md
+++ b/reference/algorithm/ranges_fold_right.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_right(I first, S last, T init, F f);       // (1)
-
-  template&amp;lt;bidirectional_range R, class T,
-           indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_right(R&amp;amp;&amp;amp; r, T init, F f);                 // (2)
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(I first,
+               S last,
+               T init,
+               F f);    // (1) C++23
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(I first,
+               S last,
+               T init,
+               F f);    // (1) C++23
+
+  template &amp;lt;bidirectional_range R,
+            class T,
+            indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(R&amp;amp;&amp;amp; r,
+               T init,
+               F f);    // (2) C++23
+  template &amp;lt;bidirectional_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;,
+            indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(R&amp;amp;&amp;amp; r,
+               T init,
+               F f);    // (2) C++26
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -113,19 +139,23 @@ return accum;
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
+- この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
+    ```cpp
+    using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, iter_reference_t&amp;lt;I&amp;gt;, T&amp;gt;&amp;gt;;
+    ```
+    * decay_t[link /reference/type_traits/decay.md]
+    * invoke_result_t[link /reference/type_traits/invoke_result.md]
+    * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+
+    - すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
+    - また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        T sum = std::ranges::fold_right(v, {a, b}, op);
+        ```
 
-この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
-
-```cpp
-using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, iter_reference_t&amp;lt;I&amp;gt;, T&amp;gt;&amp;gt;;
-```
-* decay_t[link /reference/type_traits/decay.md]
-* invoke_result_t[link /reference/type_traits/invoke_result.md]
-* iter_reference_t[link /reference/iterator/iter_reference_t.md]
-
-すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
-
-また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
 
 ## 例
 
@@ -170,7 +200,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 55
 1.125
@@ -217,7 +247,7 @@ int main() {
 * println[link /reference/print/println.md]
 * fold_left[link /reference/algorithm/ranges_fold_left.md]
 
-### 出力
+#### 出力
 ```
 init -&amp;gt; a -&amp;gt; b -&amp;gt; c -&amp;gt; d -&amp;gt; e -&amp;gt; f
 init -&amp;gt; f -&amp;gt; e -&amp;gt; d -&amp;gt; c -&amp;gt; b -&amp;gt; a
@@ -255,11 +285,35 @@ int main() {
 * iota[link /reference/ranges/iota_view.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  int sum = std::ranges::fold_right(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{}&amp;#34;, sum);
+}
+```
+* std::ranges::fold_right[color ff0000]
+
+#### 出力
+```
+6
+```
+
 ## 実装例
 
 ```cpp
@@ -309,3 +363,5 @@ constexpr auto fold_right(I first, S last, T init, F f) {
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
 - [プログラミングHaskellのfoldr, foldlの説明が秀逸だった件 - あと味](https://taiju.hatenablog.com/entry/20130202/1359773888)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- binary_search : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/binary_search.html"/>
      <id>93b8c47923f9c1090573b00a071cad863607d0a1:reference/algorithm/binary_search.md</id>
      <updated>2025-05-27T15:06:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/binary_search.md b/reference/algorithm/binary_search.md
index 342f67c3d..a1c10635e 100644
--- a/reference/algorithm/binary_search.md
+++ b/reference/algorithm/binary_search.md
@@ -5,27 +5,35 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
-  bool binary_search(ForwardIterator first,
-                     ForwardIterator last,
-                     const T&amp;amp; value);                 // (1) C++03
-
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
-  constexpr bool binary_search(ForwardIterator first,
-                               ForwardIterator last,
-                               const T&amp;amp; value);       // (1) C++20
-
-  template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
-  bool binary_search(ForwardIterator first,
-                     ForwardIterator last,
-                     const T&amp;amp; value,
-                     Compare comp);                   // (2) C++03
-
-  template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
-  constexpr bool binary_search(ForwardIterator first,
-                               ForwardIterator last,
-                               const T&amp;amp; value,
-                               Compare comp);         // (2) C++20
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
+  bool
+    binary_search(ForwardIterator first,
+                  ForwardIterator last,
+                  const T&amp;amp; value);       // (1) C++03
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
+  constexpr bool
+    binary_search(ForwardIterator first,
+                  ForwardIterator last,
+                  const T&amp;amp; value);       // (1) C++20
+
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
+  bool
+    binary_search(ForwardIterator first,
+                  ForwardIterator last,
+                  const T&amp;amp; value,
+                  Compare comp);         // (2) C++03
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
+  constexpr bool
+    binary_search(ForwardIterator first,
+                  ForwardIterator last,
+                  const T&amp;amp; value,
+                  Compare comp);         // (2) C++20
 }
 ```
 
@@ -49,9 +57,16 @@ namespace std {
 
 ## 備考
 - `comp` は 2 引数の関数オブジェクトで、1 番目の引数が 2 番目の引数「より小さい」場合に `true` を、そうでない場合に `false` を返すものとして扱われる。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::binary_search(v.begin(), v.end(), {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -74,6 +89,44 @@ int main()
 ```
 * std::binary_search[color ff0000]
 
+#### 出力
+```
+found
+```
+
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}を二分検索
+  bool found = std::binary_search(v.begin(), v.end(), {3, 4});
+  if (found) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::binary_search[color ff0000]
+
 ### 出力
 ```
 found
@@ -114,3 +167,5 @@ bool binary_search(ForwardIterator first, ForwardIterator last,
 - [LWG Issue 787. complexity of `binary_search`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787)
     - C++03までの計算量が間違っていたので、C++11で修正。
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- binary_search : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_binary_search.html"/>
      <id>93b8c47923f9c1090573b00a071cad863607d0a1:reference/algorithm/ranges_binary_search.md</id>
      <updated>2025-05-27T15:06:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_binary_search.md b/reference/algorithm/ranges_binary_search.md
index 54df91313..7c950f41a 100644
--- a/reference/algorithm/ranges_binary_search.md
+++ b/reference/algorithm/ranges_binary_search.md
@@ -10,13 +10,30 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr bool
     binary_search(I first,
                   S last,
                   const T&amp;amp; value,
                   Comp comp = {},
                   Proj proj = {}); // (1) C++20
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    binary_search(I first,
+                  S last,
+                  const T&amp;amp; value,
+                  Comp comp = {},
+                  Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
@@ -30,6 +47,18 @@ namespace std::ranges {
                   const T&amp;amp; value,
                   Comp comp = {},
                   Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    binary_search(R&amp;amp;&amp;amp; r,
+                  const T&amp;amp; value,
+                  Comp comp = {},
+                  Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -65,9 +94,15 @@ namespace std::ranges {
 
 ## 備考
 - `comp` は 2 引数の関数オブジェクトで、1 番目の引数が 2 番目の引数「より小さい」場合に `true` を、そうでない場合に `false` を返すものとして扱われる。
-
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::ranges::binary_search(v, {a, b});
+        ```
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -90,6 +125,44 @@ int main()
 ```
 * std::ranges::binary_search[color ff0000]
 
+#### 出力
+```
+found
+```
+
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}を二分検索
+  bool found = std::ranges::binary_search(v, {3, 4});
+  if (found) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::binary_search[color ff0000]
+
 ### 出力
 ```
 found
@@ -107,3 +180,5 @@ found
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- equal_range : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/equal_range.html"/>
      <id>1a1278ca88432498e33f6f87618e96f03a99c948:reference/algorithm/equal_range.md</id>
      <updated>2025-05-27T14:53:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/equal_range.md b/reference/algorithm/equal_range.md
index 9e1add89e..63b841b0f 100644
--- a/reference/algorithm/equal_range.md
+++ b/reference/algorithm/equal_range.md
@@ -5,31 +5,49 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
     equal_range(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);      // (1) C++03
-
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   constexpr pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
     equal_range(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);      // (1) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
+  constexpr pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
+    equal_range(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value);      // (1) C++26
 
-  template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
     equal_range(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);        // (2) C++03
-
-  template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   constexpr pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
     equal_range(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);        // (2) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type,
+            class Compare&amp;gt;
+  constexpr pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
+    equal_range(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value,
+                Compare comp);        // (2) C++26
 }
 ```
 * pair[link /reference/utility/pair.md]
@@ -54,7 +72,17 @@ namespace std {
 最大で 2 * log2(`last - first`) + O(1) 回の比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto result = std::equal_range(v.begin(), v.end(), {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -75,13 +103,53 @@ int main()
 ```
 * equal_range[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}が見つかる範囲を取得
+  auto result = std::equal_range(v.begin(), v.end(), {3, 4});
+
+  while (result.first != result.second) {
+    std::cout &amp;lt;&amp;lt; result.first-&amp;gt;x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; result.first-&amp;gt;y &amp;lt;&amp;lt; std::endl;
+    ++result.first;
+  }
+}
+```
+* std::equal_range[color ff0000]
+
+#### 出力
+```
+3,4
+3,4
+```
 
 ## 参照
 - [LWG Issue 384. `equal_range` has unimplementable runtime complexity](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384)
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- equal_range : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>1a1278ca88432498e33f6f87618e96f03a99c948:reference/algorithm/ranges_equal_range.md</id>
      <updated>2025-05-27T14:53:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index a580318ff..225f563da 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -10,23 +10,55 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr subrange&amp;lt;I&amp;gt;
     equal_range(I first,
                 S last,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (1) C++20
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    equal_range(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     equal_range(R&amp;amp;&amp;amp; r,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    equal_range(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -57,11 +89,21 @@ namespace std::ranges {
 ## 戻り値
 `{`[`ranges::lower_bound`](ranges_lower_bound.md)`(first, last, value, comp, proj), `[`ranges::upper_bound`](ranges_upper_bound.md)`(first, last, value, comp, proj)}`
 
+
 ## 計算量
 最大で 2 * log2(`last - first`) + O(1) 回の比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto result = std::ranges::equal_range(v, {a, b});
+        ```
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -93,7 +135,7 @@ int main()
 * std::ranges::sort[link ranges_sort.md]
 * std::ranges::equal_range[color ff0000]
 
-### 出力
+#### 出力
 ```
 size: 2
 3
@@ -102,6 +144,44 @@ size: 2
 size: 0
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}が見つかる範囲を取得
+  auto result = std::ranges::equal_range(v, {3, 4});
+
+  for (const Point&amp;amp; p : result) {
+    std::cout &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; p.y &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::equal_range[color ff0000]
+
+#### 出力
+```
+3,4
+3,4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -114,3 +194,5 @@ size: 0
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- lower_bound / upper_bound : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/lower_bound.html"/>
      <id>8eae9db6e6aa52ad8e2a4f4fc5cca009be560b16:reference/algorithm/lower_bound.md</id>
      <updated>2025-05-27T14:43:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/lower_bound.md b/reference/algorithm/lower_bound.md
index 24bc996d4..64d79a241 100644
--- a/reference/algorithm/lower_bound.md
+++ b/reference/algorithm/lower_bound.md
@@ -5,31 +5,49 @@
 
 ```cpp
 namespace std {
-  template&amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   ForwardIterator
     lower_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);       // (1) C++03
-
-  template&amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
+  constexpr ForwardIterator
+    lower_bound(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value);       // (1) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
   constexpr ForwardIterator
     lower_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);       // (1) C++20
 
-  template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   ForwardIterator
     lower_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);         // (2) C++03
-
-  template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   constexpr ForwardIterator
     lower_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);         // (2) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type,
+            class Compare&amp;gt;
+  constexpr ForwardIterator
+    lower_bound(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value,
+                Compare comp);         // (2) C++26
 }
 ```
 
@@ -71,9 +89,16 @@ namespace std {
 	具体的には、[`partition_point`](partition_point.md)`(first, last, [value](const T&amp;amp; e) { return e &amp;lt; value; })`、あるいは、[`partition_point`](partition_point.md)`(first, last, [value, comp](const T&amp;amp; e) { return comp(e, value); })` とすることで等価の結果が得られる。
 - 本関数の要件は、上記の通り C++03 までの方が C++11 よりも厳しい。
 	しかし、本アルゴリズムの特性上、処理系が C++03 までにしか準拠していない場合でも、昇順に並んでいなくても正常に動作する可能性は高いものと思われる。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::lower_bound(v.begin(), v.end(), {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -152,13 +177,53 @@ int main()
 ```
 * std::lower_bound[color ff0000]
 
-### 出力
+#### 出力
 ```
 4 pos=2
 4 pos=2
 id=4 name=Carol pos=2
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {1, 2},
+    {3, 4},
+    {5, 6},
+  };
+
+  auto it = std::lower_bound(v.begin(), v.end(), {3, 4});
+
+  // lower_boundでは指定した値&amp;#34;以上&amp;#34;の値が見つかるので、
+  // 指定した値を見つけたいなら検索結果の値を比較する必要がある
+  if (it != v.end() &amp;amp;&amp;amp; *it == Point{3, 4}) {
+    std::size_t pos = std::distance(v.begin(), it);
+    std::cout &amp;lt;&amp;lt; &amp;#34;pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::lower_bound[color ff0000]
+
+#### 出力
+```
+pos=2
+```
+
 
 ## 実装例
 ```cpp
@@ -201,3 +266,5 @@ lower_bound(ForwardIterator first, ForwardIterator last, const T&amp;amp; value)
 - [LWG Issue 384. `equal_range` has unimplementable runtime complexity](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384)
 - [LWG Issue 2150. Unclear specification of `find_end`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2150)
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- lower_bound / upper_bound : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>8eae9db6e6aa52ad8e2a4f4fc5cca009be560b16:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2025-05-27T14:43:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
index 08c91d33a..9fb2c5659 100644
--- a/reference/algorithm/ranges_lower_bound.md
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -10,23 +10,57 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr I
     lower_bound(I first,
                 S last,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (1) C++20
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    lower_bound(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;,
+              Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     lower_bound(R&amp;amp;&amp;amp; r,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;,
+              Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    lower_bound(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -64,7 +98,17 @@ namespace std::ranges {
 ## 計算量
 最大で log2(`last - first`) + O(1) 回の比較を行う
 
+
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::ranges::lower_bound(v, {a, b});
+        ```
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -139,13 +183,53 @@ int main()
 * std::ranges::distance[link /reference/iterator/ranges_distance.md]
 * std::ranges::lower_bound[color ff0000]
 
-### 出力
+#### 出力
 ```
 4 pos=2
 4 pos=2
 id=4 name=Bob pos=2
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {1, 2},
+    {3, 4},
+    {5, 6},
+  };
+
+  auto it = std::ranges::lower_bound(v, {3, 4});
+
+  // lower_boundでは指定した値&amp;#34;以上&amp;#34;の値が見つかるので、
+  // 指定した値を見つけたいなら検索結果の値を比較する必要がある
+  if (it != v.end() &amp;amp;&amp;amp; *it == Point{3, 4}) {
+    std::size_t pos = std::distance(v.begin(), it);
+    std::cout &amp;lt;&amp;lt; &amp;#34;pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::lower_bound[color ff0000]
+
+#### 出力
+```
+pos=2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -158,3 +242,5 @@ id=4 name=Bob pos=2
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- lower_bound / upper_bound : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_upper_bound.html"/>
      <id>8eae9db6e6aa52ad8e2a4f4fc5cca009be560b16:reference/algorithm/ranges_upper_bound.md</id>
      <updated>2025-05-27T14:43:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_upper_bound.md b/reference/algorithm/ranges_upper_bound.md
index 427567d23..22151d4dc 100644
--- a/reference/algorithm/ranges_upper_bound.md
+++ b/reference/algorithm/ranges_upper_bound.md
@@ -10,13 +10,30 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr I
     upper_bound(I first,
                 S last,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (1) C++20
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    upper_bound(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
@@ -30,6 +47,18 @@ namespace std::ranges {
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    upper_bound(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -69,9 +98,15 @@ namespace std::ranges {
 ## 備考
 - 本関数は、本質的に [`partition_point`](ranges_partition_point.md) と等価である。  
 	具体的には、[`partition_point`](ranges_partition_point.md)`(first, last, [value](const T&amp;amp; e) { return !bool(value &amp;lt; e); })`、あるいは、[`partition_point`](ranges_partition_point.md)`(first, last, [value, comp](const T&amp;amp; e) { return !bool(comp(value, e)); })` とすることで等価の結果が得られる。
-
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::ranges::upper_bound(v, {a, b});
+        ```
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -128,12 +163,56 @@ int main()
 * std::ranges::upper_bound[color ff0000]
 
 
-### 出力
+#### 出力
 ```
 4
 100:1 100:2 200:1 200:2 300:1 300:2
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}が見つかる範囲を取得
+  auto first = std::ranges::lower_bound(v, {3, 4});
+  auto last = std::ranges::upper_bound(v, {3, 4});
+
+  if (first != v.end() &amp;amp;&amp;amp; last != v.end()) {
+    while (first != last) {
+      std::cout &amp;lt;&amp;lt; first-&amp;gt;x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; first-&amp;gt;y &amp;lt;&amp;lt; std::endl;
+      ++first;
+    }
+  }
+}
+```
+* std::ranges::upper_bound[color ff0000]
+* std::ranges::lower_bound[link /reference/algorithm/lower_bound.md]
+
+#### 出力
+```
+3,4
+3,4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -146,3 +225,5 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- lower_bound / upper_bound : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/upper_bound.html"/>
      <id>8eae9db6e6aa52ad8e2a4f4fc5cca009be560b16:reference/algorithm/upper_bound.md</id>
      <updated>2025-05-27T14:43:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/upper_bound.md b/reference/algorithm/upper_bound.md
index 3ce4be90a..2f86c5121 100644
--- a/reference/algorithm/upper_bound.md
+++ b/reference/algorithm/upper_bound.md
@@ -5,31 +5,49 @@
 
 ```cpp
 namespace std {
-  template&amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   ForwardIterator
     upper_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);       // (1) C++03
-
-  template&amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   constexpr ForwardIterator
     upper_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);       // (1) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
+  constexpr ForwardIterator
+    upper_bound(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value);       // (1) C++26
 
-  template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   ForwardIterator
     upper_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);         // (2) C++03
-
-  template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   constexpr ForwardIterator
     upper_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);         // (2) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type,
+            class Compare&amp;gt;
+  constexpr ForwardIterator
+    upper_bound(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value,
+                Compare comp);         // (2) C++26
 }
 ```
 
@@ -68,9 +86,16 @@ namespace std {
 	具体的には、[`partition_point`](partition_point.md)`(first, last, [value](const T&amp;amp; e) { return !bool(value &amp;lt; e); })`、あるいは、[`partition_point`](partition_point.md)`(first, last, [value, comp](const T&amp;amp; e) { return !bool(comp(value, e)); })` とすることで等価の結果が得られる。
 - 本関数の要件は、上記の通り C++03 までの方が C++11 よりも厳しい。  
 	しかし、本アルゴリズムの特性上、処理系が C++03 までにしか準拠していない場合でも、昇順に並んでいなくても正常に動作する可能性は高いものと思われる。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::upper_bound(v.begin(), v.end(), {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -132,13 +157,57 @@ int main()
 * std::upper_bound[color ff0000]
 
 
-### 出力
+#### 出力
 ```
 4
 100:1 100:2 200:1 200:2 300:1 300:2
 ```
 
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}が見つかる範囲を取得
+  auto first = std::lower_bound(v.begin(), v.end(), {3, 4});
+  auto last = std::upper_bound(v.begin(), v.end(), {3, 4});
+
+  if (first != v.end() &amp;amp;&amp;amp; last != v.end()) {
+    while (first != last) {
+      std::cout &amp;lt;&amp;lt; first-&amp;gt;x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; first-&amp;gt;y &amp;lt;&amp;lt; std::endl;
+      ++first;
+    }
+  }
+}
+```
+* std::upper_bound[color ff0000]
+* std::lower_bound[link /reference/algorithm/lower_bound.md]
+
+#### 出力
+```
+3,4
+3,4
+```
+
+
 ## 実装例
 ```cpp
 template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
@@ -180,3 +249,5 @@ upper_bound(ForwardIterator first, ForwardIterator last, const T&amp;amp; value)
 - [LWG Issue 384. `equal_range` has unimplementable runtime complexity](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384)
 - [LWG Issue 2150. Unclear specification of `find_end`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2150)
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- replace_copy_if : コンパイルエラー修正 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy_if.html"/>
      <id>bd1ef79d48ec9fd9f3ac5a7950ab86ea82844b83:reference/algorithm/ranges_replace_copy_if.md</id>
      <updated>2025-05-27T14:19:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy_if.md b/reference/algorithm/ranges_replace_copy_if.md
index 75cd00256..1993964cd 100644
--- a/reference/algorithm/ranges_replace_copy_if.md
+++ b/reference/algorithm/ranges_replace_copy_if.md
@@ -164,7 +164,7 @@ int main() {
   // 値が{1, 2}の要素をすべて{9, 9}に置き換えたものを出力する
   std::ranges::replace_copy_if(
     v,
-    std::ostream_iterator&amp;lt;int&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
+    std::ostream_iterator&amp;lt;Point&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
     [](const Point&amp;amp; p) { return p.x == 1 &amp;amp;&amp;amp; p.y == 2; },
     {9, 9}
   );
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- replace_copy_if : コンパイルエラー修正 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/replace_copy_if.html"/>
      <id>bd1ef79d48ec9fd9f3ac5a7950ab86ea82844b83:reference/algorithm/replace_copy_if.md</id>
      <updated>2025-05-27T14:19:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/replace_copy_if.md b/reference/algorithm/replace_copy_if.md
index afcf0e642..39692570c 100644
--- a/reference/algorithm/replace_copy_if.md
+++ b/reference/algorithm/replace_copy_if.md
@@ -150,7 +150,7 @@ int main() {
   std::replace_copy_if(
     v.begin(),
     v.end(),
-    std::ostream_iterator&amp;lt;int&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
+    std::ostream_iterator&amp;lt;Point&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
     [](const Point&amp;amp; p) { return p.x == 1 &amp;amp;&amp;amp; p.y == 2; },
     {9, 9}
   );
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>