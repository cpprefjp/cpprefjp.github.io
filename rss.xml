<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="http://cpprefjp.github.io" />
  <updated>2015-12-15T14:13:43.275214</updated>
  <id>8d8817d5-98d7-4373-967e-2d661dd151bc</id>

  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : クロージャオブジェクトの解説を追加(#294)</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>a53bfe90166f08f421e7091aecaef6ba5d253340:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-15 14:13:10 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトのキャプチャ方法はひとつしか指定できない。変数個別のキャプチャ方法は、カンマ区切りで複数指定できる。&lt;/p&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;構文&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;[キャプチャリスト](パラメータリスト) mutable 例外仕様 属性 -&amp;gt; 戻り値の型 { 関数の本体 }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このうち、以下は省略可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータがない場合は、パラメータリストおよびその丸カッコを省略できる&lt;/li&gt;
&lt;li&gt;キャプチャした変数を書き換える必要がない場合、&lt;code&gt;mutable&lt;/code&gt;を省略できる&lt;/li&gt;
&lt;li&gt;例外仕様を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;属性を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;戻り値の型を推論に任せる場合、&lt;code&gt;-&amp;gt;&lt;/code&gt;記号および戻り値の型を省略できる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっとも短いラムダ式は、以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;[]{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このラムダ式は、なにもキャプチャせず、パラメータを受け取らず、なにも処理せず、戻り値の型が&lt;code&gt;void&lt;/code&gt;である関数オブジェクトを定義する。&lt;/p&gt;
&lt;h2&gt;クロージャオブジェクト&lt;/h2&gt;
&lt;p&gt;ラムダ式によって定義される関数オブジェクトを、クロージャオブジェクト(closure object)という。これには、以下の特徴がある：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ラムダ式ごとに、一意な名前の関数オブジェクトが定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;なコピーコンストラクタを持つ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;なムーブコンストラクタを持つ&lt;/li&gt;
&lt;li&gt;デフォルトコンストラクタを持たない&lt;/li&gt;
&lt;li&gt;コピー代入演算子は&lt;code&gt;delete&lt;/code&gt;定義される&lt;/li&gt;
&lt;li&gt;関数呼び出し演算子は、以下の特徴を持つ：&lt;ul&gt;
&lt;li&gt;ラムダ式を&lt;code&gt;mutable&lt;/code&gt;修飾しない限り、デフォルトで&lt;code&gt;const&lt;/code&gt;メンバ関数として定義される&lt;/li&gt;
&lt;li&gt;非&lt;code&gt;virtual&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非&lt;code&gt;volatile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;インライン関数&lt;/li&gt;
&lt;li&gt;ラムダ式と同じパラメータリストの型、および戻り値の型を持つ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;キャプチャをしないラムダ式の場合、クロージャオブジェクトは、ラムダ式と同じシグニチャを持つ関数ポインタへの変換演算子を持つ&lt;/li&gt;
&lt;li&gt;クロージャオブジェクトのサイズは未規定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : 構文の解説を追加(#294)</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>28facc267fe41d8073154893f9fa0bbce52b0348:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-14 14:06:19 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトのキャプチャ方法はひとつしか指定できない。変数個別のキャプチャ方法は、カンマ区切りで複数指定できる。&lt;/p&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;構文&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;[キャプチャリスト](パラメータリスト) mutable 例外仕様 属性 -&amp;gt; 戻り値の型 { 関数の本体 }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このうち、以下は省略可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータがない場合は、パラメータリストおよびその丸カッコを省略できる&lt;/li&gt;
&lt;li&gt;キャプチャした変数を書き換える必要がない場合、&lt;code&gt;mutable&lt;/code&gt;を省略できる&lt;/li&gt;
&lt;li&gt;例外仕様を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;属性を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;戻り値の型を推論に任せる場合、&lt;code&gt;-&amp;gt;&lt;/code&gt;記号および戻り値の型を省略できる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっとも短いラムダ式は、以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;[]{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このラムダ式は、なにもキャプチャせず、パラメータを受け取らず、なにも処理せず、戻り値の型が&lt;code&gt;void&lt;/code&gt;である関数オブジェクトを定義する。&lt;/p&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : 変数個別のキャプチャを、複数指定できることを明記</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>b28c5a845b45647d23604c0dd74498db537934b5:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-11 14:31:07 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトのキャプチャ方法はひとつしか指定できない。変数個別のキャプチャ方法は、カンマ区切りで複数指定できる。&lt;/p&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : 概要文章に、キャプチャの説明を追加(#294)</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>a96cd211a361405ed3b99749a9001a65ac3a746c:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-11 14:10:41 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>変数テンプレート -- 変数テンプレート : 記事「変数テンプレートをラムダ式でキャプチャするときの注意」を参照に追加</title>
      <link href="http://cpprefjp.github.io/lang/cpp14/variable_templates.html"/>
      <id>9519bc1b4d66ff125166f53675adfec7c2d88b84:lang/cpp14/variable_templates.md</id>
      <updated>2015-12-10 13:39:20 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;変数テンプレート&lt;span class=&#34;cpp cpp14&#34; title=&#34;C++14で追加&#34;&gt;(C++14)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;変数定義時のテンプレート指定を可能にする。&lt;/p&gt;
&lt;p&gt;C++11までは、関数、クラス、型の別名をテンプレートで定義できた。C++14からは、変数もテンプレートで定義できるようになった。これにより、型もしくは整数値をパラメータにとり、そのパラメータの組み合わせごとに変数の値を保持できるようになった。&lt;/p&gt;
&lt;p&gt;これはたとえば、円周率πの値を、数値型ごとの有効桁数で取得するために使用できる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;static_cast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;3.14159265358979323846&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 円の面積を求める&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;area_of_circle_with_radius&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;従来であれば、このような目的には、関数テンプレートが使用されていた。型&lt;code&gt;T&lt;/code&gt;の円周率を返す関数&lt;code&gt;pi()&lt;/code&gt;を定義すればよかった。しかし、多倍長整数のように、コピーのコストが高いものについては、関数テンプレートよりも、変数テンプレートを使用した方が効率がよくなる。&lt;/p&gt;
&lt;p&gt;そのほかの用途としては、関数呼び出しの丸カッコを省略できるため、2文字ではあるがより短いコードを書けるようにできる、というものもある。たとえば、型&lt;code&gt;T&lt;/code&gt;が整数型か判定する&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/type_traits/is_integral.html&#34;&gt;std::is_integral&lt;/a&gt;&lt;/code&gt;型特性は、以下のように、&lt;code&gt;::value&lt;/code&gt;を付けるか、クラスのインスタンスを作成して&lt;code&gt;bool&lt;/code&gt;への変換演算子を呼び出す必要がある：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;type_traits&amp;gt;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_integral&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_integral&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;変数テンプレートを使用することで、以下のように記述できる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is_integral_v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is_integral_v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 以下のようにラッパーとして定義してもよい&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// #include &amp;lt;type_traits&amp;gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// template &amp;lt;class T&amp;gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// constexpr bool is_integral_v = std::is_integral&amp;lt;int&amp;gt;::value;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_integral_v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;p&gt;C++14より前の規格でも使用できた関数テンプレートを変数にも適用可能に拡張した仕様である。&lt;/p&gt;
&lt;p&gt;言語規格から変数テンプレートについて明記されている仕様を、以下に整理する。&lt;/p&gt;
&lt;p&gt;これらは全て、関数、クラス、型の別名のテンプレートについての定義と同様である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;を適用できる。（§7.1.5 The constexpr specifier）&lt;/li&gt;
&lt;li&gt;変数の宣言でテンプレートを宣言できる。（§14 Templates）&lt;/li&gt;
&lt;li&gt;クラススコープにおける変数テンプレートは静的データメンバーテンプレートとなる。（§14 Templates）&lt;/li&gt;
&lt;li&gt;翻訳単位ごとにインスタンス化される。（§14 Templates）&lt;/li&gt;
&lt;li&gt;必要に応じて暗黙的にインスタンス化される。（§14.7.1 Implicit instantiation）&lt;/li&gt;
&lt;li&gt;明示的なインスタンス化が可能。（§14.7.2 Explicit instantiation）&lt;/li&gt;
&lt;li&gt;デフォルトテンプレート引数は使用される文脈により暗黙的に使用される。（§14.7.1 Implicit instantiation）&lt;/li&gt;
&lt;li&gt;テンプレート変数のインスタンス化は名前空間へ行われる。（§14.7.1 Implicit instantiation, §14.7.2 Explicit instantiation）&lt;/li&gt;
&lt;li&gt;テンプレート変数の宣言は明示的なインスタンス化よりも前に行わなければならない。（§14.7.2 Explicit instantiation）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;iomanip&amp;gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;limits&amp;gt;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// ネイピア数: http://www.wolframalpha.com/input/?i=Napier%27s%20constant&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;template &amp;lt; typename T = float &amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;napier&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;static_cast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;2.718&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;281&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;828&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;459&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;045&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;235&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;360&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;287&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;471&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;352&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;662&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;497&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;757&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;247&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;093&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;699&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;959&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#39;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5L&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FloatingPoint&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;precision&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits.html&#34;&gt;std::numeric_limits&lt;/a&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FloatingPoint&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits/max_digits10.html&#34;&gt;max_digits10&lt;/a&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/iostream/cout.html&#34;&gt;std::cout&lt;/a&gt;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/iomanip/setprecision.md.nolink&#34;&gt;std::setprecision&lt;/a&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;precision&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;napier&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/iomanip/setprecision.md.nolink&#34;&gt;std::setprecision&lt;/a&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;precision&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;napier&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/iomanip/setprecision.md.nolink&#34;&gt;std::setprecision&lt;/a&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;precision&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;napier&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;2.7182818284590452353602874713526624977572470936999595&#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/ostream/endl.html&#34;&gt;std::endl&lt;/a&gt;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力例&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;2.71828175
2.7182818284590451
2.71828182845904523543
2.7182818284590452353602874713526624977572470936999595
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;この機能が必要になった背景・経緯&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;型をパラメーター化された定数値を簡単に扱いたい。（N3651）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;でそのような定数値を扱いたい。（N3651）&lt;/li&gt;
&lt;li&gt;C++11規格の範囲内でも対応は出来たが煩雑で扱い難い方法を取る必要があるため簡潔に扱えるようにしたい。（N3651）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;検討されたほかの選択肢&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;または&lt;code&gt;constexpr&lt;/code&gt;と組み合わせて用いる提案があったが、ワーキンググループの多数意見によりC++14の対象では制限しない事にした。（N3651）&lt;/li&gt;
&lt;li&gt;テンプレートテンプレートについても提案があったが、ワーキンググループで複数の不要論がありC++14では含めない事にした。（N3651）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/lang/cpp11/constexpr.html&#34;&gt;constexpr&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3651.pdf&#34; target=&#34;_blank&#34;&gt;N3651 Variable Templates (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/blog/2013/04/trip-report-iso-c-spring-2013-meeting&#34; target=&#34;_blank&#34;&gt;Trip Report: ISO C++ Spring 2013 Meeting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://faithandbrave.hateblo.jp/entry/2014/01/21/162701&#34; target=&#34;_blank&#34;&gt;変数テンプレートをラムダ式でキャプチャするときの注意 - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>