<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-08-05T14:41:59.618018</updated>
  <id>f92cc41f-60e2-402c-aaa8-7fe8fb2de20d</id>

  
    <entry>
      <title>範囲for文がカスタマイゼーションポイントを見つけるルールを緩和 -- Update relaxing_the_range_for_loop_customization_point_finding_rules.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.html"/>
      <id>9a3814da7371a4b88253daddcb671ca85fabc04a:lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md</id>
      <updated>2021-08-05T18:07:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md b/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md
index 7664c767d..a70582faf 100644
--- a/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md
+++ b/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md
@@ -35,9 +35,9 @@ int main()
 {
   X x{&amp;#34;Hello&amp;#34;};
 
-  // C++17まではコンパイルエラー
+  // P0962R1非対応の場合はコンパイルエラー
   // (std::stringstream::endメンバだけが見つかり、対応するbeginがないというエラーになる)。
-  // C++20ではOK
+  // P0962R1に対応していればOK
   for (char c : x) {
     std::cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; std::endl;
   }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>範囲for文 -- DR P0962R1対応</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/range_based_for.html"/>
      <id>e2e5f5ea50abfb9e2619aec28d39daf24924e7dc:lang/cpp11/range_based_for.md</id>
      <updated>2021-08-05T04:13:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/range_based_for.md b/lang/cpp11/range_based_for.md
index 3b430a119..3ae95f0cc 100644
--- a/lang/cpp11/range_based_for.md
+++ b/lang/cpp11/range_based_for.md
@@ -107,7 +107,7 @@ begin-exprとend-exprの具体的な内容は、範囲として何を渡すか
 
 * ただし、`__bound`は配列の要素数(要素数が不明な場合はill-formed)。
 
-範囲の型がクラスであって、メンバ`begin`**または**`end`が存在するとき、以下のように展開される：
+範囲の型がクラスであって、メンバ`begin`と`end`が両方存在するとき、以下のように展開される：
 
 ```cpp
 {
@@ -124,7 +124,8 @@ begin-exprとend-exprの具体的な内容は、範囲として何を渡すか
 * for-range-declaration[italic]
 * statement[italic]
 
-* メンバ`begin`、`end`が片方しかない場合や、関数ではない場合でもこのように展開されるが、当然エラーとなる。この問題は[C++20で部分的に緩和される](/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md)。
+* メンバ`begin`、`end`が関数ではない場合でもこのように展開されるが、呼び出しができなければエラーとなる。
+* 当初のC++11では、メンバ`begin`、`end`が片方しかなくてもこのように展開されていた。これは規格の不具合であり、[修正P0962R1がC++11に遡って適用された](/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md)。
 
 範囲の型が配列でもメンバ`begin`、`end`のいずれかを持つクラスでもないとき、以下のように展開される：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>範囲for文がカスタマイゼーションポイントを見つけるルールを緩和 -- DR P0962R1対応</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.html"/>
      <id>e2e5f5ea50abfb9e2619aec28d39daf24924e7dc:lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md</id>
      <updated>2021-08-05T04:13:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md b/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md
index 4760fa6b3..7664c767d 100644
--- a/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md
+++ b/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md
@@ -8,6 +8,8 @@ C++20ではこのルールを緩和し、`begin`/`end`メンバの両方があ
 
 これは、`begin`もしくは`end`という何らかのメンバ (関数、変数、型) が特殊な意味を持ち、そのメンバが範囲for文で使用することを意図していないような状況に対応するための改訂である。
 
+なお、この修正はC++11へ遡って適用された。そのため、この修正を実装した処理系では、以下のコンパイルエラーを試すことはできない。
+
 ## 例
 ```cpp example
 #include &amp;lt;sstream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- ヘッダーユニットの説明を微調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>859c3879136be12568268ee1ece1b825604670e5:lang/cpp20/modules.md</id>
      <updated>2021-08-05T02:37:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index dd2d25cb0..9e2449d7c 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -379,17 +379,13 @@ import &amp;lt;foo.h&amp;gt;; // foo.hをヘッダーユニットとしてインポート
 * C++ライブラリヘッダー([C++標準ライブラリヘッダー](/reference.md)のうち、[C言語標準ライブラリヘッダーに由来するもの](/reference.md#clib-facilities)(`&amp;lt;cstdio&amp;gt;`など)以外)
 * その他、処理系定義のヘッダー
 
-ヘッダーユニットをインポートしてもその内容が展開されることはないが、マクロを取り込めるなど、`#include`とほぼ同じ効果が得られる。
+ヘッダーユニットをインポートしてもその内容が展開されることはないが、ヘッダーユニット内のマクロが使えるようになる。これにより`#include`とほぼ同じ効果が得られる。
 
 プリプロセッサは、非モジュールユニットに現れるインポータブルヘッダーに対する`#include`ディレクティブを`import`宣言に置換してもよいことになっている。モジュールユニットにおいては、明示的に`import`宣言をするほうがよい。
 
-#### モジュールとの違い
+ヘッダーユニットとなるヘッダーファイル自体はモジュール宣言を持てないし、`export`宣言もできない。
 
-ヘッダーユニットはインポートしたときの効果を`#include`と近くするために、普通のモジュールとは異なる性質をもつ。
-
-* ヘッダーユニットはモジュール宣言を持てない。
-* ヘッダーユニット内の宣言はすべてグローバルモジュールに属し、名前を導入する宣言ならば暗黙的にエクスポートされる。
-* ヘッダーユニットをインポートすると、ヘッダーユニット内のマクロが使えるようになる。
+ヘッダーユニット内の宣言はすべてグローバルモジュールに属し、名前を導入する宣言ならば暗黙的にエクスポートされる。
 
 ```cpp
 // P1103R3より引用
@@ -449,14 +445,13 @@ int main() {
 
 #### ヘッダーユニットが必要になった背景・経緯
 
-単にヘッダーファイルをインクルードしたいだけであれば、グローバルモジュールフラグメント内で行えば問題は無い。
+単にヘッダーファイルを使いたいだけであれば、グローバルモジュールフラグメント内でインクルードできる。
 
-しかし、処理系はヘッダーファイルをインポータブルヘッダーに指定することで、それらに対する `#include` を `import` に置き換え、
-コンパイルを速くすることができる。
+しかし、処理系はヘッダーファイルをインポータブルヘッダーに指定することで、それらに対する `#include` を `import` に置き換えることができる。
 
-例えば、C++20では標準ライブラリは従来通りヘッダーファイルで提供されるが、C++ライブラリヘッダーはインポータブルヘッダーでもある。処理系はこれらをコンパイル済みモジュールとして提供するかもしれない(ヘッダーファイルからヘッダーユニットを生成する手順を事前に行っておくことは禁止されていない)。
+プログラム全体であるヘッダーファイルに対する `#include` が `import` に置き換わった場合、そのヘッダーファイルは1回しかコンパイルされなくなり、コンパイル時間の短縮につながる可能性がある。このように、C++20としてコンパイルするだけで従来のコードでも恩恵を得ることができる。
 
-そのような処理系では、C++20としてコンパイルするだけで従来のコードでも恩恵を得ることができる。
+言語機能としてのモジュールが導入されても、すでにあるコードがリファクタリングされモジュールにまとめられるには長い時間がかかるため、過渡期においてヘッダーユニットは役に立つ。
 
 ## ビルド
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- Update modules.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>7f2d9960370b8a54f4fee4e6feb256eb17acbabb:lang/cpp20/modules.md</id>
      <updated>2021-08-05T02:16:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index 31e2f140a..dd2d25cb0 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -27,17 +27,21 @@ namespace mylib {
 
 ```cpp
 import mylib;
+// iostreamなど、一部のヘッダーはインポート(≠インクルード)可能
+import &amp;lt;iostream&amp;gt;
 
 int main() {
   // これらの型や関数の宣言はこの翻訳単位には無いが、
   // mylibでエクスポートしているので、使用することができる。
   mylib::myfunc_result_t ret = mylib::myfunc();
+  std::cout &amp;lt;&amp;lt; ret.x &amp;lt;&amp;lt; std::endl;
 }
 ```
 
 モジュールは単一の翻訳単位で構成することも、複数の翻訳単位で構成することもできる。
 
-C++20では標準ライブラリはモジュール化されないが、その中でC++ライブラリはヘッダーユニットとしてインポートできる。
+C++20では標準ライブラリはモジュール化されないが、C++ライブラリはモジュールのように扱うことができ、モジュール機能の恩恵を受けられる(ヘッダーユニット)。
+
 標準ライブラリのモジュール化はC++23以降に予定されている。
 
 ## 仕様
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extension -- path::stem, extension : 隠しファイルの例を追加</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/extension.html"/>
      <id>777e16c8ae9bb3f3b567eb9e7952415b5b323b44:reference/filesystem/path/extension.md</id>
      <updated>2021-08-01T17:19:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/extension.md b/reference/filesystem/path/extension.md
index 5974bc451..5c7499ec3 100644
--- a/reference/filesystem/path/extension.md
+++ b/reference/filesystem/path/extension.md
@@ -36,6 +36,7 @@ int main()
     &amp;#34;/foo/&amp;#34;,           // ディレクトリパス
     &amp;#34;/foo/.&amp;#34;,          // カレントディレクトリ
     &amp;#34;..&amp;#34;,              // 親ディレクトリ
+    &amp;#34;.file&amp;#34;,           // 隠しファイル (拡張子なし)
   };
 
   for (const fs::path&amp;amp; p : ps) {
@@ -53,6 +54,7 @@ int main()
 &amp;#34;/foo/&amp;#34; : &amp;#34;&amp;#34;
 &amp;#34;/foo/.&amp;#34; : &amp;#34;&amp;#34;
 &amp;#34;..&amp;#34; : &amp;#34;&amp;#34;
+&amp;#34;.file&amp;#34; : &amp;#34;&amp;#34;
 ```
 
 
@@ -71,6 +73,7 @@ int main()
     &amp;#34;C:/foo/&amp;#34;,           // ディレクトリパス
     &amp;#34;C:/foo/.&amp;#34;,          // カレントディレクトリ
     &amp;#34;..&amp;#34;,                // 親ディレクトリ
+    &amp;#34;.file&amp;#34;,             // UNIX系OSでの隠しファイル (拡張子なし)
   };
 
   for (const fs::path&amp;amp; p : ps) {
@@ -87,6 +90,7 @@ int main()
 &amp;#34;C:\foo\&amp;#34; : &amp;#34;&amp;#34;
 &amp;#34;C:\foo\.&amp;#34; : &amp;#34;&amp;#34;
 &amp;#34;..&amp;#34; : &amp;#34;&amp;#34;
+&amp;#34;.file&amp;#34; : &amp;#34;&amp;#34;
 ```
 
 Windowsでの例は、Visual C++が正式にファイルシステムライブラリをサポートしていないことから、未検証のサンプルコード・出力となっている。
@@ -97,6 +101,6 @@ Windowsでの例は、Visual C++が正式にファイルシステムライブラ
 - C++17
 
 ### 処理系
-- [Clang](/implementation.md#clang):
+- [Clang](/implementation.md#clang): 9.0
 - [GCC](/implementation.md#gcc): 8.1
 - [Visual C++](/implementation.md#visual_cpp):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stem -- path::stem, extension : 隠しファイルの例を追加</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/stem.html"/>
      <id>777e16c8ae9bb3f3b567eb9e7952415b5b323b44:reference/filesystem/path/stem.md</id>
      <updated>2021-08-01T17:19:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/stem.md b/reference/filesystem/path/stem.md
index 05fe3ce5f..e8c711bfd 100644
--- a/reference/filesystem/path/stem.md
+++ b/reference/filesystem/path/stem.md
@@ -35,6 +35,7 @@ int main()
     &amp;#34;/foo/&amp;#34;,           // ディレクトリパス
     &amp;#34;/foo/.&amp;#34;,          // カレントディレクトリ
     &amp;#34;..&amp;#34;,              // 親ディレクトリ
+    &amp;#34;.file&amp;#34;,           // 隠しファイル (拡張子なし)
   };
 
   for (const fs::path&amp;amp; p : ps) {
@@ -52,6 +53,7 @@ int main()
 &amp;#34;/foo/&amp;#34; : &amp;#34;&amp;#34;
 &amp;#34;/foo/.&amp;#34; : &amp;#34;.&amp;#34;
 &amp;#34;..&amp;#34; : &amp;#34;..&amp;#34;
+&amp;#34;.file&amp;#34; : &amp;#34;.file&amp;#34;
 ```
 
 
@@ -70,6 +72,7 @@ int main()
     &amp;#34;C:/foo/&amp;#34;,           // ディレクトリパス
     &amp;#34;C:/foo/.&amp;#34;,          // カレントディレクトリ
     &amp;#34;..&amp;#34;,                // 親ディレクトリ
+    &amp;#34;.file&amp;#34;,             // UNIX系OSでの隠しファイル (拡張子なし)
   };
 
   for (const fs::path&amp;amp; p : ps) {
@@ -86,6 +89,7 @@ int main()
 &amp;#34;C:\foo\&amp;#34; : &amp;#34;&amp;#34;
 &amp;#34;C:\foo\.&amp;#34; : &amp;#34;.&amp;#34;
 &amp;#34;..&amp;#34; : &amp;#34;..&amp;#34;
+&amp;#34;.file&amp;#34; : &amp;#34;.file&amp;#34;
 ```
 
 Windowsでの例は、Visual C++が正式にファイルシステムライブラリをサポートしていないことから、未検証のサンプルコード・出力となっている。
@@ -96,6 +100,6 @@ Windowsでの例は、Visual C++が正式にファイルシステムライブラ
 - C++17
 
 ### 処理系
-- [Clang](/implementation.md#clang):
+- [Clang](/implementation.md#clang): 9.0
 - [GCC](/implementation.md#gcc): 8.1
 - [Visual C++](/implementation.md#visual_cpp):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>