<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2026-02-08T09:25:38.171213</updated>
  <id>92084256-7aac-4c1f-b043-7ec2a3edbd8c</id>

  
    <entry>
      <title>state -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/task/state.html"/>
      <id>66e82dbb7a6661030f8d3c423991029269fd587f:reference/execution/execution/task/state.md</id>
      <updated>2026-02-08T18:20:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/task/state.md b/reference/execution/execution/task/state.md
index 6d4e38520..1f11d8307 100644
--- a/reference/execution/execution/task/state.md
+++ b/reference/execution/execution/task/state.md
@@ -1,4 +1,5 @@
 # state
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>queryable -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/queryable.html"/>
      <id>66e82dbb7a6661030f8d3c423991029269fd587f:reference/execution/queryable.md</id>
      <updated>2026-02-08T18:20:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/queryable.md b/reference/execution/queryable.md
index 590a415b7..a2bc7a73e 100644
--- a/reference/execution/queryable.md
+++ b/reference/execution/queryable.md
@@ -1,4 +1,5 @@
 # queryable
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>callable -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/functional/callable.html"/>
      <id>66e82dbb7a6661030f8d3c423991029269fd587f:reference/functional/callable.md</id>
      <updated>2026-02-08T18:20:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/callable.md b/reference/functional/callable.md
index 29ca46abb..217612955 100644
--- a/reference/functional/callable.md
+++ b/reference/functional/callable.md
@@ -1,4 +1,5 @@
 # callable
+* [meta exposition-only]
 * functional[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-integer-like -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/iterator/is_integer_like.html"/>
      <id>66e82dbb7a6661030f8d3c423991029269fd587f:reference/iterator/is_integer_like.md</id>
      <updated>2026-02-08T18:20:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/is_integer_like.md b/reference/iterator/is_integer_like.md
index 4b245bce2..f0c16dfc4 100644
--- a/reference/iterator/is_integer_like.md
+++ b/reference/iterator/is_integer_like.md
@@ -1,4 +1,5 @@
 # is-integer-like
+* [meta exposition-only]
 * iterator[meta header]
 * std[meta namespace]
 * variable[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>addable -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/addable.html"/>
      <id>66e82dbb7a6661030f8d3c423991029269fd587f:reference/linalg/addable.md</id>
      <updated>2026-02-08T18:20:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/addable.md b/reference/linalg/addable.md
index 1daecc06a..392a14c02 100644
--- a/reference/linalg/addable.md
+++ b/reference/linalg/addable.md
@@ -1,4 +1,5 @@
 # addable
+* [meta exposition-only]
 * linalg[meta header]
 * function template[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>multipliable -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/multipliable.html"/>
      <id>66e82dbb7a6661030f8d3c423991029269fd587f:reference/linalg/multipliable.md</id>
      <updated>2026-02-08T18:20:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/multipliable.md b/reference/linalg/multipliable.md
index c334e2ad0..cefafe7bc 100644
--- a/reference/linalg/multipliable.md
+++ b/reference/linalg/multipliable.md
@@ -1,4 +1,5 @@
 # multipliable
+* [meta exposition-only]
 * [mathjax enable]
 * linalg[meta header]
 * function template[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copyable-box -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/copyable_box.html"/>
      <id>66e82dbb7a6661030f8d3c423991029269fd587f:reference/ranges/copyable_box.md</id>
      <updated>2026-02-08T18:20:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/copyable_box.md b/reference/ranges/copyable_box.md
index f75ffd342..b1ed1da1e 100644
--- a/reference/ranges/copyable_box.md
+++ b/reference/ranges/copyable_box.md
@@ -1,4 +1,5 @@
 # copyable-box
+* [meta exposition-only]
 * ranges[meta header]
 * class template[meta id-type]
 * cpp20[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>movable-box -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/movable_box.html"/>
      <id>66e82dbb7a6661030f8d3c423991029269fd587f:reference/ranges/movable_box.md</id>
      <updated>2026-02-08T18:20:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/movable_box.md b/reference/ranges/movable_box.md
index 40a72fd5a..f27617132 100644
--- a/reference/ranges/movable_box.md
+++ b/reference/ranges/movable_box.md
@@ -1,4 +1,5 @@
 # movable-box
+* [meta exposition-only]
 * ranges[meta header]
 * class template[meta id-type]
 * cpp23[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>local-time-format-t -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/chrono/local-time-format-t.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/chrono/local-time-format-t.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/local-time-format-t.md b/reference/chrono/local-time-format-t.md
index 6f49a0d7a..94f08f356 100644
--- a/reference/chrono/local-time-format-t.md
+++ b/reference/chrono/local-time-format-t.md
@@ -1,4 +1,5 @@
 # local-time-format-t
+* [meta exposition-only]
 * chrono[meta header]
 * std::chrono[meta namespace]
 * class[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>class-type -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/class-type.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/class-type.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/class-type.md b/reference/execution/class-type.md
index 0793ba4f0..b3cb06e07 100644
--- a/reference/execution/class-type.md
+++ b/reference/execution/class-type.md
@@ -1,4 +1,5 @@
 # class-type
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>decays-to -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/decays-to.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/decays-to.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/decays-to.md b/reference/execution/decays-to.md
index e0b208bdb..05e9ef671 100644
--- a/reference/execution/decays-to.md
+++ b/reference/execution/decays-to.md
@@ -1,4 +1,5 @@
 # decays-to
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution-policy -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution-policy.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution-policy.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution-policy.md b/reference/execution/execution-policy.md
index 635cbc8f0..c85cb7e5b 100644
--- a/reference/execution/execution-policy.md
+++ b/reference/execution/execution-policy.md
@@ -1,4 +1,5 @@
 # execution-policy
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator-aware-forward -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/allocator-aware-forward.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/allocator-aware-forward.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/allocator-aware-forward.md b/reference/execution/execution/allocator-aware-forward.md
index 4637c1d7d..7773fc1a1 100644
--- a/reference/execution/execution/allocator-aware-forward.md
+++ b/reference/execution/execution/allocator-aware-forward.md
@@ -1,4 +1,5 @@
 # allocator-aware-forward
+* [meta exposition-only]
 * execution[meta header]
 * function template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>association-t -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/association-t.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/association-t.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/association-t.md b/reference/execution/execution/association-t.md
index f7becb8b2..a530bac42 100644
--- a/reference/execution/execution/association-t.md
+++ b/reference/execution/execution/association-t.md
@@ -1,9 +1,9 @@
 # association-t
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 template &amp;lt;class Scope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic-operation -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/basic-operation.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/basic-operation.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/basic-operation.md b/reference/execution/execution/basic-operation.md
index 865e8143b..0f7c1038a 100644
--- a/reference/execution/execution/basic-operation.md
+++ b/reference/execution/execution/basic-operation.md
@@ -1,4 +1,5 @@
 # basic-operation
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic-receiver -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/basic-receiver.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/basic-receiver.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/basic-receiver.md b/reference/execution/execution/basic-receiver.md
index ceac2741d..75181f9a5 100644
--- a/reference/execution/execution/basic-receiver.md
+++ b/reference/execution/execution/basic-receiver.md
@@ -1,4 +1,5 @@
 # basic-receiver
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic-sender -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/basic-sender.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/basic-sender.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/basic-sender.md b/reference/execution/execution/basic-sender.md
index 040b32870..247924c43 100644
--- a/reference/execution/execution/basic-sender.md
+++ b/reference/execution/execution/basic-sender.md
@@ -1,9 +1,9 @@
 # basic-sender
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 namespace std::execution {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>child-type -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/child-type.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/child-type.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/child-type.md b/reference/execution/execution/child-type.md
index c876ab739..3907b2d8c 100644
--- a/reference/execution/execution/child-type.md
+++ b/reference/execution/execution/child-type.md
@@ -1,4 +1,5 @@
 # child-type
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * type-alias[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>completion-domain -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/completion-domain.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/completion-domain.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/completion-domain.md b/reference/execution/execution/completion-domain.md
index 2d83422ca..d0882c24e 100644
--- a/reference/execution/execution/completion-domain.md
+++ b/reference/execution/execution/completion-domain.md
@@ -1,4 +1,5 @@
 # completion-domain
+* [meta exposition-only]
 * execution[meta header]
 * function template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>start-join-sender -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/counting_scope/start-join-sender.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/counting_scope/start-join-sender.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/counting_scope/start-join-sender.md b/reference/execution/execution/counting_scope/start-join-sender.md
index e011cf86c..318420e84 100644
--- a/reference/execution/execution/counting_scope/start-join-sender.md
+++ b/reference/execution/execution/counting_scope/start-join-sender.md
@@ -1,4 +1,5 @@
 # start-join-sender
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * counting_scope[meta class]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try-associate -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/counting_scope/try-associate.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/counting_scope/try-associate.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/counting_scope/try-associate.md b/reference/execution/execution/counting_scope/try-associate.md
index e4cd788c4..c709d8df3 100644
--- a/reference/execution/execution/counting_scope/try-associate.md
+++ b/reference/execution/execution/counting_scope/try-associate.md
@@ -1,10 +1,10 @@
 # try-associate
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * counting_scope[meta class]
 * function[meta id-type]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 assoc-t try-associate() noexcept; // exposition only
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>data-type -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/data-type.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/data-type.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/data-type.md b/reference/execution/execution/data-type.md
index 897641f98..d141f4e47 100644
--- a/reference/execution/execution/data-type.md
+++ b/reference/execution/execution/data-type.md
@@ -1,4 +1,5 @@
 # data-type
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * type-alias[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>decay-copyable-result-datums -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/decay-copyable-result-datums.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/decay-copyable-result-datums.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/decay-copyable-result-datums.md b/reference/execution/execution/decay-copyable-result-datums.md
index c87d03c94..617fcbce5 100644
--- a/reference/execution/execution/decay-copyable-result-datums.md
+++ b/reference/execution/execution/decay-copyable-result-datums.md
@@ -1,9 +1,9 @@
 # decay-copyable-result-datums
+* [meta exposition-only]
 * execution[meta header]
 * function template[meta id-type]
 * std::execution[meta namespace]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 constexpr void decay-copyable-result-datums(auto cs) {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>decayed-tuple -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/decayed-tuple.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/decayed-tuple.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/decayed-tuple.md b/reference/execution/execution/decayed-tuple.md
index bb7104265..ade063fb2 100644
--- a/reference/execution/execution/decayed-tuple.md
+++ b/reference/execution/execution/decayed-tuple.md
@@ -1,4 +1,5 @@
 # decayed-tuple
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * type-alias[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace-from -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/emplace-from.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/emplace-from.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/emplace-from.md b/reference/execution/execution/emplace-from.md
index b7eec6377..8fbe603eb 100644
--- a/reference/execution/execution/emplace-from.md
+++ b/reference/execution/execution/emplace-from.md
@@ -1,4 +1,5 @@
 # emplace-from
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * class template[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>env-promise -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/env-promise.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/env-promise.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/env-promise.md b/reference/execution/execution/env-promise.md
index dd745db64..844786dce 100644
--- a/reference/execution/execution/env-promise.md
+++ b/reference/execution/execution/env-promise.md
@@ -1,4 +1,5 @@
 # env-promise
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gather-signatures -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/gather-signatures.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/gather-signatures.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/gather-signatures.md b/reference/execution/execution/gather-signatures.md
index 9d41f78b4..3dbee3589 100644
--- a/reference/execution/execution/gather-signatures.md
+++ b/reference/execution/execution/gather-signatures.md
@@ -1,4 +1,5 @@
 # gather-signatures
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * type-alias[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get-domain-early -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/get-domain-early.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/get-domain-early.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/get-domain-early.md b/reference/execution/execution/get-domain-early.md
index bdcfebfa0..257327af6 100644
--- a/reference/execution/execution/get-domain-early.md
+++ b/reference/execution/execution/get-domain-early.md
@@ -1,4 +1,5 @@
 # get-domain-early
+* [meta exposition-only]
 * execution[meta header]
 * function template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get-domain-late -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/get-domain-late.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/get-domain-late.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/get-domain-late.md b/reference/execution/execution/get-domain-late.md
index 20eb3fe6b..5b5462385 100644
--- a/reference/execution/execution/get-domain-late.md
+++ b/reference/execution/execution/get-domain-late.md
@@ -1,4 +1,5 @@
 # get-domain-late
+* [meta exposition-only]
 * execution[meta header]
 * function template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>impls-for -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/impls-for.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/impls-for.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/impls-for.md b/reference/execution/execution/impls-for.md
index 33c705a1b..5b10dbabb 100644
--- a/reference/execution/execution/impls-for.md
+++ b/reference/execution/execution/impls-for.md
@@ -1,4 +1,5 @@
 # impls-for
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make-sender -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/make-sender.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/make-sender.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/make-sender.md b/reference/execution/execution/make-sender.md
index bb9542234..f8e01ee94 100644
--- a/reference/execution/execution/make-sender.md
+++ b/reference/execution/execution/make-sender.md
@@ -1,9 +1,9 @@
 # make-sender
+* [meta exposition-only]
 * execution[meta header]
 * function template[meta id-type]
 * std::execution[meta namespace]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 template&amp;lt;class Tag, class Data = see below, class... Child&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>not-a-sender -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/not-a-sender.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/not-a-sender.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/not-a-sender.md b/reference/execution/execution/not-a-sender.md
index 49f06ffe6..4dd328437 100644
--- a/reference/execution/execution/not-a-sender.md
+++ b/reference/execution/execution/not-a-sender.md
@@ -1,9 +1,9 @@
 # not-a-sender
+* [meta exposition-only]
 * execution[meta header]
 * class[meta id-type]
 * std::execution[meta namespace]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 struct not-a-sender {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>on-stop-request -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/on-stop-request.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/on-stop-request.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/on-stop-request.md b/reference/execution/execution/on-stop-request.md
index 06ad7d68c..c3a220a2d 100644
--- a/reference/execution/execution/on-stop-request.md
+++ b/reference/execution/execution/on-stop-request.md
@@ -1,4 +1,5 @@
 # on-stop-request
+* [meta exposition-only]
 * execution[meta header]
 * class[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>overload-set -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/overload-set.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/overload-set.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/overload-set.md b/reference/execution/execution/overload-set.md
index ae04ed5bd..afcd1a45c 100644
--- a/reference/execution/execution/overload-set.md
+++ b/reference/execution/execution/overload-set.md
@@ -1,4 +1,5 @@
 # overload-set
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>product-type -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/product-type.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/product-type.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/product-type.md b/reference/execution/execution/product-type.md
index 741df2bbd..4fa6bd394 100644
--- a/reference/execution/execution/product-type.md
+++ b/reference/execution/execution/product-type.md
@@ -1,4 +1,5 @@
 # product-type
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>query-with-default -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/query-with-default.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/query-with-default.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/query-with-default.md b/reference/execution/execution/query-with-default.md
index 8df81e402..ce26e6a60 100644
--- a/reference/execution/execution/query-with-default.md
+++ b/reference/execution/execution/query-with-default.md
@@ -1,4 +1,5 @@
 # query-with-default
+* [meta exposition-only]
 * execution[meta header]
 * function template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>run-loop-opstate -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/run_loop/run-loop-opstate.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/run_loop/run-loop-opstate.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/run_loop/run-loop-opstate.md b/reference/execution/execution/run_loop/run-loop-opstate.md
index 75a4389a1..8d5d921b6 100644
--- a/reference/execution/execution/run_loop/run-loop-opstate.md
+++ b/reference/execution/execution/run_loop/run-loop-opstate.md
@@ -1,4 +1,5 @@
 # run-loop-opstate
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * run_loop[meta class]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>run-loop-scheduler -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/run_loop/run-loop-scheduler.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/run_loop/run-loop-scheduler.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/run_loop/run-loop-scheduler.md b/reference/execution/execution/run_loop/run-loop-scheduler.md
index a1b154a04..25bbbf016 100644
--- a/reference/execution/execution/run_loop/run-loop-scheduler.md
+++ b/reference/execution/execution/run_loop/run-loop-scheduler.md
@@ -1,4 +1,5 @@
 # run-loop-scheduler
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * run_loop[meta class]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>run-loop-sender -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/run_loop/run-loop-sender.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/run_loop/run-loop-sender.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/run_loop/run-loop-sender.md b/reference/execution/execution/run_loop/run-loop-sender.md
index 059a36fb9..c295aa5f8 100644
--- a/reference/execution/execution/run_loop/run-loop-sender.md
+++ b/reference/execution/execution/run_loop/run-loop-sender.md
@@ -1,4 +1,5 @@
 # run-loop-sender
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * run_loop[meta class]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sender-for -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/sender-for.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/sender-for.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/sender-for.md b/reference/execution/execution/sender-for.md
index 1caf041e5..04fde6ab1 100644
--- a/reference/execution/execution/sender-for.md
+++ b/reference/execution/execution/sender-for.md
@@ -1,4 +1,5 @@
 # sender-for
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sender-in-of -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/sender-in-of.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/sender-in-of.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/sender-in-of.md b/reference/execution/execution/sender-in-of.md
index 72721a6a4..51c3a8543 100644
--- a/reference/execution/execution/sender-in-of.md
+++ b/reference/execution/execution/sender-in-of.md
@@ -1,4 +1,5 @@
 # sender-in-of
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>start-join-sender -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/simple_counting_scope/start-join-sender.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/simple_counting_scope/start-join-sender.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/simple_counting_scope/start-join-sender.md b/reference/execution/execution/simple_counting_scope/start-join-sender.md
index cf58d30d9..fc83c74a0 100644
--- a/reference/execution/execution/simple_counting_scope/start-join-sender.md
+++ b/reference/execution/execution/simple_counting_scope/start-join-sender.md
@@ -1,4 +1,5 @@
 # start-join-sender
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * simple_counting_scope[meta class]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try-associate -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/simple_counting_scope/try-associate.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/simple_counting_scope/try-associate.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/simple_counting_scope/try-associate.md b/reference/execution/execution/simple_counting_scope/try-associate.md
index b7f2d7806..eb2d8e16c 100644
--- a/reference/execution/execution/simple_counting_scope/try-associate.md
+++ b/reference/execution/execution/simple_counting_scope/try-associate.md
@@ -1,10 +1,10 @@
 # try-associate
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * simple_counting_scope[meta class]
 * function[meta id-type]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 assoc-t try-associate() noexcept; // exposition only
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>single-sender-value-type -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/single-sender-value-type.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/single-sender-value-type.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/single-sender-value-type.md b/reference/execution/execution/single-sender-value-type.md
index 454ad9b16..743a9e352 100644
--- a/reference/execution/execution/single-sender-value-type.md
+++ b/reference/execution/execution/single-sender-value-type.md
@@ -1,9 +1,9 @@
 # single-sender-value-type
+* [meta exposition-only]
 * execution[meta header]
 * type-alias[meta id-type]
 * std::execution[meta namespace]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 template&amp;lt;class Sndr, class... Env&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>single-sender -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/single-sender.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/single-sender.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/single-sender.md b/reference/execution/execution/single-sender.md
index ce983b79e..d82ded1a7 100644
--- a/reference/execution/execution/single-sender.md
+++ b/reference/execution/execution/single-sender.md
@@ -1,4 +1,5 @@
 # single-sender
+* [meta exposition-only]
 * execution[meta header]
 * type-alias[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stop-when -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/stop-when.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/stop-when.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/stop-when.md b/reference/execution/execution/stop-when.md
index fbe73234f..3c9d02629 100644
--- a/reference/execution/execution/stop-when.md
+++ b/reference/execution/execution/stop-when.md
@@ -1,9 +1,9 @@
 # stop-when
+* [meta exposition-only]
 * execution[meta header]
 * cpo[meta id-type]
 * std::execution[meta namespace]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 namespace std::execution {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>type-list -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/type-list.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/type-list.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/type-list.md b/reference/execution/execution/type-list.md
index d54a46203..fd69d8e60 100644
--- a/reference/execution/execution/type-list.md
+++ b/reference/execution/execution/type-list.md
@@ -1,4 +1,5 @@
 # type-list
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unspecified-exception -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/unspecified-exception.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/unspecified-exception.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/unspecified-exception.md b/reference/execution/execution/unspecified-exception.md
index 23972caff..9a19f6c4e 100644
--- a/reference/execution/execution/unspecified-exception.md
+++ b/reference/execution/execution/unspecified-exception.md
@@ -1,9 +1,9 @@
 # unspecified-exception
+* [meta exposition-only]
 * execution[meta header]
 * class[meta id-type]
 * std::execution[meta namespace]
 * cpp26[meta cpp]
-* [meta exposition-only]
 
 ```cpp
 class unspecified-exception;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>variant-or-empty -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/variant-or-empty.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/variant-or-empty.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/variant-or-empty.md b/reference/execution/execution/variant-or-empty.md
index e77014c3f..59ae5a739 100644
--- a/reference/execution/execution/variant-or-empty.md
+++ b/reference/execution/execution/variant-or-empty.md
@@ -1,4 +1,5 @@
 # variant-or-empty
+* [meta exposition-only]
 * execution[meta header]
 * std::execution[meta namespace]
 * type-alias[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>with-await-transform -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/with-await-transform.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/execution/with-await-transform.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/with-await-transform.md b/reference/execution/execution/with-await-transform.md
index 39fbfe496..70160141c 100644
--- a/reference/execution/execution/with-await-transform.md
+++ b/reference/execution/execution/with-await-transform.md
@@ -1,4 +1,5 @@
 # with-await-transform
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::execution[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>forwarding-query -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/forwarding-query.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/forwarding-query.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/forwarding-query.md b/reference/execution/forwarding-query.md
index bc1f240df..96c3649f6 100644
--- a/reference/execution/forwarding-query.md
+++ b/reference/execution/forwarding-query.md
@@ -1,4 +1,5 @@
 # forwarding-query
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-awaitable -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/is-awaitable.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/is-awaitable.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/is-awaitable.md b/reference/execution/is-awaitable.md
index 0db175a0b..f9d6ccf55 100644
--- a/reference/execution/is-awaitable.md
+++ b/reference/execution/is-awaitable.md
@@ -1,4 +1,5 @@
 # is-awaitable
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>movable-value -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/movable-value.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/movable-value.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/movable-value.md b/reference/execution/movable-value.md
index df9ad0534..fcda43c25 100644
--- a/reference/execution/movable-value.md
+++ b/reference/execution/movable-value.md
@@ -1,4 +1,5 @@
 # movable-value
+* [meta exposition-only]
 * execution[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sync-wait-env -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/this_thread/sync-wait-env.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/this_thread/sync-wait-env.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/this_thread/sync-wait-env.md b/reference/execution/this_thread/sync-wait-env.md
index aa20456ce..a5c950a89 100644
--- a/reference/execution/this_thread/sync-wait-env.md
+++ b/reference/execution/this_thread/sync-wait-env.md
@@ -1,4 +1,5 @@
 # sync-wait-env
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::this_thread[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sync-wait-receiver -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/execution/this_thread/sync-wait-receiver.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/execution/this_thread/sync-wait-receiver.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/this_thread/sync-wait-receiver.md b/reference/execution/this_thread/sync-wait-receiver.md
index baa38762d..ce539eae4 100644
--- a/reference/execution/this_thread/sync-wait-receiver.md
+++ b/reference/execution/this_thread/sync-wait-receiver.md
@@ -1,4 +1,5 @@
 # sync-wait-receiver
+* [meta exposition-only]
 * execution[meta header]
 * class template[meta id-type]
 * std::this_thread[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>container-compatible-range -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/exposition-only/container-compatible-range.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/exposition-only/container-compatible-range.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/exposition-only/container-compatible-range.md b/reference/exposition-only/container-compatible-range.md
index c2bb8c14f..3d3ac1186 100644
--- a/reference/exposition-only/container-compatible-range.md
+++ b/reference/exposition-only/container-compatible-range.md
@@ -1,4 +1,5 @@
 # container-compatible-range
+* [meta exposition-only]
 * exposition-only[meta header]
 * concept[meta id-type]
 * cpp23[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>decay-copy -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/exposition-only/decay-copy.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/exposition-only/decay-copy.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/exposition-only/decay-copy.md b/reference/exposition-only/decay-copy.md
index d8993b53e..b9dc21221 100644
--- a/reference/exposition-only/decay-copy.md
+++ b/reference/exposition-only/decay-copy.md
@@ -1,4 +1,5 @@
 # decay-copy
+* [meta exposition-only]
 * exposition-only[meta header]
 * function[meta id-type]
 * cpp20[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>synth-three-way-result -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/exposition-only/synth-three-way-result.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/exposition-only/synth-three-way-result.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/exposition-only/synth-three-way-result.md b/reference/exposition-only/synth-three-way-result.md
index efdedf359..540bcc8a2 100644
--- a/reference/exposition-only/synth-three-way-result.md
+++ b/reference/exposition-only/synth-three-way-result.md
@@ -1,4 +1,5 @@
 # synth-three-way-result
+* [meta exposition-only]
 * exposition-only[meta header]
 * function[meta id-type]
 * cpp20[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>const-formattable-range -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/format/const-formattable-range.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/format/const-formattable-range.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/const-formattable-range.md b/reference/format/const-formattable-range.md
index 48ab057c2..da4ceaf89 100644
--- a/reference/format/const-formattable-range.md
+++ b/reference/format/const-formattable-range.md
@@ -1,4 +1,5 @@
 # const-formattable-range
+* [meta exposition-only]
 * format[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmt-maybe-const -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/format/fmt-maybe-const.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/format/fmt-maybe-const.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/fmt-maybe-const.md b/reference/format/fmt-maybe-const.md
index 83bb3e20d..122d6ed44 100644
--- a/reference/format/fmt-maybe-const.md
+++ b/reference/format/fmt-maybe-const.md
@@ -1,4 +1,5 @@
 # fmt-maybe-const
+* [meta exposition-only]
 * format[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>range-default-formatter -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/format/range-default-formatter.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/format/range-default-formatter.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range-default-formatter.md b/reference/format/range-default-formatter.md
index 24ecc0f39..32abc6dc6 100644
--- a/reference/format/range-default-formatter.md
+++ b/reference/format/range-default-formatter.md
@@ -1,4 +1,5 @@
 # range-default-formatter
+* [meta exposition-only]
 * format[meta header]
 * class template[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>runtime-format-string -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/format/runtime-format-string.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/format/runtime-format-string.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/runtime-format-string.md b/reference/format/runtime-format-string.md
index 6c15e789b..5ae03569b 100644
--- a/reference/format/runtime-format-string.md
+++ b/reference/format/runtime-format-string.md
@@ -1,4 +1,5 @@
 # runtime-format-string
+* [meta exposition-only]
 * format[meta header]
 * class[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>call-result-t -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/functional/call-result-t.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/functional/call-result-t.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/call-result-t.md b/reference/functional/call-result-t.md
index bccac0051..28bc345e8 100644
--- a/reference/functional/call-result-t.md
+++ b/reference/functional/call-result-t.md
@@ -1,4 +1,5 @@
 # call-result-t
+* [meta exposition-only]
 * functional[meta header]
 * type-alias[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>decayed-typeof -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/functional/decayed-typeof.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/functional/decayed-typeof.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/decayed-typeof.md b/reference/functional/decayed-typeof.md
index 6c243dc42..a919d3219 100644
--- a/reference/functional/decayed-typeof.md
+++ b/reference/functional/decayed-typeof.md
@@ -1,4 +1,5 @@
 # decayed-typeof
+* [meta exposition-only]
 * functional[meta header]
 * type-alias[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nothrow-callable -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/functional/nothrow-callable.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/functional/nothrow-callable.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/nothrow-callable.md b/reference/functional/nothrow-callable.md
index 836c61e12..2351cee76 100644
--- a/reference/functional/nothrow-callable.md
+++ b/reference/functional/nothrow-callable.md
@@ -1,4 +1,5 @@
 # nothrow-callable
+* [meta exposition-only]
 * functional[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>constant-iterator -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/iterator/constant-iterator.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/iterator/constant-iterator.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/constant-iterator.md b/reference/iterator/constant-iterator.md
index c0603449a..7e35526a4 100644
--- a/reference/iterator/constant-iterator.md
+++ b/reference/iterator/constant-iterator.md
@@ -1,4 +1,5 @@
 # constant-iterator
+* [meta exposition-only]
 * iterator[meta header]
 * std[meta namespace]
 * concept[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs-if-needed -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/abs-if-needed.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/abs-if-needed.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/abs-if-needed.md b/reference/linalg/abs-if-needed.md
index f753c87cc..5eb5819f2 100644
--- a/reference/linalg/abs-if-needed.md
+++ b/reference/linalg/abs-if-needed.md
@@ -1,5 +1,5 @@
 # abs-if-needed
-
+* [meta exposition-only]
 * linalg[meta header]
 * function[meta id-type]
 * std::linalg[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compatible-static-extents -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/compatible-static-extents.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/compatible-static-extents.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/compatible-static-extents.md b/reference/linalg/compatible-static-extents.md
index 229c80665..ef0f633d4 100644
--- a/reference/linalg/compatible-static-extents.md
+++ b/reference/linalg/compatible-static-extents.md
@@ -1,4 +1,5 @@
 # compatible-static-extents
+* [meta exposition-only]
 * linalg[meta header]
 * function template[meta id-type]
 * std::linalg[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>conj-if-needed -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conj-if-needed.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/conj-if-needed.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conj-if-needed.md b/reference/linalg/conj-if-needed.md
index ca2011d3d..5b0874d8d 100644
--- a/reference/linalg/conj-if-needed.md
+++ b/reference/linalg/conj-if-needed.md
@@ -1,4 +1,5 @@
 # conj-if-needed
+* [meta exposition-only]
 * linalg[meta header]
 * function[meta id-type]
 * std::linalg[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>imag-if-needed -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/imag-if-needed.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/imag-if-needed.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/imag-if-needed.md b/reference/linalg/imag-if-needed.md
index d147a6e19..d3337550d 100644
--- a/reference/linalg/imag-if-needed.md
+++ b/reference/linalg/imag-if-needed.md
@@ -1,5 +1,5 @@
 # imag-if-needed
-
+* [meta exposition-only]
 * linalg[meta header]
 * function[meta id-type]
 * std::linalg[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in-matrix, out-matrix, inout-matrix -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/inout-matrix.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/inout-matrix.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/inout-matrix.md b/reference/linalg/inout-matrix.md
index 3d3e8ab98..13ddac094 100644
--- a/reference/linalg/inout-matrix.md
+++ b/reference/linalg/inout-matrix.md
@@ -1,4 +1,5 @@
 # in-matrix, out-matrix, inout-matrix
+* [meta exposition-only]
 * linalg[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in-object, out-object, inout-object -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/inout-object.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/inout-object.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/inout-object.md b/reference/linalg/inout-object.md
index 679d7daf7..fd649f9ac 100644
--- a/reference/linalg/inout-object.md
+++ b/reference/linalg/inout-object.md
@@ -1,4 +1,5 @@
 # in-object, out-object, inout-object
+* [meta exposition-only]
 * linalg[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in-vector, out-vector, inout-vector -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/inout-vector.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/inout-vector.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/inout-vector.md b/reference/linalg/inout-vector.md
index 17837f217..ab4f5ca58 100644
--- a/reference/linalg/inout-vector.md
+++ b/reference/linalg/inout-vector.md
@@ -1,4 +1,5 @@
 # in-vector, out-vector, inout-vector
+* [meta exposition-only]
 * linalg[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-mdspan -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/is-mdspan.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/is-mdspan.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/is-mdspan.md b/reference/linalg/is-mdspan.md
index df437ebd9..4201b7ab4 100644
--- a/reference/linalg/is-mdspan.md
+++ b/reference/linalg/is-mdspan.md
@@ -1,4 +1,5 @@
 # is-mdspan
+* [meta exposition-only]
 * linalg[meta header]
 * variable[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transpose-extents -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_transpose/transpose-extents.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/layout_transpose/transpose-extents.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_transpose/transpose-extents.md b/reference/linalg/layout_transpose/transpose-extents.md
index 0ce6db870..794746724 100644
--- a/reference/linalg/layout_transpose/transpose-extents.md
+++ b/reference/linalg/layout_transpose/transpose-extents.md
@@ -1,4 +1,5 @@
 # transpose-extents
+* [meta exposition-only]
 * linalg[meta header]
 * function template[meta id-type]
 * std::linalg[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>possibly-addable -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/possibly-addable.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/possibly-addable.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/possibly-addable.md b/reference/linalg/possibly-addable.md
index eef28e3ad..4fd3d3a6a 100644
--- a/reference/linalg/possibly-addable.md
+++ b/reference/linalg/possibly-addable.md
@@ -1,4 +1,5 @@
 # possibly-addable
+* [meta exposition-only]
 * linalg[meta header]
 * function template[meta id-type]
 * std::linalg[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>possibly-multipliable -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/possibly-multipliable.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/possibly-multipliable.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/possibly-multipliable.md b/reference/linalg/possibly-multipliable.md
index 824b1a69a..cdbc3422d 100644
--- a/reference/linalg/possibly-multipliable.md
+++ b/reference/linalg/possibly-multipliable.md
@@ -1,4 +1,5 @@
 # possibly-multipliable
+* [meta exposition-only]
 * [mathjax enable]
 * linalg[meta header]
 * function template[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>possibly-packed-inout-matrix -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/possibly-packed-inout-matrix.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/possibly-packed-inout-matrix.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/possibly-packed-inout-matrix.md b/reference/linalg/possibly-packed-inout-matrix.md
index df39fe9d1..e999838df 100644
--- a/reference/linalg/possibly-packed-inout-matrix.md
+++ b/reference/linalg/possibly-packed-inout-matrix.md
@@ -1,4 +1,5 @@
 # possibly-packed-inout-matrix
+* [meta exposition-only]
 * linalg[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>real-if-needed -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/real-if-needed.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/linalg/real-if-needed.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/real-if-needed.md b/reference/linalg/real-if-needed.md
index dd396d8b5..91eecc493 100644
--- a/reference/linalg/real-if-needed.md
+++ b/reference/linalg/real-if-needed.md
@@ -1,5 +1,5 @@
 # real-if-needed
-
+* [meta exposition-only]
 * linalg[meta header]
 * function[meta id-type]
 * std::linalg[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>de-ice -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/de-ice.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/mdspan/de-ice.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/de-ice.md b/reference/mdspan/de-ice.md
index 9d555cf63..7c1c85355 100644
--- a/reference/mdspan/de-ice.md
+++ b/reference/mdspan/de-ice.md
@@ -1,4 +1,5 @@
 # de-ice
+* [meta exposition-only]
 * mdspan[meta header]
 * function template[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>index-cast -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/extents/index-cast.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/mdspan/extents/index-cast.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/extents/index-cast.md b/reference/mdspan/extents/index-cast.md
index c34351766..7ae05cdba 100644
--- a/reference/mdspan/extents/index-cast.md
+++ b/reference/mdspan/extents/index-cast.md
@@ -1,4 +1,5 @@
 # index-cast
+* [meta exposition-only]
 * mdspan[meta header]
 * function template[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>index-pair-like -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/index-pair-like.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/mdspan/index-pair-like.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/index-pair-like.md b/reference/mdspan/index-pair-like.md
index b055196da..ea500844e 100644
--- a/reference/mdspan/index-pair-like.md
+++ b/reference/mdspan/index-pair-like.md
@@ -1,4 +1,5 @@
 # index-pair-like
+* [meta exposition-only]
 * mdspan[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-layout-left-padded-mapping-of -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/is-layout-left-padded-mapping-of.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/mdspan/is-layout-left-padded-mapping-of.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/is-layout-left-padded-mapping-of.md b/reference/mdspan/is-layout-left-padded-mapping-of.md
index 1bd50f81e..eca79f4b3 100644
--- a/reference/mdspan/is-layout-left-padded-mapping-of.md
+++ b/reference/mdspan/is-layout-left-padded-mapping-of.md
@@ -1,4 +1,5 @@
 # is-layout-left-padded-mapping-of
+* [meta exposition-only]
 * mdspan[meta header]
 * variable[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-layout-right-padded-mapping-of -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/is-layout-right-padded-mapping-of.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/mdspan/is-layout-right-padded-mapping-of.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/is-layout-right-padded-mapping-of.md b/reference/mdspan/is-layout-right-padded-mapping-of.md
index de8a0f38a..9592644d4 100644
--- a/reference/mdspan/is-layout-right-padded-mapping-of.md
+++ b/reference/mdspan/is-layout-right-padded-mapping-of.md
@@ -1,4 +1,5 @@
 # is-layout-right-padded-mapping-of
+* [meta exposition-only]
 * mdspan[meta header]
 * variable[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-mapping-of -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/is-mapping-of.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/mdspan/is-mapping-of.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/is-mapping-of.md b/reference/mdspan/is-mapping-of.md
index 546ed4033..76e58e6c5 100644
--- a/reference/mdspan/is-mapping-of.md
+++ b/reference/mdspan/is-mapping-of.md
@@ -1,4 +1,5 @@
 # is-mapping-of
+* [meta exposition-only]
 * mdspan[meta header]
 * variable[meta id-type]
 * cpp23[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>layout-mapping-alike -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/layout_stride/mapping/layout-mapping-alike.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/mdspan/layout_stride/mapping/layout-mapping-alike.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/layout_stride/mapping/layout-mapping-alike.md b/reference/mdspan/layout_stride/mapping/layout-mapping-alike.md
index 4a6db282e..d929675df 100644
--- a/reference/mdspan/layout_stride/mapping/layout-mapping-alike.md
+++ b/reference/mdspan/layout_stride/mapping/layout-mapping-alike.md
@@ -1,4 +1,5 @@
 # layout-mapping-alike
+* [meta exposition-only]
 * mdspan[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>src-indices -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/src-indices.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/mdspan/src-indices.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/src-indices.md b/reference/mdspan/src-indices.md
index 55ace153e..6e223978d 100644
--- a/reference/mdspan/src-indices.md
+++ b/reference/mdspan/src-indices.md
@@ -1,4 +1,5 @@
 # src-indices
+* [meta exposition-only]
 * mdspan[meta header]
 * function template[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-forward-iterator -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-forward-iterator.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/memory/no-throw-forward-iterator.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-forward-iterator.md b/reference/memory/no-throw-forward-iterator.md
index 6ed8ad4de..23c3e147a 100644
--- a/reference/memory/no-throw-forward-iterator.md
+++ b/reference/memory/no-throw-forward-iterator.md
@@ -1,4 +1,5 @@
 # no-throw-forward-iterator
+* [meta exposition-only]
 * memory[meta header]
 * std[meta namespace]
 * concept[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-forward-range -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-forward-range.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/memory/no-throw-forward-range.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-forward-range.md b/reference/memory/no-throw-forward-range.md
index 8b49d76c3..1d2303ecc 100644
--- a/reference/memory/no-throw-forward-range.md
+++ b/reference/memory/no-throw-forward-range.md
@@ -1,4 +1,5 @@
 # no-throw-forward-range
+* [meta exposition-only]
 * memory[meta header]
 * std[meta namespace]
 * concept[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-input-iterator -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-input-iterator.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/memory/no-throw-input-iterator.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-input-iterator.md b/reference/memory/no-throw-input-iterator.md
index 07f605762..cb4d2f8b3 100644
--- a/reference/memory/no-throw-input-iterator.md
+++ b/reference/memory/no-throw-input-iterator.md
@@ -1,4 +1,5 @@
 # no-throw-input-iterator
+* [meta exposition-only]
 * memory[meta header]
 * std[meta namespace]
 * concept[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-input-range -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-input-range.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/memory/no-throw-input-range.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-input-range.md b/reference/memory/no-throw-input-range.md
index 268284b22..fa6e0e476 100644
--- a/reference/memory/no-throw-input-range.md
+++ b/reference/memory/no-throw-input-range.md
@@ -1,4 +1,5 @@
 # no-throw-input-range
+* [meta exposition-only]
 * memory[meta header]
 * std[meta namespace]
 * concept[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-sentinel -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-sentinel.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/memory/no-throw-sentinel.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-sentinel.md b/reference/memory/no-throw-sentinel.md
index 8d8542a9d..65bf8db9c 100644
--- a/reference/memory/no-throw-sentinel.md
+++ b/reference/memory/no-throw-sentinel.md
@@ -1,4 +1,5 @@
 # no-throw-sentinel
+* [meta exposition-only]
 * memory[meta header]
 * std[meta namespace]
 * concept[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all-bidirectional -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/all-bidirectional.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/all-bidirectional.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/all-bidirectional.md b/reference/ranges/all-bidirectional.md
index 488437f49..1c7f9568f 100644
--- a/reference/ranges/all-bidirectional.md
+++ b/reference/ranges/all-bidirectional.md
@@ -1,4 +1,5 @@
 # all-bidirectional
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
@@ -12,7 +13,7 @@ namespace std::ranges {
 
 ## 概要
 
-`all-bidirectional` は、複数のビューに対し、それらすべてが [`bidirectional_range`](bidirectional_range.md) であることを表すコンセプトである。
+`all-bidirectional` は、複数のビューに対し、それらすべてが [`bidirectional_range`](bidirectional_range.md) であることを表す説明専用のコンセプトである。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all-forward -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/all-forward.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/all-forward.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/all-forward.md b/reference/ranges/all-forward.md
index 549ecd75c..927cdc518 100644
--- a/reference/ranges/all-forward.md
+++ b/reference/ranges/all-forward.md
@@ -1,4 +1,5 @@
 # all-forward
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
@@ -12,7 +13,7 @@ namespace std::ranges {
 
 ## 概要
 
-`all-forward` は、複数のビューに対し、それらすべてが [`forward_range`](forward_range.md) であることを表すコンセプトである。
+`all-forward` は、複数のビューに対し、それらすべてが [`forward_range`](forward_range.md) であることを表す説明専用のコンセプトである。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all-random-access -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/all-random-access.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/all-random-access.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/all-random-access.md b/reference/ranges/all-random-access.md
index 2751fd6d4..648b9e9e3 100644
--- a/reference/ranges/all-random-access.md
+++ b/reference/ranges/all-random-access.md
@@ -1,4 +1,5 @@
 # all-random-access
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
@@ -12,7 +13,7 @@ namespace std::ranges {
 
 ## 概要
 
-`all-random-access` は、複数のビューに対し、それらすべてが [`random_access_range`](random_access_range.md) であることを表すコンセプトである。
+`all-random-access` は、複数のビューに対し、それらすべてが [`random_access_range`](random_access_range.md) であることを表す説明専用のコンセプトである。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>as-lvalue -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/as-lvalue.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/as-lvalue.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/as-lvalue.md b/reference/ranges/as-lvalue.md
index 380efc8dc..c79ffa48c 100644
--- a/reference/ranges/as-lvalue.md
+++ b/reference/ranges/as-lvalue.md
@@ -1,4 +1,5 @@
 # as-lvalue
+* [meta exposition-only]
 * ranges[meta header]
 * function template[meta id-type]
 * cpp23[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>different-from -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/different-from.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/different-from.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/different-from.md b/reference/ranges/different-from.md
index 5b0b28e22..8fb0d6af6 100644
--- a/reference/ranges/different-from.md
+++ b/reference/ranges/different-from.md
@@ -1,4 +1,5 @@
 # different-from
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * cpp20[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>has-arrow -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/has-arrow.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/has-arrow.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/has-arrow.md b/reference/ranges/has-arrow.md
index 52d4d9a84..6613f2d50 100644
--- a/reference/ranges/has-arrow.md
+++ b/reference/ranges/has-arrow.md
@@ -1,4 +1,5 @@
 # has-arrow
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * cpp20[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>maybe-const -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/maybe-const.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/maybe-const.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/maybe-const.md b/reference/ranges/maybe-const.md
index 1acc3a80c..bb7cc9dc2 100644
--- a/reference/ranges/maybe-const.md
+++ b/reference/ranges/maybe-const.md
@@ -1,4 +1,5 @@
 # maybe-const
+* [meta exposition-only]
 * ranges[meta header]
 * type-alias[meta id-type]
 * cpp23[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>possibly-const-range -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/possibly-const-range.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/possibly-const-range.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/possibly-const-range.md b/reference/ranges/possibly-const-range.md
index 053b2a105..e1ee948d9 100644
--- a/reference/ranges/possibly-const-range.md
+++ b/reference/ranges/possibly-const-range.md
@@ -1,4 +1,5 @@
 # possibly-const-range
+* [meta exposition-only]
 * ranges[meta header]
 * std::ranges[meta namespace]
 * function[meta id-type]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>range-with-movable-references -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/range-with-movable-references.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/range-with-movable-references.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/range-with-movable-references.md b/reference/ranges/range-with-movable-references.md
index c068f0a47..61f557519 100644
--- a/reference/ranges/range-with-movable-references.md
+++ b/reference/ranges/range-with-movable-references.md
@@ -1,4 +1,5 @@
 # range-with-movable-references
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * cpp23[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>simple-view -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/simple-view.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/simple-view.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/simple-view.md b/reference/ranges/simple-view.md
index be96992ac..246a05391 100644
--- a/reference/ranges/simple-view.md
+++ b/reference/ranges/simple-view.md
@@ -1,4 +1,5 @@
 # simple-view
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * cpp20[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sized-random-access-range -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/sized-random-access-range.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/sized-random-access-range.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/sized-random-access-range.md b/reference/ranges/sized-random-access-range.md
index c6b5e78a6..1a51b2a22 100644
--- a/reference/ranges/sized-random-access-range.md
+++ b/reference/ranges/sized-random-access-range.md
@@ -1,4 +1,5 @@
 # sized-random-access-range
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * std::ranges[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>convertible-to-non-slicing -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/convertible-to-non-slicing.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/subrange/convertible-to-non-slicing.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/convertible-to-non-slicing.md b/reference/ranges/subrange/convertible-to-non-slicing.md
index d46fb555d..2d16d17b5 100644
--- a/reference/ranges/subrange/convertible-to-non-slicing.md
+++ b/reference/ranges/subrange/convertible-to-non-slicing.md
@@ -1,4 +1,5 @@
 # convertible-to-non-slicing
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * std::ranges[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pair-like-convertible-from -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/pair-like-convertible-from.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/subrange/pair-like-convertible-from.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/pair-like-convertible-from.md b/reference/ranges/subrange/pair-like-convertible-from.md
index 6d15d2fd9..25cee84ba 100644
--- a/reference/ranges/subrange/pair-like-convertible-from.md
+++ b/reference/ranges/subrange/pair-like-convertible-from.md
@@ -1,4 +1,5 @@
 # pair-like-convertible-from
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * std::ranges[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uses-nonqualification-pointer-conversion -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/uses-nonqualification-pointer-conversion.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/subrange/uses-nonqualification-pointer-conversion.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/uses-nonqualification-pointer-conversion.md b/reference/ranges/subrange/uses-nonqualification-pointer-conversion.md
index 7f1c3a6a2..85ee7f019 100644
--- a/reference/ranges/subrange/uses-nonqualification-pointer-conversion.md
+++ b/reference/ranges/subrange/uses-nonqualification-pointer-conversion.md
@@ -1,4 +1,5 @@
 # uses-nonqualification-pointer-conversion
+* [meta exposition-only]
 * ranges[meta header]
 * concept[meta id-type]
 * std::ranges[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple-for-each -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/tuple-for-each.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/tuple-for-each.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/tuple-for-each.md b/reference/ranges/tuple-for-each.md
index f4e570ca4..5cc6ded76 100644
--- a/reference/ranges/tuple-for-each.md
+++ b/reference/ranges/tuple-for-each.md
@@ -1,4 +1,5 @@
 # tuple-for-each
+* [meta exposition-only]
 * ranges[meta header]
 * function template[meta id-type]
 * cpp23[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple-transform -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/ranges/tuple-transform.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/ranges/tuple-transform.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/tuple-transform.md b/reference/ranges/tuple-transform.md
index b8c00a3c2..fd4c6f55a 100644
--- a/reference/ranges/tuple-transform.md
+++ b/reference/ranges/tuple-transform.md
@@ -1,4 +1,5 @@
 # tuple-transform
+* [meta exposition-only]
 * ranges[meta header]
 * function template[meta id-type]
 * cpp23[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>integral-constant-like -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/span/integral-constant-like.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/span/integral-constant-like.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/integral-constant-like.md b/reference/span/integral-constant-like.md
index 64270d376..9f31b07ea 100644
--- a/reference/span/integral-constant-like.md
+++ b/reference/span/integral-constant-like.md
@@ -1,4 +1,5 @@
 # integral-constant-like
+* [meta exposition-only]
 * span[meta header]
 * concept[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>maybe-static-ext -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/span/maybe-static-ext.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/span/maybe-static-ext.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/maybe-static-ext.md b/reference/span/maybe-static-ext.md
index 54c3d1d0b..29bca20d7 100644
--- a/reference/span/maybe-static-ext.md
+++ b/reference/span/maybe-static-ext.md
@@ -1,4 +1,5 @@
 # maybe-static-ext
+* [meta exposition-only]
 * span[meta header]
 * variable[meta id-type]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stoppable-source -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/stop_token/stoppable-source.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/stop_token/stoppable-source.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stop_token/stoppable-source.md b/reference/stop_token/stoppable-source.md
index 909dc19f5..40d742215 100644
--- a/reference/stop_token/stoppable-source.md
+++ b/reference/stop_token/stoppable-source.md
@@ -1,4 +1,5 @@
 # stoppable-source
+* [meta exposition-only]
 * stop_token[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pair-like -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/tuple/pair-like.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/tuple/pair-like.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/pair-like.md b/reference/tuple/pair-like.md
index 144f304ce..84d503759 100644
--- a/reference/tuple/pair-like.md
+++ b/reference/tuple/pair-like.md
@@ -1,4 +1,5 @@
 # pair-like
+* [meta exposition-only]
 * tuple[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple-like -- reference: meta exposition-onlyタグ追加(#1558)</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple-like.html"/>
      <id>f38b7a017bab215aa8f6675bf5822873c6f149eb:reference/tuple/tuple-like.md</id>
      <updated>2026-02-08T18:00:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple-like.md b/reference/tuple/tuple-like.md
index e4929c1c7..73b2af25c 100644
--- a/reference/tuple/tuple-like.md
+++ b/reference/tuple/tuple-like.md
@@ -1,4 +1,5 @@
 # tuple-like
+* [meta exposition-only]
 * tuple[meta header]
 * concept[meta id-type]
 * std[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mblen -- Merge pull request #1541 from akinomyoga/mblen</title>
      <link href="https://cpprefjp.github.io/reference/cstdlib/mblen.html"/>
      <id>819edcbcaf6e54b367c05e8cc72ee61ecc9c28b0:reference/cstdlib/mblen.md</id>
      <updated>2026-02-05T14:09:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdlib/mblen.md b/reference/cstdlib/mblen.md
index 4cdcd924d..dc6fa62ba 100644
--- a/reference/cstdlib/mblen.md
+++ b/reference/cstdlib/mblen.md
@@ -14,26 +14,64 @@ namespace std {
 
 先頭以外の文字に関するバイト数は計算されない。
 
-この関数は現在のロケールに依存してマルチバイト文字を解釈する。
+この関数は現在のロケールカテゴリー `LC_CTYPE` に依存してマルチバイト文字を解釈する。
 
 `n`は解析に使用する最大バイト数を指定する。
 
+内部状態に依存するエンコーディングを考慮するならば、
+特に理由がない限り `std::mblen` ではなく `std::mbstate_t` を受け取る `std::mbrlen` を
+新しいコードでは用いるべきである。
+エンコーディングの内部状態に関する振る舞いが C11 で変更 (WG14 N1373) されたが、
+以前の振る舞いではスレッドセーフではなく、
+現在の振る舞いではそもそも内部状態に依存する使い方ができない。
+
+### C11, C++17, POSIX.1-2024 以降
+
+この関数は以下の関数呼び出しに等価である。
+
+```cpp
+mbtowc((wchar_t *)0, (const char *)0, 0);
+mbtowc((wchar_t *)0, str, n);
+```
+* mbtowc[link mbtowc.md.nolink]
+
+つまり、関数 `mblen` はあたかも内部状態がないかのように振る舞い、
+現在のエンコーディングの初期状態を用いて `str` の先頭にある文字のバイト数を計算する。
+
+### C99, C++14, POSIX.1-2017 以前
+
+この関数は以下の関数呼び出しに等価である。
+
+```cpp
+mbtowc((wchar_t *)0, str, n);
+```
+* mbtowc[link mbtowc.md.nolink]
+
+関数 `mblen` は `std::mbstate_t` に等価な静的記憶域の内部状態を保持し、前回の `mblen` 関数呼び出しの続きとして処理を行う。
+従って、この関数はスレッドセーフではない。
+また、この関数を用いる処理の途中で、この関数を用いる別の処理を行うこともできない。
+安全に処理するためには、この関数の代わりに `std::mbstate_t` を受け取る [`std::mbrlen`](../cwchar/mbrlen.md.nolink) (`&amp;lt;cwchar&amp;gt;`) を使い、呼び出し元でデコード状態の記録場所 `std::mbstate_t` を用意する必要がある。
+
+他の標準ライブラリ関数はあたかも`mblen`を呼び出さないように振る舞う。
+つまり、明示的に `mblen` を呼び出さない限り、その内部状態を変更しない。
+
 ## 戻り値
 - 正常に動作する場合、文字の占めるバイト数を返す。
-- `str`が`nullptr`の時、内部状態を初期化し`0`を返す。
+- `str`が`nullptr`の時、内部状態を初期化する。現在のエンコーディングが状態を持つ場合は非ゼロの値を返し、それ以外の場合は`0`を返す。
 - 無効な文字列、または`n`が不足している場合、`-1`を返す。
 
 ## 例
 ### 基本的な使い方
 ```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;cstdlib&amp;gt;
 #include &amp;lt;clocale&amp;gt;
+#include &amp;lt;cstdlib&amp;gt;
+#include &amp;lt;cstring&amp;gt;
+#include &amp;lt;iostream&amp;gt;
 
 int main() {
   std::setlocale(LC_ALL, &amp;#34;ja_JP.UTF-8&amp;#34;);
   const char *str = &amp;#34;こんにちは&amp;#34;;
-  int result = std::mblen(str, MB_CUR_MAX);
+  int result = std::mblen(str, std::strlen(str));
   std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   return 0;
 }
@@ -46,15 +84,27 @@ int main() {
 
 ### 文字列の文字数を計算する
 ```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;cstdlib&amp;gt;
 #include &amp;lt;clocale&amp;gt;
+#include &amp;lt;cstdlib&amp;gt;
+#include &amp;lt;cstring&amp;gt;
+#include &amp;lt;iostream&amp;gt;
 
 int count_chars_mblen(const char* s) {
+#if __cplusplus &amp;gt;= 201703L
+  if (std::mblen(nullptr, 0) != 0) {
+    std::cerr &amp;lt;&amp;lt; &amp;#34;count_chars_mblen: State-dependent encoding is unsupported.&amp;#34; &amp;lt;&amp;lt; std::endl;
+    std::exit(1);
+  }
+#else
+  // C++14 以前: std::mblen 内部の std::mbstate_t を初期化する必要あり
+  std::mblen(nullptr, 0);
+#endif
+
   int count = 0;
-  size_t i = 0;
-  while (s[i] != &amp;#39;\0&amp;#39;) {
-    int len = std::mblen(&amp;amp;s[i], MB_CUR_MAX);
+  std::size_t i = 0;
+  std::size_t bytes = std::strlen(s);
+  while (i &amp;lt; bytes) {
+    int len = std::mblen(&amp;amp;s[i], bytes - i);
     if (len &amp;lt; 0) {
       len = 1;
     }
@@ -73,8 +123,26 @@ int main() {
 }
 ```
 
+注意: この例は飽くまで `std::mblen` を用いて文字数を数える関数の例であるが、実用上は `std::mbrlen` を用いた実装にするのが安全である。
+上の関数 `count_chars_mblen` はスレッドーセーフでない他、呼び出し元でも `std::mblen` を使っている場合にその振る舞いを破壊する可能性がある。
+
 #### 出力例
 ```
 文字列: こんにちは世界
 文字数: 7
 ```
+
+## 関連項目
+
+- [`mbrlen`](../cwchar/mbrlen.md.nolink): `std::mbstate_t` を受け取るスレッドセーフなバージョン
+- [WG14 N1373: Wording improvements for mblen, mbtowc, and c16rtomb](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1373.htm)
+    - C11 以降内部状態が最初に初期化されることになった。「表現の改善」としてこの破壊的な変更が実施されたように見える。
+    - [musl のメーリングリスト - 2019-12-26](https://www.openwall.com/lists/musl/2019/12/26/7) にて Florian Weimer が以下のように指摘している:
+        &amp;#34;actual users of the interfaces with legacy charsets do not seem to be represented on the standards committee anymore (see the mblen behavioral change in C11 as evidence supporting this theory).&amp;#34;
+        意訳: 「(C11 で入った mblen の振る舞い変更でも分かるように) C標準化委員会には古い文字コードを使っている人はもういないようだ。」
+- [WG14 N2037: mblen, mbtowc, and wctomb thread-safety](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2037.htm)
+    - [WG14 DR498: mblen, mbtowc, and wctomb thread-safety](https://www.open-std.org/jtc1/sc22/wg14/issues/c11c17/issue0498.html)
+    - [WG14 N2246: Make mblen, mbtowc, and wctomb thread-safe for encodings that are not state-dependent](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2246.htm)
+    - [WG14 N2281: Make mblen, mbtowc, and wctomb thread-safe for encodings that are not state-dependent](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2281.htm)
+    - [WG14 N2358: No internal state for mblen](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2358.htm)
+    - C11 以降もあたかも `mblen` が内部状態を持つかのような記述になっていたのが C23 で修正された。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_find -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
index e9b81315a..72ce400c5 100644
--- a/reference/algorithm/ranges_adjacent_find.md
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -20,9 +20,36 @@ namespace std::ranges {
             projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;,
+            projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  I adjacent_find(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  S last,
+                  Pred pred = {},
+                  Proj proj = {});                                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    adjacent_find(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  Pred pred = {},
+                  Proj proj = {});                                  // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -30,6 +57,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 このアルゴリズムは、範囲の先頭から1つづつ進みながら隣接するペアに対して条件を満たすかをチェックし、その条件を満たす最初の要素へのイテレータを返す。指定された条件を満たしているかをチェックされるのは、現在位置にある要素とその次の位置にある要素の2つについてであり、1つの要素は最大2回参照される。
 
@@ -61,6 +90,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iterator&amp;gt;
@@ -83,13 +113,13 @@ int main() {
 * std::ranges::distance[link /reference/iterator/ranges_distance.md]
 * std::ranges::adjacent_find[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==2
 *it == *(it+1): true
 ```
 
-### 動作イメージ
+#### 動作イメージ
 
 ```
 |0  1  2  3  4  5  6| : index
@@ -102,6 +132,32 @@ found: index==2
                [2, 2]
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2};
+
+  // 並列に同じ値が連続している最初の要素を検索する
+  auto it = std::ranges::adjacent_find(std::execution::par, v);
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::adjacent_find[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct adjacent_find_impl {
@@ -144,3 +200,4 @@ inline constexpr adjacent_find_impl adjacent_find;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_all_of.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_all_of.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_all_of.md b/reference/algorithm/ranges_all_of.md
index 861c19bff..d04dd5edf 100644
--- a/reference/algorithm/ranges_all_of.md
+++ b/reference/algorithm/ranges_all_of.md
@@ -18,14 +18,40 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr bool
     all_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool all_of(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool all_of(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の全ての要素が条件を満たすかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -43,6 +69,7 @@ namespace std::ranges {
 最大で `last - first` 回 `proj` と `pred` を実行する。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -64,12 +91,37 @@ int main() {
 ```
 * std::ranges::all_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 true
 false
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 8, 10};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に全ての要素が偶数であるかを判定
+  bool result = std::ranges::all_of(std::execution::par, v,
+                                    [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::all_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct all_of_impl {
@@ -111,3 +163,4 @@ inline constexpr all_of_impl all_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_any_of.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_any_of.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_any_of.md b/reference/algorithm/ranges_any_of.md
index 25e3f53fb..4802baf5c 100644
--- a/reference/algorithm/ranges_any_of.md
+++ b/reference/algorithm/ranges_any_of.md
@@ -18,14 +18,40 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr bool
     any_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool any_of(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool any_of(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲のいずれかの要素が条件を満たすかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -45,6 +71,7 @@ namespace std::ranges {
 最大で `last - first` 回 `pred` を実行する。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -66,12 +93,37 @@ int main() {
 ```
 * std::ranges::any_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 7, 8};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にいずれかの要素が偶数であるかを判定
+  bool result = std::ranges::any_of(std::execution::par, v,
+                                    [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::any_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct any_of_impl {
@@ -114,3 +166,4 @@ inline constexpr any_of_impl any_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_contains.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains.md b/reference/algorithm/ranges_contains.md
index 761004798..ec958c6c1 100644
--- a/reference/algorithm/ranges_contains.md
+++ b/reference/algorithm/ranges_contains.md
@@ -59,14 +59,52 @@ namespace std::ranges {
     contains(R&amp;amp;&amp;amp; r,
              const T&amp;amp; value,
              Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  bool
+    contains(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  bool
+    contains(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値が含まれるか調べる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -148,6 +186,30 @@ found
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に値が含まれるかを判定
+  bool result = std::ranges::contains(std::execution::par, v, 4);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::contains[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct contains_impl {
@@ -182,3 +244,4 @@ inline constexpr contains_impl contains;
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains_subrange -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains_subrange.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_contains_subrange.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains_subrange.md b/reference/algorithm/ranges_contains_subrange.md
index 9be4d01fe..55bbe2a5b 100644
--- a/reference/algorithm/ranges_contains_subrange.md
+++ b/reference/algorithm/ranges_contains_subrange.md
@@ -6,7 +6,7 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
+  // (1) C++23
   template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1,
            forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
@@ -14,20 +14,43 @@ namespace std::ranges {
   constexpr bool ranges::contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                            Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
 
-  // (2)
+  // (2) C++23
   template&amp;lt;forward_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
   requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
   constexpr bool ranges::contains_subrange(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {},
                                            Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  // (3) C++26
+  template&amp;lt;execution-policy Ep,
+           random_access_iterator I1, sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+           random_access_iterator I2, sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool ranges::contains_subrange(Ep&amp;amp;&amp;amp; exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                                 Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  // (4) C++26
+  template&amp;lt;execution-policy Ep,
+           sized-random-access-range R1, sized-random-access-range R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool ranges::contains_subrange(Ep&amp;amp;&amp;amp; exec, R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {},
+                                 Proj1 proj1 = {}, Proj2 proj2 = {});
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 あるシーケンスの中に、特定のサブシーケンスが含まれるか調べる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 サブシーケンスが空の場合は、常に`true`を返す。
 
@@ -40,6 +63,7 @@ first2 == last2 || !ranges::search(first1, last1, first2, last2, pred, proj1, pr
 最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;print&amp;gt;
@@ -64,6 +88,32 @@ int main() {
 found
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; sub = {2, 3, 4};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にサブ範囲が含まれるかを判定
+  bool result = std::ranges::contains_subrange(
+    std::execution::par, v, sub);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::contains_subrange[color ff0000]
+
+#### 出力
+```
+true
+```
+
 
 ## 実装例
 ```cpp
@@ -101,3 +151,4 @@ inline constexpr contains_subrange_impl contains_subrange;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy.md b/reference/algorithm/ranges_copy.md
index 7e13c6f73..d2579c96f 100644
--- a/reference/algorithm/ranges_copy.md
+++ b/reference/algorithm/ranges_copy.md
@@ -18,18 +18,46 @@ namespace std::ranges {
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     copy(R&amp;amp;&amp;amp; r, O result);           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_result&amp;lt;I, O&amp;gt;
+    copy(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         O result,
+         OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    copy(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * copy_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素をコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -57,6 +85,7 @@ copy_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,11 +112,38 @@ int main() {
 ```
 * std::ranges::copy[color ff0000]
 
-### 出力
+#### 出力
 ```
 3,1,2,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列にコピーする
+  std::ranges::copy(std::execution::par, src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -100,3 +156,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_if -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_if.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_copy_if.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_if.md b/reference/algorithm/ranges_copy_if.md
index 978a8b995..faf63d736 100644
--- a/reference/algorithm/ranges_copy_if.md
+++ b/reference/algorithm/ranges_copy_if.md
@@ -22,18 +22,54 @@ namespace std::ranges {
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_if_result&amp;lt;I, O&amp;gt;
+    copy_if(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            O result,
+            OutS result_last,
+            Pred pred,
+            Proj proj = {});                                       // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    copy_if(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            OutR&amp;amp;&amp;amp; result_r,
+            Pred pred,
+            Proj proj = {});                                       // (4) C++26
 }
 ```
 * copy_if_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素のみをコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -60,6 +96,7 @@ copy_if_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -91,6 +128,34 @@ int main() {
 3,1,1,5,9,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に偶数のみをコピーする
+  auto result = std::ranges::copy_if(std::execution::par, src, dst,
+                                     [](int x) { return x % 2 == 0; });
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy_if[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -103,3 +168,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_copy_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_n.md b/reference/algorithm/ranges_copy_n.md
index 34cb49ca2..2bb46e287 100644
--- a/reference/algorithm/ranges_copy_n.md
+++ b/reference/algorithm/ranges_copy_n.md
@@ -13,17 +13,33 @@ namespace std::ranges {
   constexpr copy_n_result&amp;lt;I, O&amp;gt;
     copy_n(I first,
            iter_difference_t&amp;lt;I&amp;gt; n,
-           O result); // (1) C++20
+           O result);                // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_n_result&amp;lt;I, O&amp;gt;
+    copy_n(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           iter_difference_t&amp;lt;I&amp;gt; n,
+           O result,
+           OutS result_last);        // (2) C++26
 }
 ```
 * copy_n_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 指定された数の要素をコピーする。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
 
 
 ## 効果
@@ -45,6 +61,7 @@ copy_n_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -67,6 +84,34 @@ int main() {
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(5);
+
+  // 並列に先頭3要素をコピー
+  std::ranges::copy_n(std::execution::par, src.begin(), 3,
+                      dst.begin(), dst.begin() + 3);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy_n[color ff0000]
+
+#### 出力
+```
+1 2 3 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -79,3 +124,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_count.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 58a13d5e8..05e78aae0 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -43,14 +43,44 @@ namespace std::ranges {
     count(R&amp;amp;&amp;amp; r,
           const T&amp;amp; value,
           Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  iter_difference_t&amp;lt;I&amp;gt;
+    count(Ep&amp;amp;&amp;amp; exec,
+          I first,
+          S last,
+          const T&amp;amp; value,
+          Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  range_difference_t&amp;lt;R&amp;gt;
+    count(Ep&amp;amp;&amp;amp; exec,
+          R&amp;amp;&amp;amp; r,
+          const T&amp;amp; value,
+          Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値と等値な要素の数を数える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -170,6 +200,28 @@ count of id==1: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2, 1};
+
+  // 並列に値が 1 の要素がいくつあるかを数える
+  auto n = std::ranges::count(std::execution::par, v, 1);
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of 1: &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count[color ff0000]
+
+#### 出力
+```
+count of 1: 3
+```
+
 ## 実装例
 ```cpp
 struct count_impl {
@@ -210,3 +262,4 @@ inline constexpr count_impl count;
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_count_if.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 265ff9c5a..3aa760e14 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -18,8 +18,34 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr range_difference_t&amp;lt;R&amp;gt;
     count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  iter_difference_t&amp;lt;I&amp;gt;
+    count_if(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             Pred pred,
+             Proj proj = {});                             // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  range_difference_t&amp;lt;R&amp;gt;
+    count_if(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             Pred pred,
+             Proj proj = {});                             // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -27,6 +53,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -47,6 +75,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -62,12 +91,35 @@ int main() {
 ```
 * std::ranges::count_if[color ff0000]
 
-### 出力
+#### 出力
 ```cpp
 count of 1 or 3: 5
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2, 1};
+
+  // 並列に値が偶数の要素がいくつあるかを数える
+  auto n = std::ranges::count_if(std::execution::par, v,
+                                 [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of even: &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count_if[color ff0000]
+
+#### 出力
+```
+count of even: 3
+```
+
 ## 実装例
 ```cpp
 struct count_if_impl {
@@ -104,3 +156,4 @@ inline constexpr count_if_impl count_if;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ends_with -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_ends_with.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_ends_with.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_ends_with.md b/reference/algorithm/ranges_ends_with.md
index 4b15e622c..a5e321787 100644
--- a/reference/algorithm/ranges_ends_with.md
+++ b/reference/algorithm/ranges_ends_with.md
@@ -39,9 +39,46 @@ namespace std::ranges {
               Pred pred = {},
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool
+    ends_with(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool
+    ends_with(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -49,6 +86,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 
@@ -66,6 +105,7 @@ namespace std::ranges {
 最大で `N2` 回の対応する述語が適用される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,7 +123,7 @@ int main() {
 ```
 * std::ranges::ends_with[color ff0000]
 
-### 出力
+#### 出力
 ```
 0
 0
@@ -91,6 +131,31 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; suffix = {4, 5, 6};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に末尾が一致するかを判定
+  bool result = std::ranges::ends_with(std::execution::par, v, suffix);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::ends_with[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct ends_with_impl {
@@ -138,3 +203,4 @@ inline constexpr ends_with_impl ends_with;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_equal.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
index d3a0c6d14..2493dbde1 100644
--- a/reference/algorithm/ranges_equal.md
+++ b/reference/algorithm/ranges_equal.md
@@ -35,14 +35,52 @@ namespace std::ranges {
           Pred pred = {},
           Proj1 proj1 = {},
           Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool equal(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool equal(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つの範囲を等値比較する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 2つの範囲の要素数および各要素が等値であった場合、`true`を返す。
 
@@ -57,6 +95,7 @@ namespace std::ranges {
 最大で `min(last1 - first1, last2 - first2)` 回の述語が適用される。ただし、2つの範囲の長さを定数時間で求められ、かつ、長さが異なる場合、1 度も述語は適用されない。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -79,13 +118,38 @@ int main() {
 ```
 * std::ranges::equal[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {1, 2, 3, 4, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に2つの範囲が等しいかを判定
+  bool result = std::ranges::equal(std::execution::par, v1, v2);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::equal[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 
 ```cpp
@@ -130,3 +194,4 @@ inline constexpr equal_impl equal;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_fill.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill.md b/reference/algorithm/ranges_fill.md
index 2c2985e6b..3987beacd 100644
--- a/reference/algorithm/ranges_fill.md
+++ b/reference/algorithm/ranges_fill.md
@@ -10,32 +10,58 @@ namespace std::ranges {
             output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
             sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
   constexpr O
-    fill(O first, S last, const T&amp;amp; value); // (1) C++20
+    fill(O first, S last, const T&amp;amp; value);           // (1) C++20
   template &amp;lt;class I,
             sentinel_for&amp;lt;O&amp;gt; S,
             class T = iter_value_t&amp;lt;O&amp;gt;&amp;gt;
     requires output_iterator&amp;lt;O, const T&amp;amp;&amp;gt;
   constexpr O
-    fill(O first, S last, const T&amp;amp; value); // (1) C++26
+    fill(O first, S last, const T&amp;amp; value);           // (1) C++26
 
   template &amp;lt;class T,
             output_range&amp;lt;const T&amp;amp;&amp;gt; R&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
-    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);           // (2) C++20
+    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);                     // (2) C++20
   template &amp;lt;class R,
             class T = range_value_t&amp;lt;R&amp;gt;&amp;gt;
     requires output_range&amp;lt;R, const T&amp;amp;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
-    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);           // (2) C++26
+    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);                     // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;O, const T&amp;amp;&amp;gt;
+  O fill(Ep&amp;amp;&amp;amp; exec,
+         O first,
+         S last,
+         const T&amp;amp; value);                            // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    fill(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value);                            // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値で出力の範囲に書き込む。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -118,6 +144,32 @@ int main() {
 1,2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(10);
+
+  // 並列に全要素を42で埋める
+  std::ranges::fill(std::execution::par, v, 42);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::fill[color ff0000]
+
+#### 出力
+```
+42 42 42 42 42 42 42 42 42 42
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -132,3 +184,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_fill_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill_n.md b/reference/algorithm/ranges_fill_n.md
index dfca5a816..64bfa0c80 100644
--- a/reference/algorithm/ranges_fill_n.md
+++ b/reference/algorithm/ranges_fill_n.md
@@ -11,20 +11,35 @@ namespace std::ranges {
   constexpr O
     fill_n(O first,
            iter_difference_t&amp;lt;O&amp;gt; n,
-           const T&amp;amp; value);   // (1) C++20
+           const T&amp;amp; value);             // (1) C++20
   template &amp;lt;class O,
             class T = iter_value_t&amp;lt;O&amp;gt;&amp;gt;
     requires output_iterator&amp;lt;O, const T&amp;amp;&amp;gt;
   constexpr O
     fill_n(O first,
            iter_difference_t&amp;lt;O&amp;gt; n,
-           const T&amp;amp; value);   // (1) C++26
+           const T&amp;amp; value);             // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;O, const T&amp;amp;&amp;gt;
+  O fill_n(Ep&amp;amp;&amp;amp; exec,
+           O first,
+           iter_difference_t&amp;lt;O&amp;gt; n,
+           const T&amp;amp; value);             // (2) C++26
 }
 ```
+* indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 指定された値で出力の範囲に `n` 個を書き込む。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## 効果
 `n` が 1 以上の場合は `[first,first + n)` 内の全ての要素に `value` を代入し、そうでない場合は何もしない。
@@ -102,6 +117,32 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(5);
+
+  // 並列に先頭3要素を42で埋める
+  std::ranges::fill_n(std::execution::par, v.begin(), 3, 42);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::fill_n[color ff0000]
+
+#### 出力
+```
+42 42 42 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +157,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_find.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 8823240a0..67daa20d7 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -43,15 +43,44 @@ namespace std::ranges {
     find(R&amp;amp;&amp;amp; r,
          const T&amp;amp; value,
          Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  I find(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         const T&amp;amp; value,
+         Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value,
+         Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -186,6 +215,29 @@ int main() {
 found: 3,4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に値を検索する
+  auto it = std::ranges::find(std::execution::par, v, 5);
+  if (it != v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find[color ff0000]
+
+#### 出力
+```
+found: 5
+```
 
 ## 実装例
 ```cpp
@@ -226,3 +278,4 @@ inline constexpr find_impl find;
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_find_end.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
index 6369dfd7e..8d6310f30 100644
--- a/reference/algorithm/ranges_find_end.md
+++ b/reference/algorithm/ranges_find_end.md
@@ -35,14 +35,54 @@ namespace std::ranges {
              Pred pred = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  subrange&amp;lt;I1&amp;gt;
+    find_end(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_subrange_t&amp;lt;R1&amp;gt;
+    find_end(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、特定のサブシーケンスを検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -61,6 +101,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -85,12 +126,39 @@ int main() {
 ```
 * std::ranges::find_end[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==2
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 1, 2, 3};
+  std::vector&amp;lt;int&amp;gt; pattern = {1, 2};
+
+  // 並列にサブシーケンスを末尾から検索する
+  auto sr = std::ranges::find_end(std::execution::par, v, pattern);
+  if (sr.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_end[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct find_end_impl {
@@ -130,3 +198,4 @@ inline constexpr find_end_impl find_end;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index a4beb961a..db300c21b 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -35,15 +35,55 @@ namespace std::ranges {
                   Pred pred = {},
                   Proj1 proj1 = {},
                   Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  I1
+    find_first_of(Ep&amp;amp;&amp;amp; exec,
+                  I1 first1,
+                  S1 last1,
+                  I2 first2,
+                  S2 last2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_iterator_t&amp;lt;R1&amp;gt;
+    find_first_of(Ep&amp;amp;&amp;amp; exec,
+                  R1&amp;amp;&amp;amp; r1,
+                  R2&amp;amp;&amp;amp; r2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 ある集合の1つとマッチする最初の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -57,6 +97,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -78,12 +119,40 @@ int main() {
 ```
 * std::ranges::find_first_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==3, value==4
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 7, 4, 2};
+  std::vector&amp;lt;int&amp;gt; targets = {2, 4, 6, 8};
+
+  // 並列に targets のいずれかと一致する最初の要素を検索する
+  auto it = std::ranges::find_first_of(std::execution::par, v, targets);
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it)
+              &amp;lt;&amp;lt; &amp;#34;, value==&amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_first_of[color ff0000]
+
+#### 出力
+```
+found: index==3, value==4
+```
+
 ## 実装例
 ```cpp
 struct find_first_of_impl {
@@ -124,3 +193,4 @@ inline constexpr find_first_of_impl find_first_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_find_if.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
index e6cf396a7..bd5d39c34 100644
--- a/reference/algorithm/ranges_find_if.md
+++ b/reference/algorithm/ranges_find_if.md
@@ -23,15 +23,42 @@ namespace std::ranges {
     find_if(R&amp;amp;&amp;amp; r,
             Pred pred,
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  I find_if(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            Pred pred,
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            Pred pred,
+            Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たす最初の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -61,12 +89,39 @@ int main() {
 ```
 * std::ranges::find_if[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9};
+
+  // 並列に5以上の最初の要素を検索する
+  auto result = std::ranges::find_if(std::execution::par, v,
+                                     [](int x) { return x &amp;gt;= 5; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if[color ff0000]
+
+#### 出力
+```
+found: 5
+```
+
 ## 実装例
 ```cpp
 struct find_if_impl {
@@ -103,3 +158,4 @@ inline constexpr find_if_impl find_if;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
index 250693822..edee510d5 100644
--- a/reference/algorithm/ranges_find_if_not.md
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -23,15 +23,42 @@ namespace std::ranges {
     find_if_not(R&amp;amp;&amp;amp; r,
                 Pred pred,
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  I find_if_not(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Pred pred,
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if_not(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Pred pred,
+                Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たさない最初の要素を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -61,12 +89,39 @@ int main() {
 ```
 * std::ranges::find_if_not[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 5, 6, 8};
+
+  // 並列に偶数でない最初の要素を検索する
+  auto result = std::ranges::find_if_not(std::execution::par, v,
+                                         [](int x) { return x % 2 == 0; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if_not[color ff0000]
+
+#### 出力
+```
+found: 5
+```
+
 ## 実装例
 ```cpp
 struct find_if_not_impl {
@@ -103,3 +158,4 @@ inline constexpr find_if_not_impl find_if_not;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_find_last.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last.md b/reference/algorithm/ranges_find_last.md
index 228a6d65f..41a33158c 100644
--- a/reference/algorithm/ranges_find_last.md
+++ b/reference/algorithm/ranges_find_last.md
@@ -59,14 +59,52 @@ namespace std::ranges {
     find_last(R&amp;amp;&amp;amp; r,
               const T&amp;amp; value,
               Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              const T&amp;amp; value,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              const T&amp;amp; value,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を末尾から検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -153,6 +191,33 @@ found: 3,4
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 3, 7};
+
+  // 並列に最後の3を検索
+  auto result = std::ranges::find_last(std::execution::par, v, 3);
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last[color ff0000]
+
+#### 出力
+```
+found: 3
+position: 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -169,3 +234,4 @@ found: 3,4
     - C++26で波カッコ初期化 (リスト初期化) に対応した
     - 関連文書：
         - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last_if -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last_if.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_find_last_if.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last_if.md b/reference/algorithm/ranges_find_last_if.md
index 3364c92a8..83e9417b7 100644
--- a/reference/algorithm/ranges_find_last_if.md
+++ b/reference/algorithm/ranges_find_last_if.md
@@ -23,14 +23,42 @@ namespace std::ranges {
     find_last_if(R&amp;amp;&amp;amp; r,
                  Pred pred,
                  Proj proj = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last_if(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 Pred pred,
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last_if(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 Pred pred,
+                 Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たす最後の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -42,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -60,12 +89,40 @@ int main() {
 ```
 * std::ranges::find_last_if[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 6, 5};
+
+  // 並列に最後の偶数を検索
+  auto result = std::ranges::find_last_if(std::execution::par, v,
+                                          [](int x) { return x % 2 == 0; });
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last_if[color ff0000]
+
+#### 出力
+```
+found: 6
+position: 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -78,3 +135,4 @@ found: 1
 
 ## 参照
 - [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last_if_not -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last_if_not.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_find_last_if_not.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last_if_not.md b/reference/algorithm/ranges_find_last_if_not.md
index fbbc83a07..5d7e3e689 100644
--- a/reference/algorithm/ranges_find_last_if_not.md
+++ b/reference/algorithm/ranges_find_last_if_not.md
@@ -23,14 +23,42 @@ namespace std::ranges {
     find_last_if_not(R&amp;amp;&amp;amp; r,
                      Pred pred,
                      Proj proj = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last_if_not(Ep&amp;amp;&amp;amp; exec,
+                     I first,
+                     S last,
+                     Pred pred,
+                     Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last_if_not(Ep&amp;amp;&amp;amp; exec,
+                     R&amp;amp;&amp;amp; r,
+                     Pred pred,
+                     Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たさない最後の要素を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -42,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -60,12 +89,40 @@ int main() {
 ```
 * std::ranges::find_last_if_not[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 3, 6, 8};
+
+  // 並列に最後の偶数でない要素を検索
+  auto result = std::ranges::find_last_if_not(std::execution::par, v,
+                                              [](int x) { return x % 2 == 0; });
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last_if_not[color ff0000]
+
+#### 出力
+```
+found: 3
+position: 2
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -78,3 +135,4 @@ found: 1
 
 ## 参照
 - [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_for_each.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each.md b/reference/algorithm/ranges_for_each.md
index 8638277ae..8617440cf 100644
--- a/reference/algorithm/ranges_for_each.md
+++ b/reference/algorithm/ranges_for_each.md
@@ -23,11 +23,36 @@ namespace std::ranges {
     for_each(R&amp;amp;&amp;amp; r,
              Fun f,
              Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  I for_each(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             Fun f,
+             Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    for_each(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             Fun f,
+             Proj proj = {}); // (4) C++26
 }
 ```
 * indirectly_unary_invocable[link /reference/iterator/indirectly_unary_invocable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 * for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +60,8 @@ namespace std::ranges {
 
 * (1): イテレータ範囲を指定する
 * (2): Rangeを直接指定する
+* (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+* (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -54,14 +81,16 @@ namespace std::ranges {
 
 
 ## 戻り値
+- (1), (2):
+    ```cpp
+    for_each_result {
+      .in = last,
+      .fun = std::move(f),
+    }
+    ```
+    * for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
 
-```cpp
-for_each_result {
-  .in = last,
-  .fun = std::move(f),
-}
-```
-* for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
+- (3), (4): `last`
 
 ## 計算量
 正確に `f` を `last - first` 回適用する
@@ -72,7 +101,7 @@ for_each_result {
 
 
 ## 例
-
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -105,6 +134,35 @@ int main() {
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に全ての要素を2倍にする
+  std::ranges::for_each(std::execution::par, v, [](int&amp;amp; x) { x *= 2; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::for_each[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
+## バージョン
+### 言語
+- C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
@@ -112,7 +170,6 @@ int main() {
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 10 [mark verified]
 
-
 ## 実装例
 ```cpp
 struct for_each_impl {
@@ -142,3 +199,4 @@ inline constexpr for_each_impl for_each;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index 7095a7aeb..241ab8d8a 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -14,14 +14,29 @@ namespace std::ranges {
                iter_difference_t&amp;lt;I&amp;gt; n,
                Fun f,
                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  I for_each_n(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               iter_difference_t&amp;lt;I&amp;gt; n,
+               Fun f,
+               Proj proj = {}); // (2) C++26
 }
 ```
 * indirectly_unary_invocable[link /reference/iterator/indirectly_unary_invocable.md]
 * for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 範囲の先頭N個の要素に、指定された関数を適用する。
 
+- (1): 通常版
+- (2): 並列アルゴリズム版。実行ポリシーを指定する
+
 ## テンプレートパラメータ制約
 - `I`が[`input_iterator`](/reference/iterator/input_iterator.md)である
 - `Fun`は`I`を`Proj`で射影した値を受け取る[1引数の`invocable`](/reference/iterator/indirectly_unary_invocable.md)である
@@ -38,18 +53,22 @@ namespace std::ranges {
 このアルゴリズムはその他のアルゴリズムと違い、[`invoke`](/reference/functional/invoke.md)`(proj, *i)` が書き換え可能な参照であれば、関数 `f` の内部でその値を書き換えても構わない。
 
 ## 戻り値
-```cpp
-for_each_n_result {
-  .in = first + n,
-  .fun = std::move(f)
-}
-```
-* for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+- (1):
+    ```cpp
+    for_each_n_result {
+      .in = first + n,
+      .fun = std::move(f)
+    }
+    ```
+    * for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+
+- (2): `first + n`
 
 ## 備考
 - 関数 `f` に戻り値がある場合、それは単に無視される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -84,6 +103,33 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に先頭3要素を出力
+  std::ranges::for_each_n(std::execution::par, v.begin(), 3,
+                          [](int x) { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;; });
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::for_each_n[color ff0000]
+
+#### 出力例
+```
+1 2 3
+```
+
+## バージョン
+### 言語
+- C++20
+
 ### 処理系
 - [Clang](/implementation.md#clang): ??
 - [GCC](/implementation.md#gcc): 10.1.0 [mark verified]
@@ -113,3 +159,4 @@ inline constexpr for_each_n_impl for_each_n;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_generate.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate.md b/reference/algorithm/ranges_generate.md
index 45d70770d..0ccfffdd4 100644
--- a/reference/algorithm/ranges_generate.md
+++ b/reference/algorithm/ranges_generate.md
@@ -13,25 +13,50 @@ namespace std::ranges {
   constexpr O
     generate(O first,
              S last,
-             F gen); // (1) C++20
+             F gen);                  // (1) C++20
 
   template &amp;lt;class R,
             copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; output_range&amp;lt;R, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     generate(R&amp;amp;&amp;amp; r,
-             F gen); // (2) C++20
+             F gen);                  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  O generate(Ep&amp;amp;&amp;amp; exec,
+             O first,
+             S last,
+             F gen);                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    generate(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             F gen);                  // (4) C++26
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 出力の範囲へ関数の結果を書き込む。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -47,6 +72,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -71,6 +97,32 @@ int main() {
 1,2,4,8,16,32,64,128,256,512,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(10);
+
+  // 並列に全要素を99で埋める
+  std::ranges::generate(std::execution::par, v, [] { return 99; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::generate[color ff0000]
+
+#### 出力
+```
+99 99 99 99 99 99 99 99 99 99
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -83,3 +135,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_generate_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate_n.md b/reference/algorithm/ranges_generate_n.md
index 6f06cec13..56f5f2c9d 100644
--- a/reference/algorithm/ranges_generate_n.md
+++ b/reference/algorithm/ranges_generate_n.md
@@ -13,15 +13,29 @@ namespace std::ranges {
     generate_n(O first,
                iter_difference_t&amp;lt;O&amp;gt; n,
                F gen);                  // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  O generate_n(Ep&amp;amp;&amp;amp; exec,
+               O first,
+               iter_difference_t&amp;lt;O&amp;gt; n,
+               F gen);                  // (2) C++26
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 
 ## 概要
 出力の範囲へ関数の結果を `n` 個書き込む。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## 効果
 `n` が 1 以上の場合、`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
@@ -41,6 +55,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -59,6 +74,35 @@ int main() {
 1,2,4,8,16,32,64,128,256,512,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(5);
+
+  // 並列に値を生成して書き込む
+  std::atomic&amp;lt;int&amp;gt; counter{0};
+  std::ranges::generate_n(std::execution::par, v.begin(), 5,
+                          [&amp;amp;counter] { return counter++; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::generate_n[color ff0000]
+
+#### 出力例
+```
+0 1 2 3 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -71,3 +115,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_in_out_result -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_in_out_result.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_in_in_out_result.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_in_out_result.md b/reference/algorithm/ranges_in_in_out_result.md
index 4939125fe..095b4a90f 100644
--- a/reference/algorithm/ranges_in_in_out_result.md
+++ b/reference/algorithm/ranges_in_in_out_result.md
@@ -3,7 +3,7 @@
 * std::ranges[meta namespace]
 * class template[meta id-type]
 * cpp20[meta cpp]
-* binary_transform_result,merge_result,set_union_result,set_intersection_result,set_symmetric_difference_result[meta alias]
+* binary_transform_result,merge_result,set_union_result,set_intersection_result,set_symmetric_difference_result,reverse_copy_truncated_result,rotate_copy_truncated_result[meta alias]
 
 ```cpp
 namespace std::ranges {
@@ -50,6 +50,14 @@ namespace std::ranges {
   // (6)
   template&amp;lt;class I1, class I2, class O&amp;gt;
   using set_symmetric_difference_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  // (7) C++26
+  template&amp;lt;class I, class O&amp;gt;
+  using reverse_copy_truncated_result = in_in_out_result&amp;lt;I, I, O&amp;gt;;
+
+  // (8) C++26
+  template&amp;lt;class I, class O&amp;gt;
+  using rotate_copy_truncated_result = in_in_out_result&amp;lt;I, I, O&amp;gt;;
 }
 ```
 * no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
@@ -62,6 +70,8 @@ namespace std::ranges {
 * (4): [`ranges::set_union`](ranges_set_union.md)で使用するエイリアス
 * (5): [`ranges::set_intersection`](ranges_set_intersection.md)で使用するエイリアス
 * (6): [`ranges::set_symmetric_difference`](ranges_set_symmetric_difference.md)で使用するエイリアス
+* (7): [`ranges::reverse_copy`](ranges_reverse_copy.md)の並列アルゴリズム版で使用するエイリアス (C++26)
+* (8): [`ranges::rotate_copy`](ranges_rotate_copy.md)の並列アルゴリズム版で使用するエイリアス (C++26)
 
 この型は、関数が2つの入力用の範囲と出力用の範囲を受け取る場合に、それぞれ処理した範囲の末尾を返すために使用される。
 
@@ -125,3 +135,5 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>includes -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_includes.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_includes.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_includes.md b/reference/algorithm/ranges_includes.md
index 41e5babb6..403ec100f 100644
--- a/reference/algorithm/ranges_includes.md
+++ b/reference/algorithm/ranges_includes.md
@@ -39,16 +39,60 @@ namespace std::ranges {
              Comp comp = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    includes(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    includes(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 `[first2,last2)` が `empty` であるか、`[first2,last2)` の全ての要素が `[first1,last1)` に含まれている場合は `true`、そうでない場合は `false` を返す。
@@ -59,6 +103,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -84,6 +129,34 @@ true
 false
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6};
+  std::vector&amp;lt;int&amp;gt; c = {2, 4, 7};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にaがbの全要素を含むか判定する
+  std::cout &amp;lt;&amp;lt; std::ranges::includes(std::execution::par, a, b) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::includes(std::execution::par, a, c) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::includes[color ff0000]
+
+#### 出力
+```
+true
+false
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +169,4 @@ false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_inplace_merge.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_inplace_merge.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_inplace_merge.md b/reference/algorithm/ranges_inplace_merge.md
index 58cfe9bb4..5d12106d2 100644
--- a/reference/algorithm/ranges_inplace_merge.md
+++ b/reference/algorithm/ranges_inplace_merge.md
@@ -47,17 +47,49 @@ namespace std::ranges {
                   iterator_t&amp;lt;R&amp;gt; middle,
                   Comp comp = {},
                   Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I
+    inplace_merge(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  I middle,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    inplace_merge(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  iterator_t&amp;lt;R&amp;gt; middle,
+                  Comp comp = {},
+                  Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つの連続したソート済み範囲をマージする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` の範囲はそれぞれソートされていること。
@@ -83,6 +115,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -112,6 +145,34 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 2, 4, 6};
+
+  // 並列にインプレースマージ
+  // [1,3,5) と [2,4,6) をマージ
+  std::ranges::inplace_merge(std::execution::par,
+                             v, v.begin() + 3);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::inplace_merge[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6
+```
+
 ## 実装例
 - [`inplace_merge` を読んでみた](http://www.kmonos.net/wlog/115.html#_2300101215)
 
@@ -129,3 +190,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_is_heap.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap.md b/reference/algorithm/ranges_is_heap.md
index 35abb8e9f..394cfad5d 100644
--- a/reference/algorithm/ranges_is_heap.md
+++ b/reference/algorithm/ranges_is_heap.md
@@ -23,16 +23,44 @@ namespace std::ranges {
     is_heap(R&amp;amp;&amp;amp; r,
             Comp comp = {},
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    is_heap(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            Comp comp = {},
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    is_heap(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            Comp comp = {},
+            Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲がヒープ化されているか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -40,6 +68,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -68,6 +97,36 @@ before: is heap? false
  after: is heap? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is heap? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_heap(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::make_heap(v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is heap? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_heap(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_heap[color ff0000]
+* std::ranges::make_heap[link ranges_make_heap.md]
+
+#### 出力
+```
+before: is heap? false
+ after: is heap? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -80,3 +139,4 @@ before: is heap? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap_until -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap_until.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_is_heap_until.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap_until.md b/reference/algorithm/ranges_is_heap_until.md
index d96bc5c22..ae1148984 100644
--- a/reference/algorithm/ranges_is_heap_until.md
+++ b/reference/algorithm/ranges_is_heap_until.md
@@ -23,16 +23,44 @@ namespace std::ranges {
     is_heap_until(R&amp;amp;&amp;amp; r,
                   Comp comp = {},
                   Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I is_heap_until(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_heap_until(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  Comp comp = {},
+                  Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -44,6 +72,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -66,12 +95,39 @@ int main()
 * std::ranges::is_heap_until[color ff0000]
 * std::ranges::make_heap[link ranges_make_heap.md]
 
-### 出力
+#### 出力
 ```
 before: is heap? false
  after: is heap? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {9, 5, 7, 3, 1, 2, 4};
+
+  // 並列にヒープ条件を満たさなくなる位置を検索
+  auto it = std::ranges::is_heap_until(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;heap part: &amp;#34;;
+  for (auto i = v.begin(); i != it; ++i) {
+    std::cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_heap_until[color ff0000]
+
+#### 出力
+```
+heap part: 9 5 7 3 1 2 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -84,3 +140,4 @@ before: is heap? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_partitioned -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_partitioned.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_is_partitioned.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_partitioned.md b/reference/algorithm/ranges_is_partitioned.md
index ffff76a49..d620305c0 100644
--- a/reference/algorithm/ranges_is_partitioned.md
+++ b/reference/algorithm/ranges_is_partitioned.md
@@ -23,14 +23,40 @@ namespace std::ranges {
     is_partitioned(R&amp;amp;&amp;amp; r,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool is_partitioned(Ep&amp;amp;&amp;amp; exec,
+                      I first,
+                      S last,
+                      Pred pred,
+                      Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool is_partitioned(Ep&amp;amp;&amp;amp; exec,
+                      R&amp;amp;&amp;amp; r,
+                      Pred pred,
+                      Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -44,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -84,6 +111,33 @@ int main()
 partitioned
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 1, 3, 5};
+
+  auto pred = [](int x) { return x % 2 == 0; };
+
+  // 並列に偶数グループと奇数グループに分かれているか判定する
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;is partitioned? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_partitioned(std::execution::par, v, pred)
+            &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_partitioned[color ff0000]
+
+#### 出力
+```
+is partitioned? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +150,4 @@ partitioned
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_is_sorted.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted.md b/reference/algorithm/ranges_is_sorted.md
index b5bf9efb0..cedf3488a 100644
--- a/reference/algorithm/ranges_is_sorted.md
+++ b/reference/algorithm/ranges_is_sorted.md
@@ -23,16 +23,42 @@ namespace std::ranges {
     is_sorted(R&amp;amp;&amp;amp; r,
               Comp comp = {},
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool is_sorted(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 Comp comp = {},
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool is_sorted(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 Comp comp = {},
+                 Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲がソート済みか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ### 戻り値
@@ -40,6 +66,7 @@ namespace std::ranges {
 - (2) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(r, comp, proj) == last`
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -66,6 +93,36 @@ before: is sorted? false
  after: is sorted? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is sorted? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_sorted(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::sort(v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is sorted? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_sorted(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_sorted[color ff0000]
+* std::ranges::sort[link ranges_sort.md]
+
+#### 出力
+```
+before: is sorted? false
+ after: is sorted? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -78,3 +135,4 @@ before: is sorted? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted_until.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_is_sorted_until.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted_until.md b/reference/algorithm/ranges_is_sorted_until.md
index d01cf16df..b92c0af1c 100644
--- a/reference/algorithm/ranges_is_sorted_until.md
+++ b/reference/algorithm/ranges_is_sorted_until.md
@@ -23,17 +23,44 @@ namespace std::ranges {
     is_sorted_until(R&amp;amp;&amp;amp; r,
                     Comp comp = {},
                     Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I is_sorted_until(Ep&amp;amp;&amp;amp; exec,
+                    I first,
+                    S last,
+                    Comp comp = {},
+                    Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_sorted_until(Ep&amp;amp;&amp;amp; exec,
+                    R&amp;amp;&amp;amp; r,
+                    Comp comp = {},
+                    Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 ソート済みか判定し、ソートされていない位置のイテレータを取得する
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 [`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、`[first,last]` の中でソートされている範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
@@ -44,6 +71,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -72,6 +100,33 @@ before: is sorted? false
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 5, 4, 6};
+
+  // 並列にソート済み範囲の終端を取得する
+  auto it = std::ranges::is_sorted_until(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;sorted until: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;sorted range size: &amp;#34; &amp;lt;&amp;lt; (it - v.begin()) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_sorted_until[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力
+```
+sorted until: 4
+sorted range size: 4
+```
+
 ## 実装例
 ```cpp
 
@@ -115,3 +170,4 @@ inline constexpr is_sorted_until_impl is_sorted_until;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lexicographical_compare.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_lexicographical_compare.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lexicographical_compare.md b/reference/algorithm/ranges_lexicographical_compare.md
index 80fb24448..059fcca8d 100644
--- a/reference/algorithm/ranges_lexicographical_compare.md
+++ b/reference/algorithm/ranges_lexicographical_compare.md
@@ -40,16 +40,58 @@ namespace std::ranges {
                             Comp comp = {},
                             Proj1 proj1 = {},
                             Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool lexicographical_compare(Ep&amp;amp;&amp;amp; exec,
+                               I1 first1,
+                               S1 last1,
+                               I2 first2,
+                               S2 last2,
+                               Comp comp = {},
+                               Proj1 proj1 = {},
+                               Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool lexicographical_compare(Ep&amp;amp;&amp;amp; exec,
+                               R1&amp;amp;&amp;amp; r1,
+                               R2&amp;amp;&amp;amp; r2,
+                               Comp comp = {},
+                               Proj1 proj1 = {},
+                               Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 ```cpp
@@ -76,6 +118,7 @@ return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;string&amp;gt;
@@ -136,6 +179,36 @@ x less than y
 x less than y
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; b = {1, 2, 3, 4, 6};
+
+  // 並列に辞書式比較を行う
+  bool result = std::ranges::lexicographical_compare(
+    std::execution::par,
+    a,
+    b
+  );
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;a &amp;lt; b: &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::lexicographical_compare[color ff0000]
+
+#### 出力
+```
+a &amp;lt; b: true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -148,3 +221,4 @@ x less than y
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_max.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max.md b/reference/algorithm/ranges_max.md
index 32ca3a62f..8fa065d48 100644
--- a/reference/algorithm/ranges_max.md
+++ b/reference/algorithm/ranges_max.md
@@ -31,12 +31,25 @@ namespace std::ranges {
     max(R&amp;amp;&amp;amp; r,
         Comp comp = {},
         Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  range_value_t&amp;lt;R&amp;gt;
+    max(Ep&amp;amp;&amp;amp; exec,
+        R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最大値を取得する。
@@ -44,6 +57,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -53,6 +67,7 @@ namespace std::ranges {
 - 等価な要素が 2 つ以上あった場合には、最も左の要素を返す。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -90,6 +105,28 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`max`
 - `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`max`マクロが定義されなくなる。
 - `std::ranges::max()`を呼び出す際に、`(std::ranges::max)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::max()`関数が必ず使用される。
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最大値を取得
+  int result = std::ranges::max(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::max[color ff0000]
+
+#### 出力
+```
+9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -102,3 +139,4 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`max`
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_max_element.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
index eebec0f04..88e4a3e42 100644
--- a/reference/algorithm/ranges_max_element.md
+++ b/reference/algorithm/ranges_max_element.md
@@ -23,17 +23,44 @@ namespace std::ranges {
     max_element(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I max_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    max_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 [`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -70,6 +98,30 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最大要素を検索する
+  auto it = std::ranges::max_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;max: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::max_element[color ff0000]
+
+#### 出力
+```
+max: 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -82,3 +134,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_merge.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
index 739eace4e..83440d5a8 100644
--- a/reference/algorithm/ranges_merge.md
+++ b/reference/algorithm/ranges_merge.md
@@ -43,6 +43,50 @@ namespace std::ranges {
           Comp comp = {},
           Proj1 proj1 = {},
           Proj2 proj2 = {});  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  merge_result&amp;lt;I1, I2, O&amp;gt;
+    merge(Ep&amp;amp;&amp;amp; exec,
+          I1 first1,
+          S1 last1,
+          I2 first2,
+          S2 last2,
+          O result,
+          OutS result_last,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  merge_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;,
+    borrowed_iterator_t&amp;lt;OutR&amp;gt;
+  &amp;gt;
+    merge(Ep&amp;amp;&amp;amp; exec,
+          R1&amp;amp;&amp;amp; r1,
+          R2&amp;amp;&amp;amp; r2,
+          OutR&amp;amp;&amp;amp; result_r,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * merge_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲をマージして、出力イテレータへ出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -85,6 +135,7 @@ merge_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -122,6 +173,35 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 3, 5, 7};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6, 8};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列に2つのソート済み範囲をマージする
+  std::ranges::merge(std::execution::par, a, b, result);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::merge[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6 7 8
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -134,3 +214,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_min.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min.md b/reference/algorithm/ranges_min.md
index f3ec69f0d..49775810a 100644
--- a/reference/algorithm/ranges_min.md
+++ b/reference/algorithm/ranges_min.md
@@ -31,12 +31,25 @@ namespace std::ranges {
     min(R&amp;amp;&amp;amp; r,
         Comp comp = {},
         Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  range_value_t&amp;lt;R&amp;gt;
+    min(Ep&amp;amp;&amp;amp; exec,
+        R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値を取得する。
@@ -44,6 +57,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -54,6 +68,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -91,6 +106,28 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`min`
 - `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`min`マクロが定義されなくなる。
 - `std::ranges::min()`を呼び出す際に、`(std::ranges::min)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::min()`が必ず使用される。
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小値を取得
+  int result = std::ranges::min(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::min[color ff0000]
+
+#### 出力
+```
+1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -103,3 +140,4 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`min`
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_min_element.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
index e7c039f0f..67b5dc891 100644
--- a/reference/algorithm/ranges_min_element.md
+++ b/reference/algorithm/ranges_min_element.md
@@ -23,11 +23,36 @@ namespace std::ranges {
     min_element(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I min_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    min_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +60,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -46,6 +73,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -73,6 +101,30 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小要素を検索する
+  auto it = std::ranges::min_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;min: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::min_element[color ff0000]
+
+#### 出力
+```
+min: 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -85,3 +137,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_minmax.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax.md b/reference/algorithm/ranges_minmax.md
index 2f678c217..22b63c906 100644
--- a/reference/algorithm/ranges_minmax.md
+++ b/reference/algorithm/ranges_minmax.md
@@ -31,6 +31,17 @@ namespace std::ranges {
     minmax(R&amp;amp;&amp;amp; r,
            Comp comp = {},
            Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           Comp comp = {},
+           Proj proj = {}); // (4) C++26
 }
 ```
 * minmax_result[link ranges_min_max_result.md]
@@ -38,6 +49,8 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値と最大値の組を取得する。
@@ -45,6 +58,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -63,6 +77,7 @@ minmax_result {
 - 範囲バージョンは高々`(3/2) * t.size()`回の述語適用。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -93,6 +108,28 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小値と最大値を取得
+  auto [min_val, max_val] = std::ranges::minmax(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; min_val &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; max_val &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::minmax[color ff0000]
+
+#### 出力
+```
+1, 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +142,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
index a243db083..332cc08d7 100644
--- a/reference/algorithm/ranges_minmax_element.md
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -23,12 +23,38 @@ namespace std::ranges {
     minmax_element(R&amp;amp;&amp;amp; r,
                    Comp comp = {},
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  minmax_element_result&amp;lt;I&amp;gt;
+    minmax_element(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   Comp comp = {},
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  minmax_element_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax_element(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   Comp comp = {},
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * minmax_element_result[link ranges_min_max_result.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -36,6 +62,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -53,6 +81,7 @@ minmax_element_result {
 `n` を範囲の要素数とする場合、[`max`](max.md)`(floor(3(n - 1) / 2), 0)` 回の述語適用を行う。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;cassert&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -77,6 +106,32 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小要素と最大要素を同時に検索する
+  auto [min_it, max_it] = std::ranges::minmax_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;min: &amp;#34; &amp;lt;&amp;lt; *min_it &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;max: &amp;#34; &amp;lt;&amp;lt; *max_it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::minmax_element[color ff0000]
+
+#### 出力
+```
+min: 1
+max: 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -89,3 +144,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_mismatch.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index e45983580..0d062d1d1 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -38,10 +38,51 @@ namespace std::ranges {
              Pred pred = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  mismatch_result&amp;lt;I1, I2&amp;gt;
+    mismatch(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  mismatch_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;
+  &amp;gt;
+    mismatch(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * mismatch_result[link ranges_in_in_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -49,6 +90,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -66,6 +109,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -107,7 +151,7 @@ int main() {
 * std::ranges::mismatch[color ff0000]
 * std::to_string[link /reference/string/to_string.md]
 
-### 出力
+#### 出力
 ```
 mismatch index: 2
 mismatch value: (3,4)
@@ -117,6 +161,35 @@ mismatch value: (end,2)
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {1, 2, 4, 4, 5};
+
+  // 並列に2つのシーケンスが異なる場所を探す
+  auto [it1, it2] = std::ranges::mismatch(std::execution::par, v1, v2);
+  if (it1 == v1.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;all match&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;mismatch at index: &amp;#34; &amp;lt;&amp;lt; std::distance(v1.begin(), it1) &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;values: &amp;#34; &amp;lt;&amp;lt; *it1 &amp;lt;&amp;lt; &amp;#34; vs &amp;#34; &amp;lt;&amp;lt; *it2 &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::mismatch[color ff0000]
+
+#### 出力
+```
+mismatch at index: 2
+values: 3 vs 4
+```
+
 ## 実装例
 ```cpp
 struct mismatch_impl {
@@ -158,3 +231,4 @@ inline constexpr mismatch_impl mismatch;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_move.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move.md b/reference/algorithm/ranges_move.md
index 08ab3cf3c..f489ba666 100644
--- a/reference/algorithm/ranges_move.md
+++ b/reference/algorithm/ranges_move.md
@@ -13,26 +13,54 @@ namespace std::ranges {
   constexpr move_result&amp;lt;I, O&amp;gt;
     move(I first,
          S last,
-         O result); // (1) C++20
+         O result);           // (1) C++20
 
   template &amp;lt;input_range R,
             weakly_incrementable O&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     move(R&amp;amp;&amp;amp; r,
-         O result); // (2) C++20
+         O result);           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_movable&amp;lt;I, O&amp;gt;
+  move_result&amp;lt;I, O&amp;gt;
+    move(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         O result,
+         OutS result_last);   // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    move(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         OutR&amp;amp;&amp;amp; result_r);    // (4) C++26
 }
 ```
 * move_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_movable[link /reference/iterator/indirectly_movable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素をムーブする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -59,6 +87,7 @@ move_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -93,6 +122,34 @@ int main() {
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, &amp;#34;baz&amp;#34;};
+  std::vector&amp;lt;std::string&amp;gt; dst(src.size());
+
+  // 並列にムーブする
+  std::ranges::move(std::execution::par, src, dst);
+
+  for (const auto&amp;amp; s : dst) {
+    std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::move[color ff0000]
+
+#### 出力
+```
+hello world foo bar baz
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +162,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_backward -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move_backward.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_move_backward.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move_backward.md b/reference/algorithm/ranges_move_backward.md
index 4e6ab8bb6..059f1c1bc 100644
--- a/reference/algorithm/ranges_move_backward.md
+++ b/reference/algorithm/ranges_move_backward.md
@@ -13,25 +13,51 @@ namespace std::ranges {
   constexpr move_backward_result&amp;lt;I1, I2&amp;gt;
     move_backward(I1 first,
                   S1 last,
-                  I2 result); // (1) C++20
+                  I2 result);           // (1) C++20
 
   template &amp;lt;bidirectional_range R,
             bidirectional_iterator I&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
   constexpr move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
     move_backward(R&amp;amp;&amp;amp; r,
-                  I result); // (2) C++20
+                  I result);            // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2&amp;gt;
+    requires indirectly_movable&amp;lt;I1, I2&amp;gt;
+  move_backward_result&amp;lt;I1, I2&amp;gt;
+    move_backward(Ep&amp;amp;&amp;amp; exec,
+                  I1 first,
+                  S1 last,
+                  I2 result);           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            random_access_iterator I&amp;gt;
+    requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+  move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+    move_backward(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  I result);            // (4) C++26
 }
 ```
 * move_backward_result[link ranges_in_out_result.md]
 * indirectly_movable[link /reference/iterator/indirectly_movable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素を後ろからムーブする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 `result` は `(first,last]` の範囲に含まれてはならない。
@@ -61,6 +87,7 @@ move_backward_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -104,6 +131,33 @@ int main() {
 2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 0, 0};
+
+  // 並列に先頭3要素を後方へムーブ
+  std::ranges::move_backward(std::execution::par,
+                             v.begin(), v.begin() + 3, v.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::move_backward[color ff0000]
+
+#### 出力
+```
+1 2 1 2 3
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +170,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_none_of.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_none_of.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_none_of.md b/reference/algorithm/ranges_none_of.md
index 9d3bc4f7a..1a3c07c17 100644
--- a/reference/algorithm/ranges_none_of.md
+++ b/reference/algorithm/ranges_none_of.md
@@ -23,14 +23,40 @@ namespace std::ranges {
     none_of(R&amp;amp;&amp;amp; r,
             Pred pred,
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool none_of(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               Pred pred,
+               Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool none_of(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               Pred pred,
+               Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の全ての要素が条件を満たさないかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -62,6 +88,7 @@ all_of(first, last, not_fn(pred));
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,12 +110,37 @@ int main() {
 ```
 * std::ranges::none_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 7, 9};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に全ての要素が偶数でないかを判定
+  bool result = std::ranges::none_of(std::execution::par, v,
+                                     [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::none_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct none_of_impl {
@@ -131,3 +183,4 @@ inline constexpr none_of_impl none_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_nth_element.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
index 46e6a0f6e..1ef170c40 100644
--- a/reference/algorithm/ranges_nth_element.md
+++ b/reference/algorithm/ranges_nth_element.md
@@ -27,11 +27,39 @@ namespace std::ranges {
                 iterator_t&amp;lt;R&amp;gt; nth,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I nth_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                I nth,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    nth_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; nth,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -39,6 +67,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
 
@@ -56,6 +86,7 @@ namespace std::ranges {
 平均で線形時間
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -88,6 +119,37 @@ int main()
 10
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {5, 10, 4, 7, 1, 9, 8, 6, 2};
+
+  // 並列に4番目に小さい値より小さい値を前に集める
+  std::ranges::nth_element(std::execution::par, v, v.begin() + 3);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;4th element: &amp;#34; &amp;lt;&amp;lt; v[3] &amp;lt;&amp;lt; std::endl;
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::nth_element[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力例
+```
+4th element: 5
+2 1 4 5 7 6 8 9 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -100,3 +162,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index e5e6cfcb8..fca20788b 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -27,11 +27,39 @@ namespace std::ranges {
                  iterator_t&amp;lt;R&amp;gt; middle,
                  Comp comp = {},
                  Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I partial_sort(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 I middle,
+                 S last,
+                 Comp comp = {},
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    partial_sort(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 iterator_t&amp;lt;R&amp;gt; middle,
+                 Comp comp = {},
+                 Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -39,6 +67,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は、「売り上げランキング トップ1位から10位まで」のように、全体ではなく最高順位から途中までの順位がわかればよい状況で、全体を並び替える[`sort()`](sort.md)関数の代わりに使用できる。
 
@@ -56,6 +86,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -81,6 +112,34 @@ int main()
 12435
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列に先頭3要素を並んだ状態にする
+  std::ranges::partial_sort(std::execution::par, v, v.begin() + 3);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partial_sort[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力例
+```
+1 1 2 4 5 9 3 6 5 3 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -93,3 +152,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_partial_sort_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort_copy.md b/reference/algorithm/ranges_partial_sort_copy.md
index bb5a1dd34..6ba612c0a 100644
--- a/reference/algorithm/ranges_partial_sort_copy.md
+++ b/reference/algorithm/ranges_partial_sort_copy.md
@@ -42,6 +42,48 @@ namespace std::ranges {
                       Comp comp = {},
                       Proj1 proj1 = {},
                       Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+             indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+  partial_sort_copy_result&amp;lt;I1, I2&amp;gt;
+    partial_sort_copy(Ep&amp;amp;&amp;amp; exec,
+                      I1 first,
+                      S1 last,
+                      I2 result_first,
+                      S2 result_last,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+             indirect_strict_weak_order&amp;lt;
+               Comp,
+               projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+             &amp;gt;
+  partial_sort_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    partial_sort_copy(Ep&amp;amp;&amp;amp; exec,
+                      R1&amp;amp;&amp;amp; r,
+                      R2&amp;amp;&amp;amp; result_r,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * partial_sort_copy_result[link ranges_in_out_result.md]
@@ -50,12 +92,18 @@ namespace std::ranges {
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を部分的にソートした結果を他の範囲にコピーする
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `N =` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` とする。
@@ -78,6 +126,7 @@ partial_sort_copy_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -104,6 +153,34 @@ int main()
 12
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 4, 1, 5, 9, 2, 6};
+  std::vector&amp;lt;int&amp;gt; dst(3);
+
+  // 並列に上位3個の要素をソートしてコピー
+  std::ranges::partial_sort_copy(std::execution::par,
+                                 src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partial_sort_copy[color ff0000]
+
+#### 出力
+```
+1 1 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +193,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_partition.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition.md b/reference/algorithm/ranges_partition.md
index 6d73b817e..a87c9e0d1 100644
--- a/reference/algorithm/ranges_partition.md
+++ b/reference/algorithm/ranges_partition.md
@@ -24,15 +24,45 @@ namespace std::ranges {
     partition(R&amp;amp;&amp;amp; r,
               Pred pred,
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    partition(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    partition(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -54,6 +84,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -93,6 +124,41 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+
+  // 並列に偶数グループと奇数グループに分ける
+  auto boundary = std::ranges::partition(std::execution::par, v, [](int x) { return x % 2 == 0; });
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;even: &amp;#34;;
+  for (auto it = v.begin(); it != boundary.begin(); ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;odd: &amp;#34;;
+  for (int x : boundary) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partition[color ff0000]
+
+#### 出力例
+```
+even: 8 2 6 4
+odd: 5 3 7 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +171,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
index 26ec256e3..0cf6d1f51 100644
--- a/reference/algorithm/ranges_partition_copy.md
+++ b/reference/algorithm/ranges_partition_copy.md
@@ -33,12 +33,53 @@ namespace std::ranges {
                    O2 out_false,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O1,
+            sized_sentinel_for&amp;lt;O1&amp;gt; OutS1,
+            random_access_iterator O2,
+            sized_sentinel_for&amp;lt;O2&amp;gt; OutS2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;I, O2&amp;gt;
+  partition_copy_result&amp;lt;I, O1, O2&amp;gt;
+    partition_copy(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   O1 out_true,
+                   OutS1 out_true_last,
+                   O2 out_false,
+                   OutS2 out_false_last,
+                   Pred pred,
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR1,
+            sized-random-access-range OutR2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR1&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR2&amp;gt;&amp;gt;
+  partition_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR1&amp;gt;, borrowed_iterator_t&amp;lt;OutR2&amp;gt;&amp;gt;
+    partition_copy(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   OutR1&amp;amp;&amp;amp; out_true,
+                   OutR2&amp;amp;&amp;amp; out_false,
+                   Pred pred,
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * partition_copy_result[link ranges_in_out_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -46,6 +87,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -64,6 +107,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -105,6 +149,45 @@ evens : 2,4,
 odds : 1,3,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+  std::vector&amp;lt;int&amp;gt; evens(8);
+  std::vector&amp;lt;int&amp;gt; odds(8);
+
+  // 並列に偶数と奇数に分類してコピー
+  auto [in_end, even_end, odd_end] =
+    std::ranges::partition_copy(std::execution::par, v,
+                                evens, odds,
+                                [](int x) { return x % 2 == 0; });
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;evens: &amp;#34;;
+  for (auto it = evens.begin(); it != even_end; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;odds: &amp;#34;;
+  for (auto it = odds.begin(); it != odd_end; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partition_copy[color ff0000]
+
+#### 出力
+```
+evens: 2 4 6 8
+odds: 1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -117,3 +200,4 @@ odds : 1,3,5,
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_remove.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove.md b/reference/algorithm/ranges_remove.md
index 046703e18..0ce717b59 100644
--- a/reference/algorithm/ranges_remove.md
+++ b/reference/algorithm/ranges_remove.md
@@ -53,15 +53,55 @@ namespace std::ranges {
     remove(R&amp;amp;&amp;amp; r,
            const T&amp;amp; value,
            Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
+    requires permutable&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    remove(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           S last,
+           const T&amp;amp; value,
+           Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T,
+            class Proj = identity&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           const T&amp;amp; value,
+           Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された要素を取り除く。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -172,6 +212,34 @@ int main() {
 5,6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 2, 5, 2, 7};
+
+  // 並列に値2を除去する
+  auto result = std::ranges::remove(std::execution::par, v, 2);
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -186,3 +254,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_remove_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy.md b/reference/algorithm/ranges_remove_copy.md
index 68e13f9ee..b241f71f8 100644
--- a/reference/algorithm/ranges_remove_copy.md
+++ b/reference/algorithm/ranges_remove_copy.md
@@ -71,18 +71,64 @@ namespace std::ranges {
                 O result,
                 const T&amp;amp; value,
                 Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  remove_copy_result&amp;lt;I, O&amp;gt;
+    remove_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                O result,
+                OutS result_last,
+                const T&amp;amp; value,
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  remove_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    remove_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                OutR&amp;amp;&amp;amp; result_r,
+                const T&amp;amp; value,
+                Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * remove_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された要素を除け、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なってはならない。
@@ -174,6 +220,33 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 2, 5, 2, 7};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に値2を除去してコピーする
+  auto result = std::ranges::remove_copy(std::execution::par, src, dst, 2);
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_copy[color ff0000]
+
+#### 出力
+```
+1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -188,3 +261,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy_if -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy_if.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_remove_copy_if.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy_if.md b/reference/algorithm/ranges_remove_copy_if.md
index 2f0c10842..369cf096e 100644
--- a/reference/algorithm/ranges_remove_copy_if.md
+++ b/reference/algorithm/ranges_remove_copy_if.md
@@ -29,18 +29,54 @@ namespace std::ranges {
                    O result,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  remove_copy_if_result&amp;lt;I, O&amp;gt;
+    remove_copy_if(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   O result,
+                   OutS result_last,
+                   Pred pred,
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  remove_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    remove_copy_if(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   OutR&amp;amp;&amp;amp; result_r,
+                   Pred pred,
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * remove_copy_if_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を除け、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なってはならない。
@@ -63,6 +99,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -84,6 +121,34 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に奇数を除去してコピーする
+  auto result = std::ranges::remove_copy_if(std::execution::par, src, dst,
+                                            [](int x) { return x % 2 != 0; });
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_copy_if[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +161,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_if -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_if.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_remove_if.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_if.md b/reference/algorithm/ranges_remove_if.md
index 6ee0da6da..b6c23a265 100644
--- a/reference/algorithm/ranges_remove_if.md
+++ b/reference/algorithm/ranges_remove_if.md
@@ -24,9 +24,37 @@ namespace std::ranges {
     remove_if(R&amp;amp;&amp;amp; r,
               Pred pred,
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    remove_if(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove_if(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -34,6 +62,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -59,6 +89,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -98,6 +129,35 @@ size before: 5
 size after: 2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  // 並列に奇数を除去する
+  auto result = std::ranges::remove_if(std::execution::par, v,
+                                       [](int x) { return x % 2 != 0; });
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_if[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +170,4 @@ size after: 2
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_replace.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace.md b/reference/algorithm/ranges_replace.md
index 9e208283a..26bc41e47 100644
--- a/reference/algorithm/ranges_replace.md
+++ b/reference/algorithm/ranges_replace.md
@@ -71,16 +71,59 @@ namespace std::ranges {
             const T1&amp;amp; old_value,
             const T2&amp;amp; new_value,
             Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;I, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  I replace(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (4) C++26
 }
 ```
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値と一致する要素を指定された値に置き換える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -168,6 +211,32 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 2, 5, 2, 7};
+
+  // 並列に値2を全て10に置き換える
+  std::ranges::replace(std::execution::par, v, 2, 10);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace[color ff0000]
+
+#### 出力
+```
+1 10 3 10 5 10 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -182,3 +251,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_replace_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy.md b/reference/algorithm/ranges_replace_copy.md
index 6fe9ba293..03ffe9d92 100644
--- a/reference/algorithm/ranges_replace_copy.md
+++ b/reference/algorithm/ranges_replace_copy.md
@@ -24,7 +24,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (1) C++20
+                 Proj proj = {});                     // (1) C++20
   template &amp;lt;input_iterator I,
             sentinel_for&amp;lt;I&amp;gt; S,
             class O,
@@ -43,7 +43,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (1) C++26
+                 Proj proj = {});                     // (1) C++26
 
   template &amp;lt;input_range R,
             class T1,
@@ -62,7 +62,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (2) C++20
+                 Proj proj = {});                     // (2) C++20
   template &amp;lt;input_range R,
             class O,
             class Proj = identity,
@@ -80,18 +80,68 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (2) C++26
+                 Proj proj = {});                     // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  replace_copy_result&amp;lt;I, O&amp;gt;
+    replace_copy(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 O result,
+                 OutS result_last,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {});                     // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  replace_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    replace_copy(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 OutR&amp;amp;&amp;amp; result_r,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {});                     // (4) C++26
 }
 ```
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * replace_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
@@ -185,6 +235,34 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 2, 1, 2};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に1を10に置き換えてコピー
+  std::ranges::replace_copy(std::execution::par,
+                            src, dst, 1, 10);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_copy[color ff0000]
+
+#### 出力
+```
+3 10 2 10 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -199,3 +277,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy_if.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_replace_copy_if.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy_if.md b/reference/algorithm/ranges_replace_copy_if.md
index ef97b244c..6dd2ba5c4 100644
--- a/reference/algorithm/ranges_replace_copy_if.md
+++ b/reference/algorithm/ranges_replace_copy_if.md
@@ -19,7 +19,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (1) C++20
+                    Proj proj = {});                  // (1) C++20
   template &amp;lt;input_iterator I,
             sentinel_for&amp;lt;I&amp;gt; S,
             class O,
@@ -35,7 +35,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (1) C++26
+                    Proj proj = {});                  // (1) C++26
 
   template &amp;lt;input_range R,
             class T,
@@ -48,7 +48,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (2) C++20
+                    Proj proj = {});                  // (2) C++20
   template &amp;lt;input_range R,
             class O,
             class T = iter_value_t&amp;lt;O&amp;gt;,
@@ -62,18 +62,58 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (2) C++26
+                    Proj proj = {});                  // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  replace_copy_if_result&amp;lt;I, O&amp;gt;
+    replace_copy_if(Ep&amp;amp;&amp;amp; exec,
+                    I first,
+                    S last,
+                    O result,
+                    OutS result_last,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {});                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  replace_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    replace_copy_if(Ep&amp;amp;&amp;amp; exec,
+                    R&amp;amp;&amp;amp; r,
+                    OutR&amp;amp;&amp;amp; result_r,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {});                  // (4) C++26
 }
 ```
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * replace_copy_if_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
@@ -172,6 +212,35 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 4, 1, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に奇数を0に置き換えてコピー
+  std::ranges::replace_copy_if(std::execution::par,
+                               src, dst,
+                               [](int x) { return x % 2 != 0; }, 0);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_copy_if[color ff0000]
+
+#### 出力
+```
+0 0 4 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -186,3 +255,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_if -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_if.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_replace_if.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_if.md b/reference/algorithm/ranges_replace_if.md
index 21580be08..6d8cd8f0d 100644
--- a/reference/algorithm/ranges_replace_if.md
+++ b/reference/algorithm/ranges_replace_if.md
@@ -17,7 +17,7 @@ namespace std::ranges {
                S last,
                Pred pred,
                const T&amp;amp; new_value,
-               Proj proj = {}); // (1) C++20
+               Proj proj = {});           // (1) C++20
 
   template &amp;lt;input_range R,
             class T,
@@ -28,17 +28,50 @@ namespace std::ranges {
     replace_if(R&amp;amp;&amp;amp; r,
                Pred pred,
                const T&amp;amp; new_value,
-               Proj proj = {}); // (2) C++20
+               Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_writable&amp;lt;I, const T&amp;amp;&amp;gt;
+  I replace_if(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {});           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace_if(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {});           // (4) C++26
 }
 ```
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を指定された値に置き換える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -64,6 +97,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -88,6 +122,33 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  // 並列に奇数を全て0に置き換える
+  std::ranges::replace_if(std::execution::par, v,
+                          [](int x) { return x % 2 != 0; }, 0);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_if[color ff0000]
+
+#### 出力
+```
+0 2 0 4 0 6 0 8 0 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -102,3 +163,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_reverse.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse.md b/reference/algorithm/ranges_reverse.md
index d144567a3..be480a16a 100644
--- a/reference/algorithm/ranges_reverse.md
+++ b/reference/algorithm/ranges_reverse.md
@@ -17,16 +17,37 @@ namespace std::ranges {
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     reverse(R&amp;amp;&amp;amp; r);  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  I reverse(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    reverse(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r);  // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 要素の並びを逆にする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -42,6 +63,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -62,6 +84,33 @@ esrever
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に要素の並びを逆にする
+  std::ranges::reverse(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::reverse[color ff0000]
+
+#### 出力
+```
+5 4 3 2 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -74,3 +123,4 @@ esrever
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_reverse_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse_copy.md b/reference/algorithm/ranges_reverse_copy.md
index c0370b15d..879d2d72e 100644
--- a/reference/algorithm/ranges_reverse_copy.md
+++ b/reference/algorithm/ranges_reverse_copy.md
@@ -21,18 +21,47 @@ namespace std::ranges {
   constexpr reverse_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     reverse_copy(R&amp;amp;&amp;amp; r,
                  O result); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  reverse_copy_truncated_result&amp;lt;I, O&amp;gt;
+    reverse_copy(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 O result,
+                 OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  reverse_copy_truncated_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    reverse_copy(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * reverse_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
+* reverse_copy_truncated_result[link ranges_in_in_out_result.md]
 
 ## 概要
 要素の並びを逆にし、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -44,7 +73,8 @@ namespace std::ranges {
 
 
 ## 戻り値
-`{ .in = last, .out = result + (last - first) }`
+- (1), (2): `{ .in = last, .out = result + (last - first) }`
+- (3), (4): 出力範囲が入力範囲より短い場合、出力範囲の末尾まで書き込み、`in1`と`in2`で入力範囲のどこまで処理されたかを示す。`in1`は常に`last`と等しく、`in2`は入力範囲内の停止点を指す。出力範囲が十分な場合は`in2 == first`となる
 
 
 ## 計算量
@@ -52,6 +82,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -66,11 +97,38 @@ int main() {
 ```
 * std::ranges::reverse_copy[color ff0000]
 
-### 出力
+#### 出力
 ```
 esrever
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に逆順コピーする
+  auto result = std::ranges::reverse_copy(std::execution::par, src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::reverse_copy[color ff0000]
+
+#### 出力
+```
+5 4 3 2 1
+```
+
 
 ## バージョン
 ### 言語
@@ -84,3 +142,5 @@ esrever
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_rotate.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate.md b/reference/algorithm/ranges_rotate.md
index a72fe1ebb..23a4eb07d 100644
--- a/reference/algorithm/ranges_rotate.md
+++ b/reference/algorithm/ranges_rotate.md
@@ -18,15 +18,39 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     rotate(R&amp;amp;&amp;amp; r,
            iterator_t&amp;lt;R&amp;gt; middle); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    rotate(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           I middle,
+           S last);               // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    rotate(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           iterator_t&amp;lt;R&amp;gt; middle); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` は有効な範囲である必要がある。
@@ -131,6 +155,34 @@ swapping 0x1806043(1) &amp;lt;-&amp;gt; 0x1806045(5)
 234501
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に要素を回転させる (先頭から2つ目の要素が先頭に来る)
+  std::ranges::rotate(std::execution::par, v, v.begin() + 2);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::rotate[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力
+```
+3 4 5 1 2
+```
+
 ## 実装例
 - [std::rotate を読んでみた](http://www.kmonos.net/wlog/115.html#_0007101223)
 
@@ -146,3 +198,4 @@ swapping 0x1806043(1) &amp;lt;-&amp;gt; 0x1806045(5)
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate_copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_rotate_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate_copy.md b/reference/algorithm/ranges_rotate_copy.md
index 6e2aa01a1..67725ea13 100644
--- a/reference/algorithm/ranges_rotate_copy.md
+++ b/reference/algorithm/ranges_rotate_copy.md
@@ -23,17 +23,48 @@ namespace std::ranges {
     rotate_copy(R&amp;amp;&amp;amp; r,
                 iterator_t&amp;lt;R&amp;gt; middle,
                 O result); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  rotate_copy_truncated_result&amp;lt;I, O&amp;gt;
+    rotate_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                I middle,
+                S last,
+                O result,
+                OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  rotate_copy_truncated_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    rotate_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; middle,
+                OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * rotate_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
+* rotate_copy_truncated_result[link ranges_in_in_out_result.md]
 
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -45,7 +76,8 @@ namespace std::ranges {
 
 
 ## 戻り値
-回転前の先頭の要素を指すイテレータ`result + (last - first)`
+- (1), (2): `{ .in = last, .out = result + (last - first) }`
+- (3), (4): 出力範囲が入力範囲より短い場合、出力範囲の末尾まで書き込み、`in1`と`in2`で入力範囲のどこまで処理されたかを示す。`in1`は`[middle, last)`の範囲内の停止点、`in2`は`[first, middle)`の範囲内の停止点を指す。出力範囲が十分な場合は`in1 == last`かつ`in2 == middle`となる
 
 
 ## 計算量
@@ -53,6 +85,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -71,11 +104,39 @@ int main() {
 * std::ranges::rotate_copy[color ff0000]
 * str.begin()[link /reference/string/basic_string/begin.md]
 
-### 出力
+#### 出力
 ```
 tatero
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に回転コピーする（3番目の要素が先頭になるように）
+  auto result = std::ranges::rotate_copy(
+    std::execution::par, src, src.begin() + 2, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::rotate_copy[color ff0000]
+
+#### 出力
+```
+3 4 5 1 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -88,3 +149,5 @@ tatero
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_search.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index 4ff7e480e..ef8d61005 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -35,14 +35,54 @@ namespace std::ranges {
            Pred pred = {},
            Proj1 proj1 = {},
            Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  subrange&amp;lt;I1&amp;gt;
+    search(Ep&amp;amp;&amp;amp; exec,
+           I1 first1,
+           S1 last1,
+           I2 first2,
+           S2 last2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_subrange_t&amp;lt;R1&amp;gt;
+    search(Ep&amp;amp;&amp;amp; exec,
+           R1&amp;amp;&amp;amp; r1,
+           R2&amp;amp;&amp;amp; r2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 あるシーケンスの中から、特定のサブシーケンスを探す
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 - (1) :
@@ -54,6 +94,7 @@ namespace std::ranges {
 最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,6 +124,33 @@ found: index==0
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 3, 4};
+  std::vector&amp;lt;int&amp;gt; pattern = {3, 4};
+
+  // 並列にサブシーケンスを検索する
+  auto sr = std::ranges::search(std::execution::par, v, pattern);
+  if (sr.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::search[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct search_impl {
@@ -128,3 +196,4 @@ inline constexpr search_impl search;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_difference.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_set_difference.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_difference.md b/reference/algorithm/ranges_set_difference.md
index 3cf8ab2d2..30a8b7c9b 100644
--- a/reference/algorithm/ranges_set_difference.md
+++ b/reference/algorithm/ranges_set_difference.md
@@ -39,6 +39,46 @@ namespace std::ranges {
                    Comp comp = {},
                    Proj1 proj1 = {},
                    Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_difference_result&amp;lt;I1, O&amp;gt;
+    set_difference(Ep&amp;amp;&amp;amp; exec,
+                   I1 first1,
+                   S1 last1,
+                   I2 first2,
+                   S2 last2,
+                   O result,
+                   OutS result_last,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    set_difference(Ep&amp;amp;&amp;amp; exec,
+                   R1&amp;amp;&amp;amp; r1,
+                   R2&amp;amp;&amp;amp; r2,
+                   OutR&amp;amp;&amp;amp; result_r,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_difference_result[link ranges_in_out_result.md]
@@ -46,6 +86,10 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -53,6 +97,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
@@ -83,6 +129,7 @@ set_difference_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -115,6 +162,40 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; b = {2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; result(a.size());
+
+  // 並列にa - bの差集合を作る
+  auto ret = std::ranges::set_difference(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_difference[color ff0000]
+
+#### 出力
+```
+1 5 6
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -127,3 +208,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_intersection.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_set_intersection.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_intersection.md b/reference/algorithm/ranges_set_intersection.md
index 6ae748e66..f349845a7 100644
--- a/reference/algorithm/ranges_set_intersection.md
+++ b/reference/algorithm/ranges_set_intersection.md
@@ -43,6 +43,50 @@ namespace std::ranges {
                      Comp comp = {},
                      Proj1 proj1 = {},
                      Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_intersection_result&amp;lt;I1, I2, O&amp;gt;
+    set_intersection(Ep&amp;amp;&amp;amp; exec,
+                     I1 first1,
+                     S1 last1,
+                     I2 first2,
+                     S2 last2,
+                     O result,
+                     OutS result_last,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_intersection_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              borrowed_iterator_t&amp;lt;OutR&amp;gt;
+            &amp;gt;
+    set_intersection(Ep&amp;amp;&amp;amp; exec,
+                     R1&amp;amp;&amp;amp; r1,
+                     R2&amp;amp;&amp;amp; r2,
+                     OutR&amp;amp;&amp;amp; result_r,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_intersection_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の積集合を得る
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -89,6 +139,7 @@ set_intersection_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -119,6 +170,40 @@ int main()
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; result(std::min(a.size(), b.size()));
+
+  // 並列にaとbの積集合を作る
+  auto ret = std::ranges::set_intersection(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_intersection[color ff0000]
+
+#### 出力
+```
+2 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -131,3 +216,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_symmetric_difference.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_set_symmetric_difference.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_symmetric_difference.md b/reference/algorithm/ranges_set_symmetric_difference.md
index b2c8fa3ce..64836ea7e 100644
--- a/reference/algorithm/ranges_set_symmetric_difference.md
+++ b/reference/algorithm/ranges_set_symmetric_difference.md
@@ -43,6 +43,50 @@ namespace std::ranges {
                              Comp comp = {},
                              Proj1 proj1 = {},
                              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_symmetric_difference_result&amp;lt;I1, I2, O&amp;gt;
+    set_symmetric_difference(Ep&amp;amp;&amp;amp; exec,
+                             I1 first1,
+                             S1 last1,
+                             I2 first2,
+                             S2 last2,
+                             O result,
+                             OutS result_last,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_symmetric_difference_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              borrowed_iterator_t&amp;lt;OutR&amp;gt;
+            &amp;gt;
+    set_symmetric_difference(Ep&amp;amp;&amp;amp; exec,
+                             R1&amp;amp;&amp;amp; r1,
+                             R2&amp;amp;&amp;amp; r2,
+                             OutR&amp;amp;&amp;amp; result_r,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_symmetric_difference_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -91,6 +141,7 @@ set_symmetric_difference_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -116,7 +167,7 @@ int main()
 * end()[link /reference/set/set/end.md]
 * std::inserter[link /reference/iterator/inserter.md]
 
-### 出力
+#### 出力
 ```
 1
 5
@@ -125,6 +176,39 @@ int main()
 8
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6, 8};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列に対称差を求める
+  auto [in1, in2, out] = std::ranges::set_symmetric_difference(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_symmetric_difference[color ff0000]
+
+#### 出力
+```
+1 3 5 6 8
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -137,3 +221,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_union.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_set_union.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_union.md b/reference/algorithm/ranges_set_union.md
index e4f8a977f..e650cf490 100644
--- a/reference/algorithm/ranges_set_union.md
+++ b/reference/algorithm/ranges_set_union.md
@@ -45,6 +45,52 @@ namespace std::ranges {
               Comp comp = {},
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_union_result&amp;lt;I1, I2, O&amp;gt;
+    set_union(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              OutS result_last,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;
+               iterator_t&amp;lt;R1&amp;gt;,
+               iterator_t&amp;lt;R2&amp;gt;,
+               iterator_t&amp;lt;OutR&amp;gt;,
+               Comp,
+               Proj1,
+               Proj2&amp;gt;
+  set_union_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    set_union(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              OutR&amp;amp;&amp;amp; result_r,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_union_result[link ranges_in_in_out_result.md]
@@ -52,12 +98,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の和集合を得る
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
@@ -83,6 +135,7 @@ set_union_result {
 最大で `2 * ((last1 - first1) + (last2 - first2)) - 1` 回の比較を行う
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -121,6 +174,40 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列にaとbの和集合を作る
+  auto ret = std::ranges::set_union(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_union[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -133,3 +220,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_left -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_left.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_shift_left.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_left.md b/reference/algorithm/ranges_shift_left.md
index 73310893b..712f3cdbc 100644
--- a/reference/algorithm/ranges_shift_left.md
+++ b/reference/algorithm/ranges_shift_left.md
@@ -18,15 +18,39 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     shift_left(R&amp;amp;&amp;amp; r,
                range_difference_t&amp;lt;R&amp;gt; n); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    shift_left(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               iter_difference_t&amp;lt;I&amp;gt; n);  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_left(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               range_difference_t&amp;lt;R&amp;gt; n); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の要素をn個だけ左にシフトさせる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
@@ -62,6 +86,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -86,6 +111,32 @@ int main()
 3,4,5,4,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に2つ左シフト
+  auto result = std::ranges::shift_left(std::execution::par, v, 2);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::shift_left[color ff0000]
+
+#### 出力
+```
+3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -98,3 +149,4 @@ int main()
 
 ## 参照
 - [N4901 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_right -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_right.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_shift_right.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_right.md b/reference/algorithm/ranges_shift_right.md
index 1d90e77d2..ca8d29d5d 100644
--- a/reference/algorithm/ranges_shift_right.md
+++ b/reference/algorithm/ranges_shift_right.md
@@ -18,9 +18,31 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     shift_right(R&amp;amp;&amp;amp; r,
                 range_difference_t&amp;lt;R&amp;gt; n); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    shift_right(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                iter_difference_t&amp;lt;I&amp;gt; n); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_right(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                range_difference_t&amp;lt;R&amp;gt; n); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -28,6 +50,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
@@ -63,6 +87,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -87,6 +112,32 @@ int main()
 1,2,1,2,3,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に2つ右シフト
+  auto result = std::ranges::shift_right(std::execution::par, v, 2);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::shift_right[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -99,3 +150,4 @@ int main()
 
 ## 参照
 - [N4901 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_sort.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort.md b/reference/algorithm/ranges_sort.md
index 95bb2f901..3fd99752c 100644
--- a/reference/algorithm/ranges_sort.md
+++ b/reference/algorithm/ranges_sort.md
@@ -25,17 +25,45 @@ namespace std::ranges {
     sort(R&amp;amp;&amp;amp; r,
          Comp comp = {},
          Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I sort(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         Comp comp = {},
+         Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    sort(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         Comp comp = {},
+         Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を並べ替える
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
@@ -164,6 +192,33 @@ Carol
 Bob
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列ソート
+  std::ranges::sort(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::sort[color ff0000]
+
+#### 出力
+```
+1 1 2 3 3 4 5 5 5 6 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -176,3 +231,4 @@ Bob
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_partition -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_partition.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_stable_partition.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_partition.md b/reference/algorithm/ranges_stable_partition.md
index 872f5f7cc..e425a0e81 100644
--- a/reference/algorithm/ranges_stable_partition.md
+++ b/reference/algorithm/ranges_stable_partition.md
@@ -43,9 +43,37 @@ namespace std::ranges {
     stable_partition(R&amp;amp;&amp;amp; r,
                      Pred pred,
                      Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    stable_partition(Ep&amp;amp;&amp;amp; exec,
+                     I first,
+                     S last,
+                     Pred pred,
+                     Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    stable_partition(Ep&amp;amp;&amp;amp; exec,
+                     R&amp;amp;&amp;amp; r,
+                     Pred pred,
+                     Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -53,6 +81,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -74,6 +104,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -102,6 +133,33 @@ int main()
 5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+
+  // 並列に相対順序を保ちながら偶数グループと奇数グループに分ける
+  std::ranges::stable_partition(std::execution::par, v, [](int x) { return x % 2 == 0; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::stable_partition[color ff0000]
+
+#### 出力
+```
+2 4 6 8 1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +174,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_sort -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_sort.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_stable_sort.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_sort.md b/reference/algorithm/ranges_stable_sort.md
index 8497fd89e..94f35b9ca 100644
--- a/reference/algorithm/ranges_stable_sort.md
+++ b/reference/algorithm/ranges_stable_sort.md
@@ -43,17 +43,45 @@ namespace std::ranges {
     stable_sort(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I stable_sort(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    stable_sort(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を安定ソートで並べ替える
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
@@ -72,6 +100,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -97,6 +126,33 @@ int main()
 12345
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列に安定ソートする
+  std::ranges::stable_sort(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::stable_sort[color ff0000]
+
+#### 出力
+```
+1 1 2 3 3 4 5 5 5 6 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -111,3 +167,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>starts_with -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_starts_with.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_starts_with.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_starts_with.md b/reference/algorithm/ranges_starts_with.md
index a3e605434..d7ee0b1c0 100644
--- a/reference/algorithm/ranges_starts_with.md
+++ b/reference/algorithm/ranges_starts_with.md
@@ -35,8 +35,46 @@ namespace std::ranges {
                 Pred pred = {},
                 Proj1 proj1 = {},
                 Proj2 proj2 = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool
+    starts_with(Ep&amp;amp;&amp;amp; exec,
+                I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool
+    starts_with(Ep&amp;amp;&amp;amp; exec,
+                R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -44,6 +82,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 
@@ -54,6 +94,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -70,13 +111,38 @@ int main() {
 ```
 * std::ranges::starts_with[color ff0000]
 
-### 出力
+#### 出力
 ```
 1
 0
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; prefix = {1, 2, 3};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に先頭が一致するかを判定
+  bool result = std::ranges::starts_with(std::execution::par, v, prefix);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::starts_with[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct starts_with_impl {
@@ -114,3 +180,4 @@ inline constexpr starts_with_impl starts_with;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap_ranges -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_swap_ranges.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_swap_ranges.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_swap_ranges.md b/reference/algorithm/ranges_swap_ranges.md
index eca99ff9a..d851f7e21 100644
--- a/reference/algorithm/ranges_swap_ranges.md
+++ b/reference/algorithm/ranges_swap_ranges.md
@@ -15,7 +15,7 @@ namespace std::ranges {
     swap_ranges(I1 first1,
                 S1 last1,
                 I2 first2,
-                S2 last2); // (1) C++20
+                S2 last2);                  // (1) C++20
 
   template &amp;lt;input_range R1,
             input_range R2&amp;gt;
@@ -24,17 +24,47 @@ namespace std::ranges {
               borrowed_iterator_t&amp;lt;R1&amp;gt;,
               borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
     swap_ranges(R1&amp;amp;&amp;amp; r1,
-                R2&amp;amp;&amp;amp; r2); // (2) C++20
+                R2&amp;amp;&amp;amp; r2);                   // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2&amp;gt;
+    requires indirectly_swappable&amp;lt;I1, I2&amp;gt;
+  swap_ranges_result&amp;lt;I1, I2&amp;gt;
+    swap_ranges(Ep&amp;amp;&amp;amp; exec,
+                I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2);                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2&amp;gt;
+    requires indirectly_swappable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+  swap_ranges_result&amp;lt;
+            borrowed_iterator_t&amp;lt;R1&amp;gt;,
+            borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    swap_ranges(Ep&amp;amp;&amp;amp; exec,
+                R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2);                   // (4) C++26
 }
 ```
 * swap_ranges_result[link ranges_in_in_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された2つの範囲同士を swap する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -63,6 +93,7 @@ swap_ranges_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -93,6 +124,41 @@ v1: 5,2,4,
 v2: 3,1,2,1,3,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {6, 7, 8, 9, 10};
+
+  // 並列に2つの範囲をswapする
+  std::ranges::swap_ranges(std::execution::par, v1, v2);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;v1: &amp;#34;;
+  for (int x : v1) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;v2: &amp;#34;;
+  for (int x : v2) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::swap_ranges[color ff0000]
+
+#### 出力
+```
+v1: 6 7 8 9 10
+v2: 1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +171,4 @@ v2: 3,1,2,1,3,
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_transform.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_transform.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_transform.md b/reference/algorithm/ranges_transform.md
index 6650810ac..dabb5817b 100644
--- a/reference/algorithm/ranges_transform.md
+++ b/reference/algorithm/ranges_transform.md
@@ -80,6 +80,93 @@ namespace std::ranges {
               F binary_op,
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (4) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I, Proj&amp;gt;&amp;gt;
+             &amp;gt;
+  unary_transform_result&amp;lt;I, O&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              I first1,
+              S last1,
+              O result,
+              OutS result_last,
+              F op,
+              Proj proj = {}); // (5) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               iterator_t&amp;lt;OutR&amp;gt;,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+             &amp;gt;
+  unary_transform_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              OutR&amp;amp;&amp;amp; result_r,
+              F op,
+              Proj proj = {}); // (6) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
+  binary_transform_result&amp;lt;I1, I2, O&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              OutS result_last,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (7) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               iterator_t&amp;lt;OutR&amp;gt;,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
+  binary_transform_result&amp;lt;
+            borrowed_iterator_t&amp;lt;R1&amp;gt;,
+            borrowed_iterator_t&amp;lt;R2&amp;gt;,
+            borrowed_iterator_t&amp;lt;OutR&amp;gt;
+          &amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              OutR&amp;amp;&amp;amp; result_r,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (8) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -88,6 +175,10 @@ namespace std::ranges {
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 * unary_transform_result[link ranges_in_out_result.md]
 * binary_transform_result[link ranges_in_in_out_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -95,6 +186,8 @@ namespace std::ranges {
 
 - (1), (2): 1つの範囲の要素に関数を適用し、結果を出力イテレータに出力する
 - (3), (4): 2つの範囲の要素を1つずつ取り出して関数を適用し、結果を出力イテレータに出力する
+- (5), (6): (1), (2)の並列アルゴリズム版。実行ポリシーを指定する
+- (7), (8): (3), (4)の並列アルゴリズム版。実行ポリシーを指定する
 
 - (1), (3): イテレータ範囲を指定する
 - (2), (4): Rangeを直接指定する
@@ -127,7 +220,8 @@ namespace std::ranges {
 - (3), (4) : `result` は `first1` や `first2` と同じであっても構わない。
 
 
-## (1)の例
+## 例
+### (1)の例
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -158,7 +252,7 @@ int main() {
 ```
 
 
-## (2)の例
+### (2)の例
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -188,6 +282,33 @@ b
 cccc
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; result(v.size());
+
+  // 並列に全ての要素を2乗する
+  std::ranges::transform(std::execution::par, v, result, [](int x) { return x * x; });
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::transform[color ff0000]
+
+#### 出力
+```
+1 4 9 16 25
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -200,6 +321,7 @@ cccc
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
 
 ## 関連項目
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_unique.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique.md b/reference/algorithm/ranges_unique.md
index 31f6880e6..04d030671 100644
--- a/reference/algorithm/ranges_unique.md
+++ b/reference/algorithm/ranges_unique.md
@@ -24,10 +24,38 @@ namespace std::ranges {
     unique(R&amp;amp;&amp;amp; r,
            C comp = {},
            Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    unique(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           S last,
+           C comp = {},
+           Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    unique(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           C comp = {},
+           Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
 * indirect_equivalence_relation[link /reference/iterator/indirect_equivalence_relation.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +63,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は、隣り合った重複要素を除いた要素を、範囲の先頭に集める。この関数によってコンテナから直接要素が削除され、コンテナの要素数が減るようなことはない。コンテナから実際に要素を削除する場合は、この関数の戻り値として、先頭に集められた重複なし範囲の末尾の次を指すイテレータが返るため、そのイテレータを介してコンテナの`erase()`メンバ関数などを呼び出し、削除を行うこと。
 
@@ -59,6 +89,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -118,6 +149,34 @@ unsorted unique : 2,5,3,1,2,4,2,1,4,3
 sorted unique : 1,2,3,4,5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 1, 2, 3, 3, 3, 4, 4, 5};
+
+  // 並列に隣り合った重複要素を除去する
+  auto result = std::ranges::unique(std::execution::par, v);
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::unique[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -130,3 +189,4 @@ sorted unique : 1,2,3,4,5
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique_copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/algorithm/ranges_unique_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique_copy.md b/reference/algorithm/ranges_unique_copy.md
index eb7d53793..30c2fbe5e 100644
--- a/reference/algorithm/ranges_unique_copy.md
+++ b/reference/algorithm/ranges_unique_copy.md
@@ -37,6 +37,36 @@ namespace std::ranges {
                 O result,
                 C comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  unique_copy_result&amp;lt;I, O&amp;gt;
+    unique_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                O result,
+                OutS result_last,
+                C comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  unique_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    unique_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                OutR&amp;amp;&amp;amp; result_r,
+                C comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -45,12 +75,18 @@ namespace std::ranges {
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
 * unique_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なっていてはならない
@@ -73,6 +109,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -129,6 +166,33 @@ unsorted unique : 2,5,3,1,2,4,2,1,4,3
 sorted unique : 1,2,3,4,5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 1, 2, 3, 3, 3, 4, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に隣り合った重複要素を除去してコピーする
+  auto result = std::ranges::unique_copy(std::execution::par, src, dst);
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::unique_copy[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -141,3 +205,4 @@ sorted unique : 1,2,3,4,5
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/execution.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/execution.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;execution&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;execution&lt;/span&gt;&lt;span class=&#34;cpp cpp17&#34; title=&#34;C++17で追加&#34;&gt;(C++17)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;execution&amp;gt;&lt;/code&gt;ヘッダでは、アルゴリズムの並列実行を許可するための実行ポリシー、汎用的な非同期実行フレームワークとしての実行制御ライブラリを定義する。&lt;/p&gt;
&lt;h2&gt;実行ポリシー(C++17)&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;execution&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行ポリシー用の名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/is_execution_policy.html&#34;&gt;is_execution_policy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が実行ポリシーかを判定する (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution-policy.html&#34;&gt;execution-policy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が実行ポリシーであることを表す (説明専用concept)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;実行制御ライブラリ(C++26)&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;execution&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行制御ライブラリの名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;this_thread&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行制御ライブラリ／Senderコンシューマの名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;li&gt;C++26 実行制御ライブラリ&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html&#34; target=&#34;_blank&#34;&gt;P0024R2 The Parallelism TS Should be Standardized&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html&#34; target=&#34;_blank&#34;&gt;P2300R10 &lt;code&gt;std::execution&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html&#34; target=&#34;_blank&#34;&gt;P3179R9 C++ parallel range algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution-policy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution-policy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/execution/execution-policy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution-policy.md b/reference/execution/execution-policy.md
new file mode 100644
index 000000000..635cbc8f0
--- /dev/null
+++ b/reference/execution/execution-policy.md
@@ -0,0 +1,31 @@
+# execution-policy
+* execution[meta header]
+* concept[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class T&amp;gt;
+  concept execution-policy = is_execution_policy_v&amp;lt;remove_cvref_t&amp;lt;T&amp;gt;&amp;gt;;
+}
+```
+* is_execution_policy_v[link is_execution_policy.md]
+* remove_cvref_t[link /reference/type_traits/remove_cvref.md]
+
+## 概要
+`execution-policy`は、型`T`が実行ポリシー型であることを表す説明専用のコンセプトである。
+
+このコンセプトは、並列Rangeアルゴリズムのテンプレートパラメータ制約として使用される。
+
+このコンセプトに合致する型は、以下のページを参照：
+
+- [実行ポリシー](execution/execution_policy.md)
+
+
+## バージョン
+### 言語
+- C++26
+
+## 参照
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_destroy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy.md b/reference/memory/ranges_destroy.md
index 075fcc299..19d0f925d 100644
--- a/reference/memory/ranges_destroy.md
+++ b/reference/memory/ranges_destroy.md
@@ -13,6 +13,17 @@ namespace std::ranges {
   template &amp;lt;no-throw-input-range R&amp;gt;
     requires destructible&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; destroy(R&amp;amp;&amp;amp; r) noexcept; // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I destroy(Ep&amp;amp;&amp;amp; exec, I first, S last) noexcept;           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires destructible&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt; destroy(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r) noexcept; // (4) C++26
 }
 ```
 * no-throw-input-iterator[link no-throw-input-iterator.md]
@@ -20,6 +31,10 @@ namespace std::ranges {
 * destructible[link /reference/concepts/destructible.md]
 * no-throw-input-range[link no-throw-input-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 デストラクタを呼び出す。
@@ -28,6 +43,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -52,6 +69,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -94,6 +112,35 @@ int main()
 0
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* p = alloc.allocate(3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::construct_at(p + i, &amp;#34;hello&amp;#34;);
+  }
+
+  // 並列に破棄
+  std::ranges::destroy(std::execution::par, p, p + 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::destroy[color ff0000]
+
+#### 出力
+```
+done
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -109,3 +156,4 @@ int main()
 
 ## 参照
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_destroy_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy_n.md b/reference/memory/ranges_destroy_n.md
index 258acf0e1..3d6da8eae 100644
--- a/reference/memory/ranges_destroy_n.md
+++ b/reference/memory/ranges_destroy_n.md
@@ -9,16 +9,26 @@ namespace std::ranges {
   template &amp;lt;no-throw-input-iterator I&amp;gt;
     requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
   constexpr I destroy_n(I first, iter_difference_t&amp;lt;I&amp;gt; n) noexcept; // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I destroy_n(Ep&amp;amp;&amp;amp; exec, I first, iter_difference_t&amp;lt;I&amp;gt; n) noexcept; // (2) C++26
 }
 ```
 * no-throw-input-iterator[link no-throw-input-iterator.md]
 * destructible[link /reference/concepts/destructible.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 イテレータ範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトを破棄するために使用する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -38,6 +48,7 @@ return destroy(counted_iterator(first, n), default_sentinel).base();
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -80,6 +91,35 @@ int main()
 0
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* p = alloc.allocate(3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::construct_at(p + i, &amp;#34;hello&amp;#34;);
+  }
+
+  // 並列にn個破棄
+  std::ranges::destroy_n(std::execution::par, p, 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::destroy_n[color ff0000]
+
+#### 出力
+```
+done
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -95,3 +135,4 @@ int main()
 
 ## 参照
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_copy.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy.md b/reference/memory/ranges_uninitialized_copy.md
index 7e76fade9..35100d93d 100644
--- a/reference/memory/ranges_uninitialized_copy.md
+++ b/reference/memory/ranges_uninitialized_copy.md
@@ -42,6 +42,29 @@ namespace std::ranges {
   &amp;gt;
     uninitialized_copy(IR&amp;amp;&amp;amp; in_range,
                        OR&amp;amp;&amp;amp; out_range); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, sized_sentinel_for&amp;lt;I&amp;gt; S1,
+            random_access_iterator O, sized_sentinel_for&amp;lt;O&amp;gt; S2&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_copy_result&amp;lt;I, O&amp;gt;
+    uninitialized_copy(Ep&amp;amp;&amp;amp; exec,
+                       I ifirst,
+                       S1 ilast,
+                       O ofirst,
+                       S2 olast);       // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range IR,
+            sized-random-access-range OR&amp;gt;
+  requires constructible_from&amp;lt;range_value_t&amp;lt;OR&amp;gt;, range_reference_t&amp;lt;IR&amp;gt;&amp;gt;
+  uninitialized_copy_result&amp;lt;
+    borrowed_iterator_t&amp;lt;IR&amp;gt;,
+    borrowed_iterator_t&amp;lt;OR&amp;gt;
+  &amp;gt;
+    uninitialized_copy(Ep&amp;amp;&amp;amp; exec,
+                       IR&amp;amp;&amp;amp; in_range,
+                       OR&amp;amp;&amp;amp; out_range); // (4) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -51,12 +74,18 @@ namespace std::ranges {
 * iter_reference_t[link /reference/iterator/iter_reference_t.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
-未初期化領域のイテレータ範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力イテレータ範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
+未初期化領域のイテレータ範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力イテレータ範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してコピー出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -105,6 +134,7 @@ return {std::move(ifirst), ofirst};
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -152,6 +182,39 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3};
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* dst = alloc.allocate(3);
+
+  // 並列に未初期化領域へコピー
+  std::ranges::uninitialized_copy(
+    std::execution::par, src, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_copy[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -169,3 +232,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_copy_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy_n.md b/reference/memory/ranges_uninitialized_copy_n.md
index fb409e56e..52380f451 100644
--- a/reference/memory/ranges_uninitialized_copy_n.md
+++ b/reference/memory/ranges_uninitialized_copy_n.md
@@ -31,6 +31,20 @@ namespace std::ranges {
       O ofirst,
       S olast
     );                               // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_copy_n_result&amp;lt;I, O&amp;gt;
+    uninitialized_copy_n(
+      Ep&amp;amp;&amp;amp; exec,
+      I ifirst,
+      iter_difference_t&amp;lt;I&amp;gt; n,
+      O ofirst,
+      S olast
+    );                               // (2) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -38,11 +52,15 @@ namespace std::ranges {
 * no-throw-sentinel[link no-throw-sentinel.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
 * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してコピー出力する。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +95,7 @@ return {std::move(t.in).base(), t.out};
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -123,6 +142,39 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* dst = alloc.allocate(3);
+
+  // 並列に3要素を未初期化領域へコピー
+  std::ranges::uninitialized_copy_n(
+    std::execution::par, src.begin(), 3, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_copy_n[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -140,3 +192,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_default_construct.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_default_construct.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_default_construct.md b/reference/memory/ranges_uninitialized_default_construct.md
index 32812ee0c..9e0669a5e 100644
--- a/reference/memory/ranges_uninitialized_default_construct.md
+++ b/reference/memory/ranges_uninitialized_default_construct.md
@@ -23,18 +23,38 @@ namespace std::ranges {
     requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_default_construct(R&amp;amp;&amp;amp; r);           // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_default_construct(Ep&amp;amp;&amp;amp; exec,
+                                    I first, S last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_default_construct(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r); // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素をデフォルト構築する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +97,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -124,6 +145,32 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にデフォルト構築
+  std::ranges::uninitialized_default_construct(
+    std::execution::par, p, p + 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::uninitialized_default_construct[color ff0000]
+
+#### 出力
+```
+done
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -142,3 +189,4 @@ int main()
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
 - [P3369R0 `constexpr` for `uninitialized_default_construct`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)
     - 上記2文書で、C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_default_construct_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_default_construct_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_default_construct_n.md b/reference/memory/ranges_uninitialized_default_construct_n.md
index 6e9cd283b..f9ff6fdbc 100644
--- a/reference/memory/ranges_uninitialized_default_construct_n.md
+++ b/reference/memory/ranges_uninitialized_default_construct_n.md
@@ -16,13 +16,26 @@ namespace std::ranges {
   constexpr I
     uninitialized_default_construct_n(I first,
                                       iter_difference_t&amp;lt;I&amp;gt; n); // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_default_construct_n(Ep&amp;amp;&amp;amp; exec,
+                                      I first,
+                                      iter_difference_t&amp;lt;I&amp;gt; n); // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) の各要素をデフォルト構築する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -46,6 +59,7 @@ return uninitialized_default_construct(counted_iterator(first, n),
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -92,6 +106,32 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個デフォルト構築
+  std::ranges::uninitialized_default_construct_n(
+    std::execution::par, p, 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::uninitialized_default_construct_n[color ff0000]
+
+#### 出力
+```
+done
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +150,4 @@ int main()
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
 - [P3369R0 `constexpr` for `uninitialized_default_construct`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)
     - 上記2文書で、C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_fill.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_fill.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_fill.md b/reference/memory/ranges_uninitialized_fill.md
index 735aa3dfa..4e2cd51e1 100644
--- a/reference/memory/ranges_uninitialized_fill.md
+++ b/reference/memory/ranges_uninitialized_fill.md
@@ -15,7 +15,8 @@ namespace std::ranges {
             no-throw-sentinel&amp;lt;I&amp;gt; S,
             class T&amp;gt;
     requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
-  I uninitialized_fill(I first, S last, const T&amp;amp; x); // (1) C++26
+  constexpr I
+    uninitialized_fill(I first, S last, const T&amp;amp; x); // (1) C++26
 
   template &amp;lt;no-throw-forward-range R,
             class T&amp;gt;
@@ -27,6 +28,22 @@ namespace std::ranges {
     requires constructible_from&amp;lt;range_value_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_fill(R&amp;amp;&amp;amp; r, const T&amp;amp; x);           // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T&amp;gt;
+    requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
+  I uninitialized_fill(Ep&amp;amp;&amp;amp; exec,
+                       I first, S last, const T&amp;amp; x); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T&amp;gt;
+    requires constructible_from&amp;lt;range_value_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_fill(Ep&amp;amp;&amp;amp; exec,
+                       R&amp;amp;&amp;amp; r, const T&amp;amp; x);           // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
@@ -34,12 +51,18 @@ namespace std::ranges {
 * constructible_from[link /reference/concepts/constructible_from.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) を、指定された値で配置`new`で初期化する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -78,6 +101,7 @@ return first;
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -121,6 +145,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列に未初期化領域を42で埋める
+  std::ranges::uninitialized_fill(
+    std::execution::par, p, p + 3, 42);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_fill[color ff0000]
+
+#### 出力
+```
+42 42 42
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -138,3 +192,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_fill_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_fill_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_fill_n.md b/reference/memory/ranges_uninitialized_fill_n.md
index 5c0377772..c90ee2a52 100644
--- a/reference/memory/ranges_uninitialized_fill_n.md
+++ b/reference/memory/ranges_uninitialized_fill_n.md
@@ -18,14 +18,28 @@ namespace std::ranges {
     uninitialized_fill_n(I first,
                          iter_difference_t&amp;lt;I&amp;gt; n,
                          const T&amp;amp; x);            // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, class T&amp;gt;
+    requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
+  I
+    uninitialized_fill_n(Ep&amp;amp;&amp;amp; exec,
+                         I first,
+                         iter_difference_t&amp;lt;I&amp;gt; n,
+                         const T&amp;amp; x);            // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) を、指定された値で配置`new`で初期化する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -48,6 +62,7 @@ return uninitialized_fill(counted_iterator(first, n), default_sentinel, x).base(
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -90,6 +105,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個の未初期化領域を99で埋める
+  std::ranges::uninitialized_fill_n(
+    std::execution::par, p, 3, 99);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_fill_n[color ff0000]
+
+#### 出力
+```
+99 99 99
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -107,3 +152,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_move.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move.md b/reference/memory/ranges_uninitialized_move.md
index 2fca1ad0f..2faf9699d 100644
--- a/reference/memory/ranges_uninitialized_move.md
+++ b/reference/memory/ranges_uninitialized_move.md
@@ -34,6 +34,26 @@ namespace std::ranges {
     borrowed_iterator_t&amp;lt;OR&amp;gt;
   &amp;gt;
     uninitialized_move(IR&amp;amp;&amp;amp; in_range, OR&amp;amp;&amp;amp; out_range);          // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, sized_sentinel_for&amp;lt;I&amp;gt; S1,
+            random_access_iterator O, sized_sentinel_for&amp;lt;O&amp;gt; S2&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_rvalue_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_move_result&amp;lt;I, O&amp;gt;
+    uninitialized_move(Ep&amp;amp;&amp;amp; exec,
+                       I ifirst, S1 ilast,
+                       O ofirst, S2 olast);                     // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range IR,
+            sized-random-access-range OR&amp;gt;
+  requires constructible_from&amp;lt;range_value_t&amp;lt;OR&amp;gt;, range_rvalue_reference_t&amp;lt;IR&amp;gt;&amp;gt;
+  uninitialized_move_result&amp;lt;
+    borrowed_iterator_t&amp;lt;IR&amp;gt;,
+    borrowed_iterator_t&amp;lt;OR&amp;gt;
+  &amp;gt;
+    uninitialized_move(Ep&amp;amp;&amp;amp; exec,
+                       IR&amp;amp;&amp;amp; in_range, OR&amp;amp;&amp;amp; out_range);          // (4) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -42,12 +62,18 @@ namespace std::ranges {
 * constructible_from[link /reference/concepts/constructible_from.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -97,6 +123,7 @@ return {std::move(ifirst), ofirst};
 またその場合、`[ifirst, ilast)`内の一部のオブジェクトは有効だが未規定な状態として残される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -144,6 +171,40 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;test&amp;#34;};
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* dst = alloc.allocate(3);
+
+  // 並列に未初期化領域へムーブ
+  std::ranges::uninitialized_move(
+    std::execution::par, src, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_move[color ff0000]
+
+#### 出力
+```
+hello world test
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -161,3 +222,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_move_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move_n.md b/reference/memory/ranges_uninitialized_move_n.md
index 044b99e9f..945884f49 100644
--- a/reference/memory/ranges_uninitialized_move_n.md
+++ b/reference/memory/ranges_uninitialized_move_n.md
@@ -31,17 +31,35 @@ namespace std::ranges {
       O ofirst,
       S olast
     );                               // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_rvalue_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_move_n_result&amp;lt;I, O&amp;gt;
+    uninitialized_move_n(
+      Ep&amp;amp;&amp;amp; exec,
+      I ifirst,
+      iter_difference_t&amp;lt;I&amp;gt; n,
+      O ofirst,
+      S olast
+    );                               // (2) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してムーブ出力する。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +95,7 @@ return {std::move(t.in).base(), t.out};
 またその場合、`[ifirst, ifirst + n)`内の一部のオブジェクトは有効だが未規定な状態として残される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -123,6 +142,40 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;test&amp;#34;};
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* dst = alloc.allocate(3);
+
+  // 並列に3要素を未初期化領域へムーブ
+  std::ranges::uninitialized_move_n(
+    std::execution::par, src.begin(), 3, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_move_n[color ff0000]
+
+#### 出力
+```
+hello world test
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -140,3 +193,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_value_construct.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_value_construct.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_value_construct.md b/reference/memory/ranges_uninitialized_value_construct.md
index 2e1d24423..587a6be87 100644
--- a/reference/memory/ranges_uninitialized_value_construct.md
+++ b/reference/memory/ranges_uninitialized_value_construct.md
@@ -23,18 +23,38 @@ namespace std::ranges {
     requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_value_construct(R&amp;amp;&amp;amp; r);            // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_value_construct(Ep&amp;amp;&amp;amp; exec,
+                                  I first, S last);  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_value_construct(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r); // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素を値構築する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -73,6 +93,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -120,6 +141,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列に値初期化
+  std::ranges::uninitialized_value_construct(
+    std::execution::par, p, p + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_value_construct[color ff0000]
+
+#### 出力
+```
+0 0 0
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -137,3 +188,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct_n -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_value_construct_n.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/memory/ranges_uninitialized_value_construct_n.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_value_construct_n.md b/reference/memory/ranges_uninitialized_value_construct_n.md
index be0805925..03103a277 100644
--- a/reference/memory/ranges_uninitialized_value_construct_n.md
+++ b/reference/memory/ranges_uninitialized_value_construct_n.md
@@ -16,13 +16,26 @@ namespace std::ranges {
   constexpr I
     uninitialized_value_construct_n(I first,
                                     iter_difference_t&amp;lt;I&amp;gt; n); // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_value_construct_n(Ep&amp;amp;&amp;amp; exec,
+                                    I first,
+                                    iter_difference_t&amp;lt;I&amp;gt; n); // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) の各要素を値構築する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -47,6 +60,7 @@ return uninitialized_value_construct(counted_iterator(first, n),
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -93,6 +107,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個値初期化
+  std::ranges::uninitialized_value_construct_n(
+    std::execution::par, p, 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_value_construct_n[color ff0000]
+
+#### 出力
+```
+0 0 0
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +154,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/ranges.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/ranges.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges.md b/reference/ranges.md
index 6956f1b61..395b20031 100644
--- a/reference/ranges.md
+++ b/reference/ranges.md
@@ -91,6 +91,7 @@ C++20では関数によるカスタマイゼーションポイントの問題点
 | [`common_range`](ranges/common_range.md)               | イテレータと番兵の型が等しいRange (concept)                 | C++20          |
 | [`viewable_range`](ranges/viewable_range.md)           | ビューに変換できるRange (concept)                           | C++20          |
 | [`constant_range`](ranges/constant_range.md)           | 要素が定数なRange (concept)                           | C++23          |
+| [`sized-random-access-range`](ranges/sized-random-access-range.md) | サイズ付きランダムアクセスRange (説明専用concept) | C++26          |
 
 ## カスタマイゼーションポイント
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sized-random-access-range -- Merge pull request #1581 from cpprefjp/paralle_range</title>
      <link href="https://cpprefjp.github.io/reference/ranges/sized-random-access-range.html"/>
      <id>2d382b2af21460549db4dc14b9123cbe7ec36d63:reference/ranges/sized-random-access-range.md</id>
      <updated>2026-02-05T14:05:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/sized-random-access-range.md b/reference/ranges/sized-random-access-range.md
new file mode 100644
index 000000000..c6b5e78a6
--- /dev/null
+++ b/reference/ranges/sized-random-access-range.md
@@ -0,0 +1,27 @@
+# sized-random-access-range
+* ranges[meta header]
+* concept[meta id-type]
+* std::ranges[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class R&amp;gt;
+  concept sized-random-access-range =
+    random_access_range&amp;lt;R&amp;gt; &amp;amp;&amp;amp; sized_range&amp;lt;R&amp;gt;;
+}
+```
+* random_access_range[link random_access_range.md]
+* sized_range[link sized_range.md]
+
+## 概要
+`sized-random-access-range`は、範囲`R`が[`random_access_range`](random_access_range.md)かつ[`sized_range`](sized_range.md)であることを表す説明専用のコンセプトである。
+
+このコンセプトは、並列Rangeアルゴリズムのテンプレートパラメータ制約として使用される。並列アルゴリズムでは、範囲のサイズが既知であり、かつランダムアクセスが可能である必要がある。
+
+## バージョン
+### 言語
+- C++26
+
+## 参照
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_find -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
index e9b81315a..72ce400c5 100644
--- a/reference/algorithm/ranges_adjacent_find.md
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -20,9 +20,36 @@ namespace std::ranges {
             projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;,
+            projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  I adjacent_find(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  S last,
+                  Pred pred = {},
+                  Proj proj = {});                                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    adjacent_find(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  Pred pred = {},
+                  Proj proj = {});                                  // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -30,6 +57,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 このアルゴリズムは、範囲の先頭から1つづつ進みながら隣接するペアに対して条件を満たすかをチェックし、その条件を満たす最初の要素へのイテレータを返す。指定された条件を満たしているかをチェックされるのは、現在位置にある要素とその次の位置にある要素の2つについてであり、1つの要素は最大2回参照される。
 
@@ -61,6 +90,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iterator&amp;gt;
@@ -83,13 +113,13 @@ int main() {
 * std::ranges::distance[link /reference/iterator/ranges_distance.md]
 * std::ranges::adjacent_find[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==2
 *it == *(it+1): true
 ```
 
-### 動作イメージ
+#### 動作イメージ
 
 ```
 |0  1  2  3  4  5  6| : index
@@ -102,6 +132,32 @@ found: index==2
                [2, 2]
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2};
+
+  // 並列に同じ値が連続している最初の要素を検索する
+  auto it = std::ranges::adjacent_find(std::execution::par, v);
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::adjacent_find[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct adjacent_find_impl {
@@ -144,3 +200,4 @@ inline constexpr adjacent_find_impl adjacent_find;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_all_of.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_all_of.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_all_of.md b/reference/algorithm/ranges_all_of.md
index 861c19bff..d04dd5edf 100644
--- a/reference/algorithm/ranges_all_of.md
+++ b/reference/algorithm/ranges_all_of.md
@@ -18,14 +18,40 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr bool
     all_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool all_of(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool all_of(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の全ての要素が条件を満たすかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -43,6 +69,7 @@ namespace std::ranges {
 最大で `last - first` 回 `proj` と `pred` を実行する。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -64,12 +91,37 @@ int main() {
 ```
 * std::ranges::all_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 true
 false
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 8, 10};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に全ての要素が偶数であるかを判定
+  bool result = std::ranges::all_of(std::execution::par, v,
+                                    [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::all_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct all_of_impl {
@@ -111,3 +163,4 @@ inline constexpr all_of_impl all_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_any_of.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_any_of.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_any_of.md b/reference/algorithm/ranges_any_of.md
index 25e3f53fb..4802baf5c 100644
--- a/reference/algorithm/ranges_any_of.md
+++ b/reference/algorithm/ranges_any_of.md
@@ -18,14 +18,40 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr bool
     any_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool any_of(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool any_of(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲のいずれかの要素が条件を満たすかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -45,6 +71,7 @@ namespace std::ranges {
 最大で `last - first` 回 `pred` を実行する。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -66,12 +93,37 @@ int main() {
 ```
 * std::ranges::any_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 7, 8};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にいずれかの要素が偶数であるかを判定
+  bool result = std::ranges::any_of(std::execution::par, v,
+                                    [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::any_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct any_of_impl {
@@ -114,3 +166,4 @@ inline constexpr any_of_impl any_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_contains.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains.md b/reference/algorithm/ranges_contains.md
index 761004798..ec958c6c1 100644
--- a/reference/algorithm/ranges_contains.md
+++ b/reference/algorithm/ranges_contains.md
@@ -59,14 +59,52 @@ namespace std::ranges {
     contains(R&amp;amp;&amp;amp; r,
              const T&amp;amp; value,
              Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  bool
+    contains(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  bool
+    contains(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値が含まれるか調べる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -148,6 +186,30 @@ found
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に値が含まれるかを判定
+  bool result = std::ranges::contains(std::execution::par, v, 4);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::contains[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct contains_impl {
@@ -182,3 +244,4 @@ inline constexpr contains_impl contains;
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains_subrange -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains_subrange.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_contains_subrange.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains_subrange.md b/reference/algorithm/ranges_contains_subrange.md
index 9be4d01fe..55bbe2a5b 100644
--- a/reference/algorithm/ranges_contains_subrange.md
+++ b/reference/algorithm/ranges_contains_subrange.md
@@ -6,7 +6,7 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
+  // (1) C++23
   template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1,
            forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
@@ -14,20 +14,43 @@ namespace std::ranges {
   constexpr bool ranges::contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
                                            Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
 
-  // (2)
+  // (2) C++23
   template&amp;lt;forward_range R1, forward_range R2,
            class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
   requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
   constexpr bool ranges::contains_subrange(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {},
                                            Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  // (3) C++26
+  template&amp;lt;execution-policy Ep,
+           random_access_iterator I1, sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+           random_access_iterator I2, sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool ranges::contains_subrange(Ep&amp;amp;&amp;amp; exec, I1 first1, S1 last1, I2 first2, S2 last2,
+                                 Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  // (4) C++26
+  template&amp;lt;execution-policy Ep,
+           sized-random-access-range R1, sized-random-access-range R2,
+           class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool ranges::contains_subrange(Ep&amp;amp;&amp;amp; exec, R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {},
+                                 Proj1 proj1 = {}, Proj2 proj2 = {});
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 あるシーケンスの中に、特定のサブシーケンスが含まれるか調べる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 サブシーケンスが空の場合は、常に`true`を返す。
 
@@ -40,6 +63,7 @@ first2 == last2 || !ranges::search(first1, last1, first2, last2, pred, proj1, pr
 最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;print&amp;gt;
@@ -64,6 +88,32 @@ int main() {
 found
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; sub = {2, 3, 4};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にサブ範囲が含まれるかを判定
+  bool result = std::ranges::contains_subrange(
+    std::execution::par, v, sub);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::contains_subrange[color ff0000]
+
+#### 出力
+```
+true
+```
+
 
 ## 実装例
 ```cpp
@@ -101,3 +151,4 @@ inline constexpr contains_subrange_impl contains_subrange;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy.md b/reference/algorithm/ranges_copy.md
index 7e13c6f73..d2579c96f 100644
--- a/reference/algorithm/ranges_copy.md
+++ b/reference/algorithm/ranges_copy.md
@@ -18,18 +18,46 @@ namespace std::ranges {
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     copy(R&amp;amp;&amp;amp; r, O result);           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_result&amp;lt;I, O&amp;gt;
+    copy(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         O result,
+         OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    copy(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * copy_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素をコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -57,6 +85,7 @@ copy_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,11 +112,38 @@ int main() {
 ```
 * std::ranges::copy[color ff0000]
 
-### 出力
+#### 出力
 ```
 3,1,2,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列にコピーする
+  std::ranges::copy(std::execution::par, src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -100,3 +156,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_copy_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_if.md b/reference/algorithm/ranges_copy_if.md
index 978a8b995..faf63d736 100644
--- a/reference/algorithm/ranges_copy_if.md
+++ b/reference/algorithm/ranges_copy_if.md
@@ -22,18 +22,54 @@ namespace std::ranges {
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_if_result&amp;lt;I, O&amp;gt;
+    copy_if(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            O result,
+            OutS result_last,
+            Pred pred,
+            Proj proj = {});                                       // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    copy_if(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            OutR&amp;amp;&amp;amp; result_r,
+            Pred pred,
+            Proj proj = {});                                       // (4) C++26
 }
 ```
 * copy_if_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素のみをコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -60,6 +96,7 @@ copy_if_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -91,6 +128,34 @@ int main() {
 3,1,1,5,9,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に偶数のみをコピーする
+  auto result = std::ranges::copy_if(std::execution::par, src, dst,
+                                     [](int x) { return x % 2 == 0; });
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy_if[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -103,3 +168,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_copy_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_n.md b/reference/algorithm/ranges_copy_n.md
index 34cb49ca2..2bb46e287 100644
--- a/reference/algorithm/ranges_copy_n.md
+++ b/reference/algorithm/ranges_copy_n.md
@@ -13,17 +13,33 @@ namespace std::ranges {
   constexpr copy_n_result&amp;lt;I, O&amp;gt;
     copy_n(I first,
            iter_difference_t&amp;lt;I&amp;gt; n,
-           O result); // (1) C++20
+           O result);                // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  copy_n_result&amp;lt;I, O&amp;gt;
+    copy_n(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           iter_difference_t&amp;lt;I&amp;gt; n,
+           O result,
+           OutS result_last);        // (2) C++26
 }
 ```
 * copy_n_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 指定された数の要素をコピーする。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
 
 
 ## 効果
@@ -45,6 +61,7 @@ copy_n_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -67,6 +84,34 @@ int main() {
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(5);
+
+  // 並列に先頭3要素をコピー
+  std::ranges::copy_n(std::execution::par, src.begin(), 3,
+                      dst.begin(), dst.begin() + 3);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::copy_n[color ff0000]
+
+#### 出力
+```
+1 2 3 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -79,3 +124,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_count.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 58a13d5e8..05e78aae0 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -43,14 +43,44 @@ namespace std::ranges {
     count(R&amp;amp;&amp;amp; r,
           const T&amp;amp; value,
           Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  iter_difference_t&amp;lt;I&amp;gt;
+    count(Ep&amp;amp;&amp;amp; exec,
+          I first,
+          S last,
+          const T&amp;amp; value,
+          Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  range_difference_t&amp;lt;R&amp;gt;
+    count(Ep&amp;amp;&amp;amp; exec,
+          R&amp;amp;&amp;amp; r,
+          const T&amp;amp; value,
+          Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値と等値な要素の数を数える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -170,6 +200,28 @@ count of id==1: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2, 1};
+
+  // 並列に値が 1 の要素がいくつあるかを数える
+  auto n = std::ranges::count(std::execution::par, v, 1);
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of 1: &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count[color ff0000]
+
+#### 出力
+```
+count of 1: 3
+```
+
 ## 実装例
 ```cpp
 struct count_impl {
@@ -210,3 +262,4 @@ inline constexpr count_impl count;
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_count_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 265ff9c5a..3aa760e14 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -18,8 +18,34 @@ namespace std::ranges {
             indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr range_difference_t&amp;lt;R&amp;gt;
     count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  iter_difference_t&amp;lt;I&amp;gt;
+    count_if(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             Pred pred,
+             Proj proj = {});                             // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  range_difference_t&amp;lt;R&amp;gt;
+    count_if(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             Pred pred,
+             Proj proj = {});                             // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -27,6 +53,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -47,6 +75,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -62,12 +91,35 @@ int main() {
 ```
 * std::ranges::count_if[color ff0000]
 
-### 出力
+#### 出力
 ```cpp
 count of 1 or 3: 5
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 3, 1, 2, 2, 1};
+
+  // 並列に値が偶数の要素がいくつあるかを数える
+  auto n = std::ranges::count_if(std::execution::par, v,
+                                 [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of even: &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count_if[color ff0000]
+
+#### 出力
+```
+count of even: 3
+```
+
 ## 実装例
 ```cpp
 struct count_if_impl {
@@ -104,3 +156,4 @@ inline constexpr count_if_impl count_if;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ends_with -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_ends_with.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_ends_with.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_ends_with.md b/reference/algorithm/ranges_ends_with.md
index 4b15e622c..a5e321787 100644
--- a/reference/algorithm/ranges_ends_with.md
+++ b/reference/algorithm/ranges_ends_with.md
@@ -39,9 +39,46 @@ namespace std::ranges {
               Pred pred = {},
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool
+    ends_with(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool
+    ends_with(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -49,6 +86,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 
@@ -66,6 +105,7 @@ namespace std::ranges {
 最大で `N2` 回の対応する述語が適用される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,7 +123,7 @@ int main() {
 ```
 * std::ranges::ends_with[color ff0000]
 
-### 出力
+#### 出力
 ```
 0
 0
@@ -91,6 +131,31 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; suffix = {4, 5, 6};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に末尾が一致するかを判定
+  bool result = std::ranges::ends_with(std::execution::par, v, suffix);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::ends_with[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct ends_with_impl {
@@ -138,3 +203,4 @@ inline constexpr ends_with_impl ends_with;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_equal.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
index d3a0c6d14..2493dbde1 100644
--- a/reference/algorithm/ranges_equal.md
+++ b/reference/algorithm/ranges_equal.md
@@ -35,14 +35,52 @@ namespace std::ranges {
           Pred pred = {},
           Proj1 proj1 = {},
           Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool equal(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool equal(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つの範囲を等値比較する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 2つの範囲の要素数および各要素が等値であった場合、`true`を返す。
 
@@ -57,6 +95,7 @@ namespace std::ranges {
 最大で `min(last1 - first1, last2 - first2)` 回の述語が適用される。ただし、2つの範囲の長さを定数時間で求められ、かつ、長さが異なる場合、1 度も述語は適用されない。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -79,13 +118,38 @@ int main() {
 ```
 * std::ranges::equal[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {1, 2, 3, 4, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に2つの範囲が等しいかを判定
+  bool result = std::ranges::equal(std::execution::par, v1, v2);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::equal[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 
 ```cpp
@@ -130,3 +194,4 @@ inline constexpr equal_impl equal;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_fill.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill.md b/reference/algorithm/ranges_fill.md
index 2c2985e6b..3987beacd 100644
--- a/reference/algorithm/ranges_fill.md
+++ b/reference/algorithm/ranges_fill.md
@@ -10,32 +10,58 @@ namespace std::ranges {
             output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
             sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
   constexpr O
-    fill(O first, S last, const T&amp;amp; value); // (1) C++20
+    fill(O first, S last, const T&amp;amp; value);           // (1) C++20
   template &amp;lt;class I,
             sentinel_for&amp;lt;O&amp;gt; S,
             class T = iter_value_t&amp;lt;O&amp;gt;&amp;gt;
     requires output_iterator&amp;lt;O, const T&amp;amp;&amp;gt;
   constexpr O
-    fill(O first, S last, const T&amp;amp; value); // (1) C++26
+    fill(O first, S last, const T&amp;amp; value);           // (1) C++26
 
   template &amp;lt;class T,
             output_range&amp;lt;const T&amp;amp;&amp;gt; R&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
-    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);           // (2) C++20
+    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);                     // (2) C++20
   template &amp;lt;class R,
             class T = range_value_t&amp;lt;R&amp;gt;&amp;gt;
     requires output_range&amp;lt;R, const T&amp;amp;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
-    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);           // (2) C++26
+    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);                     // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;O, const T&amp;amp;&amp;gt;
+  O fill(Ep&amp;amp;&amp;amp; exec,
+         O first,
+         S last,
+         const T&amp;amp; value);                            // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    fill(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value);                            // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値で出力の範囲に書き込む。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -118,6 +144,32 @@ int main() {
 1,2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(10);
+
+  // 並列に全要素を42で埋める
+  std::ranges::fill(std::execution::par, v, 42);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::fill[color ff0000]
+
+#### 出力
+```
+42 42 42 42 42 42 42 42 42 42
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -132,3 +184,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_fill_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill_n.md b/reference/algorithm/ranges_fill_n.md
index dfca5a816..64bfa0c80 100644
--- a/reference/algorithm/ranges_fill_n.md
+++ b/reference/algorithm/ranges_fill_n.md
@@ -11,20 +11,35 @@ namespace std::ranges {
   constexpr O
     fill_n(O first,
            iter_difference_t&amp;lt;O&amp;gt; n,
-           const T&amp;amp; value);   // (1) C++20
+           const T&amp;amp; value);             // (1) C++20
   template &amp;lt;class O,
             class T = iter_value_t&amp;lt;O&amp;gt;&amp;gt;
     requires output_iterator&amp;lt;O, const T&amp;amp;&amp;gt;
   constexpr O
     fill_n(O first,
            iter_difference_t&amp;lt;O&amp;gt; n,
-           const T&amp;amp; value);   // (1) C++26
+           const T&amp;amp; value);             // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            class T&amp;gt;
+    requires indirectly_writable&amp;lt;O, const T&amp;amp;&amp;gt;
+  O fill_n(Ep&amp;amp;&amp;amp; exec,
+           O first,
+           iter_difference_t&amp;lt;O&amp;gt; n,
+           const T&amp;amp; value);             // (2) C++26
 }
 ```
+* indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 指定された値で出力の範囲に `n` 個を書き込む。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## 効果
 `n` が 1 以上の場合は `[first,first + n)` 内の全ての要素に `value` を代入し、そうでない場合は何もしない。
@@ -102,6 +117,32 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(5);
+
+  // 並列に先頭3要素を42で埋める
+  std::ranges::fill_n(std::execution::par, v.begin(), 3, 42);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::fill_n[color ff0000]
+
+#### 出力
+```
+42 42 42 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +157,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 8823240a0..67daa20d7 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -43,15 +43,44 @@ namespace std::ranges {
     find(R&amp;amp;&amp;amp; r,
          const T&amp;amp; value,
          Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  I find(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         const T&amp;amp; value,
+         Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value,
+         Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -186,6 +215,29 @@ int main() {
 found: 3,4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に値を検索する
+  auto it = std::ranges::find(std::execution::par, v, 5);
+  if (it != v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find[color ff0000]
+
+#### 出力
+```
+found: 5
+```
 
 ## 実装例
 ```cpp
@@ -226,3 +278,4 @@ inline constexpr find_impl find;
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_end.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
index 6369dfd7e..8d6310f30 100644
--- a/reference/algorithm/ranges_find_end.md
+++ b/reference/algorithm/ranges_find_end.md
@@ -35,14 +35,54 @@ namespace std::ranges {
              Pred pred = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  subrange&amp;lt;I1&amp;gt;
+    find_end(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_subrange_t&amp;lt;R1&amp;gt;
+    find_end(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、特定のサブシーケンスを検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -61,6 +101,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -85,12 +126,39 @@ int main() {
 ```
 * std::ranges::find_end[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==2
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 1, 2, 3};
+  std::vector&amp;lt;int&amp;gt; pattern = {1, 2};
+
+  // 並列にサブシーケンスを末尾から検索する
+  auto sr = std::ranges::find_end(std::execution::par, v, pattern);
+  if (sr.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_end[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct find_end_impl {
@@ -130,3 +198,4 @@ inline constexpr find_end_impl find_end;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index a4beb961a..db300c21b 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -35,15 +35,55 @@ namespace std::ranges {
                   Pred pred = {},
                   Proj1 proj1 = {},
                   Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  I1
+    find_first_of(Ep&amp;amp;&amp;amp; exec,
+                  I1 first1,
+                  S1 last1,
+                  I2 first2,
+                  S2 last2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_iterator_t&amp;lt;R1&amp;gt;
+    find_first_of(Ep&amp;amp;&amp;amp; exec,
+                  R1&amp;amp;&amp;amp; r1,
+                  R2&amp;amp;&amp;amp; r2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 ある集合の1つとマッチする最初の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -57,6 +97,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -78,12 +119,40 @@ int main() {
 ```
 * std::ranges::find_first_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: index==3, value==4
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 7, 4, 2};
+  std::vector&amp;lt;int&amp;gt; targets = {2, 4, 6, 8};
+
+  // 並列に targets のいずれかと一致する最初の要素を検索する
+  auto it = std::ranges::find_first_of(std::execution::par, v, targets);
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it)
+              &amp;lt;&amp;lt; &amp;#34;, value==&amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_first_of[color ff0000]
+
+#### 出力
+```
+found: index==3, value==4
+```
+
 ## 実装例
 ```cpp
 struct find_first_of_impl {
@@ -124,3 +193,4 @@ inline constexpr find_first_of_impl find_first_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
index e6cf396a7..bd5d39c34 100644
--- a/reference/algorithm/ranges_find_if.md
+++ b/reference/algorithm/ranges_find_if.md
@@ -23,15 +23,42 @@ namespace std::ranges {
     find_if(R&amp;amp;&amp;amp; r,
             Pred pred,
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  I find_if(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            Pred pred,
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            Pred pred,
+            Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たす最初の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -61,12 +89,39 @@ int main() {
 ```
 * std::ranges::find_if[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9};
+
+  // 並列に5以上の最初の要素を検索する
+  auto result = std::ranges::find_if(std::execution::par, v,
+                                     [](int x) { return x &amp;gt;= 5; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if[color ff0000]
+
+#### 出力
+```
+found: 5
+```
+
 ## 実装例
 ```cpp
 struct find_if_impl {
@@ -103,3 +158,4 @@ inline constexpr find_if_impl find_if;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
index 250693822..edee510d5 100644
--- a/reference/algorithm/ranges_find_if_not.md
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -23,15 +23,42 @@ namespace std::ranges {
     find_if_not(R&amp;amp;&amp;amp; r,
                 Pred pred,
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  I find_if_not(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Pred pred,
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if_not(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Pred pred,
+                Proj proj = {}); // (4) C++26
 }
 ```
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たさない最初の要素を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -61,12 +89,39 @@ int main() {
 ```
 * std::ranges::find_if_not[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 5, 6, 8};
+
+  // 並列に偶数でない最初の要素を検索する
+  auto result = std::ranges::find_if_not(std::execution::par, v,
+                                         [](int x) { return x % 2 == 0; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if_not[color ff0000]
+
+#### 出力
+```
+found: 5
+```
+
 ## 実装例
 ```cpp
 struct find_if_not_impl {
@@ -103,3 +158,4 @@ inline constexpr find_if_not_impl find_if_not;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_last.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last.md b/reference/algorithm/ranges_find_last.md
index 228a6d65f..41a33158c 100644
--- a/reference/algorithm/ranges_find_last.md
+++ b/reference/algorithm/ranges_find_last.md
@@ -59,14 +59,52 @@ namespace std::ranges {
     find_last(R&amp;amp;&amp;amp; r,
               const T&amp;amp; value,
               Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              const T&amp;amp; value,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              const T&amp;amp; value,
+              Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を末尾から検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -153,6 +191,33 @@ found: 3,4
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 3, 7};
+
+  // 並列に最後の3を検索
+  auto result = std::ranges::find_last(std::execution::par, v, 3);
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last[color ff0000]
+
+#### 出力
+```
+found: 3
+position: 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -169,3 +234,4 @@ found: 3,4
     - C++26で波カッコ初期化 (リスト初期化) に対応した
     - 関連文書：
         - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_last_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last_if.md b/reference/algorithm/ranges_find_last_if.md
index 3364c92a8..83e9417b7 100644
--- a/reference/algorithm/ranges_find_last_if.md
+++ b/reference/algorithm/ranges_find_last_if.md
@@ -23,14 +23,42 @@ namespace std::ranges {
     find_last_if(R&amp;amp;&amp;amp; r,
                  Pred pred,
                  Proj proj = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last_if(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 Pred pred,
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last_if(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 Pred pred,
+                 Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たす最後の要素を検索する。
 
-* (1): イテレータ範囲を指定する
-* (2): Rangeを直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -42,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -60,12 +89,40 @@ int main() {
 ```
 * std::ranges::find_last_if[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 4, 3, 6, 5};
+
+  // 並列に最後の偶数を検索
+  auto result = std::ranges::find_last_if(std::execution::par, v,
+                                          [](int x) { return x % 2 == 0; });
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last_if[color ff0000]
+
+#### 出力
+```
+found: 6
+position: 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -78,3 +135,4 @@ found: 1
 
 ## 参照
 - [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last_if_not -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last_if_not.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_find_last_if_not.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last_if_not.md b/reference/algorithm/ranges_find_last_if_not.md
index fbbc83a07..5d7e3e689 100644
--- a/reference/algorithm/ranges_find_last_if_not.md
+++ b/reference/algorithm/ranges_find_last_if_not.md
@@ -23,14 +23,42 @@ namespace std::ranges {
     find_last_if_not(R&amp;amp;&amp;amp; r,
                      Pred pred,
                      Proj proj = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::subrange&amp;lt;I&amp;gt;
+    find_last_if_not(Ep&amp;amp;&amp;amp; exec,
+                     I first,
+                     S last,
+                     Pred pred,
+                     Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last_if_not(Ep&amp;amp;&amp;amp; exec,
+                     R&amp;amp;&amp;amp; r,
+                     Pred pred,
+                     Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の中から、指定された条件を満たさない最後の要素を検索する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -42,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -60,12 +89,40 @@ int main() {
 ```
 * std::ranges::find_last_if_not[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 3, 6, 8};
+
+  // 並列に最後の偶数でない要素を検索
+  auto result = std::ranges::find_last_if_not(std::execution::par, v,
+                                              [](int x) { return x % 2 == 0; });
+
+  if (!result.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;position: &amp;#34; &amp;lt;&amp;lt; (result.begin() - v.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last_if_not[color ff0000]
+
+#### 出力
+```
+found: 3
+position: 2
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -78,3 +135,4 @@ found: 1
 
 ## 参照
 - [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_for_each.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each.md b/reference/algorithm/ranges_for_each.md
index 8638277ae..8617440cf 100644
--- a/reference/algorithm/ranges_for_each.md
+++ b/reference/algorithm/ranges_for_each.md
@@ -23,11 +23,36 @@ namespace std::ranges {
     for_each(R&amp;amp;&amp;amp; r,
              Fun f,
              Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  I for_each(Ep&amp;amp;&amp;amp; exec,
+             I first,
+             S last,
+             Fun f,
+             Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    for_each(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             Fun f,
+             Proj proj = {}); // (4) C++26
 }
 ```
 * indirectly_unary_invocable[link /reference/iterator/indirectly_unary_invocable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 * for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +60,8 @@ namespace std::ranges {
 
 * (1): イテレータ範囲を指定する
 * (2): Rangeを直接指定する
+* (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+* (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -54,14 +81,16 @@ namespace std::ranges {
 
 
 ## 戻り値
+- (1), (2):
+    ```cpp
+    for_each_result {
+      .in = last,
+      .fun = std::move(f),
+    }
+    ```
+    * for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
 
-```cpp
-for_each_result {
-  .in = last,
-  .fun = std::move(f),
-}
-```
-* for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
+- (3), (4): `last`
 
 ## 計算量
 正確に `f` を `last - first` 回適用する
@@ -72,7 +101,7 @@ for_each_result {
 
 
 ## 例
-
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;array&amp;gt;
@@ -105,6 +134,35 @@ int main() {
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に全ての要素を2倍にする
+  std::ranges::for_each(std::execution::par, v, [](int&amp;amp; x) { x *= 2; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::for_each[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
+## バージョン
+### 言語
+- C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
@@ -112,7 +170,6 @@ int main() {
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 10 [mark verified]
 
-
 ## 実装例
 ```cpp
 struct for_each_impl {
@@ -142,3 +199,4 @@ inline constexpr for_each_impl for_each;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index 7095a7aeb..241ab8d8a 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -14,14 +14,29 @@ namespace std::ranges {
                iter_difference_t&amp;lt;I&amp;gt; n,
                Fun f,
                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  I for_each_n(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               iter_difference_t&amp;lt;I&amp;gt; n,
+               Fun f,
+               Proj proj = {}); // (2) C++26
 }
 ```
 * indirectly_unary_invocable[link /reference/iterator/indirectly_unary_invocable.md]
 * for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 範囲の先頭N個の要素に、指定された関数を適用する。
 
+- (1): 通常版
+- (2): 並列アルゴリズム版。実行ポリシーを指定する
+
 ## テンプレートパラメータ制約
 - `I`が[`input_iterator`](/reference/iterator/input_iterator.md)である
 - `Fun`は`I`を`Proj`で射影した値を受け取る[1引数の`invocable`](/reference/iterator/indirectly_unary_invocable.md)である
@@ -38,18 +53,22 @@ namespace std::ranges {
 このアルゴリズムはその他のアルゴリズムと違い、[`invoke`](/reference/functional/invoke.md)`(proj, *i)` が書き換え可能な参照であれば、関数 `f` の内部でその値を書き換えても構わない。
 
 ## 戻り値
-```cpp
-for_each_n_result {
-  .in = first + n,
-  .fun = std::move(f)
-}
-```
-* for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+- (1):
+    ```cpp
+    for_each_n_result {
+      .in = first + n,
+      .fun = std::move(f)
+    }
+    ```
+    * for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
+
+- (2): `first + n`
 
 ## 備考
 - 関数 `f` に戻り値がある場合、それは単に無視される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -84,6 +103,33 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に先頭3要素を出力
+  std::ranges::for_each_n(std::execution::par, v.begin(), 3,
+                          [](int x) { std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;; });
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::for_each_n[color ff0000]
+
+#### 出力例
+```
+1 2 3
+```
+
+## バージョン
+### 言語
+- C++20
+
 ### 処理系
 - [Clang](/implementation.md#clang): ??
 - [GCC](/implementation.md#gcc): 10.1.0 [mark verified]
@@ -113,3 +159,4 @@ inline constexpr for_each_n_impl for_each_n;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_generate.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate.md b/reference/algorithm/ranges_generate.md
index 45d70770d..0ccfffdd4 100644
--- a/reference/algorithm/ranges_generate.md
+++ b/reference/algorithm/ranges_generate.md
@@ -13,25 +13,50 @@ namespace std::ranges {
   constexpr O
     generate(O first,
              S last,
-             F gen); // (1) C++20
+             F gen);                  // (1) C++20
 
   template &amp;lt;class R,
             copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; output_range&amp;lt;R, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     generate(R&amp;amp;&amp;amp; r,
-             F gen); // (2) C++20
+             F gen);                  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  O generate(Ep&amp;amp;&amp;amp; exec,
+             O first,
+             S last,
+             F gen);                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    generate(Ep&amp;amp;&amp;amp; exec,
+             R&amp;amp;&amp;amp; r,
+             F gen);                  // (4) C++26
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 出力の範囲へ関数の結果を書き込む。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -47,6 +72,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -71,6 +97,32 @@ int main() {
 1,2,4,8,16,32,64,128,256,512,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(10);
+
+  // 並列に全要素を99で埋める
+  std::ranges::generate(std::execution::par, v, [] { return 99; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::generate[color ff0000]
+
+#### 出力
+```
+99 99 99 99 99 99 99 99 99 99
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -83,3 +135,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_generate_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate_n.md b/reference/algorithm/ranges_generate_n.md
index 6f06cec13..56f5f2c9d 100644
--- a/reference/algorithm/ranges_generate_n.md
+++ b/reference/algorithm/ranges_generate_n.md
@@ -13,15 +13,29 @@ namespace std::ranges {
     generate_n(O first,
                iter_difference_t&amp;lt;O&amp;gt; n,
                F gen);                  // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator O,
+            copy_constructible F&amp;gt;
+    requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
+  O generate_n(Ep&amp;amp;&amp;amp; exec,
+               O first,
+               iter_difference_t&amp;lt;O&amp;gt; n,
+               F gen);                  // (2) C++26
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 
 ## 概要
 出力の範囲へ関数の結果を `n` 個書き込む。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## 効果
 `n` が 1 以上の場合、`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
@@ -41,6 +55,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -59,6 +74,35 @@ int main() {
 1,2,4,8,16,32,64,128,256,512,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v(5);
+
+  // 並列に値を生成して書き込む
+  std::atomic&amp;lt;int&amp;gt; counter{0};
+  std::ranges::generate_n(std::execution::par, v.begin(), 5,
+                          [&amp;amp;counter] { return counter++; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::generate_n[color ff0000]
+
+#### 出力例
+```
+0 1 2 3 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -71,3 +115,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_in_out_result -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_in_out_result.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_in_in_out_result.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_in_out_result.md b/reference/algorithm/ranges_in_in_out_result.md
index 4939125fe..095b4a90f 100644
--- a/reference/algorithm/ranges_in_in_out_result.md
+++ b/reference/algorithm/ranges_in_in_out_result.md
@@ -3,7 +3,7 @@
 * std::ranges[meta namespace]
 * class template[meta id-type]
 * cpp20[meta cpp]
-* binary_transform_result,merge_result,set_union_result,set_intersection_result,set_symmetric_difference_result[meta alias]
+* binary_transform_result,merge_result,set_union_result,set_intersection_result,set_symmetric_difference_result,reverse_copy_truncated_result,rotate_copy_truncated_result[meta alias]
 
 ```cpp
 namespace std::ranges {
@@ -50,6 +50,14 @@ namespace std::ranges {
   // (6)
   template&amp;lt;class I1, class I2, class O&amp;gt;
   using set_symmetric_difference_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  // (7) C++26
+  template&amp;lt;class I, class O&amp;gt;
+  using reverse_copy_truncated_result = in_in_out_result&amp;lt;I, I, O&amp;gt;;
+
+  // (8) C++26
+  template&amp;lt;class I, class O&amp;gt;
+  using rotate_copy_truncated_result = in_in_out_result&amp;lt;I, I, O&amp;gt;;
 }
 ```
 * no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
@@ -62,6 +70,8 @@ namespace std::ranges {
 * (4): [`ranges::set_union`](ranges_set_union.md)で使用するエイリアス
 * (5): [`ranges::set_intersection`](ranges_set_intersection.md)で使用するエイリアス
 * (6): [`ranges::set_symmetric_difference`](ranges_set_symmetric_difference.md)で使用するエイリアス
+* (7): [`ranges::reverse_copy`](ranges_reverse_copy.md)の並列アルゴリズム版で使用するエイリアス (C++26)
+* (8): [`ranges::rotate_copy`](ranges_rotate_copy.md)の並列アルゴリズム版で使用するエイリアス (C++26)
 
 この型は、関数が2つの入力用の範囲と出力用の範囲を受け取る場合に、それぞれ処理した範囲の末尾を返すために使用される。
 
@@ -125,3 +135,5 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>includes -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_includes.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_includes.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_includes.md b/reference/algorithm/ranges_includes.md
index 41e5babb6..403ec100f 100644
--- a/reference/algorithm/ranges_includes.md
+++ b/reference/algorithm/ranges_includes.md
@@ -39,16 +39,60 @@ namespace std::ranges {
              Comp comp = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    includes(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    includes(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 `[first2,last2)` が `empty` であるか、`[first2,last2)` の全ての要素が `[first1,last1)` に含まれている場合は `true`、そうでない場合は `false` を返す。
@@ -59,6 +103,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -84,6 +129,34 @@ true
 false
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6};
+  std::vector&amp;lt;int&amp;gt; c = {2, 4, 7};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列にaがbの全要素を含むか判定する
+  std::cout &amp;lt;&amp;lt; std::ranges::includes(std::execution::par, a, b) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::includes(std::execution::par, a, c) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::includes[color ff0000]
+
+#### 出力
+```
+true
+false
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +169,4 @@ false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_inplace_merge.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_inplace_merge.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_inplace_merge.md b/reference/algorithm/ranges_inplace_merge.md
index 58cfe9bb4..5d12106d2 100644
--- a/reference/algorithm/ranges_inplace_merge.md
+++ b/reference/algorithm/ranges_inplace_merge.md
@@ -47,17 +47,49 @@ namespace std::ranges {
                   iterator_t&amp;lt;R&amp;gt; middle,
                   Comp comp = {},
                   Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I
+    inplace_merge(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  I middle,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    inplace_merge(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  iterator_t&amp;lt;R&amp;gt; middle,
+                  Comp comp = {},
+                  Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つの連続したソート済み範囲をマージする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` の範囲はそれぞれソートされていること。
@@ -83,6 +115,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -112,6 +145,34 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 2, 4, 6};
+
+  // 並列にインプレースマージ
+  // [1,3,5) と [2,4,6) をマージ
+  std::ranges::inplace_merge(std::execution::par,
+                             v, v.begin() + 3);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::inplace_merge[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6
+```
+
 ## 実装例
 - [`inplace_merge` を読んでみた](http://www.kmonos.net/wlog/115.html#_2300101215)
 
@@ -129,3 +190,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_heap.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap.md b/reference/algorithm/ranges_is_heap.md
index 35abb8e9f..394cfad5d 100644
--- a/reference/algorithm/ranges_is_heap.md
+++ b/reference/algorithm/ranges_is_heap.md
@@ -23,16 +23,44 @@ namespace std::ranges {
     is_heap(R&amp;amp;&amp;amp; r,
             Comp comp = {},
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    is_heap(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            Comp comp = {},
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool
+    is_heap(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            Comp comp = {},
+            Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲がヒープ化されているか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -40,6 +68,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -68,6 +97,36 @@ before: is heap? false
  after: is heap? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is heap? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_heap(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::make_heap(v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is heap? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_heap(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_heap[color ff0000]
+* std::ranges::make_heap[link ranges_make_heap.md]
+
+#### 出力
+```
+before: is heap? false
+ after: is heap? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -80,3 +139,4 @@ before: is heap? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap_until -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap_until.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_heap_until.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap_until.md b/reference/algorithm/ranges_is_heap_until.md
index d96bc5c22..ae1148984 100644
--- a/reference/algorithm/ranges_is_heap_until.md
+++ b/reference/algorithm/ranges_is_heap_until.md
@@ -23,16 +23,44 @@ namespace std::ranges {
     is_heap_until(R&amp;amp;&amp;amp; r,
                   Comp comp = {},
                   Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I is_heap_until(Ep&amp;amp;&amp;amp; exec,
+                  I first,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_heap_until(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  Comp comp = {},
+                  Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -44,6 +72,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -66,12 +95,39 @@ int main()
 * std::ranges::is_heap_until[color ff0000]
 * std::ranges::make_heap[link ranges_make_heap.md]
 
-### 出力
+#### 出力
 ```
 before: is heap? false
  after: is heap? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {9, 5, 7, 3, 1, 2, 4};
+
+  // 並列にヒープ条件を満たさなくなる位置を検索
+  auto it = std::ranges::is_heap_until(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;heap part: &amp;#34;;
+  for (auto i = v.begin(); i != it; ++i) {
+    std::cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_heap_until[color ff0000]
+
+#### 出力
+```
+heap part: 9 5 7 3 1 2 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -84,3 +140,4 @@ before: is heap? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_partitioned -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_partitioned.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_partitioned.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_partitioned.md b/reference/algorithm/ranges_is_partitioned.md
index ffff76a49..d620305c0 100644
--- a/reference/algorithm/ranges_is_partitioned.md
+++ b/reference/algorithm/ranges_is_partitioned.md
@@ -23,14 +23,40 @@ namespace std::ranges {
     is_partitioned(R&amp;amp;&amp;amp; r,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool is_partitioned(Ep&amp;amp;&amp;amp; exec,
+                      I first,
+                      S last,
+                      Pred pred,
+                      Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool is_partitioned(Ep&amp;amp;&amp;amp; exec,
+                      R&amp;amp;&amp;amp; r,
+                      Pred pred,
+                      Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -44,6 +70,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -84,6 +111,33 @@ int main()
 partitioned
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 1, 3, 5};
+
+  auto pred = [](int x) { return x % 2 == 0; };
+
+  // 並列に偶数グループと奇数グループに分かれているか判定する
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;is partitioned? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_partitioned(std::execution::par, v, pred)
+            &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_partitioned[color ff0000]
+
+#### 出力
+```
+is partitioned? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +150,4 @@ partitioned
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_sorted.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted.md b/reference/algorithm/ranges_is_sorted.md
index b5bf9efb0..cedf3488a 100644
--- a/reference/algorithm/ranges_is_sorted.md
+++ b/reference/algorithm/ranges_is_sorted.md
@@ -23,16 +23,42 @@ namespace std::ranges {
     is_sorted(R&amp;amp;&amp;amp; r,
               Comp comp = {},
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool is_sorted(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 Comp comp = {},
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  bool is_sorted(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 Comp comp = {},
+                 Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲がソート済みか判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ### 戻り値
@@ -40,6 +66,7 @@ namespace std::ranges {
 - (2) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(r, comp, proj) == last`
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -66,6 +93,36 @@ before: is sorted? false
  after: is sorted? true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is sorted? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_sorted(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::sort(v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is sorted? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_sorted(std::execution::par, v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_sorted[color ff0000]
+* std::ranges::sort[link ranges_sort.md]
+
+#### 出力
+```
+before: is sorted? false
+ after: is sorted? true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -78,3 +135,4 @@ before: is sorted? false
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted_until.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_is_sorted_until.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted_until.md b/reference/algorithm/ranges_is_sorted_until.md
index d01cf16df..b92c0af1c 100644
--- a/reference/algorithm/ranges_is_sorted_until.md
+++ b/reference/algorithm/ranges_is_sorted_until.md
@@ -23,17 +23,44 @@ namespace std::ranges {
     is_sorted_until(R&amp;amp;&amp;amp; r,
                     Comp comp = {},
                     Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I is_sorted_until(Ep&amp;amp;&amp;amp; exec,
+                    I first,
+                    S last,
+                    Comp comp = {},
+                    Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_sorted_until(Ep&amp;amp;&amp;amp; exec,
+                    R&amp;amp;&amp;amp; r,
+                    Comp comp = {},
+                    Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 ソート済みか判定し、ソートされていない位置のイテレータを取得する
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 [`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、`[first,last]` の中でソートされている範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
@@ -44,6 +71,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -72,6 +100,33 @@ before: is sorted? false
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 5, 4, 6};
+
+  // 並列にソート済み範囲の終端を取得する
+  auto it = std::ranges::is_sorted_until(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;sorted until: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;sorted range size: &amp;#34; &amp;lt;&amp;lt; (it - v.begin()) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_sorted_until[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力
+```
+sorted until: 4
+sorted range size: 4
+```
+
 ## 実装例
 ```cpp
 
@@ -115,3 +170,4 @@ inline constexpr is_sorted_until_impl is_sorted_until;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lexicographical_compare.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_lexicographical_compare.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lexicographical_compare.md b/reference/algorithm/ranges_lexicographical_compare.md
index 80fb24448..059fcca8d 100644
--- a/reference/algorithm/ranges_lexicographical_compare.md
+++ b/reference/algorithm/ranges_lexicographical_compare.md
@@ -40,16 +40,58 @@ namespace std::ranges {
                             Comp comp = {},
                             Proj1 proj1 = {},
                             Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool lexicographical_compare(Ep&amp;amp;&amp;amp; exec,
+                               I1 first1,
+                               S1 last1,
+                               I2 first2,
+                               S2 last2,
+                               Comp comp = {},
+                               Proj1 proj1 = {},
+                               Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  bool lexicographical_compare(Ep&amp;amp;&amp;amp; exec,
+                               R1&amp;amp;&amp;amp; r1,
+                               R2&amp;amp;&amp;amp; r2,
+                               Comp comp = {},
+                               Proj1 proj1 = {},
+                               Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 ```cpp
@@ -76,6 +118,7 @@ return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;string&amp;gt;
@@ -136,6 +179,36 @@ x less than y
 x less than y
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; b = {1, 2, 3, 4, 6};
+
+  // 並列に辞書式比較を行う
+  bool result = std::ranges::lexicographical_compare(
+    std::execution::par,
+    a,
+    b
+  );
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;a &amp;lt; b: &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::lexicographical_compare[color ff0000]
+
+#### 出力
+```
+a &amp;lt; b: true
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -148,3 +221,4 @@ x less than y
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_max.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max.md b/reference/algorithm/ranges_max.md
index 32ca3a62f..8fa065d48 100644
--- a/reference/algorithm/ranges_max.md
+++ b/reference/algorithm/ranges_max.md
@@ -31,12 +31,25 @@ namespace std::ranges {
     max(R&amp;amp;&amp;amp; r,
         Comp comp = {},
         Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  range_value_t&amp;lt;R&amp;gt;
+    max(Ep&amp;amp;&amp;amp; exec,
+        R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最大値を取得する。
@@ -44,6 +57,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -53,6 +67,7 @@ namespace std::ranges {
 - 等価な要素が 2 つ以上あった場合には、最も左の要素を返す。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -90,6 +105,28 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`max`
 - `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`max`マクロが定義されなくなる。
 - `std::ranges::max()`を呼び出す際に、`(std::ranges::max)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::max()`関数が必ず使用される。
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最大値を取得
+  int result = std::ranges::max(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::max[color ff0000]
+
+#### 出力
+```
+9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -102,3 +139,4 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`max`
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_max_element.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
index eebec0f04..88e4a3e42 100644
--- a/reference/algorithm/ranges_max_element.md
+++ b/reference/algorithm/ranges_max_element.md
@@ -23,17 +23,44 @@ namespace std::ranges {
     max_element(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I max_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    max_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -43,6 +70,7 @@ namespace std::ranges {
 [`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -70,6 +98,30 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最大要素を検索する
+  auto it = std::ranges::max_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;max: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::max_element[color ff0000]
+
+#### 出力
+```
+max: 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -82,3 +134,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_merge.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
index 739eace4e..83440d5a8 100644
--- a/reference/algorithm/ranges_merge.md
+++ b/reference/algorithm/ranges_merge.md
@@ -43,6 +43,50 @@ namespace std::ranges {
           Comp comp = {},
           Proj1 proj1 = {},
           Proj2 proj2 = {});  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  merge_result&amp;lt;I1, I2, O&amp;gt;
+    merge(Ep&amp;amp;&amp;amp; exec,
+          I1 first1,
+          S1 last1,
+          I2 first2,
+          S2 last2,
+          O result,
+          OutS result_last,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  merge_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;,
+    borrowed_iterator_t&amp;lt;OutR&amp;gt;
+  &amp;gt;
+    merge(Ep&amp;amp;&amp;amp; exec,
+          R1&amp;amp;&amp;amp; r1,
+          R2&amp;amp;&amp;amp; r2,
+          OutR&amp;amp;&amp;amp; result_r,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * merge_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲をマージして、出力イテレータへ出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -85,6 +135,7 @@ merge_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -122,6 +173,35 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 3, 5, 7};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6, 8};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列に2つのソート済み範囲をマージする
+  std::ranges::merge(std::execution::par, a, b, result);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::merge[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6 7 8
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -134,3 +214,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_min.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min.md b/reference/algorithm/ranges_min.md
index f3ec69f0d..49775810a 100644
--- a/reference/algorithm/ranges_min.md
+++ b/reference/algorithm/ranges_min.md
@@ -31,12 +31,25 @@ namespace std::ranges {
     min(R&amp;amp;&amp;amp; r,
         Comp comp = {},
         Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  range_value_t&amp;lt;R&amp;gt;
+    min(Ep&amp;amp;&amp;amp; exec,
+        R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値を取得する。
@@ -44,6 +57,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -54,6 +68,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -91,6 +106,28 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`min`
 - `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`min`マクロが定義されなくなる。
 - `std::ranges::min()`を呼び出す際に、`(std::ranges::min)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::min()`が必ず使用される。
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小値を取得
+  int result = std::ranges::min(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::min[color ff0000]
+
+#### 出力
+```
+1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -103,3 +140,4 @@ Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`min`
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_min_element.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
index e7c039f0f..67b5dc891 100644
--- a/reference/algorithm/ranges_min_element.md
+++ b/reference/algorithm/ranges_min_element.md
@@ -23,11 +23,36 @@ namespace std::ranges {
     min_element(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  I min_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    min_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +60,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -46,6 +73,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -73,6 +101,30 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小要素を検索する
+  auto it = std::ranges::min_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;min: &amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::min_element[color ff0000]
+
+#### 出力
+```
+min: 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -85,3 +137,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_minmax.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax.md b/reference/algorithm/ranges_minmax.md
index 2f678c217..22b63c906 100644
--- a/reference/algorithm/ranges_minmax.md
+++ b/reference/algorithm/ranges_minmax.md
@@ -31,6 +31,17 @@ namespace std::ranges {
     minmax(R&amp;amp;&amp;amp; r,
            Comp comp = {},
            Proj proj = {}); // (3) C++20
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           Comp comp = {},
+           Proj proj = {}); // (4) C++26
 }
 ```
 * minmax_result[link ranges_min_max_result.md]
@@ -38,6 +49,8 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値と最大値の組を取得する。
@@ -45,6 +58,7 @@ namespace std::ranges {
 - (1): 2つの値を指定する
 - (2): 初期化子リストを指定する
 - (3): Rangeを指定する
+- (4): (3)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -63,6 +77,7 @@ minmax_result {
 - 範囲バージョンは高々`(3/2) * t.size()`回の述語適用。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;cassert&amp;gt;
@@ -93,6 +108,28 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小値と最大値を取得
+  auto [min_val, max_val] = std::ranges::minmax(std::execution::par, v);
+  std::cout &amp;lt;&amp;lt; min_val &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; max_val &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::minmax[color ff0000]
+
+#### 出力
+```
+1, 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +142,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
index a243db083..332cc08d7 100644
--- a/reference/algorithm/ranges_minmax_element.md
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -23,12 +23,38 @@ namespace std::ranges {
     minmax_element(R&amp;amp;&amp;amp; r,
                    Comp comp = {},
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  minmax_element_result&amp;lt;I&amp;gt;
+    minmax_element(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   Comp comp = {},
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  minmax_element_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax_element(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   Comp comp = {},
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * minmax_element_result[link ranges_min_max_result.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * ranges::less[link /reference/functional/ranges_less.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -36,6 +62,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -53,6 +81,7 @@ minmax_element_result {
 `n` を範囲の要素数とする場合、[`max`](max.md)`(floor(3(n - 1) / 2), 0)` 回の述語適用を行う。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;cassert&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -77,6 +106,32 @@ int main()
 ```
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6};
+
+  // 並列に最小要素と最大要素を同時に検索する
+  auto [min_it, max_it] = std::ranges::minmax_element(std::execution::par, v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;min: &amp;#34; &amp;lt;&amp;lt; *min_it &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;max: &amp;#34; &amp;lt;&amp;lt; *max_it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::minmax_element[color ff0000]
+
+#### 出力
+```
+min: 1
+max: 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -89,3 +144,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_mismatch.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index e45983580..0d062d1d1 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -38,10 +38,51 @@ namespace std::ranges {
              Pred pred = {},
              Proj1 proj1 = {},
              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  mismatch_result&amp;lt;I1, I2&amp;gt;
+    mismatch(Ep&amp;amp;&amp;amp; exec,
+             I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  mismatch_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;
+  &amp;gt;
+    mismatch(Ep&amp;amp;&amp;amp; exec,
+             R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * mismatch_result[link ranges_in_in_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -49,6 +90,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 戻り値
@@ -66,6 +109,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -107,7 +151,7 @@ int main() {
 * std::ranges::mismatch[color ff0000]
 * std::to_string[link /reference/string/to_string.md]
 
-### 出力
+#### 出力
 ```
 mismatch index: 2
 mismatch value: (3,4)
@@ -117,6 +161,35 @@ mismatch value: (end,2)
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {1, 2, 4, 4, 5};
+
+  // 並列に2つのシーケンスが異なる場所を探す
+  auto [it1, it2] = std::ranges::mismatch(std::execution::par, v1, v2);
+  if (it1 == v1.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;all match&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;mismatch at index: &amp;#34; &amp;lt;&amp;lt; std::distance(v1.begin(), it1) &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;values: &amp;#34; &amp;lt;&amp;lt; *it1 &amp;lt;&amp;lt; &amp;#34; vs &amp;#34; &amp;lt;&amp;lt; *it2 &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::mismatch[color ff0000]
+
+#### 出力
+```
+mismatch at index: 2
+values: 3 vs 4
+```
+
 ## 実装例
 ```cpp
 struct mismatch_impl {
@@ -158,3 +231,4 @@ inline constexpr mismatch_impl mismatch;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_move.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move.md b/reference/algorithm/ranges_move.md
index 08ab3cf3c..f489ba666 100644
--- a/reference/algorithm/ranges_move.md
+++ b/reference/algorithm/ranges_move.md
@@ -13,26 +13,54 @@ namespace std::ranges {
   constexpr move_result&amp;lt;I, O&amp;gt;
     move(I first,
          S last,
-         O result); // (1) C++20
+         O result);           // (1) C++20
 
   template &amp;lt;input_range R,
             weakly_incrementable O&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     move(R&amp;amp;&amp;amp; r,
-         O result); // (2) C++20
+         O result);           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_movable&amp;lt;I, O&amp;gt;
+  move_result&amp;lt;I, O&amp;gt;
+    move(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         O result,
+         OutS result_last);   // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    move(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         OutR&amp;amp;&amp;amp; result_r);    // (4) C++26
 }
 ```
 * move_result[link ranges_in_out_result.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_movable[link /reference/iterator/indirectly_movable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素をムーブする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -59,6 +87,7 @@ move_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -93,6 +122,34 @@ int main() {
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, &amp;#34;baz&amp;#34;};
+  std::vector&amp;lt;std::string&amp;gt; dst(src.size());
+
+  // 並列にムーブする
+  std::ranges::move(std::execution::par, src, dst);
+
+  for (const auto&amp;amp; s : dst) {
+    std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::move[color ff0000]
+
+#### 出力
+```
+hello world foo bar baz
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +162,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_backward -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move_backward.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_move_backward.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move_backward.md b/reference/algorithm/ranges_move_backward.md
index 4e6ab8bb6..059f1c1bc 100644
--- a/reference/algorithm/ranges_move_backward.md
+++ b/reference/algorithm/ranges_move_backward.md
@@ -13,25 +13,51 @@ namespace std::ranges {
   constexpr move_backward_result&amp;lt;I1, I2&amp;gt;
     move_backward(I1 first,
                   S1 last,
-                  I2 result); // (1) C++20
+                  I2 result);           // (1) C++20
 
   template &amp;lt;bidirectional_range R,
             bidirectional_iterator I&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
   constexpr move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
     move_backward(R&amp;amp;&amp;amp; r,
-                  I result); // (2) C++20
+                  I result);            // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2&amp;gt;
+    requires indirectly_movable&amp;lt;I1, I2&amp;gt;
+  move_backward_result&amp;lt;I1, I2&amp;gt;
+    move_backward(Ep&amp;amp;&amp;amp; exec,
+                  I1 first,
+                  S1 last,
+                  I2 result);           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            random_access_iterator I&amp;gt;
+    requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+  move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+    move_backward(Ep&amp;amp;&amp;amp; exec,
+                  R&amp;amp;&amp;amp; r,
+                  I result);            // (4) C++26
 }
 ```
 * move_backward_result[link ranges_in_out_result.md]
 * indirectly_movable[link /reference/iterator/indirectly_movable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された範囲の要素を後ろからムーブする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 `result` は `(first,last]` の範囲に含まれてはならない。
@@ -61,6 +87,7 @@ move_backward_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -104,6 +131,33 @@ int main() {
 2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 0, 0};
+
+  // 並列に先頭3要素を後方へムーブ
+  std::ranges::move_backward(std::execution::par,
+                             v.begin(), v.begin() + 3, v.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::move_backward[color ff0000]
+
+#### 出力
+```
+1 2 1 2 3
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +170,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_none_of.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_none_of.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_none_of.md b/reference/algorithm/ranges_none_of.md
index 9d3bc4f7a..1a3c07c17 100644
--- a/reference/algorithm/ranges_none_of.md
+++ b/reference/algorithm/ranges_none_of.md
@@ -23,14 +23,40 @@ namespace std::ranges {
     none_of(R&amp;amp;&amp;amp; r,
             Pred pred,
             Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool none_of(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               Pred pred,
+               Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  bool none_of(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               Pred pred,
+               Proj proj = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の全ての要素が条件を満たさないかを判定する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## テンプレートパラメータ制約
 - (1):
@@ -62,6 +88,7 @@ all_of(first, last, not_fn(pred));
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,12 +110,37 @@ int main() {
 ```
 * std::ranges::none_of[color ff0000]
 
-### 出力
+#### 出力
 ```
 false
 true
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 3, 5, 7, 9};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に全ての要素が偶数でないかを判定
+  bool result = std::ranges::none_of(std::execution::par, v,
+                                     [](int x) { return x % 2 == 0; });
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::none_of[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct none_of_impl {
@@ -131,3 +183,4 @@ inline constexpr none_of_impl none_of;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_nth_element.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
index 46e6a0f6e..1ef170c40 100644
--- a/reference/algorithm/ranges_nth_element.md
+++ b/reference/algorithm/ranges_nth_element.md
@@ -27,11 +27,39 @@ namespace std::ranges {
                 iterator_t&amp;lt;R&amp;gt; nth,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I nth_element(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                I nth,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    nth_element(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; nth,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -39,6 +67,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
 
@@ -56,6 +86,7 @@ namespace std::ranges {
 平均で線形時間
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -88,6 +119,37 @@ int main()
 10
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {5, 10, 4, 7, 1, 9, 8, 6, 2};
+
+  // 並列に4番目に小さい値より小さい値を前に集める
+  std::ranges::nth_element(std::execution::par, v, v.begin() + 3);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;4th element: &amp;#34; &amp;lt;&amp;lt; v[3] &amp;lt;&amp;lt; std::endl;
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::nth_element[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力例
+```
+4th element: 5
+2 1 4 5 7 6 8 9 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -100,3 +162,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index e5e6cfcb8..fca20788b 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -27,11 +27,39 @@ namespace std::ranges {
                  iterator_t&amp;lt;R&amp;gt; middle,
                  Comp comp = {},
                  Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I partial_sort(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 I middle,
+                 S last,
+                 Comp comp = {},
+                 Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    partial_sort(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 iterator_t&amp;lt;R&amp;gt; middle,
+                 Comp comp = {},
+                 Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -39,6 +67,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は、「売り上げランキング トップ1位から10位まで」のように、全体ではなく最高順位から途中までの順位がわかればよい状況で、全体を並び替える[`sort()`](sort.md)関数の代わりに使用できる。
 
@@ -56,6 +86,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -81,6 +112,34 @@ int main()
 12435
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列に先頭3要素を並んだ状態にする
+  std::ranges::partial_sort(std::execution::par, v, v.begin() + 3);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partial_sort[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力例
+```
+1 1 2 4 5 9 3 6 5 3 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -93,3 +152,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_partial_sort_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort_copy.md b/reference/algorithm/ranges_partial_sort_copy.md
index bb5a1dd34..6ba612c0a 100644
--- a/reference/algorithm/ranges_partial_sort_copy.md
+++ b/reference/algorithm/ranges_partial_sort_copy.md
@@ -42,6 +42,48 @@ namespace std::ranges {
                       Comp comp = {},
                       Proj1 proj1 = {},
                       Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+             indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+  partial_sort_copy_result&amp;lt;I1, I2&amp;gt;
+    partial_sort_copy(Ep&amp;amp;&amp;amp; exec,
+                      I1 first,
+                      S1 last,
+                      I2 result_first,
+                      S2 result_last,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+             indirect_strict_weak_order&amp;lt;
+               Comp,
+               projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+             &amp;gt;
+  partial_sort_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    partial_sort_copy(Ep&amp;amp;&amp;amp; exec,
+                      R1&amp;amp;&amp;amp; r,
+                      R2&amp;amp;&amp;amp; result_r,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * partial_sort_copy_result[link ranges_in_out_result.md]
@@ -50,12 +92,18 @@ namespace std::ranges {
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を部分的にソートした結果を他の範囲にコピーする
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `N =` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` とする。
@@ -78,6 +126,7 @@ partial_sort_copy_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -104,6 +153,34 @@ int main()
 12
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 4, 1, 5, 9, 2, 6};
+  std::vector&amp;lt;int&amp;gt; dst(3);
+
+  // 並列に上位3個の要素をソートしてコピー
+  std::ranges::partial_sort_copy(std::execution::par,
+                                 src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partial_sort_copy[color ff0000]
+
+#### 出力
+```
+1 1 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +193,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_partition.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition.md b/reference/algorithm/ranges_partition.md
index 6d73b817e..a87c9e0d1 100644
--- a/reference/algorithm/ranges_partition.md
+++ b/reference/algorithm/ranges_partition.md
@@ -24,15 +24,45 @@ namespace std::ranges {
     partition(R&amp;amp;&amp;amp; r,
               Pred pred,
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    partition(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    partition(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -54,6 +84,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -93,6 +124,41 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+
+  // 並列に偶数グループと奇数グループに分ける
+  auto boundary = std::ranges::partition(std::execution::par, v, [](int x) { return x % 2 == 0; });
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;even: &amp;#34;;
+  for (auto it = v.begin(); it != boundary.begin(); ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;odd: &amp;#34;;
+  for (int x : boundary) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partition[color ff0000]
+
+#### 出力例
+```
+even: 8 2 6 4
+odd: 5 3 7 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +171,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
index 26ec256e3..0cf6d1f51 100644
--- a/reference/algorithm/ranges_partition_copy.md
+++ b/reference/algorithm/ranges_partition_copy.md
@@ -33,12 +33,53 @@ namespace std::ranges {
                    O2 out_false,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O1,
+            sized_sentinel_for&amp;lt;O1&amp;gt; OutS1,
+            random_access_iterator O2,
+            sized_sentinel_for&amp;lt;O2&amp;gt; OutS2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;I, O2&amp;gt;
+  partition_copy_result&amp;lt;I, O1, O2&amp;gt;
+    partition_copy(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   O1 out_true,
+                   OutS1 out_true_last,
+                   O2 out_false,
+                   OutS2 out_false_last,
+                   Pred pred,
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR1,
+            sized-random-access-range OutR2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR1&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR2&amp;gt;&amp;gt;
+  partition_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR1&amp;gt;, borrowed_iterator_t&amp;lt;OutR2&amp;gt;&amp;gt;
+    partition_copy(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   OutR1&amp;amp;&amp;amp; out_true,
+                   OutR2&amp;amp;&amp;amp; out_false,
+                   Pred pred,
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * partition_copy_result[link ranges_in_out_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -46,6 +87,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -64,6 +107,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -105,6 +149,45 @@ evens : 2,4,
 odds : 1,3,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+  std::vector&amp;lt;int&amp;gt; evens(8);
+  std::vector&amp;lt;int&amp;gt; odds(8);
+
+  // 並列に偶数と奇数に分類してコピー
+  auto [in_end, even_end, odd_end] =
+    std::ranges::partition_copy(std::execution::par, v,
+                                evens, odds,
+                                [](int x) { return x % 2 == 0; });
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;evens: &amp;#34;;
+  for (auto it = evens.begin(); it != even_end; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;odds: &amp;#34;;
+  for (auto it = odds.begin(); it != odd_end; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partition_copy[color ff0000]
+
+#### 出力
+```
+evens: 2 4 6 8
+odds: 1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -117,3 +200,4 @@ odds : 1,3,5,
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_remove.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove.md b/reference/algorithm/ranges_remove.md
index 046703e18..0ce717b59 100644
--- a/reference/algorithm/ranges_remove.md
+++ b/reference/algorithm/ranges_remove.md
@@ -53,15 +53,55 @@ namespace std::ranges {
     remove(R&amp;amp;&amp;amp; r,
            const T&amp;amp; value,
            Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
+    requires permutable&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    remove(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           S last,
+           const T&amp;amp; value,
+           Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T,
+            class Proj = identity&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           const T&amp;amp; value,
+           Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された要素を取り除く。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -172,6 +212,34 @@ int main() {
 5,6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 2, 5, 2, 7};
+
+  // 並列に値2を除去する
+  auto result = std::ranges::remove(std::execution::par, v, 2);
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -186,3 +254,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_remove_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy.md b/reference/algorithm/ranges_remove_copy.md
index 68e13f9ee..b241f71f8 100644
--- a/reference/algorithm/ranges_remove_copy.md
+++ b/reference/algorithm/ranges_remove_copy.md
@@ -71,18 +71,64 @@ namespace std::ranges {
                 O result,
                 const T&amp;amp; value,
                 Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  remove_copy_result&amp;lt;I, O&amp;gt;
+    remove_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                O result,
+                OutS result_last,
+                const T&amp;amp; value,
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  remove_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    remove_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                OutR&amp;amp;&amp;amp; result_r,
+                const T&amp;amp; value,
+                Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * remove_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された要素を除け、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なってはならない。
@@ -174,6 +220,33 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 2, 5, 2, 7};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に値2を除去してコピーする
+  auto result = std::ranges::remove_copy(std::execution::par, src, dst, 2);
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_copy[color ff0000]
+
+#### 出力
+```
+1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -188,3 +261,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_remove_copy_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy_if.md b/reference/algorithm/ranges_remove_copy_if.md
index 2f0c10842..369cf096e 100644
--- a/reference/algorithm/ranges_remove_copy_if.md
+++ b/reference/algorithm/ranges_remove_copy_if.md
@@ -29,18 +29,54 @@ namespace std::ranges {
                    O result,
                    Pred pred,
                    Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  remove_copy_if_result&amp;lt;I, O&amp;gt;
+    remove_copy_if(Ep&amp;amp;&amp;amp; exec,
+                   I first,
+                   S last,
+                   O result,
+                   OutS result_last,
+                   Pred pred,
+                   Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  remove_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    remove_copy_if(Ep&amp;amp;&amp;amp; exec,
+                   R&amp;amp;&amp;amp; r,
+                   OutR&amp;amp;&amp;amp; result_r,
+                   Pred pred,
+                   Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * remove_copy_if_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を除け、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なってはならない。
@@ -63,6 +99,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -84,6 +121,34 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に奇数を除去してコピーする
+  auto result = std::ranges::remove_copy_if(std::execution::par, src, dst,
+                                            [](int x) { return x % 2 != 0; });
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_copy_if[color ff0000]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -96,3 +161,4 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_remove_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_if.md b/reference/algorithm/ranges_remove_if.md
index 6ee0da6da..b6c23a265 100644
--- a/reference/algorithm/ranges_remove_if.md
+++ b/reference/algorithm/ranges_remove_if.md
@@ -24,9 +24,37 @@ namespace std::ranges {
     remove_if(R&amp;amp;&amp;amp; r,
               Pred pred,
               Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    remove_if(Ep&amp;amp;&amp;amp; exec,
+              I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove_if(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -34,6 +62,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -59,6 +89,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -98,6 +129,35 @@ size before: 5
 size after: 2
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  // 並列に奇数を除去する
+  auto result = std::ranges::remove_if(std::execution::par, v,
+                                       [](int x) { return x % 2 != 0; });
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::remove_if[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+2 4 6 8 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +170,4 @@ size after: 2
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_replace.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace.md b/reference/algorithm/ranges_replace.md
index 9e208283a..26bc41e47 100644
--- a/reference/algorithm/ranges_replace.md
+++ b/reference/algorithm/ranges_replace.md
@@ -71,16 +71,59 @@ namespace std::ranges {
             const T1&amp;amp; old_value,
             const T2&amp;amp; new_value,
             Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;I, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  I replace(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (4) C++26
 }
 ```
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値と一致する要素を指定された値に置き換える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -168,6 +211,32 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 2, 5, 2, 7};
+
+  // 並列に値2を全て10に置き換える
+  std::ranges::replace(std::execution::par, v, 2, 10);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace[color ff0000]
+
+#### 出力
+```
+1 10 3 10 5 10 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -182,3 +251,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_replace_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy.md b/reference/algorithm/ranges_replace_copy.md
index 6fe9ba293..03ffe9d92 100644
--- a/reference/algorithm/ranges_replace_copy.md
+++ b/reference/algorithm/ranges_replace_copy.md
@@ -24,7 +24,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (1) C++20
+                 Proj proj = {});                     // (1) C++20
   template &amp;lt;input_iterator I,
             sentinel_for&amp;lt;I&amp;gt; S,
             class O,
@@ -43,7 +43,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (1) C++26
+                 Proj proj = {});                     // (1) C++26
 
   template &amp;lt;input_range R,
             class T1,
@@ -62,7 +62,7 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (2) C++20
+                 Proj proj = {});                     // (2) C++20
   template &amp;lt;input_range R,
             class O,
             class Proj = identity,
@@ -80,18 +80,68 @@ namespace std::ranges {
                  O result,
                  const T1&amp;amp; old_value,
                  const T2&amp;amp; new_value,
-                 Proj proj = {}); // (2) C++26
+                 Proj proj = {});                     // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  replace_copy_result&amp;lt;I, O&amp;gt;
+    replace_copy(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 O result,
+                 OutS result_last,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {});                     // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  replace_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    replace_copy(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 OutR&amp;amp;&amp;amp; result_r,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {});                     // (4) C++26
 }
 ```
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * replace_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
@@ -185,6 +235,34 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 2, 1, 2};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に1を10に置き換えてコピー
+  std::ranges::replace_copy(std::execution::par,
+                            src, dst, 1, 10);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_copy[color ff0000]
+
+#### 出力
+```
+3 10 2 10 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -199,3 +277,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_replace_copy_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy_if.md b/reference/algorithm/ranges_replace_copy_if.md
index ef97b244c..6dd2ba5c4 100644
--- a/reference/algorithm/ranges_replace_copy_if.md
+++ b/reference/algorithm/ranges_replace_copy_if.md
@@ -19,7 +19,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (1) C++20
+                    Proj proj = {});                  // (1) C++20
   template &amp;lt;input_iterator I,
             sentinel_for&amp;lt;I&amp;gt; S,
             class O,
@@ -35,7 +35,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (1) C++26
+                    Proj proj = {});                  // (1) C++26
 
   template &amp;lt;input_range R,
             class T,
@@ -48,7 +48,7 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (2) C++20
+                    Proj proj = {});                  // (2) C++20
   template &amp;lt;input_range R,
             class O,
             class T = iter_value_t&amp;lt;O&amp;gt;,
@@ -62,18 +62,58 @@ namespace std::ranges {
                     O result,
                     Pred pred,
                     const T&amp;amp; new_value,
-                    Proj proj = {}); // (2) C++26
+                    Proj proj = {});                  // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  replace_copy_if_result&amp;lt;I, O&amp;gt;
+    replace_copy_if(Ep&amp;amp;&amp;amp; exec,
+                    I first,
+                    S last,
+                    O result,
+                    OutS result_last,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {});                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  replace_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    replace_copy_if(Ep&amp;amp;&amp;amp; exec,
+                    R&amp;amp;&amp;amp; r,
+                    OutR&amp;amp;&amp;amp; result_r,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {});                  // (4) C++26
 }
 ```
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * replace_copy_if_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
@@ -172,6 +212,35 @@ int main() {
 9,9
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {3, 1, 4, 1, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に奇数を0に置き換えてコピー
+  std::ranges::replace_copy_if(std::execution::par,
+                               src, dst,
+                               [](int x) { return x % 2 != 0; }, 0);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_copy_if[color ff0000]
+
+#### 出力
+```
+0 0 4 0 0
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -186,3 +255,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_if -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_if.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_replace_if.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_if.md b/reference/algorithm/ranges_replace_if.md
index 21580be08..6d8cd8f0d 100644
--- a/reference/algorithm/ranges_replace_if.md
+++ b/reference/algorithm/ranges_replace_if.md
@@ -17,7 +17,7 @@ namespace std::ranges {
                S last,
                Pred pred,
                const T&amp;amp; new_value,
-               Proj proj = {}); // (1) C++20
+               Proj proj = {});           // (1) C++20
 
   template &amp;lt;input_range R,
             class T,
@@ -28,17 +28,50 @@ namespace std::ranges {
     replace_if(R&amp;amp;&amp;amp; r,
                Pred pred,
                const T&amp;amp; new_value,
-               Proj proj = {}); // (2) C++20
+               Proj proj = {});           // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_writable&amp;lt;I, const T&amp;amp;&amp;gt;
+  I replace_if(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {});           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace_if(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {});           // (4) C++26
 }
 ```
 * indirectly_writable[link /reference/iterator/indirectly_writable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 条件を満たす要素を指定された値に置き換える。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -64,6 +97,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -88,6 +122,33 @@ int main() {
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  // 並列に奇数を全て0に置き換える
+  std::ranges::replace_if(std::execution::par, v,
+                          [](int x) { return x % 2 != 0; }, 0);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::replace_if[color ff0000]
+
+#### 出力
+```
+0 2 0 4 0 6 0 8 0 10
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -102,3 +163,4 @@ int main() {
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
     - C++26で波カッコ初期化 (リスト初期化) に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_reverse.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse.md b/reference/algorithm/ranges_reverse.md
index d144567a3..be480a16a 100644
--- a/reference/algorithm/ranges_reverse.md
+++ b/reference/algorithm/ranges_reverse.md
@@ -17,16 +17,37 @@ namespace std::ranges {
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     reverse(R&amp;amp;&amp;amp; r);  // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  I reverse(Ep&amp;amp;&amp;amp; exec,
+            I first,
+            S last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    reverse(Ep&amp;amp;&amp;amp; exec,
+            R&amp;amp;&amp;amp; r);  // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 要素の並びを逆にする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -42,6 +63,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -62,6 +84,33 @@ esrever
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に要素の並びを逆にする
+  std::ranges::reverse(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::reverse[color ff0000]
+
+#### 出力
+```
+5 4 3 2 1
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -74,3 +123,4 @@ esrever
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_reverse_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse_copy.md b/reference/algorithm/ranges_reverse_copy.md
index c0370b15d..879d2d72e 100644
--- a/reference/algorithm/ranges_reverse_copy.md
+++ b/reference/algorithm/ranges_reverse_copy.md
@@ -21,18 +21,47 @@ namespace std::ranges {
   constexpr reverse_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
     reverse_copy(R&amp;amp;&amp;amp; r,
                  O result); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  reverse_copy_truncated_result&amp;lt;I, O&amp;gt;
+    reverse_copy(Ep&amp;amp;&amp;amp; exec,
+                 I first,
+                 S last,
+                 O result,
+                 OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  reverse_copy_truncated_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    reverse_copy(Ep&amp;amp;&amp;amp; exec,
+                 R&amp;amp;&amp;amp; r,
+                 OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
 * reverse_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
+* reverse_copy_truncated_result[link ranges_in_in_out_result.md]
 
 ## 概要
 要素の並びを逆にし、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -44,7 +73,8 @@ namespace std::ranges {
 
 
 ## 戻り値
-`{ .in = last, .out = result + (last - first) }`
+- (1), (2): `{ .in = last, .out = result + (last - first) }`
+- (3), (4): 出力範囲が入力範囲より短い場合、出力範囲の末尾まで書き込み、`in1`と`in2`で入力範囲のどこまで処理されたかを示す。`in1`は常に`last`と等しく、`in2`は入力範囲内の停止点を指す。出力範囲が十分な場合は`in2 == first`となる
 
 
 ## 計算量
@@ -52,6 +82,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -66,11 +97,38 @@ int main() {
 ```
 * std::ranges::reverse_copy[color ff0000]
 
-### 出力
+#### 出力
 ```
 esrever
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に逆順コピーする
+  auto result = std::ranges::reverse_copy(std::execution::par, src, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::reverse_copy[color ff0000]
+
+#### 出力
+```
+5 4 3 2 1
+```
+
 
 ## バージョン
 ### 言語
@@ -84,3 +142,5 @@ esrever
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_rotate.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate.md b/reference/algorithm/ranges_rotate.md
index a72fe1ebb..23a4eb07d 100644
--- a/reference/algorithm/ranges_rotate.md
+++ b/reference/algorithm/ranges_rotate.md
@@ -18,15 +18,39 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     rotate(R&amp;amp;&amp;amp; r,
            iterator_t&amp;lt;R&amp;gt; middle); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    rotate(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           I middle,
+           S last);               // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    rotate(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           iterator_t&amp;lt;R&amp;gt; middle); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` は有効な範囲である必要がある。
@@ -131,6 +155,34 @@ swapping 0x1806043(1) &amp;lt;-&amp;gt; 0x1806045(5)
 234501
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に要素を回転させる (先頭から2つ目の要素が先頭に来る)
+  std::ranges::rotate(std::execution::par, v, v.begin() + 2);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::rotate[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+#### 出力
+```
+3 4 5 1 2
+```
+
 ## 実装例
 - [std::rotate を読んでみた](http://www.kmonos.net/wlog/115.html#_0007101223)
 
@@ -146,3 +198,4 @@ swapping 0x1806043(1) &amp;lt;-&amp;gt; 0x1806045(5)
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_rotate_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate_copy.md b/reference/algorithm/ranges_rotate_copy.md
index 6e2aa01a1..67725ea13 100644
--- a/reference/algorithm/ranges_rotate_copy.md
+++ b/reference/algorithm/ranges_rotate_copy.md
@@ -23,17 +23,48 @@ namespace std::ranges {
     rotate_copy(R&amp;amp;&amp;amp; r,
                 iterator_t&amp;lt;R&amp;gt; middle,
                 O result); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  rotate_copy_truncated_result&amp;lt;I, O&amp;gt;
+    rotate_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                I middle,
+                S last,
+                O result,
+                OutS result_last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  rotate_copy_truncated_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    rotate_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; middle,
+                OutR&amp;amp;&amp;amp; result_r); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
 * rotate_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
+* rotate_copy_truncated_result[link ranges_in_in_out_result.md]
 
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定し、出力範囲の終端も指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -45,7 +76,8 @@ namespace std::ranges {
 
 
 ## 戻り値
-回転前の先頭の要素を指すイテレータ`result + (last - first)`
+- (1), (2): `{ .in = last, .out = result + (last - first) }`
+- (3), (4): 出力範囲が入力範囲より短い場合、出力範囲の末尾まで書き込み、`in1`と`in2`で入力範囲のどこまで処理されたかを示す。`in1`は`[middle, last)`の範囲内の停止点、`in2`は`[first, middle)`の範囲内の停止点を指す。出力範囲が十分な場合は`in1 == last`かつ`in2 == middle`となる
 
 
 ## 計算量
@@ -53,6 +85,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -71,11 +104,39 @@ int main() {
 * std::ranges::rotate_copy[color ff0000]
 * str.begin()[link /reference/string/basic_string/begin.md]
 
-### 出力
+#### 出力
 ```
 tatero
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に回転コピーする（3番目の要素が先頭になるように）
+  auto result = std::ranges::rotate_copy(
+    std::execution::par, src, src.begin() + 2, dst);
+
+  for (int x : dst) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::rotate_copy[color ff0000]
+
+#### 出力
+```
+3 4 5 1 2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -88,3 +149,5 @@ tatero
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
+- [P3709R2 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_search.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index 4ff7e480e..ef8d61005 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -35,14 +35,54 @@ namespace std::ranges {
            Pred pred = {},
            Proj1 proj1 = {},
            Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  subrange&amp;lt;I1&amp;gt;
+    search(Ep&amp;amp;&amp;amp; exec,
+           I1 first1,
+           S1 last1,
+           I2 first2,
+           S2 last2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  borrowed_subrange_t&amp;lt;R1&amp;gt;
+    search(Ep&amp;amp;&amp;amp; exec,
+           R1&amp;amp;&amp;amp; r1,
+           R2&amp;amp;&amp;amp; r2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 あるシーケンスの中から、特定のサブシーケンスを探す
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 - (1) :
@@ -54,6 +94,7 @@ namespace std::ranges {
 最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,6 +124,33 @@ found: index==0
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 3, 4};
+  std::vector&amp;lt;int&amp;gt; pattern = {3, 4};
+
+  // 並列にサブシーケンスを検索する
+  auto sr = std::ranges::search(std::execution::par, v, pattern);
+  if (sr.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::search[color ff0000]
+
+#### 出力
+```
+found: index==2
+```
+
 ## 実装例
 ```cpp
 struct search_impl {
@@ -128,3 +196,4 @@ inline constexpr search_impl search;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_difference.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_set_difference.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_difference.md b/reference/algorithm/ranges_set_difference.md
index 3cf8ab2d2..30a8b7c9b 100644
--- a/reference/algorithm/ranges_set_difference.md
+++ b/reference/algorithm/ranges_set_difference.md
@@ -39,6 +39,46 @@ namespace std::ranges {
                    Comp comp = {},
                    Proj1 proj1 = {},
                    Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_difference_result&amp;lt;I1, O&amp;gt;
+    set_difference(Ep&amp;amp;&amp;amp; exec,
+                   I1 first1,
+                   S1 last1,
+                   I2 first2,
+                   S2 last2,
+                   O result,
+                   OutS result_last,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    set_difference(Ep&amp;amp;&amp;amp; exec,
+                   R1&amp;amp;&amp;amp; r1,
+                   R2&amp;amp;&amp;amp; r2,
+                   OutR&amp;amp;&amp;amp; result_r,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_difference_result[link ranges_in_out_result.md]
@@ -46,6 +86,10 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -53,6 +97,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
@@ -83,6 +129,7 @@ set_difference_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -115,6 +162,40 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; b = {2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; result(a.size());
+
+  // 並列にa - bの差集合を作る
+  auto ret = std::ranges::set_difference(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_difference[color ff0000]
+
+#### 出力
+```
+1 5 6
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -127,3 +208,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_intersection.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_set_intersection.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_intersection.md b/reference/algorithm/ranges_set_intersection.md
index 6ae748e66..f349845a7 100644
--- a/reference/algorithm/ranges_set_intersection.md
+++ b/reference/algorithm/ranges_set_intersection.md
@@ -43,6 +43,50 @@ namespace std::ranges {
                      Comp comp = {},
                      Proj1 proj1 = {},
                      Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_intersection_result&amp;lt;I1, I2, O&amp;gt;
+    set_intersection(Ep&amp;amp;&amp;amp; exec,
+                     I1 first1,
+                     S1 last1,
+                     I2 first2,
+                     S2 last2,
+                     O result,
+                     OutS result_last,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_intersection_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              borrowed_iterator_t&amp;lt;OutR&amp;gt;
+            &amp;gt;
+    set_intersection(Ep&amp;amp;&amp;amp; exec,
+                     R1&amp;amp;&amp;amp; r1,
+                     R2&amp;amp;&amp;amp; r2,
+                     OutR&amp;amp;&amp;amp; result_r,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_intersection_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の積集合を得る
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -89,6 +139,7 @@ set_intersection_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -119,6 +170,40 @@ int main()
 4
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; result(std::min(a.size(), b.size()));
+
+  // 並列にaとbの積集合を作る
+  auto ret = std::ranges::set_intersection(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_intersection[color ff0000]
+
+#### 出力
+```
+2 4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -131,3 +216,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_symmetric_difference.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_set_symmetric_difference.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_symmetric_difference.md b/reference/algorithm/ranges_set_symmetric_difference.md
index b2c8fa3ce..64836ea7e 100644
--- a/reference/algorithm/ranges_set_symmetric_difference.md
+++ b/reference/algorithm/ranges_set_symmetric_difference.md
@@ -43,6 +43,50 @@ namespace std::ranges {
                              Comp comp = {},
                              Proj1 proj1 = {},
                              Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_symmetric_difference_result&amp;lt;I1, I2, O&amp;gt;
+    set_symmetric_difference(Ep&amp;amp;&amp;amp; exec,
+                             I1 first1,
+                             S1 last1,
+                             I2 first2,
+                             S2 last2,
+                             O result,
+                             OutS result_last,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;, Comp, Proj1, Proj2&amp;gt;
+  set_symmetric_difference_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              borrowed_iterator_t&amp;lt;OutR&amp;gt;
+            &amp;gt;
+    set_symmetric_difference(Ep&amp;amp;&amp;amp; exec,
+                             R1&amp;amp;&amp;amp; r1,
+                             R2&amp;amp;&amp;amp; r2,
+                             OutR&amp;amp;&amp;amp; result_r,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_symmetric_difference_result[link ranges_in_in_out_result.md]
@@ -50,12 +94,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 事前条件
@@ -91,6 +141,7 @@ set_symmetric_difference_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -116,7 +167,7 @@ int main()
 * end()[link /reference/set/set/end.md]
 * std::inserter[link /reference/iterator/inserter.md]
 
-### 出力
+#### 出力
 ```
 1
 5
@@ -125,6 +176,39 @@ int main()
 8
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 6, 8};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列に対称差を求める
+  auto [in1, in2, out] = std::ranges::set_symmetric_difference(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_symmetric_difference[color ff0000]
+
+#### 出力
+```
+1 3 5 6 8
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -137,3 +221,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_union.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_set_union.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_union.md b/reference/algorithm/ranges_set_union.md
index e4f8a977f..e650cf490 100644
--- a/reference/algorithm/ranges_set_union.md
+++ b/reference/algorithm/ranges_set_union.md
@@ -45,6 +45,52 @@ namespace std::ranges {
               Comp comp = {},
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  set_union_result&amp;lt;I1, I2, O&amp;gt;
+    set_union(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              OutS result_last,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;
+               iterator_t&amp;lt;R1&amp;gt;,
+               iterator_t&amp;lt;R2&amp;gt;,
+               iterator_t&amp;lt;OutR&amp;gt;,
+               Comp,
+               Proj1,
+               Proj2&amp;gt;
+  set_union_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    set_union(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              OutR&amp;amp;&amp;amp; result_r,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (4) C++26
 }
 ```
 * set_union_result[link ranges_in_in_out_result.md]
@@ -52,12 +98,18 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * mergeable[link /reference/iterator/mergeable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 2つのソート済み範囲の和集合を得る
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
@@ -83,6 +135,7 @@ set_union_result {
 最大で `2 * ((last1 - first1) + (last2 - first2)) - 1` 回の比較を行う
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;set&amp;gt;
@@ -121,6 +174,40 @@ int main()
 6
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {1, 2, 3, 4};
+  std::vector&amp;lt;int&amp;gt; b = {2, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; result(a.size() + b.size());
+
+  // 並列にaとbの和集合を作る
+  auto ret = std::ranges::set_union(
+    std::execution::par,
+    a,
+    b,
+    result
+  );
+
+  for (auto it = result.begin(); it != ret.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::set_union[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5 6
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -133,3 +220,4 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_left -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_left.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_shift_left.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_left.md b/reference/algorithm/ranges_shift_left.md
index 73310893b..712f3cdbc 100644
--- a/reference/algorithm/ranges_shift_left.md
+++ b/reference/algorithm/ranges_shift_left.md
@@ -18,15 +18,39 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     shift_left(R&amp;amp;&amp;amp; r,
                range_difference_t&amp;lt;R&amp;gt; n); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    shift_left(Ep&amp;amp;&amp;amp; exec,
+               I first,
+               S last,
+               iter_difference_t&amp;lt;I&amp;gt; n);  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_left(Ep&amp;amp;&amp;amp; exec,
+               R&amp;amp;&amp;amp; r,
+               range_difference_t&amp;lt;R&amp;gt; n); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲の要素をn個だけ左にシフトさせる。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
@@ -62,6 +86,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -86,6 +111,32 @@ int main()
 3,4,5,4,5,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に2つ左シフト
+  auto result = std::ranges::shift_left(std::execution::par, v, 2);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::shift_left[color ff0000]
+
+#### 出力
+```
+3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -98,3 +149,4 @@ int main()
 
 ## 参照
 - [N4901 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_right -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_right.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_shift_right.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_right.md b/reference/algorithm/ranges_shift_right.md
index 1d90e77d2..ca8d29d5d 100644
--- a/reference/algorithm/ranges_shift_right.md
+++ b/reference/algorithm/ranges_shift_right.md
@@ -18,9 +18,31 @@ namespace std::ranges {
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     shift_right(R&amp;amp;&amp;amp; r,
                 range_difference_t&amp;lt;R&amp;gt; n); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    shift_right(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                iter_difference_t&amp;lt;I&amp;gt; n); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_right(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                range_difference_t&amp;lt;R&amp;gt; n); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -28,6 +50,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
@@ -63,6 +87,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -87,6 +112,32 @@ int main()
 1,2,1,2,3,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 並列に2つ右シフト
+  auto result = std::ranges::shift_right(std::execution::par, v, 2);
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::shift_right[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
 ## バージョン
 ### 言語
 - C++23
@@ -99,3 +150,4 @@ int main()
 
 ## 参照
 - [N4901 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_sort.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort.md b/reference/algorithm/ranges_sort.md
index 95bb2f901..3fd99752c 100644
--- a/reference/algorithm/ranges_sort.md
+++ b/reference/algorithm/ranges_sort.md
@@ -25,17 +25,45 @@ namespace std::ranges {
     sort(R&amp;amp;&amp;amp; r,
          Comp comp = {},
          Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I sort(Ep&amp;amp;&amp;amp; exec,
+         I first,
+         S last,
+         Comp comp = {},
+         Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    sort(Ep&amp;amp;&amp;amp; exec,
+         R&amp;amp;&amp;amp; r,
+         Comp comp = {},
+         Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を並べ替える
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
@@ -164,6 +192,33 @@ Carol
 Bob
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列ソート
+  std::ranges::sort(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::sort[color ff0000]
+
+#### 出力
+```
+1 1 2 3 3 4 5 5 5 6 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -176,3 +231,4 @@ Bob
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_partition -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_partition.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_stable_partition.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_partition.md b/reference/algorithm/ranges_stable_partition.md
index 872f5f7cc..e425a0e81 100644
--- a/reference/algorithm/ranges_stable_partition.md
+++ b/reference/algorithm/ranges_stable_partition.md
@@ -43,9 +43,37 @@ namespace std::ranges {
     stable_partition(R&amp;amp;&amp;amp; r,
                      Pred pred,
                      Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    stable_partition(Ep&amp;amp;&amp;amp; exec,
+                     I first,
+                     S last,
+                     Pred pred,
+                     Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    stable_partition(Ep&amp;amp;&amp;amp; exec,
+                     R&amp;amp;&amp;amp; r,
+                     Pred pred,
+                     Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -53,6 +81,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -74,6 +104,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -102,6 +133,33 @@ int main()
 5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
+
+  // 並列に相対順序を保ちながら偶数グループと奇数グループに分ける
+  std::ranges::stable_partition(std::execution::par, v, [](int x) { return x % 2 == 0; });
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::stable_partition[color ff0000]
+
+#### 出力
+```
+2 4 6 8 1 3 5 7
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -116,3 +174,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_sort -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_sort.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_stable_sort.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_sort.md b/reference/algorithm/ranges_stable_sort.md
index 8497fd89e..94f35b9ca 100644
--- a/reference/algorithm/ranges_stable_sort.md
+++ b/reference/algorithm/ranges_stable_sort.md
@@ -43,17 +43,45 @@ namespace std::ranges {
     stable_sort(R&amp;amp;&amp;amp; r,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I stable_sort(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    stable_sort(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * ranges::less[link /reference/functional/ranges_less.md]
 * sortable[link /reference/iterator/sortable.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 範囲を安定ソートで並べ替える
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
@@ -72,6 +100,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -97,6 +126,33 @@ int main()
 12345
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
+
+  // 並列に安定ソートする
+  std::ranges::stable_sort(std::execution::par, v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::stable_sort[color ff0000]
+
+#### 出力
+```
+1 1 2 3 3 4 5 5 5 6 9
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -111,3 +167,4 @@ int main()
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
 - [P2562R1 `constexpr` Stable Sorting](https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf)
     - C++26から`constexpr`に対応した
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>starts_with -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_starts_with.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_starts_with.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_starts_with.md b/reference/algorithm/ranges_starts_with.md
index a3e605434..d7ee0b1c0 100644
--- a/reference/algorithm/ranges_starts_with.md
+++ b/reference/algorithm/ranges_starts_with.md
@@ -35,8 +35,46 @@ namespace std::ranges {
                 Pred pred = {},
                 Proj1 proj1 = {},
                 Proj2 proj2 = {}); // (2) C++23
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  bool
+    starts_with(Ep&amp;amp;&amp;amp; exec,
+                I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  bool
+    starts_with(Ep&amp;amp;&amp;amp; exec,
+                R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (4) C++26
 }
 ```
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -44,6 +82,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 戻り値
 
@@ -54,6 +94,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -70,13 +111,38 @@ int main() {
 ```
 * std::ranges::starts_with[color ff0000]
 
-### 出力
+#### 出力
 ```
 1
 0
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;execution&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5, 6};
+  std::vector&amp;lt;int&amp;gt; prefix = {1, 2, 3};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 並列に先頭が一致するかを判定
+  bool result = std::ranges::starts_with(std::execution::par, v, prefix);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::starts_with[color ff0000]
+
+#### 出力
+```
+true
+```
+
 ## 実装例
 ```cpp
 struct starts_with_impl {
@@ -114,3 +180,4 @@ inline constexpr starts_with_impl starts_with;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap_ranges -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_swap_ranges.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_swap_ranges.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_swap_ranges.md b/reference/algorithm/ranges_swap_ranges.md
index eca99ff9a..d851f7e21 100644
--- a/reference/algorithm/ranges_swap_ranges.md
+++ b/reference/algorithm/ranges_swap_ranges.md
@@ -15,7 +15,7 @@ namespace std::ranges {
     swap_ranges(I1 first1,
                 S1 last1,
                 I2 first2,
-                S2 last2); // (1) C++20
+                S2 last2);                  // (1) C++20
 
   template &amp;lt;input_range R1,
             input_range R2&amp;gt;
@@ -24,17 +24,47 @@ namespace std::ranges {
               borrowed_iterator_t&amp;lt;R1&amp;gt;,
               borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
     swap_ranges(R1&amp;amp;&amp;amp; r1,
-                R2&amp;amp;&amp;amp; r2); // (2) C++20
+                R2&amp;amp;&amp;amp; r2);                   // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2&amp;gt;
+    requires indirectly_swappable&amp;lt;I1, I2&amp;gt;
+  swap_ranges_result&amp;lt;I1, I2&amp;gt;
+    swap_ranges(Ep&amp;amp;&amp;amp; exec,
+                I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2);                  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2&amp;gt;
+    requires indirectly_swappable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+  swap_ranges_result&amp;lt;
+            borrowed_iterator_t&amp;lt;R1&amp;gt;,
+            borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    swap_ranges(Ep&amp;amp;&amp;amp; exec,
+                R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2);                   // (4) C++26
 }
 ```
 * swap_ranges_result[link ranges_in_in_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 指定された2つの範囲同士を swap する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## 効果
@@ -63,6 +93,7 @@ swap_ranges_result {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -93,6 +124,41 @@ v1: 5,2,4,
 v2: 3,1,2,1,3,
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; v2 = {6, 7, 8, 9, 10};
+
+  // 並列に2つの範囲をswapする
+  std::ranges::swap_ranges(std::execution::par, v1, v2);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;v1: &amp;#34;;
+  for (int x : v1) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;v2: &amp;#34;;
+  for (int x : v2) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::swap_ranges[color ff0000]
+
+#### 出力
+```
+v1: 6 7 8 9 10
+v2: 1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -105,3 +171,4 @@ v2: 3,1,2,1,3,
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_transform.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_transform.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_transform.md b/reference/algorithm/ranges_transform.md
index 6650810ac..dabb5817b 100644
--- a/reference/algorithm/ranges_transform.md
+++ b/reference/algorithm/ranges_transform.md
@@ -80,6 +80,93 @@ namespace std::ranges {
               F binary_op,
               Proj1 proj1 = {},
               Proj2 proj2 = {}); // (4) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I, Proj&amp;gt;&amp;gt;
+             &amp;gt;
+  unary_transform_result&amp;lt;I, O&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              I first1,
+              S last1,
+              O result,
+              OutS result_last,
+              F op,
+              Proj proj = {}); // (5) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               iterator_t&amp;lt;OutR&amp;gt;,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+             &amp;gt;
+  unary_transform_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              R&amp;amp;&amp;amp; r,
+              OutR&amp;amp;&amp;amp; result_r,
+              F op,
+              Proj proj = {}); // (6) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I1,
+            sized_sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2,
+            sized_sentinel_for&amp;lt;I2&amp;gt; S2,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
+  binary_transform_result&amp;lt;I1, I2, O&amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              OutS result_last,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (7) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R1,
+            sized-random-access-range R2,
+            sized-random-access-range OutR,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               iterator_t&amp;lt;OutR&amp;gt;,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
+  binary_transform_result&amp;lt;
+            borrowed_iterator_t&amp;lt;R1&amp;gt;,
+            borrowed_iterator_t&amp;lt;R2&amp;gt;,
+            borrowed_iterator_t&amp;lt;OutR&amp;gt;
+          &amp;gt;
+    transform(Ep&amp;amp;&amp;amp; exec,
+              R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              OutR&amp;amp;&amp;amp; result_r,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (8) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -88,6 +175,10 @@ namespace std::ranges {
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 * unary_transform_result[link ranges_in_out_result.md]
 * binary_transform_result[link ranges_in_in_out_result.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -95,6 +186,8 @@ namespace std::ranges {
 
 - (1), (2): 1つの範囲の要素に関数を適用し、結果を出力イテレータに出力する
 - (3), (4): 2つの範囲の要素を1つずつ取り出して関数を適用し、結果を出力イテレータに出力する
+- (5), (6): (1), (2)の並列アルゴリズム版。実行ポリシーを指定する
+- (7), (8): (3), (4)の並列アルゴリズム版。実行ポリシーを指定する
 
 - (1), (3): イテレータ範囲を指定する
 - (2), (4): Rangeを直接指定する
@@ -127,7 +220,8 @@ namespace std::ranges {
 - (3), (4) : `result` は `first1` や `first2` と同じであっても構わない。
 
 
-## (1)の例
+## 例
+### (1)の例
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -158,7 +252,7 @@ int main() {
 ```
 
 
-## (2)の例
+### (2)の例
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -188,6 +282,33 @@ b
 cccc
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+  std::vector&amp;lt;int&amp;gt; result(v.size());
+
+  // 並列に全ての要素を2乗する
+  std::ranges::transform(std::execution::par, v, result, [](int x) { return x * x; });
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::transform[color ff0000]
+
+#### 出力
+```
+1 4 9 16 25
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -200,6 +321,7 @@ cccc
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
 
 ## 関連項目
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_unique.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique.md b/reference/algorithm/ranges_unique.md
index 31f6880e6..04d030671 100644
--- a/reference/algorithm/ranges_unique.md
+++ b/reference/algorithm/ranges_unique.md
@@ -24,10 +24,38 @@ namespace std::ranges {
     unique(R&amp;amp;&amp;amp; r,
            C comp = {},
            Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    unique(Ep&amp;amp;&amp;amp; exec,
+           I first,
+           S last,
+           C comp = {},
+           Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    unique(Ep&amp;amp;&amp;amp; exec,
+           R&amp;amp;&amp;amp; r,
+           C comp = {},
+           Proj proj = {}); // (4) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
 * indirect_equivalence_relation[link /reference/iterator/indirect_equivalence_relation.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 
 ## 概要
@@ -35,6 +63,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 この関数は、隣り合った重複要素を除いた要素を、範囲の先頭に集める。この関数によってコンテナから直接要素が削除され、コンテナの要素数が減るようなことはない。コンテナから実際に要素を削除する場合は、この関数の戻り値として、先頭に集められた重複なし範囲の末尾の次を指すイテレータが返るため、そのイテレータを介してコンテナの`erase()`メンバ関数などを呼び出し、削除を行うこと。
 
@@ -59,6 +89,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -118,6 +149,34 @@ unsorted unique : 2,5,3,1,2,4,2,1,4,3
 sorted unique : 1,2,3,4,5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 1, 2, 3, 3, 3, 4, 4, 5};
+
+  // 並列に隣り合った重複要素を除去する
+  auto result = std::ranges::unique(std::execution::par, v);
+  v.erase(result.begin(), result.end());
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::unique[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -130,3 +189,4 @@ sorted unique : 1,2,3,4,5
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/algorithm/ranges_unique_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique_copy.md b/reference/algorithm/ranges_unique_copy.md
index eb7d53793..30c2fbe5e 100644
--- a/reference/algorithm/ranges_unique_copy.md
+++ b/reference/algorithm/ranges_unique_copy.md
@@ -37,6 +37,36 @@ namespace std::ranges {
                 O result,
                 C comp = {},
                 Proj proj = {}); // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; OutS,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  unique_copy_result&amp;lt;I, O&amp;gt;
+    unique_copy(Ep&amp;amp;&amp;amp; exec,
+                I first,
+                S last,
+                O result,
+                OutS result_last,
+                C comp = {},
+                Proj proj = {}); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            sized-random-access-range OutR,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+  unique_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, borrowed_iterator_t&amp;lt;OutR&amp;gt;&amp;gt;
+    unique_copy(Ep&amp;amp;&amp;amp; exec,
+                R&amp;amp;&amp;amp; r,
+                OutR&amp;amp;&amp;amp; result_r,
+                C comp = {},
+                Proj proj = {}); // (4) C++26
 }
 ```
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -45,12 +75,18 @@ namespace std::ranges {
 * indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
 * unique_copy_result[link ranges_in_out_result.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なっていてはならない
@@ -73,6 +109,7 @@ namespace std::ranges {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -129,6 +166,33 @@ unsorted unique : 2,5,3,1,2,4,2,1,4,3
 sorted unique : 1,2,3,4,5
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 1, 2, 3, 3, 3, 4, 4, 5};
+  std::vector&amp;lt;int&amp;gt; dst(src.size());
+
+  // 並列に隣り合った重複要素を除去してコピーする
+  auto result = std::ranges::unique_copy(std::execution::par, src, dst);
+
+  for (auto it = dst.begin(); it != result.out; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::unique_copy[color ff0000]
+
+#### 出力
+```
+1 2 3 4 5
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -141,3 +205,4 @@ sorted unique : 1,2,3,4,5
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/execution.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/execution.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;execution&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;execution&lt;/span&gt;&lt;span class=&#34;cpp cpp17&#34; title=&#34;C++17で追加&#34;&gt;(C++17)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;execution&amp;gt;&lt;/code&gt;ヘッダでは、アルゴリズムの並列実行を許可するための実行ポリシー、汎用的な非同期実行フレームワークとしての実行制御ライブラリを定義する。&lt;/p&gt;
&lt;h2&gt;実行ポリシー(C++17)&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;execution&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行ポリシー用の名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/is_execution_policy.html&#34;&gt;is_execution_policy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が実行ポリシーかを判定する (class template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution-policy.html&#34;&gt;execution-policy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が実行ポリシーであることを表す (説明専用concept)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;実行制御ライブラリ(C++26)&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;execution&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行制御ライブラリの名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;execution/execution.html&#34;&gt;this_thread&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行制御ライブラリ／Senderコンシューマの名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;li&gt;C++26 実行制御ライブラリ&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html&#34; target=&#34;_blank&#34;&gt;P0024R2 The Parallelism TS Should be Standardized&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html&#34; target=&#34;_blank&#34;&gt;P2300R10 &lt;code&gt;std::execution&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html&#34; target=&#34;_blank&#34;&gt;P3179R9 C++ parallel range algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution-policy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution-policy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/execution/execution-policy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution-policy.md b/reference/execution/execution-policy.md
new file mode 100644
index 000000000..635cbc8f0
--- /dev/null
+++ b/reference/execution/execution-policy.md
@@ -0,0 +1,31 @@
+# execution-policy
+* execution[meta header]
+* concept[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class T&amp;gt;
+  concept execution-policy = is_execution_policy_v&amp;lt;remove_cvref_t&amp;lt;T&amp;gt;&amp;gt;;
+}
+```
+* is_execution_policy_v[link is_execution_policy.md]
+* remove_cvref_t[link /reference/type_traits/remove_cvref.md]
+
+## 概要
+`execution-policy`は、型`T`が実行ポリシー型であることを表す説明専用のコンセプトである。
+
+このコンセプトは、並列Rangeアルゴリズムのテンプレートパラメータ制約として使用される。
+
+このコンセプトに合致する型は、以下のページを参照：
+
+- [実行ポリシー](execution/execution_policy.md)
+
+
+## バージョン
+### 言語
+- C++26
+
+## 参照
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_destroy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy.md b/reference/memory/ranges_destroy.md
index 075fcc299..19d0f925d 100644
--- a/reference/memory/ranges_destroy.md
+++ b/reference/memory/ranges_destroy.md
@@ -13,6 +13,17 @@ namespace std::ranges {
   template &amp;lt;no-throw-input-range R&amp;gt;
     requires destructible&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; destroy(R&amp;amp;&amp;amp; r) noexcept; // (2) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I destroy(Ep&amp;amp;&amp;amp; exec, I first, S last) noexcept;           // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires destructible&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt; destroy(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r) noexcept; // (4) C++26
 }
 ```
 * no-throw-input-iterator[link no-throw-input-iterator.md]
@@ -20,6 +31,10 @@ namespace std::ranges {
 * destructible[link /reference/concepts/destructible.md]
 * no-throw-input-range[link no-throw-input-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 デストラクタを呼び出す。
@@ -28,6 +43,8 @@ namespace std::ranges {
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -52,6 +69,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -94,6 +112,35 @@ int main()
 0
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* p = alloc.allocate(3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::construct_at(p + i, &amp;#34;hello&amp;#34;);
+  }
+
+  // 並列に破棄
+  std::ranges::destroy(std::execution::par, p, p + 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::destroy[color ff0000]
+
+#### 出力
+```
+done
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -109,3 +156,4 @@ int main()
 
 ## 参照
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_destroy_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy_n.md b/reference/memory/ranges_destroy_n.md
index 258acf0e1..3d6da8eae 100644
--- a/reference/memory/ranges_destroy_n.md
+++ b/reference/memory/ranges_destroy_n.md
@@ -9,16 +9,26 @@ namespace std::ranges {
   template &amp;lt;no-throw-input-iterator I&amp;gt;
     requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
   constexpr I destroy_n(I first, iter_difference_t&amp;lt;I&amp;gt; n) noexcept; // (1) C++20
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires destructible&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I destroy_n(Ep&amp;amp;&amp;amp; exec, I first, iter_difference_t&amp;lt;I&amp;gt; n) noexcept; // (2) C++26
 }
 ```
 * no-throw-input-iterator[link no-throw-input-iterator.md]
 * destructible[link /reference/concepts/destructible.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 イテレータ範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトを破棄するために使用する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -38,6 +48,7 @@ return destroy(counted_iterator(first, n), default_sentinel).base();
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -80,6 +91,35 @@ int main()
 0
 ```
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* p = alloc.allocate(3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::construct_at(p + i, &amp;#34;hello&amp;#34;);
+  }
+
+  // 並列にn個破棄
+  std::ranges::destroy_n(std::execution::par, p, 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::destroy_n[color ff0000]
+
+#### 出力
+```
+done
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -95,3 +135,4 @@ int main()
 
 ## 参照
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_copy.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy.md b/reference/memory/ranges_uninitialized_copy.md
index 7e76fade9..35100d93d 100644
--- a/reference/memory/ranges_uninitialized_copy.md
+++ b/reference/memory/ranges_uninitialized_copy.md
@@ -42,6 +42,29 @@ namespace std::ranges {
   &amp;gt;
     uninitialized_copy(IR&amp;amp;&amp;amp; in_range,
                        OR&amp;amp;&amp;amp; out_range); // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, sized_sentinel_for&amp;lt;I&amp;gt; S1,
+            random_access_iterator O, sized_sentinel_for&amp;lt;O&amp;gt; S2&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_copy_result&amp;lt;I, O&amp;gt;
+    uninitialized_copy(Ep&amp;amp;&amp;amp; exec,
+                       I ifirst,
+                       S1 ilast,
+                       O ofirst,
+                       S2 olast);       // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range IR,
+            sized-random-access-range OR&amp;gt;
+  requires constructible_from&amp;lt;range_value_t&amp;lt;OR&amp;gt;, range_reference_t&amp;lt;IR&amp;gt;&amp;gt;
+  uninitialized_copy_result&amp;lt;
+    borrowed_iterator_t&amp;lt;IR&amp;gt;,
+    borrowed_iterator_t&amp;lt;OR&amp;gt;
+  &amp;gt;
+    uninitialized_copy(Ep&amp;amp;&amp;amp; exec,
+                       IR&amp;amp;&amp;amp; in_range,
+                       OR&amp;amp;&amp;amp; out_range); // (4) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -51,12 +74,18 @@ namespace std::ranges {
 * iter_reference_t[link /reference/iterator/iter_reference_t.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
-未初期化領域のイテレータ範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力イテレータ範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
+未初期化領域のイテレータ範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力イテレータ範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してコピー出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -105,6 +134,7 @@ return {std::move(ifirst), ofirst};
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -152,6 +182,39 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3};
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* dst = alloc.allocate(3);
+
+  // 並列に未初期化領域へコピー
+  std::ranges::uninitialized_copy(
+    std::execution::par, src, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_copy[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -169,3 +232,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_copy_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy_n.md b/reference/memory/ranges_uninitialized_copy_n.md
index fb409e56e..52380f451 100644
--- a/reference/memory/ranges_uninitialized_copy_n.md
+++ b/reference/memory/ranges_uninitialized_copy_n.md
@@ -31,6 +31,20 @@ namespace std::ranges {
       O ofirst,
       S olast
     );                               // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_copy_n_result&amp;lt;I, O&amp;gt;
+    uninitialized_copy_n(
+      Ep&amp;amp;&amp;amp; exec,
+      I ifirst,
+      iter_difference_t&amp;lt;I&amp;gt; n,
+      O ofirst,
+      S olast
+    );                               // (2) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -38,11 +52,15 @@ namespace std::ranges {
 * no-throw-sentinel[link no-throw-sentinel.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
 * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してコピー出力する。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +95,7 @@ return {std::move(t.in).base(), t.out};
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -123,6 +142,39 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; src = {1, 2, 3, 4, 5};
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* dst = alloc.allocate(3);
+
+  // 並列に3要素を未初期化領域へコピー
+  std::ranges::uninitialized_copy_n(
+    std::execution::par, src.begin(), 3, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_copy_n[color ff0000]
+
+#### 出力
+```
+1 2 3
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -140,3 +192,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_default_construct.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_default_construct.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_default_construct.md b/reference/memory/ranges_uninitialized_default_construct.md
index 32812ee0c..9e0669a5e 100644
--- a/reference/memory/ranges_uninitialized_default_construct.md
+++ b/reference/memory/ranges_uninitialized_default_construct.md
@@ -23,18 +23,38 @@ namespace std::ranges {
     requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_default_construct(R&amp;amp;&amp;amp; r);           // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_default_construct(Ep&amp;amp;&amp;amp; exec,
+                                    I first, S last); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_default_construct(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r); // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素をデフォルト構築する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +97,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -124,6 +145,32 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にデフォルト構築
+  std::ranges::uninitialized_default_construct(
+    std::execution::par, p, p + 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::uninitialized_default_construct[color ff0000]
+
+#### 出力
+```
+done
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -142,3 +189,4 @@ int main()
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
 - [P3369R0 `constexpr` for `uninitialized_default_construct`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)
     - 上記2文書で、C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_default_construct_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_default_construct_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_default_construct_n.md b/reference/memory/ranges_uninitialized_default_construct_n.md
index 6e9cd283b..f9ff6fdbc 100644
--- a/reference/memory/ranges_uninitialized_default_construct_n.md
+++ b/reference/memory/ranges_uninitialized_default_construct_n.md
@@ -16,13 +16,26 @@ namespace std::ranges {
   constexpr I
     uninitialized_default_construct_n(I first,
                                       iter_difference_t&amp;lt;I&amp;gt; n); // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_default_construct_n(Ep&amp;amp;&amp;amp; exec,
+                                      I first,
+                                      iter_difference_t&amp;lt;I&amp;gt; n); // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) の各要素をデフォルト構築する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -46,6 +59,7 @@ return uninitialized_default_construct(counted_iterator(first, n),
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -92,6 +106,32 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個デフォルト構築
+  std::ranges::uninitialized_default_construct_n(
+    std::execution::par, p, 3);
+
+  alloc.deallocate(p, 3);
+  std::cout &amp;lt;&amp;lt; &amp;#34;done&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::uninitialized_default_construct_n[color ff0000]
+
+#### 出力
+```
+done
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +150,4 @@ int main()
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
 - [P3369R0 `constexpr` for `uninitialized_default_construct`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)
     - 上記2文書で、C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_fill.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_fill.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_fill.md b/reference/memory/ranges_uninitialized_fill.md
index 735aa3dfa..4e2cd51e1 100644
--- a/reference/memory/ranges_uninitialized_fill.md
+++ b/reference/memory/ranges_uninitialized_fill.md
@@ -15,7 +15,8 @@ namespace std::ranges {
             no-throw-sentinel&amp;lt;I&amp;gt; S,
             class T&amp;gt;
     requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
-  I uninitialized_fill(I first, S last, const T&amp;amp; x); // (1) C++26
+  constexpr I
+    uninitialized_fill(I first, S last, const T&amp;amp; x); // (1) C++26
 
   template &amp;lt;no-throw-forward-range R,
             class T&amp;gt;
@@ -27,6 +28,22 @@ namespace std::ranges {
     requires constructible_from&amp;lt;range_value_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_fill(R&amp;amp;&amp;amp; r, const T&amp;amp; x);           // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S,
+            class T&amp;gt;
+    requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
+  I uninitialized_fill(Ep&amp;amp;&amp;amp; exec,
+                       I first, S last, const T&amp;amp; x); // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R,
+            class T&amp;gt;
+    requires constructible_from&amp;lt;range_value_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_fill(Ep&amp;amp;&amp;amp; exec,
+                       R&amp;amp;&amp;amp; r, const T&amp;amp; x);           // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
@@ -34,12 +51,18 @@ namespace std::ranges {
 * constructible_from[link /reference/concepts/constructible_from.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) を、指定された値で配置`new`で初期化する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -78,6 +101,7 @@ return first;
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -121,6 +145,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列に未初期化領域を42で埋める
+  std::ranges::uninitialized_fill(
+    std::execution::par, p, p + 3, 42);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_fill[color ff0000]
+
+#### 出力
+```
+42 42 42
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -138,3 +192,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_fill_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_fill_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_fill_n.md b/reference/memory/ranges_uninitialized_fill_n.md
index 5c0377772..c90ee2a52 100644
--- a/reference/memory/ranges_uninitialized_fill_n.md
+++ b/reference/memory/ranges_uninitialized_fill_n.md
@@ -18,14 +18,28 @@ namespace std::ranges {
     uninitialized_fill_n(I first,
                          iter_difference_t&amp;lt;I&amp;gt; n,
                          const T&amp;amp; x);            // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, class T&amp;gt;
+    requires constructible_from&amp;lt;iter_value_t&amp;lt;I&amp;gt;, const T&amp;amp;&amp;gt;
+  I
+    uninitialized_fill_n(Ep&amp;amp;&amp;amp; exec,
+                         I first,
+                         iter_difference_t&amp;lt;I&amp;gt; n,
+                         const T&amp;amp; x);            // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) を、指定された値で配置`new`で初期化する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -48,6 +62,7 @@ return uninitialized_fill(counted_iterator(first, n), default_sentinel, x).base(
 呼び出すコンストラクタなどから例外が送出された場合、その例外がこの関数の外側に伝播される前に、その時点で構築済のオブジェクトは全て未規定の順序で破棄される。すなわち、例外が送出された場合は初期化対象領域は未初期化のままとなる。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -90,6 +105,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個の未初期化領域を99で埋める
+  std::ranges::uninitialized_fill_n(
+    std::execution::par, p, 3, 99);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_fill_n[color ff0000]
+
+#### 出力
+```
+99 99 99
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -107,3 +152,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_move.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move.md b/reference/memory/ranges_uninitialized_move.md
index 2fca1ad0f..2faf9699d 100644
--- a/reference/memory/ranges_uninitialized_move.md
+++ b/reference/memory/ranges_uninitialized_move.md
@@ -34,6 +34,26 @@ namespace std::ranges {
     borrowed_iterator_t&amp;lt;OR&amp;gt;
   &amp;gt;
     uninitialized_move(IR&amp;amp;&amp;amp; in_range, OR&amp;amp;&amp;amp; out_range);          // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I, sized_sentinel_for&amp;lt;I&amp;gt; S1,
+            random_access_iterator O, sized_sentinel_for&amp;lt;O&amp;gt; S2&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_rvalue_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_move_result&amp;lt;I, O&amp;gt;
+    uninitialized_move(Ep&amp;amp;&amp;amp; exec,
+                       I ifirst, S1 ilast,
+                       O ofirst, S2 olast);                     // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range IR,
+            sized-random-access-range OR&amp;gt;
+  requires constructible_from&amp;lt;range_value_t&amp;lt;OR&amp;gt;, range_rvalue_reference_t&amp;lt;IR&amp;gt;&amp;gt;
+  uninitialized_move_result&amp;lt;
+    borrowed_iterator_t&amp;lt;IR&amp;gt;,
+    borrowed_iterator_t&amp;lt;OR&amp;gt;
+  &amp;gt;
+    uninitialized_move(Ep&amp;amp;&amp;amp; exec,
+                       IR&amp;amp;&amp;amp; in_range, OR&amp;amp;&amp;amp; out_range);          // (4) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
@@ -42,12 +62,18 @@ namespace std::ranges {
 * constructible_from[link /reference/concepts/constructible_from.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -97,6 +123,7 @@ return {std::move(ifirst), ofirst};
 またその場合、`[ifirst, ilast)`内の一部のオブジェクトは有効だが未規定な状態として残される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -144,6 +171,40 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;test&amp;#34;};
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* dst = alloc.allocate(3);
+
+  // 並列に未初期化領域へムーブ
+  std::ranges::uninitialized_move(
+    std::execution::par, src, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_move[color ff0000]
+
+#### 出力
+```
+hello world test
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -161,3 +222,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_move_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move_n.md b/reference/memory/ranges_uninitialized_move_n.md
index 044b99e9f..945884f49 100644
--- a/reference/memory/ranges_uninitialized_move_n.md
+++ b/reference/memory/ranges_uninitialized_move_n.md
@@ -31,17 +31,35 @@ namespace std::ranges {
       O ofirst,
       S olast
     );                               // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            random_access_iterator O,
+            sized_sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
+  requires constructible_from&amp;lt;iter_value_t&amp;lt;O&amp;gt;, iter_rvalue_reference_t&amp;lt;I&amp;gt;&amp;gt;
+  uninitialized_move_n_result&amp;lt;I, O&amp;gt;
+    uninitialized_move_n(
+      Ep&amp;amp;&amp;amp; exec,
+      I ifirst,
+      iter_difference_t&amp;lt;I&amp;gt; n,
+      O ofirst,
+      S olast
+    );                               // (2) C++26
 }
 ```
 * in_out_result[link /reference/algorithm/ranges_in_out_result.md]
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * constructible_from[link /reference/concepts/constructible_from.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
 
 ## 概要
 未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してムーブ出力する。
 
 - (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -77,6 +95,7 @@ return {std::move(t.in).base(), t.out};
 またその場合、`[ifirst, ifirst + n)`内の一部のオブジェクトは有効だが未規定な状態として残される。
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -123,6 +142,40 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::string&amp;gt; src = {&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;test&amp;#34;};
+  std::allocator&amp;lt;std::string&amp;gt; alloc;
+  std::string* dst = alloc.allocate(3);
+
+  // 並列に3要素を未初期化領域へムーブ
+  std::ranges::uninitialized_move_n(
+    std::execution::par, src.begin(), 3, dst, dst + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; dst[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::destroy(dst, dst + 3);
+  alloc.deallocate(dst, 3);
+}
+```
+* std::ranges::uninitialized_move_n[color ff0000]
+
+#### 出力
+```
+hello world test
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -140,3 +193,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_value_construct.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_value_construct.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_value_construct.md b/reference/memory/ranges_uninitialized_value_construct.md
index 2e1d24423..587a6be87 100644
--- a/reference/memory/ranges_uninitialized_value_construct.md
+++ b/reference/memory/ranges_uninitialized_value_construct.md
@@ -23,18 +23,38 @@ namespace std::ranges {
     requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     uninitialized_value_construct(R&amp;amp;&amp;amp; r);            // (2) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I,
+            sized_sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_value_construct(Ep&amp;amp;&amp;amp; exec,
+                                  I first, S last);  // (3) C++26
+
+  template &amp;lt;execution-policy Ep,
+            sized-random-access-range R&amp;gt;
+    requires default_initializable&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    uninitialized_value_construct(Ep&amp;amp;&amp;amp; exec, R&amp;amp;&amp;amp; r); // (4) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
 * no-throw-sentinel[link no-throw-sentinel.md]
 * no-throw-forward-range[link no-throw-forward-range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* sized-random-access-range[link /reference/ranges/sized-random-access-range.md]
 
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素を値構築する。
 
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
+- (3): (1)の並列アルゴリズム版。実行ポリシーを指定する
+- (4): (2)の並列アルゴリズム版。実行ポリシーを指定する
 
 
 ## テンプレートパラメータ制約
@@ -73,6 +93,7 @@ return first;
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -120,6 +141,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列に値初期化
+  std::ranges::uninitialized_value_construct(
+    std::execution::par, p, p + 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_value_construct[color ff0000]
+
+#### 出力
+```
+0 0 0
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -137,3 +188,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct_n -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_value_construct_n.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/memory/ranges_uninitialized_value_construct_n.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_value_construct_n.md b/reference/memory/ranges_uninitialized_value_construct_n.md
index be0805925..03103a277 100644
--- a/reference/memory/ranges_uninitialized_value_construct_n.md
+++ b/reference/memory/ranges_uninitialized_value_construct_n.md
@@ -16,13 +16,26 @@ namespace std::ranges {
   constexpr I
     uninitialized_value_construct_n(I first,
                                     iter_difference_t&amp;lt;I&amp;gt; n); // (1) C++26
+
+  template &amp;lt;execution-policy Ep,
+            random_access_iterator I&amp;gt;
+    requires default_initializable&amp;lt;iter_value_t&amp;lt;I&amp;gt;&amp;gt;
+  I
+    uninitialized_value_construct_n(Ep&amp;amp;&amp;amp; exec,
+                                    I first,
+                                    iter_difference_t&amp;lt;I&amp;gt; n); // (2) C++26
 }
 ```
 * no-throw-forward-iterator[link no-throw-forward-iterator.md]
+* execution-policy[link /reference/execution/execution-policy.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
 
 ## 概要
 未初期化領域の範囲 (`[first, first + n)`) の各要素を値構築する。
 
+- (1): イテレータ範囲を指定する
+- (2): (1)の並列アルゴリズム版。実行ポリシーを指定する
+
 
 ## テンプレートパラメータ制約
 - (1):
@@ -47,6 +60,7 @@ return uninitialized_value_construct(counted_iterator(first, n),
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;memory&amp;gt;
@@ -93,6 +107,36 @@ int main()
 ```
 
 
+### 並列アルゴリズムの例 (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;execution&amp;gt;
+
+int main() {
+  std::allocator&amp;lt;int&amp;gt; alloc;
+  int* p = alloc.allocate(3);
+
+  // 並列にn個値初期化
+  std::ranges::uninitialized_value_construct_n(
+    std::execution::par, p, 3);
+
+  for (int i = 0; i &amp;lt; 3; ++i) {
+    std::cout &amp;lt;&amp;lt; p[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  alloc.deallocate(p, 3);
+}
+```
+* std::ranges::uninitialized_value_construct_n[color ff0000]
+
+#### 出力
+```
+0 0 0
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -110,3 +154,4 @@ int main()
 - [P0896R4 The One Ranges Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P3508R0 Wording for &amp;#34;constexpr for specialized memory algorithms&amp;#34;](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
     - C++26から`constexpr`がついた
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/ranges.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/ranges.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges.md b/reference/ranges.md
index 6956f1b61..395b20031 100644
--- a/reference/ranges.md
+++ b/reference/ranges.md
@@ -91,6 +91,7 @@ C++20では関数によるカスタマイゼーションポイントの問題点
 | [`common_range`](ranges/common_range.md)               | イテレータと番兵の型が等しいRange (concept)                 | C++20          |
 | [`viewable_range`](ranges/viewable_range.md)           | ビューに変換できるRange (concept)                           | C++20          |
 | [`constant_range`](ranges/constant_range.md)           | 要素が定数なRange (concept)                           | C++23          |
+| [`sized-random-access-range`](ranges/sized-random-access-range.md) | サイズ付きランダムアクセスRange (説明専用concept) | C++26          |
 
 ## カスタマイゼーションポイント
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sized-random-access-range -- C++26対応として並列Rangeアルゴリズムを追加 #1502</title>
      <link href="https://cpprefjp.github.io/reference/ranges/sized-random-access-range.html"/>
      <id>b20232b36796b5173e693fd7778e7b563ec3d021:reference/ranges/sized-random-access-range.md</id>
      <updated>2026-02-05T13:53:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/sized-random-access-range.md b/reference/ranges/sized-random-access-range.md
new file mode 100644
index 000000000..c6b5e78a6
--- /dev/null
+++ b/reference/ranges/sized-random-access-range.md
@@ -0,0 +1,27 @@
+# sized-random-access-range
+* ranges[meta header]
+* concept[meta id-type]
+* std::ranges[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class R&amp;gt;
+  concept sized-random-access-range =
+    random_access_range&amp;lt;R&amp;gt; &amp;amp;&amp;amp; sized_range&amp;lt;R&amp;gt;;
+}
+```
+* random_access_range[link random_access_range.md]
+* sized_range[link sized_range.md]
+
+## 概要
+`sized-random-access-range`は、範囲`R`が[`random_access_range`](random_access_range.md)かつ[`sized_range`](sized_range.md)であることを表す説明専用のコンセプトである。
+
+このコンセプトは、並列Rangeアルゴリズムのテンプレートパラメータ制約として使用される。並列アルゴリズムでは、範囲のサイズが既知であり、かつランダムアクセスが可能である必要がある。
+
+## バージョン
+### 言語
+- C++26
+
+## 参照
+- [P3179R9 C++ parallel range algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>