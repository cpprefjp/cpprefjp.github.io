<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2019-05-22T04:40:07.834054</updated>
  <id>859ce1a0-fc55-44ee-a401-d268960c0e48</id>

  
    <entry>
      <title>operator= -- variantのoperator= : 日本語修正</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant/op_assign.html"/>
      <id>64d226c27caeb17cacd1691b7c32635099e1bb80:reference/variant/variant/op_assign.md</id>
      <updated>2019-05-22T13:36:14+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;function&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;variant&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace std&#34;&gt;std::&lt;/span&gt;&lt;span class=&#34;class&#34; title=&#34;class variant&#34;&gt;variant::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;operator=&lt;/span&gt;&lt;span class=&#34;cpp cpp17&#34; title=&#34;C++17で追加&#34;&gt;(C++17)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rhs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// (1)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rhs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;noexcept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;see&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;below&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// (2)&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rhs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;noexcept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;see&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;below&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// (3)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;variant&lt;/code&gt;オブジェクトもしくは候補型の値を代入する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) : コピー代入演算子&lt;/li&gt;
&lt;li&gt;(2) : ムーブ代入演算子&lt;/li&gt;
&lt;li&gt;(3) : クラスのテンプレート引数で指定した候補型のうち、いずれかの型の値を代入する&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テンプレートパラメータ制約&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(2) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_move_constructible.html&#34;&gt;is_move_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_move_assignable.html&#34;&gt;is_move_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;であること&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) :&lt;ul&gt;
&lt;li&gt;ここで説明用に、&lt;code&gt;*this&lt;/code&gt;が保持している型&lt;code&gt;Tj&lt;/code&gt;と、そのインデックス値&lt;code&gt;j&lt;/code&gt;を定義する。&lt;code&gt;Types...&lt;/code&gt;の各型&lt;code&gt;Ti&lt;/code&gt;に対して擬似的な関数&lt;code&gt;FUN(Ti)&lt;/code&gt;を定義したとして、&lt;code&gt;FUN(&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs))&lt;/code&gt;呼び出しによって選択されたオーバーロードされた関数のパラメータ型を、代入してその後含まれる値の型を&lt;code&gt;Tj&lt;/code&gt;とする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_same.html&#34;&gt;is_same_v&lt;/a&gt;&amp;lt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;T&amp;gt;, variant&amp;gt;&lt;/code&gt;が&lt;code&gt;false&lt;/code&gt;であること&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_assignable.html&#34;&gt;is_assignable_v&lt;/a&gt;&amp;lt;Tj&amp;amp;, T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_constructible.html&#34;&gt;is_constructible_v&lt;/a&gt;&amp;lt;Tj, T&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;であること&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;効果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;と&lt;code&gt;rhs&lt;/code&gt;がどちらも値を保持していない場合、なにもしない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;が値を保持し、&lt;code&gt;rhs&lt;/code&gt;が保持していない場合、&lt;code&gt;*this&lt;/code&gt;が値を保持していない状態にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt; == rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;である場合、&lt;code&gt;rhs&lt;/code&gt;が保持している値を&lt;code&gt;*this&lt;/code&gt;が保持する値としてコピー代入する (型の切り替えを行わない)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;Types...&lt;/code&gt;の&lt;code&gt;j&lt;/code&gt;番目の型を&lt;code&gt;Tj&lt;/code&gt;として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_copy_constructible.html&#34;&gt;is_nothrow_copy_constructible_v&lt;/a&gt;&amp;lt;Tj&amp;gt; == true&lt;/code&gt;もしくは&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_constructible.html&#34;&gt;is_nothrow_move_constructible_v&lt;/a&gt;&amp;lt;Tj&amp;gt; == false&lt;/code&gt;である場合、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/emplace.md.nolink&#34;&gt;emplace&lt;/a&gt;&amp;lt;j&amp;gt;(&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/get.html&#34;&gt;get&lt;/a&gt;&amp;lt;j&amp;gt;(rhs))&lt;/code&gt;と等価&lt;/li&gt;
&lt;li&gt;いずれにも当てはまらない場合、&lt;code&gt;operator=(variant(rhs))&lt;/code&gt;と等価&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;と&lt;code&gt;rhs&lt;/code&gt;がどちらも値を保持していない場合、なにもしない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;が値を保持し、&lt;code&gt;rhs&lt;/code&gt;が保持していない場合、&lt;code&gt;*this&lt;/code&gt;が値を保持していない状態にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt; == rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;である場合、&lt;code&gt;rhs&lt;/code&gt;が保持している値を&lt;code&gt;*this&lt;/code&gt;が保持する値としてムーブ代入する (型の切り替えを行わない)&lt;/li&gt;
&lt;li&gt;いずれにも当てはまらない場合、&lt;code&gt;rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;j&lt;/code&gt;として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/emplace.md.nolink&#34;&gt;emplace&lt;/a&gt;&amp;lt;j&amp;gt;(&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/get.html&#34;&gt;get&lt;/a&gt;&amp;lt;j&amp;gt;(&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/move.html&#34;&gt;std::move&lt;/a&gt;(rhs)))&lt;/code&gt;と等価&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;が&lt;code&gt;Tj&lt;/code&gt;型の値を保持している場合、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs)&lt;/code&gt;の値を&lt;code&gt;*this&lt;/code&gt;に代入する (型の切り替えを行わない)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_constructible.html&#34;&gt;is_nothrow_constructible_v&lt;/a&gt;&amp;lt;Tj, T&amp;gt; || !&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_constructible.html&#34;&gt;is_nothrow_move_constructible_v&lt;/a&gt;&amp;lt;Tj&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;である場合、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/emplace.md.nolink&#34;&gt;emplace&lt;/a&gt;&amp;lt;j&amp;gt;(&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs))&lt;/code&gt;の呼び出しと等価&lt;/li&gt;
&lt;li&gt;いずれにも当てはまらない場合、&lt;code&gt;operator=(variant(&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs)))&lt;/code&gt;呼び出しと等価&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;戻り値&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;*this&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;事後条件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1), (2) : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt; == rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;(3) : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/holds_alternative.html&#34;&gt;holds_alternative&lt;/a&gt;&amp;lt;Tj&amp;gt;(*this)&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;であること&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例外&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(2) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;noexcept&lt;/code&gt;演算子内部の式は、以下と等価となる：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_constructible.html&#34;&gt;is_nothrow_move_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_assignable.html&#34;&gt;is_nothrow_move_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;Types...&lt;/code&gt;の&lt;code&gt;j&lt;/code&gt;番目の型を&lt;code&gt;Tj&lt;/code&gt;として、型&lt;code&gt;Tj&lt;/code&gt;のムーブ構築中に例外が発生した場合、その&lt;code&gt;variant&lt;/code&gt;オブジェクトは値を保持しない状態になる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;Types...&lt;/code&gt;の&lt;code&gt;j&lt;/code&gt;番目の型を&lt;code&gt;Tj&lt;/code&gt;として、型&lt;code&gt;Tj&lt;/code&gt;のムーブ代入中に例外が発生した場合、型&lt;code&gt;Tj&lt;/code&gt;のムーブ代入演算子が保証する例外安全性が定義する値の保持状態となり、&lt;code&gt;*this&lt;/code&gt;の&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;は&lt;code&gt;j&lt;/code&gt;となる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;noexcept&lt;/code&gt;演算子内部の式は、以下と等価となる：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_assignable.html&#34;&gt;is_nothrow_assignable_v&lt;/a&gt;&amp;lt;Tj&amp;amp;, T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_constructible.html&#34;&gt;is_nothrow_constructible_v&lt;/a&gt;&amp;lt;Tj, T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;値を保持する&lt;code&gt;*this&lt;/code&gt;に対して&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs)&lt;/code&gt;の代入中に例外が発生した場合、&lt;code&gt;*this&lt;/code&gt;が保持する値と&lt;code&gt;rhs&lt;/code&gt;の値は、代入式の例外安全性が保証する状態となり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/valueless_by_exception.html&#34;&gt;valueless_by_exception()&lt;/a&gt;&lt;/code&gt;は&lt;code&gt;false&lt;/code&gt;となる&lt;/li&gt;
&lt;li&gt;保持する値の初期化中に例外が発生した場合、&lt;code&gt;variant&lt;/code&gt;オブジェクトは値を保持しない可能性がある&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;備考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_copy_constructible.html&#34;&gt;is_copy_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_copy_assignable.html&#34;&gt;is_copy_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;でない場合、この演算子は&lt;code&gt;delete&lt;/code&gt;定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_copy_constructible.html&#34;&gt;is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_copy_assignable.html&#34;&gt;is_trivially_copy_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_destructible.html&#34;&gt;is_trivially_destructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;である場合、この演算子は自明となる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_move_constructible.html&#34;&gt;is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_move_assignable.html&#34;&gt;is_trivially_move_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_destructible.html&#34;&gt;is_trivially_destructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;である場合、この演算子は自明となる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) :&lt;ul&gt;
&lt;li&gt;以下のコードは不適格となる。第1テンプレート引数の型をとるコンストラクタオーバーロードと、第2テンプレート引数の型をとるコンストラクタオーバーロードが定義されるため、曖昧になる：

&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;abc&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// コンパイルエラー！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;yata&#34; id=&#34;8ab66193079d2c3cf5b2f6c1c3a358d84bd53df5&#34;&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;cassert&amp;gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;variant&amp;gt;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: 4.0.1&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: 7.3&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: ??&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- variantの代入演算子 : (3)の仕様を追加 #584</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant/op_assign.html"/>
      <id>01ae73c66eaed0712e864881031f2165e78e72a1:reference/variant/variant/op_assign.md</id>
      <updated>2019-05-22T13:29:37+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;function&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;variant&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace std&#34;&gt;std::&lt;/span&gt;&lt;span class=&#34;class&#34; title=&#34;class variant&#34;&gt;variant::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;operator=&lt;/span&gt;&lt;span class=&#34;cpp cpp17&#34; title=&#34;C++17で追加&#34;&gt;(C++17)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rhs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// (1)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;constexpr&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rhs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;noexcept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;see&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;below&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// (2)&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rhs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;noexcept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;see&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;below&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// (3)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;variant&lt;/code&gt;オブジェクトもしくは候補型の値を代入する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) : コピー代入演算子&lt;/li&gt;
&lt;li&gt;(2) : ムーブ代入演算子&lt;/li&gt;
&lt;li&gt;(3) : クラスのテンプレート引数で指定した候補型のうち、いずれかの型の値を代入する&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テンプレートパラメータ制約&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(2) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_move_constructible.html&#34;&gt;is_move_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_move_assignable.html&#34;&gt;is_move_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;であること&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) :&lt;ul&gt;
&lt;li&gt;ここで説明用の型として、&lt;code&gt;*this&lt;/code&gt;が保持している型&lt;code&gt;Tj&lt;/code&gt;と、そのインデックス値&lt;code&gt;j&lt;/code&gt;を定義する。&lt;code&gt;Types...&lt;/code&gt;の各型&lt;code&gt;Ti&lt;/code&gt;に対して擬似的な関数&lt;code&gt;FUN(Ti)&lt;/code&gt;を定義したとして、&lt;code&gt;FUN(&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs))&lt;/code&gt;呼び出しによって選択されたオーバーロードされた関数のパラメータ型を、代入してその後含まれる値の型を&lt;code&gt;Tj&lt;/code&gt;とする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_same.html&#34;&gt;is_same_v&lt;/a&gt;&amp;lt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;T&amp;gt;, variant&amp;gt;&lt;/code&gt;が&lt;code&gt;false&lt;/code&gt;であること&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_assignable.html&#34;&gt;is_assignable_v&lt;/a&gt;&amp;lt;Tj&amp;amp;, T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_constructible.html&#34;&gt;is_constructible_v&lt;/a&gt;&amp;lt;Tj, T&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;であること&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;効果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;と&lt;code&gt;rhs&lt;/code&gt;がどちらも値を保持していない場合、なにもしない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;が値を保持し、&lt;code&gt;rhs&lt;/code&gt;が保持していない場合、&lt;code&gt;*this&lt;/code&gt;が値を保持していない状態にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt; == rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;である場合、&lt;code&gt;rhs&lt;/code&gt;が保持している値を&lt;code&gt;*this&lt;/code&gt;が保持する値としてコピー代入する (型の切り替えを行わない)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;Types...&lt;/code&gt;の&lt;code&gt;j&lt;/code&gt;番目の型を&lt;code&gt;Tj&lt;/code&gt;として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_copy_constructible.html&#34;&gt;is_nothrow_copy_constructible_v&lt;/a&gt;&amp;lt;Tj&amp;gt; == true&lt;/code&gt;もしくは&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_constructible.html&#34;&gt;is_nothrow_move_constructible_v&lt;/a&gt;&amp;lt;Tj&amp;gt; == false&lt;/code&gt;である場合、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/emplace.md.nolink&#34;&gt;emplace&lt;/a&gt;&amp;lt;j&amp;gt;(&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/get.html&#34;&gt;get&lt;/a&gt;&amp;lt;j&amp;gt;(rhs))&lt;/code&gt;と等価&lt;/li&gt;
&lt;li&gt;いずれにも当てはまらない場合、&lt;code&gt;operator=(variant(rhs))&lt;/code&gt;と等価&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;と&lt;code&gt;rhs&lt;/code&gt;がどちらも値を保持していない場合、なにもしない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;が値を保持し、&lt;code&gt;rhs&lt;/code&gt;が保持していない場合、&lt;code&gt;*this&lt;/code&gt;が値を保持していない状態にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt; == rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;である場合、&lt;code&gt;rhs&lt;/code&gt;が保持している値を&lt;code&gt;*this&lt;/code&gt;が保持する値としてムーブ代入する (型の切り替えを行わない)&lt;/li&gt;
&lt;li&gt;いずれにも当てはまらない場合、&lt;code&gt;rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;j&lt;/code&gt;として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/emplace.md.nolink&#34;&gt;emplace&lt;/a&gt;&amp;lt;j&amp;gt;(&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/get.html&#34;&gt;get&lt;/a&gt;&amp;lt;j&amp;gt;(&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/move.html&#34;&gt;std::move&lt;/a&gt;(rhs)))&lt;/code&gt;と等価&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;が&lt;code&gt;Tj&lt;/code&gt;型の値を保持している場合、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs)&lt;/code&gt;の値を&lt;code&gt;*this&lt;/code&gt;に代入する (型の切り替えを行わない)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_constructible.html&#34;&gt;is_nothrow_constructible_v&lt;/a&gt;&amp;lt;Tj, T&amp;gt; || !&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_constructible.html&#34;&gt;is_nothrow_move_constructible_v&lt;/a&gt;&amp;lt;Tj&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;である場合、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/emplace.md.nolink&#34;&gt;emplace&lt;/a&gt;&amp;lt;j&amp;gt;(&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs))&lt;/code&gt;の呼び出しと等価&lt;/li&gt;
&lt;li&gt;いずれにも当てはまらない場合、&lt;code&gt;operator=(variant(&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs)))&lt;/code&gt;呼び出しと等価&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;戻り値&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;*this&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;事後条件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1), (2) : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt; == rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;(3) : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/holds_alternative.html&#34;&gt;holds_alternative&lt;/a&gt;&amp;lt;Tj&amp;gt;(*this)&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;であること&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例外&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(2) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;noexcept&lt;/code&gt;演算子内部の式は、以下と等価となる：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_constructible.html&#34;&gt;is_nothrow_move_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_move_assignable.html&#34;&gt;is_nothrow_move_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;Types...&lt;/code&gt;の&lt;code&gt;j&lt;/code&gt;番目の型を&lt;code&gt;Tj&lt;/code&gt;として、型&lt;code&gt;Tj&lt;/code&gt;のムーブ構築中に例外が発生した場合、その&lt;code&gt;variant&lt;/code&gt;オブジェクトは値を保持しない状態になる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rhs.&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;Types...&lt;/code&gt;の&lt;code&gt;j&lt;/code&gt;番目の型を&lt;code&gt;Tj&lt;/code&gt;として、型&lt;code&gt;Tj&lt;/code&gt;のムーブ代入中に例外が発生した場合、型&lt;code&gt;Tj&lt;/code&gt;のムーブ代入演算子が保証する例外安全性が定義する値の保持状態となり、&lt;code&gt;*this&lt;/code&gt;の&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/index.html&#34;&gt;index()&lt;/a&gt;&lt;/code&gt;は&lt;code&gt;j&lt;/code&gt;となる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;noexcept&lt;/code&gt;演算子内部の式は、以下と等価となる：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_assignable.html&#34;&gt;is_nothrow_assignable_v&lt;/a&gt;&amp;lt;Tj&amp;amp;, T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_constructible.html&#34;&gt;is_nothrow_constructible_v&lt;/a&gt;&amp;lt;Tj, T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;値を保持する&lt;code&gt;*this&lt;/code&gt;に対して&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(rhs)&lt;/code&gt;の代入中に例外が発生した場合、&lt;code&gt;*this&lt;/code&gt;が保持する値と&lt;code&gt;rhs&lt;/code&gt;の値は、代入式の例外安全性が保証する状態となり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/valueless_by_exception.html&#34;&gt;valueless_by_exception()&lt;/a&gt;&lt;/code&gt;は&lt;code&gt;false&lt;/code&gt;となる&lt;/li&gt;
&lt;li&gt;保持する値の初期化中に例外が発生した場合、&lt;code&gt;variant&lt;/code&gt;オブジェクトは値を保持しない可能性がある&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;備考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(1) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_copy_constructible.html&#34;&gt;is_copy_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_copy_assignable.html&#34;&gt;is_copy_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;でない場合、この演算子は&lt;code&gt;delete&lt;/code&gt;定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_copy_constructible.html&#34;&gt;is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_copy_assignable.html&#34;&gt;is_trivially_copy_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_destructible.html&#34;&gt;is_trivially_destructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;である場合、この演算子は自明となる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2) :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Types...&lt;/code&gt;のすべての型&lt;code&gt;Ti&lt;/code&gt;について、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_move_constructible.html&#34;&gt;is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_move_assignable.html&#34;&gt;is_trivially_move_assignable_v&lt;/a&gt;&amp;lt;Ti&amp;gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_trivially_destructible.html&#34;&gt;is_trivially_destructible_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;である場合、この演算子は自明となる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(3) :&lt;ul&gt;
&lt;li&gt;以下のコードは不適格となる。第1テンプレート引数の型をとるコンストラクタオーバーロードと、第2テンプレート引数の型をとるコンストラクタオーバーロードが定義されるため、曖昧になる：

&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variant&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;abc&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// コンパイルエラー！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;yata&#34; id=&#34;8ab66193079d2c3cf5b2f6c1c3a358d84bd53df5&#34;&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;cassert&amp;gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;variant&amp;gt;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: 4.0.1&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: 7.3&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: ??&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- インポートに関連する訳を修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>94ca1ce4257f0ba7fe2114329469ea430e3b9bbe:lang/cpp20/modules.md</id>
      <updated>2019-05-22T03:38:23+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;モジュール&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20では、インクルードに代わる新たな仕組みとしてモジュールが導入された。&lt;/p&gt;
&lt;p&gt;C++20では、プリプロセッサを用いずにプログラムを分割することができる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// a.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// モジュールAのインターフェース&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エクスポートしていない関数foo&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// エクスポートしている関数bar&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// a-impl.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// モジュールAの実装&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK: fooはエクスポートしていないが、モジュールAの中では見える。&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// unrelated.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK: barはAからエクスポートされているので見える&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: fooはモジュールAの外では見えない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;モジュール宣言&lt;/h3&gt;
&lt;p&gt;モジュール宣言の構文は以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;export(opt) module モジュール名 属性(opt);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;モジュール宣言は翻訳単位あたり1回だけ、原則として翻訳単位の先頭に記述する。&lt;/li&gt;
&lt;li&gt;モジュール宣言を含む翻訳単位をモジュールユニットという。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt;がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。&lt;/li&gt;
&lt;li&gt;あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モジュール名は、識別子または識別子をドットで繋いだもの(例えば、&lt;code&gt;foo&lt;/code&gt;や&lt;code&gt;std.core&lt;/code&gt;)である。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fooのモジュールインターフェースユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fooのモジュール実装ユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// foo.barのモジュール実装ユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deprecated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;プライベートモジュールフラグメント&lt;/h4&gt;
&lt;h4&gt;グローバルモジュール&lt;/h4&gt;
&lt;p&gt;C++20では、名前のあるモジュールに属していない宣言はグローバルモジュールに属している。&lt;/p&gt;
&lt;p&gt;グローバルモジュールの性質は以下の通り。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名前を持たず、インポートすることはできない。&lt;/li&gt;
&lt;li&gt;宣言をエクスポートすることはできない。&lt;/li&gt;
&lt;li&gt;モジュールインターフェースユニットを持つことはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;エクスポート&lt;/h3&gt;
&lt;p&gt;モジュールインターフェースユニットの中では、宣言に&lt;code&gt;export&lt;/code&gt;キーワードを付加することでその対象をエクスポートできる。
モジュールをインポートすると、エクスポートした宣言が見える(名前解決の候補に挙がる)ようになる。&lt;/p&gt;
&lt;p&gt;モジュール実装ユニットでは、エクスポートできない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 変数のエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*...*/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// クラスのエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*...*/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 名前空間のエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 関数テンプレートのエクスポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;また、波カッコに&lt;code&gt;export&lt;/code&gt;をつけることで、その中の宣言をまとめてエクスポートできる。この波カッコはスコープを作らない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt;を付けた宣言が新たな名前を宣言していない場合は、エラーとなる。&lt;/li&gt;
&lt;li&gt;内部リンケージを持つ名前をエクスポートすると、エラーとなる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// エラー: 新たな名前を宣言していない&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// エラー: 内部リンケージを持つ名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// エラー: 内部リンケージを持つ名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// エラー: 明示的にstaticで宣言されている名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: 新たな名前を宣言していない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;モジュールリンケージ&lt;/h4&gt;
&lt;p&gt;C++20では、新たにモジュールリンケージが追加された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名前のあるモジュールに属していてエクスポートしていない名前は、モジュールリンケージを持つ。&lt;ul&gt;
&lt;li&gt;エクスポートしている名前は外部リンケージを持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モジュールリンケージを持つ名前は、同一モジュール内で参照できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;インポート&lt;/h3&gt;
&lt;p&gt;モジュールインポート宣言は次のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libのインポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;モジュールインポート宣言は、モジュールのインターフェースユニットをインポートする。&lt;/p&gt;
&lt;p&gt;インポートした翻訳単位がエクスポートしている宣言は見える(名前解決の候補に挙がる)ようになる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エクスポートしていない宣言は見えない。&lt;/li&gt;
&lt;li&gt;マクロは取り込まれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;インポート宣言もエクスポートできる。これを再エクスポートという。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libの再エクスポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;再エクスポートすると、インポートで見えるようになった宣言をそのままエクスポートしたことになる。&lt;/p&gt;
&lt;h3&gt;モジュールパーティション&lt;/h3&gt;
&lt;p&gt;モジュールは分割することができる。分割したモジュールをモジュールパーティションという。&lt;/p&gt;
&lt;p&gt;モジュールパーティションを宣言する構文は以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;export(opt) module モジュール名:モジュールパーティション名 属性(opt);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;モジュールパーティション名の書式は、モジュール名と同じである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt; がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libモジュールのモジュールインターフェースパーティションpart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libモジュールのモジュール実装パーティションinternal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主となるモジュールが異なる場合はインポートできない。&lt;ul&gt;
&lt;li&gt;外部へ公開するには、モジュールインターフェースから再エクスポートする。&lt;/li&gt;
&lt;li&gt;モジュールの利用者にパーティションの存在を意識させてはいけない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;インポート宣言にはモジュールパーティション名だけを書く。&lt;/li&gt;
&lt;li&gt;インポートするとエクスポートしていない宣言も見えるようになる。&lt;ul&gt;
&lt;li&gt;ただし、再エクスポートはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主となるモジュールのインターフェースとパーティションを区別する場合は、プライマリーモジュールインターフェースユニットという事がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 翻訳単位1&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位2&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位3&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位4&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このモジュールAは4つの翻訳単位からなる。上から順に、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(プライマリー)モジュールインターフェースユニット&lt;/li&gt;
&lt;li&gt;モジュールインターフェースパーティション &lt;code&gt;:Foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;モジュール実装パーティション &lt;code&gt;:Internals&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;モジュール実装ユニット&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;ODRの緩和&lt;/h3&gt;
&lt;p&gt;C++20では、複数の定義が同時に見えるようにならない限りODR違反とならない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// a.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// b.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このプログラムでは、関数&lt;code&gt;foo&lt;/code&gt;をモジュールA,Bで2回定義しているが、モジュールA,Bを同時にインポートしていないのでODR違反とならない。&lt;/p&gt;
&lt;h2&gt;後方互換性のための機能&lt;/h2&gt;
&lt;h3&gt;グローバルモジュールフラグメント&lt;/h3&gt;
&lt;p&gt;モジュール宣言の前にグローバルモジュールの実装を書くことができる。これをグローバルモジュールフラグメントという。&lt;/p&gt;
&lt;p&gt;グローバルモジュールフラグメントにはプリプロセッサディレクティブのみ記述できる。
翻訳フェーズ4以前の段階でプリプロセッサディレクティブ以外の記述がある場合は、エラーとなる。&lt;/p&gt;
&lt;p&gt;この機能は、モジュールのインターフェースへ影響を与えずにインクルードをするために用意された。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;c1&#34;&gt;// グローバルモジュールフラグメントの宣言&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;iostream&amp;gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &amp;lt;iostream&amp;gt;中の宣言はモジュールfooに含まれない。&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#include &#34;lib.h&#34;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &#34;lib.h&#34;中の宣言がモジュールfooに含まれてしまう(モジュールリンケージを持ってしまう)。&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;foo&#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;ヘッダーユニット&lt;/h3&gt;
&lt;p&gt;ヘッダーユニットは、ヘッダーファイルをモジュールとしてインポートする機能である。
ヘッダーファイル内の宣言が見えるようになり、通常のモジュールとは異なりマクロも引き継がれる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iostream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// iostreamをヘッダーユニットとしてインポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ヘッダーユニットは再エクスポートできるため、ライブラリをモジュールでラップするのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// lib.h&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#define NUM 1000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// lib_mod.cpp&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// lib.h中の宣言をすべてエクスポートするモジュールlib&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;lib.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// main.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: マクロは再エクスポートしても引き継がれない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ヘッダーユニットをインポートすると以下のことが起こる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ヘッダーファイルをプリプロセスし、その時定義されていたマクロをインポート宣言の直後で再定義する。&lt;/li&gt;
&lt;li&gt;ヘッダーファイルをフェーズ7までコンパイルし、その翻訳単位(ヘッダーユニット)をインポートする。&lt;ul&gt;
&lt;li&gt;内部リンケージを持たない名前は暗黙的にエクスポートされる。&lt;/li&gt;
&lt;li&gt;ヘッダーユニットはモジュール宣言を持てない。ヘッダーユニット内の宣言はグローバルモジュールに属する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// a.h&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define X 123 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #1&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 45  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #2&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Z a   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #3&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#undef  X      &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// a.hではここで#1が無効になる&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// b.h&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;a.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// b.hではここで#1, #2, #3が定義され、#1が無効になる&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define X 456 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// OK: #1で定義したXはすでに無効&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 6   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// エラー: #2で定義したYが有効&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// c.h&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 45  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #4&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Z c   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #5&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// d.h&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;a.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// d.hではここで#1, #2, #3が定義され、#1が無効になる&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;c.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// d.hではここで#4, #5が定義される&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// OK: #4は#2と同じ&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// エラー: #5は#3を異なる値で再定義している&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;C++20では、&lt;code&gt;#include&lt;/code&gt; プリプロセッサディレクティブがヘッダーユニットのインポートに置き換えられる場合がある。&lt;/p&gt;
&lt;h2&gt;ビルド&lt;/h2&gt;
&lt;p&gt;プログラムのビルドは規格の範囲外なので、ここでは一般論を述べる。&lt;/p&gt;
&lt;p&gt;モジュールをコンパイルすると、何らかの中間表現(コンパイル済みモジュール)が保存される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレートはテンプレートのまま（実体化することなく）エクスポートできるので、中間表現は機械語ではなく、いわゆるプリコンパイルドヘッダーと似たようなものにならざるを得ない。&lt;/li&gt;
&lt;li&gt;モジュールAをインポートするプログラムをコンパイルするには、モジュールAのコンパイル済みモジュールが存在しなければならない。&lt;/li&gt;
&lt;li&gt;モジュールAをインポートするプログラムをリンクするには、モジュールAに関するモジュールユニットから生成されるオブジェクトファイル、ライブラリなどを別途リンクしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;この機能が必要になった背景・経緯&lt;/h2&gt;
&lt;p&gt;プリプロセッサによるインクルードは、ヘッダーファイルの内容をその場に展開する。
これには次のような問題が指摘されてきた。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;コンパイル時間が長くなる&lt;ul&gt;
&lt;li&gt;ヘッダーファイルの内容が再帰的に展開され、プログラムが長くなる（Hello worldだけでも数万行に達する）&lt;/li&gt;
&lt;li&gt;さらに、展開が翻訳単位ごとに行われるので、全体で見ると同じヘッダーファイルが何度も解析される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プリプロセッサの状態により、インクルードの結果が変わってしまう&lt;ul&gt;
&lt;li&gt;インクルードの順番によってエラーが起きることがあった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ヘッダーファイル内の記述の影響を受けすぎる&lt;ul&gt;
&lt;li&gt;影響が大きいため、ヘッダーファイル内に書くことがためらわれる記述があった。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using namespace&lt;/code&gt;やマクロ(例えばWindowsにおける&lt;code&gt;max&lt;/code&gt;)など。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;モジュールは、以上のような問題のないプログラム分割の仕組みとして導入された。&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3 Merging Modules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>MATSUMURA Tetsuro</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- コピー&amp;ペーストのミスを修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>02efe58d131d1d715b44f2e3535007bdf4d3811a:lang/cpp20/modules.md</id>
      <updated>2019-05-22T02:30:16+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;モジュール&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20では、インクルードに代わる新たな仕組みとしてモジュールが導入された。&lt;/p&gt;
&lt;p&gt;C++20では、プリプロセッサを用いずにプログラムを分割することができる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// a.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// モジュールAのインターフェース&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エクスポートしていない関数foo&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// エクスポートしている関数bar&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// a-impl.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// モジュールAの実装&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK: fooはエクスポートしていないが、モジュールAの中では見える。&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// unrelated.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK: barはAからエクスポートされているので見える&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: fooはモジュールAの外では見えない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;モジュール宣言&lt;/h3&gt;
&lt;p&gt;モジュール宣言の構文は以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;export(opt) module モジュール名 属性(opt);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;モジュール宣言は翻訳単位あたり1回だけ記述でき、翻訳単位の先頭に記述する。&lt;/li&gt;
&lt;li&gt;モジュール宣言を含む翻訳単位をモジュールユニットという。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt;がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。&lt;/li&gt;
&lt;li&gt;あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モジュール名は、識別子または識別子をドットで繋いだもの(例えば、&lt;code&gt;foo&lt;/code&gt;や&lt;code&gt;std.core&lt;/code&gt;)である。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fooのモジュールインターフェースユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fooのモジュールユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// foo.barのモジュールユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deprecated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;グローバルモジュール&lt;/h4&gt;
&lt;p&gt;C++20では、名前のあるモジュールに属していない宣言はグローバルモジュールに属している。&lt;/p&gt;
&lt;p&gt;グローバルモジュールの性質は以下の通り。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名前を持たず、インポートすることはできない。&lt;/li&gt;
&lt;li&gt;宣言をエクスポートすることはできない。&lt;/li&gt;
&lt;li&gt;モジュールインターフェースユニットを持つことはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;エクスポート&lt;/h3&gt;
&lt;p&gt;モジュールインターフェースユニットの中では、宣言に&lt;code&gt;export&lt;/code&gt;キーワードを付加することでその対象をエクスポートできる。
モジュールをインポートすると、エクスポートした宣言が見える(名前解決の候補に挙がる)ようになる。&lt;/p&gt;
&lt;p&gt;モジュール実装ユニットでは、エクスポートできない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 変数のエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*...*/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// クラスのエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*...*/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 名前空間のエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 関数テンプレートのエクスポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;また、波カッコに&lt;code&gt;export&lt;/code&gt;をつけることで、その中の宣言をまとめてエクスポートできる。この波カッコはスコープを作らない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt;を付けた宣言が新たな名前を宣言していない場合は、エラーとなる。&lt;/li&gt;
&lt;li&gt;内部リンケージを持つ名前をエクスポートすると、エラーとなる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// エラー: 新たな名前を宣言していない&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// エラー: 内部リンケージを持つ名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// エラー: 内部リンケージを持つ名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// エラー: 明示的にstaticで宣言されている名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: 新たな名前を宣言していない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;モジュールリンケージ&lt;/h4&gt;
&lt;p&gt;C++20では、新たにモジュールリンケージが追加された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名前のあるモジュールに属していてエクスポートしていない名前は、モジュールリンケージを持つ。&lt;ul&gt;
&lt;li&gt;エクスポートしている名前は外部リンケージを持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モジュールリンケージを持つ名前は、同一モジュール内で参照できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;インポート&lt;/h3&gt;
&lt;p&gt;モジュールのインポート宣言は次のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libのインポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;モジュールをインポートすると、そのモジュールがエクスポートしている宣言が見える(名前解決の候補に挙がる)ようになる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エクスポートしていない宣言は見えない。&lt;/li&gt;
&lt;li&gt;マクロは取り込まれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;インポート宣言もエクスポートできる。これを再エクスポートという。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libの再エクスポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;再エクスポートすると、インポートで見えるようになった宣言をそのままエクスポートしたことになる。&lt;/p&gt;
&lt;h3&gt;モジュールパーティション&lt;/h3&gt;
&lt;p&gt;モジュールは分割することができる。分割したモジュールをモジュールパーティションという。&lt;/p&gt;
&lt;p&gt;モジュールパーティションを宣言する構文は以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;export(opt) module モジュール名:モジュールパーティション名 属性(opt);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;モジュールパーティション名の書式は、モジュール名と同じである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt; がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libモジュールのモジュールインターフェースパーティションpart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libモジュールのモジュール実装パーティションinternal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主となるモジュールが異なる場合はインポートできない。&lt;ul&gt;
&lt;li&gt;外部へ公開するには、モジュールインターフェースから再エクスポートする。&lt;/li&gt;
&lt;li&gt;モジュールの利用者にパーティションの存在を意識させてはいけない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;インポート宣言にはモジュールパーティション名だけを書く。&lt;/li&gt;
&lt;li&gt;インポートするとエクスポートしていない宣言も見えるようになる。&lt;ul&gt;
&lt;li&gt;ただし、再エクスポートはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主となるモジュールのインターフェースとパーティションを区別する場合は、プライマリーモジュールインターフェースユニットという事がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 翻訳単位1&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位2&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位3&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位4&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このモジュールAは4つの翻訳単位からなる。上から順に、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(プライマリー)モジュールインターフェースユニット&lt;/li&gt;
&lt;li&gt;モジュールインターフェースパーティション &lt;code&gt;:Foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;モジュール実装パーティション &lt;code&gt;:Internals&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;モジュール実装ユニット&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;ODRの緩和&lt;/h3&gt;
&lt;p&gt;C++20では、複数の定義が同時に見えるようにならない限りODR違反とならない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// a.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// b.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このプログラムでは、関数&lt;code&gt;foo&lt;/code&gt;をモジュールA,Bで2回定義しているが、モジュールA,Bを同時にインポートしていないのでODR違反とならない。&lt;/p&gt;
&lt;h2&gt;後方互換性のための機能&lt;/h2&gt;
&lt;h3&gt;グローバルモジュールフラグメント&lt;/h3&gt;
&lt;p&gt;モジュール宣言の前にグローバルモジュールの実装を書くことができる。これをグローバルモジュールフラグメントという。&lt;/p&gt;
&lt;p&gt;グローバルモジュールフラグメントにはプリプロセッサディレクティブのみ記述できる。
翻訳フェーズ4以前の段階でプリプロセッサディレクティブ以外の記述がある場合は、エラーとなる。&lt;/p&gt;
&lt;p&gt;この機能は、モジュールのインターフェースへ影響を与えずにインクルードをするために用意された。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;c1&#34;&gt;// グローバルモジュールフラグメントの宣言&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;iostream&amp;gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &amp;lt;iostream&amp;gt;中の宣言はモジュールfooに含まれない。&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#include &#34;lib.h&#34;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &#34;lib.h&#34;中の宣言がモジュールfooに含まれてしまう(モジュールリンケージを持ってしまう)。&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;foo&#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;ヘッダーユニット&lt;/h3&gt;
&lt;p&gt;ヘッダーユニットは、ヘッダーファイルをモジュールとしてインポートする機能である。
ヘッダーファイル内の宣言が見えるようになり、通常のモジュールとは異なりマクロも引き継がれる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iostream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// iostreamをヘッダーユニットとしてインポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ヘッダーユニットは再エクスポートできるため、ライブラリをモジュールでラップするのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// lib.h&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#define NUM 1000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// lib_mod.cpp&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// lib.h中の宣言をすべてエクスポートするモジュールlib&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;lib.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// main.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: マクロは再エクスポートしても引き継がれない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ヘッダーユニットをインポートすると以下のことが起こる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ヘッダーファイルをプリプロセスし、その時定義されていたマクロをインポート宣言の直後で再定義する。&lt;/li&gt;
&lt;li&gt;ヘッダーファイルをフェーズ7までコンパイルし、その翻訳単位(ヘッダーユニット)をインポートする。&lt;ul&gt;
&lt;li&gt;内部リンケージを持たない名前は暗黙的にエクスポートされる。&lt;/li&gt;
&lt;li&gt;ヘッダーユニットはモジュール宣言を持てない。ヘッダーユニット内の宣言はグローバルモジュールに属する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// a.h&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define X 123 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #1&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 45  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #2&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Z a   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #3&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#undef  X      &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// a.hではここで#1が無効になる&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// b.h&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;a.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// b.hではここで#1, #2, #3が定義され、#1が無効になる&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define X 456 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// OK: #1で定義したXはすでに無効&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 6   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// エラー: #2で定義したYが有効&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// c.h&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 45  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #4&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Z c   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #5&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// d.h&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;a.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// d.hではここで#1, #2, #3が定義され、#1が無効になる&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;c.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// d.hではここで#4, #5が定義される&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// OK: #4は#2と同じ&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// エラー: #5は#3を異なる値で再定義している&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;C++20では、&lt;code&gt;#include&lt;/code&gt; プリプロセッサディレクティブがヘッダーユニットのインポートに置き換えられる場合がある。&lt;/p&gt;
&lt;h2&gt;ビルド&lt;/h2&gt;
&lt;p&gt;プログラムのビルドは規格の範囲外なので、ここでは一般論を述べる。&lt;/p&gt;
&lt;p&gt;モジュールをコンパイルすると、何らかの中間表現(コンパイル済みモジュール)が保存される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレートはテンプレートのまま（実体化することなく）エクスポートできるので、中間表現は機械語ではなく、いわゆるプリコンパイルドヘッダーと似たようなものにならざるを得ない。&lt;/li&gt;
&lt;li&gt;モジュールAをインポートするプログラムをコンパイルするには、モジュールAのコンパイル済みモジュールが存在しなければならない。&lt;/li&gt;
&lt;li&gt;モジュールAをインポートするプログラムをリンクするには、モジュールAに関するモジュールユニットから生成されるオブジェクトファイル、ライブラリなどを別途リンクしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;この機能が必要になった背景・経緯&lt;/h2&gt;
&lt;p&gt;プリプロセッサによるインクルードは、ヘッダーファイルの内容をその場に展開する。
これには次のような問題が指摘されてきた。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;コンパイル時間が長くなる&lt;ul&gt;
&lt;li&gt;ヘッダーファイルの内容が再帰的に展開され、プログラムが長くなる（Hello worldだけでも数万行に達する）&lt;/li&gt;
&lt;li&gt;さらに、展開が翻訳単位ごとに行われるので、全体で見ると同じヘッダーファイルが何度も解析される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プリプロセッサの状態により、インクルードの結果が変わってしまう&lt;ul&gt;
&lt;li&gt;インクルードの順番によってエラーが起きることがあった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ヘッダーファイル内の記述の影響を受けすぎる&lt;ul&gt;
&lt;li&gt;影響が大きいため、ヘッダーファイル内に書くことがためらわれる記述があった。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using namespace&lt;/code&gt;やマクロ(例えばWindowsにおける&lt;code&gt;max&lt;/code&gt;)など。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;モジュールは、以上のような問題のないプログラム分割の仕組みとして導入された。&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3 Merging Modules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>MATSUMURA Tetsuro</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>modules.md -- PR1103R3からモジュールのサンプルコードを追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>09b3d932d3d688577ab56ffc3ada3f997ff87114:lang/cpp20/modules.md</id>
      <updated>2019-05-22T02:28:41+09:00</updated>
      
        <content type="html">&lt;p&gt;// a.h&lt;/p&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;define X 123 // #1&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;define Y 45  // #2&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;define Z a   // #3&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;undef X      // a.hではここで#2が無効になる&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;define X 456 // OK: #1で定義したXはすでに無効&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;define Y 6   // エラー: #2で定義したYが有効&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;define Y 45  // #4&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;define Z c   // #5&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;モジュール&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;// b.h
import &#34;a.h&#34;; // b.hではここで#1, #2, #3が定義され、#1が無効になる&lt;/p&gt;
&lt;p&gt;// c.h&lt;/p&gt;
&lt;p&gt;// d.h
import &#34;a.h&#34;; // d.hではここで#1, #2, #3が定義され、#1が無効になる
import &#34;c.h&#34;; // d.hではここで#4, #5が定義される
int a = Y;    // OK: #4は#2と同じ
int c = Z;    // エラー: #5は#3を異なる値で再定義している&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20では、インクルードに代わる新たな仕組みとしてモジュールが導入された。&lt;/p&gt;
&lt;p&gt;C++20では、プリプロセッサを用いずにプログラムを分割することができる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// a.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// モジュールAのインターフェース&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エクスポートしていない関数foo&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// エクスポートしている関数bar&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// a-impl.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// モジュールAの実装&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK: fooはエクスポートしていないが、モジュールAの中では見える。&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// unrelated.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK: barはAからエクスポートされているので見える&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: fooはモジュールAの外では見えない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;モジュール宣言&lt;/h3&gt;
&lt;p&gt;モジュール宣言の構文は以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;export(opt) module モジュール名 属性(opt);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;モジュール宣言は翻訳単位あたり1回だけ記述でき、翻訳単位の先頭に記述する。&lt;/li&gt;
&lt;li&gt;モジュール宣言を含む翻訳単位をモジュールユニットという。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt;がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。&lt;/li&gt;
&lt;li&gt;あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モジュール名は、識別子または識別子をドットで繋いだもの(例えば、&lt;code&gt;foo&lt;/code&gt;や&lt;code&gt;std.core&lt;/code&gt;)である。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fooのモジュールインターフェースユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fooのモジュールユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// foo.barのモジュールユニット&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deprecated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;グローバルモジュール&lt;/h4&gt;
&lt;p&gt;C++20では、名前のあるモジュールに属していない宣言はグローバルモジュールに属している。&lt;/p&gt;
&lt;p&gt;グローバルモジュールの性質は以下の通り。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名前を持たず、インポートすることはできない。&lt;/li&gt;
&lt;li&gt;宣言をエクスポートすることはできない。&lt;/li&gt;
&lt;li&gt;モジュールインターフェースユニットを持つことはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;エクスポート&lt;/h3&gt;
&lt;p&gt;モジュールインターフェースユニットの中では、宣言に&lt;code&gt;export&lt;/code&gt;キーワードを付加することでその対象をエクスポートできる。
モジュールをインポートすると、エクスポートした宣言が見える(名前解決の候補に挙がる)ようになる。&lt;/p&gt;
&lt;p&gt;モジュール実装ユニットでは、エクスポートできない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 変数のエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*...*/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// クラスのエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/*...*/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 名前空間のエクスポート&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 関数テンプレートのエクスポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;また、波カッコに&lt;code&gt;export&lt;/code&gt;をつけることで、その中の宣言をまとめてエクスポートできる。この波カッコはスコープを作らない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt;を付けた宣言が新たな名前を宣言していない場合は、エラーとなる。&lt;/li&gt;
&lt;li&gt;内部リンケージを持つ名前をエクスポートすると、エラーとなる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// エラー: 新たな名前を宣言していない&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// エラー: 内部リンケージを持つ名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// エラー: 内部リンケージを持つ名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// エラー: 明示的にstaticで宣言されている名前はエクスポートできない&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: 新たな名前を宣言していない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;モジュールリンケージ&lt;/h4&gt;
&lt;p&gt;C++20では、新たにモジュールリンケージが追加された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名前のあるモジュールに属していてエクスポートしていない名前は、モジュールリンケージを持つ。&lt;ul&gt;
&lt;li&gt;エクスポートしている名前は外部リンケージを持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モジュールリンケージを持つ名前は、同一モジュール内で参照できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;インポート&lt;/h3&gt;
&lt;p&gt;モジュールのインポート宣言は次のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libのインポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;モジュールをインポートすると、そのモジュールがエクスポートしている宣言が見える(名前解決の候補に挙がる)ようになる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エクスポートしていない宣言は見えない。&lt;/li&gt;
&lt;li&gt;マクロは取り込まれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;インポート宣言もエクスポートできる。これを再エクスポートという。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libの再エクスポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;再エクスポートすると、インポートで見えるようになった宣言をそのままエクスポートしたことになる。&lt;/p&gt;
&lt;h3&gt;モジュールパーティション&lt;/h3&gt;
&lt;p&gt;モジュールは分割することができる。分割したモジュールをモジュールパーティションという。&lt;/p&gt;
&lt;p&gt;モジュールパーティションを宣言する構文は以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;export(opt) module モジュール名:モジュールパーティション名 属性(opt);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;モジュールパーティション名の書式は、モジュール名と同じである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt; がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libモジュールのモジュールインターフェースパーティションpart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;internal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// libモジュールのモジュール実装パーティションinternal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主となるモジュールが異なる場合はインポートできない。&lt;ul&gt;
&lt;li&gt;外部へ公開するには、モジュールインターフェースから再エクスポートする。&lt;/li&gt;
&lt;li&gt;モジュールの利用者にパーティションの存在を意識させてはいけない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;インポート宣言にはモジュールパーティション名だけを書く。&lt;/li&gt;
&lt;li&gt;インポートするとエクスポートしていない宣言も見えるようになる。&lt;ul&gt;
&lt;li&gt;ただし、再エクスポートはできない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主となるモジュールのインターフェースとパーティションを区別する場合は、プライマリーモジュールインターフェースユニットという事がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 翻訳単位1&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位2&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位3&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 翻訳単位4&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Internals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;baz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このモジュールAは4つの翻訳単位からなる。上から順に、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(プライマリー)モジュールインターフェースユニット&lt;/li&gt;
&lt;li&gt;モジュールインターフェースパーティション &lt;code&gt;:Foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;モジュール実装パーティション &lt;code&gt;:Internals&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;モジュール実装ユニット&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;ODRの緩和&lt;/h3&gt;
&lt;p&gt;C++20では、複数の定義が同時に見えるようにならない限りODR違反とならない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// a.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// b.cpp&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このプログラムでは、関数&lt;code&gt;foo&lt;/code&gt;をモジュールA,Bで2回定義しているが、モジュールA,Bを同時にインポートしていないのでODR違反とならない。&lt;/p&gt;
&lt;h2&gt;後方互換性のための機能&lt;/h2&gt;
&lt;h3&gt;グローバルモジュールフラグメント&lt;/h3&gt;
&lt;p&gt;モジュール宣言の前にグローバルモジュールの実装を書くことができる。これをグローバルモジュールフラグメントという。&lt;/p&gt;
&lt;p&gt;グローバルモジュールフラグメントにはプリプロセッサディレクティブのみ記述できる。
翻訳フェーズ4以前の段階でプリプロセッサディレクティブ以外の記述がある場合は、エラーとなる。&lt;/p&gt;
&lt;p&gt;この機能は、モジュールのインターフェースへ影響を与えずにインクルードをするために用意された。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;             &lt;span class=&#34;c1&#34;&gt;// グローバルモジュールフラグメントの宣言&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#include &amp;lt;iostream&amp;gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &amp;lt;iostream&amp;gt;中の宣言はモジュールfooに含まれない。&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#include &#34;lib.h&#34;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &#34;lib.h&#34;中の宣言がモジュールfooに含まれてしまう(モジュールリンケージを持ってしまう)。&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;foo&#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;ヘッダーユニット&lt;/h3&gt;
&lt;p&gt;ヘッダーユニットは、ヘッダーファイルをモジュールとしてインポートする機能である。
ヘッダーファイル内の宣言が見えるようになり、通常のモジュールとは異なりマクロも引き継がれる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iostream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// iostreamをヘッダーユニットとしてインポート&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ヘッダーユニットは再エクスポートできるため、ライブラリをモジュールでラップするのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// lib.h&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#define NUM 1000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// lib_mod.cpp&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// lib.h中の宣言をすべてエクスポートするモジュールlib&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;lib.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// main.cpp&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lib&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK&lt;/span&gt;
  &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// エラー: マクロは再エクスポートしても引き継がれない&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ヘッダーユニットをインポートすると以下のことが起こる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ヘッダーファイルをプリプロセスし、その時定義されていたマクロをインポート宣言の直後で再定義する。&lt;/li&gt;
&lt;li&gt;ヘッダーファイルをフェーズ7までコンパイルし、その翻訳単位(ヘッダーユニット)をインポートする。&lt;ul&gt;
&lt;li&gt;内部リンケージを持たない名前は暗黙的にエクスポートされる。&lt;/li&gt;
&lt;li&gt;ヘッダーユニットはモジュール宣言を持てない。ヘッダーユニット内の宣言はグローバルモジュールに属する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;c1&#34;&gt;// &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3&lt;/a&gt;より引用&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// a.h&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define X 123 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #1&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 45  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #2&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Z a   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #3&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#undef  X      &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// a.hではここで#1が無効になる&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// b.h&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;a.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// b.hではここで#1, #2, #3が定義され、#1が無効になる&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define X 456 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// OK: #1で定義したXはすでに無効&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 6   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// エラー: #2で定義したYが有効&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// c.h&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Y 45  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #4&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define Z c   &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #5&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// d.h&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;a.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// d.hではここで#1, #2, #3が定義され、#1が無効になる&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;c.h&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// d.hではここで#4, #5が定義される&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// OK: #4は#2と同じ&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// エラー: #5は#3を異なる値で再定義している&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;C++20では、&lt;code&gt;#include&lt;/code&gt; プリプロセッサディレクティブがヘッダーユニットのインポートに置き換えられる場合がある。&lt;/p&gt;
&lt;h2&gt;ビルド&lt;/h2&gt;
&lt;p&gt;プログラムのビルドは規格の範囲外なので、ここでは一般論を述べる。&lt;/p&gt;
&lt;p&gt;モジュールをコンパイルすると、何らかの中間表現(コンパイル済みモジュール)が保存される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレートはテンプレートのまま（実体化することなく）エクスポートできるので、中間表現は機械語ではなく、いわゆるプリコンパイルドヘッダーと似たようなものにならざるを得ない。&lt;/li&gt;
&lt;li&gt;モジュールAをインポートするプログラムをコンパイルするには、モジュールAのコンパイル済みモジュールが存在しなければならない。&lt;/li&gt;
&lt;li&gt;モジュールAをインポートするプログラムをリンクするには、モジュールAに関するモジュールユニットから生成されるオブジェクトファイル、ライブラリなどを別途リンクしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;この機能が必要になった背景・経緯&lt;/h2&gt;
&lt;p&gt;プリプロセッサによるインクルードは、ヘッダーファイルの内容をその場に展開する。
これには次のような問題が指摘されてきた。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;コンパイル時間が長くなる&lt;ul&gt;
&lt;li&gt;ヘッダーファイルの内容が再帰的に展開され、プログラムが長くなる（Hello worldだけでも数万行に達する）&lt;/li&gt;
&lt;li&gt;さらに、展開が翻訳単位ごとに行われるので、全体で見ると同じヘッダーファイルが何度も解析される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プリプロセッサの状態により、インクルードの結果が変わってしまう&lt;ul&gt;
&lt;li&gt;インクルードの順番によってエラーが起きることがあった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ヘッダーファイル内の記述の影響を受けすぎる&lt;ul&gt;
&lt;li&gt;影響が大きいため、ヘッダーファイル内に書くことがためらわれる記述があった。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using namespace&lt;/code&gt;やマクロ(例えばWindowsにおける&lt;code&gt;max&lt;/code&gt;)など。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;モジュールは、以上のような問題のないプログラム分割の仕組みとして導入された。&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&#34; target=&#34;_blank&#34;&gt;P1103R3 Merging Modules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>MATSUMURA Tetsuro</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>