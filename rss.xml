<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-03-14T14:39:31.955320</updated>
  <id>da99d836-fad8-492d-a1ba-2566eae41de1</id>

  
    <entry>
      <title>range_adaptor_closure -- Update range_adaptor_closure.md</title>
      <link href="https://cpprefjp.github.io/reference/ranges/range_adaptor_closure.html"/>
      <id>76cc74bf7f8bdc0643b621a8e56310592c8443e4:reference/ranges/range_adaptor_closure.md</id>
      <updated>2024-03-13T01:18:20+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/range_adaptor_closure.md b/reference/ranges/range_adaptor_closure.md
index 770edfb32..b1ca321d9 100644
--- a/reference/ranges/range_adaptor_closure.md
+++ b/reference/ranges/range_adaptor_closure.md
@@ -50,8 +50,22 @@ public:
 
 inline constexpr user_defined_closure_t user_defined;
 ```
+* std::ranges::range_adaptor_closure[color ff0000]
+* std::ranges::viewable_range[link viewable_range.md]
+
+パイプライン記法をサポートする方法は規定されていないが、一般には処理系がRangeと`range_adaptor_closure`を引数とする以下のような`operator|`を定義することで行われると考えられる。
 
-パイプライン記法をサポートする方法は規定されていないが、一般には処理系がRangeと`range_adaptor_closure`を引数とする`operator|`を定義することで行われる。
+```cpp
+template&amp;lt;std::ranges::viewable_range R, class T&amp;gt;
+  requires std::derived_from&amp;lt;T, std::ranges::range_adaptor_closure&amp;lt;T&amp;gt;&amp;gt; &amp;amp;&amp;amp; std::invocable&amp;lt;T, R&amp;gt;
+constexpr auto operator| (R&amp;amp;&amp;amp; r, T&amp;amp;&amp;amp; raco) {
+  return raco(std::forward&amp;lt;R&amp;gt;(r));
+}
+```
+* std::ranges::range_adaptor_closure[color ff0000]
+* std::ranges::viewable_range[link viewable_range.md]
+* std::invocable[link /reference/concepts/invocable.md]
+* std::derived_from[link /reference/concepts/derived_from.md]
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>conj-if-needed -- linalg/conj-if-needed: fix meta header(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conj-if-needed.html"/>
      <id>89ae27b0cd8d0256805fd9d3baea485efbd79307:reference/linalg/conj-if-needed.md</id>
      <updated>2024-03-12T23:42:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conj-if-needed.md b/reference/linalg/conj-if-needed.md
index c8775c88b..0046a563b 100644
--- a/reference/linalg/conj-if-needed.md
+++ b/reference/linalg/conj-if-needed.md
@@ -1,5 +1,5 @@
 # conj-if-needed
-* lingalg[meta header]
+* linalg[meta header]
 * function[meta id-type]
 * std::linalg[meta namespace]
 * cpp26[meta cpp]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>linalg -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;linalg&lt;/span&gt;&lt;span class=&#34;cpp cpp26&#34; title=&#34;C++26で追加&#34;&gt;(C++26)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダでは、線形代数(linear algebra)に関する基礎的な演算アルゴリズムを提供する。
本ヘッダが提供するエンティティは、すべて名前空間&lt;code&gt;std::linalg&lt;/code&gt;に属する。&lt;/p&gt;
&lt;p&gt;1次元データであるベクトル(vector)や2次元データである行列(matrix)に対して、線形代数分野のデファクトスタンダードとされる BLAS(Basic Linear Algebra Subprograms) 互換のアルゴリズム群、いくつかの LAPACK(Linear Algebra PACKage) 互換のアルゴリズムが提供される。
BLAS互換アルゴリズムは、演算対象データの次元数や計算オーダーに応じて3段階に区分される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Level 1 BLAS : ベクトルーベクトルの演算&lt;/li&gt;
&lt;li&gt;Level 2 BLAS : 行列ーベクトルの演算&lt;/li&gt;
&lt;li&gt;Level 3 BLAS : 行列ー行列の演算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例えば、2個の一般行列の積を求める&lt;code&gt;std::linalg::matrix_product&lt;/code&gt;はLevel 3 BLASルーチン&lt;code&gt;xGEMM&lt;/code&gt;に対応する。
（実際のBLASルーチン名は、浮動小数点数型の単精度&lt;code&gt;S&lt;/code&gt;／倍精度&lt;code&gt;D&lt;/code&gt;とそれぞれの複素数版&lt;code&gt;C&lt;/code&gt;,&lt;code&gt;Z&lt;/code&gt;として、プレフィックス&lt;code&gt;x&lt;/code&gt;部は文字4種類のいずれか。）&lt;/p&gt;
&lt;p&gt;また、多次元配列ビュー&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/mdspan.html&#34;&gt;std::mdpan&lt;/a&gt;&lt;/code&gt;と組み合わせて利用する拡張機能が提供される。&lt;/p&gt;
&lt;h2&gt;共通要件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダが提供する演算アルゴリズムは、スカラ値およびベクトル／行列の要素型として線形代数値型(linear algebra value types)を取り扱う。&lt;/p&gt;
&lt;p&gt;線形代数値型はBLASが取り扱う&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;をはじめ、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts/semiregular.html&#34;&gt;semiregular&lt;/a&gt;&lt;/code&gt;のモデルであれば良い。
また、線形代数値型の値初期化は加法元（算術型であれば値&lt;code&gt;0&lt;/code&gt;）であること。&lt;/p&gt;
&lt;p&gt;プログラム定義型を利用する場合、演算アルゴリズムはカスタマイゼーションポイントとして&lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;imag&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;を非修飾名で呼び出す。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;std::mdspan&lt;/code&gt;向け機能拡張&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/layout_blas_packed.html&#34;&gt;layout_blas_packed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列要素のBLAS互換パックレイアウトに対応する&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/LayoutMappingPolicy.html&#34;&gt;レイアウトマッピングポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/scaled_accessor.html&#34;&gt;scaled_accessor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scaled&lt;/code&gt;関数用の&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/AccessorPolicy.html&#34;&gt;アクセサポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/scaled.html&#34;&gt;scaled&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素値をスカラー倍した読み取り専用&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/conjugated_accessor.html&#34;&gt;conjugated_accessor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;conjugated&lt;/code&gt;関数用の&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/AccessorPolicy.html&#34;&gt;アクセサポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/conjugated.html&#34;&gt;conjugated&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取り専用の複素共役ビュー&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/layout_transpose.html&#34;&gt;layout_transpose&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;transposed&lt;/code&gt;関数用の&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/LayoutMappingPolicy.html&#34;&gt;レイアウトマッピングポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/transposed.html&#34;&gt;transposed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2次元&lt;code&gt;std::mdspan&lt;/code&gt;の行列転置ビューを作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/conjugate_transposed.html&#34;&gt;conjugate_transposed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取り専用の複素共役転置ビュー&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 1アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;setup_givens_rotation_result&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;setup_givens_rotation&lt;/code&gt;の結果型 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;setup_givens_rotation&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xLARTG: ギブンス回転をセットアップする (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;apply_givens_rotation&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xROT: ベクトルにギブンス回転を適用する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;swap_elements&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSWAP: 2つのベクトル／行列の要素を交換する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSCAL: ベクトル／行列の要素にスカラ値を乗算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xCOPY: ベクトル／行列の要素をコピーする (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xAXPY: 2つのベクトル／行列の要素を加算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dot&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xDOT, xDOTU: 2つのベクトルのドット積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dotc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xDOTC: 2つのベクトルの複素共役ドット積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sum_of_squares_result&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector_sum_of_squares&lt;/code&gt;の結果型 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector_sum_of_squares&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xLASSQ: ベクトル要素の平方和を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector_two_norm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xNRM2: ベクトルのユークリッドノルム(Euclidean norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector_abs_sum&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xASUM: ベクトル要素の絶対値和を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector_idx_abs_max&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xIAMAX: ベクトル要素のうち最大絶対値インデクスを返す (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_frob_norm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列のフロベニウスノルム(Frobenius norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_one_norm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列の1ノルム(One norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_inf_norm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列の無限大ノルム(Infinity norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 2アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGEMV: 一般行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYMV: 対称行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHEMV: ハミルトニアン行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMV: 三角行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_vector_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSV: 三角行列を係数とする行列方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGER, xGERU: 行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_rank_1_update_c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGERC: 複素行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR: 対称行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER: ハミルトニアン行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_2_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR2: 対称行列のRank-2更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_2_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER2: ハミルトニアン行列のRank-2更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 3アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGEMM: 2つの一般行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYMM: 対称行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHEMM: ハミルトニアン行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: 三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_left_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: In-placeに三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_right_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: In-placeに三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYRK: 対称行列のRank-k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHERK: ハミルトニアン行列のRank-k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_2k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR2K: 対称行列のRank-2k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_2k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER2K: ハミルトニアン行列のRank-2k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_matrix_left_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSM: 三角行列の連立一次方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_matrix_right_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSM: 三角行列の連立一次方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;タグ型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/column_major_t.html&#34;&gt;column_major_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(column-major)順序を表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/column_major_t.html&#34;&gt;column_major&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(column-major)順序を表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/row_major_t.html&#34;&gt;row_major_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(row-major)順序を表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/row_major_t.html&#34;&gt;row_major&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(row-major)順序を表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/upper_triangle_t.md.nolink&#34;&gt;upper_triangle_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上三角行列を表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/upper_triangle_t.md.nolink&#34;&gt;upper_triangle&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上三角行列を表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/lower_triangle_t.md.nolink&#34;&gt;lower_triangle_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下三角行列を表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/lower_triangle_t.md.nolink&#34;&gt;lower_triangle&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下三角行列を表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;implicit_unit_diagonal_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;implicit unit diagonalを表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;implicit_unit_diagonal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;implicit unit diagonalを表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;explicit_diagonal_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;explicit diagonalを表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;explicit_diagonal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;explicit diagonalを表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++26&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html&#34; target=&#34;_blank&#34;&gt;P1673R13 A free function linear algebra interface based on the BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1674r2.html&#34; target=&#34;_blank&#34;&gt;P1674R2: Evolving a Standard C++ Linear Algebra Library from the BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CppCon/CppCon2023/blob/main/Presentations/stdlinalg_linear_algebra_coming_to_standard_cpp.pdf&#34; target=&#34;_blank&#34;&gt;std::linalg: Linear Algebra Coming to Standard C++&lt;/a&gt;, CppCon 2023&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.netlib.org/blas/&#34; target=&#34;_blank&#34;&gt;BLAS (Basic Linear Algebra Subprograms)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>conj-if-needed -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conj-if-needed.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/conj-if-needed.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conj-if-needed.md b/reference/linalg/conj-if-needed.md
new file mode 100644
index 000000000..c8775c88b
--- /dev/null
+++ b/reference/linalg/conj-if-needed.md
@@ -0,0 +1,30 @@
+# conj-if-needed
+* lingalg[meta header]
+* function[meta id-type]
+* std::linalg[meta namespace]
+* cpp26[meta cpp]
+
+## 概要
+`conj-if-needed`は、[`std::complex`](/reference/complex/complex.md)などの複素数型に対して複素共役を求める、説明専用の関数オブジェクトである。
+
+型`T`の式`E`に対して、式`conj-if-needed(E)`は次と等価である。
+
+- `T`が算術型かつ式`conj(E)`が下記宣言を含むコンテキストにおいてオーバーロード解決を行った結果が妥当であるとき、`conj(E)`
+    ```cpp
+    template&amp;lt;class T&amp;gt; T conj(const T&amp;amp;) = delete; 
+    ```
+
+-  そうでなければ、`E`
+
+
+## 備考
+オーバーロード解決により選択された関数が入力値の複素共役(complex conjugate)を返さないとき、プログラムは不適格となる。
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>conjugate_transposed -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conjugate_transposed.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/conjugate_transposed.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conjugate_transposed.md b/reference/linalg/conjugate_transposed.md
new file mode 100644
index 000000000..98e6ad4ae
--- /dev/null
+++ b/reference/linalg/conjugate_transposed.md
@@ -0,0 +1,80 @@
+# conjugate_transposed
+* linalg[meta header]
+* function template[meta id-type]
+* std::linalg[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::linalg {
+  template&amp;lt;class ElementType, class Extents, class Layout, class Accessor&amp;gt;
+    constexpr auto conjugate_transposed(mdspan&amp;lt;ElementType, Extents, Layout, Accessor&amp;gt; a);
+}
+```
+* Extents[link /reference/mdspan/extents.md]
+* Layout[link /reference/mdspan/LayoutMappingPolicy.md]
+* Accessor[link /reference/mdspan/AccessorPolicy.md]
+* mdspan[link /reference/mdspan/mdspan.md]
+
+## 概要
+行列(matrix)を表現する2次元配列ビュー[`std::mdspan`](/reference/mdspan/mdspan.md)に対して、共役転置(conjugate transpose)を表現する新しい2次元配列ビューを作る。
+
+本操作により`mdspan`参照先メモリブロックが書き換えられることはなく、戻り値`mdspan`を介した要素アクセス時に共役転置変換が行われる。
+
+
+## 効果
+以下と等価。
+```cpp
+return conjugated(transposed(a));
+```
+* conjugated[link conjugated.md]
+* transposed[link transposed.md]
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;complex&amp;gt;
+#include &amp;lt;linalg&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+
+int main()
+{
+  std::complex&amp;lt;double&amp;gt; arr[] = {{1, 1}, {2, 2}, {3, 3}, {4, 4}};
+  std::mdspan mat0{arr, 2, 2};
+  // 1+i  2+2i
+  // 3+3i 4+4i
+
+  auto mat1 = std::linalg::conjugate_transposed(mat0);
+  // 1-i  3-3i
+  // 2-2i 4-4i
+  assert(imag(mat1[1, 0]) == -3);
+
+  // linalg::conjugate_transposed適用後のmdspan要素は読み取り専用となり、
+  // 例えば mat1[0] = {0, 0}; はコンパイルエラーを引き起こす。
+}
+```
+* std::linalg::conjugate_transposed[color ff0000]
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`mdspan`](/reference/mdspan/mdspan.md)
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
+- [P1674R2: Evolving a Standard C++ Linear Algebra Library from the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1674r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>conjugated -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conjugated.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/conjugated.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conjugated.md b/reference/linalg/conjugated.md
new file mode 100644
index 000000000..78fb8b04a
--- /dev/null
+++ b/reference/linalg/conjugated.md
@@ -0,0 +1,91 @@
+# conjugated
+* linalg[meta header]
+* function template[meta id-type]
+* std::linalg[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::linalg {
+  template&amp;lt;class ElementType, class Extents, class Layout, class Accessor&amp;gt;
+    constexpr auto conjugated(mdspan&amp;lt;ElementType, Extents, Layout, Accessor&amp;gt; a);
+}
+```
+* Extents[link /reference/mdspan/extents.md]
+* Layout[link /reference/mdspan/LayoutMappingPolicy.md]
+* Accessor[link /reference/mdspan/AccessorPolicy.md]
+* mdspan[link /reference/mdspan/mdspan.md]
+
+## 概要
+多次元配列ビュー[`std::mdspan`](/reference/mdspan/mdspan.md)に対して、要素値の複素共役変換を行なった新しい多次元配列ビューを作る。
+
+本操作により`mdspan`参照先メモリブロックが書き換えられることはなく、戻り値`mdspan`を介した要素アクセス時に複素共役変換が行われる。
+
+
+## 戻り値
+- `Accessor`が[`conjugated_accessor`](conjugated_accessor.md)の特殊化のとき、説明用の型`A`を[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;decltype(a.accessor().nested_accessor())&amp;gt;`として、
+
+    ```cpp
+    mdspan&amp;lt;typename A::element_type, Extents, Layout, A&amp;gt;(
+      a.data_handle(), a.mapping(), a.accessor().nested_accessor())
+    ```
+    * mdspan[link /reference/mdspan/mdspan.md]
+    * Extents[link /reference/mdspan/extents.md]
+    * Layout[link /reference/mdspan/LayoutMappingPolicy.md]
+
+- そうではないとき、説明用の型`A`を[`conjugated_accessor`](conjugated_accessor.md)`&amp;lt;Accessor&amp;gt;`として、
+
+    ```cpp
+    mdspan&amp;lt;typename A::element_type, Extents, Layout, A&amp;gt;(
+      a.data_handle(), a.mapping(), conjugated_accessor(a.accessor()))
+    ```
+    * mdspan[link /reference/mdspan/mdspan.md]
+    * Extents[link /reference/mdspan/extents.md]
+    * Layout[link /reference/mdspan/LayoutMappingPolicy.md]
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;complex&amp;gt;
+#include &amp;lt;linalg&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+
+int main()
+{
+  std::complex&amp;lt;double&amp;gt; arr[] = {{1, 1}, {2, 2}, {3, 3}};
+  std::mdspan vec0{arr, 3};
+  // 1+i 2+2i 3+3i
+
+  auto vec1 = std::linalg::conjugated(vec0);
+  // 1-i 2-2i 3-3i
+  assert(real(vec1[0]) == 1 &amp;amp;&amp;amp; imag(vec1[0]) == -1);
+
+  // linalg::conjugated適用後のmdspan要素は読み取り専用となり、
+  // 例えば vec1[0] = {4, 4}; はコンパイルエラーを引き起こす。
+}
+```
+* std::linalg::conjugated[color ff0000]
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`mdspan`](/reference/mdspan/mdspan.md)
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
+- [P1674R2: Evolving a Standard C++ Linear Algebra Library from the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1674r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>conjugated_accessor -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conjugated_accessor.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/conjugated_accessor.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conjugated_accessor.md b/reference/linalg/conjugated_accessor.md
new file mode 100644
index 000000000..4fa5278f8
--- /dev/null
+++ b/reference/linalg/conjugated_accessor.md
@@ -0,0 +1,74 @@
+# conjugated_accessor
+* linalg[meta header]
+* class template[meta id-type]
+* std::linalg[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::linalg {
+  template&amp;lt; class NestedAccessor&amp;gt;
+  class conjugated_accessor;
+}
+```
+* NestedAccessor[link /reference/mdspan/AccessorPolicy.md]
+
+## 概要
+`conjugated_accessor`は、多次元配列ビュー[`mdspan`](/reference/mdspan/mdspan.md)の全要素を複素共役した多次元配列ビューを表現する[アクセサポリシー](/reference/mdspan/AccessorPolicy.md)クラスである。
+
+`conjugated_accessor`クラステンプレートは、複素共役操作[`conjugated`](conjugated.md)の戻り値型として利用される。
+戻り値`mdspad`の要素型は読み取り専用となる。
+
+### 説明専用メンバ
+`conjugated_accessor`クラステンプレートは、下記の説明専用メンバ変数を保持する。
+
+- `nested-accessor_` : `NestedAccessor`型の入れ子アクセサポリシー
+
+
+## 適格要件
+- `element_type`が適格な型であること
+- [`is_copy_constructible_v`](/reference/type_traits/is_copy_constructible.md)`&amp;lt;reference&amp;gt; == true`
+- [`is_reference_v`](/reference/type_traits/is_reference.md)`&amp;lt;element_type&amp;gt; == false`
+- `NestedAccessor`が[アクセサポリシー](/reference/mdspan/AccessorPolicy.md)要件を満たす
+
+
+## メンバ関数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`(constructor)`](conjugated_accessor/op_constructor.md) | コンストラクタ | C++26 |
+| `(destructor)` | デストラクタ | C++26 |
+| [`access`](conjugated_accessor/access.md) | 指定オフセット位置にある要素へアクセスする | C++26 |
+| [`offset`](conjugated_accessor/offset.md) | 指定オフセット位置のハンドルを取得する | C++26 |
+| `nested_accessor` | 入れ子アクセサポリシー`nested-accessor_`を取得する | C++26 |
+
+
+## メンバ型
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| `element_type` | [`add_const_t`](/reference/type_traits/add_const.md)`&amp;lt;decltype(`[`conj-if-needed`](conj-if-needed.md)`(declval&amp;lt;NestedAccessor::element_type&amp;gt;()))&amp;gt;` | C++26 |
+| `reference` | [`remove_const_t`](/reference/type_traits/remove_const.md)`&amp;lt;element_type&amp;gt;` | C++26 |
+| `data_handle_type` | `NestedAccessor::data_handle_type` | C++26 |
+| `offset_policy` | `conjugated_accessor&amp;lt;NestedAccessor::offset_policy&amp;gt;` | C++26 |
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`mdspan`](/reference/mdspan/mdspan.md)
+- [`conjugated`](conjugated.md)
+- [`conjugate_transposed`](conjugate_transposed.md)
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
+- [P1674R2: Evolving a Standard C++ Linear Algebra Library from the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1674r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>acccess -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conjugated_accessor/access.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/conjugated_accessor/access.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conjugated_accessor/access.md b/reference/linalg/conjugated_accessor/access.md
new file mode 100644
index 000000000..2e3760423
--- /dev/null
+++ b/reference/linalg/conjugated_accessor/access.md
@@ -0,0 +1,32 @@
+# acccess
+* linalg[meta header]
+* function[meta id-type]
+* std::linalg[meta namespace]
+* conjugated_accessor[meta class]
+* cpp26[meta cpp]
+
+```cpp
+constexpr reference access(data_handle_type p, size_t i) const;
+```
+
+## 概要
+指定オフセット位置にある要素へアクセスする。
+
+
+## 戻り値
+[`conj-if-needed`](../conj-if-needed.md)`(NestedAccessor::element_type(nested-accessor_.access(p, i)))`
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>offset -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conjugated_accessor/offset.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/conjugated_accessor/offset.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conjugated_accessor/offset.md b/reference/linalg/conjugated_accessor/offset.md
new file mode 100644
index 000000000..3dd78c837
--- /dev/null
+++ b/reference/linalg/conjugated_accessor/offset.md
@@ -0,0 +1,32 @@
+# offset
+* linalg[meta header]
+* function[meta id-type]
+* std::linalg[meta namespace]
+* conjugated_accessor[meta class]
+* cpp26[meta cpp]
+
+```cpp
+constexpr offset_policy::data_handle_type offset(data_handle_type p, size_t i) const;
+```
+
+## 概要
+指定オフセット位置のハンドルを取得する。
+
+
+## 戻り値
+`nested-accessor_.offset(p, i)`
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/conjugated_accessor/op_constructor.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/conjugated_accessor/op_constructor.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/conjugated_accessor/op_constructor.md b/reference/linalg/conjugated_accessor/op_constructor.md
new file mode 100644
index 000000000..2caccac95
--- /dev/null
+++ b/reference/linalg/conjugated_accessor/op_constructor.md
@@ -0,0 +1,48 @@
+# コンストラクタ
+* linalg[meta header]
+* function[meta id-type]
+* std::linalg[meta namespace]
+* conjugated_accessor[meta class]
+* cpp26[meta cpp]
+
+```cpp
+constexpr conjugated_accessor() = default; // (1)
+
+template&amp;lt;class OtherNestedAccessor&amp;gt;
+explicit(!is_convertible_v&amp;lt;OtherNestedAccessor, NestedAccessor&amp;gt;)
+constexpr conjugated_accessor(const conjugated_accessor&amp;lt;OtherNestedAccessor&amp;gt;&amp;amp; other); // (2)
+
+constexpr conjugated_accessor(const NestedAccessor&amp;amp; acc); // (3)
+```
+* is_convertible_v[link /reference/type_traits/is_convertible.md]
+* NestedAccessor[link /reference/mdspan/AccessorPolicy.md]
+* OtherNestedAccessor[link /reference/mdspan/AccessorPolicy.md]
+
+## 概要
+- (1) : デフォルトコンストラクタ
+- (2) : 他`conjugated_accessor`からの変換コンストラクタ
+- (3) : `NestedAccessor`から構築
+
+
+## テンプレートパラメータ制約
+- (2) : [`is_constructible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;NestedAccessor, const OtherNestedAccessor&amp;amp;&amp;gt; == true`
+
+
+## 効果
+- (2) : `nested-accessor_`を`other.nested_accessor()`で直接非リスト初期化する。
+- (3) : `nested-accessor_`を`acc`で直接非リスト初期化する。
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>layout_transpose -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_transpose.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/layout_transpose.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_transpose.md b/reference/linalg/layout_transpose.md
index c652870be..04478f200 100644
--- a/reference/linalg/layout_transpose.md
+++ b/reference/linalg/layout_transpose.md
@@ -43,6 +43,7 @@ namespace std::linalg {
 ## 関連項目
 - [`mdspan`](/reference/mdspan/mdspan.md)
 - [`transposed`](transposed.md)
+- [`conjugate_transposed`](conjugate_transposed.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scaled -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/scaled.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/scaled.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/scaled.md b/reference/linalg/scaled.md
index d0ee62546..5dc16a38a 100644
--- a/reference/linalg/scaled.md
+++ b/reference/linalg/scaled.md
@@ -5,9 +5,11 @@
 * cpp26[meta cpp]
 
 ```cpp
-template&amp;lt;class ScalingFactor,
-         class ElementType, class Extents, class Layout, class Accessor&amp;gt;
-constexpr auto scaled(ScalingFactor alpha, mdspan&amp;lt;ElementType, Extents, Layout, Accessor&amp;gt; x);
+namespace std::linalg {
+  template&amp;lt;class ScalingFactor,
+           class ElementType, class Extents, class Layout, class Accessor&amp;gt;
+  constexpr auto scaled(ScalingFactor alpha, mdspan&amp;lt;ElementType, Extents, Layout, Accessor&amp;gt; x);
+}
 ```
 * Extents[link /reference/mdspan/extents.md]
 * Layout[link /reference/mdspan/LayoutMappingPolicy.md]
@@ -41,15 +43,15 @@ mdspan&amp;lt;typename SA::element_type, Extents, Layout, SA&amp;gt;(
 int main()
 {
   int arr[] = {1, 2, 3, 4};
-  std::mdspan vec0{arr, std::extents&amp;lt;size_t, 4&amp;gt;{}};
-  // 1 2 3 4 
+  std::mdspan vec0{arr, 4};
+  // 1 2 3 4
 
   auto vec1 = std::linalg::scaled(2, vec0);
   // 2 4 6 8
   assert(vec1[0] == 2);
 
-  // linalg::scaled適用後のmdspan要素は読み取り専用となため、
-  // 例えば vec1[0] == 42; はコンパイルエラーを引き起こす。
+  // linalg::scaled適用後のmdspan要素は読み取り専用となり、
+  // 例えば vec1[0] = 42; はコンパイルエラーを引き起こす。
 }
 ```
 * std::linalg::scaled[color ff0000]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/scaled_accessor/op_constructor.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/scaled_accessor/op_constructor.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/scaled_accessor/op_constructor.md b/reference/linalg/scaled_accessor/op_constructor.md
index e6efd62d5..6a3ee36d4 100644
--- a/reference/linalg/scaled_accessor/op_constructor.md
+++ b/reference/linalg/scaled_accessor/op_constructor.md
@@ -24,6 +24,10 @@ constexpr scaled_accessor(const ScalingFactor&amp;amp; s, const NestedAccessor&amp;amp; a); // (
 - (3) : `ScalingFactor`と`NestedAccessor`から構築
 
 
+## テンプレートパラメータ制約
+- (2) : [`is_constructible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;NestedAccessor, const OtherNestedAccessor&amp;amp;&amp;gt; == true`
+
+
 ## 効果
 - (2) : `scaling-factor`を`other.scaling_factor()`で、`nested-accessor`を`other.nested_accessor()`で直接非リスト初期化する。
 - (3) : `scaling-factor`を`s`で、`nested-accessor`を`a`で直接非リスト初期化する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transposed -- linalg: conjugated,conjugate_transposed(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/transposed.html"/>
      <id>2079dde1871789376e53808abe998ea70d7d9e52:reference/linalg/transposed.md</id>
      <updated>2024-03-12T23:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/transposed.md b/reference/linalg/transposed.md
index e29d0f86c..dec56c1af 100644
--- a/reference/linalg/transposed.md
+++ b/reference/linalg/transposed.md
@@ -5,12 +5,10 @@
 * cpp26[meta cpp]
 
 ```cpp
-template&amp;lt;class ElementType,
-         class Extents,
-         class Layout,
-         class Accessor&amp;gt;
-constexpr auto transposed(
-  mdspan&amp;lt;ElementType, Extents, Layout, Accessor&amp;gt; a);
+namespace std::linalg {
+  template&amp;lt;class ElementType, class Extents, class Layout, class Accessor&amp;gt;
+    constexpr auto transposed(mdspan&amp;lt;ElementType, Extents, Layout, Accessor&amp;gt; a);
+}
 ```
 * Extents[link /reference/mdspan/extents.md]
 * Layout[link /reference/mdspan/LayoutMappingPolicy.md]
@@ -82,9 +80,8 @@ constexpr auto transposed(
 int main()
 {
   int arr[] = {1, 2, 3, 4, 5, 6};
-  using Ext2D = std::dextents&amp;lt;size_t, 2&amp;gt;;
 
-  std::mdspan mat0{arr, Ext2D{2, 3}};
+  std::mdspan mat0{arr, 2, 3};
   assert(mat0.extent(0) == 2 &amp;amp;&amp;amp; mat0.extent(1) == 3);
   // 1 2
   // 3 4
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>range_adaptor_closure -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/ranges/range_adaptor_closure.html"/>
      <id>8ec80d9ac8e75017c6a1d35e7fbe9d57e8d6d62c:reference/ranges/range_adaptor_closure.md</id>
      <updated>2024-03-12T07:19:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/range_adaptor_closure.md b/reference/ranges/range_adaptor_closure.md
index cabde221a..770edfb32 100644
--- a/reference/ranges/range_adaptor_closure.md
+++ b/reference/ranges/range_adaptor_closure.md
@@ -110,7 +110,6 @@ int main() {
 * std::ranges::range_adaptor_closure[color ff0000]
 * std::bind_back[link /reference/functional/bind_back.md]
 * std::invocable[link /reference/concepts/invocable.md]
-* std::views::all[link all.md]
 * std::ranges::range[link range.md]
 * std::ranges::viewable_range[link viewable_range.md]
 * std::ranges::join_view[link join_view.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>