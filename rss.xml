<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-08-17T07:53:33.878426</updated>
  <id>276c2066-deab-4e16-877e-9e5d061f47cf</id>

  
    <entry>
      <title>insert -- 未使用のコード修飾を削除</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/insert.html"/>
      <id>3547182922866d554e5e9e681ffdc2bb81c6503f:reference/flat_map/flat_map/insert.md</id>
      <updated>2023-08-17T16:47:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/insert.md b/reference/flat_map/flat_map/insert.md
index e19ee2fba..2a500628c 100644
--- a/reference/flat_map/flat_map/insert.md
+++ b/reference/flat_map/flat_map/insert.md
@@ -38,7 +38,6 @@ void insert(sorted_unique_t s,
 * pair[link /reference/utility/pair.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * sorted_unique_t[link /reference/flat_map/sorted_unique_t.md]
-* container-compatible-range[link /reference/exposition-only/container-compatible-range.md]
 
 ## 概要
 新しく一つの要素(引数 `x`, `y`を使う)または要素のシーケンス(入力イテレータまたは `initializer_list` を使う)を挿入し、コンテナを拡張する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_map -- flat_map : insert_rangeを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map.html"/>
      <id>292f841f9c90af75b5804ce5481dc23e6f93580a:reference/flat_map/flat_map.md</id>
      <updated>2023-08-17T16:33:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map.md b/reference/flat_map/flat_map.md
index 53e8f472e..24660156e 100644
--- a/reference/flat_map/flat_map.md
+++ b/reference/flat_map/flat_map.md
@@ -60,7 +60,7 @@ namespace std {
 | [`clear`](flat_map/clear.md)                       | 全ての要素を削除する                       | C++23 |
 | [`insert`](flat_map/insert.md)                     | 要素を挿入する                             | C++23 |
 | [`insert_or_assign`](flat_map/insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               | C++23 |
-| [`insert_range`](flat_map/insert_range.md.nolink)         | Rangeを挿入する                            | C++23 |
+| [`insert_range`](flat_map/insert_range.md)         | Rangeを挿入する                            | C++23 |
 | [`emplace`](flat_map/emplace.md)                   | 要素を直接構築する                         | C++23 |
 | [`emplace_hint`](flat_map/emplace_hint.md)         | ヒントを使って要素を直接構築する           | C++23 |
 | [`try_emplace`](flat_map/try_emplace.md)           | キーが存在しない場合のみ要素を直接構築する | C++23 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- flat_map : insert_rangeを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/insert.html"/>
      <id>292f841f9c90af75b5804ce5481dc23e6f93580a:reference/flat_map/flat_map/insert.md</id>
      <updated>2023-08-17T16:33:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/insert.md b/reference/flat_map/flat_map/insert.md
index 5f3a656f0..e19ee2fba 100644
--- a/reference/flat_map/flat_map/insert.md
+++ b/reference/flat_map/flat_map/insert.md
@@ -30,13 +30,10 @@ void insert(sorted_unique_t,
             InputIterator first,
             InputIterator last);                  // (8) C++23
 
-template&amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
-void insert_range(R&amp;amp;&amp;amp; rg);                        // (9) C++23
-
-void insert(initializer_list&amp;lt;value_type&amp;gt; il);     // (10) C++23
+void insert(initializer_list&amp;lt;value_type&amp;gt; il);     // (9) C++23
 
 void insert(sorted_unique_t s,
-            initializer_list&amp;lt;value_type&amp;gt; il);     // (11) C++23
+            initializer_list&amp;lt;value_type&amp;gt; il);     // (10) C++23
 ```
 * pair[link /reference/utility/pair.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
@@ -64,9 +61,8 @@ void insert(sorted_unique_t s,
 - (6) : 指定された位置に、要素型`value_type`のコンストラクタ引数を受け取って挿入する
 - (7) : イテレータ範囲`[first, last)`を挿入する
 - (8) : ソート済みかつ重複要素のないイテレータ範囲`[first, last)`を挿入する
-- (9) : Rangeを挿入する
-- (10) : 初期化子リストを挿入する
-- (11) : ソート済みかつ重複要素のない初期化子リストを挿入する
+- (9) : 初期化子リストを挿入する
+- (10) : ソート済みかつ重複要素のない初期化子リストを挿入する
 
 
 ## 要件
@@ -181,44 +177,12 @@ void insert(sorted_unique_t s,
     * key_equiv[link key_equiv.md]
     * distance[link /reference/iterator/distance.md]
 
-- (9) : メンバ変数として保持しているコンテナ`c`に、以下のように挿入する：
-    ```cpp
-    for (const auto&amp;amp; e : rg) {
-      c.keys.insert(c.keys.end(), e.first);
-      c.values.insert(c.values.end(), e.second);
-    }
-    ```
-    * c.keys[link containers.md]
-    * c.values[link containers.md]
-    * end()[link /reference/vector/vector/end.md]
-    * insert[link /reference/vector/vector/insert.md]
-    * first[link /reference/utility/pair.md]
-    * second[link /reference/utility/pair.md]
-
-    - 次に、新しく挿入された要素の範囲を`value_comp()`を基準にソートする
-    - 次に、ソートされた結果の範囲と、既存の要素のソートされた範囲をひとつのソートされた範囲にマージする
-    - 最後に、重複する要素を以下のように削除する：
-
-    ```cpp
-    auto zv = ranges::zip_view(c.keys, c.values);
-    auto it = ranges::unique(zv, key_equiv(compare)).begin();
-    auto dist = distance(zv.begin(), it);
-    c.keys.erase(c.keys.begin() + dist, c.keys.end());
-    c.values.erase(c.values.begin() + dist, c.values.end());
-    ```
-    * c.keys[link containers.md]
-    * c.values[link containers.md]
-    * ranges::zip_view[link /ranges/zip_view.md.nolink]
-    * ranges::unique[link /reference/algorithm/ranges_unique.md]
-    * key_equiv[link key_equiv.md]
-    * distance[link /reference/iterator/distance.md]
-
-- (10) :
+- (9) :
     ```cpp
     insert(il.begin(), il.end());
     ```
 
-- (11) :
+- (10) :
     ```cpp
     insert(s, il.begin(), il.end());
     ```
@@ -231,17 +195,16 @@ void insert(sorted_unique_t s,
 - (3), (4), (6) :
     - 挿入された場合には、新しく挿入された要素を指すイテレータを返す。
     - 挿入されなかった場合には、`x`のキーと等価のキーを持つ要素へのイテレータを返す。
-- (7), (8), (9), (10), (11) : なし
+- (7), (8), (9), (10) : なし
 
 
 ## 計算量
 - (7) : Nをこの操作の前の[`size()`](size.md)、Mを[`distance`](/reference/iterator/distance.md)`(first, last)`として、N + MlogM
-- (7) : Nをこの操作のあとの[`size()`](size.md)として、Nに対して線形
-- (8) : Nをこの操作の前の[`size()`](size.md)、Mを[`ranges::distance`](/reference/iterator/ranges_distance.md)`(rg)`として、N + MlogM
+- (8) : Nをこの操作のあとの[`size()`](size.md)として、Nに対して線形
 
 
 ## 備考
-- (7), (8), (9) : この操作はインプレース・マージを行うため、追加のメモリ確保を行う可能性がある
+- (7), (8) : この操作はインプレース・マージを行うため、追加のメモリ確保を行う可能性がある
 
 
 ## 例
@@ -263,7 +226,6 @@ int main()
   };
 
   // シーケンスを挿入する
-  fm.insert(fm2);
   fm.insert(fm2.begin(), fm2.end());
 
   // 挿入するシーケンスがソート済みかつ重複要素がないことがわかっている場合、
@@ -275,6 +237,7 @@ int main()
   }
 }
 ```
+* insert[color ff0000]
 * begin()[link begin.md]
 * end()[link end.md]
 * std::sorted_unique[link /reference/flat_map/sorted_unique_t.md]
@@ -298,6 +261,7 @@ int main()
 | 名前                                           | 説明                                       |
 |------------------------------------------------|--------------------------------------------|
 | [`flat_map::insert_or_assign`](insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               |
+| [`flat_map::insert_range`](insert_range.md)         | Rangeを挿入する                            |
 | [`flat_map::emplace`](emplace.md)                   | 要素を直接構築する                         |
 | [`flat_map::emplace_hint`](emplace_hint.md)         | ヒントを使って要素を直接構築する           |
 | [`flat_map::try_emplace`](try_emplace.md)           | キーが存在しない場合のみ要素を直接構築する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_range -- flat_map : insert_rangeを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/insert_range.html"/>
      <id>292f841f9c90af75b5804ce5481dc23e6f93580a:reference/flat_map/flat_map/insert_range.md</id>
      <updated>2023-08-17T16:33:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/insert_range.md b/reference/flat_map/flat_map/insert_range.md
new file mode 100644
index 000000000..7962278bf
--- /dev/null
+++ b/reference/flat_map/flat_map/insert_range.md
@@ -0,0 +1,120 @@
+# insert_range
+* flat_map[meta header]
+* std[meta namespace]
+* flat_map[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+template&amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+void insert_range(R&amp;amp;&amp;amp; rg);                        // (1) C++23
+```
+* container-compatible-range[link /reference/exposition-only/container-compatible-range.md]
+
+## 概要
+Rangeを挿入し、コンテナを拡張する。
+
+これは、挿入された要素の数だけコンテナの [`size()`](size.md) を増やす。
+
+`flat_map` コンテナは重複したキーを持つ要素を許さないため、挿入操作はそれぞれの要素が他のコンテナ内の既存要素と同じキーかどうかをチェックする。もし同じであれば要素は挿入されない。
+
+重複した値を許す、類似したコンテナについては `flat_multimap` を参照。
+
+内部的に `flat_map` コンテナは、コンストラクト時に指定された比較オブジェクトによって要素を下位から上位へとソートして保持する。
+
+
+## 効果
+- メンバ変数として保持しているコンテナ`c`に、以下のように挿入する：
+    ```cpp
+    for (const auto&amp;amp; e : rg) {
+      c.keys.insert(c.keys.end(), e.first);
+      c.values.insert(c.values.end(), e.second);
+    }
+    ```
+    * c.keys[link containers.md]
+    * c.values[link containers.md]
+    * end()[link /reference/vector/vector/end.md]
+    * insert[link /reference/vector/vector/insert.md]
+    * first[link /reference/utility/pair.md]
+    * second[link /reference/utility/pair.md]
+
+    - 次に、新しく挿入された要素の範囲を`value_comp()`を基準にソートする
+    - 次に、ソートされた結果の範囲と、既存の要素のソートされた範囲をひとつのソートされた範囲にマージする
+    - 最後に、重複する要素を以下のように削除する：
+
+    ```cpp
+    auto zv = ranges::zip_view(c.keys, c.values);
+    auto it = ranges::unique(zv, key_equiv(compare)).begin();
+    auto dist = distance(zv.begin(), it);
+    c.keys.erase(c.keys.begin() + dist, c.keys.end());
+    c.values.erase(c.values.begin() + dist, c.values.end());
+    ```
+    * c.keys[link containers.md]
+    * c.values[link containers.md]
+    * ranges::zip_view[link /ranges/zip_view.md.nolink]
+    * ranges::unique[link /reference/algorithm/ranges_unique.md]
+    * key_equiv[link key_equiv.md]
+    * distance[link /reference/iterator/distance.md]
+
+
+## 戻り値
+なし
+
+
+## 計算量
+- Nをこの操作の前の[`size()`](size.md)、Mを[`ranges::distance`](/reference/iterator/ranges_distance.md)`(rg)`として、N + MlogM
+
+
+## 備考
+- この操作はインプレース・マージを行うため、追加のメモリ確保を行う可能性がある
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+
+int main()
+{
+  std::flat_map&amp;lt;int, char&amp;gt; fm = {
+    {3, &amp;#39;a&amp;#39;}
+  };
+
+  std::flat_map&amp;lt;int, char&amp;gt; fm2 = {
+    {5, &amp;#39;d&amp;#39;},
+    {15, &amp;#39;e&amp;#39;}
+  };
+
+  fm.insert_range(fm2);
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* insert_range[color ff0000]
+
+### 出力
+```
+3 : a
+5 : d
+15 : e
+```
+
+## バージョン
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前                                           | 説明                                       |
+|------------------------------------------------|--------------------------------------------|
+| [`flat_map::insert`](insert.md)                     | 要素を挿入する               |
+| [`flat_map::insert_or_assign`](insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               |
+| [`flat_map::emplace`](emplace.md)                   | 要素を直接構築する                         |
+| [`flat_map::emplace_hint`](emplace_hint.md)         | ヒントを使って要素を直接構築する           |
+| [`flat_map::try_emplace`](try_emplace.md)           | キーが存在しない場合のみ要素を直接構築する |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>説明専用ライブラリ -- container-compatible-rangeコンセプトを追加 #1069</title>
      <link href="https://cpprefjp.github.io/reference/exposition-only.html"/>
      <id>f3f750307c2fa2056d04f01ad79cc0e75236a054:reference/exposition-only.md</id>
      <updated>2023-08-16T20:22:34+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;exposition-only&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;説明専用ライブラリ&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このページでは、説明専用のライブラリをまとめる。
これらはC++規格の文章中に現れる説明のためのものであり、実際に使うことはできない。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exposition-only/decay-copy.html&#34;&gt;decay-copy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay&lt;/a&gt;&lt;/code&gt;した型にコピーまたはムーブする (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exposition-only/synth-three-way-result.html&#34;&gt;synth-three-way&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;三方比較可能であればそれを行い、そうでなければ三方比較を実装して比較を行う (variable)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exposition-only/synth-three-way-result.html&#34;&gt;synth-three-way-result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;synth-three-way&lt;/code&gt;関数オブジェクトでの比較結果の型 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;コンテナ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exposition-only/container-compatible-range.html&#34;&gt;container-compatible-range&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定されたコンテナと互換性のあるRange&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;concepts&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts/boolean-testable.html&#34;&gt;boolean-testable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真理値型 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/dereferenceable.html&#34;&gt;with-reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型&lt;code&gt;T&lt;/code&gt;に参照を付加する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/dereferenceable.html&#34;&gt;can-reference&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/dereferenceable.html&#34;&gt;with-reference&lt;/a&gt;&lt;/code&gt;可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/dereferenceable.html&#34;&gt;dereferenceable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;単純な間接参照が可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/is_integer_like.html&#34;&gt;is-integer-like&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号付整数型と同等の型か否かを表す (variable template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/is_integer_like.html&#34;&gt;is-signed-integer-like&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号なし整数型と同等の型か否かを表す (variable template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/constant-iterator.html&#34;&gt;&lt;code&gt;constant-iterator&lt;/code&gt; &lt;/a&gt;&lt;/td&gt;
&lt;td&gt;要素不変なイテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;ranges&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/copyable_box.html&#34;&gt;copyable-box&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピー可能、または例外なしでムーブ可能な場合のみ値を保持する型 (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/simple-view.html&#34;&gt;simple-view&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;単純なビューを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/has-arrow.html&#34;&gt;has-arrow&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/input_iterator.html&#34;&gt;std::input_iterator&lt;/a&gt;&lt;/code&gt;を満たし、アロー演算子が使用できる型かを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/different-from.html&#34;&gt;different-from&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;const&lt;/code&gt;/&lt;code&gt;volatile&lt;/code&gt;修飾を無視して、2つの型が同じでないことを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/subrange/uses-nonqualification-pointer-conversion.html&#34;&gt;uses-nonqualification-pointer-conversion&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;直接変換できない型同士のポインタの変換が必要かどうかを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/subrange/convertible-to-non-slicing.html&#34;&gt;convertible-to-non-slicing&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スライシングを起こさずに変換できるかどうかを表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/subrange/pair-like-convertible-from.html&#34;&gt;pair-like-convertible-from&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある2つの型から構築出来る&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/pair-like.html&#34;&gt;pair-like&lt;/a&gt;&lt;/code&gt;な型を表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;tuple&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple-like.html&#34;&gt;tuple-like&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;tuple&lt;/a&gt;&lt;/code&gt;のような型を表す (concept)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/pair-like.html&#34;&gt;pair-like&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;pair&lt;/a&gt;&lt;/code&gt;のような型を表す (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://timsong-cpp.github.io/cppwp/n4861/expos.only.func&#34; target=&#34;_blank&#34;&gt;N4861 16.4.2.1 Exposition-only functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cplusplus.github.io/LWG/issue3404&#34; target=&#34;_blank&#34;&gt;LWG 3404 Finish removing &lt;code&gt;subrange&lt;/code&gt;&#39;s conversions from &lt;code&gt;pair-like&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2278r4.html&#34; target=&#34;_blank&#34;&gt;P2278R4 &lt;code&gt;cbegin&lt;/code&gt; should always return a constant iterator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>container-compatible-range -- container-compatible-rangeコンセプトを追加 #1069</title>
      <link href="https://cpprefjp.github.io/reference/exposition-only/container-compatible-range.html"/>
      <id>f3f750307c2fa2056d04f01ad79cc0e75236a054:reference/exposition-only/container-compatible-range.md</id>
      <updated>2023-08-16T20:22:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/exposition-only/container-compatible-range.md b/reference/exposition-only/container-compatible-range.md
new file mode 100644
index 000000000..a6b13dd0d
--- /dev/null
+++ b/reference/exposition-only/container-compatible-range.md
@@ -0,0 +1,27 @@
+# container-compatible-range
+* exposition-only[meta header]
+* concept[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class R, class T&amp;gt;
+  concept container-compatible-range =
+    ranges::input_range&amp;lt;R&amp;gt; &amp;amp;&amp;amp; convertible_to&amp;lt;ranges::range_reference_t&amp;lt;R&amp;gt;, T&amp;gt;;
+}
+```
+* ranges::input_range[link /reference/ranges/input_range.md]
+* ranges::range_reference[link /reference/ranges/range_reference_t.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+
+## 概要
+container-compatible-rangeは、指定されたコンテナと互換性のあるRangeであることを表すコンセプトである。
+
+
+## バージョン
+### 言語
+- C++23
+
+
+## 参照
+- [P1206R7 `ranges::to`: A function to convert any range to a container](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1206r7.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- container-compatible-rangeコンセプトを追加 #1069</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/insert.html"/>
      <id>f3f750307c2fa2056d04f01ad79cc0e75236a054:reference/flat_map/flat_map/insert.md</id>
      <updated>2023-08-16T20:22:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/insert.md b/reference/flat_map/flat_map/insert.md
index 243f2797d..5f3a656f0 100644
--- a/reference/flat_map/flat_map/insert.md
+++ b/reference/flat_map/flat_map/insert.md
@@ -41,6 +41,7 @@ void insert(sorted_unique_t s,
 * pair[link /reference/utility/pair.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 * sorted_unique_t[link /reference/flat_map/sorted_unique_t.md]
+* container-compatible-range[link /reference/exposition-only/container-compatible-range.md]
 
 ## 概要
 新しく一つの要素(引数 `x`, `y`を使う)または要素のシーケンス(入力イテレータまたは `initializer_list` を使う)を挿入し、コンテナを拡張する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/insert.html"/>
      <id>1e3373055cb45f236e09607348f156090c597335:reference/flat_map/flat_map/insert.md</id>
      <updated>2023-08-16T20:16:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/insert.md b/reference/flat_map/flat_map/insert.md
index d3c7e9001..243f2797d 100644
--- a/reference/flat_map/flat_map/insert.md
+++ b/reference/flat_map/flat_map/insert.md
@@ -40,7 +40,7 @@ void insert(sorted_unique_t s,
 ```
 * pair[link /reference/utility/pair.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
-* sorted_unique_t[link ]
+* sorted_unique_t[link /reference/flat_map/sorted_unique_t.md]
 
 ## 概要
 新しく一つの要素(引数 `x`, `y`を使う)または要素のシーケンス(入力イテレータまたは `initializer_list` を使う)を挿入し、コンテナを拡張する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- map::insert : P&amp;&amp;とvalue_type&amp;&amp;は両方存在するのでオーバーロード番号を分け、概要文章を追加</title>
      <link href="https://cpprefjp.github.io/reference/map/map/insert.html"/>
      <id>2dd6e26bcbdb1a1faebd702ca4e0be505acb9668:reference/map/map/insert.md</id>
      <updated>2023-08-16T20:11:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/insert.md b/reference/map/map/insert.md
index db4b32347..259a068cb 100644
--- a/reference/map/map/insert.md
+++ b/reference/map/map/insert.md
@@ -8,23 +8,25 @@
 pair&amp;lt;iterator, bool&amp;gt; insert(const value_type&amp;amp; x);               // (1)
 
 template &amp;lt;class P&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; insert(P&amp;amp;&amp;amp; x);                             // (2) C++11から
-pair&amp;lt;iterator, bool&amp;gt; insert(value_type&amp;amp;&amp;amp; x);                    // (2) C++17から
+pair&amp;lt;iterator, bool&amp;gt; insert(P&amp;amp;&amp;amp; x);                             // (2) C++11
 
-iterator insert(iterator position, const value_type&amp;amp; x);        // (3) C++11まで
-iterator insert(const_iterator position, const value_type&amp;amp; x);  // (3) C++11から
+pair&amp;lt;iterator, bool&amp;gt; insert(value_type&amp;amp;&amp;amp; x);                    // (3) C++17
+
+iterator insert(iterator position, const value_type&amp;amp; x);        // (4) C++03まで
+iterator insert(const_iterator position, const value_type&amp;amp; x);  // (4) C++11から
 
 template &amp;lt;class P&amp;gt;
-iterator insert(const_iterator position, P&amp;amp;&amp;amp; x);                // (4) C++11から
-iterator insert(const_iterator position, value_type&amp;amp;&amp;amp; x);       // (4) C++17から
+iterator insert(const_iterator position, P&amp;amp;&amp;amp; x);                // (5) C++11
+
+iterator insert(const_iterator position, value_type&amp;amp;&amp;amp; x);       // (6) C++17
 
 template &amp;lt;class InputIterator&amp;gt;
-void insert(InputIterator first, InputIterator last);           // (5)
+void insert(InputIterator first, InputIterator last);           // (7)
 
-void insert(initializer_list&amp;lt;value_type&amp;gt; init);                 // (6) C++11から
+void insert(initializer_list&amp;lt;value_type&amp;gt; init);                 // (8) C++11
 
-insert_return_type insert(node_type&amp;amp;&amp;amp; nh);                      // (7) C++17から
-iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (8) C++17から
+insert_return_type insert(node_type&amp;amp;&amp;amp; nh);                      // (9) C++17
+iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (10) C++17
 ```
 * pair[link /reference/utility/pair.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
@@ -43,64 +45,75 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (8) C++17か
 この操作は、適切な引数 `position` を提供することで効率を飛躍的に改善することができる。
 
 
-## 要件
-- (1) : `value_type` は、コンテナに対してコピー挿入可能でなければならない。
-- (2) : `value_type` は、コンテナに対してムーブ挿入可能でなければならない。
-- (3) : `value_type` は、コンテナに対してコピー挿入可能でなければならない。
-- (4) : `value_type` は、コンテナに対してムーブ挿入可能でなければならない。
-- (5) : イテレータ範囲`[first, last)`の各イテレータが、`*this`の要素を指さないこと。
-- (6) : (5)の要件と同じである。
-- (7) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`である。
-- (8) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`である。
+- (1) : 単一要素を挿入する
+- (2) : 単一要素として要素型`value_type`のコンストラクタ引数を受け取って挿入する
+- (3) : 単一要素の一時オブジェクトを挿入する
+- (4) : 指定された位置に、単一要素を挿入する
+- (5) : 指定された位置に、要素型`value_type`のコンストラクタ引数を受け取って挿入する
+- (6) : 指定された位置に、単一要素の一時オブジェクトを挿入する
+- (7) : イテレータ範囲`[first, last)`を挿入する
+- (8) : 初期化子リストを挿入する
+- (9) : [ノードハンドル](/reference/node_handle/node_handle.md)を挿入する
+- (10) : 指定された位置に、[ノードハンドル](/reference/node_handle/node_handle.md)を挿入する
+
+
+## テンプレートパラメータ制約
+- (1) : `value_type` は、コンテナに対してコピー挿入可能であること
+- (2) : [`std::is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true`であること
+- (3) : `value_type` は、コンテナに対してムーブ挿入可能であること
+- (4) : `value_type` は、コンテナに対してコピー挿入可能であること
+- (5) : [`std::is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true`であること
+- (6) : `value_type` は、コンテナに対してムーブ挿入可能であること
+
+
+## 事前条件
+- (7), (8) : イテレータ範囲`[first, last)`の各イテレータが、`*this`の要素を指さないこと
+- (9), (10) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`であること
 
 
 ## 効果
 - (1) : `x`を`*this`の要素としてコピー挿入する。ただし、`x`のキーと等価のキーを持つ要素が`*this`に存在する場合には、挿入されない。
 - (2) : [`emplace`](emplace.md)`(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
-- (3) : `x`を`*this`の要素としてコピー挿入する。ただし、`x`のキーと等価のキーを持つ要素が`*this`に存在する場合には、挿入されない。可能であれば、挿入位置のヒントを表すイテレータ`position`のすぐ前に挿入する。
-- (4) : [`emplace_hint`](emplace_hint.md)`(position,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
-- (5) : イテレータ範囲`[first, last)`の各要素を`*this`の要素として挿入する。ただし、`*this`にすでに存在するキーと等価なキーを持つ要素については、挿入されない。
-- (6) : `insert(init.begin(), init.end())`と等価。
-- (7) : `nh`が空の場合、効果はない。
+- (3) : `x`を`*this`の要素としてムーブ挿入する。ただし、`x`のキーと等価のキーを持つ要素が`*this`に存在する場合には、挿入されない。
+- (4) : `x`を`*this`の要素としてコピー挿入する。ただし、`x`のキーと等価のキーを持つ要素が`*this`に存在する場合には、挿入されない。可能であれば、挿入位置のヒントを表すイテレータ`position`のすぐ前に挿入する。
+- (5) : [`emplace_hint`](emplace_hint.md)`(position,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
+- (6) : `x`を`*this`の要素としてムーブ挿入する。ただし、`x`のキーと等価のキーを持つ要素が`*this`に存在する場合には、挿入されない。可能であれば、挿入位置のヒントを表すイテレータ`position`のすぐ前に挿入する。
+- (7) : イテレータ範囲`[first, last)`の各要素を`*this`の要素として挿入する。ただし、`*this`にすでに存在するキーと等価なキーを持つ要素については、挿入されない。
+- (8) : `insert(init.begin(), init.end())`と等価。
+- (9) : `nh`が空の場合、効果はない。
 それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
-- (8) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。
-それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。`nh.key()`と等価のキーの要素を指すイテレータを常に返す。
-要素は、`p`の直前の位置のできるだけ近くに挿入される。
+- (10) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。`nh.key()`と等価のキーの要素を指すイテレータを常に返す。要素は、`p`の直前の位置のできるだけ近くに挿入される。
 
 
 ## 戻り値
-- (1), (2) : 戻り値としては、イテレータと`bool`値の組を返す。
+- (1), (2), (3) : 戻り値としては、イテレータと`bool`値の組を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、 `second` に `true` が設定される。
     - 挿入されなかった場合には、 `first` に `x` と等価のキーを持つ要素へのイテレータ、 `second` に `false` が設定される。
-- (3), (4) :
+- (4), (5), (6) :
     - 挿入された場合には、新しく挿入された要素を指すイテレータを返す。
     - 挿入されなかった場合には、`x`のキーと等価のキーを持つ要素へのイテレータを返す。
-- (5), (6) : なし
-- (7) : 戻り値としては、[`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
+- (7), (8) : なし
+- (9) : 戻り値としては、[`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
     - 挿入された場合には、空の[ノードハンドル](/reference/node_handle/node_handle.md)。
     - 挿入されなかった場合には、`nh`の値である。 
-- (8) : `nh`が空の場合、`(*this).end()`を返す。そうではない場合、`nh`と等価のキーの要素を指すイテレータを常に返す。
+- (10) : `nh`が空の場合、`(*this).end()`を返す。そうではない場合、`nh`と等価のキーの要素を指すイテレータを常に返す。
 
 
 ## 計算量
-- (1), (2) : 対数時間
-- (3), (4) : 一般に対数時間だが、指定された新たな要素が `position` が指す要素の直前に挿入された場合は償却定数時間。（ただし、備考も参照）
-- (5), (6) : 一般に N log(size + N)。（ただし、備考も参照）
+- (1), (2), (3) : 対数時間
+- (4), (5), (6) : 一般に対数時間だが、指定された新たな要素が `position` が指す要素の直前に挿入された場合は償却定数時間。（ただし、備考も参照）
+- (7), (8) : 一般に N log(size + N)。（ただし、備考も参照）
     - ここで、 `N` は `first` と `last` の間の距離であり `size` は挿入前のコンテナの [`size()`](size.md) を表す。
-- (7) : 対数時間
-- (8) : 一般に対数時間だが、指定された新たな要素が `position` が指す要素の直前に挿入された場合は償却定数時間。
+- (9) : 対数時間
+- (10) : 一般に対数時間だが、指定された新たな要素が `position` が指す要素の直前に挿入された場合は償却定数時間。
 
 
 ## 備考
 - これらの関数が呼ばれた後も、当該コンテナ内の要素を指す参照やイテレータは無効にはならない。  
 	なお、規格書に明確な記載は無いが、当該コンテナ内の要素を指すポインタも無効にはならない。
-- (3), (4) : C++03 までの仕様では、計算量が償却定数時間となる条件は、「`position` が指す要素の**後ろ**に挿入された場合」となっているが、主要な実装はC++03時点から `position` が指す**前**に挿入する場合に償却定数時間となっていた。これは、`position` の後ろでは、適切な位置が先頭の場合に指定する方法がないこと、`vector::insert` の場合、`position` の前に挿入されること、STL のオリジナルである HP 社の実装が `position` の前に挿入する場合に償却定数時間であったことなどによる。
-
-- (5) : C++03 までの仕様では、`first` と `last` の間が昇順にソートされていた場合、計算量が線形時間となっていたが、この仕様は実現性がないため C++11 では削除された。（例えば、コンテナの既存の要素が 2 から 100 の偶数のみの場合に、1 から 99 のソートされた奇数の範囲を挿入する場合を考えてみよ）
-
-- (2), (4) : [`std::is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true`である場合のみ、これらの関数はオーバーロード解決に参加する。
-
-- (7), (8) : 要素は、コピーもムーブもされない。
+- (4), (5), (6): C++03 までの仕様では、計算量が償却定数時間となる条件は、「`position` が指す要素の**後ろ**に挿入された場合」となっているが、主要な実装はC++03時点から `position` が指す**前**に挿入する場合に償却定数時間となっていた。これは、`position` の後ろでは、適切な位置が先頭の場合に指定する方法がないこと、`vector::insert` の場合、`position` の前に挿入されること、STL のオリジナルである HP 社の実装が `position` の前に挿入する場合に償却定数時間であったことなどによる。
+- (7) : C++03 までの仕様では、`first` と `last` の間が昇順にソートされていた場合、計算量が線形時間となっていたが、この仕様は実現性がないため C++11 では削除された。（例えば、コンテナの既存の要素が 2 から 100 の偶数のみの場合に、1 から 99 のソートされた奇数の範囲を挿入する場合を考えてみよ）
+- (9), (10) : 要素は、コピーもムーブもされない。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>