<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-06-22T07:20:05.733549</updated>
  <id>ba2dbf7e-d48b-423e-b4b9-3a2449f7fd51</id>

  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_map/unordered_map/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/erase.md b/reference/unordered_map/unordered_map/erase.md
index cfbdeb6f0..ba3dbaa80 100644
--- a/reference/unordered_map/unordered_map/erase.md
+++ b/reference/unordered_map/unordered_map/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要。
-- (2) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
-- (3) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
+- (4) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -94,10 +96,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_map&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, um);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, um);
 
     auto count1 = um.erase(&amp;#34;5th&amp;#34;);
     auto count2 = um.erase(&amp;#34;8th&amp;#34;);
@@ -107,10 +109,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_map&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, um);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, um);
 
     auto it1 = std::next(um.cbegin());
     auto it2 = std::next(it1, 2);
@@ -135,12 +137,12 @@ argument: (3rd, 3)
 return value: (1st, 1)
 after : (9th, 9), (7th, 7), (5th, 5), (1st, 1), 
 
-(2) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
+(3) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 argument: 5th, 8th
 return value: 1, 0
 after : (9th, 9), (7th, 7), (3rd, 3), (1st, 1), 
 
-(3) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
+(4) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 arguments: (7th, 7), (3rd, 3)
 return value: (3rd, 3)
 after : (9th, 9), (3rd, 3), (1st, 1), 
@@ -200,10 +202,6 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 
-## 参照
-- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
-
-
 ## 関連項目
 
 | 名前                                | 説明                                                   |
@@ -214,3 +212,8 @@ int main()
 | [`clear`](clear.md)               | 全要素の削除                                           |
 | [`swap`](swap.md)                 | 内容の交換                                             |
 
+
+## 参照
+- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_map/unordered_multimap/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/erase.md b/reference/unordered_map/unordered_multimap/erase.md
index 804e96d93..e93bb2ddf 100644
--- a/reference/unordered_map/unordered_multimap/erase.md
+++ b/reference/unordered_map/unordered_multimap/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。
-- (2) : 削除した要素数。
-- (3) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。
+- (4) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -94,10 +96,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_multimap&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, {&amp;#34;3rd&amp;#34;, 33}, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, um);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, um);
 
     auto count1 = um.erase(&amp;#34;5th&amp;#34;);
     auto count2 = um.erase(&amp;#34;8th&amp;#34;);
@@ -108,10 +110,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_multimap&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, {&amp;#34;3rd&amp;#34;, 33}, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, um);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, um);
 
     auto it1 = std::next(um.cbegin());
     auto it2 = std::next(it1, 2);
@@ -136,12 +138,12 @@ argument: (3rd, 33)
 return value: (3rd, 3)
 after : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 
-(2) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
+(3) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
 argument: 5th, 8th, 3rd
 return value: 1, 0, 2
 after : (9th, 9), (7th, 7), (1st, 1), 
 
-(3) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
+(4) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
 arguments: (7th, 7), (3rd, 33)
 return value: (3rd, 33)
 after : (9th, 9), (3rd, 33), (3rd, 3), (1st, 1), 
@@ -215,5 +217,5 @@ int main()
 ## 参照
 - [LWG Issue 518. Are `insert` and `erase` stable for `unordered_multiset` and `unordered_multimap`?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518)
     - 安定性の保証が規定された経緯のレポート
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_set/unordered_multiset/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/erase.md b/reference/unordered_set/unordered_multiset/erase.md
index 88cb5415f..b32770c2f 100644
--- a/reference/unordered_set/unordered_multiset/erase.md
+++ b/reference/unordered_set/unordered_multiset/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。
-- (2) : 削除した要素数。
-- (3) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。
+- (4) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -86,10 +88,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_multiset&amp;lt;int&amp;gt; ums{ 1, 3, 5, 7, 9, 3, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, ums);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, ums);
 
     auto count1 = ums.erase(5);
     auto count2 = ums.erase(8);
@@ -100,10 +102,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_multiset&amp;lt;int&amp;gt; ums{ 1, 3, 5, 7, 9, 3, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, ums);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, ums);
 
     auto it1 = std::next(ums.cbegin());
     auto it2 = std::next(it1, 2);
@@ -127,12 +129,12 @@ argument: 1
 return value: 3
 after : 9 7 5 3 3
 
-(2) erase(const value_type&amp;amp;) before : 9 7 5 1 3 3
+(3) erase(const value_type&amp;amp;) before : 9 7 5 1 3 3
 argument: 5, 8, 3
 return value: 1, 0, 2
 after : 9 7 1
 
-(3) erase(const_iterator, const_iterator) before : 9 7 5 1 3 3
+(4) erase(const_iterator, const_iterator) before : 9 7 5 1 3 3
 arguments: 7, 1
 return value: 1
 after : 9 1 3 3
@@ -202,5 +204,5 @@ int main()
 ## 参照
 - [LWG Issue 518. Are `insert` and `erase` stable for `unordered_multiset` and `unordered_multimap`?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518)
     - 安定性の保証が規定された経緯のレポート
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_set/unordered_set/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/erase.md b/reference/unordered_set/unordered_set/erase.md
index 8a6c214ac..cab1403e8 100644
--- a/reference/unordered_set/unordered_set/erase.md
+++ b/reference/unordered_set/unordered_set/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。
-- (2) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
-- (3) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
+- (4) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -86,10 +88,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 1, 3, 5, 7, 9, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, us);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, us);
 
     auto count1 = us.erase(5);
     auto count2 = us.erase(8);
@@ -99,10 +101,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 1, 3, 5, 7, 9, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, us);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, us);
 
     auto it1 = std::next(us.cbegin());
     auto it2 = std::next(it1, 2);
@@ -126,12 +128,12 @@ argument: 3
 return value: 1
 after : 9 7 5 1
 
-(2) erase(const value_type&amp;amp;) before : 9 7 5 3 1
+(3) erase(const value_type&amp;amp;) before : 9 7 5 3 1
 argument: 5, 8
 return value: 1, 0
 after : 9 7 3 1
 
-(3) erase(const_iterator, const_iterator) before : 9 7 5 3 1
+(4) erase(const_iterator, const_iterator) before : 9 7 5 3 1
 arguments: 7, 3
 return value: 3
 after : 9 3 1
@@ -186,9 +188,6 @@ int main()
 - [ICC](/implementation.md#icc): ?
 - [Visual C++](/implementation.md#visual_cpp): ?
 
-## 参照
-- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
-
 
 ## 関連項目
 
@@ -200,3 +199,8 @@ int main()
 | [`clear`](clear.md)               | 全要素の削除                                           |
 | [`swap`](swap.md)                 | 内容の交換                                             |
 
+
+## 参照
+- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : オーバーロード仕様が古くなっていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/map/map/erase.html"/>
      <id>6251e4abe9d90fab42621ba97fea3a0b4a3c94aa:reference/map/map/erase.md</id>
      <updated>2023-06-22T16:06:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/erase.md b/reference/map/map/erase.md
index 868c9e440..84fe25a4f 100644
--- a/reference/map/map/erase.md
+++ b/reference/map/map/erase.md
@@ -5,13 +5,18 @@
 * function[meta id-type]
 
 ```cpp
-void erase(iterator position);                             // (1) C++03
-iterator erase(const_iterator position);                   // (1) C++11
+void erase(iterator position);                             // (1) C++03 (C++11で一旦削除)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; x);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-void erase(iterator first, iterator last);                 // (3) C++03
-iterator erase(const_iterator first, const_iterator last); // (3) C++11
+size_type erase(const key_type&amp;amp; x);                        // (3) C++03
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+void erase(iterator first, iterator last);                 // (5) C++03
+iterator erase(const_iterator first, const_iterator last); // (5) C++11
 ```
 
 ## 概要
@@ -20,8 +25,10 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 - (1) : 指定されたイテレータが指す要素を削除する
-- (2) : 指定されたキーをもつ要素を削除する
-- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素を削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素を削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
 
 
 ## パラメータ
@@ -31,16 +38,20 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 
 ## 戻り値
-- (1), (3)
+- (1) :
+    - C++03 : 戻り値なし
+    - C++17 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (2) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す
+- (5) :
     - C++03 : 戻り値なし
     - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
-- (2) 削除された要素の数を返す。
 
 
 ## 計算量
-- (1) 定数時間。
-- (2) コンテナの [`size()`](/reference/map/map/size.md) について対数時間。
-- (3) コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間。
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
 
 
 ## 備考
@@ -174,7 +185,11 @@ int main()
 
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+    - C++11で、`erase(iterator)`を`erase(const_iterator)`に変更
 - [LWG Issue 2258. `a.erase(q1, q2)` unable to directly return `q2`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258)
     - C++11では、「`a.erase(q1, q2)`の結果として`q2`が返る」という仕様だったが、`const_iterator`型が渡された場合に`iterator`型を返せない問題があった。そのためC++14では、`q2`が指す要素を指すイテレータが返る、ということが明記された
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を再追加
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; erase(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : オーバーロード仕様が古くなっていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/erase.html"/>
      <id>6251e4abe9d90fab42621ba97fea3a0b4a3c94aa:reference/map/multimap/erase.md</id>
      <updated>2023-06-22T16:06:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/erase.md b/reference/map/multimap/erase.md
index 2f45485d8..f52bcb6cf 100644
--- a/reference/map/multimap/erase.md
+++ b/reference/map/multimap/erase.md
@@ -5,13 +5,18 @@
 * function[meta id-type]
 
 ```cpp
-void erase(iterator position);                             // (1) C++03
-iterator erase(const_iterator position);                   // (1) C++11
+void erase(iterator position);                             // (1) C++03 (C++11で一旦削除)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; x);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-void erase(iterator first, iterator last);                 // (3) C++03
-iterator erase(const_iterator first, const_iterator last); // (3) C++11
+size_type erase(const key_type&amp;amp; x);                        // (3) C++03
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+void erase(iterator first, iterator last);                 // (5) C++03
+iterator erase(const_iterator first, const_iterator last); // (5) C++11
 ```
 
 
@@ -21,9 +26,10 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 - (1) : 指定されたイテレータが指す要素を削除する
-- (2) : 指定されたキーをもつ要素をすべて削除する
-- (3) : 指定されたイテレータ範囲の要素をすべて削除する
-
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素をすべて削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素をすべて削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
 
 ## パラメータ
 - `position` : `multimap` から削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
@@ -32,16 +38,20 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 
 ## 戻り値
-- (1), (3)
+- (1) :
+    - C++03 : 戻り値なし
+    - C++17 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (2) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す
+- (5) :
     - C++03 : 戻り値なし
     - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
-- (2) 削除された要素の数を返す。
 
 
 ## 計算量
-- (1) 定数時間。
-- (2) コンテナの [`size()`](/reference/map/map/size.md) について対数時間。
-- (3) コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間。
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
 
 
 ## 備考
@@ -164,7 +174,10 @@ int main()
 
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+    - C++11で、`erase(iterator)`を`erase(const_iterator)`に変更
 - [LWG Issue 2258. `a.erase(q1, q2)` unable to directly return `q2`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258)
     - C++11では、「`a.erase(q1, q2)`の結果として`q2`が返る」という仕様だったが、`const_iterator`型が渡された場合に`iterator`型を返せない問題があった。そのためC++14では、`q2`が指す要素を指すイテレータが返る、ということが明記された
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を再追加
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; erase(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : オーバーロード仕様が古くなっていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/erase.html"/>
      <id>6251e4abe9d90fab42621ba97fea3a0b4a3c94aa:reference/set/multiset/erase.md</id>
      <updated>2023-06-22T16:06:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/erase.md b/reference/set/multiset/erase.md
index 4aed5f014..f8cd9641c 100644
--- a/reference/set/multiset/erase.md
+++ b/reference/set/multiset/erase.md
@@ -5,13 +5,18 @@
 * function[meta id-type]
 
 ```cpp
-void erase(iterator position);                             // (1) C++03 まで
-iterator erase(const_iterator position);                   // (1) C++11 から
+void erase(iterator position);                             // (1) C++03 (C++11で一旦削除)
+iterator erase(iterator position);                         // (1) C++17
 
-void erase(iterator first, iterator last);                 // (2) C++03 まで
-iterator erase(const_iterator first, const_iterator last); // (2) C++11 から
+iterator erase(const_iterator position);                   // (2) C++11
 
-size_type erase(const key_type&amp;amp; x);                        // (3)
+size_type erase(const key_type&amp;amp; x);                        // (3) C++03
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+void erase(iterator first, iterator last);                 // (5) C++03
+iterator erase(const_iterator first, const_iterator last); // (5) C++11
 ```
 
 
@@ -20,8 +25,10 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 - (1) : 指定されたイテレータが指す要素を削除する
-- (2) : 指定されたキーをもつ要素をすべて削除する
-- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素をすべて削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素をすべて削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
 
 
 ## パラメータ
@@ -31,16 +38,20 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 戻り値
-- (1), (2) :
-    - C++03 まで : なし
+- (1) :
+    - C++03 : 戻り値なし
+    - C++17 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (2) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す
+- (5) :
+    - C++03 : 戻り値なし
     - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
-- (3) : 削除された要素の数を返す。
 
 
 ## 計算量
-- (1) : 定数時間
-- (2) : コンテナの [`size()`](size.md) についての対数時間と、それに加えて `first` と `last` の間の距離に対する線形時間。
-- (3) : コンテナの [`size()`](size.md) についての対数時間と、それに加えて `x` と等価なキーの要素数に対する線形時間。
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
 
 
 ## 備考
@@ -157,7 +168,10 @@ int main()
 
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+    - C++11で、`erase(iterator)`を`erase(const_iterator)`に変更
 - [LWG Issue 2258. `a.erase(q1, q2)` unable to directly return `q2`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258)
     - C++11では、「`a.erase(q1, q2)`の結果として`q2`が返る」という仕様だったが、`const_iterator`型が渡された場合に`iterator`型を返せない問題があった。そのためC++14では、`q2`が指す要素を指すイテレータが返る、ということが明記された
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を再追加
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; erase(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : オーバーロード仕様が古くなっていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/set/set/erase.html"/>
      <id>6251e4abe9d90fab42621ba97fea3a0b4a3c94aa:reference/set/set/erase.md</id>
      <updated>2023-06-22T16:06:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/erase.md b/reference/set/set/erase.md
index 1138910f9..683180d57 100644
--- a/reference/set/set/erase.md
+++ b/reference/set/set/erase.md
@@ -5,13 +5,18 @@
 * function[meta id-type]
 
 ```cpp
-void erase(iterator position);                             // (1) C++03 まで
-iterator erase(const_iterator position);                   // (1) C++11 から
+void erase(iterator position);                             // (1) C++03 (C++11で一旦削除)
+iterator erase(iterator position);                         // (1) C++17
 
-void erase(iterator first, iterator last);                 // (2) C++03 まで
-iterator erase(const_iterator first, const_iterator last); // (2) C++11 から
+iterator erase(const_iterator position);                   // (2) C++11
 
-size_type erase(const key_type&amp;amp; x);                        // (3)
+size_type erase(const key_type&amp;amp; x);                        // (3) C++03
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+void erase(iterator first, iterator last);                 // (5) C++03
+iterator erase(const_iterator first, const_iterator last); // (5) C++11
 ```
 
 
@@ -20,8 +25,10 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 - (1) : 指定されたイテレータが指す要素を削除する
-- (2) : 指定されたキーをもつ要素を削除する
-- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素を削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素を削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
 
 
 ## パラメータ
@@ -31,16 +38,20 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 戻り値
-- (1), (2) :
-    - C++03 まで : なし
+- (1) :
+    - C++03 : 戻り値なし
+    - C++17 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (2) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す
+- (5) :
+    - C++03 : 戻り値なし
     - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
-- (3) : 削除された要素の数を返す。
 
 
 ## 計算量
-- (1) : 定数時間
-- (2) : コンテナの [`size()`](size.md) についての対数時間と、それに加えて `first` と `last` の間の距離に対する線形時間。
-- (3) : コンテナの [`size()`](size.md) について対数時間。
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
 
 
 ## 備考
@@ -158,7 +169,11 @@ int main()
 
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+    - C++11で、`erase(iterator)`を`erase(const_iterator)`に変更
 - [LWG Issue 2258. `a.erase(q1, q2)` unable to directly return `q2`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258)
     - C++11では、「`a.erase(q1, q2)`の結果として`q2`が返る」という仕様だったが、`const_iterator`型が渡された場合に`iterator`型を返せない問題があった。そのためC++14では、`q2`が指す要素を指すイテレータが返る、ということが明記された
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を再追加
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; erase(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : endが返る条件の文章がわかりにくかったので修正</title>
      <link href="https://cpprefjp.github.io/reference/map/map/erase.html"/>
      <id>ae7c515da20425de6c80b7b4336ec49ba8d7f0c6:reference/map/map/erase.md</id>
      <updated>2023-06-19T15:30:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/erase.md b/reference/map/map/erase.md
index df6cd4fe5..868c9e440 100644
--- a/reference/map/map/erase.md
+++ b/reference/map/map/erase.md
@@ -33,7 +33,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 ## 戻り値
 - (1), (3)
     - C++03 : 戻り値なし
-    - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す(コンテナが空になった場合や、最後尾の要素を削除した場合)。
+    - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
 - (2) 削除された要素の数を返す。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : endが返る条件の文章がわかりにくかったので修正</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/erase.html"/>
      <id>ae7c515da20425de6c80b7b4336ec49ba8d7f0c6:reference/map/multimap/erase.md</id>
      <updated>2023-06-19T15:30:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/erase.md b/reference/map/multimap/erase.md
index 0c19e0a46..2f45485d8 100644
--- a/reference/map/multimap/erase.md
+++ b/reference/map/multimap/erase.md
@@ -34,7 +34,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 ## 戻り値
 - (1), (3)
     - C++03 : 戻り値なし
-    - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す(コンテナが空になった場合や、最後尾の要素を削除した場合)。
+    - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
 - (2) 削除された要素の数を返す。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : endが返る条件の文章がわかりにくかったので修正</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/erase.html"/>
      <id>ae7c515da20425de6c80b7b4336ec49ba8d7f0c6:reference/set/multiset/erase.md</id>
      <updated>2023-06-19T15:30:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/erase.md b/reference/set/multiset/erase.md
index 73871bdc7..4aed5f014 100644
--- a/reference/set/multiset/erase.md
+++ b/reference/set/multiset/erase.md
@@ -33,7 +33,7 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 ## 戻り値
 - (1), (2) :
     - C++03 まで : なし
-    - C++11 から : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す(コンテナが空になった場合や、最後尾の要素を削除した場合)。
+    - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
 - (3) : 削除された要素の数を返す。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : endが返る条件の文章がわかりにくかったので修正</title>
      <link href="https://cpprefjp.github.io/reference/set/set/erase.html"/>
      <id>ae7c515da20425de6c80b7b4336ec49ba8d7f0c6:reference/set/set/erase.md</id>
      <updated>2023-06-19T15:30:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/erase.md b/reference/set/set/erase.md
index a789cada3..1138910f9 100644
--- a/reference/set/set/erase.md
+++ b/reference/set/set/erase.md
@@ -33,7 +33,7 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 ## 戻り値
 - (1), (2) :
     - C++03 まで : なし
-    - C++11 から : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す(コンテナが空になった場合や、最後尾の要素を削除した場合)。
+    - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
 - (3) : 削除された要素の数を返す。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map/setのerase : 範囲外のイテレータや存在しないキーが指定された場合の動作が未定義であることを記載</title>
      <link href="https://cpprefjp.github.io/reference/map/map/erase.html"/>
      <id>587bd5b265057b6b9f69895cf8c98d6c37bdd483:reference/map/map/erase.md</id>
      <updated>2023-06-19T15:23:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/erase.md b/reference/map/map/erase.md
index b0105266c..df6cd4fe5 100644
--- a/reference/map/map/erase.md
+++ b/reference/map/map/erase.md
@@ -19,6 +19,10 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
+- (1) : 指定されたイテレータが指す要素を削除する
+- (2) : 指定されたキーをもつ要素を削除する
+- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+
 
 ## パラメータ
 - `position` : `map` から削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
@@ -40,7 +44,8 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 
 ## 備考
-- 削除された要素を指すイテレータ、および、参照のみ無効になる。なお、規格書に明確な記載は無いが、削除された要素を指すポインタも無効になる。
+- この関数に、範囲外のイテレータ (終端イテレータを含む) や存在しないキーを指定した場合の動作は未定義
+- 削除された要素を指すイテレータ、および、参照のみ無効になる。なお、規格書に明確な記載は無いが、削除された要素を指すポインタも無効になる
 - ループ中で `map` の要素を削除するためには、C++03 までは以下のようなコードを書く必要があった。
     ```cpp
     while (it != map_object.end()) {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map/setのerase : 範囲外のイテレータや存在しないキーが指定された場合の動作が未定義であることを記載</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/erase.html"/>
      <id>587bd5b265057b6b9f69895cf8c98d6c37bdd483:reference/map/multimap/erase.md</id>
      <updated>2023-06-19T15:23:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/erase.md b/reference/map/multimap/erase.md
index 3a5579f7f..0c19e0a46 100644
--- a/reference/map/multimap/erase.md
+++ b/reference/map/multimap/erase.md
@@ -20,6 +20,10 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
+- (1) : 指定されたイテレータが指す要素を削除する
+- (2) : 指定されたキーをもつ要素をすべて削除する
+- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+
 
 ## パラメータ
 - `position` : `multimap` から削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
@@ -41,6 +45,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 
 ## 備考
+- この関数に、範囲外のイテレータ (終端イテレータを含む) や存在しないキーを指定した場合の動作は未定義
 - 削除された要素を指すイテレータ、および、参照のみ無効になる。なお、規格書に明確な記載は無いが、削除された要素を指すポインタも無効になる。
 - ループ中で `multimap` の要素を削除するためには、C++03 までは以下のようなコードを書く必要があった。
     ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map/setのerase : 範囲外のイテレータや存在しないキーが指定された場合の動作が未定義であることを記載</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/erase.html"/>
      <id>587bd5b265057b6b9f69895cf8c98d6c37bdd483:reference/set/multiset/erase.md</id>
      <updated>2023-06-19T15:23:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/erase.md b/reference/set/multiset/erase.md
index 5d22911a4..73871bdc7 100644
--- a/reference/set/multiset/erase.md
+++ b/reference/set/multiset/erase.md
@@ -19,6 +19,10 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 単一要素またはイテレータ範囲`[first, last)`を `multiset` コンテナから削除する。 
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
+- (1) : 指定されたイテレータが指す要素を削除する
+- (2) : 指定されたキーをもつ要素をすべて削除する
+- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+
 
 ## パラメータ
 - `position` : `multiset` から削除する単一要素を指すイテレータ。`iterator`、および、`const_iterator` はメンバ型であり、双方向イテレータとして定義される。
@@ -40,6 +44,7 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 備考
+- この関数に、範囲外のイテレータ (終端イテレータを含む) や存在しないキーを指定した場合の動作は未定義
 - 削除された要素を指すイテレータ、および、参照のみ無効になる。なお、規格書に明確な記載は無いが、削除された要素を指すポインタも無効になる。
 - ループ中で `multiset` の要素を削除するためには、C++03 までは以下のようなコードを書く必要があった。
     ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map/setのerase : 範囲外のイテレータや存在しないキーが指定された場合の動作が未定義であることを記載</title>
      <link href="https://cpprefjp.github.io/reference/set/set/erase.html"/>
      <id>587bd5b265057b6b9f69895cf8c98d6c37bdd483:reference/set/set/erase.md</id>
      <updated>2023-06-19T15:23:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/erase.md b/reference/set/set/erase.md
index 7dfa75ab7..a789cada3 100644
--- a/reference/set/set/erase.md
+++ b/reference/set/set/erase.md
@@ -19,6 +19,10 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 単一要素またはイテレータ範囲`[first, last)`を `set` コンテナから削除する。 
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
+- (1) : 指定されたイテレータが指す要素を削除する
+- (2) : 指定されたキーをもつ要素を削除する
+- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+
 
 ## パラメータ
 - `position` : `set` から削除する単一要素を指すイテレータ。`iterator`、および、`const_iterator` はメンバ型であり、双方向イテレータとして定義される。
@@ -40,6 +44,7 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 備考
+- この関数に、範囲外のイテレータ (終端イテレータを含む) や存在しないキーを指定した場合の動作は未定義
 - 削除された要素を指すイテレータ、および、参照のみ無効になる。なお、規格書に明確な記載は無いが、削除された要素を指すポインタも無効になる。
 - ループ中で `set` の要素を削除するためには、C++03 までは以下のようなコードを書く必要があった。
     ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>offsetof -- offsetof : メタ情報の修正</title>
      <link href="https://cpprefjp.github.io/reference/cstddef/offsetof.html"/>
      <id>c46ebf4afd42816c9a9f10d04d668e336cfea25e:reference/cstddef/offsetof.md</id>
      <updated>2023-06-15T15:37:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstddef/offsetof.md b/reference/cstddef/offsetof.md
index 19146806b..94d3ac76d 100644
--- a/reference/cstddef/offsetof.md
+++ b/reference/cstddef/offsetof.md
@@ -1,7 +1,6 @@
 # offsetof
 * cstddef[meta header]
-* std[meta namespace]
-* type-alias[meta id-type]
+* macro[meta id-type]
 
 ```cpp
 # define offsetof(type, member) see-below
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>