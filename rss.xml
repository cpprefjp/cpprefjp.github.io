<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-25T14:42:47.938470</updated>
  <id>a898a07a-f186-4dfe-9db2-a9726d68f552</id>

  
    <entry>
      <title>execution -- execution: when_all (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>047e1191ef711f8fcd7fdea93660261e9c655747:reference/execution/execution.md</id>
      <updated>2025-05-23T22:38:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index 08afa903d..fbd7bf5d4 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -123,7 +123,7 @@ namespace std::execution {
 | [`execution::let_stopped`](execution/let_stopped.md.nolink) | 停止完了を入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::bulk`](execution/bulk.md.nolink) | インデクス空間上で指定関数を連続実行 (customization point object) | C++26 |
 | [`execution::split`](execution/split.md.nolink) | 入力Senderの値を複製送信 (customization point object) | C++26 |
-| [`execution::when_all`](execution/when_all.md.nolink) | 全ての入力Sender完了を待機 (customization point object) | C++26 |
+| [`execution::when_all`](execution/when_all.md) | 全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::when_all_with_variant`](execution/when_all_with_variant.md.nolink) | 複数の値完了シグネチャをもつ全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::into_variant`](execution/into_variant.md) | 複数の値完了シグネチャを単一[`variant`](/reference/variant/variant.md)型の値完了シグネチャに変換 (customization point object) | C++26 |
 | [`execution::stopped_as_optional`](execution/stopped_as_optional.md.nolink) | 入力Senderの停止完了を[`optional`](/reference/optional/optional.md)型の値完了に変換 (customization point object) | C++26 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>impls-for -- execution: when_all (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/impls-for.html"/>
      <id>047e1191ef711f8fcd7fdea93660261e9c655747:reference/execution/execution/impls-for.md</id>
      <updated>2025-05-23T22:38:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/impls-for.md b/reference/execution/execution/impls-for.md
index 1ef00f637..a52188719 100644
--- a/reference/execution/execution/impls-for.md
+++ b/reference/execution/execution/impls-for.md
@@ -99,7 +99,7 @@ namespace std::execution {
 - 完了タグ`Tag`と引数リスト`args`を用いて、接続先[Receiver](receiver.md)`rcvr`の完了操作を呼び出す。
     - `Tag`型は[`set_value_t`](set_value.md), [`set_error_t`](set_error.md), [`set_stopped_t`](set_stopped.md)のいずれか。
 - 第1引数`Index`は、`default-impls`実装では利用しない。
-    - 複数の子Senderを保持するSenderアルゴリズムの`impls-for`オーバーライド実装で利用する（例 : [`when_all`](when_all.md.nolink)）。
+    - 複数の子Senderを保持するSenderアルゴリズムの`impls-for`オーバーライド実装で利用する（例 : [`when_all`](when_all.md)）。
 
 ```cpp
 []&amp;lt;class Index, class Rcvr, class Tag, class... Args&amp;gt;(
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>on-stop-request -- execution: when_all (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/on-stop-request.html"/>
      <id>047e1191ef711f8fcd7fdea93660261e9c655747:reference/execution/execution/on-stop-request.md</id>
      <updated>2025-05-23T22:38:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/on-stop-request.md b/reference/execution/execution/on-stop-request.md
new file mode 100644
index 000000000..06ad7d68c
--- /dev/null
+++ b/reference/execution/execution/on-stop-request.md
@@ -0,0 +1,30 @@
+# on-stop-request
+* execution[meta header]
+* class[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+struct on-stop-request {
+  inplace_stop_source&amp;amp; stop-src;  // exposition only
+  void operator()() noexcept { stop-src.request_stop(); }
+};
+```
+* inplace_stop_source[link /reference/stop_token/inplace_stop_source.md]
+* request_stop()[link /reference/stop_token/inplace_stop_source/request_stop.md]
+
+## 概要
+`on-stop-request`は、Senderアルゴリズム動作仕様定義で用いられる説明専用のクラステンプレートである。
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 関連項目
+- [`execution::when_all`](when_all.md)
+
+
+## 参照
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>when_all -- execution: when_all (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/when_all.html"/>
      <id>047e1191ef711f8fcd7fdea93660261e9c655747:reference/execution/execution/when_all.md</id>
      <updated>2025-05-23T22:38:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/when_all.md b/reference/execution/execution/when_all.md
new file mode 100644
index 000000000..9a727719a
--- /dev/null
+++ b/reference/execution/execution/when_all.md
@@ -0,0 +1,478 @@
+# when_all
+* execution[meta header]
+* cpo[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  struct when_all_t { unspecified };
+  inline constexpr when_all_t when_all{};
+}
+```
+* unspecified[italic]
+
+## 概要
+`when_all`は、複数の入力[Sender](sender.md)が全て完了するまで待機するSenderアダプタである。
+
+- 入力Sender全てが値完了のとき、全ての値完了結果を[`tuple`](/reference/tuple/tuple.md)に結合して値完了操作を行う。
+- いずれかがエラー完了のとき、同エラー値をもってエラー完了操作を行う。このとき停止要求が作成される。
+- いずれかが停止完了のとき、停止完了操作を行う。このとき停止要求が作成される。
+
+
+## 効果
+説明用のパック`sndrs`に対してパック`Sndrs`を`decltype((sndrs))...`としたとき、型`CD`を[`common_type_t`](/reference/type_traits/common_type.md)`&amp;lt;decltype(`[`get-domain-early`](get-domain-early.md)`(sndrs))...&amp;gt;`とする。
+
+下記いずれかが`true`となるとき、呼び出し式`when_all(sndrs...)`は不適格となる。
+
+- `sizeof...(sndrs) == 0`、または
+- `(`[`sender`](sender.md)`&amp;lt;Sndrs&amp;gt; &amp;amp;&amp;amp; ...) == false`、または
+- 型`CD`が不適格
+
+そうでなければ、呼び出し式`when_all(sndrs...)`は下記と等価。
+
+```cpp
+transform_sender(CD(), make-sender(when_all, {}, sndrs...))
+```
+* transform_sender[link transform_sender.md]
+* make-sender[link make-sender.md]
+
+
+### Senderアルゴリズムタグ `when_all`
+Senderアルゴリズム動作説明用のクラステンプレート[`impls-for`](impls-for.md)に対して、下記の特殊化が定義される。
+
+```cpp
+namespace std::execution {
+  template&amp;lt;&amp;gt;
+  struct impls-for&amp;lt;when_all_t&amp;gt; : default-impls {
+    static constexpr auto get-attrs = see below;
+    static constexpr auto get-env = see below;
+    static constexpr auto get-state = see below;
+    static constexpr auto start = see below;
+    static constexpr auto complete = see below;
+  };
+}
+```
+* impls-for[link impls-for.md]
+* default-impls[link impls-for.md]
+* see below[italic]
+
+`impls-for&amp;lt;when_all_t&amp;gt;::get-attrs`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[](auto&amp;amp;&amp;amp;, auto&amp;amp;&amp;amp;... child) noexcept {
+  if constexpr (same_as&amp;lt;CD, default_domain&amp;gt;) {
+    return env&amp;lt;&amp;gt;();
+  } else {
+    return MAKE-ENV(get_domain, CD());
+  }
+}
+```
+* default_domain[link default_domain.md]
+* env&amp;lt;&amp;gt;[link env.md]
+* MAKE-ENV[link MAKE-ENV.md.nolink]
+* get_domain[link get_domain.md]
+
+`impls-for&amp;lt;when_all_t&amp;gt;::get-env`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[]&amp;lt;class State, class Rcvr&amp;gt;(auto&amp;amp;&amp;amp;, State&amp;amp; state, const Receiver&amp;amp; rcvr) noexcept {
+  return see below;
+}
+```
+* see below[italic]
+
+ラムダ式は下記を満たすオブジェクト`e`を返す。
+
+- `decltype(e)`が[`queryable`](../queryable.md)のモデル、かつ
+- 式`e.query(`[`get_stop_token`](../get_stop_token.md)`)`が`state.stop-src.get_token()`と等価、かつ
+- [`get_stop_token`](../get_stop_token.md)以外の[クエリオブジェクト](../queryable.md)`q`に対して、式`e.query(q)`は[`get_env`](get_env.md)`(rcvr).query(q)`と等価。
+
+`impls-for&amp;lt;when_all_t&amp;gt;::get-state`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[]&amp;lt;class Sndr, class Rcvr&amp;gt;(Sndr&amp;amp;&amp;amp; sndr, Rcvr&amp;amp; rcvr) noexcept(e) -&amp;gt; decltype(e) {
+  return e;
+}
+```
+
+ラムダ式が返す式`e`は下記の通り。
+
+```cpp
+std::forward&amp;lt;Sndr&amp;gt;(sndr).apply(make-state&amp;lt;Rcvr&amp;gt;())
+```
+* apply[link product-type.md]
+
+`impls-for&amp;lt;when_all_t&amp;gt;::start`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[]&amp;lt;class State, class Rcvr, class... Ops&amp;gt;(
+    State&amp;amp; state, Rcvr&amp;amp; rcvr, Ops&amp;amp;... ops) noexcept -&amp;gt; void {
+  state.on_stop.emplace(
+    get_stop_token(get_env(rcvr)),
+    on-stop-request{state.stop_src});
+  if (state.stop_src.stop_requested()) {
+    state.on_stop.reset();
+    set_stopped(std::move(rcvr));
+  } else {
+    (start(ops), ...);
+  }
+}
+```
+* get_stop_token[link ../get_stop_token.md]
+* get_env[link get_env.md]
+* on-stop-request[link on-stop-request.md]
+* set_stopped[link set_stopped.md]
+* start[link start.md]
+* emplace[link /reference/optional/optional/emplace.md]
+* reset()[link /reference/optional/optional/reset.md]
+* stop_requested()[link /reference/stop_token/inplace_stop_token/stop_requested.md]
+* std::move[link /reference/utility/move.md]
+
+`impls-for&amp;lt;when_all_t&amp;gt;::complete`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[]&amp;lt;class Index, class State, class Rcvr, class Set, class... Args&amp;gt;(
+    this auto&amp;amp; complete, Index, State&amp;amp; state, Rcvr&amp;amp; rcvr, Set, Args&amp;amp;&amp;amp;... args) noexcept -&amp;gt; void {
+  if constexpr (same_as&amp;lt;Set, set_error_t&amp;gt;) {
+    if (disposition::error != state.disp.exchange(disposition::error)) {
+      state.stop_src.request_stop();
+      TRY-EMPLACE-ERROR(state.errors, std::forward&amp;lt;Args&amp;gt;(args)...);
+    }
+  } else if constexpr (same_as&amp;lt;Set, set_stopped_t&amp;gt;) {
+    auto expected = disposition::started;
+    if (state.disp.compare_exchange_strong(expected, disposition::stopped)) {
+      state.stop_src.request_stop();
+    }
+  } else if constexpr (!same_as&amp;lt;decltype(State::values), tuple&amp;lt;&amp;gt;&amp;gt;) {
+    if (state.disp == disposition::started) {
+      auto&amp;amp; opt = get&amp;lt;Index::value&amp;gt;(state.values);
+      TRY-EMPLACE-VALUE(complete, opt, std::forward&amp;lt;Args&amp;gt;(args)...);
+    }
+  }
+  state.arrive(rcvr);
+}
+```
+* set_error_t[link set_error.md]
+* set_stopped_t[link set_stopped.md]
+* tuple&amp;lt;&amp;gt;[link /reference/tuple/tuple.md]
+* get[link /reference/tuple/tuple/get.md]
+* exchange[link /reference/atomic/atomic/exchange.md]
+* compare_exchange_strong[link /reference/atomic/atomic/compare_exchange_strong.md]
+* request_stop()[link /reference/stop_token/inplace_stop_source/request_stop.md]
+
+説明用の式`v`, `e`に対して、式`decltype(auto(e))(e)`が潜在的に例外送出するならば、`TRY-EMPLACE-ERROR(v, e)`を下記と等価な式とする。
+そうでなければ、`v.`[`template emplace`](/reference/variant/variant/emplace.md)`&amp;lt;decltype(auto(e))&amp;gt;(e)`とする。
+
+```cpp
+try {
+  v.template emplace&amp;lt;decltype(auto(e))&amp;gt;(e);
+} catch (...) {
+  v.template emplace&amp;lt;exception_ptr&amp;gt;(current_exception());
+}
+```
+* template emplace[link /reference/variant/variant/emplace.md]
+* exception_ptr[link /reference/exception/exception_ptr.md]
+* current_exception()[link /reference/exception/current_exception.md]
+
+説明用の式`c`, `o`およびパック`as`に対して、式[`decayed-tuple`](decayed-tuple.md)`&amp;lt;decltype(as)...&amp;gt;{as...}`が潜在的に例外送出するならば、`TRY-EMPLACE-VALUE(c, o, as...)`を下記と等価な式とする。
+そうでなければ、`o.`[`emplace`](/reference/optional/optional/emplace.md)`(as...)`とする。
+
+```cpp
+try {
+  o.emplace(as...);
+} catch (...) {
+  c(Index(), state, rcvr, set_error, current_exception());
+  return;
+}
+```
+* set_error[link set_error.md]
+* emplace[link /reference/optional/optional/emplace.md]
+* current_exception()[link /reference/exception/current_exception.md]
+
+
+## 説明専用エンティティ
+説明専用のコンセプト`max-1-sender-in`, 列挙型`disposition`, クラス`make-state`は、それぞれ下記の通り定義される。
+
+```cpp
+template&amp;lt;class Sndr, class Env&amp;gt;
+concept max-1-sender-in = sender_in&amp;lt;Sndr, Env&amp;gt; &amp;amp;&amp;amp;  // exposition only
+  (tuple_size_v&amp;lt;value_types_of_t&amp;lt;Sndr, Env, tuple, tuple&amp;gt;&amp;gt; &amp;lt;= 1);
+```
+* sender_in[link sender_in.md]
+* value_types_of_t[link value_types_of_t.md]
+* tuple_size_v[link /reference/tuple/tuple_size.md]
+* tuple[link /reference/tuple/tuple.md]
+
+```cpp
+enum class disposition { started, error, stopped };  // exposition only
+```
+
+```cpp
+template&amp;lt;class Rcvr&amp;gt;
+struct make-state {
+  template&amp;lt;max-1-sender-in&amp;lt;env_of_t&amp;lt;Rcvr&amp;gt;&amp;gt;... Sndrs&amp;gt;
+  auto operator()(auto, auto, Sndrs&amp;amp;&amp;amp;... sndrs) const {
+    using values_tuple = see below;
+    using errors_variant = see below;
+    using stop_callback = stop_callback_for_t&amp;lt;stop_token_of_t&amp;lt;env_of_t&amp;lt;Rcvr&amp;gt;&amp;gt;, on-stop-request&amp;gt;;
+
+    struct state-type {
+      void arrive(Rcvr&amp;amp; rcvr) noexcept {               // exposition only
+        if (0 == --count) {
+          complete(rcvr);
+        }
+      }
+
+      void complete(Rcvr&amp;amp; rcvr) noexcept;              // exposition only
+
+      atomic&amp;lt;size_t&amp;gt; count{sizeof...(sndrs)};          // exposition only
+      inplace_stop_source stop_src{};                  // exposition only
+      atomic&amp;lt;disposition&amp;gt; disp{disposition::started};  // exposition only
+      errors_variant errors{};                         // exposition only
+      values_tuple values{};                           // exposition only
+      optional&amp;lt;stop_callback&amp;gt; on_stop{nullopt};        // exposition only
+    };
+
+    return state-type{};
+  }
+};
+```
+* env_of_t[link env_of_t.md]
+* stop_token_of_t[link ../stop_token_of_t.md]
+* on-stop-request[link on-stop-request.md]
+* atomic[link /reference/atomic/atomic.md]
+* stop_callback_for_t[link /reference/stop_token/stop_callback_for_t.md]
+* inplace_stop_source[link /reference/stop_token/inplace_stop_source.md]
+* stop_callback[link /reference/stop_token/stop_token.md]
+* optional[link /reference/optional/optional.md]
+* nullopt[link /reference/optional/nullopt_t.md]
+* see below[italic]
+
+説明用の型`copy-fail`を、いずれかの子[Sender](sender.md)の値結果データのdecayコピーが潜在的に例外送出するならば[`exception_ptr`](/reference/exception/exception_ptr.md)とする。そうでなければ、未規定の空のクラス型`none-such`とする。
+
+型`values_tuple`は、適格であるならば下記の型とする。そうでなければ、[`tuple&amp;lt;&amp;gt;`](/reference/tuple/tuple.md)とする。
+
+```cpp
+tuple&amp;lt;value_types_of_t&amp;lt;Sndrs, env_of_t&amp;lt;Rcvr&amp;gt;, decayed-tuple, optional&amp;gt;...&amp;gt;
+```
+* value_types_of_t[link value_types_of_t.md]
+* env_of_t[link env_of_t.md]
+* decayed-tuple[link decayed-tuple.md]
+* tuple[link /reference/tuple/tuple.md]
+* optional[link /reference/optional/optional.md]
+
+説明用のパック`Es`を全ての子[Sender](sender.md)のエラー結果データの[decayed](/reference/type_traits/decay.md)型としたとき、型`errors_variant`は下記定義において重複削除した型となる。
+
+```cpp
+variant&amp;lt;none-such, copy-fail, Es...&amp;gt;
+```
+* variant[link /reference/variant/variant.md]
+
+メンバ関数`void state-type::complete(Rcvr&amp;amp; rcvr) noexcept`の動作は下記の通り。
+
+- `disp == disposition::started`のとき、下記を評価する。
+
+    ```cpp
+    auto tie = []&amp;lt;class... T&amp;gt;(tuple&amp;lt;T...&amp;gt;&amp;amp; t) noexcept { return tuple&amp;lt;T&amp;amp;...&amp;gt;(t); };
+    auto set = [&amp;amp;](auto&amp;amp;... t) noexcept { set_value(std::move(rcvr), std::move(t)...); };
+
+    on_stop.reset();
+    apply(
+      [&amp;amp;](auto&amp;amp;... opts) noexcept {
+        apply(set, tuple_cat(tie(*opts)...));
+      },
+      values);
+    ```
+    * set_value[link set_value.md]
+    * tuple[link /reference/tuple/tuple.md]
+    * apply[link /reference/tuple/apply.md]
+    * tuple_cat[link /reference/tuple/tuple_cat.md]
+    * reset()[link /reference/optional/optional/reset.md]
+    * std::move[link /reference/utility/move.md]
+
+- そうではなく、`disp == disposition::error`のとき、下記を評価する。
+
+    ```cpp
+    on_stop.reset();
+    visit(
+      [&amp;amp;]&amp;lt;class Error&amp;gt;(Error&amp;amp; error) noexcept {
+        if constexpr (!same_as&amp;lt;Error, none-such&amp;gt;) {
+          set_error(std::move(rcvr), std::move(error));
+        }
+      },
+      errors);
+    ```
+    * set_error[link set_error.md]
+    * reset()[link /reference/optional/optional/reset.md]
+    * visit[link /reference/variant/visit.md]
+    * std::move[link /reference/utility/move.md]
+
+- それ以外のとき、下記を評価する。
+
+    ```cpp
+    on_stop.reset();
+    set_stopped(std::move(rcvr));
+    ```
+    * set_stopped[link set_stopped.md]
+    * reset()[link /reference/optional/optional/reset.md]
+
+
+## カスタマイゼーションポイント
+Senderアルゴリズム構築時および[Receiver](receiver.md)接続時に、関連付けられた実行ドメインに対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](../execution/default_domain.md)では無変換。
+
+
+## 例
+### 例1: 基本の使い方
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+using namespace std::string_literals;
+
+int main()
+{
+  // string型の値を送信するSender
+  ex::sender auto snd1 = ex::just(&amp;#34;C++&amp;#34;s);
+  // (int,char)型の値を送信するSender
+  ex::sender auto snd2 = ex::just(123, &amp;#39;X&amp;#39;);
+  // snd1,snd2両方の完了を待機するSender
+  ex::sender auto sndr = ex::when_all(snd1, snd2);
+
+　auto result = std::this_thread::sync_wait(sndr);
+  // result := optional&amp;lt;tuple&amp;lt;string,int,char&amp;gt;&amp;gt;型
+  std::println(&amp;#34;result={}&amp;#34;, result.value());
+}
+```
+* ex::when_all[color ff0000]
+* ex::sender[link sender.md]
+* ex::just[link just.md]
+* std::this_thread::sync_wait[link ../this_thread/sync_wait.md]
+* value()[link /reference/optional/optional/value.md]
+
+#### 出力
+```
+result=(&amp;#34;C++&amp;#34;, 123, &amp;#39;X&amp;#39;)
+```
+
+### 例2: 停止要求のハンドリング
+```cpp
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+
+// MySenderは下記いずれかの完了操作を行う
+//   値完了     set_value(string)
+//   エラー完了 set_error(int)
+//   停止完了   set_stopped()
+struct MySender {
+  using sender_concept = ex::sender_t;
+  using completion_signatures = ex::completion_signatures&amp;lt;
+    ex::set_value_t(std::string),
+    ex::set_error_t(int),
+    ex::set_stopped_t()
+  &amp;gt;;
+
+  template &amp;lt;typename Rcvr&amp;gt;
+  struct state {
+    using operation_state_concept = ex::operation_state_t;
+
+    state(Rcvr rcvr, int val)
+      : rcvr_{std::move(rcvr)}, val_{val} {}
+
+    void start() noexcept {
+      auto stok = ex::get_stop_token(ex::get_env(rcvr_));
+      if (stok.stop_requested()) {
+   　　  // 接続先Receiverにおいて停止要求が行われていれば
+        // MySenderも停止完了により早期リターンする
+        std::println(&amp;#34;{}: set_stopped&amp;#34;, val_);
+        ex::set_stopped(std::move(rcvr_));
+        return;
+      }
+      // MySenderの本体処理
+      if (0 &amp;lt;= val_) {
+        // 成功: 値完了操作
+        using namespace std::string_literals;
+        std::println(&amp;#34;{}: set_value&amp;#34;, val_);
+        ex::set_value(std::move(rcvr_), &amp;#34;Hello&amp;#34;s);
+      } else {
+        // 失敗: エラー完了操作
+        std::println(&amp;#34;{}: set_error&amp;#34;, val_);
+        ex::set_error(std::move(rcvr_), val_);
+      }
+    }
+
+    Rcvr rcvr_;
+    int val_;
+  };
+
+  template &amp;lt;typename Rcvr&amp;gt;
+  auto connect(Rcvr rcvr) noexcept {
+    return state{std::move(rcvr), val_};
+  }
+
+  int val_;
+};
+
+int main()
+{
+  ex::sender auto snd1 = MySender{1};  // 値完了
+  ex::sender auto snd2 = MySender{-2}; // エラー完了 → 停止要求
+  ex::sender auto snd3 = MySender{3};  // 停止完了
+  ex::sender auto sndr = ex::when_all(snd1, snd2, snd3);
+  try {
+    auto result = std::this_thread::sync_wait(sndr);
+    // result := optional&amp;lt;tuple&amp;lt;string,string,string&amp;gt;&amp;gt;型
+    std::println(&amp;#34;value={}&amp;#34;, *result);
+  } catch (int err) {
+    std::println(&amp;#34;error={}&amp;#34;, err);
+  }
+}
+```
+* ex::when_all[color ff0000]
+* ex::sender_t[link sender.md]
+* ex::sender[link sender.md]
+* ex::completion_signatures[link completion_signatures.md]
+* ex::set_value_t[link set_value.md]
+* ex::set_value[link set_value.md]
+* ex::set_error_t[link set_error.md]
+* ex::set_error[link set_error.md]
+* ex::set_stopped_t[link set_stopped.md]
+* ex::set_stopped[link set_stopped.md]
+* ex::operation_state_t[link operation_state.md]
+* ex::get_stop_token[link ../get_stop_token.md]
+* ex::get_env[link get_env.md]
+* std::this_thread::sync_wait[link ../this_thread/sync_wait.md]
+* stop_requested()[link /reference/stop_token/inplace_stop_token/stop_requested.md]
+* std::move[link /reference/utility/move.md]
+
+#### 出力
+```
+1: set_value
+-2: set_error
+3: set_stopped
+error=-2
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution::when_all_with_variant`](when_all_with_variant.md.nolink)
+
+
+## 参照
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>projected_value_t -- 不可視文字を削除</title>
      <link href="https://cpprefjp.github.io/reference/iterator/projected_value_t.html"/>
      <id>047c55b383de775f4a241e99d3fcc9faa0720b0f:reference/iterator/projected_value_t.md</id>
      <updated>2025-05-23T16:25:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/projected_value_t.md b/reference/iterator/projected_value_t.md
index 3c9315a02..241752afb 100644
--- a/reference/iterator/projected_value_t.md
+++ b/reference/iterator/projected_value_t.md
@@ -6,13 +6,13 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;indirectly_­readable I,
-            indirectly_­regular_­unary_­invocable&amp;lt;I&amp;gt; Proj&amp;gt;
+  template &amp;lt;indirectly_readable I,
+            indirectly_regular_unary_invocable&amp;lt;I&amp;gt; Proj&amp;gt;
   using projected_value_t = remove_cvref_t&amp;lt;invoke_result_t&amp;lt;Proj&amp;amp;, iter_value_t&amp;lt;I&amp;gt;&amp;amp;&amp;gt;&amp;gt;;
 }
 ```
 * indirectly_readable[link /reference/iterator/indirectly_readable.md]
-* indirectly_­regular_­unary_­invocable[link /reference/iterator/indirectly_­regular_­unary_­invocable.md.nolink]
+* indirectly_regular_unary_invocable[link /reference/iterator/indirectly_regular_unary_invocable.md.nolink]
 
 ## 概要
 イテレータ型`I`が指す値型を取得する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- algorithm/find : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find.html"/>
      <id>0f3ab3ae9af4e61b5f15be6aed0792f6337ef2b4:reference/algorithm/find.md</id>
      <updated>2025-05-23T16:13:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find.md b/reference/algorithm/find.md
index 958f3f53a..41aecc838 100644
--- a/reference/algorithm/find.md
+++ b/reference/algorithm/find.md
@@ -5,21 +5,41 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class InputIterator, class T&amp;gt;
-  InputIterator find(InputIterator first,
-                     InputIterator last,
-                     const T&amp;amp; value);               // (1) C++03
-
-  template &amp;lt;class InputIterator, class T&amp;gt;
-  constexpr InputIterator find(InputIterator first,
-                               InputIterator last,
-                               const T&amp;amp; value);     // (1) C++20
-
-  template&amp;lt;class ExecutionPolicy, class ForwardIterator, class T&amp;gt;
-  ForwardIterator find(ExecutionPolicy&amp;amp;&amp;amp; exec,
-                       ForwardIterator first,
-                       ForwardIterator last,
-                       const T&amp;amp; value);             // (2) C++17
+  template &amp;lt;class InputIterator,
+            class T&amp;gt;
+  InputIterator
+    find(InputIterator first,
+         InputIterator last,
+         const T&amp;amp; value);     // (1) C++03
+  template &amp;lt;class InputIterator,
+            class T&amp;gt;
+  constexpr InputIterator
+    find(InputIterator first,
+         InputIterator last,
+         const T&amp;amp; value);     // (1) C++20
+  template &amp;lt;class InputIterator,
+            class T = typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type&amp;gt;
+  constexpr InputIterator
+    find(InputIterator first,
+         InputIterator last,
+         const T&amp;amp; value);     // (1) C++26
+
+  template&amp;lt;class ExecutionPolicy,
+           class ForwardIterator,
+           class T&amp;gt;
+  ForwardIterator
+    find(ExecutionPolicy&amp;amp;&amp;amp; exec,
+         ForwardIterator first,
+         ForwardIterator last,
+         const T&amp;amp; value);   // (2) C++17
+  template&amp;lt;class ExecutionPolicy,
+           class ForwardIterator,
+           class T = typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type&amp;gt;
+  ForwardIterator
+    find(ExecutionPolicy&amp;amp;&amp;amp; exec,
+         ForwardIterator first,
+         ForwardIterator last,
+         const T&amp;amp; value);   // (2) C++26
 }
 ```
 
@@ -35,7 +55,16 @@ namespace std {
 最大で `last - first` 回比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+		std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::find(v.begin(), v.begin(), {a, b});
+        ```
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -53,11 +82,46 @@ int main() {
 ```
 * std::find[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+	{1, 2},
+	{3, 4},
+	{5, 6}
+  };
+
+  auto it = std::find(v.begin(), v.end(), {3, 4});
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;y &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::find[color ff0000]
+
+#### 出力
+```
+found: 3,4
+```
+
 
 ## 実装例
 ```cpp
@@ -73,3 +137,5 @@ InputIterator find(InputIterator first, InputIterator last, const T&amp;amp; value) {
 ## 参照
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
 - [P0467R2 Iterator Concerns for Parallel Algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0467r2.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- algorithm/find : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>0f3ab3ae9af4e61b5f15be6aed0792f6337ef2b4:reference/algorithm/ranges_find.md</id>
      <updated>2025-05-23T16:13:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 9e404321c..bfb96b38a 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -16,6 +16,16 @@ namespace std::ranges {
          S last,
          const T&amp;amp; value,
          Proj proj = {}); // (1) C++20
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr I
+    find(I first,
+         S last,
+         const T&amp;amp; value,
+         Proj proj = {}); // (1) C++26
 
   template &amp;lt;input_range R,
             class T,
@@ -25,6 +35,14 @@ namespace std::ranges {
     find(R&amp;amp;&amp;amp; r,
          const T&amp;amp; value,
          Proj proj = {}); // (2) C++20
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    find(R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value,
+         Proj proj = {}); // (2) C++26
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -51,7 +69,17 @@ namespace std::ranges {
 最大で `last - first` 回比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+		    std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::ranges::find(r, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -69,11 +97,46 @@ int main() {
 ```
 * std::ranges::find[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+	{1, 2},
+	{3, 4},
+	{5, 6}
+  };
+
+  auto it = std::ranges::find(v, {3, 4});
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;y &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find[color ff0000]
+
+#### 出力
+```
+found: 3,4
+```
+
 
 ## 実装例
 ```cpp
@@ -120,3 +183,5 @@ inline constexpr find_impl find;
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iterator -- algorithm/find : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/iterator.html"/>
      <id>0f3ab3ae9af4e61b5f15be6aed0792f6337ef2b4:reference/iterator.md</id>
      <updated>2025-05-23T16:13:32+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;iterator&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;ヘッダでは、イテレータに関する機能群を提供する。
イテレータは日本語では反復子とも呼ばれ、配列やコンテナのような範囲を横断する手段として使用できる。&lt;/p&gt;
&lt;p&gt;C++標準ライブラリのイテレータは、以下のように階層的に定義される。
この階層はC++言語機能の継承と同じように見なせる。たとえば、入力イテレータと前方向イテレータはis a関係が成り立っており、前方向イテレータは入力イテレータと見なすことができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;../static/image/reference/iterator/iterators.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;C++20以降の標準ライブラリでは、任意のイテレータに対して可能な操作によって上記5つに隣接イテレータ（&lt;em&gt;contiguous iterator&lt;/em&gt;）を加えた6つのイテレータカテゴリを定義する。それぞれ次のイテレータコンセプトが対応する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入力イテレータ : &lt;code&gt;&lt;a href=&#34;iterator/input_iterator.html&#34;&gt;input_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;出力イテレータ : &lt;code&gt;&lt;a href=&#34;iterator/output_iterator.html&#34;&gt;output_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;前方向イテレータ : &lt;code&gt;&lt;a href=&#34;iterator/forward_iterator.html&#34;&gt;forward_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;双方向イテレータ : &lt;code&gt;&lt;a href=&#34;iterator/bidirectional_iterator.html&#34;&gt;bidirectional_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ランダムアクセスイテレータ : &lt;code&gt;&lt;a href=&#34;iterator/random_access_iterator.html&#34;&gt;random_access_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;隣接イテレータ : &lt;code&gt;&lt;a href=&#34;iterator/contiguous_iterator.html&#34;&gt;contiguous_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このヘッダでは、以下の標準ヘッダをインクルードする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;concepts.html&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/a&gt;&lt;/code&gt; (C++20)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt; (C++20)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;イテレータコンセプト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_readable.html&#34;&gt;indirectly_readable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;間接参照によって読み取り可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_writable.html&#34;&gt;indirectly_writable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;間接参照によって書き込み可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/weakly_incrementable.html&#34;&gt;weakly_incrementable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前置/後置インクリメント可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/incrementable.html&#34;&gt;incrementable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;weakly_incrementable&lt;/code&gt;かつ&lt;a href=&#34;concepts/regular.html&#34;&gt;正則&lt;/a&gt; (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/input_or_output_iterator.html&#34;&gt;input_or_output_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基礎的なイテレータコンセプト (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/sentinel_for.html&#34;&gt;sentinel_for&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同じ範囲についてのイテレータと番兵 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/sized_sentinel_for.html&#34;&gt;sized_sentinel_for&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;距離を定義可能なイテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/disable_sized_sentinel_for.html&#34;&gt;disable_sized_sentinel_for&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sentinel_for&amp;lt;S, I&amp;gt;&lt;/code&gt;について、&lt;code&gt;sized_sentinel_for&lt;/code&gt;を不適合にする (variable template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/input_iterator.html&#34;&gt;input_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/output_iterator.html&#34;&gt;output_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/forward_iterator.html&#34;&gt;forward_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前方向イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/bidirectional_iterator.html&#34;&gt;bidirectional_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双方向イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/random_access_iterator.html&#34;&gt;random_access_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/contiguous_iterator.html&#34;&gt;contiguous_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;隣接イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;イテレータを介した関数呼び出しに関するコンセプト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_unary_invocable.html&#34;&gt;indirectly_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの要素型によって呼び出し可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_unary_invocable.html&#34;&gt;indirectly_regular_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正則な&lt;code&gt;indirectly_unary_invocable&lt;/code&gt; (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirect_unary_predicate.html&#34;&gt;indirect_unary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの要素型についての単項述語 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirect_binary_predicate.html&#34;&gt;indirect_binary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータの要素型についての二項述語 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirect_equivalence_relation.html&#34;&gt;indirect_equivalence_relation&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータの要素型についての同値関係 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirect_strict_weak_order.html&#34;&gt;indirect_strict_weak_order&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータの要素型についての狭義の弱順序 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;イテレータによるアルゴリズムに関するコンセプト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_movable.html&#34;&gt;indirectly_movable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;片方のイテレータからもう片方のイテレータへ要素をムーブ可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_movable_storable.html&#34;&gt;indirectly_movable_storable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;片方のイテレータからもう片方のイテレータへ中間オブジェクトを介して要素をムーブ可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_copyable.html&#34;&gt;indirectly_copyable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;片方のイテレータからもう片方のイテレータへ要素をコピー可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_copyable_storable.html&#34;&gt;indirectly_copyable_storable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;片方のイテレータからもう片方のイテレータへ中間オブジェクトを介して要素をコピー可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_swappable.html&#34;&gt;indirectly_swappable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータ間で要素を交換可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_comparable.html&#34;&gt;indirectly_comparable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータ間で要素を比較可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/permutable.html&#34;&gt;permutable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを介して要素を並べ替え可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/mergeable.html&#34;&gt;mergeable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを介して範囲をマージ可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/sortable.html&#34;&gt;sortable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを介して範囲をソート可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;イテレータの情報&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iterator_traits.html&#34;&gt;iterator_traits&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータに関する型情報(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iterator.html&#34;&gt;iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを定義するための基底クラス(class template)&lt;/td&gt;
&lt;td&gt;C++17から非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iter_difference_t.html&#34;&gt;iter_difference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの&lt;code&gt;difference_type&lt;/code&gt;を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iter_value_t.html&#34;&gt;iter_value_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの&lt;code&gt;value_type&lt;/code&gt;を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iter_reference_t.html&#34;&gt;iter_reference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの&lt;code&gt;reference_type&lt;/code&gt;を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iter_rvalue_reference_t.html&#34;&gt;iter_rvalue_reference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの指す要素の右辺値参照型を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iter_common_reference_t.html&#34;&gt;iter_common_reference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの&lt;code&gt;value_type&lt;/code&gt;と&lt;code&gt;reference_type&lt;/code&gt;の&lt;code&gt;&lt;a href=&#34;type_traits/common_reference.html&#34;&gt;common_reference&lt;/a&gt;&lt;/code&gt;を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iter_const_reference_t.html&#34;&gt;iter_const_reference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの参照型（&lt;code&gt;iter_reference_t&lt;/code&gt;）を&lt;code&gt;const&lt;/code&gt;化したものを取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirect_result_t.html&#34;&gt;indirect_result_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数呼び出し可能な型&lt;code&gt;F&lt;/code&gt;を複数のイテレータ&lt;code&gt;Is...&lt;/code&gt;によって呼び出した時の戻り値型を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/projected.html&#34;&gt;projected&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータ&lt;code&gt;I&lt;/code&gt;の&lt;code&gt;Proj&lt;/code&gt;による射影操作の結果を表すことのできる&lt;code&gt;&lt;a href=&#34;iterator/indirectly_readable.html&#34;&gt;indirectly_readable&lt;/a&gt;&lt;/code&gt;なクラス (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/projected_value_t.html&#34;&gt;projected_value_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イイテレータ&lt;code&gt;I&lt;/code&gt;の&lt;code&gt;Proj&lt;/code&gt;による射影操作の結果となる値型を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/incrementable_traits.html&#34;&gt;incrementable_traits&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;iter_difference_t&lt;/code&gt;にアダプトするためのカスタマイゼーションポイント (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/indirectly_readable_traits.html&#34;&gt;indirectly_readable_traits&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;iter_value_t&lt;/code&gt;にアダプトするためのカスタマイゼーションポイント (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iterator_tag.html&#34;&gt;input_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iterator_tag.html&#34;&gt;output_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iterator_tag.html&#34;&gt;forward_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前方向イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iterator_tag.html&#34;&gt;bidirectional_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双方向イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iterator_tag.html&#34;&gt;random_access_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iterator_tag.html&#34;&gt;contiguous_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;隣接イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;イテレータの進行と距離&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/advance.html&#34;&gt;advance&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;回イテレータを進める(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/distance.html&#34;&gt;distance&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータ間の距離を求める(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/next.html&#34;&gt;next&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;回前方に進めたイテレータを返す(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/prev.html&#34;&gt;prev&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;回後方に進めたイテレータを返す(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/ranges_advance.html&#34;&gt;ranges::advance&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを進める(function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/ranges_distance.html&#34;&gt;ranges::distance&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の長さを求める(function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/ranges_next.html&#34;&gt;ranges::next&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前方に進めたイテレータを返す(function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/ranges_prev.html&#34;&gt;ranges::prev&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;後方に進めたイテレータを返す(function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;逆順イテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/reverse_iterator.html&#34;&gt;reverse_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逆方向に進むイテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/make_reverse_iterator.html&#34;&gt;make_reverse_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;reverse_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;挿入イテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/back_insert_iterator.html&#34;&gt;back_insert_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;末尾に要素を挿入する出力イテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/back_inserter.html&#34;&gt;back_inserter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;back_insert_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/front_insert_iterator.html&#34;&gt;front_insert_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;先頭に要素を挿入する出力イテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/front_inserter.html&#34;&gt;front_inserter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;front_insert_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/insert_iterator.html&#34;&gt;insert_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意の位置に要素を挿入する出力イテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/inserter.html&#34;&gt;inserter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;insert_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;要素を移動するイテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/move_iterator.html&#34;&gt;move_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;間接参照時にムーブするイテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/make_move_iterator.html&#34;&gt;make_move_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;move_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/move_sentinel.html&#34;&gt;move_sentinel&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;move_iterator&lt;/code&gt;の終端を表す番兵型(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ストリームイテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/istream_iterator.html&#34;&gt;istream_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力ストリームイテレータ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/ostream_iterator.html&#34;&gt;ostream_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力ストリームイテレータ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/istreambuf_iterator.html&#34;&gt;istreambuf_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力ストリームバッファイテレータ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/ostreambuf_iterator.html&#34;&gt;ostreambuf_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力ストリームバッファイテレータ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定数イテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/basic_const_iterator.html&#34;&gt;basic_const_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの要素を&lt;code&gt;const&lt;/code&gt;化するラッパーイテレータ(class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/const_iterator.html&#34;&gt;const_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素が&lt;code&gt;const&lt;/code&gt;化されたイテレータ型を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/const_sentinel.html&#34;&gt;const_sentinel&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素が&lt;code&gt;const&lt;/code&gt;化された番兵型を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/make_const_iterator.html&#34;&gt;make_const_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;const_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/make_const_sentinel.html&#34;&gt;make_const_sentinel&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;const_sentinel&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;その他のイテレータアダプタ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/common_iterator.html&#34;&gt;common_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータ型と番兵型が異なる場合に型を共通化するためのラッパーイテレータ(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/counted_iterator.html&#34;&gt;counted_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;予め指定された&lt;code&gt;N&lt;/code&gt;個の要素だけをイテレートするラッパーイテレータ(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;番兵型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/default_sentinel_t.html&#34;&gt;default_sentinel_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意の範囲の終端を表すことのできるデフォルトの番兵型(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/default_sentinel_t.html&#34;&gt;default_sentinel&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意の範囲の終端を表すことのできるデフォルトの番兵オブジェクト(constant variable)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/unreachable_sentinel_t.html&#34;&gt;unreachable_sentinel_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;別の方法で終端が指定される範囲の仮想的な終端を表す番兵型(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/unreachable_sentinel_t.html&#34;&gt;unreachable_sentinel&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;別の方法で終端が指定される範囲の仮想的な終端を表す番兵オブジェクト(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;先頭イテレータと末尾イテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/begin.html&#34;&gt;begin&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の先頭を指すイテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/end.html&#34;&gt;end&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の末尾の次を指すイテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/cbegin.html&#34;&gt;cbegin&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の先頭を指す読み取り専用イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/cend.html&#34;&gt;cend&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の末尾の次を指す読み取り専用イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/rbegin.html&#34;&gt;rbegin&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の末尾を指す逆イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/rend.html&#34;&gt;rend&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の先頭の前を指す逆イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/crbegin.html&#34;&gt;crbegin&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の末尾を指す読み取り専用逆イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/crend.html&#34;&gt;crend&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の先頭の前を指す読み取り専用逆イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;コンテナアクセス&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/size.html&#34;&gt;size&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンテナの要素数を取得する (function)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/ssize.html&#34;&gt;ssize&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンテナの要素数を、符号付き整数型で取得する (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/empty.html&#34;&gt;empty&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンテナが空かどうかを判定する (function)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/data.html&#34;&gt;data&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンテナの要素配列へのポインタを取得する (function)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;カスタマイゼーションポイントオブジェクト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iter_move.html&#34;&gt;ranges::iter_move&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの指す要素をムーブする (customization point object)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;iterator/iter_swap.html&#34;&gt;ranges::iter_swap&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータの指す要素を&lt;em&gt;swap&lt;/em&gt;する (customization point object)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf&#34; target=&#34;_blank&#34;&gt;P0896R4 The One Ranges Proposal (was Merging the Ranges TS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2051r0.html&#34; target=&#34;_blank&#34;&gt;P2051R0 C++ Standard Library Issues to be moved in Prague&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2278r4.html&#34; target=&#34;_blank&#34;&gt;P2278R4 &lt;code&gt;cbegin&lt;/code&gt; should always return a constant iterator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>projected -- algorithm/find : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/iterator/projected.html"/>
      <id>0f3ab3ae9af4e61b5f15be6aed0792f6337ef2b4:reference/iterator/projected.md</id>
      <updated>2025-05-23T16:13:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/projected.md b/reference/iterator/projected.md
index 9e769a725..cf694bbc7 100644
--- a/reference/iterator/projected.md
+++ b/reference/iterator/projected.md
@@ -87,6 +87,7 @@ int main() {
 
 ## 関連項目
 
+- [`projected_value_t`](projected_value_t.md)
 - [`indirectly_comparable`](indirectly_comparable.md)
 - [`mergeable`](mergeable.md)
 - [`sortable`](sortable.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>projected_value_t -- algorithm/find : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/iterator/projected_value_t.html"/>
      <id>0f3ab3ae9af4e61b5f15be6aed0792f6337ef2b4:reference/iterator/projected_value_t.md</id>
      <updated>2025-05-23T16:13:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/projected_value_t.md b/reference/iterator/projected_value_t.md
new file mode 100644
index 000000000..3c9315a02
--- /dev/null
+++ b/reference/iterator/projected_value_t.md
@@ -0,0 +1,81 @@
+# projected_value_t
+* iterator[meta header]
+* std[meta namespace]
+* type-alias[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;indirectly_­readable I,
+            indirectly_­regular_­unary_­invocable&amp;lt;I&amp;gt; Proj&amp;gt;
+  using projected_value_t = remove_cvref_t&amp;lt;invoke_result_t&amp;lt;Proj&amp;amp;, iter_value_t&amp;lt;I&amp;gt;&amp;amp;&amp;gt;&amp;gt;;
+}
+```
+* indirectly_readable[link /reference/iterator/indirectly_readable.md]
+* indirectly_­regular_­unary_­invocable[link /reference/iterator/indirectly_­regular_­unary_­invocable.md.nolink]
+
+## 概要
+イテレータ型`I`が指す値型を取得する。
+
+この型は、間接参照可能な型`I`に任意の射影操作`Proj`を適用した結果となる値型を返す。
+
+
+## 例
+```cpp example
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {  
+  using vec_iterator = std::vector&amp;lt;int&amp;gt;::iterator;
+  using pointer = double*;
+
+  static_assert(std::same_as&amp;lt;
+    std::projected_value_t&amp;lt;vec_iterator, std::identity&amp;gt;,
+    int
+  &amp;gt;);
+
+  static_assert(std::same_as&amp;lt;
+    std::projected_value_t&amp;lt;pointer, std::identity&amp;gt;,
+    double
+  &amp;gt;);
+}
+```
+* std::projected_value_t[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): 21 [mark verified]
+- [GCC](/implementation.md#gcc): 15.1 [mark verified]
+- [Visual C++](/implementation.md#visual_cpp): 2022 Update 13 [mark noimpl]
+
+
+## 関連項目
+- [`std::projected`](projected.md)
+- [`std::ranges::find()`](/reference/algorithm/ranges_find.md)
+- [`std::ranges::find_last()`](/reference/algorithm/ranges_find_last.md)
+- [`std::ranges::count()`](/reference/algorithm/ranges_count.md)
+- [`std::ranges::search_n()`](/reference/algorithm/ranges_search_n.md)
+- [`std::ranges::replace()`](/reference/algorithm/ranges_replace.md)
+- [`std::ranges::replace_if()`](/reference/algorithm/ranges_replace_if.md)
+- [`std::ranges::replace_copy()`](/reference/algorithm/replace_copy.md)
+- [`std::ranges::remove()`](/reference/algorithm/ranges_remove.md)
+- [`std::ranges::remove_copy()`](/reference/algorithm/ranges_remove_copy.md)
+- [`std::ranges::lower_bound()`](/reference/algorithm/ranges_lower_bound.md)
+- [`std::ranges::upper_bound()`](/reference/algorithm/ranges_upper_bound.md)
+- [`std::ranges::equal_range()`](/reference/algorithm/ranges_equal_range.md)
+- [`std::ranges::binary_search()`](/reference/algorithm/ranges_binary_search.md)
+- [`std::ranges::contains()`](/reference/algorithm/ranges_contains.md)
+
+
+## 参照
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で、アルゴリズムに波カッコ初期化 (リスト初期化) を渡せるようにするために導入された。`find(r, {1, 2});`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/deque/deque/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/erase_free.md b/reference/deque/deque/erase_free.md
index 5ed9fec9a..6c95c90d4 100644
--- a/reference/deque/deque/erase_free.md
+++ b/reference/deque/deque/erase_free.md
@@ -7,7 +7,11 @@
 ```cpp
 namespace std {
   template &amp;lt;class T, class Allocator, class U&amp;gt;
-  typename deque&amp;lt;T, Allocator&amp;gt;::size_type erase(deque&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+  typename deque&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(deque&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++20
+  template &amp;lt;class T, class Allocator, class U = T&amp;gt;
+  typename deque&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(deque&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++26
 }
 ```
 
@@ -35,7 +39,18 @@ return r;
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::deque&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; d;
+        erase(d, {}); // 空の要素を削除
+        erase(d, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;deque&amp;gt;
@@ -54,13 +69,39 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 5
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;deque&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::deque&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; d = {
+    {1, 2, 3},
+    {4, 5, 6},
+    {},
+    {7, 8}
+  };
+
+  std::erase(d, {}); // 空の要素を削除
+  std::erase(d, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+
+  std::println(&amp;#34;{}&amp;#34;, d);
+}
+```
+
+#### 出力
+```
+[[4, 5, 6], [7, 8]]
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -74,3 +115,5 @@ int main()
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/forward_list/forward_list/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/erase_free.md b/reference/forward_list/forward_list/erase_free.md
index 9e8ca2134..b6b6ffc18 100644
--- a/reference/forward_list/forward_list/erase_free.md
+++ b/reference/forward_list/forward_list/erase_free.md
@@ -7,7 +7,11 @@
 ```cpp
 namespace std {
   template &amp;lt;class T, class Allocator, class U&amp;gt;
-  typename forward_list&amp;lt;T, Allocator&amp;gt;::size_type erase(forward_list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+  typename forward_list&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(forward_list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++20
+  template &amp;lt;class T, class Allocator, class U = T&amp;gt;
+  typename forward_list&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(forward_list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++26
 }
 ```
 
@@ -28,7 +32,18 @@ erase_if(c, [&amp;amp;](auto&amp;amp; elem) { return elem == value; });
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::forward_list&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; ls;
+        erase(ls, {}); // 空の要素を削除
+        erase(ls, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;forward_list&amp;gt;
@@ -47,13 +62,39 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 5
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;forward_list&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::forward_list&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; ls = {
+    {1, 2, 3},
+    {4, 5, 6},
+    {},
+    {7, 8}
+  };
+
+  std::erase(ls, {}); // 空の要素を削除
+  std::erase(ls, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+
+  std::println(&amp;#34;{}&amp;#34;, ls);
+}
+```
+
+#### 出力
+```
+[[4, 5, 6], [7, 8]]
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -67,3 +108,5 @@ int main()
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/list/list/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/list/list/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/erase_free.md b/reference/list/list/erase_free.md
index 8f1c859cf..004e672b9 100644
--- a/reference/list/list/erase_free.md
+++ b/reference/list/list/erase_free.md
@@ -7,7 +7,11 @@
 ```cpp
 namespace std {
   template &amp;lt;class T, class Allocator, class U&amp;gt;
-  typename list&amp;lt;T, Allocator&amp;gt;::size_type erase(list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+  typename list&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++20
+  template &amp;lt;class T, class Allocator, class U = T&amp;gt;
+  typename list&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++26
 }
 ```
 
@@ -28,7 +32,18 @@ erase_if(c, [&amp;amp;](auto&amp;amp; elem) { return elem == value; });
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::list&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; ls;
+        erase(ls, {}); // 空の要素を削除
+        erase(ls, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;list&amp;gt;
@@ -47,13 +62,39 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 5
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;list&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::list&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; ls = {
+    {1, 2, 3},
+    {4, 5, 6},
+    {},
+    {7, 8}
+  };
+
+  std::erase(ls, {}); // 空の要素を削除
+  std::erase(ls, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+
+  std::println(&amp;#34;{}&amp;#34;, ls);
+}
+```
+
+#### 出力
+```
+[[4, 5, 6], [7, 8]]
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -67,3 +108,5 @@ int main()
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/string/basic_string/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/erase_free.md b/reference/string/basic_string/erase_free.md
index 35d7ec1a3..dfc18ebac 100644
--- a/reference/string/basic_string/erase_free.md
+++ b/reference/string/basic_string/erase_free.md
@@ -8,7 +8,10 @@
 namespace std {
   template &amp;lt;class CharT, class Traits, class Allocator, class U&amp;gt;
   constexpr typename basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;::size_type
-    erase(basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+    erase(basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);   // (1) C++20
+  template &amp;lt;class CharT, class Traits, class Allocator, class U = CharT&amp;gt;
+  constexpr typename basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;::size_type
+    erase(basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);   // (1) C++26
 }
 ```
 
@@ -36,7 +39,17 @@ return r;
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        erase(s, {});    // ヌル文字&amp;#39;\0&amp;#39;を削除
+        erase(s, {&amp;#39;a&amp;#39;}); // 文字&amp;#39;a&amp;#39;を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;string&amp;gt;
@@ -53,11 +66,33 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 HelloWorld
 ```
 
+### 波カッコ初期化を入力文字として使用する (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main() {
+  const char ar[] = &amp;#34;hel\0lo&amp;#34;;
+  std::string s(ar, ar + sizeof(ar));
+
+  std::erase(s, {});
+  std::erase(s, {&amp;#39;l&amp;#39;});
+
+  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
+}
+```
+
+#### 出力
+```
+heo
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -71,3 +106,5 @@ HelloWorld
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/vector/vector/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector/erase_free.md b/reference/vector/vector/erase_free.md
index 81a12080a..82a5411ff 100644
--- a/reference/vector/vector/erase_free.md
+++ b/reference/vector/vector/erase_free.md
@@ -8,7 +8,10 @@
 namespace std {
   template &amp;lt;class T, class Allocator, class U&amp;gt;
   constexpr typename vector&amp;lt;T, Allocator&amp;gt;::size_type
-    erase(vector&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+    erase(vector&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);  // (1) C++20
+  template &amp;lt;class T, class Allocator, class U = T&amp;gt;
+  constexpr typename vector&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(vector&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);  // (1) C++26
 }
 ```
 
@@ -36,7 +39,18 @@ return r;
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; v;
+        erase(v, {}); // 空の要素を削除
+        erase(v, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -55,13 +69,38 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 5
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; v = {
+    {1, 2, 3},
+    {4, 5, 6},
+    {},
+    {7, 8}
+  };
+
+  std::erase(v, {}); // 空の要素を削除
+  std::erase(v, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+
+  std::println(&amp;#34;{}&amp;#34;, v);
+}
+```
+
+#### 出力
+```
+[[4, 5, 6], [7, 8]]
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -75,3 +114,5 @@ int main()
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/cmath/abs.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/cmath/abs.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/abs.md b/reference/cmath/abs.md
index 8ae5febb3..52d2b8bda 100644
--- a/reference/cmath/abs.md
+++ b/reference/cmath/abs.md
@@ -45,12 +45,12 @@ namespace std {
 ## 戻り値
 引数 `x` の絶対値を返す。
 
-- (1),(2),(3),(4) : `x` が `±∞` だった場合 `+∞` を返す。
+- (1), (2), (3), (4) : `x` が `±∞` だった場合 `+∞` を返す。
 
 
 ## 備考
 - $$ f(x) = | x | $$
-- 任意の整数型に対するオーバーロード(5)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(6),(7),(8)が追加された
+- 任意の整数型に対するオーバーロード(5)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(6), (7), (8)が追加された
 - C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/condition_variable/condition_variable_any/wait.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait.md b/reference/condition_variable/condition_variable_any/wait.md
index 3694af8c1..32a396579 100644
--- a/reference/condition_variable/condition_variable_any/wait.md
+++ b/reference/condition_variable/condition_variable_any/wait.md
@@ -65,7 +65,7 @@ return pred();
 
 
 ## 戻り値
-- (1),(2) : なし
+- (1), (2) : なし
 - (3) : 停止要求の有無によらず、`pred()`の結果が返る。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/cstdlib/abs.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/cstdlib/abs.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdlib/abs.md b/reference/cstdlib/abs.md
index ad61f0b6a..a9bbede8c 100644
--- a/reference/cstdlib/abs.md
+++ b/reference/cstdlib/abs.md
@@ -59,7 +59,7 @@ namespace std {
 ## 戻り値
 引数 `j` の絶対値を返す。
 
-- (4),(5),(6),(7) : `j` が `±∞` だった場合 `+∞` を返す。
+- (4), (5), (6), (7) : `j` が `±∞` だった場合 `+∞` を返す。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected.void/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/expected/expected.void/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected.void/op_constructor.md b/reference/expected/expected.void/op_constructor.md
index 84266a193..494caea13 100644
--- a/reference/expected/expected.void/op_constructor.md
+++ b/reference/expected/expected.void/op_constructor.md
@@ -198,7 +198,7 @@ int main()
     // ムーブ後のstd::unique_ptr型はnullptrが保証される
   }
 
-  // (6),(7) エラー値の変換コピー／ムーブ構築
+  // (6), (7) エラー値の変換コピー／ムーブ構築
   {
     std::unexpected&amp;lt;IntPair&amp;gt; src1{std::in_place, 1, 2};
     std::expected&amp;lt;void, IntTuple&amp;gt; dst1 = src1;
@@ -217,7 +217,7 @@ int main()
     assert(x1.has_value());
   }
 
-  // (9),(10) 引数リストからエラー値を直接構築
+  // (9), (10) 引数リストからエラー値を直接構築
   {
     std::expected&amp;lt;void, ComplexType&amp;gt; x1{std::unexpect, &amp;#34;C++&amp;#34;, 1};
     assert(not x1.has_value());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/expected/expected/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/op_constructor.md b/reference/expected/expected/op_constructor.md
index 43c739071..96418b457 100644
--- a/reference/expected/expected/op_constructor.md
+++ b/reference/expected/expected/op_constructor.md
@@ -255,7 +255,7 @@ int main()
     assert(*dst2.value() == 42);
   }
 
-  // (7),(8) エラー値の変換コピー／ムーブ構築
+  // (7), (8) エラー値の変換コピー／ムーブ構築
   {
     std::unexpected&amp;lt;IntPair&amp;gt; src1{std::in_place, 1, 2};
     std::expected&amp;lt;int, IntTuple&amp;gt; dst1 = src1;
@@ -268,7 +268,7 @@ int main()
     assert(*dst2.error() == 42);
   }
 
-  // (9),(10) 引数リストから正常値を直接構築
+  // (9), (10) 引数リストから正常値を直接構築
   {
     std::expected&amp;lt;ComplexType, int&amp;gt; x1{std::in_place, &amp;#34;C++&amp;#34;, 1};
     assert(x1.has_value());
@@ -281,7 +281,7 @@ int main()
     assert((x2.value().seq == std::vector&amp;lt;int&amp;gt;{5, 6, 7, 8}));
   }
 
-  // (11),(12) 引数リストからエラー値を直接構築
+  // (11), (12) 引数リストからエラー値を直接構築
   {
     std::expected&amp;lt;int, ComplexType&amp;gt; x1{std::unexpect, &amp;#34;Hello!&amp;#34;, 4};
     assert(not x1.has_value());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/expected/unexpected/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/expected/unexpected/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/unexpected/op_constructor.md b/reference/expected/unexpected/op_constructor.md
index 02406bb5d..1b8373301 100644
--- a/reference/expected/unexpected/op_constructor.md
+++ b/reference/expected/unexpected/op_constructor.md
@@ -109,7 +109,7 @@ int main()
     // ムーブ後のstd::unique_ptr型はnullptrが保証される
   }
 
-  // (4),(5) 引数リストから直接構築
+  // (4), (5) 引数リストから直接構築
   {
     std::unexpected&amp;lt;ComplexType&amp;gt; x1{std::in_place, &amp;#34;C++&amp;#34;, 1};
     assert(x1.error().data == &amp;#34;C&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format_to -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/format/format_to.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/format/format_to.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format_to.md b/reference/format/format_to.md
index 03cc3bc5c..2cd9f2489 100644
--- a/reference/format/format_to.md
+++ b/reference/format/format_to.md
@@ -51,15 +51,15 @@ format_to(back_inserter(buffer), &amp;#34;The answer is {}.&amp;#34;, 42);
 
 `Out`は以下の制約を満たす。
 
-* (1),(3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
-* (2),(4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
+* (1), (3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
+* (2), (4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
 
 ## 事前条件
 
 `Out`は以下のコンセプトのモデルである。
 
-* (1),(3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
-* (2),(4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
+* (1), (3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
+* (2), (4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
 
 ## 効果
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>vformat_to -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/format/vformat_to.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/format/vformat_to.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/vformat_to.md b/reference/format/vformat_to.md
index dd565dd0d..e14207425 100644
--- a/reference/format/vformat_to.md
+++ b/reference/format/vformat_to.md
@@ -42,15 +42,15 @@ namespace std {
 
 `Out`は以下の制約を満たす。
 
-* (1),(3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
-* (2),(4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
+* (1), (3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
+* (2), (4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
 
 ## 事前条件
 
 `out`は以下の制約を満たす型の有効なオブジェクトである。
 
-* (1),(3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
-* (2),(4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
+* (1), (3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
+* (2), (4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
 
 ## 効果
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>splice_after -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/splice_after.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/forward_list/forward_list/splice_after.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/splice_after.md b/reference/forward_list/forward_list/splice_after.md
index ecb33dfab..20677d81e 100644
--- a/reference/forward_list/forward_list/splice_after.md
+++ b/reference/forward_list/forward_list/splice_after.md
@@ -35,9 +35,9 @@ void splice_after(const_iterator position, forward_list&amp;amp;&amp;amp; x,
 
 
 ## 効果
-- (1),(2) : `position`の指す要素の後ろに、`x`の全ての要素を移動する
-- (3),(4) : `position`の指す要素の後ろに、`x`の要素のうち`i`の次の要素を移動する
-- (5),(6) : `position`の指す要素の後ろに、`x`の要素のうち`(first, last)`の範囲を移動する
+- (1), (2) : `position`の指す要素の後ろに、`x`の全ての要素を移動する
+- (3), (4) : `position`の指す要素の後ろに、`x`の要素のうち`i`の次の要素を移動する
+- (5), (6) : `position`の指す要素の後ろに、`x`の要素のうち`(first, last)`の範囲を移動する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>yield_value -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/generator/generator/promise_type/yield_value.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/generator/generator/promise_type/yield_value.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/generator/generator/promise_type/yield_value.md b/reference/generator/generator/promise_type/yield_value.md
index 51bcb800f..ca95b2820 100644
--- a/reference/generator/generator/promise_type/yield_value.md
+++ b/reference/generator/generator/promise_type/yield_value.md
@@ -90,7 +90,7 @@ return yield_value(ranges::elements_of(nested(
 
 
 ## 例外
-- (1),(3),(4) : 投げない。
+- (1), (3), (4) : 投げない。
 - (2) : 格納されるオブジェクトの初期化によって送出された例外。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/queue/queue/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/queue/queue/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/queue/queue/op_constructor.md b/reference/queue/queue/op_constructor.md
index 0dfe840c6..4596320db 100644
--- a/reference/queue/queue/op_constructor.md
+++ b/reference/queue/queue/op_constructor.md
@@ -6,11 +6,11 @@
 
 ```cpp
 // C++03まで
-explicit queue(const Container&amp;amp; other = Container());  // (1),(2)
+explicit queue(const Container&amp;amp; other = Container());  // (1), (2)
 
 // C++11以降 C++17まで
 explicit queue(const Container&amp;amp; other);           // (2)
-explicit queue(Container&amp;amp;&amp;amp; other = Container());  // (1),(3)
+explicit queue(Container&amp;amp;&amp;amp; other = Container());  // (1), (3)
 
 // C++20以降
 queue() : queue(Container()) {}          // (1)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/stack/stack/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/stack/stack/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stack/stack/op_constructor.md b/reference/stack/stack/op_constructor.md
index 14b0c8d2f..f173b91ca 100644
--- a/reference/stack/stack/op_constructor.md
+++ b/reference/stack/stack/op_constructor.md
@@ -6,11 +6,11 @@
 
 ```cpp
 // C++03まで
-explicit stack(const Container&amp;amp; cont = Container());  // (1),(2)
+explicit stack(const Container&amp;amp; cont = Container());  // (1), (2)
 
 // C++11以降 C++17まで
 explicit stack(const Container&amp;amp; cont);           // (2)
-explicit stack(Container&amp;amp;&amp;amp; cont = Container());  // (1),(3)
+explicit stack(Container&amp;amp;&amp;amp; cont = Container());  // (1), (3)
 
 // C++20以降
 stack() : stack(Container()) {}    // (1)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/string/basic_string/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_constructor.md b/reference/string/basic_string/op_constructor.md
index 5bf500824..b0a95566d 100644
--- a/reference/string/basic_string/op_constructor.md
+++ b/reference/string/basic_string/op_constructor.md
@@ -268,4 +268,4 @@ s14 : Hello
 - [P2166R1 A Proposal to Prohibit std::basic_string and std::basic_string_view construction from nullptr.](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2166r1.html)
     - C++23での(16)`nullptr_t`をとるコンストラクタのdelete宣言追加
 - [P2438R2 `std::string::substr() &amp;amp;&amp;amp;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2438r2.html)
-    - C++23での(17),(18)`basic_string&amp;amp;&amp;amp;`と範囲指定をとるコンストラクタ追加
+    - C++23での(17), (18)`basic_string&amp;amp;&amp;amp;`と範囲指定をとるコンストラクタ追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>