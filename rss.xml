<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-06-21T04:46:11.304638</updated>
  <id>37f4c7b0-97e0-4bac-abd4-de8e75c79f65</id>

  
    <entry>
      <title>is_pod -- fix(type_traits): deprecate POD</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_pod.html"/>
      <id>95d222bcf1758c69d95e49dedf7114b41e3cca6d:reference/type_traits/is_pod.md</id>
      <updated>2020-06-21T13:42:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_pod.md b/reference/type_traits/is_pod.md
index 84a2db377..c7ae6b1c2 100644
--- a/reference/type_traits/is_pod.md
+++ b/reference/type_traits/is_pod.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * class template[meta id-type]
 * cpp11[meta cpp]
+* cpp20deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -14,6 +15,8 @@ namespace std {
 }
 ```
 
+このトレイトはC++20で非推奨になった。同時にPODという概念自体が非推奨になった。
+
 ## 概要
 型`T`がPOD型 (Plain Old Data) か調べる。POD型は、トリビアル型、かつスタンダードレイアウト型、およびそのcv修飾を含む。
 
@@ -29,6 +32,12 @@ namespace std {
 ## 備考
 &amp;#34;Plain Old Data&amp;#34;という名称はつまり、C言語の構造体や共用体と互換性を持つためである。
 
+## 非推奨の詳細 (C++20)
+
+C++11でPODをトリビアルとスタンダードレイアウトという２つの概念に分離した。  
+そして実用上必要だったのはトリビアル型ではなく[トリビアルコピー可能](is_trivially_copyable.md)型、もしくは[スタンダードレイアウト](is_standard_layout.md)型であった。  
+結果として、トリビアル型かつスタンダードレイアウト型というあまりに強すぎる制約を課すPODというのは、もはや定義だけされて使われていないものとなっていた。
+したがって、規格書の文面でPODという用語に依存している部分は他の説明に書き換え、非推奨にすることとした。
 
 ## 例
 ```cpp example
@@ -80,3 +89,6 @@ int main(){}
 - [LWG Issue 2015. Incorrect pre-conditions for some type traits](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2015)
     - C++11では要件が「型`T`は完全型であるか、`const`/`volatile`修飾された(あるいはされていない)`void`か、要素数不明の配列型でなければならない。」だったが、これは間違いであるため、C++14で「型[`remove_all_extents`](remove_all_extents.md)`&amp;lt;T&amp;gt;::type`は、完全型か、`const`/`volatile`修飾された(あるいはされていない)`void`でなければならない。」に変更された。
 - [P0006R0 Adopt Type Traits Variable Templates from Library Fundamentals TS for C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0006r0.html)
+- [CGW issue 2323. Expunge POD](https://wg21.cmeerw.net/cwg/issue2323)
+- [P0488R0 WG21 Working Paper, NB Comments, ISO/IEC CD 14882 #US 101](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf#US101)
+- [P0767R1: Deprecate POD](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0767r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>strong_order -- strong_order : 定数式となる条件の修正</title>
      <link href="https://cpprefjp.github.io/reference/compare/strong_order.html"/>
      <id>6b7efebf8a5b218aa02b2caebc04dc8b861dc293:reference/compare/strong_order.md</id>
      <updated>2020-06-19T16:23:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/compare/strong_order.md b/reference/compare/strong_order.md
index c347c730e..a73be309a 100644
--- a/reference/compare/strong_order.md
+++ b/reference/compare/strong_order.md
@@ -53,7 +53,7 @@ namespace std {
 
 1. --
 2. 呼び出される`strong_order(a, b)`およびその戻り値の`strong_ordering`への変換が定数評価可能であるかに従う。
-3. 常に定数評価可能
+3. 引数`a, b`が定数（式）ならば、常に定数評価可能
 4. 呼び出される`a &amp;lt;=&amp;gt; b`およびその戻り値の`strong_ordering`への変換が定数評価可能であるかに従う。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-integer-like -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/is_integer_like.html"/>
      <id>04ade5aa2a00781f76671c69f9aefc5e391133e6:reference/iterator/is_integer_like.md</id>
      <updated>2020-06-19T12:01:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/is_integer_like.md b/reference/iterator/is_integer_like.md
index b2568a278..7099dcf45 100644
--- a/reference/iterator/is_integer_like.md
+++ b/reference/iterator/is_integer_like.md
@@ -49,9 +49,9 @@ namespace std {
 - `numeric_limits&amp;lt;I&amp;gt;::is_specialized == true`
 - [`numeric_limits&amp;lt;I&amp;gt;::is_signed`](/reference/limits/numeric_limits/is_signed.md)` == true`
     - `I`が*signed-integer-class*型の場合のみ
-- [`numeric_limits&amp;lt;I&amp;gt;::digits`](/limits/numeric_limits/digits.md)は`I`の幅と等しい
-- [`numeric_limits&amp;lt;I&amp;gt;::digits10`](/limits/numeric_limits/digits10.md)は`static_cast&amp;lt;int&amp;gt;(digits * log10(2))`と等しい
-- [`numeric_limits&amp;lt;I&amp;gt;::min()`](/limits/numeric_limits/min.md)と[`numeric_limits&amp;lt;I&amp;gt;::max()`](/limits/numeric_limits/max.md)はそれぞれ、`I`の表現可能な値の最小値と最大値を返す。[`numeric_limits&amp;lt;I&amp;gt;::lowest()`](/limits/numeric_limits/lowest.md)は`numeric_limits&amp;lt;I&amp;gt;::max()`を返す。
+- [`numeric_limits&amp;lt;I&amp;gt;::digits`](/reference/limits/numeric_limits/digits.md)は`I`の幅と等しい
+- [`numeric_limits&amp;lt;I&amp;gt;::digits10`](/reference/limits/numeric_limits/digits10.md)は`static_cast&amp;lt;int&amp;gt;(digits * log10(2))`と等しい
+- [`numeric_limits&amp;lt;I&amp;gt;::min()`](/reference/limits/numeric_limits/min.md)と[`numeric_limits&amp;lt;I&amp;gt;::max()`](/reference/limits/numeric_limits/max.md)はそれぞれ、`I`の表現可能な値の最小値と最大値を返す。[`numeric_limits&amp;lt;I&amp;gt;::lowest()`](/reference/limits/numeric_limits/lowest.md)は`numeric_limits&amp;lt;I&amp;gt;::max()`を返す。
 
 
 ## バージョン
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-integer-like -- is-integer-like : 追記 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/is_integer_like.html"/>
      <id>32c50ecfb68c3e7cb8ef3eee7707727da6d37ea8:reference/iterator/is_integer_like.md</id>
      <updated>2020-06-19T11:46:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/is_integer_like.md b/reference/iterator/is_integer_like.md
index dcbc6f3e4..b2568a278 100644
--- a/reference/iterator/is_integer_like.md
+++ b/reference/iterator/is_integer_like.md
@@ -18,7 +18,41 @@ namespace std {
 
 これらの説明専用の変数テンプレートは、任意の型`T`が符号付/なし整数型そのものあるいはそれと同様に扱える型である場合に`true`を示すものである。
 
-これは標準ライブラリ内において、イテレータの差分型（`difference_type`）としてユーザー定義の整数型の使用を許可するためにコンセプトの文脈で使用される。
+これは標準ライブラリ内において、イテレータの差分型（`difference_type`）として実装定義の整数型の使用を許可するためにコンセプトの文脈で使用される。
+
+## 効果
+
+`is-integer-like&amp;lt;T&amp;gt;`は`T`が[`integral`](/reference/concepts/integral.md)のモデルとなるか*integer-class*である時に`true`を示す。  
+`is-signed-integer-like&amp;lt;T&amp;gt;`は`T`が[`signed_integral`](/reference/concepts/signed_integral.md)のモデルとなるか*signed-integer-class*である時に`true`を示す。
+
+## (signed-)integer-class型
+
+*integer-class*型は組み込みの整数型と同じように動作する実装定義のクラス型である。
+
+*integer-class*型の表現可能な範囲はそれが定義する値の連続集合であり、`0`と`1`を必ず含んでいなければならない。この時、その範囲に負の数が含まれていればその型は*signed-integer-class*型であり、それ以外のものは*unsigned-integer-class*型である。
+
+### 要件
+
+`I`をある*integer-class*型、`B`を少なくとも`I`と同じ範囲の値を表現可能で同じ幅を持つ別の*integer-class*型とする。  
+`I`の値`a, b`、`a, b`それぞれと同じ値を表現する`B`の値`x, y`と任意の整数型の値`c`について次のことが成り立つ。
+
+- 式`@x`が適格である全ての単項演算子`@`について`@a`もまた適格であり、共に同じ値、効果、値カテゴリを持つ。`@x`が`bool`型を示す場合`@a`もまた`bool`型を示すが。`@x`が`B`を示す場合は`@a`は`I`を示す。
+- 式`c @= x`が適格である全ての（複合）代入演算子`@=`について`c @= a`もまた適格であり、共に同じ値、効果を持つ。式`c @= a`の結果は`c`を参照する*lvalue*となる。
+- 式`x @ y`が適格である全ての二項演算子`@`について`a @ b`もまた適格であり、結果の値を`I`が表現できる場合は共に同じ値、効果、値カテゴリを持つ。`x @ y`が`bool`型を示す場合`a @ b`もまた`bool`型を示すが。`x @ y`が`B`を示す場合は`a @ b`は`I`を示す。
+- *integer-class*型の値は任意の整数型に明示的に変換でき、任意の整数型の値は*integer-class*型に暗黙的にも明示的にも変換できる。それらの変換は例外を送出しない。
+- *integer-class*型の式`E`は`bool(E != I(0))`のように文脈的に`bool`に変換できる。
+- *integer-class*型は[`regular`](/reference/concepts/regular.md)及び[`totally_ordered`](/reference/concepts/totally_ordered.md)のモデルとなる。
+- 値初期化された*integer-class*型の値は`0`になる。
+
+*integer-class*型`I`について[`numeric_limits&amp;lt;I&amp;gt;`](/reference/limits/numeric_limits.md)の特殊化は次のような値を示す。
+
+- `numeric_limits&amp;lt;I&amp;gt;::is_specialized == true`
+- [`numeric_limits&amp;lt;I&amp;gt;::is_signed`](/reference/limits/numeric_limits/is_signed.md)` == true`
+    - `I`が*signed-integer-class*型の場合のみ
+- [`numeric_limits&amp;lt;I&amp;gt;::digits`](/limits/numeric_limits/digits.md)は`I`の幅と等しい
+- [`numeric_limits&amp;lt;I&amp;gt;::digits10`](/limits/numeric_limits/digits10.md)は`static_cast&amp;lt;int&amp;gt;(digits * log10(2))`と等しい
+- [`numeric_limits&amp;lt;I&amp;gt;::min()`](/limits/numeric_limits/min.md)と[`numeric_limits&amp;lt;I&amp;gt;::max()`](/limits/numeric_limits/max.md)はそれぞれ、`I`の表現可能な値の最小値と最大値を返す。[`numeric_limits&amp;lt;I&amp;gt;::lowest()`](/limits/numeric_limits/lowest.md)は`numeric_limits&amp;lt;I&amp;gt;::max()`を返す。
+
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>byte -- fix(cstddef/byte): msvcの実装状況を追加</title>
      <link href="https://cpprefjp.github.io/reference/cstddef/byte.html"/>
      <id>f1473391a87489d20ee0291a1322a6b1cebaaa7a:reference/cstddef/byte.md</id>
      <updated>2020-06-18T21:22:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstddef/byte.md b/reference/cstddef/byte.md
index 4d7c86576..4e72e22c9 100644
--- a/reference/cstddef/byte.md
+++ b/reference/cstddef/byte.md
@@ -88,7 +88,7 @@ int main()
 ### 処理系
 - [Clang](/implementation.md#clang): 5.0
 - [GCC](/implementation.md#gcc): 7.1
-- [Visual C++](/implementation.md#visual_cpp): ??
+- [Visual C++](/implementation.md#visual_cpp): 2017 Update 3(`_HAS_STD_BYTE`を`0`に定義することで無効化できる)
 
 
 ## 関連項目
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
</feed>