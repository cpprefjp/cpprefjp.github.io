<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-06-23T04:55:29.569674</updated>
  <id>f7b210b7-2b72-431d-84a0-c5d0a2212523</id>

  
    <entry>
      <title>flat_map -- flat_map : try_emplaceを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map.html"/>
      <id>2c9f635eff6128691a72fb7312df6fe1f69deb8e:reference/flat_map/flat_map.md</id>
      <updated>2023-06-23T13:50:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map.md b/reference/flat_map/flat_map.md
index a64b6db0b..fad991010 100644
--- a/reference/flat_map/flat_map.md
+++ b/reference/flat_map/flat_map.md
@@ -63,7 +63,7 @@ namespace std {
 | [`insert_range`](flat_map/insert_range.md.nolink)         | Rangeを挿入する                            | C++23 |
 | [`emplace`](flat_map/emplace.md)                   | 要素を直接構築する                         | C++23 |
 | [`emplace_hint`](flat_map/emplace_hint.md)         | ヒントを使って要素を直接構築する           | C++23 |
-| [`try_emplace`](flat_map/try_emplace.md.nolink)           | キーが存在しない場合のみ要素を直接構築する | C++23 |
+| [`try_emplace`](flat_map/try_emplace.md)           | キーが存在しない場合のみ要素を直接構築する | C++23 |
 | [`erase`](flat_map/erase.md)                       | 要素を削除する                             | C++23 |
 | [`swap`](flat_map/swap.md.nolink)                         | コンテンツを交換する                       | C++23 |
 | [`extract`](flat_map/extract.md.nolink)                   | キーのコンテナ、値のコンテナを取得する     | C++23 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace -- flat_map : try_emplaceを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/emplace.html"/>
      <id>2c9f635eff6128691a72fb7312df6fe1f69deb8e:reference/flat_map/flat_map/emplace.md</id>
      <updated>2023-06-23T13:50:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/emplace.md b/reference/flat_map/flat_map/emplace.md
index 398b43084..b87c0a203 100644
--- a/reference/flat_map/flat_map/emplace.md
+++ b/reference/flat_map/flat_map/emplace.md
@@ -135,5 +135,5 @@ CCC : (1, 2)
 | [`flat_map::insert`](insert.md.nolink)                     | 要素を挿入する                             |
 | [`flat_map::insert_or_assign`](insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               |
 | [`flat_map::emplace_hint`](emplace_hint.md)         | ヒントを使って要素を直接構築する           |
-| [`flat_map::try_emplace`](try_emplace.md.nolink)           | キーが存在しない場合のみ要素を直接構築する |
+| [`flat_map::try_emplace`](try_emplace.md)           | キーが存在しない場合のみ要素を直接構築する |
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace_hint -- flat_map : try_emplaceを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/emplace_hint.html"/>
      <id>2c9f635eff6128691a72fb7312df6fe1f69deb8e:reference/flat_map/flat_map/emplace_hint.md</id>
      <updated>2023-06-23T13:50:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/emplace_hint.md b/reference/flat_map/flat_map/emplace_hint.md
index c9516eae4..7a016946b 100644
--- a/reference/flat_map/flat_map/emplace_hint.md
+++ b/reference/flat_map/flat_map/emplace_hint.md
@@ -28,7 +28,7 @@ iterator emplace_hint(const_iterator hint, Args&amp;amp;&amp;amp;... args);
 
 
 ## 備考
-- [`try_emplace`](try_emplace.md.nolink) と異なり、たとえ要素が挿入されなかった場合でも `value_type` 型のオブジェクトが構築される可能性があり、結果として引数 `args` が [`move`](/reference/utility/move.md) の対象となって変更されてしまっている可能性があるため、注意が必要である。
+- [`try_emplace`](try_emplace.md) と異なり、たとえ要素が挿入されなかった場合でも `value_type` 型のオブジェクトが構築される可能性があり、結果として引数 `args` が [`move`](/reference/utility/move.md) の対象となって変更されてしまっている可能性があるため、注意が必要である。
 
 
 ## 例
@@ -78,5 +78,5 @@ int main()
 | [`flat_map::insert`](insert.md.nolink)                     | 要素を挿入する                             |
 | [`flat_map::insert_or_assign`](insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               |
 | [`flat_map::emplace`](emplace.md)                   | 要素を直接構築する                         |
-| [`flat_map::try_emplace`](try_emplace.md.nolink)           | キーが存在しない場合のみ要素を直接構築する |
+| [`flat_map::try_emplace`](try_emplace.md)           | キーが存在しない場合のみ要素を直接構築する |
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator[] -- flat_map : try_emplaceを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/op_at.html"/>
      <id>2c9f635eff6128691a72fb7312df6fe1f69deb8e:reference/flat_map/flat_map/op_at.md</id>
      <updated>2023-06-23T13:50:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/op_at.md b/reference/flat_map/flat_map/op_at.md
index df611e9bd..113fb30e2 100644
--- a/reference/flat_map/flat_map/op_at.md
+++ b/reference/flat_map/flat_map/op_at.md
@@ -30,20 +30,20 @@ mapped_type&amp;amp; operator[](K&amp;amp;&amp;amp; x);             // (3) C++23
     ```cpp
     return try_emplace(x).first-&amp;gt;second;
     ```
-    * try_emplace[link try_emplace.md.nolink]
+    * try_emplace[link try_emplace.md]
 
 - (2) : 以下と等価
     ```cpp
     return try_emplace(std::move(x)).first-&amp;gt;second;
     ```
-    * try_emplace[link try_emplace.md.nolink]
+    * try_emplace[link try_emplace.md]
     * std::move[link /reference/utility/move.md]
 
 - (3) : 以下と等価
     ```cpp
     return try_emplace(std::forward(x)).first-&amp;gt;second;
     ```
-    * try_emplace[link try_emplace.md.nolink]
+    * try_emplace[link try_emplace.md]
     * std::forward[link /reference/utility/forward.md]
 
 
@@ -75,9 +75,9 @@ int main()
   fm[2] = &amp;#39;b&amp;#39;;
 }
 ```
-* m[1][color ff0000]
-* m[2][color ff0000]
-* m.insert[link insert.md.nolink]
+* fm[1][color ff0000]
+* fm[2][color ff0000]
+* fm.insert[link insert.md.nolink]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_emplace -- flat_map : try_emplaceを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/try_emplace.html"/>
      <id>2c9f635eff6128691a72fb7312df6fe1f69deb8e:reference/flat_map/flat_map/try_emplace.md</id>
      <updated>2023-06-23T13:50:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/try_emplace.md b/reference/flat_map/flat_map/try_emplace.md
new file mode 100644
index 000000000..5a5d8c721
--- /dev/null
+++ b/reference/flat_map/flat_map/try_emplace.md
@@ -0,0 +1,178 @@
+# try_emplace
+* flat_map[meta header]
+* std[meta namespace]
+* flat_map[meta class]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+template &amp;lt;class... Args&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(const key_type&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);       // (1) C++23
+
+template &amp;lt;class... Args&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(key_type&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);       // (2) C++23
+
+template &amp;lt;class... Args&amp;gt;
+iterator
+  try_emplace(const_iterator hint,
+              const key_type&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);       // (3) C++23
+
+template &amp;lt;class... Args&amp;gt;
+iterator
+  try_emplace(const_iterator hint,
+              key_type&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);       // (4) C++23
+
+template &amp;lt;class K, class... Args&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(K&amp;amp;&amp;amp; k
+              Args&amp;amp;&amp;amp;... args);       // (5) C++23
+
+template &amp;lt;class K, class... Args&amp;gt;
+iterator
+  try_emplace(const_iterator hint,
+              K&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);       // (6) C++23
+```
+* pair[link /reference/utility/pair.md]
+
+## 概要
+指定されたキーが存在しない場合のみ要素を直接構築で挿入する。
+
+引数 `k` と等価のキーを持つ要素が存在しない場合、コンテナに新しい要素を挿入する。要素は引数からコンテナ内に直接構築されるため、構築されたオブジェクトはコピーもムーブもされない。  
+なお、本メンバ関数は [`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) 等と異なり、引数 `k` と等価のキーを持つ要素が既に存在する場合には、`k` や `args` がムーブされてしまうことはない。
+
+引数 `hint` は、`k` を検索する際のヒントに使用される。
+
+- (1) : 指定されたキーが存在しない場合に、要素を直接構築で挿入する
+- (2) : 指定された一時オブジェクトのキーが存在しない場合に、要素を直接構築で挿入する
+- (3) : キーを検索するヒントを指定し、指定されたキーが存在しない場合に、要素を直接構築で挿入する
+- (4) : キーを検索するヒントを指定し、指定された一時オブジェクトのキーが存在しない場合に、要素を直接構築で挿入する
+- (5) : `key_type`と比較可能なキーが指定され、対応する存在しない場合に、要素を直接構築で挿入する
+- (6) : keyを研削するヒントと`key_type`と比較可能なキーが指定され、対応する存在しない場合に、要素を直接構築で挿入する
+
+
+## テンプレートパラメータ制約
+- [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;mapped_type, Args...&amp;gt;`が`true`であること
+- (5), (6) :
+    - `Compare::is_transparent`が有効な式であること
+    - [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;key_type, K&amp;gt;`が`true`であること
+- (5) :
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt;`と[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt;`がどちらも`false`であること
+
+なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
+
+
+## 事前条件
+- (5), (6) : `k`から`key_type`への変換は、[`find`](find.md)`(k) ==` [`find`](find.md)`(u)`が`true`となるオブジェクト`u`を構築する
+
+
+## 効果
+`k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、以下と等価：
+
+- (1), (2), (3), (4) :
+    ```cpp
+    auto key_it = ranges::upper_bound(c.keys, k, compare);
+    auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);
+    c.keys.insert(key_it, std::forward&amp;lt;decltype(k)&amp;gt;(k));
+    c.values.emplace(value_it, std::forward&amp;lt;Args&amp;gt;(args)...);
+    ```
+    * c.keys[link containers.md]
+    * c.values[link containers.md]
+    * ranges::upper_bound[link /reference/algorithm/ranges_upper_bound.md]
+    * begin()[link /reference/vector/vector/begin.md]
+    * distance[link /reference/iterator/distance.md]
+    * insert[link /reference/vector/vector/insert.md]
+    * emplace[link /reference/vector/vector/emplace.md]
+    * std::forward[link /reference/utility/forward.md]
+
+- (5), (6) :
+    ```cpp
+    auto key_it = ranges::upper_bound(c.keys, k, compare);
+    auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);
+    c.keys.emplace(key_it, std::forward&amp;lt;K&amp;gt;(k));
+    c.values.emplace(value_it, std::forward&amp;lt;Args&amp;gt;(args)...);
+    ```
+    * c.keys[link containers.md]
+    * c.values[link containers.md]
+    * ranges::upper_bound[link /reference/algorithm/ranges_upper_bound.md]
+    * begin()[link /reference/vector/vector/begin.md]
+    * distance[link /reference/iterator/distance.md]
+    * emplace[link /reference/vector/vector/emplace.md]
+    * std::forward[link /reference/utility/forward.md]
+
+
+## 戻り値
+- (1), (2), (5) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+    - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
+    - 挿入されなかった場合には、`first` に `k` と等価のキーを持つ既存の要素へのイテレータ、`second` に `false` が設定される。
+- (3), (4), (6) :
+    - 挿入された場合には、挿入された要素へのイテレータを返す。
+    - 挿入されなかった場合には、`k` と等価のキーを持つ既存の要素へのイテレータを返す。
+
+
+## 計算量
+- (1), (2), (5) : [`emplace`](emplace.md) と同じ
+- (3), (4), (6) : [`emplace_hint`](emplace_hint.md) と同じ
+
+
+## 備考
+- 概要に記載されているように、本メンバ関数は指定されたキーと等価の要素が既に存在する場合には、引数に副作用が発生しない。  
+    一方、[`emplace`](emplace.md)、[`emplace_hint`](emplace_hint.md)、[`insert`](insert.md.nolink) にはそのような規定は無く、挿入がされなかった場合でも引数に副作用（引数からのムーブ）が発生してしまう可能性があるため、注意が必要である。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main()
+{
+  std::flat_map&amp;lt;int, std::unique_ptr&amp;lt;int&amp;gt;&amp;gt; fm;
+
+  auto u1 = std::make_unique&amp;lt;int&amp;gt;(114);
+  auto [it1, b1] = fm.try_emplace(42, std::move(u1));
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; (u1.get() == nullptr) &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; *it1-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; b1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+
+  auto u2 = std::make_unique&amp;lt;int&amp;gt;(514);
+  auto [it2, b2] = fm.try_emplace(42, std::move(u2));
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; (u2.get() == nullptr) &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; *it2-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; b2 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+}
+```
+* try_emplace[color ff0000]
+* get[link /reference/memory/unique_ptr/get.md]
+* std::move[link /reference/utility/move.md]
+
+#### 出力
+```
+true, 114, true
+false, 114, false
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前                                           | 説明                                       |
+|------------------------------------------------|--------------------------------------------|
+| [`flat_map::insert`](insert.md.nolink)                     | 要素を挿入する                             |
+| [`flat_map::insert_or_assign`](insert_or_assign.md.nolink) | 要素を挿入、あるいは代入する               |
+| [`flat_map::emplace`](emplace.md)                   | 要素を直接構築する                         |
+| [`flat_map::emplace_hint`](emplace_hint.md)         | ヒントを使って要素を直接構築する           |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_map -- flat_map : eraseを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map.html"/>
      <id>2ba5e134badc55935bde36761d61ced7bc9dcd68:reference/flat_map/flat_map.md</id>
      <updated>2023-06-22T16:47:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map.md b/reference/flat_map/flat_map.md
index c699ae3a3..a64b6db0b 100644
--- a/reference/flat_map/flat_map.md
+++ b/reference/flat_map/flat_map.md
@@ -64,7 +64,7 @@ namespace std {
 | [`emplace`](flat_map/emplace.md)                   | 要素を直接構築する                         | C++23 |
 | [`emplace_hint`](flat_map/emplace_hint.md)         | ヒントを使って要素を直接構築する           | C++23 |
 | [`try_emplace`](flat_map/try_emplace.md.nolink)           | キーが存在しない場合のみ要素を直接構築する | C++23 |
-| [`erase`](flaflat_maptmap/erase.md.nolink)                | 要素を削除する                             | C++23 |
+| [`erase`](flat_map/erase.md)                       | 要素を削除する                             | C++23 |
 | [`swap`](flat_map/swap.md.nolink)                         | コンテンツを交換する                       | C++23 |
 | [`extract`](flat_map/extract.md.nolink)                   | キーのコンテナ、値のコンテナを取得する     | C++23 |
 | [`replace`](flat_map/replace.md.nolink)                   | キーのコンテナ、値のコンテナを置き換える   | C++23 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- flat_map : eraseを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/erase.html"/>
      <id>2ba5e134badc55935bde36761d61ced7bc9dcd68:reference/flat_map/flat_map/erase.md</id>
      <updated>2023-06-22T16:47:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/erase.md b/reference/flat_map/flat_map/erase.md
new file mode 100644
index 000000000..866a61380
--- /dev/null
+++ b/reference/flat_map/flat_map/erase.md
@@ -0,0 +1,169 @@
+# erase
+* flat_map[meta header]
+* std[meta namespace]
+* flat_map[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator erase(iterator position);                         // (1) C++23
+
+iterator erase(const_iterator position);                   // (2) C++23
+
+size_type erase(const key_type&amp;amp; x);                        // (3) C++23
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+iterator erase(const_iterator first, const_iterator last); // (5) C++23
+```
+
+## 概要
+単一要素またはイテレータ範囲`[first, last)`を `map` コンテナから削除する。
+
+これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
+
+- (1) : 指定されたイテレータが指す要素を削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素を削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素を削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
+
+
+## パラメータ
+- `position` : 削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
+- `x` : 削除する値のキー。`key_type` はメンバ型であり、コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素のキーの型である。
+- `first, last` : 削除するイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+
+
+## 戻り値
+- (1), (2), (5) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す。
+
+
+## 計算量
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
+
+
+## 備考
+- この関数に、範囲外のイテレータ (終端イテレータを含む) や存在しないキーを指定した場合の動作は未定義
+- 削除された要素を指すイテレータ、および、参照のみ無効になる。なお、規格書に明確な記載は無いが、削除された要素を指すポインタも無効になる
+- ループ中で `map` の要素を削除するためには、C++03 までは以下のようなコードを書く必要があった。
+    ```cpp
+    while (it != map_object.end()) {
+      if (条件) {
+        map_object.erase(it++);
+      }
+      else {
+        ++it;
+      }
+    }
+    ```
+
+    - これは、`erase` で指定したイテレータが、対象となる要素が削除されることによって無効になるため、後置インクリメント `it++` を使用することで要素が削除されるより先に削除対象の次の要素を指すようにするためである。
+    - このような書き方は C++11 以降でも依然として有効だが、`erase` が削除された次の要素を指すイテレータを返すようになったため、以下のようなコードを
+    ```cpp
+    map_object.erase(it++);
+    ```
+
+    - 以下のように書くこともできるようになった
+    ```cpp
+    it = map_object.erase(it);
+    ```
+
+
+## 例
+### 基本的な使い方 (C++23)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+
+int main()
+{
+  std::flat_map&amp;lt;int, char&amp;gt; fm = {
+    {1, &amp;#39;A&amp;#39;},
+    {2, &amp;#39;B&amp;#39;},
+    {3, &amp;#39;C&amp;#39;}
+  };
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.erase(1);
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.erase(fm.begin(), fm.end());
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+}
+```
+* erase[color ff0000]
+* fm.size()[link size.md]
+* fm.begin()[link begin.md]
+* fm.end()[link end.md]
+
+#### 出力
+```
+3
+2
+0
+```
+
+### イテレート中に要素を削除する (C++23)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+
+int main()
+{
+  std::flat_map&amp;lt;int, char&amp;gt; fm = {
+    {3, &amp;#39;a&amp;#39;},
+    {1, &amp;#39;b&amp;#39;},
+    {4, &amp;#39;c&amp;#39;}
+  };
+
+  // イテレート中に要素削除をするような場合には、
+  // 範囲for文は使用できない
+  for (auto it = fm.begin(); it != fm.end();) {
+    // 条件一致した要素を削除する
+    if (it-&amp;gt;first == 1) {
+      // 削除された要素の次を指すイテレータが返される。
+      it = fm.erase(it);
+    }
+    // 要素削除をしない場合に、イテレータを進める
+    else {
+      ++it;
+    }
+  }
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#39;:&amp;#39; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+
+#### 出力
+```
+3:a
+4:c
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|---------------------------------|----------------------|
+| [`flat_map::clear`](clear.md)   | 全ての要素を削除する |
+| [`flat_map::insert`](insert.md.nolink) | 要素を挿入する |
+| [`flat_map::find`](find.md)     | 指定したキーで要素を探す |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : サンプルコード中で未定義動作をしていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/map/map/erase.html"/>
      <id>a6c9e227b387d2aa8631acc1df6f78468d690702:reference/map/map/erase.md</id>
      <updated>2023-06-22T16:41:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/erase.md b/reference/map/map/erase.md
index 84fe25a4f..f40a1cb9a 100644
--- a/reference/map/map/erase.md
+++ b/reference/map/map/erase.md
@@ -99,9 +99,6 @@ int main()
   m.erase(1);
   std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
 
-  m.erase(5);
-  std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
-
   m.erase(m.begin(), m.end());
   std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
 
@@ -118,7 +115,6 @@ int main()
 ```
 3
 2
-2
 0
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : サンプルコード中で未定義動作をしていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/erase.html"/>
      <id>a6c9e227b387d2aa8631acc1df6f78468d690702:reference/map/multimap/erase.md</id>
      <updated>2023-06-22T16:41:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/erase.md b/reference/map/multimap/erase.md
index f52bcb6cf..47d878c4d 100644
--- a/reference/map/multimap/erase.md
+++ b/reference/map/multimap/erase.md
@@ -99,9 +99,6 @@ int main()
   m.erase(1);
   std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
 
-  m.erase(5);
-  std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
-
   m.erase(m.begin(), m.end());
   std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
 
@@ -118,7 +115,6 @@ int main()
 ```
 3
 2
-2
 0
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : サンプルコード中で未定義動作をしていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/erase.html"/>
      <id>a6c9e227b387d2aa8631acc1df6f78468d690702:reference/set/multiset/erase.md</id>
      <updated>2023-06-22T16:41:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/erase.md b/reference/set/multiset/erase.md
index f8cd9641c..4ed6d8977 100644
--- a/reference/set/multiset/erase.md
+++ b/reference/set/multiset/erase.md
@@ -99,9 +99,6 @@ int main()
   c.erase(10);
   std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
 
-  c.erase(5);
-  std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
-
   c.erase(c.begin(), c.end());
   std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
 }
@@ -116,7 +113,6 @@ int main()
 ```
 3
 1
-1
 0
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : サンプルコード中で未定義動作をしていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/set/set/erase.html"/>
      <id>a6c9e227b387d2aa8631acc1df6f78468d690702:reference/set/set/erase.md</id>
      <updated>2023-06-22T16:41:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/erase.md b/reference/set/set/erase.md
index 683180d57..2b3f85a0e 100644
--- a/reference/set/set/erase.md
+++ b/reference/set/set/erase.md
@@ -99,9 +99,6 @@ int main()
   c.erase(10);
   std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
 
-  c.erase(5);
-  std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
-
   c.erase(c.begin(), c.end());
   std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
 }
@@ -116,7 +113,6 @@ int main()
 ```
 3
 2
-2
 0
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- map / setのextract : C++23でのheterogeneousなオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/map/map/extract.html"/>
      <id>6eaa82d487e3c732fa17de04e4bf624125036174:reference/map/map/extract.md</id>
      <updated>2023-06-22T16:34:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/extract.md b/reference/map/map/extract.md
index 07df0c89b..d181eed22 100644
--- a/reference/map/map/extract.md
+++ b/reference/map/map/extract.md
@@ -6,13 +6,20 @@
 * cpp17[meta cpp]
 
 ```cpp
-node_type extract(const_iterator position); (1)
-node_type extract(const key_type&amp;amp; x);       (2)
+node_type extract(const_iterator position); // (1) C++17
+
+node_type extract(const key_type&amp;amp; x);       // (2) C++17
+
+template &amp;lt;class K&amp;gt;
+node_type extract(K&amp;amp;&amp;amp; x);                   // (3) C++23
 ```
 
 ## 概要
-(1) `position`が指すノードを切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を返す。  
-(2) `x`と等価なキーが見つかった場合、`x`が指すノードを切り離し、その要素を所有するノードハンドルを返す。それ以外の場合は空のノードハンドルを返す。 
+指定された要素を`*this`から切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を取得する。
+
+- (1) : `position`が指すノードを切り離す
+- (2) : `x`と等価なキーをもつノードを切り離す
+- (3) : `key_type`と比較可能な`x`と等価なキーをもつノードを切り離す
 
 
 ## 戻り値
@@ -20,13 +27,13 @@ node_type extract(const key_type&amp;amp; x);       (2)
 
 
 ## 計算量
-(1) 償却定数時間  
-(2) `map a;`のとき、log(a.size())
+- (1) : 償却定数時間
+- (2), (3) : 要素数を`N`として、`log(N)`
 
 
 ## 備考
-`extract`は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる。
-また、`extract`は再確保なしでマップ要素のキーを変更することができる。 
+- この関数は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる
+- この関数は、再確保なしでマップ要素のキーを変更することができる
 
 
 ## 例
@@ -96,4 +103,5 @@ m2 :
 
 ## 参照
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; extract(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- map / setのextract : C++23でのheterogeneousなオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/extract.html"/>
      <id>6eaa82d487e3c732fa17de04e4bf624125036174:reference/map/multimap/extract.md</id>
      <updated>2023-06-22T16:34:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/extract.md b/reference/map/multimap/extract.md
index ba164ebf2..280b5cee4 100644
--- a/reference/map/multimap/extract.md
+++ b/reference/map/multimap/extract.md
@@ -6,27 +6,34 @@
 * cpp17[meta cpp]
 
 ```cpp
-node_type extract(const_iterator position); (1)
-node_type extract(const key_type&amp;amp; x);       (2)
+node_type extract(const_iterator position); // (1) C++17
+
+node_type extract(const key_type&amp;amp; x);       // (2) C++17
+
+template &amp;lt;class K&amp;gt;
+node_type extract(K&amp;amp;&amp;amp; x);                   // (3) C++23
 ```
 
 ## 概要
-(1) `position`が指すノードを切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を返す。  
-(2) `x`と等価なキーが見つかった場合、`x`が指す最初の要素を持つノードを切り離し、その要素を所有するノードハンドルを返す。それ以外の場合は空のノードハンドルを返す。
+指定された要素を`*this`から切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を取得する。
+
+- (1) : `position`が指すノードを切り離す
+- (2) : `x`と等価なキーをもつノードをすべて切り離す
+- (3) : `key_type`と比較可能な`x`と等価なキーをもつノードをすべて切り離す
 
 
 ## 戻り値
-要素を所有するノードハンドル。ただし、オーバーロード(2)の場合は空のノードハンドルの可能性がある。
+要素を所有するノードハンドル。ただし、オーバーロード(2), (3)の場合は空のノードハンドルの可能性がある。
 
 
 ## 計算量
-(1) 償却定数時間  
-(2) log((*this).size())
+- (1) : 償却定数時間
+- (2), (3) : 要素数を`N`として、`log(N)`
 
 
 ## 備考
-`extract`は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる。
-また、`extract`は再確保なしでマップ要素のキーを変更することができる。 
+- この関数は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる
+- この関数は、再確保なしでマップ要素のキーを変更することができる
 
 
 ## 例
@@ -96,4 +103,5 @@ m2 :
 
 ## 参照
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; extract(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- map / setのextract : C++23でのheterogeneousなオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/extract.html"/>
      <id>6eaa82d487e3c732fa17de04e4bf624125036174:reference/set/multiset/extract.md</id>
      <updated>2023-06-22T16:34:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/extract.md b/reference/set/multiset/extract.md
index 468599150..960f6ac4e 100644
--- a/reference/set/multiset/extract.md
+++ b/reference/set/multiset/extract.md
@@ -6,27 +6,35 @@
 * cpp17[meta cpp]
 
 ```cpp
-node_type extract(const_iterator position); (1)
-node_type extract(const key_type&amp;amp; x);       (2)
+node_type extract(const_iterator position); // (1) C++17
+
+node_type extract(const key_type&amp;amp; x);       // (2) C++17
+
+template &amp;lt;class K&amp;gt;
+node_type extract(K&amp;amp;&amp;amp; x);                   // (3) C++23
 ```
 
 ## 概要
-(1) `position`が指すノードを切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を返す。  
-(2) `x`と等価なキーが見つかった場合、`x`が指す最初の要素を持つノードを切り離し、その要素を所有するノードハンドルを返す。それ以外の場合は空のノードハンドルを返す。
+指定された要素を`*this`から切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を取得する。
+
+- (1) : `position`が指すノードを切り離す
+- (2) : `x`と等価なキーをもつノードをすべて切り離す
+- (3) : `key_type`と比較可能な`x`と等価なキーをもつノードをすべて切り離す
 
 
 ## 戻り値
-要素を所有するノードハンドル。ただし、オーバーロード(2)の場合は空のノードハンドルの可能性がある。
+要素を所有するノードハンドル。ただし、オーバーロード(2), (3)の場合は空のノードハンドルの可能性がある。
 
 
 ## 計算量
-(1) 償却定数時間  
-(2) log((*this).size())
+- (1) : 償却定数時間
+- (2), (3) : 要素数を`N`として、`log(N)`
 
 
 ## 備考
-`extract`は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる。
-また、`extract`は、ムーブオンリーオブジェクトを`multiset`から取り出すことができる。
+- この関数は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる
+- この関数は、再確保なしでマップ要素のキーを変更することができる
+
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -132,4 +140,5 @@ s2 = { 1, 2 }
 
 ## 参照
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; extract(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- map / setのextract : C++23でのheterogeneousなオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/set/set/extract.html"/>
      <id>6eaa82d487e3c732fa17de04e4bf624125036174:reference/set/set/extract.md</id>
      <updated>2023-06-22T16:34:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/extract.md b/reference/set/set/extract.md
index 8021f6bfb..43a428d31 100644
--- a/reference/set/set/extract.md
+++ b/reference/set/set/extract.md
@@ -6,27 +6,35 @@
 * cpp17[meta cpp]
 
 ```cpp
-node_type extract(const_iterator position); (1)
-node_type extract(const key_type&amp;amp; x);       (2)
+node_type extract(const_iterator position); // (1) C++17
+
+node_type extract(const key_type&amp;amp; x);       // (2) C++17
+
+template &amp;lt;class K&amp;gt;
+node_type extract(K&amp;amp;&amp;amp; x);                   // (3) C++23
 ```
 
 ## 概要
-(1) `position`が指すノードを切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を返す。  
-(2) `x`と等価なキーが見つかった場合、`x`が指すノードを切り離し、その要素を所有するノードハンドルを返す。それ以外の場合は空のノードハンドルを返す。 
+指定された要素を`*this`から切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を取得する。
+
+- (1) : `position`が指すノードを切り離す
+- (2) : `x`と等価なキーをもつノードを切り離す
+- (3) : `key_type`と比較可能な`x`と等価なキーをもつノードを切り離す
 
 
 ## 戻り値
-要素を所有するノードハンドル。ただし、オーバーロード(2)の場合は空のノードハンドルの可能性がある。
+要素を所有するノードハンドル。ただし、オーバーロード(2), (3)の場合は空のノードハンドルの可能性がある。
 
 
 ## 計算量
-(1) 償却定数時間  
-(2) log((*this).size())
+- (1) : 償却定数時間
+- (2), (3) : 要素数を`N`として、`log(N)`
 
 
 ## 備考
-`extract`は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる。
-また、`extract`は、ムーブオンリーオブジェクトを`set`から取り出すことができる。
+- この関数は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる
+- この関数は、再確保なしでマップ要素のキーを変更することができる
+
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -132,4 +140,5 @@ s2 = { 1, 2 }
 
 ## 参照
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; extract(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_map/unordered_map/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/erase.md b/reference/unordered_map/unordered_map/erase.md
index cfbdeb6f0..ba3dbaa80 100644
--- a/reference/unordered_map/unordered_map/erase.md
+++ b/reference/unordered_map/unordered_map/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要。
-- (2) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
-- (3) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
+- (4) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -94,10 +96,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_map&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, um);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, um);
 
     auto count1 = um.erase(&amp;#34;5th&amp;#34;);
     auto count2 = um.erase(&amp;#34;8th&amp;#34;);
@@ -107,10 +109,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_map&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, um);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, um);
 
     auto it1 = std::next(um.cbegin());
     auto it2 = std::next(it1, 2);
@@ -135,12 +137,12 @@ argument: (3rd, 3)
 return value: (1st, 1)
 after : (9th, 9), (7th, 7), (5th, 5), (1st, 1), 
 
-(2) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
+(3) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 argument: 5th, 8th
 return value: 1, 0
 after : (9th, 9), (7th, 7), (3rd, 3), (1st, 1), 
 
-(3) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
+(4) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 arguments: (7th, 7), (3rd, 3)
 return value: (3rd, 3)
 after : (9th, 9), (3rd, 3), (1st, 1), 
@@ -200,10 +202,6 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 
-## 参照
-- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
-
-
 ## 関連項目
 
 | 名前                                | 説明                                                   |
@@ -214,3 +212,8 @@ int main()
 | [`clear`](clear.md)               | 全要素の削除                                           |
 | [`swap`](swap.md)                 | 内容の交換                                             |
 
+
+## 参照
+- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_map/unordered_multimap/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/erase.md b/reference/unordered_map/unordered_multimap/erase.md
index 804e96d93..e93bb2ddf 100644
--- a/reference/unordered_map/unordered_multimap/erase.md
+++ b/reference/unordered_map/unordered_multimap/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。
-- (2) : 削除した要素数。
-- (3) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。
+- (4) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -94,10 +96,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_multimap&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, {&amp;#34;3rd&amp;#34;, 33}, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, um);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, um);
 
     auto count1 = um.erase(&amp;#34;5th&amp;#34;);
     auto count2 = um.erase(&amp;#34;8th&amp;#34;);
@@ -108,10 +110,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_multimap&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, {&amp;#34;3rd&amp;#34;, 33}, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, um);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, um);
 
     auto it1 = std::next(um.cbegin());
     auto it2 = std::next(it1, 2);
@@ -136,12 +138,12 @@ argument: (3rd, 33)
 return value: (3rd, 3)
 after : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 
-(2) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
+(3) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
 argument: 5th, 8th, 3rd
 return value: 1, 0, 2
 after : (9th, 9), (7th, 7), (1st, 1), 
 
-(3) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
+(4) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
 arguments: (7th, 7), (3rd, 33)
 return value: (3rd, 33)
 after : (9th, 9), (3rd, 33), (3rd, 3), (1st, 1), 
@@ -215,5 +217,5 @@ int main()
 ## 参照
 - [LWG Issue 518. Are `insert` and `erase` stable for `unordered_multiset` and `unordered_multimap`?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518)
     - 安定性の保証が規定された経緯のレポート
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_set/unordered_multiset/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/erase.md b/reference/unordered_set/unordered_multiset/erase.md
index 88cb5415f..b32770c2f 100644
--- a/reference/unordered_set/unordered_multiset/erase.md
+++ b/reference/unordered_set/unordered_multiset/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。
-- (2) : 削除した要素数。
-- (3) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。
+- (4) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -86,10 +88,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_multiset&amp;lt;int&amp;gt; ums{ 1, 3, 5, 7, 9, 3, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, ums);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, ums);
 
     auto count1 = ums.erase(5);
     auto count2 = ums.erase(8);
@@ -100,10 +102,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_multiset&amp;lt;int&amp;gt; ums{ 1, 3, 5, 7, 9, 3, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, ums);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, ums);
 
     auto it1 = std::next(ums.cbegin());
     auto it2 = std::next(it1, 2);
@@ -127,12 +129,12 @@ argument: 1
 return value: 3
 after : 9 7 5 3 3
 
-(2) erase(const value_type&amp;amp;) before : 9 7 5 1 3 3
+(3) erase(const value_type&amp;amp;) before : 9 7 5 1 3 3
 argument: 5, 8, 3
 return value: 1, 0, 2
 after : 9 7 1
 
-(3) erase(const_iterator, const_iterator) before : 9 7 5 1 3 3
+(4) erase(const_iterator, const_iterator) before : 9 7 5 1 3 3
 arguments: 7, 1
 return value: 1
 after : 9 1 3 3
@@ -202,5 +204,5 @@ int main()
 ## 参照
 - [LWG Issue 518. Are `insert` and `erase` stable for `unordered_multiset` and `unordered_multimap`?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518)
     - 安定性の保証が規定された経緯のレポート
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_set/unordered_set/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/erase.md b/reference/unordered_set/unordered_set/erase.md
index 8a6c214ac..cab1403e8 100644
--- a/reference/unordered_set/unordered_set/erase.md
+++ b/reference/unordered_set/unordered_set/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。
-- (2) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
-- (3) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
+- (4) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -86,10 +88,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 1, 3, 5, 7, 9, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, us);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, us);
 
     auto count1 = us.erase(5);
     auto count2 = us.erase(8);
@@ -99,10 +101,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 1, 3, 5, 7, 9, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, us);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, us);
 
     auto it1 = std::next(us.cbegin());
     auto it2 = std::next(it1, 2);
@@ -126,12 +128,12 @@ argument: 3
 return value: 1
 after : 9 7 5 1
 
-(2) erase(const value_type&amp;amp;) before : 9 7 5 3 1
+(3) erase(const value_type&amp;amp;) before : 9 7 5 3 1
 argument: 5, 8
 return value: 1, 0
 after : 9 7 3 1
 
-(3) erase(const_iterator, const_iterator) before : 9 7 5 3 1
+(4) erase(const_iterator, const_iterator) before : 9 7 5 3 1
 arguments: 7, 3
 return value: 3
 after : 9 3 1
@@ -186,9 +188,6 @@ int main()
 - [ICC](/implementation.md#icc): ?
 - [Visual C++](/implementation.md#visual_cpp): ?
 
-## 参照
-- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
-
 
 ## 関連項目
 
@@ -200,3 +199,8 @@ int main()
 | [`clear`](clear.md)               | 全要素の削除                                           |
 | [`swap`](swap.md)                 | 内容の交換                                             |
 
+
+## 参照
+- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>