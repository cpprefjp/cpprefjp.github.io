<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-30T03:55:14.194692</updated>
  <id>dace0b40-ba43-4da6-af8c-bd563607799f</id>

  
    <entry>
      <title>clear -- Merge pull request #1450 from math-hiyoko/complexity_of_hash_table_clear</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/clear.html"/>
      <id>773e04a8fa8d232d4b56020467c2d4d0b85f48cf:reference/unordered_map/unordered_map/clear.md</id>
      <updated>2025-05-30T12:51:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/clear.md b/reference/unordered_map/unordered_map/clear.md
index 1d0ce4f0c..34eaefc58 100644
--- a/reference/unordered_map/unordered_map/clear.md
+++ b/reference/unordered_map/unordered_map/clear.md
@@ -36,6 +36,24 @@ void clear() noexcept;
 ## 計算量
 本関数呼び出し前のコンテナの要素数（[`size`](size.md)`()`）に比例
 
+### 計算量に関する備考
+多くの実装（GCC libstdc++, LLVM libc++ など）は
+
+1. 全ての要素を走査して各要素を破棄
+2. 全てのバケットを走査して各バケットの状態をリセット
+
+という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() *` [`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
+規格の計算量の要件は要素数 `size()` に線形となっているが、規格がコンテナに対して定義する計算量は「コンテナに格納している要素に対する操作の数の計算量」であるためバケットの走査などを考慮していない。
+
+
+## 備考
+- `clear()` がバケット数([`bucket_count`](bucket_count.md)`()`)を縮小することを規格は要求していない。
+実装によっては `clear()` 後もバケット配列が維持され、動的メモリが残る場合がある。
+- バケット数を初期状態まで縮小させたいときには `clear()` の代わりに以下のように操作する
+    ```cpp
+    um = std::unordered_map&amp;lt;std::string, int&amp;gt;();
+    ```
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- Merge pull request #1450 from math-hiyoko/complexity_of_hash_table_clear</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/clear.html"/>
      <id>773e04a8fa8d232d4b56020467c2d4d0b85f48cf:reference/unordered_map/unordered_multimap/clear.md</id>
      <updated>2025-05-30T12:51:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/clear.md b/reference/unordered_map/unordered_multimap/clear.md
index e4d252581..9480119e0 100644
--- a/reference/unordered_map/unordered_multimap/clear.md
+++ b/reference/unordered_map/unordered_multimap/clear.md
@@ -36,6 +36,24 @@ void clear() noexcept;
 ## 計算量
 本関数呼び出し前のコンテナの要素数（[`size`](size.md)`()`）に比例
 
+### 計算量に関する備考
+多くの実装（GCC libstdc++, LLVM libc++ など）は
+
+1. 全ての要素を走査して各要素を破棄
+2. 全てのバケットを走査して各バケットの状態をリセット
+
+という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() *` [`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
+規格の計算量の要件は要素数 `size()` に線形となっているが、規格がコンテナに対して定義する計算量は「コンテナに格納している要素に対する操作の数の計算量」であるためバケットの走査などを考慮していない。
+
+
+## 備考
+- `clear()` がバケット数([`bucket_count`](bucket_count.md)`()`)を縮小することを規格は要求していない。
+実装によっては `clear()` 後もバケット配列が維持され、動的メモリが残る場合がある。
+- バケット数を初期状態まで縮小させたいときには `clear()` の代わりに以下のように操作する
+    ```cpp
+    um = std::unordered_multimap&amp;lt;std::string, int&amp;gt;();
+    ```
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- Merge pull request #1450 from math-hiyoko/complexity_of_hash_table_clear</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/clear.html"/>
      <id>773e04a8fa8d232d4b56020467c2d4d0b85f48cf:reference/unordered_set/unordered_multiset/clear.md</id>
      <updated>2025-05-30T12:51:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/clear.md b/reference/unordered_set/unordered_multiset/clear.md
index 8ba2f6e24..f19039fd3 100644
--- a/reference/unordered_set/unordered_multiset/clear.md
+++ b/reference/unordered_set/unordered_multiset/clear.md
@@ -36,6 +36,24 @@ void clear() noexcept;
 ## 計算量
 本関数呼び出し前のコンテナの要素数（[`size`](size.md)`()`）に比例
 
+### 計算量に関する備考
+多くの実装（GCC libstdc++, LLVM libc++ など）は
+
+1. 全ての要素を走査して各要素を破棄
+2. 全てのバケットを走査して各バケットの状態をリセット
+
+という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() *` [`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
+規格の計算量の要件は要素数 `size()` に線形となっているが、規格がコンテナに対して定義する計算量は「コンテナに格納している要素に対する操作の数の計算量」であるためバケットの走査などを考慮していない。
+
+
+## 備考
+- `clear()` がバケット数([`bucket_count`](bucket_count.md)`()`)を縮小することを規格は要求していない。
+実装によっては `clear()` 後もバケット配列が維持され、動的メモリが残る場合がある。
+- バケット数を初期状態まで縮小させたいときには `clear()` の代わりに以下のように操作する
+    ```cpp
+    ums = std::unordered_multiset&amp;lt;int&amp;gt;();
+    ```
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- Merge pull request #1450 from math-hiyoko/complexity_of_hash_table_clear</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/clear.html"/>
      <id>773e04a8fa8d232d4b56020467c2d4d0b85f48cf:reference/unordered_set/unordered_set/clear.md</id>
      <updated>2025-05-30T12:51:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/clear.md b/reference/unordered_set/unordered_set/clear.md
index e54f8a9f4..4aabb8fe9 100644
--- a/reference/unordered_set/unordered_set/clear.md
+++ b/reference/unordered_set/unordered_set/clear.md
@@ -36,6 +36,24 @@ void clear() noexcept;
 ## 計算量
 本関数呼び出し前のコンテナの要素数（[`size`](size.md)`()`）に比例
 
+### 計算量に関する備考
+多くの実装（GCC libstdc++, LLVM libc++ など）は
+
+1. 全ての要素を走査して各要素を破棄
+2. 全てのバケットを走査して各バケットの状態をリセット
+
+という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() *` [`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
+規格の計算量の要件は要素数 `size()` に線形となっているが、規格がコンテナに対して定義する計算量は「コンテナに格納している要素に対する操作の数の計算量」であるためバケットの走査などを考慮していない。
+
+
+## 備考
+- `clear()` がバケット数([`bucket_count`](bucket_count.md)`()`)を縮小することを規格は要求していない。
+実装によっては `clear()` 後もバケット配列が維持され、動的メモリが残る場合がある。
+- バケット数を初期状態まで縮小させたいときには `clear()` の代わりに以下のように操作する
+    ```cpp
+    us = std::unordered_set&amp;lt;int&amp;gt;();
+    ```
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_istream_view -- basic_istream_view : メンバ関数を追加 #713</title>
      <link href="https://cpprefjp.github.io/reference/ranges/basic_istream_view.html"/>
      <id>0d8274fb2864796421c8f9bb995382a00906040d:reference/ranges/basic_istream_view.md</id>
      <updated>2025-05-30T12:45:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/basic_istream_view.md b/reference/ranges/basic_istream_view.md
index 9008e803c..ee8f80af0 100644
--- a/reference/ranges/basic_istream_view.md
+++ b/reference/ranges/basic_istream_view.md
@@ -69,9 +69,17 @@ concept stream-extractable = requires(basic_istream&amp;lt;CharT, Traits&amp;gt;&amp;amp; is, Val&amp;amp; t)
 
 | 名前                                                     | 説明                             | 対応バージョン |
 |----------------------------------------------------------|----------------------------------|----------------|
-| [`(constructor)`](basic_istream_view/op_constructor.md.nolink)  | コンストラクタ                   | C++20          |
-| [`begin`](basic_istream_view/begin.md.nolink)                   | ストリームから値を1つ読み、それを指すイテレータを取得する   | C++20          |
-| [`end`](basic_istream_view/end.md.nolink)                       | 番兵を取得する                   | C++20          |
+| [`(constructor)`](basic_istream_view/op_constructor.md)  | コンストラクタ                   | C++20          |
+| [`begin`](basic_istream_view/begin.md)                   | ストリームから値を1つ読み、それを指すイテレータを取得する   | C++20          |
+| [`end`](basic_istream_view/end.md)                       | 番兵を取得する                   | C++20          |
+
+## 継承しているメンバ関数
+
+| 名前                                         | 説明                              | 対応バージョン |
+|----------------------------------------------|------------------------------ ----|----------------|
+| [`cbegin`](view_interface/cbegin.md)         | 定数イテレータを取得する          | C++23          |
+| [`cend`](view_interface/cend.md)             | 定数イテレータ（番兵）を取得する  | C++23          |
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>begin -- basic_istream_view : メンバ関数を追加 #713</title>
      <link href="https://cpprefjp.github.io/reference/ranges/basic_istream_view/begin.html"/>
      <id>0d8274fb2864796421c8f9bb995382a00906040d:reference/ranges/basic_istream_view/begin.md</id>
      <updated>2025-05-30T12:45:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/basic_istream_view/begin.md b/reference/ranges/basic_istream_view/begin.md
new file mode 100644
index 000000000..237814e8a
--- /dev/null
+++ b/reference/ranges/basic_istream_view/begin.md
@@ -0,0 +1,56 @@
+# begin
+* ranges[meta header]
+* std::ranges[meta namespace]
+* basic_istream_view[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+constexpr auto begin(); // (1) C++20
+```
+
+## 概要
+
+ストリームから値を1つ読み、それを指すイテレータを取得する。
+
+
+## 効果
+以下と等価：
+
+```cpp
+*stream_ &amp;gt;&amp;gt; value_;
+return iterator{*this};
+```
+
+
+## 例
+
+```cpp example
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;sstream&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main() {
+  auto iss = std::istringstream{&amp;#34;1 2 3 4 5&amp;#34;};
+  auto r = std::views::istream&amp;lt;int&amp;gt;(iss);
+  auto it = r.begin();
+  std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+}
+```
+* begin[color ff0000]
+
+### 出力
+
+```
+1
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 13.0.0 [mark verified]
+- [GCC](/implementation.md#gcc): 10.1.0 [mark verified]
+- [ICC](/implementation.md#icc): ?
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10 [mark verified]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>end -- basic_istream_view : メンバ関数を追加 #713</title>
      <link href="https://cpprefjp.github.io/reference/ranges/basic_istream_view/end.html"/>
      <id>0d8274fb2864796421c8f9bb995382a00906040d:reference/ranges/basic_istream_view/end.md</id>
      <updated>2025-05-30T12:45:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/basic_istream_view/end.md b/reference/ranges/basic_istream_view/end.md
new file mode 100644
index 000000000..be86e677f
--- /dev/null
+++ b/reference/ranges/basic_istream_view/end.md
@@ -0,0 +1,60 @@
+# end
+* ranges[meta header]
+* std::ranges[meta namespace]
+* basic_istream_view[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+constexpr default_sentinel_t end() const noexcept; // (1) C++20
+```
+
+## 概要
+
+番兵を取得する。
+
+
+## 戻り値
+以下と等価：
+
+```cpp
+return default_sentinel;
+```
+
+
+## 例
+
+```cpp example
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;sstream&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main() {
+  auto iss = std::istringstream{&amp;#34;1 2 3 4 5&amp;#34;};
+  auto r = std::views::istream&amp;lt;int&amp;gt;(iss);
+  auto it = r.begin();
+  auto last = r.end();
+
+  for (; it != last; ++it) {
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+}
+```
+* end[color ff0000]
+* begin()[link begin.md]
+
+### 出力
+
+```
+1 2 3 4 5 
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 13.0.0 [mark verified]
+- [GCC](/implementation.md#gcc): 10.1.0 [mark verified]
+- [ICC](/implementation.md#icc): ?
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10 [mark verified]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- basic_istream_view : メンバ関数を追加 #713</title>
      <link href="https://cpprefjp.github.io/reference/ranges/basic_istream_view/op_constructor.html"/>
      <id>0d8274fb2864796421c8f9bb995382a00906040d:reference/ranges/basic_istream_view/op_constructor.md</id>
      <updated>2025-05-30T12:45:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/basic_istream_view/op_constructor.md b/reference/ranges/basic_istream_view/op_constructor.md
new file mode 100644
index 000000000..c37f9b480
--- /dev/null
+++ b/reference/ranges/basic_istream_view/op_constructor.md
@@ -0,0 +1,52 @@
+# コンストラクタ
+* ranges[meta header]
+* std::ranges[meta namespace]
+* basic_istream_view[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+constexpr explicit
+  basic_istream_view(basic_istream&amp;lt;CharT, Traits&amp;gt;&amp;amp; stream); // (1) C++20
+```
+
+## 概要
+[`basic_istream_view`](../basic_istream_view.md)オブジェクトを構築する。
+
+- (1) : [`basic_istream`](/reference/istream/basic_istream.md)の参照を受け取るコンストラクタ
+
+
+## 効果
+
+- (1) : [`addressof`](/reference/memory/addressof.md)`(stream)`をメンバ変数`stream_`に保持する
+
+
+## 例
+```cpp example
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;sstream&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main() {
+  auto iss = std::istringstream{&amp;#34;1 2 3 4 5&amp;#34;};
+
+  for (int i : std::views::istream&amp;lt;int&amp;gt;(iss)) {
+    std::cout &amp;lt;&amp;lt; i;
+  }
+}
+```
+
+### 出力
+```
+12345
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 13.0.0 [mark verified]
+- [GCC](/implementation.md#gcc): 10.1.0 [mark verified]
+- [ICC](/implementation.md#icc): ?
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10 [mark verified]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stopped_as_error -- execution/stopped_as_error: 効果を修正 (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/stopped_as_error.html"/>
      <id>c658129825465e613e0ed82e5af2f5ae1379365a:reference/execution/execution/stopped_as_error.md</id>
      <updated>2025-05-30T10:54:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/stopped_as_error.md b/reference/execution/execution/stopped_as_error.md
index c815f9729..678417fc2 100644
--- a/reference/execution/execution/stopped_as_error.md
+++ b/reference/execution/execution/stopped_as_error.md
@@ -32,7 +32,7 @@ transform_sender(get-domain-early(sndr), make-sender(stopped_as_error, err, sndr
 
 
 ### Senderアルゴリズムタグ `stopped_as_error`
-説明用の式`sndr`と`env`に対して、型`Sndr`を`decltype((sndr))`、型`Env`を`decltype((env))`とする。[`sender-for`](sender-for.md)`&amp;lt;Sndr, stopped_as_error_t&amp;gt; == false`、もしくは[`single-sender-value-type`](single-sender-value-type.md.nolink)`&amp;lt;Sndr, Env&amp;gt;`が不適格または`void`のとき、式`stopped_as_error.transform_sender(sndr, env)`は不適格となる。
+説明用の式`sndr`と`env`に対して、型`Sndr`を`decltype((sndr))`、型`Env`を`decltype((env))`とする。[`sender-for`](sender-for.md)`&amp;lt;Sndr, stopped_as_error_t&amp;gt; == false`のとき、式`stopped_as_error.transform_sender(sndr, env)`は不適格となる。
 
 そうでなければ、式`stopped_as_error.transform_sender(sndr, env)`は下記と等価。
 
@@ -108,7 +108,7 @@ int main()
     ex::sender auto snd0 = MySender{-1};
     ex::sender auto snd1 = ex::stopped_as_error(snd0, MyStoppedError{});
     try {
-      auto result = std::this_thread::sync_wait(snd1).value();
+      auto [result] = std::this_thread::sync_wait(snd1).value();
       std::println(&amp;#34;(int) {}&amp;#34;, result);
     } catch (MyStoppedError) {
       std::println(&amp;#34;stopped&amp;#34;);
@@ -120,7 +120,7 @@ int main()
       MySender{-1}
       | ex::stopped_as_error(MyStoppedError{});
     try {
-      auto result = std::this_thread::sync_wait(sndr).value();
+      auto [result] = std::this_thread::sync_wait(sndr).value();
       std::println(&amp;#34;(int) {}&amp;#34;, result);
     } catch (MyStoppedError) {
       std::println(&amp;#34;stopped&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- execution: stopped_as_{error,optional} (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>b272152786f1bf6578039bc74ac6d7e05a9c6aed:reference/execution/execution.md</id>
      <updated>2025-05-30T10:42:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index ad7cf4d46..16b4448d7 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -126,8 +126,8 @@ namespace std::execution {
 | [`execution::when_all`](execution/when_all.md) | 全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::when_all_with_variant`](execution/when_all_with_variant.md) | 複数の値完了シグネチャをもつ全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::into_variant`](execution/into_variant.md) | 複数の値完了シグネチャを単一[`variant`](/reference/variant/variant.md)型の値完了シグネチャに変換 (customization point object) | C++26 |
-| [`execution::stopped_as_optional`](execution/stopped_as_optional.md.nolink) | 入力Senderの停止完了を[`optional`](/reference/optional/optional.md)型の値完了に変換 (customization point object) | C++26 |
-| [`execution::stopped_as_error`](execution/stopped_as_error.md.nolink) | 入力Senderの停止完了をエラー完了に変換 (customization point object) | C++26 |
+| [`execution::stopped_as_optional`](execution/stopped_as_optional.md) | 入力Senderの停止完了を空の[`optional`](/reference/optional/optional.md)値完了に変換 (customization point object) | C++26 |
+| [`execution::stopped_as_error`](execution/stopped_as_error.md) | 入力Senderの停止完了をエラー完了に変換 (customization point object) | C++26 |
 
 ### Senderコンシューマ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stopped_as_error -- execution: stopped_as_{error,optional} (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/stopped_as_error.html"/>
      <id>b272152786f1bf6578039bc74ac6d7e05a9c6aed:reference/execution/execution/stopped_as_error.md</id>
      <updated>2025-05-30T10:42:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/stopped_as_error.md b/reference/execution/execution/stopped_as_error.md
new file mode 100644
index 000000000..c815f9729
--- /dev/null
+++ b/reference/execution/execution/stopped_as_error.md
@@ -0,0 +1,167 @@
+# stopped_as_error
+* execution[meta header]
+* cpo[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  struct stopped_as_error_t { unspecified };
+  inline constexpr stopped_as_error_t stopped_as_error{};
+}
+```
+* unspecified[italic]
+
+## 概要
+`stopped_as_error`は、入力[Sender](sender.md)の[停止完了](set_stopped.md)をカスタムエラー型の[エラー完了](set_error.md)にマップするSenderアダプタである。
+
+`stopped_as_error`は[パイプ可能Senderアダプタオブジェクト](sender_adaptor_closure.md)であり、パイプライン記法をサポートする。
+
+
+## 効果
+説明用の式`sndr`と`err`に対して、型`Sndr`を`decltype((sndr))`、型`Err`を`decltype((err))`とする。`Sndr`が[`sender`](sender.md)を満たさない、もしくは`Err`が[`moveable-value`](../movable-value.md)を満たさないとき、呼び出し式`stopped_as_error(sndr, err)`は不適格となる。
+
+そうでなければ、呼び出し式`stopped_as_error(sndr, err)`は`sndr`が1回だけ評価されることを除いて、下記と等価。
+
+```cpp
+transform_sender(get-domain-early(sndr), make-sender(stopped_as_error, err, sndr))
+```
+* transform_sender[link transform_sender.md]
+* get-domain-early[link get-domain-early.md]
+* make-sender[link make-sender.md]
+
+
+### Senderアルゴリズムタグ `stopped_as_error`
+説明用の式`sndr`と`env`に対して、型`Sndr`を`decltype((sndr))`、型`Env`を`decltype((env))`とする。[`sender-for`](sender-for.md)`&amp;lt;Sndr, stopped_as_error_t&amp;gt; == false`、もしくは[`single-sender-value-type`](single-sender-value-type.md.nolink)`&amp;lt;Sndr, Env&amp;gt;`が不適格または`void`のとき、式`stopped_as_error.transform_sender(sndr, env)`は不適格となる。
+
+そうでなければ、式`stopped_as_error.transform_sender(sndr, env)`は下記と等価。
+
+```cpp
+auto&amp;amp;&amp;amp; [_, err, child] = sndr;
+using E = decltype(auto(err));
+return let_stopped(
+    std::forward_like&amp;lt;Sndr&amp;gt;(child),
+    [err = std::forward_like&amp;lt;Sndr&amp;gt;(err)]() mutable noexcept(is_nothrow_move_constructible_v&amp;lt;E&amp;gt;) {
+      return just_error(std::move(err));
+    });
+```
+* let_stopped[link let_stopped.md.nolink]
+* just_error[link just_error.md]
+* is_nothrow_move_constructible_v[link /reference/type_traits/is_nothrow_move_constructible.md]
+* std::move[link /reference/utility/move.md]
+
+
+## カスタマイゼーションポイント
+Senderアルゴリズム構築時に、[Sender](sender.md)`sndr`に[関連付けられた実行ドメイン](get-domain-early.md)に対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](default_domain.md)では無変換。
+
+[Receiver](receiver.md)との[接続(connect)](connect.md)時に、[関連付けられた実行ドメイン](get-domain-late.md)に対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](default_domain.md)では`stopped_as_error.transform_sender(sndr, env)`が呼ばれ、前述仕様通りのSenderへと変換される。
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+// MySenderは下記いずれかの完了操作を行う
+//   値完了   set_value(int)
+//   停止完了 set_stopped()
+struct MySender {
+  using sender_concept = ex::sender_t;
+  using completion_signatures = ex::completion_signatures&amp;lt;
+    ex::set_value_t(int),
+    ex::set_stopped_t()
+  &amp;gt;;
+
+  template &amp;lt;typename Rcvr&amp;gt;
+  struct state {
+    using operation_state_concept = ex::operation_state_t;
+
+    state(Rcvr rcvr, int val)
+      : rcvr_{std::move(rcvr)}, val_{val} {}
+
+    void start() noexcept {
+      if (0 &amp;lt; val_) {
+        ex::set_value(std::move(rcvr_), val_);
+      } else {
+        ex::set_stopped(std::move(rcvr_));
+      }
+    }
+
+    Rcvr rcvr_;
+    int val_;
+  };
+
+  template &amp;lt;typename Rcvr&amp;gt;
+  auto connect(Rcvr rcvr) noexcept {
+    return state{std::move(rcvr), val_};
+  }
+
+  int val_;
+};
+
+int main()
+{
+  { // 関数呼び出し
+    ex::sender auto snd0 = MySender{-1};
+    ex::sender auto snd1 = ex::stopped_as_error(snd0, MyStoppedError{});
+    try {
+      auto result = std::this_thread::sync_wait(snd1).value();
+      std::println(&amp;#34;(int) {}&amp;#34;, result);
+    } catch (MyStoppedError) {
+      std::println(&amp;#34;stopped&amp;#34;);
+    }
+  }
+
+  { // パイプライン記法
+    ex::sender auto sndr =
+      MySender{-1}
+      | ex::stopped_as_error(MyStoppedError{});
+    try {
+      auto result = std::this_thread::sync_wait(sndr).value();
+      std::println(&amp;#34;(int) {}&amp;#34;, result);
+    } catch (MyStoppedError) {
+      std::println(&amp;#34;stopped&amp;#34;);
+    }
+  }
+}
+```
+* ex::stopped_as_error[color ff0000]
+* ex::sender_t[link sender.md]
+* ex::sender[link sender.md]
+* ex::completion_signatures[link completion_signatures.md]
+* ex::set_value_t[link set_value.md]
+* ex::set_value[link set_value.md]
+* ex::set_stopped_t[link set_stopped.md]
+* ex::set_stopped[link set_stopped.md]
+* ex::operation_state_t[link operation_state.md]
+* std::this_thread::sync_wait[link ../this_thread/sync_wait.md]
+* std::move[link /reference/utility/move.md]
+
+### 出力
+```
+stopped
+stopped
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution::stopped_as_optional`](stopped_as_optional.md)
+
+
+## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stopped_as_optional -- execution: stopped_as_{error,optional} (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/stopped_as_optional.html"/>
      <id>b272152786f1bf6578039bc74ac6d7e05a9c6aed:reference/execution/execution/stopped_as_optional.md</id>
      <updated>2025-05-30T10:42:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/stopped_as_optional.md b/reference/execution/execution/stopped_as_optional.md
new file mode 100644
index 000000000..1f056d35f
--- /dev/null
+++ b/reference/execution/execution/stopped_as_optional.md
@@ -0,0 +1,167 @@
+# stopped_as_optional
+* execution[meta header]
+* cpo[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  struct stopped_as_optional_t { unspecified };
+  inline constexpr stopped_as_optional_t stopped_as_optional{};
+}
+```
+* unspecified[italic]
+
+## 概要
+`stopped_as_optional`は、入力[Sender](sender.md)の[停止完了](set_stopped.md)を空の[`optional`](/reference/optional/optional.md)による[値完了](set_value.md)にマップするSenderアダプタである。入力Senderの値完了操作も[`optional`](/reference/optional/optional.md)へと変換される。
+
+`stopped_as_optional`は[パイプ可能Senderアダプタオブジェクト](sender_adaptor_closure.md)であり、パイプライン記法をサポートする。
+
+
+## 効果
+説明用の式`sndr`に対して、型`Sndr`を`decltype((sndr))`とする。呼び出し式`stopped_as_optional(sndr)`は`sndr`が1回だけ評価されることを除いて、下記と等価。
+
+```cpp
+transform_sender(get-domain-early(sndr), make-sender(stopped_as_optional, {}, sndr))
+```
+* transform_sender[link transform_sender.md]
+* get-domain-early[link get-domain-early.md]
+* make-sender[link make-sender.md]
+
+
+### Senderアルゴリズムタグ `stopped_as_optional`
+説明用の式`sndr`と`env`に対して、型`Sndr`を`decltype((sndr))`、型`Env`を`decltype((env))`とする。[`sender-for`](sender-for.md)`&amp;lt;Sndr, stopped_as_optional_t&amp;gt; == false`、もしくは[`single-sender-value-type`](single-sender-value-type.md.nolink)`&amp;lt;Sndr, Env&amp;gt;`が不適格または`void`のとき、式`stopped_as_optional.transform_sender(sndr, env)`は不適格となる。
+
+そうでなければ、式`stopped_as_optional.transform_sender(sndr, env)`は下記と等価。
+
+```cpp
+auto&amp;amp;&amp;amp; [_, _, child] = sndr;
+using V = single-sender-value-type&amp;lt;Sndr, Env&amp;gt;;
+return let_stopped(
+    then(std::forward_like&amp;lt;Sndr&amp;gt;(child),
+         []&amp;lt;class... Ts&amp;gt;(Ts&amp;amp;&amp;amp;... ts) noexcept(is_nothrow_constructible_v&amp;lt;V, Ts...&amp;gt;) {
+           return optional&amp;lt;V&amp;gt;(in_place, std::forward&amp;lt;Ts&amp;gt;(ts)...);
+         }),
+    []() noexcept { return just(optional&amp;lt;V&amp;gt;()); });
+```
+* single-sender-value-type[link single-sender-value-type.md.nolink]
+* let_stopped[link let_stopped.md.nolink]
+* then[link then.md]
+* just[link just.md]
+* is_nothrow_constructible_v[link /reference/type_traits/is_nothrow_constructible.md]
+* optional[link /reference/optional/optional.md]
+* in_place[link /reference/utility/in_place_t.md]
+
+
+## カスタマイゼーションポイント
+Senderアルゴリズム構築時に、[Sender](sender.md)`sndr`に[関連付けられた実行ドメイン](get-domain-early.md)に対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](default_domain.md)では無変換。
+
+[Receiver](receiver.md)との[接続(connect)](connect.md)時に、[関連付けられた実行ドメイン](get-domain-late.md)に対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](default_domain.md)では`stopped_as_optional.transform_sender(sndr, env)`が呼ばれ、前述仕様通りのSenderへと変換される。
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+// MySenderは下記いずれかの完了操作を行う
+//   値完了   set_value(int)
+//   停止完了 set_stopped()
+struct MySender {
+  using sender_concept = ex::sender_t;
+  using completion_signatures = ex::completion_signatures&amp;lt;
+    ex::set_value_t(int),
+    ex::set_stopped_t()
+  &amp;gt;;
+
+  template &amp;lt;typename Rcvr&amp;gt;
+  struct state {
+    using operation_state_concept = ex::operation_state_t;
+
+    state(Rcvr rcvr, int val)
+      : rcvr_{std::move(rcvr)}, val_{val} {}
+
+    void start() noexcept {
+      if (0 &amp;lt; val_) {
+        ex::set_value(std::move(rcvr_), val_);
+      } else {
+        ex::set_stopped(std::move(rcvr_));
+      }
+    }
+
+    Rcvr rcvr_;
+    int val_;
+  };
+
+  template &amp;lt;typename Rcvr&amp;gt;
+  auto connect(Rcvr rcvr) noexcept {
+    return state{std::move(rcvr), val_};
+  }
+
+  int val_;
+};
+
+int main()
+{
+  { // 関数呼び出し
+    ex::sender auto snd0 = MySender{-1};
+    ex::sender auto snd1 = ex::stopped_as_optional(snd0);
+    auto [result] = std::this_thread::sync_wait(snd1).value();
+    if (result) {
+      std::println(&amp;#34;(int) {}&amp;#34;, *result);
+    } else {
+      std::println(&amp;#34;stopped&amp;#34;);
+    }
+  }
+
+  { // パイプライン記法
+    ex::sender auto sndr = MySender{-1} | ex::stopped_as_optional();
+    auto [result] = std::this_thread::sync_wait(sndr).value();
+    if (result) {
+      std::println(&amp;#34;(int) {}&amp;#34;, *result);
+    } else {
+      std::println(&amp;#34;stopped&amp;#34;);
+    }
+  }
+}
+```
+* ex::stopped_as_optional[color ff0000]
+* ex::sender_t[link sender.md]
+* ex::sender[link sender.md]
+* ex::completion_signatures[link completion_signatures.md]
+* ex::set_value_t[link set_value.md]
+* ex::set_value[link set_value.md]
+* ex::set_stopped_t[link set_stopped.md]
+* ex::set_stopped[link set_stopped.md]
+* ex::operation_state_t[link operation_state.md]
+* std::this_thread::sync_wait[link ../this_thread/sync_wait.md]
+* std::move[link /reference/utility/move.md]
+
+### 出力
+```
+stopped
+stopped
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution::stopped_as_error`](stopped_as_error.md)
+
+
+## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- fix: markdown format</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/clear.html"/>
      <id>507925290698fc75f0e2c4d05849a850b81da4f3:reference/unordered_map/unordered_map/clear.md</id>
      <updated>2025-05-30T01:59:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/clear.md b/reference/unordered_map/unordered_map/clear.md
index 77f01844e..34eaefc58 100644
--- a/reference/unordered_map/unordered_map/clear.md
+++ b/reference/unordered_map/unordered_map/clear.md
@@ -42,7 +42,7 @@ void clear() noexcept;
 1. 全ての要素を走査して各要素を破棄
 2. 全てのバケットを走査して各バケットの状態をリセット
 
-という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() * `[`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
+という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() *` [`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
 規格の計算量の要件は要素数 `size()` に線形となっているが、規格がコンテナに対して定義する計算量は「コンテナに格納している要素に対する操作の数の計算量」であるためバケットの走査などを考慮していない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>koki watanabe</name>
        <email>address8128@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- fix: markdown format</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/clear.html"/>
      <id>507925290698fc75f0e2c4d05849a850b81da4f3:reference/unordered_map/unordered_multimap/clear.md</id>
      <updated>2025-05-30T01:59:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/clear.md b/reference/unordered_map/unordered_multimap/clear.md
index 42e015bfd..9480119e0 100644
--- a/reference/unordered_map/unordered_multimap/clear.md
+++ b/reference/unordered_map/unordered_multimap/clear.md
@@ -42,7 +42,7 @@ void clear() noexcept;
 1. 全ての要素を走査して各要素を破棄
 2. 全てのバケットを走査して各バケットの状態をリセット
 
-という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() * `[`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
+という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() *` [`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
 規格の計算量の要件は要素数 `size()` に線形となっているが、規格がコンテナに対して定義する計算量は「コンテナに格納している要素に対する操作の数の計算量」であるためバケットの走査などを考慮していない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>koki watanabe</name>
        <email>address8128@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- fix: markdown format</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/clear.html"/>
      <id>507925290698fc75f0e2c4d05849a850b81da4f3:reference/unordered_set/unordered_multiset/clear.md</id>
      <updated>2025-05-30T01:59:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/clear.md b/reference/unordered_set/unordered_multiset/clear.md
index e3c3f9233..f19039fd3 100644
--- a/reference/unordered_set/unordered_multiset/clear.md
+++ b/reference/unordered_set/unordered_multiset/clear.md
@@ -42,7 +42,7 @@ void clear() noexcept;
 1. 全ての要素を走査して各要素を破棄
 2. 全てのバケットを走査して各バケットの状態をリセット
 
-という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() * `[`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
+という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() *` [`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
 規格の計算量の要件は要素数 `size()` に線形となっているが、規格がコンテナに対して定義する計算量は「コンテナに格納している要素に対する操作の数の計算量」であるためバケットの走査などを考慮していない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>koki watanabe</name>
        <email>address8128@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- fix: markdown format</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/clear.html"/>
      <id>507925290698fc75f0e2c4d05849a850b81da4f3:reference/unordered_set/unordered_set/clear.md</id>
      <updated>2025-05-30T01:59:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/clear.md b/reference/unordered_set/unordered_set/clear.md
index 66d2c8b14..4aabb8fe9 100644
--- a/reference/unordered_set/unordered_set/clear.md
+++ b/reference/unordered_set/unordered_set/clear.md
@@ -42,7 +42,7 @@ void clear() noexcept;
 1. 全ての要素を走査して各要素を破棄
 2. 全てのバケットを走査して各バケットの状態をリセット
 
-という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() * `[`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
+という手順を取るため、実際の実行時間はバケット数 [`bucket_count`](bucket_count.md)`()` について線形となる (`size() &amp;lt;= bucket_count() *` [`max_load_factor()`](max_load_factor.md) = O(`bucket_count()`) であることに注意)。
 規格の計算量の要件は要素数 `size()` に線形となっているが、規格がコンテナに対して定義する計算量は「コンテナに格納している要素に対する操作の数の計算量」であるためバケットの走査などを考慮していない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>koki watanabe</name>
        <email>address8128@gmail.com</email>
      </author>
    </entry>
  
</feed>