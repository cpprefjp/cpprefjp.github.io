<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-03-01T05:38:27.765061</updated>
  <id>cc09dd95-3900-4ba2-9b39-d6d0a84542d5</id>

  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 微修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>dd9230e50d7909b013e4930f029f7b252dc63d70:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-03-01T14:35:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index ac669ea6a..d6d4ceaa3 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -299,7 +299,7 @@ auto f10(J x) -&amp;gt; Widget&amp;amp; {
 
 ## この機能が必要になった背景・経緯
 
-C++20までは戻り値型が参照型である場合に暗黙ムーブが行われていなかった。より正確には、関数戻り値の初期化時に戻り値構築のためのコンストラクタを選択するオーバーロード解決が行われる場合にのみ、暗黙ムーブが考慮されていたが、戻り値型が参照型の場合は参照の初期化だけが起こりコンストラクタ呼び出しは関与しないため暗黙ムーブは考慮されていなかった。
+C++20までは戻り値型が参照型である場合に暗黙ムーブが行われていなかった。より正確には、関数戻り値の初期化時に初期化のためのコンストラクタを選択するオーバーロード解決が行われる場合にのみ、暗黙ムーブが考慮されていたが、戻り値型が参照型の場合は参照の初期化だけが起こりコンストラクタ呼び出しは関与しないため暗黙ムーブは考慮されていなかった。
 
 これによって、同じ`return`文でも戻り値型が異なることでそのオペランドの扱いが変化してしまっていた。
 
@@ -318,9 +318,7 @@ auto g(Widget&amp;amp;&amp;amp; w) -&amp;gt; Widget&amp;amp;&amp;amp; {
 
 この非一貫性を解消することがまず求められていた。
 
-また、C++20時点の暗黙ムーブの使用は二段階のオーバーロード解決を行う複雑なものであり、暗黙ムーブが行われるかどうかについて実装間で挙動に差異が生じていた。
-
-C++20の仕様は次のようになっていた。
+また、C++20時点の暗黙ムーブの使用は二段階のオーバーロード解決を行う複雑なものであり、暗黙ムーブが行われるかどうかについて実装間で挙動に差異が生じていた。C++20時点の暗黙ムーブの仕様は次のようになっていた
 
 暗黙ムーブ可能なエンティティが次のコピー初期化が行われる場所で指名されている場合、コピーの代わりにムーブが使用される場合がある
 
@@ -334,9 +332,9 @@ C++20の仕様は次のようになっていた。
 1. オペランドのid式を右辺値（*rvalue*）としてオーバーロード解決を実行する
 2. 1が失敗した（もしくは行われなかった）場合、オペランドのid式を左辺値（*lvalue*）としてオーバーロード解決を実行する
 
-この最後の手順の1回目のオーバーロード解決時にコピーコンストラクタの代わりにムーブコンストラクタが選択されることによって、C++20の暗黙ムーブは達成されていた。しかし、この手順2における「失敗」という言葉の意味が明確ではなく、それによって実装間で暗黙ムーブが行われるかどうか、あるいは選択されるコンストラクタに差異が生じていた。
+この最後の手順の1回目のオーバーロード解決時にコピーコンストラクタの代わりにムーブコンストラクタが選択されることによって、C++20の暗黙ムーブは実行される。しかし、この手順における「失敗」という言葉の意味が明確ではなく、それによって実装間で暗黙ムーブが行われるかどうか、あるいは選択されるコンストラクタに差異が生じていた。
 
-`return`文オペランドの扱いの戻り値型の違いによる非一貫性と、使用の複雑さと曖昧さによる実装間の差異の2つの問題を解決するために、C++23ではムーブする資格がある式という概念を用いて暗黙ムーブの仕様が単純化された。
+`return`文オペランドの扱いの戻り値型の違いによる非一貫性と、仕様の複雑さと曖昧さによる実装間の差異の2つの問題を解決するために、C++23ではムーブする資格がある式という概念を用いて暗黙ムーブの仕様が単純化された。
 
 ## 参照
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 不可視文字の削除</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>c4b15eaed4ad336a858490578ffbb2bd63907a59:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-03-01T14:13:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index dc7b5733b..ac669ea6a 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -329,7 +329,7 @@ C++20の仕様は次のようになっていた。
 - `throw`式のオペランド
     - （諸条件はC++23仕様と同一なので省略）
 
-これらのコピー初期化が行われる場所において、呼び出されるコンストラクタまたは[`return_­value()`オーバーロード](/lang/cpp20/coroutines.md)を選択するオーバーロード解決は次の順序で実行される
+これらのコピー初期化が行われる場所において、呼び出されるコンストラクタまたは[`return_value()`オーバーロード](/lang/cpp20/coroutines.md)を選択するオーバーロード解決は次の順序で実行される
 
 1. オペランドのid式を右辺値（*rvalue*）としてオーバーロード解決を実行する
 2. 1が失敗した（もしくは行われなかった）場合、オペランドのid式を左辺値（*lvalue*）としてオーバーロード解決を実行する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 暗黙ムーブ : 経緯を追加 #1021</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>8384e0bb49cce5acc30eca4215df91ecd554eddb:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-03-01T12:46:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index f61ff2f24..dc7b5733b 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -207,6 +207,20 @@ auto g(bool b) -&amp;gt; Weird {
 }
 ```
 
+```cpp
+// ムーブしないことを明示する関数、C++20までは使用可能
+template&amp;lt;typename T&amp;gt;
+auto unmove(T&amp;amp;&amp;amp; v) -&amp;gt; T&amp;amp; {
+  return v; // C++23からng、vはxvalue
+}
+
+// C++23では次のように修正する必要がある
+template&amp;lt;typename T&amp;gt;
+auto unmove(T&amp;amp;&amp;amp; v) -&amp;gt; T&amp;amp; {
+  return static_cast&amp;lt;T&amp;amp;&amp;gt;(v); // ok、キャスト式はムーブする資格のある式ではない
+}
+```
+
 ```cpp
 // 例示用のムーブ可能な型
 struct Widget {
@@ -284,15 +298,48 @@ auto f10(J x) -&amp;gt; Widget&amp;amp; {
 ```
 
 ## この機能が必要になった背景・経緯
-(執筆中)
 
-## 検討されたほかの選択肢
-(執筆中)
+C++20までは戻り値型が参照型である場合に暗黙ムーブが行われていなかった。より正確には、関数戻り値の初期化時に戻り値構築のためのコンストラクタを選択するオーバーロード解決が行われる場合にのみ、暗黙ムーブが考慮されていたが、戻り値型が参照型の場合は参照の初期化だけが起こりコンストラクタ呼び出しは関与しないため暗黙ムーブは考慮されていなかった。
+
+これによって、同じ`return`文でも戻り値型が異なることでそのオペランドの扱いが変化してしまっていた。
+
+```cpp
+// Widget, RRefTakerは上の例を参照
+// どちらも、C++20の場合
+
+auto f(Widget&amp;amp;&amp;amp; w) -&amp;gt; RRefTaker {
+  return w;  // ok、wは右辺値として扱われる
+}
+
+auto g(Widget&amp;amp;&amp;amp; w) -&amp;gt; Widget&amp;amp;&amp;amp; {
+  return w;  // ng、wは左辺値として扱われる
+}
+```
+
+この非一貫性を解消することがまず求められていた。
+
+また、C++20時点の暗黙ムーブの使用は二段階のオーバーロード解決を行う複雑なものであり、暗黙ムーブが行われるかどうかについて実装間で挙動に差異が生じていた。
+
+C++20の仕様は次のようになっていた。
+
+暗黙ムーブ可能なエンティティが次のコピー初期化が行われる場所で指名されている場合、コピーの代わりにムーブが使用される場合がある
+
+- `return/co_return`文のオペランド
+    - （諸条件はC++23仕様と同一なので省略）
+- `throw`式のオペランド
+    - （諸条件はC++23仕様と同一なので省略）
+
+これらのコピー初期化が行われる場所において、呼び出されるコンストラクタまたは[`return_­value()`オーバーロード](/lang/cpp20/coroutines.md)を選択するオーバーロード解決は次の順序で実行される
+
+1. オペランドのid式を右辺値（*rvalue*）としてオーバーロード解決を実行する
+2. 1が失敗した（もしくは行われなかった）場合、オペランドのid式を左辺値（*lvalue*）としてオーバーロード解決を実行する
+
+この最後の手順の1回目のオーバーロード解決時にコピーコンストラクタの代わりにムーブコンストラクタが選択されることによって、C++20の暗黙ムーブは達成されていた。しかし、この手順2における「失敗」という言葉の意味が明確ではなく、それによって実装間で暗黙ムーブが行われるかどうか、あるいは選択されるコンストラクタに差異が生じていた。
 
-## 関連項目
-(執筆中)
+`return`文オペランドの扱いの戻り値型の違いによる非一貫性と、使用の複雑さと曖昧さによる実装間の差異の2つの問題を解決するために、C++23ではムーブする資格がある式という概念を用いて暗黙ムーブの仕様が単純化された。
 
 ## 参照
 
 - [P2266R3 Simpler implicit move](https://wg21.link/p2266r3)
-- [The Complete Guide to `return x;` - Arthur O&amp;#39;Dwyer - [CppNow 2021] - YouTube](https://www.youtube.com/watch?v=OGKAJD7bmr8)
\ No newline at end of file
+- [The Complete Guide to `return x;` - Arthur O&amp;#39;Dwyer - [CppNow 2021] - YouTube](https://www.youtube.com/watch?v=OGKAJD7bmr8)
+- [c++ - Does c++23 break unmove - Stack Overflow](https://stackoverflow.com/questions/76647046/does-c23-break-unmove)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>const_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/const_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/const_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/const_pointer_cast.md b/reference/memory/shared_ptr/const_pointer_cast.md
index 6df15cd64..628c1ad98 100644
--- a/reference/memory/shared_ptr/const_pointer_cast.md
+++ b/reference/memory/shared_ptr/const_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dynamic_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/dynamic_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/dynamic_pointer_cast.md b/reference/memory/shared_ptr/dynamic_pointer_cast.md
index aa1c77dff..ae416865b 100644
--- a/reference/memory/shared_ptr/dynamic_pointer_cast.md
+++ b/reference/memory/shared_ptr/dynamic_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reinterpret_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/reinterpret_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/reinterpret_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/reinterpret_pointer_cast.md b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
index 9054ca33f..81c9ba5c2 100644
--- a/reference/memory/shared_ptr/reinterpret_pointer_cast.md
+++ b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>static_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/static_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/static_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/static_pointer_cast.md b/reference/memory/shared_ptr/static_pointer_cast.md
index 5514da616..9bed817c3 100644
--- a/reference/memory/shared_ptr/static_pointer_cast.md
+++ b/reference/memory/shared_ptr/static_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>const_pointer_cast -- typo: 動作未定義 -&gt; 未定義動作</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/const_pointer_cast.html"/>
      <id>fc76618bd1e1be1d071a19d7c5ee3c462e56e494:reference/memory/shared_ptr/const_pointer_cast.md</id>
      <updated>2024-02-29T23:21:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/const_pointer_cast.md b/reference/memory/shared_ptr/const_pointer_cast.md
index 6df15cd64..628c1ad98 100644
--- a/reference/memory/shared_ptr/const_pointer_cast.md
+++ b/reference/memory/shared_ptr/const_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ToruNiina</name>
        <email>niina.toru.68u@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dynamic_pointer_cast -- typo: 動作未定義 -&gt; 未定義動作</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html"/>
      <id>fc76618bd1e1be1d071a19d7c5ee3c462e56e494:reference/memory/shared_ptr/dynamic_pointer_cast.md</id>
      <updated>2024-02-29T23:21:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/dynamic_pointer_cast.md b/reference/memory/shared_ptr/dynamic_pointer_cast.md
index aa1c77dff..ae416865b 100644
--- a/reference/memory/shared_ptr/dynamic_pointer_cast.md
+++ b/reference/memory/shared_ptr/dynamic_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ToruNiina</name>
        <email>niina.toru.68u@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reinterpret_pointer_cast -- typo: 動作未定義 -&gt; 未定義動作</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/reinterpret_pointer_cast.html"/>
      <id>fc76618bd1e1be1d071a19d7c5ee3c462e56e494:reference/memory/shared_ptr/reinterpret_pointer_cast.md</id>
      <updated>2024-02-29T23:21:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/reinterpret_pointer_cast.md b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
index 9054ca33f..81c9ba5c2 100644
--- a/reference/memory/shared_ptr/reinterpret_pointer_cast.md
+++ b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ToruNiina</name>
        <email>niina.toru.68u@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>static_pointer_cast -- typo: 動作未定義 -&gt; 未定義動作</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/static_pointer_cast.html"/>
      <id>fc76618bd1e1be1d071a19d7c5ee3c462e56e494:reference/memory/shared_ptr/static_pointer_cast.md</id>
      <updated>2024-02-29T23:21:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/static_pointer_cast.md b/reference/memory/shared_ptr/static_pointer_cast.md
index 5514da616..9bed817c3 100644
--- a/reference/memory/shared_ptr/static_pointer_cast.md
+++ b/reference/memory/shared_ptr/static_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ToruNiina</name>
        <email>niina.toru.68u@gmail.com</email>
      </author>
    </entry>
  
</feed>