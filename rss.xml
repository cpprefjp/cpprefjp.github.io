<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-11-09T14:37:19.432833</updated>
  <id>0257f6a2-55f5-4894-8cec-67cd7f9b0aeb</id>

  
    <entry>
      <title>new式での配列要素数の推論 -- Update array_size_deduction_in_new-expressions.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/array_size_deduction_in_new-expressions.html"/>
      <id>eb1fee71d44f377415b87862bf82edc8969355ff:lang/cpp20/array_size_deduction_in_new-expressions.md</id>
      <updated>2021-11-09T12:07:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/array_size_deduction_in_new-expressions.md b/lang/cpp20/array_size_deduction_in_new-expressions.md
index 3570ddcf6..9916a0ea4 100644
--- a/lang/cpp20/array_size_deduction_in_new-expressions.md
+++ b/lang/cpp20/array_size_deduction_in_new-expressions.md
@@ -11,9 +11,9 @@ C++20では、`new`式で配列の要素数を推論できる。
 double a[3] {1,2,3};               // OK
 double a[] {1,2,3};                // OK
 double* p = new double[3]{1,2,3};  // OK
-double* p = new double[]{1,2,3};   // OK (C++17ではエラー)
+double* p = new double[]{1,2,3};   // OK (P1009R2非対応の環境ではエラー)
 double* p = new double[](1,2,3);   // OK (丸カッコでの集成体初期化:C++20)
-char*   p = new char[]{&amp;#34;hello&amp;#34;};   // OK (C++17ではエラー)
+char*   p = new char[]{&amp;#34;hello&amp;#34;};   // OK (P1009R2非対応の環境ではエラー)
 ```
 
 要素数が推論できない場合、エラーとなる。
@@ -24,6 +24,9 @@ double a[];               // エラー
 double* p = new double[]; // エラー
 ```
 
+この変更(P1009R2)は過去すべてのC++規格に遡って適用された。そのため、P1009R2に対応した環境では、言語バージョンにかかわらず使用できる。
+また、clangは以前から独自にサポートしていた。
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -59,8 +62,6 @@ double* p = new double[]{1,2,3}   // エラー
 
 `new`式で要素数を必須とする強い理由がないため、推論できるようになった。
 
-なお、clangは以前から`new`式での配列要素数を推論できていたが、clang独自の拡張である。
-
 ## 関連項目
 
 * [丸カッコの値リストからの集成体初期化を許可](allow_initializing_aggregates_from_a_parenthesized_list_of_values.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- Merge pull request #915 from meruneru/master</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/sort.html"/>
      <id>0ea9d2cf11127a5c907d1640fdd59321a80143d7:reference/algorithm/sort.md</id>
      <updated>2021-11-09T09:31:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/sort.md b/reference/algorithm/sort.md
index b49efaa26..2a488dd5a 100644
--- a/reference/algorithm/sort.md
+++ b/reference/algorithm/sort.md
@@ -112,11 +112,12 @@ int main()
 ```
 
 ### ユーザー定義型の配列を並べ替える (C++11)
-```cpp
+```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
 #include &amp;lt;string&amp;gt;
 #include &amp;lt;tuple&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
 
 // 要素がひとつの場合
 struct MyInt {
@@ -182,10 +183,11 @@ Carol
 
 
 ### ユーザー定義型の配列を並べ替える (C++20)
-```cpp
+```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
 #include &amp;lt;string&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
 
 // 要素がひとつの場合
 struct MyInt {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- std::sortのサンプルにexampleタグ付与</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/sort.html"/>
      <id>69487cbe2f5c6ddfbfefa24147c4c989598ed600:reference/algorithm/sort.md</id>
      <updated>2021-11-08T20:25:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/sort.md b/reference/algorithm/sort.md
index e0aa873c3..2a488dd5a 100644
--- a/reference/algorithm/sort.md
+++ b/reference/algorithm/sort.md
@@ -183,7 +183,7 @@ Carol
 
 
 ### ユーザー定義型の配列を並べ替える (C++20)
-```cpp
+```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
 #include &amp;lt;string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>meruneru</name>
        <email>meruneru1032@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>符号付き整数型が2の補数表現であることを規定 -- cpp20/signed_integers_are_twos_complement: シフト演算の説明増補</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html"/>
      <id>4a452247e2cf759ffd06ca8f6050d59afee6d91d:lang/cpp20/signed_integers_are_twos_complement.md</id>
      <updated>2021-11-08T19:27:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/signed_integers_are_twos_complement.md b/lang/cpp20/signed_integers_are_twos_complement.md
index 737b283e6..125151a46 100644
--- a/lang/cpp20/signed_integers_are_twos_complement.md
+++ b/lang/cpp20/signed_integers_are_twos_complement.md
@@ -8,9 +8,11 @@ C++20では、符号付き整数型のビット表現を「2の補数 (Two&amp;#39;s Com
 
 値`-0`は、`0`を意味する。
 
-符号付き整数型に対する右シフトは「符号拡張 (sign extension)」を行い、符号ビットが右に伝播する。
+符号付き整数型に対する左シフト`&amp;lt;&amp;lt;`は[論理シフト(Logical shift)](https://en.wikipedia.org/wiki/Logical_shift)となる。対応する符号無し整数型における左シフト演算とビット表現が等しい結果が得られる。
 
-ただし、符号付き整数型のオーバーフロー時の動作は、これまでと変わらず未定義動作である。[`std::numeric_limits`](/reference/limits/numeric_limits.md)`&amp;lt;符号付き整数型&amp;gt;::`[`is_modulo`](/reference/limits/numeric_limits/is_modulo.md)はデフォルトで`false`のままとなる。
+符号付き整数型に対する右シフト`&amp;gt;&amp;gt;`は[算術シフト(Arithmetic shift)](https://en.wikipedia.org/wiki/Arithmetic_shift)となる。右シフトでは「符号拡張 (sign extension)」が行われ、符号ビットが右に伝播する。
+
+ただし、符号付き整数型に対する算術演算におけるオーバーフロー時の動作は、これまでと変わらず未定義動作である。[`std::numeric_limits`](/reference/limits/numeric_limits.md)`&amp;lt;符号付き整数型&amp;gt;::`[`is_modulo`](/reference/limits/numeric_limits/is_modulo.md)はデフォルトで`false`のままとなる。
 
 
 ## 備考
@@ -43,13 +45,24 @@ int main()
     assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b0000&amp;#39;0000));
     assert(y == static_cast&amp;lt;std::int8_t&amp;gt;(0b0000&amp;#39;0000));
   }
-  // 右シフト時の符号拡張
+  // 論理左シフト演算
+  {
+    std::int8_t x = 64;
+    assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b0100&amp;#39;0000));
+
+    x &amp;lt;&amp;lt;= 1;
+
+    assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(-128));
+    assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b1000&amp;#39;0000));
+  }
+  // 算術右シフト演算
   {
     std::int8_t x = -124;
     assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b1000&amp;#39;0100));
 
     x &amp;gt;&amp;gt;= 2;
 
+    assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(-31));
     assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b1110&amp;#39;0001));
   }
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>符号付き整数型が2の補数表現であることを規定 -- cpp20/signed_integers_are_twos_complement: P0907R3 -&gt; R4</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html"/>
      <id>d959de9d5074b09659624dd9f2d7328eea2bf907:lang/cpp20/signed_integers_are_twos_complement.md</id>
      <updated>2021-11-08T13:50:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/signed_integers_are_twos_complement.md b/lang/cpp20/signed_integers_are_twos_complement.md
index 7eda67748..737b283e6 100644
--- a/lang/cpp20/signed_integers_are_twos_complement.md
+++ b/lang/cpp20/signed_integers_are_twos_complement.md
@@ -124,7 +124,7 @@ C11規格は、2の補数のほかに、1の補数表現 (Ones&amp;#39; complement) と
 ## 参照
 - [P1236R1: Alternative Wording for P0907R4 Signed Integers are Two&amp;#39;s Complement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1236r1.html)
     - C++20に採択された提案文書
-- [P0907R3 Signed Integers are Two&amp;#39;s Complement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r3.html)
+- [P0907R4 Signed Integers are Two&amp;#39;s Complement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r4.html)
     - 元になった提案文書
 - [符号付き整数型の負数表現を 2 の補数と規定 (P1236R1) - cppmap](https://cppmap.github.io/standardization/cpp20/#2-p1236r1)
 - [2の補数表現における演算](http://www.cc.kyoto-su.ac.jp/~kbys/kiso/number/int-op.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>