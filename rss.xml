<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-28T03:12:25.281846</updated>
  <id>e3ba6198-19a0-41ba-9f65-8d97d1ea34b9</id>

  
    <entry>
      <title>任意の式によるSFINAE -- C++11 SFINAE expr : decltype(a + b, bool())の説明コメントを追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/sfinae_expressions.html"/>
      <id>b4235fc7c5fb8384fe4de49592703923fe8809c4:lang/cpp11/sfinae_expressions.md</id>
      <updated>2021-05-28T12:07:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/sfinae_expressions.md b/lang/cpp11/sfinae_expressions.md
index 9ebea4788..8526b9169 100644
--- a/lang/cpp11/sfinae_expressions.md
+++ b/lang/cpp11/sfinae_expressions.md
@@ -14,6 +14,11 @@
 template &amp;lt;class T1, class T2&amp;gt;
 auto is_addable(T1 a, T2 b) -&amp;gt; decltype(a + b, bool())
 {
+  // decltype(a + b, bool())は、式a + bを評価しつつ、
+  // 戻り値の型としてはboolを返すという動作。
+  // 組み込みのカンマ演算子の
+  // 「`a, b`は`a`を評価しつつ式の結果としては`b`を返す」という仕様を利用している
+
   std::cout &amp;lt;&amp;lt; &amp;#34;型T1とT2の間で、+演算子による加算が可能&amp;#34; &amp;lt;&amp;lt; std::endl;
   return true;
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>overrideとfinal -- override_final: コード説明コメントにてfinalクラス継承不可を明記</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/override_final.html"/>
      <id>f2669bf093d4e8f5f53df3c69f112fd4b26288fa:lang/cpp11/override_final.md</id>
      <updated>2021-05-28T09:49:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/override_final.md b/lang/cpp11/override_final.md
index 8d2beef61..11af2f0ba 100644
--- a/lang/cpp11/override_final.md
+++ b/lang/cpp11/override_final.md
@@ -65,7 +65,7 @@ class AAA {
 
 ## 例
 ```cpp example
-//基底クラス
+// 基底クラス
 class base {
   virtual void func_final() final;
   virtual void func_virt();
@@ -73,29 +73,29 @@ class base {
   void func_non_virt();
 };
 
-//派生クラス
+// 派生クラス
 class derived : public base {
-  //NG, final メンバ関数はオーバーライドできない
+  // NG, final メンバ関数はオーバーライドできない
   void func_final();
 
-  //OK, オーバーライドできている
+  // OK, オーバーライドできている
   void func_virt() override;
 
-  //NG, 引数の個数、型が違っており、オーバーライドできてない
+  // NG, 引数の個数、型が違っており、オーバーライドできてない
   void func_virt_int(short a) override;
 
-  //NG, 基底クラスの func_non_virt() は仮想関数では無いので、オーバーライドできていない
+  // NG, 基底クラスの func_non_virt() は仮想関数では無いので、オーバーライドできていない
   void func_non_virt() override;
 };
 
-//オーバーライド不可の基底クラス
+// オーバーライド不可の基底クラス
 class base_f final {
   virtual void func_virt();
 };
 
-//派生クラス
+// NG, final基底クラスからの継承はできない
 class derived_f : public base_f {
-  //NG, final 基底クラスのメンバ関数はオーバーライドできない
+  // NG, （結果的に）final基底クラスのメンバ関数はオーバーライドできない
   void func_virt();
 };
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>厳密な式の評価順 -- expression_evaluation_order: 調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/expression_evaluation_order.html"/>
      <id>8dbd27843b8385284a601eed184bf5e25e6f4d23:lang/cpp17/expression_evaluation_order.md</id>
      <updated>2021-05-27T18:13:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/expression_evaluation_order.md b/lang/cpp17/expression_evaluation_order.md
index 9be20dc13..ba082317b 100644
--- a/lang/cpp17/expression_evaluation_order.md
+++ b/lang/cpp17/expression_evaluation_order.md
@@ -4,18 +4,19 @@
 ## 概要
 
 C++14までは式の評価順序が未規定（unspecified）であったが、
-C++17では次の式は全てa, bの順で評価されるように定義された。
+C++17では次の式は全て`a`, `b`の順で評価されるように定義された。
 
-1. a.b
-1. a-&amp;gt;b
-1. a-&amp;gt;*b
-1. a(b1, b2, b3)
-1. b @= a
-1. a[b]
-1. a &amp;lt;&amp;lt; b
-1. a &amp;gt;&amp;gt; b
+1. `a.b`
+1. `a-&amp;gt;b`
+1. `a-&amp;gt;*b`
+1. `a(b1, b2, b3)`
+1. `b @= a`
+1. `a[b]`
+1. `a &amp;lt;&amp;lt; b`
+1. `a &amp;gt;&amp;gt; b`
 
-関数の引数リスト内の式（上記例で言えばb1, b2, b3）の評価順序は未規定である。
+関数の引数リスト内の式（上記例で言えば`b1`, `b2`, `b3`）の評価順序は未規定である。
+`@=`は代入演算子`=`や任意の複合代入演算子（`+=`, `-=`など）を表す。
 
 
 ## 仕様
@@ -36,7 +37,7 @@ C++17では式の評価順序が下記の通りに定められた。
 
 3番目の規則については、
 代入演算子`operator=`をオーバーロードした場合を考えるとわかりやすいと思う。
-代入演算子は右から左の順、つまりa, bの順で評価される。
+代入演算子は右から左の順、つまり`a`, `b`の順で評価される。
 
 ```cpp
 struct Hoge {
@@ -52,7 +53,7 @@ int main()
 Hogeクラスの代入演算子をオーバーロードすると、
 `b = a;`は`b.operator=(a);`となりメンバ関数呼び出しと等価になる。
 このとき3番目の規則が存在しなかったとすると、メンバ関数呼び出しの規則が適用される。
-メンバ関数呼び出しの評価順序は左から右の順、つまりb, aの順で評価され、
+メンバ関数呼び出しの評価順序は左から右の順、つまり`b`, `a`の順で評価され、
 代入式の評価順序と逆になってしまう。
 
 ```cpp
@@ -117,8 +118,8 @@ int main() {
 ```
 
 下記のプログラムの動作を考える。
-`std::cout`, f, g, hが互いに作用する
-（例えばf, g, h内で`std::cout`に何か出力するなど）場合、
+`std::cout`, `f`, `g`, `h`が互いに作用する
+（例えば`f`, `g`, `h`内で`std::cout`に何か出力するなど）場合、
 このプログラムの動作は不定であった。
 
 シフト演算子は左結合なので`(((std::cout &amp;lt;&amp;lt; f) &amp;lt;&amp;lt; g) &amp;lt;&amp;lt; h)`の順に評価されそうだが、
@@ -137,8 +138,8 @@ std::cout.operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g()).operator&amp;lt;&amp;lt;(h());
 
 このとき`operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g())`のように、
 メンバ関数呼び出しの連鎖が発生するが、この評価順は未規定であり、
-右から左、すなわちg, fの順で評価されるかも知れないし、
-左から右、すなわちf, gの順に評価されるかも知れない。
+右から左、すなわち`g`, `f`の順で評価されるかも知れないし、
+左から右、すなわち`f`, `g`の順に評価されるかも知れない。
 
 以上のように、シンプルな代入演算やメンバ関数の連鎖などC++で広く使われている手法でさえ、
 動作結果が不定となってしまう問題がある。
@@ -157,4 +158,4 @@ C++の既存のプログラムを壊すこと無く、なおかつ、
 
 ## 参照
 - [P0145R3 Refining Expression Evaluation Order for Idiomatic C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf)
-- [Wording for Order of Evaluation of Function Arguments](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0400r0.html)
+- [P0400R0 Wording for Order of Evaluation of Function Arguments](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0400r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- P0784R7 : operator newの省略について修正と追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>c44228943d181c419c872b3f3e7ae02c9a6f99ba:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-27T01:00:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index f43fcc721..bae99d54e 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -134,7 +134,7 @@ int main () {
 
 したがって、C++20のコンパイル時動的メモリ確保の仕様では、コンパイル時に確保したメモリ領域を実行時へ持ち越すことはできない。
 
-実際には、これらの定数式中の`new`式の評価は常に省略されている。この省略はC++14より許可されている最適化の一環として行われ、スタック領域などのストレージを別途割り当てることで動的メモリ確保を避けるものである。対応する`delete`式の呼び出しも同様に省略され、定数式においてはメモリの確保と解放が一貫していることのマーカーとしての役割しか持たない。
+実際には、これらの定数式中の`new`式において呼び出される`::operator new()`の評価は常に省略されている。この省略はC++14より許可されている最適化の一環として行われ、スタック領域などのストレージを別途あてがうことで動的メモリ確保を避けるものである。対応する`delete`式における`::operator delete()`の呼び出しも同様に省略され、定数式における`new/delete`式はメモリの確保と解放が一貫していることのマーカーとしての側面が強くなっている。
 
 ```cpp
 constexpr void f() {
@@ -142,12 +142,12 @@ constexpr void f() {
   int* d = new int{2};
   delete d;
 
-  // 次のようなコードと等価になる
+  // たとえば次のようなコードと等価になる
   int d{2};
 }
 ```
 
-実際にはどこのストレージが提供されるかは規定されていない。
+実際にはどこのストレージが提供されるかは実装定義である。
 
 ### `std::allocator/std::allocator_traits`
 
@@ -245,6 +245,10 @@ constexpr int g() {
 
 `destroy_at`には類似のファミリとして[`destroy_n`](/reference/memory/destroy_n.md)と、それらの`range`版があり（あるいは追加され）、`construct_at`も`range`版が同時に追加されるが、それらについても`construct_at/destroy_at`と同様の扱いが可能となる。
 
+`std::allocator::allocate()`はグローバルの`::operator new()`を呼び出すが、この呼び出しは`new`式の時と同様に省略されており、`std::allocator::deallocate()`における`::operator delete()`の呼び出しも省略されている。この2つもまた`new/delete`式と同様に、メモリの確保と解放が一貫していることのマーカーとしての側面が強くなっている。
+
+結局、C++20のコンパイル時動的メモリ確保は定数式にヒープ領域を導入するものではなく、デフォルトの`::operator new`による動的メモリ確保を別の領域をあてがう形に置換することで行われている。
+
 ## この機能が必要になった背景・経緯
 
 `std::vector`をはじめとする可変サイズのコンテナは実行時に非常に有用であるため、同様に定数式においても有用である可能性があり、その必要性がC++コミュニティからも示されいていた（[C++Now 2017: Ben Deane &amp;amp; Jason Turner &amp;#34;constexpr ALL the things!&amp;#34;](https://youtu.be/HMB9oXFobJc)、[P0810R0 constexpr in Practice](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0810r0.pdf)など）。
@@ -341,4 +345,5 @@ int main() {
 - [P0784R6 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r6.html)
 - [P0784R7 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html)
 - [動的メモリー確保 - 江添亮の入門C++](https://ezoeryou.github.io/cpp-intro/#動的メモリー確保)
+- [N3664 Clarifying Memory Allocation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html)
 - [P1974R0 Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- P0784R7 : 追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>ad0646b0e078c6894772d1f63968ee54458d3baf:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-26T17:18:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index fd5182681..f43fcc721 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -155,7 +155,7 @@ constexpr void f() {
 
 `std::allocator/std::allocator_traits`では`new/delete`式とは異なり、メモリの確保・解放（[`allocate`](/reference/memory/allocator/allocate.md)/[`deallocate`](/reference/memory/allocator/deallocate.md)）とその領域へのオブジェクト構築・破棄（[`construct`](/reference/memory/allocator_traits/construct.md)/[`destroy`](/reference/memory/allocator_traits/destroy.md)）の操作が複合していない。オブジェクト構築・破棄においては*placement new*と*pseudo-destructor call*が必要となるが、*placement new*はポインタの再解釈が必要となることから許可されず、そのために不必要であるので*pseudo-destructor call*も許可されない。
 
-代わりに、*placement new*を行うライブラリ機能である[`construct_at`](/reference/memory/construct.md.nolink)を追加し、*pseudo-destructor call*を行う[`destroy_at`](/reference/memory/destroy_at.md)と共に`constexpr`を付加し定数式で使用可能とする。これによって、ポインタ再解釈を回避しつつ*placement new*と*pseudo-destructor call*が定数式で使用可能となる。
+代わりに、*placement new*を行うライブラリ機能である[`construct_at`](/reference/memory/construct.md.nolink)を追加し、*pseudo-destructor call*を行う[`destroy_at`](/reference/memory/destroy_at.md)と共に`constexpr`を付加し定数式で使用可能とする。これらの関数は`void*`ではなく`T*`を取るため、これによってポインタ再解釈を回避しつつ*placement new*と*pseudo-destructor call*が定数式で使用可能となる。
 
 そして、`std::allocator_traits`の`construct`と`destroy`は`construct_at/destroy_at`を呼び出して処理を行うように変更される。なお、これによって実行時の振る舞いが変化することはない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>