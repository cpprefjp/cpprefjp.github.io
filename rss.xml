<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-09-16T14:37:38.167719</updated>
  <id>9d9612bc-c7e5-45e3-9af0-cae79a81257f</id>

  
    <entry>
      <title>契約に基づくプログラミング -- Update contract-based_programming.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/contract-based_programming.html"/>
      <id>a56ced58defb9873924f6ce75b068f7ab97b77cb:lang/cpp23/contract-based_programming.md</id>
      <updated>2020-09-16T20:09:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/contract-based_programming.md b/lang/cpp23/contract-based_programming.md
index e9b84b75b..f41b2de38 100644
--- a/lang/cpp23/contract-based_programming.md
+++ b/lang/cpp23/contract-based_programming.md
@@ -126,8 +126,11 @@ C++20では、プログラムのコンパイルは次の3つのうちどれか
 * `audit`: 契約レベルが`default`または`audit`の契約がチェックされる。
 
 ビルドレベルを指定する方法は処理系定義である。ただし、ソースコード上で指定する方法は提供されない。
-`constexpr`などの定数表現評価では、チェックされた契約のみが評価される。
-チェックされない契約が評価されるかは未規定である。`false`に評価される場合の動作は未定義である。
+
+なお、契約がチェックされることと、評価されることは異なる。
+
+* `constexpr`などの定数表現評価では、チェックされた契約のみが評価される。
+* チェックされない契約が評価されるかは未規定である。チェックされない契約が評価され、結果が`false`となった場合の動作は未定義である。
 
 ### 違反ハンドラーと違反継続モード
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>indirect_binary_predicate -- indirect_binary_predicate : 取り消し</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirect_binary_predicate.html"/>
      <id>a3b4bd8bd35b2218c3244fb8db82feb498eb0423:reference/iterator/indirect_binary_predicate.md</id>
      <updated>2020-09-16T19:05:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirect_binary_predicate.md b/reference/iterator/indirect_binary_predicate.md
index e94820bce..1c50e9922 100644
--- a/reference/iterator/indirect_binary_predicate.md
+++ b/reference/iterator/indirect_binary_predicate.md
@@ -30,8 +30,6 @@ namespace std {
 
 単純には、型`I1, I2, F`のオブジェクトをそれぞれ`i1, i2, f`とすると`bool c = f(*i1, *i2)`のような呼び出しが可能であることを表している。
 
-これは例えば、[`shared_ptr`](/reference/memory/shared_ptr.md)の比較に[`owner_less`](/reference/memory/owner_less.md)を用いる場合に、そのような述語オブジェクトの制約に用いることができる。
-
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>indirect_binary_predicate -- indirect_binary_predicate : 追記</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirect_binary_predicate.html"/>
      <id>1953d9dd48bded3c128f16953b7290bd0b440e82:reference/iterator/indirect_binary_predicate.md</id>
      <updated>2020-09-16T18:02:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirect_binary_predicate.md b/reference/iterator/indirect_binary_predicate.md
index 1c50e9922..e94820bce 100644
--- a/reference/iterator/indirect_binary_predicate.md
+++ b/reference/iterator/indirect_binary_predicate.md
@@ -30,6 +30,8 @@ namespace std {
 
 単純には、型`I1, I2, F`のオブジェクトをそれぞれ`i1, i2, f`とすると`bool c = f(*i1, *i2)`のような呼び出しが可能であることを表している。
 
+これは例えば、[`shared_ptr`](/reference/memory/shared_ptr.md)の比較に[`owner_less`](/reference/memory/owner_less.md)を用いる場合に、そのような述語オブジェクトの制約に用いることができる。
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>indirectly_unary_invocable/indirectly_regular_unary_invocable -- indirectly_unary_invocable : リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirectly_unary_invocable.html"/>
      <id>e42943be02570aa69d3a2062569be5ecdde16694:reference/iterator/indirectly_unary_invocable.md</id>
      <updated>2020-09-16T17:30:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirectly_unary_invocable.md b/reference/iterator/indirectly_unary_invocable.md
index ad573b88d..2a07efedf 100644
--- a/reference/iterator/indirectly_unary_invocable.md
+++ b/reference/iterator/indirectly_unary_invocable.md
@@ -37,7 +37,7 @@ namespace std {
 * iter_common_reference_t[link /reference/iterator/iter_common_reference_t.md]
 * common_reference_with[link /reference/concepts/common_reference_with.md]
 * invoke_result_t[link /reference/type_traits/invoke_result.md]
-* regular_invocable[link /reference/concepts/regular_invocable.md]
+* regular_invocable[link /reference/concepts/invocable.md]
 
 ## 概要
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>latch -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/reference/latch/latch.html"/>
      <id>e903f2efa5c11041302dcace00475d3eaa8d2e4b:reference/latch/latch.md</id>
      <updated>2020-09-16T17:29:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/latch/latch.md b/reference/latch/latch.md
index 68854e07c..837911df7 100644
--- a/reference/latch/latch.md
+++ b/reference/latch/latch.md
@@ -64,7 +64,7 @@ int main()
   int shared_data = 0;
 
   // 初期化済みを表すラッチ: 初期カウント値=1
-  std::latch initalized{1};
+  std::latch initialized{1};
   // タスク完了を表すラッチ: 初期カウント値=ワーカ数+1(メインスレッド)
   std::latch completed{NWORKER+1};
 
@@ -72,7 +72,7 @@ int main()
   for (int id = 1; id &amp;lt;= NWORKER; id++) {
     std::thread([&amp;amp;,id]{
       // 共有データの初期化完了を待機
-      initalized.wait();
+      initialized.wait();
       // メインスレッド上でのshared_data代入完了は保証されており、
       // 以降はshared_data読出のみであればデータ競合発生しない。
       int local_data = shared_data;
@@ -92,7 +92,7 @@ int main()
   shared_data = 42;
 
   // 共有データ初期化完了をワーカスレッド群へ通知
-  initalized.count_down();
+  initialized.count_down();
   // メインスレッドはブロックされず後続行を実行する
 
   { // メインスレッドのタスクを実行
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>