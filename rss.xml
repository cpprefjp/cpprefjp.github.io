<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-23T16:21:19.328610</updated>
  <id>4c74d91a-b98d-4a41-9af6-7eea7d39993d</id>

  
    <entry>
      <title>cout -- chore(cout): use archive URL</title>
      <link href="https://cpprefjp.github.io/reference/iostream/cout.html"/>
      <id>2f81026abfb8140518f84a4d581e58cd01798c97:reference/iostream/cout.md</id>
      <updated>2021-05-24T01:16:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iostream/cout.md b/reference/iostream/cout.md
index 5d8b1e527..ed878e357 100644
--- a/reference/iostream/cout.md
+++ b/reference/iostream/cout.md
@@ -109,7 +109,7 @@ Windowsでは`wchar_t`型といえばUTF-16でエンコードされた文字を
 ## 参照
 
 - [使用できるロケール文字列](../../article/platform/locales.md)
-- [標準出力に書き込む | 株式会社きじねこ](http://www.kijineko.co.jp/tech/cppsamples/stdout.html)
+- [標準出力に書き込む | 株式会社きじねこ](https://web.archive.org/web/20191011112040/http://www.kijineko.co.jp/tech/cppsamples/stdout.html)
 - [c++で日本語の処理（ロケール周り） 7/8追記 - nullnull7の日記](http://nullnull.hatenablog.com/entry/20120629/1340935277)
 - [std::locale constructor modifies global locale via &amp;#34;setlocale()&amp;#34; | Microsoft Connect](http://web.archive.org/web/20100328154628/http://connect.microsoft.com:80/VisualStudio/feedback/details/492128/std-locale-constructor-modifies-global-locale-via-setlocale)
 - [ASCII.jp：Windows 10に“まとも”に使えるコンソール「WindowsTerminal」が登場する (2/2)](https://ascii.jp/elem/000/001/868/1868623/2/)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>iリテラル -- iリテラルの引数名を明記</title>
      <link href="https://cpprefjp.github.io/reference/complex/complex/op_i.html"/>
      <id>bb064cc055dbd658437963cfa115b0c14b0ac16b:reference/complex/complex/op_i.md</id>
      <updated>2021-05-22T15:11:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/complex/complex/op_i.md b/reference/complex/complex/op_i.md
index b9bd97317..cc4da8f72 100644
--- a/reference/complex/complex/op_i.md
+++ b/reference/complex/complex/op_i.md
@@ -8,9 +8,9 @@
 namespace std {
 inline namespace literals {
 inline namespace complex_literals {
-  constexpr complex&amp;lt;double&amp;gt; operator&amp;#34;&amp;#34;i(long double);
+  constexpr complex&amp;lt;double&amp;gt; operator&amp;#34;&amp;#34;i(long double d);
 
-  constexpr complex&amp;lt;double&amp;gt; operator&amp;#34;&amp;#34;i(unsigned long long);
+  constexpr complex&amp;lt;double&amp;gt; operator&amp;#34;&amp;#34;i(unsigned long long d);
 }}}
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Toshinori Tsuboi</name>
        <email>ikamat.kmr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>polymorphic_allocator -- fix typo</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator.html"/>
      <id>df189fefabbf261cdb312b8f2ec0f575d2611b57:reference/memory_resource/polymorphic_allocator.md</id>
      <updated>2021-05-22T03:28:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/polymorphic_allocator.md b/reference/memory_resource/polymorphic_allocator.md
index b1a2e7c4d..bdaa26a6c 100644
--- a/reference/memory_resource/polymorphic_allocator.md
+++ b/reference/memory_resource/polymorphic_allocator.md
@@ -86,7 +86,7 @@ C++20にてC++プログラミングにおいての基礎部品となる型（*vo
 ## 参照
 - [C++1z 多相アロケータとメモリプール - Faith and Brave - C++で遊ぼう ](https://faithandbrave.hateblo.jp/entry/2016/08/08/170454)
 - [memory_resourceについて - 本の虫](https://cpplover.blogspot.com/2015/09/memoryresource.html)
-- [Polymorphic Allocator in C++17 - Qita](https://qiita.com/MitsutakaTakeda/items/48980faa9498c46b15b2)
+- [Polymorphic Allocator in C++17 - Qiita](https://qiita.com/MitsutakaTakeda/items/48980faa9498c46b15b2)
 - [P0220R1 Adopt Library Fundamentals V1 TS Components for C++17 (R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html)
 - [P0337r0 | Delete operator= for polymorphic_allocator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0337r0.html)
 - [Working Draft, C++ Extensions for Library Fundamentals, Version 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html#memory.resource.synop)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Kisaragi</name>
        <email>48310258+KisaragiEffective@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- 可変サイズをもつコンテナのconstexpr化、サンプル修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>349a94b27c91229137e409b6cc122621c3c13b2e:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-21T15:38:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 9755d4ba8..7facfa381 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -78,22 +78,18 @@ C++17までは、クラス型のリテラル型はトリビアルデストラク
 struct S {
   int n = 10;
   
-  constexpr void* operator new(std::size_t n) {
-    return ::operator new(n); // 定数式で実行可能ではない
-  }
-  
-  constexpr void operator delete(void* p) noexcept {
-    ::operator delete(p); // 定数式で実行可能ではない
-  }
+  // 仮に定数式で実行可能なように定義されていたとしても
+  constexpr void* operator new(std::size_t n);
+  constexpr void operator delete(void* p) noexcept;
 };
 
 constexpr int f() {
-  S* s = new S{}; // NG
+  S* s = new S{}; // NG、ユーザー定義operator newの呼び出し
 
   s-&amp;gt;n = 20;
   int n = s-&amp;gt;n;
 
-  delete s; // NG
+  delete s;
 
   return n;
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- constexpr new/delete式追記 #688</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>f6ff668687cac2a08f3dd158745b476c9f6bfee7:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-21T15:16:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 9f26787c9..9755d4ba8 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -67,7 +67,74 @@ C++17までは、クラス型のリテラル型はトリビアルデストラク
 なお、クラスが仮想基底クラスを持つ時、デストラクタもコンストラクタも`constexpr`指定することはできない。
 
 ### `new/delete`式
-(執筆中)
+
+定数式では未定義動作を可能な限り検出しコンパイルエラーとしなければならない。`operator new/operator delete`や`malloc/free`はその実行に伴ってポインタの再解釈（`void*`への/からのキャスト）が必要となるが、ポインタの再解釈は検出しづらい未定義動作に繋がりうるため定数式では禁止されている。
+
+そのため、そのようなポインタの再解釈が発生しない動的メモリ確保機能である`new/delete`式がコンパイル時の動的メモリ確保・解放の方法として許可される。`new/delete`式は`operator new/operator delete`とは異なり、メモリの確保・解放とその領域のオブジェクト構築・破棄を一挙に行う言語機能である。
+
+ただし、コンパイル時に実行される`new`式はグローバルのオーバーロード可能な[`operator new`](/reference/new/op_new.md)を呼び出すものでなくてはならない。そうではない`new`式の定数式における評価はコンパイルエラーとなる。
+
+```cpp
+struct S {
+  int n = 10;
+  
+  constexpr void* operator new(std::size_t n) {
+    return ::operator new(n); // 定数式で実行可能ではない
+  }
+  
+  constexpr void operator delete(void* p) noexcept {
+    ::operator delete(p); // 定数式で実行可能ではない
+  }
+};
+
+constexpr int f() {
+  S* s = new S{}; // NG
+
+  s-&amp;gt;n = 20;
+  int n = s-&amp;gt;n;
+
+  delete s; // NG
+
+  return n;
+}
+```
+
+そして、コンパイル時に`new`式で確保されたメモリ領域は、コンパイル時に`delete`式によって解放されなければならない。その対応が取れていない`new/delete`式の呼び出しは、どちらもコンパイルエラーとなる。
+
+```cpp
+constexpr int f() {
+  int* d = new int;
+
+  *d = 20;
+  int n = *d;
+
+  // 忘れる
+  //delete d;
+
+  return n;
+}
+
+int main () {
+  constexpr int n = f();  // NG、コンパイルエラー
+}
+```
+
+したがって、C++20のコンパイル時動的メモリ確保の仕様では、コンパイル時に確保したメモリ領域を実行時へ持ち越すことはできない。
+
+実際には、これらの定数式中の`new`式の評価は常に省略されている。この省略はC++14より許可されている最適化の一環として行われ、スタック領域などのストレージを別途割り当てることで動的メモリ確保を避けるものである。対応する`delete`式の呼び出しも同様に省略され、定数式においてはメモリの確保と解放が一貫していることのマーカーとしての役割しか持たない。
+
+```cpp
+constexpr void f() {
+  // このコードは定数式中で
+  int* d = new int{2};
+  delete d;
+
+  // 次のようなコードと等価になる
+  int d{2};
+}
+```
+
+実際にはどこのストレージが提供されるかは規定されていない。ただ、定数式が実行される環境はC++コンパイラの内蔵する`constexpr`インタプリタ上であり、その環境のメモリ領域とはコンパイラ実行環境のヒープ領域が対応する。
 
 ### `std::allocator/std::allocator_traits`
 (執筆中)
@@ -103,4 +170,5 @@ std::vector&amp;lt;std::metainfo&amp;gt; args = std::meta::get_template_args(reflexpr(T));
 - [P0784R5 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r5.html)
 - [P0784R6 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r6.html)
 - [P0784R7 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html)
+- [動的メモリー確保 - 江添亮の入門C++](https://ezoeryou.github.io/cpp-intro/#動的メモリー確保)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>