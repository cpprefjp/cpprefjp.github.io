<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-25T14:39:19.905406</updated>
  <id>093b13e0-7b9f-4dbf-a543-b26165945e45</id>

  
    <entry>
      <title>format -- range_formatter : メンバ関数を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/format.html"/>
      <id>74662b472ba0ca06ab99ac08ed74a3d2e8669584:reference/format/format.md</id>
      <updated>2023-01-25T14:16:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format.md b/reference/format/format.md
index 83a6ce5a0..97fae21fa 100644
--- a/reference/format/format.md
+++ b/reference/format/format.md
@@ -172,7 +172,7 @@ Range・シーケンスコンテナに対して使用できる標準のオプシ
     - 要素型の書式を指定して、デバッグ出力指定をしなければ、デフォルトで有効になっているデバッグ出力を解除できる
 
 
-#### 連想コンテナの書式 (C++23)
+#### &amp;lt;a id=&amp;#34;assoc-format-options&amp;#34; href=&amp;#34;#assoc-format-options&amp;#34;&amp;gt;連想コンテナの書式 (C++23)&amp;lt;/a&amp;gt;
 
 Range・シーケンスコンテナと同じだが、デフォルトで`m`書式を適用する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_separator -- range_formatter : メンバ関数を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/formatter/set_separator.html"/>
      <id>74662b472ba0ca06ab99ac08ed74a3d2e8669584:reference/format/formatter/set_separator.md</id>
      <updated>2023-01-25T14:16:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/formatter/set_separator.md b/reference/format/formatter/set_separator.md
index d54d732a9..1d82f14ae 100644
--- a/reference/format/formatter/set_separator.md
+++ b/reference/format/formatter/set_separator.md
@@ -16,7 +16,7 @@ constexpr void
 
 このメンバ関数は、[`std::format()`](/reference/format/format.md)関数の「[pair、tupleの書式](/reference/format/format.md#tuple-format-options)」において区切り文字を変更するオプションを指定することで自動的に呼び出される。
 
-デフォルトの開きカッコは`&amp;#34;, &amp;#34;`である。
+デフォルトの区切り文字は`&amp;#34;, &amp;#34;`である。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>range_formatter -- range_formatter : メンバ関数を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter.html"/>
      <id>74662b472ba0ca06ab99ac08ed74a3d2e8669584:reference/format/range_formatter.md</id>
      <updated>2023-01-25T14:16:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter.md b/reference/format/range_formatter.md
index 7f3190b22..c2d5c38f5 100644
--- a/reference/format/range_formatter.md
+++ b/reference/format/range_formatter.md
@@ -19,18 +19,18 @@ namespace std {
 ユーザー定義のコンテナ・RangeをRange書式に対応する場合は、以下のようにする：
 
 - オリジナル書式を定義しないのであれば、このクラスではなく、[`format_kind`](format_kind.md)を特殊化する
-- オリジナル書式を定義するのであれば、このクラスおよび[`format_kind`](format_kind.md)を特殊化して[`parse()`](range_formatter/parse.md.nolink)メンバ関数と[`format()`](range_formatter/format.md.nolink)メンバ関数を実装する
+- オリジナル書式を定義するのであれば、このクラスおよび[`format_kind`](format_kind.md)を特殊化して[`parse()`](range_formatter/parse.md)メンバ関数と[`format()`](range_formatter/format.md)メンバ関数を実装する
 
 
 ## メンバ関数
 
 | メンバ関数 | 説明 | 対応バージョン |
 |------------|------|----------------|
-| [`set_separator`](range_formatter/set_separator.md.nolink) | 要素の区切り文字を設定する | C++23 |
-| [`set_brackets`](range_formatter/set_brackets.md.nolink)   | 全体の囲み文字を設定する | C++23 |
-| [`underlying`](range_formatter/underlying.md.nolink)       | 要素型の`formatter`を取得する | C++23 |
-| [`parse`](range_formatter/parse.md.nolink)                 | 書式の解析を行う | C++23 |
-| [`format`](range_formatter/format.md.nolink)               | 書式化を行う | C++23 |
+| [`set_separator`](range_formatter/set_separator.md) | 要素の区切り文字を設定する | C++23 |
+| [`set_brackets`](range_formatter/set_brackets.md)   | 全体の囲み文字を設定する | C++23 |
+| [`underlying`](range_formatter/underlying.md)       | 要素型の`formatter`を取得する | C++23 |
+| [`parse`](range_formatter/parse.md)                 | 書式の解析を行う | C++23 |
+| [`format`](range_formatter/format.md)               | 書式化を行う | C++23 |
 
 
 ## 例
@@ -64,6 +64,9 @@ public:
   const std::vector&amp;lt;T&amp;gt;&amp;amp; base() const { return v_; }
 };
 
+template &amp;lt;class T&amp;gt;
+constexpr std::range_format std::format_kind&amp;lt;MyVector&amp;lt;T&amp;gt;&amp;gt; = std::range_format::sequence;
+
 template &amp;lt;class T&amp;gt;
 class std::range_formatter&amp;lt;MyVector&amp;lt;T&amp;gt;&amp;gt; : public std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; {
   bool is_colon = false;
@@ -87,7 +90,7 @@ public:
   // format()関数は書式の情報をもたない。
   // parse()関数で解析した書式をメンバ変数で保持しておいて、
   // それをもとに書式化する
-  auto format(const MyVector&amp;lt;T&amp;gt;&amp;amp; v, std::format_context&amp;amp; fctx) const {
+  auto format(MyVector&amp;lt;T&amp;gt;&amp;amp;&amp;amp; v, std::format_context&amp;amp; fctx) const {
     if (is_colon) {
       auto out = fctx.out();
       bool is_first = true;
@@ -124,7 +127,7 @@ int main()
 * fctx.advance_to[link basic_format_context/advance_to.md]
 * std::format_to[link format_to.md]
 * std::format[link format.md]
-* underlying()[link range_formatter/underlying.md.nolink]
+* underlying()[link range_formatter/underlying.md]
 
 
 #### 出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format -- range_formatter : メンバ関数を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter/format.html"/>
      <id>74662b472ba0ca06ab99ac08ed74a3d2e8669584:reference/format/range_formatter/format.md</id>
      <updated>2023-01-25T14:16:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter/format.md b/reference/format/range_formatter/format.md
new file mode 100644
index 000000000..8cebaf5e1
--- /dev/null
+++ b/reference/format/range_formatter/format.md
@@ -0,0 +1,47 @@
+# format
+* format[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* range_formatter[meta class]
+* cpp23[meta cpp]
+
+```cpp
+template &amp;lt;ranges::input_range R, class FormatContext&amp;gt;
+  requires formattable&amp;lt;ranges::range_reference_t&amp;lt;R&amp;gt;, charT&amp;gt; &amp;amp;&amp;amp;
+           same_as&amp;lt;remove_cvref_t&amp;lt;ranges::range_reference_t&amp;lt;R&amp;gt;&amp;gt;, T&amp;gt;
+typename FormatContext::iterator
+  format(R&amp;amp;&amp;amp; r, FormatContext&amp;amp; ctx) const; // (1)
+```
+* FormatContext[link /reference/format/basic_format_context.md]
+* ranges::input_range[link /reference/ranges/input_range.md]
+* ranges::range_reference_t[link /reference/ranges/range_reference_t.md]
+
+## 概要
+受け取ったRangeオブジェクト`R`を書式化する。
+
+
+## 効果
+- [`parse()`](parse.md)メンバ関数で解析した書式文字列の指定に基づいて、`r`の値を文字列に変換し、以下を[`ctx.out()`](/reference/format/basic_format_context/out.md)に出力する：
+    - Range書式として[`s` (文字列として出力)](/reference/format/format.md#range-format-options)が指定された場合、[`basic_string`](/reference/string/basic_string.md)`&amp;lt;charT&amp;gt;(`[`from_range`](/reference/ranges/from_range_t.md.nolink)`, r)`を出力する
+    - そうでなく、Range書式として[`?s` (デバッグ文字列として出力)](/reference/format/format.md#range-format-options)が指定された場合、[`basic_string`](/reference/string/basic_string.md)`&amp;lt;charT&amp;gt;(`[`from_range`](/reference/ranges/from_range_t.md.nolink)`, r)`に引用符を付け、エスケープシーケンスをエスケープして出力する
+    - そうでなければ、
+        - 開きカッコを出力する
+        - Range `r`の各要素`e`について、
+            - [`underlying()`](underlying.md)の[`formatter`](/reference/format/formatter.md)で`e`を書式化して出力する
+            - 最後の要素でなければ、区切り文字を出力する
+        - 閉じカッコを出力する
+
+
+## 戻り値
+出力がおわった位置の出力イテレータを返す。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>parse -- range_formatter : メンバ関数を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter/parse.html"/>
      <id>74662b472ba0ca06ab99ac08ed74a3d2e8669584:reference/format/range_formatter/parse.md</id>
      <updated>2023-01-25T14:16:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter/parse.md b/reference/format/range_formatter/parse.md
new file mode 100644
index 000000000..22b031b48
--- /dev/null
+++ b/reference/format/range_formatter/parse.md
@@ -0,0 +1,39 @@
+# parse
+* format[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* range_formatter[meta class]
+* cpp23[meta cpp]
+
+```cpp
+template &amp;lt;class ParseContext&amp;gt;
+constexpr typename ParseContext::iterator
+  parse(ParseContext&amp;amp; ctx);
+```
+* ParseContext[link /reference/format/basic_format_parse_context.md]
+
+## 概要
+書式文字列の範囲`[ctx.begin(), ctx.end())`を解析する。
+
+
+## 効果
+- [`std::format()`](/reference/format/format.md)関数ページに記載されている「[Range・シーケンスコンテナの書式](/reference/format/format.md#range-format-options)」および「[連想コンテナの書式](/reference/format/format.md#assoc-format-options)」を解析する
+    - このとき、書式によって以下を設定する
+        - `n`オプション (囲み文字をなくす) が指定されなければ、全体の囲み文字を、[`set_brackets()`](set_brackets.md)メンバ関数で設定する
+        - 要素の区切り文字を、[`set_separator()`](set_separator.md)メンバ関数で設定する
+        - 要素に対する書式が空でなければ、各要素の[`formatter`](/reference/format/formatter.md)を`e`として、[`e.set_debug_format()`](/reference/format/formatter/set_debug_format.md)が有効な式であれば、それを呼び出してデバッグ書式を有効にする
+
+
+## 戻り値
+`ctx`のうち、解析がおわった位置を指すイテレータを返す。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_brackets -- range_formatter : メンバ関数を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter/set_brackets.html"/>
      <id>74662b472ba0ca06ab99ac08ed74a3d2e8669584:reference/format/range_formatter/set_brackets.md</id>
      <updated>2023-01-25T14:16:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter/set_brackets.md b/reference/format/range_formatter/set_brackets.md
new file mode 100644
index 000000000..045bf01a6
--- /dev/null
+++ b/reference/format/range_formatter/set_brackets.md
@@ -0,0 +1,34 @@
+# set_brackets
+* format[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* range_formatter[meta class]
+* cpp23[meta cpp]
+
+```cpp
+constexpr void
+  set_brackets(basic_string_view&amp;lt;charT&amp;gt; opening,
+               basic_string_view&amp;lt;charT&amp;gt; closing); // (1)
+```
+
+## 概要
+全体の囲み文字を設定する。
+
+このメンバ関数は、[`std::format()`](/reference/format/format.md)関数の「[Range・シーケンスコンテナの書式](/reference/format/format.md#range-format-options)」および「[連想コンテナの書式](/reference/format/format.md#assoc-format-options)」において囲み文字を変更するオプションを指定することで自動的に呼び出される。
+
+- Range・シーケンスコンテナのデフォルトの開きカッコは`&amp;#34;[&amp;#34;`、閉じカッコは`&amp;#34;]&amp;#34;`
+- 連想コンテナのデフォルトの開きカッコは`&amp;#34;{&amp;#34;`、閉じカッコは`&amp;#34;}&amp;#34;`
+
+
+## 効果
+`opening`を開きカッコ、`closing`を閉じカッコとして設定する。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_separator -- range_formatter : メンバ関数を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter/set_separator.html"/>
      <id>74662b472ba0ca06ab99ac08ed74a3d2e8669584:reference/format/range_formatter/set_separator.md</id>
      <updated>2023-01-25T14:16:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter/set_separator.md b/reference/format/range_formatter/set_separator.md
new file mode 100644
index 000000000..bed0838d4
--- /dev/null
+++ b/reference/format/range_formatter/set_separator.md
@@ -0,0 +1,32 @@
+# set_separator
+* format[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* range_formatter[meta class]
+* cpp23[meta cpp]
+
+```cpp
+constexpr void
+  set_separator(basic_string_view&amp;lt;charT&amp;gt; sep); // (1)
+```
+
+## 概要
+要素の区切り文字を設定する。
+
+このメンバ関数は、[`std::format()`](/reference/format/format.md)関数の「[Range・シーケンスコンテナの書式](/reference/format/format.md#range-format-options)」および「[連想コンテナの書式](/reference/format/format.md#assoc-format-options)」において区切り文字を変更するオプションを指定することで自動的に呼び出される。
+
+デフォルトの区切り文字は`&amp;#34;, &amp;#34;`である。
+
+
+## 効果
+`sep`を区切り文字として設定する。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>underlying -- range_formatter : メンバ関数を追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter/underlying.html"/>
      <id>74662b472ba0ca06ab99ac08ed74a3d2e8669584:reference/format/range_formatter/underlying.md</id>
      <updated>2023-01-25T14:16:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter/underlying.md b/reference/format/range_formatter/underlying.md
new file mode 100644
index 000000000..e8ea0a660
--- /dev/null
+++ b/reference/format/range_formatter/underlying.md
@@ -0,0 +1,33 @@
+# underlying
+* format[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* range_formatter[meta class]
+* cpp23[meta cpp]
+
+```cpp
+constexpr formatter&amp;lt;T, charT&amp;gt;&amp;amp; underlying();             // (1) C++23
+constexpr const formatter&amp;lt;T, charT&amp;gt;&amp;amp; underlying() const; // (2) C++23
+```
+* formatter[link /reference/format/formatter.md]
+
+## 概要
+Rangeの要素型に対する[`formatter`](/reference/format/formatter.md)を取得する。
+
+- (1) : 非const版
+- (2) : const版
+
+
+## 戻り値
+メンバ変数として保持している、Rangeの要素型に対する[`formatter`](/reference/format/formatter.md)を返す。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>range_formatter -- range_formatter : サンプルコードのコンパイルが通らなさそうなので見直し</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter.html"/>
      <id>373f49da92fb9c34115279a210f29067b6259e35:reference/format/range_formatter.md</id>
      <updated>2023-01-25T11:56:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter.md b/reference/format/range_formatter.md
index 5b0cec189..7f3190b22 100644
--- a/reference/format/range_formatter.md
+++ b/reference/format/range_formatter.md
@@ -41,7 +41,31 @@ namespace std {
 #include &amp;lt;vector&amp;gt;
 
 template &amp;lt;class T&amp;gt;
-class std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; : public std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; {
+class MyVector {
+  std::vector&amp;lt;T&amp;gt; v_;
+public:
+  using base_type = std::vector&amp;lt;T&amp;gt;;
+  using iterator = typename base_type::iterator;
+  using const_iterator = typename base_type::iterator;
+  using value_type = typename base_type::value_type;
+  using reference = typename base_type::reference;
+  using const_reference = typename base_type::const_reference;
+
+  MyVector() = default;
+  MyVector(std::initializer_list&amp;lt;T&amp;gt; init)
+      : v_(init.begin(), init.end()) {}
+
+  iterator begin() { v_.begin(); }
+  const_iterator begin() const { v_.begin(); }
+
+  iterator end() { v_.end(); }
+  const_iterator end() const { v_.end(); }
+
+  const std::vector&amp;lt;T&amp;gt;&amp;amp; base() const { return v_; }
+};
+
+template &amp;lt;class T&amp;gt;
+class std::range_formatter&amp;lt;MyVector&amp;lt;T&amp;gt;&amp;gt; : public std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; {
   bool is_colon = false;
   using base_type = std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt;;
 public:
@@ -63,7 +87,7 @@ public:
   // format()関数は書式の情報をもたない。
   // parse()関数で解析した書式をメンバ変数で保持しておいて、
   // それをもとに書式化する
-  auto format(const std::vector&amp;lt;T&amp;gt;&amp;amp; v, std::format_context&amp;amp; fctx) const {
+  auto format(const MyVector&amp;lt;T&amp;gt;&amp;amp; v, std::format_context&amp;amp; fctx) const {
     if (is_colon) {
       auto out = fctx.out();
       bool is_first = true;
@@ -80,10 +104,12 @@ public:
       }
       return out;
     }
-    return base_type::format(v, fctx);
+    return base_type::format(v.base(), fctx);
   }
 };
 
+#include &amp;lt;cstdint&amp;gt;
+
 int main()
 {
   std::vector&amp;lt;std::uint8_t&amp;gt; v = {0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- move_only_function/op_constructor: 全オーバーロードの例示コード追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function/op_constructor.html"/>
      <id>63e429d33d1a3e2f10ecbfe657d31a3c5b0eb41e:reference/functional/move_only_function/op_constructor.md</id>
      <updated>2023-01-25T11:29:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function/op_constructor.md b/reference/functional/move_only_function/op_constructor.md
index 1635fa0f5..d5bd1e25b 100644
--- a/reference/functional/move_only_function/op_constructor.md
+++ b/reference/functional/move_only_function/op_constructor.md
@@ -24,7 +24,12 @@ explicit move_only_function(in_place_type_t&amp;lt;T&amp;gt;, initializer_list&amp;lt;U&amp;gt;, Args&amp;amp;&amp;amp;...);
 `move_only_function`オブジェクトを構築する。
 
 
-`move_only_function`クラステンプレートパラメータのnoexcept例外指定 *noex* 特殊化に応じて、説明用の`bool`型テンプレート定数`is-callable-from&amp;lt;VT&amp;gt;`を下記のように定義する :
+`move_only_function`クラステンプレートパラメータのCV修飾子 *cv*, 参照修飾子 *ref*, noexcept例外指定 *noex* に応じて、説明用のプレースホルダ *inv-quals* を次のように定義する :
+
+- *ref* が空（参照修飾無し）ならば、*cv*`&amp;amp;`
+- そうでなければ、*cv* *ref*
+
+また、説明用の`bool`型テンプレート定数`is-callable-from&amp;lt;VT&amp;gt;`を下記のように定義する :
 
 - *noex* が`true`のとき : [`is_nothrow_invocable_r_v`](/reference/type_traits/is_nothrow_invocable_r.md)`&amp;lt;R, VT /*cv*/ /*ref*/, ArgTypes...&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_invocable_r_v`](/reference/type_traits/is_nothrow_invocable_r.md)`&amp;lt;R, VT /*inv-quals*/, ArgTypes...&amp;gt;`
 - *noex* が`false`のとき : [`is_invocable_r_v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, VT /*cv*/ /*ref*/, ArgTypes...&amp;gt; &amp;amp;&amp;amp;` [`is_invocable_r_v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, VT /*inv-quals*/, ArgTypes...&amp;gt;`
@@ -76,8 +81,10 @@ explicit move_only_function(in_place_type_t&amp;lt;T&amp;gt;, initializer_list&amp;lt;U&amp;gt;, Args&amp;amp;&amp;amp;...);
 ## 例
 ```cpp example
 #include &amp;lt;cassert&amp;gt;
-#include &amp;lt;iostream&amp;gt;
 #include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;numeric&amp;gt;
+#include &amp;lt;utility&amp;gt;
 
 struct ident_functor {
   int operator()(int x) const
@@ -89,77 +96,88 @@ int ident_func(int x)
 
 struct X {
   int value;
-  X() : value(3) {}
 
-  int ident_member_func(int x) const
-  { return x; }
+  int add_member_func(int x) const
+  { return value + x; }
 };
 
+struct add_functor {
+  int value;
+
+  add_functor(int v) : value(v) {}
+  add_functor(std::initializer_list&amp;lt;int&amp;gt; lst, int iv)
+    : value(std::accumulate(lst.begin(), lst.end(), iv)) {}
+
+  int operator()(int x) const
+  { return value + x; }
+};
+
+
 int main()
 {
-  // (1)
-  // デフォルトコンストラクタ
+  // (1) デフォルトコンストラクタ
+  // (2) ヌルポインタを受け取るコンストラクタ
   // 空のmove_only_functionオブジェクトを作る
   {
-    std::move_only_function&amp;lt;int(int)&amp;gt; f;
-    assert(!f);
-  }
-
-  // (2)
-  // ヌルポインタを受け取るコンストラクタ
-  // デフォルトコンストラクタと同様、空のmove_only_functionオブジェクトを作る
-  {
-    std::move_only_function&amp;lt;int(int)&amp;gt; f = nullptr;
-    assert(!f);
+    std::move_only_function&amp;lt;int(int)&amp;gt; f1;
+    assert(!f1);
+    std::move_only_function&amp;lt;int(int)&amp;gt; f2 = nullptr;
+    assert(!f2);
   }
 
-  // (3)
-  // ムーブ構築
+  // (3) ムーブ構築
   {
     std::move_only_function&amp;lt;int(int)&amp;gt; f = ident_functor();
     std::move_only_function&amp;lt;int(int)&amp;gt; g = std::move(f);
+    assert(g &amp;amp;&amp;amp; !f);
 
     int result = g(1);
     std::cout &amp;lt;&amp;lt; &amp;#34;(3) : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
 
-  // (4)
-  // 関数ポインタを受け取って構築
+  // (4) 関数ポインタを受け取って構築
   {
     std::function&amp;lt;int(int)&amp;gt; f = ident_func;
 
     int result = f(1);
     std::cout &amp;lt;&amp;lt; &amp;#34;(4) function pointer : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
-
-  // (4)
-  // 関数オブジェクトを受け取って構築
+  // (4) 関数オブジェクトを受け取って構築
   {
     std::function&amp;lt;int(int)&amp;gt; f = ident_functor();
 
     int result = f(1);
     std::cout &amp;lt;&amp;lt; &amp;#34;(4) function object : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
-
-  // (4)
-  // メンバ関数ポインタを受け取った構築
+  // (4) メンバ関数ポインタを受け取った構築
   {
-    std::function&amp;lt;int(const X&amp;amp;, int)&amp;gt; f = &amp;amp;X::ident_member_func;
+    std::function&amp;lt;int(const X&amp;amp;, int)&amp;gt; f = &amp;amp;X::add_member_func;
 
-    X x;
+    X x{2};
     int result = f(x, 1);
     std::cout &amp;lt;&amp;lt; &amp;#34;(4) member function pointer : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
-
-  // (4)
-  // メンバ変数ポインタを受け取った構築
+  // (4) メンバ変数ポインタを受け取った構築
   {
     std::function&amp;lt;int(const X&amp;amp;)&amp;gt; f = &amp;amp;X::value;
-
-    X x;
+    X x{2};
     int result = f(x);
     std::cout &amp;lt;&amp;lt; &amp;#34;(4) member variable pointer : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
+
+  // (5) 引数リストによる直接構築コンストラクタ
+  {
+    std::move_only_function&amp;lt;int(int)&amp;gt; f(std::in_place_type&amp;lt;add_functor&amp;gt;, 2);
+    int result = f(1);
+    std::cout &amp;lt;&amp;lt; &amp;#34;(5) : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+  }
+
+  // (6) initializer_list＋引数リストによる直接構築コンストラクタ
+  {
+    std::move_only_function&amp;lt;int(int)&amp;gt; f(std::in_place_type&amp;lt;add_functor&amp;gt;, std::initializer_list&amp;lt;int&amp;gt;{1, 2, 3}, 4);
+    int result = f(5);
+    std::cout &amp;lt;&amp;lt; &amp;#34;(6) : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+  }
 }
 ```
 * std::move[link /reference/utility/move.md]
@@ -169,8 +187,10 @@ int main()
 (3) : 1
 (4) function pointer : 1
 (4) function object : 1
-(4) member function pointer : 1
-(4) member variable pointer : 3
+(4) member function pointer : 3
+(4) member variable pointer : 2
+(5) : 3
+(6) : 15
 ```
 
 
@@ -180,7 +200,7 @@ int main()
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): ??
+- [GCC](/implementation.md#gcc): 12.1
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unreachable -- utility/unreachable: 微調整</title>
      <link href="https://cpprefjp.github.io/reference/utility/unreachable.html"/>
      <id>da6808523e7c9835d8383ecb2480e4368a26fccb:reference/utility/unreachable.md</id>
      <updated>2023-01-25T10:47:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/unreachable.md b/reference/utility/unreachable.md
index 9ba4c982d..90ea2d775 100644
--- a/reference/utility/unreachable.md
+++ b/reference/utility/unreachable.md
@@ -15,7 +15,7 @@ namespace std {
 
 
 ## 事前条件
-`true`==`false`
+`false`==`true`
 
 
 ## 備考
@@ -44,9 +44,9 @@ int flip(int x)
 
 int main()
 {
-  std::cout &amp;lt;&amp;lt; f(0) &amp;lt;&amp;lt; std::endl;
-  std::cout &amp;lt;&amp;lt; f(1) &amp;lt;&amp;lt; std::endl;
-  // f(2)呼び出しは未定義動作
+  std::cout &amp;lt;&amp;lt; flip(0) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; flip(1) &amp;lt;&amp;lt; std::endl;
+  // 例えば f(2) 呼び出しは未定義動作となる。
 }
 ```
 * std::unreachable[color ff0000]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_only_function -- move_only_function: 推論補助を定義しない旨を明記</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function.html"/>
      <id>684d1f03ad7dfc7059d79909f078182c3bc58266:reference/functional/move_only_function.md</id>
      <updated>2023-01-25T10:14:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function.md b/reference/functional/move_only_function.md
index 448d26961..1d7619561 100644
--- a/reference/functional/move_only_function.md
+++ b/reference/functional/move_only_function.md
@@ -6,7 +6,8 @@
 
 ```cpp
 namespace std {
-  template&amp;lt;class... S&amp;gt; class move_only_function; // 宣言のみ
+  template&amp;lt;class... S&amp;gt;
+  class move_only_function; // 宣言のみ
 
   template&amp;lt;class R, class... ArgTypes&amp;gt;
   class move_only_function&amp;lt;R(ArgTypes...) /*cv*/ /*ref*/ noexcept(/*noex*/)&amp;gt;;
@@ -26,12 +27,13 @@ namespace std {
 [`std::function`](function.md)と比べて、`std::move_only_function`は下記の特徴をもつ。
 
 - ムーブのみ対応。コピー不可。
-- const性を正しく伝搬する。
 - 関数型のCV修飾／参照修飾／noexcept例外指定をサポートする。
+    - const性などを正しく伝搬することでバグ発生リスクを軽減する
 - [`target_type`](function/target_type.md)型と[`target()`](function/target.md)を提供しない。
     - 実行時型情報（RTTI）非依存
 - [関数呼び出し](move_only_function/op_call.md)は強い事前条件を持つ。
     - 関数呼び出し時のnullチェックが要求されない
+- クラステンプレート引数の[推論補助](/lang/cpp17/type_deduction_for_class_templates.md)を提供しない。
 
 
 ## メンバ関数
@@ -241,3 +243,4 @@ int main()
 - [P0288R9 move_only_function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0288r9.html)
 - [N4348 Making `std::function` safe for concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html)
     - `std::function`のconst性伝搬に関して、スレッドセーフ保証の観点からの問題指摘。
+- [Why does C++23 std::move_only_function not have deduction guides?](https://stackoverflow.com/questions/69509236/why-does-c23-stdmove-only-function-not-have-deduction-guides)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>