<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-07-28T05:12:55.023825</updated>
  <id>2b890d35-7dd1-4665-99fd-691c907ec846</id>

  
    <entry>
      <title>コンストラクタ -- add range constructor to list, deque, and string (#1069)</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_constructor.html"/>
      <id>3cac84021a71976657fcb10d7411ed4642e214b8:reference/unordered_map/unordered_map/op_constructor.md</id>
      <updated>2024-07-28T14:09:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_constructor.md b/reference/unordered_map/unordered_map/op_constructor.md
index e7bc4911e..34b0d996e 100644
--- a/reference/unordered_map/unordered_map/op_constructor.md
+++ b/reference/unordered_map/unordered_map/op_constructor.md
@@ -67,8 +67,27 @@ unordered_map(initializer_list&amp;lt;value_type&amp;gt; il,
               size_type n,
               const hasher&amp;amp; hf, 
               const allocator_type&amp;amp; a);                             // (15) C++14
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_map(std::from_range_t, R&amp;amp;&amp;amp; rg,
+              size_type n = 実装依存の既定値,
+              const hasher&amp;amp; hf = hasher(),
+              const key_equal&amp;amp; eql = key_equal(),
+              const allocator_type&amp;amp; a = allocator_type());          // (16) C++23
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_map(std::from_range_t, R&amp;amp;&amp;amp; rg,
+              size_type n,
+              const allocator_type&amp;amp; a);                             // (17) C++23
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_map(std::from_range_t, R&amp;amp;&amp;amp; rg,
+              size_type n,
+              const hasher&amp;amp; hf,
+              const allocator_type&amp;amp; a);                             // (18) C++23
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 ## 概要
 `unordered_map` オブジェクトを構築する
@@ -133,6 +152,12 @@ unordered_map(initializer_list&amp;lt;value_type&amp;gt; il,
 
 - (15) : (5) の形式を `unordered_map(il, n, hf, key_equal(), a)` として呼び出した場合と等価である。
 
+- (16) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で `unordered_map` が構築された後、Range `rg` の要素が挿入される。
+
+- (17) : (16) の形式を `unordered_map(from_range, std::forward&amp;lt;R&amp;gt;(rg), n, hasher(), key_equal(), a)` として呼び出した場合と等価である。
+
+- (18) : (16) の形式を `unordered_map(from_range, std::forward&amp;lt;R&amp;gt;(rg), n, hf, key_equal(), a)` として呼び出した場合と等価である。
+
 
 ## 事後条件
 以下では構築されたオブジェクトを `u` とする。
@@ -190,6 +215,7 @@ unordered_map(initializer_list&amp;lt;value_type&amp;gt; il,
 - (13) : (3) の形式を `unordered_map(f, l, n, hf, key_equal(), a)` として呼び出した場合と等価。
 - (14) : (5) の形式を `unordered_map(il, n, hasher(), key_equal(), a)` として呼び出した場合と等価。
 - (15) : (5) の形式を `unordered_map(il, n, hf, key_equal(), a)` として呼び出した場合と等価。
+- (16), (17), (18) : 平均的には O(n)、ここで、n は [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)`。最悪のケースでは O(n&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;)
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to list, deque, and string (#1069)</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/op_constructor.html"/>
      <id>3cac84021a71976657fcb10d7411ed4642e214b8:reference/unordered_map/unordered_multimap/op_constructor.md</id>
      <updated>2024-07-28T14:09:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/op_constructor.md b/reference/unordered_map/unordered_multimap/op_constructor.md
index 766900cdf..0e44aed11 100644
--- a/reference/unordered_map/unordered_multimap/op_constructor.md
+++ b/reference/unordered_map/unordered_multimap/op_constructor.md
@@ -68,8 +68,27 @@ unordered_multimap(initializer_list&amp;lt;value_type&amp;gt; il,
                    size_type n,
                    const hasher&amp;amp; hf, 
                    const allocator_type&amp;amp; a);                              // (15) C++14
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_multimap(std::from_range_t, R&amp;amp;&amp;amp; rg,
+                   size_type n = 実装依存の既定値,
+                   const hasher&amp;amp; hf = hasher(),
+                   const key_equal&amp;amp; eql = key_equal(),
+                   const allocator_type&amp;amp; a = allocator_type());           // (16) C++23
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_multimap(std::from_range_t, R&amp;amp;&amp;amp; rg,
+                   size_type n,
+                   const allocator_type&amp;amp; a);                              // (17) C++23
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_multimap(std::from_range_t, R&amp;amp;&amp;amp; rg,
+                   size_type n,
+                   const hasher&amp;amp; hf,
+                   const allocator_type&amp;amp; a);                              // (18) C++23
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 ## 概要
 `unordered_multimap` オブジェクトを構築する
@@ -136,6 +155,12 @@ unordered_multimap(initializer_list&amp;lt;value_type&amp;gt; il,
 
 - (15) : (5) の形式を `unordered_multimap(il, n, hf, key_equal(), a)` として呼び出した場合と等価である。
 
+- (16) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で `unordered_multimap` が構築された後、Range `rg` の要素が挿入される。
+
+- (17) : (16) の形式を `unordered_multimap(from_range, std::forward&amp;lt;R&amp;gt;(rg), n, hasher(), key_equal(), a)` として呼び出した場合と等価である。
+
+- (18) : (16) の形式を `unordered_multimap(from_range, std::forward&amp;lt;R&amp;gt;(rg), n, hf, key_equal(), a)` として呼び出した場合と等価である。
+
 
 ## 事後条件
 以下では構築されたオブジェクトを `u` とする。
@@ -194,6 +219,7 @@ unordered_multimap(initializer_list&amp;lt;value_type&amp;gt; il,
 - (13) : (3) の形式を `unordered_multimap(f, l, n, hf, key_equal(), a)` として呼び出した場合と等価。
 - (14) : (5) の形式を `unordered_multimap(il, n, hasher(), key_equal(), a)` として呼び出した場合と等価。
 - (15) : (5) の形式を `unordered_multimap(il, n, hf, key_equal(), a)` として呼び出した場合と等価。
+- (16), (17), (18) : 平均的には O(n)、ここで、n は [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)`。最悪のケースでは O(n&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;)
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to list, deque, and string (#1069)</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/op_constructor.html"/>
      <id>3cac84021a71976657fcb10d7411ed4642e214b8:reference/unordered_set/unordered_multiset/op_constructor.md</id>
      <updated>2024-07-28T14:09:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/op_constructor.md b/reference/unordered_set/unordered_multiset/op_constructor.md
index e6fe7d5fb..3cbeb1ced 100644
--- a/reference/unordered_set/unordered_multiset/op_constructor.md
+++ b/reference/unordered_set/unordered_multiset/op_constructor.md
@@ -69,8 +69,27 @@ unordered_multiset(initializer_list&amp;lt;value_type&amp;gt; il,
                    size_type n,
                    const hasher&amp;amp; hf, 
                    const allocator_type&amp;amp; a);                              // (15) C++14
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_multiset(std::from_range_t, R&amp;amp;&amp;amp; rg,
+                   size_type n = 実装依存の既定値,
+                   const hasher&amp;amp; hf = hasher(),
+                   const key_equal&amp;amp; eql = key_equal(),
+                   const allocator_type&amp;amp; a = allocator_type());           // (16) C++23
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_multiset(std::from_range_t, R&amp;amp;&amp;amp; rg,
+                   size_type n,
+                   const allocator_type&amp;amp; a);                              // (17) C++23
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_multiset(std::from_range_t, R&amp;amp;&amp;amp; rg,
+                   size_type n,
+                   const hasher&amp;amp; hf,
+                   const allocator_type&amp;amp; a);                              // (18) C++23
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 ## 概要
 `unordered_multiset` オブジェクトを構築する
@@ -137,6 +156,12 @@ unordered_multiset(initializer_list&amp;lt;value_type&amp;gt; il,
 
 - (15) : (5) の形式を `unordered_multiset(il, n, hf, key_equal(), a)` として呼び出した場合と等価である。
 
+- (16) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で `unordered_multiset` が構築された後、Range `rg` の要素が挿入される。
+
+- (17) : (16) の形式を `unordered_multiset(from_range, std::forward&amp;lt;R&amp;gt;(rg), n, hasher(), key_equal(), a)` として呼び出した場合と等価である。
+
+- (18) : (16) の形式を `unordered_multiset(from_range, std::forward&amp;lt;R&amp;gt;(rg), n, hf, key_equal(), a)` として呼び出した場合と等価である。
+
 
 ## 事後条件
 以下では構築されたオブジェクトを `u` とする。
@@ -195,6 +220,7 @@ unordered_multiset(initializer_list&amp;lt;value_type&amp;gt; il,
 - (13) : (3) の形式を `unordered_multiset(f, l, n, hf, key_equal(), a)` として呼び出した場合と等価。
 - (14) : (5) の形式を `unordered_multiset(il, n, hasher(), key_equal(), a)` として呼び出した場合と等価。
 - (15) : (5) の形式を `unordered_multiset(il, n, hf, key_equal(), a)` として呼び出した場合と等価。
+- (16), (17), (18) : 平均的には O(n)、ここで、n は [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)`。最悪のケースでは O(n&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;)
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to list, deque, and string (#1069)</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/op_constructor.html"/>
      <id>3cac84021a71976657fcb10d7411ed4642e214b8:reference/unordered_set/unordered_set/op_constructor.md</id>
      <updated>2024-07-28T14:09:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/op_constructor.md b/reference/unordered_set/unordered_set/op_constructor.md
index 83ceb4e1e..e55faf15e 100644
--- a/reference/unordered_set/unordered_set/op_constructor.md
+++ b/reference/unordered_set/unordered_set/op_constructor.md
@@ -69,8 +69,27 @@ unordered_set(initializer_list&amp;lt;value_type&amp;gt; il,
               size_type n,
               const hasher&amp;amp; hf, 
               const allocator_type&amp;amp; a);                             // (15) C++14
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_set(std::from_range_t, R&amp;amp;&amp;amp; rg,
+              size_type n = 実装依存の既定値,
+              const hasher&amp;amp; hf = hasher(),
+              const key_equal&amp;amp; eql = key_equal(),
+              const allocator_type&amp;amp; a = allocator_type());          // (16) C++23
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_set(std::from_range_t, R&amp;amp;&amp;amp; rg,
+              size_type n,
+              const allocator_type&amp;amp; a);                             // (17) C++23
+
+template &amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+unordered_set(std::from_range_t, R&amp;amp;&amp;amp; rg,
+              size_type n,
+              const hasher&amp;amp; hf,
+              const allocator_type&amp;amp; a);                             // (18) C++23
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 ## 概要
 `unordered_set` オブジェクトを構築する
@@ -137,6 +156,12 @@ unordered_set(initializer_list&amp;lt;value_type&amp;gt; il,
 
 - (15) : (5) の形式を `unordered_set(il, n, hf, key_equal(), a)` として呼び出した場合と等価である。
 
+- (16) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で `unordered_set` が構築された後、Range `rg` の要素が挿入される。
+
+- (17) : (16) の形式を `unordered_set(from_range, std::forward&amp;lt;R&amp;gt;(rg), n, hasher(), key_equal(), a)` として呼び出した場合と等価である。
+
+- (18) : (16) の形式を `unordered_set(from_range, std::forward&amp;lt;R&amp;gt;(rg), n, hf, key_equal(), a)` として呼び出した場合と等価である。
+
 
 ## 事後条件
 以下では構築されたオブジェクトを `u` とする。
@@ -195,6 +220,7 @@ unordered_set(initializer_list&amp;lt;value_type&amp;gt; il,
 - (13) : (3) の形式を `unordered_set(f, l, n, hf, key_equal(), a)` として呼び出した場合と等価。
 - (14) : (5) の形式を `unordered_set(il, n, hasher(), key_equal(), a)` として呼び出した場合と等価。
 - (15) : (5) の形式を `unordered_set(il, n, hf, key_equal(), a)` として呼び出した場合と等価。
+- (16), (17), (18) : 平均的には O(n)、ここで、n は [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)`。最悪のケースでは O(n&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;)
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to list, deque, and string</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/op_constructor.html"/>
      <id>d0f20fcc442cbdefaf64774e01e0e908de46b3e5:reference/deque/deque/op_constructor.md</id>
      <updated>2024-07-27T23:46:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/op_constructor.md b/reference/deque/deque/op_constructor.md
index 8841fdf4f..81bb9d044 100644
--- a/reference/deque/deque/op_constructor.md
+++ b/reference/deque/deque/op_constructor.md
@@ -31,8 +31,13 @@ deque(deque&amp;amp;&amp;amp; y, const Allocator&amp;amp; a);             // (9) C++11 から
 
 deque(initializer_list&amp;lt;T&amp;gt; il,
       const Allocator&amp;amp; a = Allocator());          // (10) C++11 から
+
+template &amp;lt;container-compatible-range&amp;lt;T&amp;gt; R&amp;gt;
+deque(from_range_t, R&amp;amp;&amp;amp; rg,
+      const Allocator&amp;amp; a = Allocator());          // (11) C++23 から
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 
 ## 概要
@@ -55,6 +60,7 @@ deque(initializer_list&amp;lt;T&amp;gt; il,
 - (8) : コピーコンストラクタ。アロケータに `a` を使用して、`x` と同じ要素を保持した `deque` を構築する。
 - (9) : ムーブコンストラクタ。アロケータに `a` を使用して、ムーブセマンティクスを使って `y` の要素でコンテナを構築する。
 - (10) : 初期化子リストで要素を構築するコンストラクタ。`deque(il.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), il.`[`end`](../../initializer_list/initializer_list/end.md)`(), a)` と等価。
+- (11) : Rangeコンストラクタ。アロケータに `a` を使用して、`rg` の要素で `deque` を構築する。
 
 
 ## 計算量
@@ -68,7 +74,8 @@ deque(initializer_list&amp;lt;T&amp;gt; il,
 - (7) : 定数時間
 - (8) : `x` の要素数に対して線形時間
 - (9) : `a == y.`[`get_allocator`](get_allocator.md)`()` の場合、定数時間、そうでなければ `y` の要素数に対して線形時間
-- (10) : `il`の要素数に対して線形時間
+- (10) : `il` の要素数に対して線形時間
+- (11) : `rg` の要素数に対して線形時間
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to list, deque, and string</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/op_constructor.html"/>
      <id>d0f20fcc442cbdefaf64774e01e0e908de46b3e5:reference/forward_list/forward_list/op_constructor.md</id>
      <updated>2024-07-27T23:46:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/op_constructor.md b/reference/forward_list/forward_list/op_constructor.md
index 8429ac4d3..8c5aea629 100644
--- a/reference/forward_list/forward_list/op_constructor.md
+++ b/reference/forward_list/forward_list/op_constructor.md
@@ -32,8 +32,13 @@ forward_list(forward_list&amp;amp;&amp;amp; x, const Allocator&amp;amp; a);      // (9) C++11
 
 forward_list(initializer_list&amp;lt;T&amp;gt; il,
              const Allocator&amp;amp; a = Allocator());          // (10) C++11
+
+template &amp;lt;container-compatible-range&amp;lt;T&amp;gt; R&amp;gt;
+forward_list(from_range_t, R&amp;amp;&amp;amp; rg,
+             const Allocator&amp;amp; a = Allocator());          // (11) C++23
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 ## 概要
 `forward_list`オブジェクトを、以下に示す通りの要素で初期化する。
@@ -53,6 +58,7 @@ forward_list(initializer_list&amp;lt;T&amp;gt; il,
 - (8) : アロケータを指定したコピーコンストラクタ  
 - (9) : アロケータを指定したムーブコンストラクタ  
 - (10) : 初期化子リストを受け取るコンストラクタ。`forward_list(il.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), il.`[`end`](../../initializer_list/initializer_list/end.md)`(), a)` と等価。
+- (11) : Range `rg` の要素をコピーした `forward_list` オブジェクトを構築する。
 
 
 ## 計算量
@@ -65,6 +71,7 @@ forward_list(initializer_list&amp;lt;T&amp;gt; il,
 - (8) : `x` の要素数に対して線形時間
 - (9) : `x.`[`get_allocator`](get_allocator.md)`() == a` であれば、定数時間。そうでなければ `x` の要素数に対して線形時間
 - (10) : `il` の要素数に対して線形時間
+- (11) : `rg` の要素数に対して線形時間
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to list, deque, and string</title>
      <link href="https://cpprefjp.github.io/reference/list/list/op_constructor.html"/>
      <id>d0f20fcc442cbdefaf64774e01e0e908de46b3e5:reference/list/list/op_constructor.md</id>
      <updated>2024-07-27T23:46:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/op_constructor.md b/reference/list/list/op_constructor.md
index 2ec356e95..a881629f4 100644
--- a/reference/list/list/op_constructor.md
+++ b/reference/list/list/op_constructor.md
@@ -29,8 +29,13 @@ list(list&amp;amp;&amp;amp; x, const Allocator&amp;amp; a);              // (9) C++11 から
 
 list(initializer_list&amp;lt;T&amp;gt; il,
      const Allocator&amp;amp; a = Allocator());          // (10) C++11 から
+
+template &amp;lt;container-compatible-range&amp;lt;T&amp;gt; R&amp;gt;
+list(from_range_t, R&amp;amp;&amp;amp; rg,
+     const Allocator&amp;amp; a = Allocator());          // (11) C++23 から
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 
 ## 概要
@@ -48,6 +53,7 @@ list オブジェクトの構築
 - (8) : アロケータを指定したコピーコンストラクタ。
 - (9) : アロケータを指定したムーブコンストラクタ。
 - (10) : 初期化子リストを受け取るコンストラクタ。`list(il.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), il.`[`end`](../../initializer_list/initializer_list/end.md)`(), a)` と等価。
+- (11) : Rangeコンストラクタ。Range `rg` の要素で `list` を構築する。
 
 
 ## 計算量
@@ -57,6 +63,8 @@ list オブジェクトの構築
 - (6), (8) : `x.`[`size`](size.md)`()` に対して線形時間
 - (7) : 定数時間
 - (9) : `a == x.`[`get_allocator`](get_allocator.md)`()` であれば定数時間。そうでなければ `x.`[`size`](size.md)`()` に対して線形時間
+- (10) : `il.`[`size`](../../initializer_list/initializer_list/size.md)`()` に対して線形時間
+- (11) : [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)` に対して線形時間
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to list, deque, and string</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_constructor.html"/>
      <id>d0f20fcc442cbdefaf64774e01e0e908de46b3e5:reference/string/basic_string/op_constructor.md</id>
      <updated>2024-07-27T23:46:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_constructor.md b/reference/string/basic_string/op_constructor.md
index a4d4337da..5bf500824 100644
--- a/reference/string/basic_string/op_constructor.md
+++ b/reference/string/basic_string/op_constructor.md
@@ -118,8 +118,13 @@ constexpr basic_string(const T&amp;amp; t,
                        size_type pos,
                        size_type n,
                        const Allocator&amp;amp; a = Allocator());        // (15) C++20
+
+template &amp;lt;container-compatible-range&amp;lt;CharT&amp;gt; R&amp;gt;
+constexpr basic_string(from_range_t, R&amp;amp;&amp;amp; rg,
+                       const Allocator&amp;amp; a = Allocator());        // (19) C++23
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 ## 概要
 - (1) : デフォルトコンストラクタ。アロケータをデフォルト構築して空の`basic_string`オブジェクトを構築する。
@@ -139,6 +144,7 @@ constexpr basic_string(const T&amp;amp; t,
 - (15) : [`basic_string_view`](/reference/string_view/basic_string_view.md)`&amp;lt;charT, traits&amp;gt;`に変換可能な`t`が参照する範囲の文字列の`pos`番目から`n`文字の部分文字列がコピーされる。`n == npos`の場合、`pos`番目から末尾までの部分文字列がコピーされる。
 - (17) : `str`オブジェクトの部分文字列のコピーから`basic_string`オブジェクトを構築する。`str`オブジェクトの`pos`番目から`n`文字の部分文字列がコピーされる。`n == npos`の場合、`pos`番目から末尾までの部分文字列がコピーされる。`str`は未規定の値になる。
 - (18) : `str`オブジェクトの部分文字列のコピーから`basic_string`オブジェクトを構築する。`str`オブジェクトの`pos`番目から末尾までの部分文字列がコピーされる。`str`は未規定の値になる。
+- (19) : Range`rg`から`basic_string`オブジェクトを構築する。
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to map and set</title>
      <link href="https://cpprefjp.github.io/reference/map/map/op_constructor.html"/>
      <id>f45447e6da9c7e0f0949b475509b1493f654487e:reference/map/map/op_constructor.md</id>
      <updated>2024-07-27T18:49:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/op_constructor.md b/reference/map/map/op_constructor.md
index de6950de8..a6a69716a 100644
--- a/reference/map/map/op_constructor.md
+++ b/reference/map/map/op_constructor.md
@@ -40,8 +40,18 @@ map(initializer_list&amp;lt;value_type&amp;gt; init,
 
 map(initializer_list&amp;lt;value_type&amp;gt; init,
     const Allocator&amp;amp; alloc);                           // (11) C++14 から
+
+template &amp;lt;container-compatible-range &amp;lt;value_type&amp;gt; R&amp;gt;
+map(from_range_t, R&amp;amp;&amp;amp; rg,
+    const Compare&amp;amp; comp = Compare(),
+    const Allocator&amp;amp; alloc = Allocator());             // (12) C++23 から
+
+template &amp;lt;container-compatible-range &amp;lt;value_type&amp;gt; R&amp;gt;
+map(from_range_t, R&amp;amp;&amp;amp; rg,
+    const Allocator&amp;amp; alloc);                           // (13) C++23 から
 ```
 * initializer_list[link ../../initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 ## 概要
 `map` オブジェクトの構築
@@ -60,6 +70,8 @@ map(initializer_list&amp;lt;value_type&amp;gt; init,
 - (9) アロケータ `alloc` を指定したムーブコンストラクタ。`y` の要素をムーブすることで `map` オブジェクトを構築する。（C++11 から）
 - (10) 比較オブジェクト `comp`、アロケータ `alloc` 、および初期化リスト `init` の要素で `map` オブジェクトを構築する。`map(init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`(), comp, alloc)` と等価。（C++11 から）
 - (11) アロケータ `alloc` 、および初期化リスト `init` の要素で `map` オブジェクトを構築する。`map(init, Compare(), alloc)` と等価。（C++14 から）
+- (12) Rangeコンストラクタ。比較オブジェクト `comp`、アロケータ `alloc` 、およびRange `rg` の要素で `map` オブジェクトを構築する。
+- (13) Rangeコンストラクタ。アロケータ `alloc` 、およびRange `rg` の要素で `map` オブジェクトを構築する。
 
 
 ## 計算量
@@ -69,6 +81,7 @@ map(initializer_list&amp;lt;value_type&amp;gt; init,
 - (8) 定数時間
 - (9) 定数時間。但し、`alloc == y.`[`get_allocator`](/reference/map/map/get_allocator.md)`()` でなければ `y.`[`size`](size.md)`()` に対して線形時間
 - (10)、(11) `N = init.`[`size`](../../initializer_list/initializer_list/size.md)`()` とすると、範囲 `[init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`())` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
+- (12)、(13) `N =` [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)` とすると、`rg` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to map and set</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/op_constructor.html"/>
      <id>f45447e6da9c7e0f0949b475509b1493f654487e:reference/map/multimap/op_constructor.md</id>
      <updated>2024-07-27T18:49:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/op_constructor.md b/reference/map/multimap/op_constructor.md
index ac4fc9f3d..72cfb0496 100644
--- a/reference/map/multimap/op_constructor.md
+++ b/reference/map/multimap/op_constructor.md
@@ -42,8 +42,18 @@ multimap(initializer_list&amp;lt;value_type&amp;gt; init,
 
 multimap(initializer_list&amp;lt;value_type&amp;gt; init,
          const Allocator&amp;amp; alloc);                        // (11) C++14 から
+
+template &amp;lt;container-compatible-range &amp;lt;value_type&amp;gt; R&amp;gt;
+multimap(from_range_t, R&amp;amp;&amp;amp; rg,
+         const Compare&amp;amp; comp = Compare(),
+         const Allocator&amp;amp; alloc = Allocator());          // (12) C++23 から
+
+template &amp;lt;container-compatible-range &amp;lt;value_type&amp;gt; R&amp;gt;
+multimap(from_range_t, R&amp;amp;&amp;amp; rg,
+         const Allocator&amp;amp; alloc);                        // (13) C++23 から
 ```
 * initializer_list[link ../../initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 
 ## 概要
@@ -63,6 +73,8 @@ multimap(initializer_list&amp;lt;value_type&amp;gt; init,
 - (9) アロケータ `alloc` を指定したムーブコンストラクタ。`y` の要素をムーブすることでコンテナを構築する。（C++11 から）
 - (10) 比較オブジェクト `comp`、アロケータ `alloc`、および初期化リスト `init` の要素で `multimap` オブジェクトを構築する。`multimap(init.`[`begin`](../../initializer_list/initializer_list/begin.md)`, init.`[`end`](../../initializer_list/initializer_list/end.md)`, comp, alloc)` と等価。（C++11 から）
 - (11) アロケータ `alloc`、および初期化リスト `init` の要素で `multimap` オブジェクトを構築する。`multimap(init, Compare(), alloc)` と等価。（C++14 から）
+- (12) Rangeコンストラクタ。比較オブジェクト `comp`、アロケータ `alloc` 、およびRange `rg` の要素で `multimap` オブジェクトを構築する。
+- (13) Rangeコンストラクタ。アロケータ `alloc` 、およびRange `rg` の要素で `multimap` オブジェクトを構築する。
 
 
 ## 計算量
@@ -72,6 +84,7 @@ multimap(initializer_list&amp;lt;value_type&amp;gt; init,
 - (8) 定数時間
 - (9) 定数時間。ただし、`alloc == y.`[`get_allocator`](get_allocator.md)`()` でなければ `y.`[`size`](size.md)`()` に対して線形時間
 - (10)、(11) `N = init.`[`size`](../../initializer_list/initializer_list/size.md)`()` とすると、範囲 `[init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`())` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
+- (12)、(13) `N =` [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)` とすると、`rg` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to map and set</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/op_constructor.html"/>
      <id>f45447e6da9c7e0f0949b475509b1493f654487e:reference/set/multiset/op_constructor.md</id>
      <updated>2024-07-27T18:49:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/op_constructor.md b/reference/set/multiset/op_constructor.md
index 2d547bfe5..dff5fb8b5 100644
--- a/reference/set/multiset/op_constructor.md
+++ b/reference/set/multiset/op_constructor.md
@@ -31,13 +31,23 @@ multiset(const set&amp;amp; x, const Allocator&amp;amp; alloc);          // (8) C++11
 multiset(set&amp;amp;&amp;amp; y, const Allocator&amp;amp; alloc);               // (9) C++11
 
 multiset(initializer_list&amp;lt;value_type&amp;gt; init,
-    const Compare&amp;amp; comp = Compare(),
-    const Allocator&amp;amp; alloc = Allocator());          // (10) C++11
+         const Compare&amp;amp; comp = Compare(),
+         const Allocator&amp;amp; alloc = Allocator());          // (10) C++11
 
 multiset(initializer_list&amp;lt;value_type&amp;gt; init,
-    const Allocator&amp;amp; a);                            // (11) C++14
+         const Allocator&amp;amp; a);                            // (11) C++14
+
+template &amp;lt;container-compatible-range &amp;lt;value_type&amp;gt; R&amp;gt;
+multiset(from_range_t, R&amp;amp;&amp;amp; rg,
+         const Compare&amp;amp; comp = Compare(),
+         const Allocator&amp;amp; alloc = Allocator());          // (12) C++23
+
+template &amp;lt;container-compatible-range &amp;lt;value_type&amp;gt; R&amp;gt;
+multiset(from_range_t, R&amp;amp;&amp;amp; rg,
+         const Allocator&amp;amp; alloc);                        // (13) C++23
 ```
 * initializer_list[link ../../initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 
 ## 概要
@@ -54,7 +64,9 @@ multiset(initializer_list&amp;lt;value_type&amp;gt; init,
 - (6), (8) : コピーコンストラクタ。`x`のコンテンツのコピーでコンテナを構築する。もし `alloc` が与えられなかった場合、アロケータを `std::`[`allocator_traits`](../../memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`select_on_container_copy_construction`](../../memory/allocator_traits/select_on_container_copy_construction.md)`(x.`[`get_allocator`](get_allocator.md)`())` の呼び出しによって取得する。
 - (7), (9) : ムーブコンストラクタ。`y` のコンテンツをムーブすることでコンテナを構築する。もし `alloc` が与えられなかった場合、アロケータを `y` に属しているアロケータをムーブして取得する。
 - (10) : 初期化リスト `init` のコンテンツでコンテナを構築する。
-- (11) : (10)のコンストラクタを `set(init, Compare(), a)` のように呼び出して、`multiset`オブジェクトを構築する。
+- (11) : (10)のコンストラクタを `multiset(init, Compare(), a)` のように呼び出して、`multiset`オブジェクトを構築する。
+- (12) : Range `rg` の要素で `multiset` オブジェクトを構築する。
+- (13) : (12)のコンストラクタを `multiset(`[`from_range`](../../ranges/from_range_t.md)`, rg, Compare(), alloc)` のように呼び出して、`multiset`オブジェクトを構築する。
 
 
 ## 計算量
@@ -63,6 +75,7 @@ multiset(initializer_list&amp;lt;value_type&amp;gt; init,
 - (6), (8) : `x` の [`size`](size.md) に対して線形時間（全要素をコピー構築する）。
 - (7), (9) : 定数時間。ただし、`alloc` が与えられてかつ `alloc != y.`[`get_allocator`](get_allocator.md)`()` の場合は線形時間。
 - (10), (11) : `comp` によって既にソート済みである場合は、`init` のサイズ（コピーコンストラクト）。未ソートの `init` の場合は、`init` のサイズについて N * logN （ソート、コピーコンストラクト）。
+- (12), (13) : `comp` によって既にソート済みである場合は、`rg` のサイズ（コピーコンストラクト）。未ソートの `rg` の場合は、`rg` のサイズについて N * logN （ソート、コピーコンストラクト）。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- add range constructor to map and set</title>
      <link href="https://cpprefjp.github.io/reference/set/set/op_constructor.html"/>
      <id>f45447e6da9c7e0f0949b475509b1493f654487e:reference/set/set/op_constructor.md</id>
      <updated>2024-07-27T18:49:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/op_constructor.md b/reference/set/set/op_constructor.md
index 22e8e1e44..69d2b4834 100644
--- a/reference/set/set/op_constructor.md
+++ b/reference/set/set/op_constructor.md
@@ -36,8 +36,18 @@ set(initializer_list&amp;lt;value_type&amp;gt; init,
 
 set(initializer_list&amp;lt;value_type&amp;gt; init,
     const Allocator&amp;amp; a);                            // (11) C++14
+
+template &amp;lt;container-compatible-range &amp;lt;value_type&amp;gt; R&amp;gt;
+set(from_range_t, R&amp;amp;&amp;amp; rg,
+    const Compare&amp;amp; comp = Compare(),
+    const Allocator&amp;amp; alloc = Allocator());          // (12) C++23
+
+template &amp;lt;container-compatible-range &amp;lt;value_type&amp;gt; R&amp;gt;
+set(from_range_t, R&amp;amp;&amp;amp; rg,
+    const Allocator&amp;amp; alloc);                        // (13) C++23
 ```
 * initializer_list[link ../../initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
 
 
 ## 概要
@@ -55,6 +65,8 @@ set(initializer_list&amp;lt;value_type&amp;gt; init,
 - (7), (9) : ムーブコンストラクタ。`y` のコンテンツをムーブすることでコンテナを構築する。もし `alloc` が与えられなかった場合、アロケータを `y` に属しているアロケータをムーブして取得する。
 - (10) : 初期化リスト `init` のコンテンツでコンテナを構築する。
 - (11) : (10)のコンストラクタを `set(init, Compare(), a)` のように呼び出して、`set`オブジェクトを構築する。
+- (12) : Range `rg` の要素で `set` オブジェクトを構築する。
+- (13) : (12)のコンストラクタを `set(`[`from_range`](../../ranges/from_range_t.md)`, rg, Compare(), alloc)` のように呼び出して、`set`オブジェクトを構築する。
 
 
 ## 計算量
@@ -63,6 +75,7 @@ set(initializer_list&amp;lt;value_type&amp;gt; init,
 - (6), (8) : `x` の [`size`](size.md) に対して線形時間（全要素をコピー構築する）。
 - (7), (9) : 定数時間。ただし、`alloc` が与えられてかつ `alloc != y.`[`get_allocator`](get_allocator.md)`()` の場合は線形時間。
 - (10), (11) : `comp` によって既にソート済みである場合は、`init` のサイズ（コピーコンストラクト）。未ソートの `init` の場合は、`init` のサイズについて N * logN （ソート、コピーコンストラクト）。
+- (12), (13) : `comp` によって既にソート済みである場合は、`rg` のサイズ（コピーコンストラクト）。未ソートの `rg` の場合は、`rg` のサイズについて N * logN （ソート、コピーコンストラクト）。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- fix description about constructor complexity in map and set</title>
      <link href="https://cpprefjp.github.io/reference/map/map/op_constructor.html"/>
      <id>75e450d08d80a5cdbf2ca0648edd0172436062e9:reference/map/map/op_constructor.md</id>
      <updated>2024-07-27T17:57:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/op_constructor.md b/reference/map/map/op_constructor.md
index 044525df9..de6950de8 100644
--- a/reference/map/map/op_constructor.md
+++ b/reference/map/map/op_constructor.md
@@ -67,8 +67,8 @@ map(initializer_list&amp;lt;value_type&amp;gt; init,
 - (4)、(5) `N =` [`distance`](../../iterator/distance.md)`(first, last)` とすると、範囲 `[first, last)` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
 - (6)、(7) `x.`[`size`](size.md)`()`  に対して線形時間
 - (8) 定数時間
-- (9) 定数時間。但し、`alloc == y.`[`get_allocator`](/reference/map/map/get_allocator.md)`()` でなければ `y.`[`size`](size.md)`()` に対して線形時間。
-- (10)、(11) `init.`[`size`](size.md)`()` に対して線形時間。
+- (9) 定数時間。但し、`alloc == y.`[`get_allocator`](/reference/map/map/get_allocator.md)`()` でなければ `y.`[`size`](size.md)`()` に対して線形時間
+- (10)、(11) `N = init.`[`size`](../../initializer_list/initializer_list/size.md)`()` とすると、範囲 `[init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`())` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- fix description about constructor complexity in map and set</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/op_constructor.html"/>
      <id>75e450d08d80a5cdbf2ca0648edd0172436062e9:reference/map/multimap/op_constructor.md</id>
      <updated>2024-07-27T17:57:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/op_constructor.md b/reference/map/multimap/op_constructor.md
index 399f10e85..ac4fc9f3d 100644
--- a/reference/map/multimap/op_constructor.md
+++ b/reference/map/multimap/op_constructor.md
@@ -71,7 +71,7 @@ multimap(initializer_list&amp;lt;value_type&amp;gt; init,
 - (6)、(7) `x.`[`size`](size.md)`()` に対して線形時間
 - (8) 定数時間
 - (9) 定数時間。ただし、`alloc == y.`[`get_allocator`](get_allocator.md)`()` でなければ `y.`[`size`](size.md)`()` に対して線形時間
-- (10)、(11) `init.`[`size`](size.md)`()` に対して線形時間
+- (10)、(11) `N = init.`[`size`](../../initializer_list/initializer_list/size.md)`()` とすると、範囲 `[init.`[`begin`](../../initializer_list/initializer_list/begin.md)`(), init.`[`end`](../../initializer_list/initializer_list/end.md)`())` が比較オブジェクト `comp` によって既にソート済みである場合は `N` に比例、そうでなければ `N log N` に比例
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- fix description about constructor complexity in map and set</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/op_constructor.html"/>
      <id>75e450d08d80a5cdbf2ca0648edd0172436062e9:reference/set/multiset/op_constructor.md</id>
      <updated>2024-07-27T17:57:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/op_constructor.md b/reference/set/multiset/op_constructor.md
index ff871be24..2d547bfe5 100644
--- a/reference/set/multiset/op_constructor.md
+++ b/reference/set/multiset/op_constructor.md
@@ -62,7 +62,7 @@ multiset(initializer_list&amp;lt;value_type&amp;gt; init,
 - (4), (5) : `comp` によって既にソート済みである場合は、イテレータ間の距離（コピーコンストラクト）。未ソートのシーケンスの場合は、それらの距離について N * logN （ソート、コピーコンストラクト）。
 - (6), (8) : `x` の [`size`](size.md) に対して線形時間（全要素をコピー構築する）。
 - (7), (9) : 定数時間。ただし、`alloc` が与えられてかつ `alloc != y.`[`get_allocator`](get_allocator.md)`()` の場合は線形時間。
-- (10), (11) : `init` の要素数に対して線形時間。
+- (10), (11) : `comp` によって既にソート済みである場合は、`init` のサイズ（コピーコンストラクト）。未ソートの `init` の場合は、`init` のサイズについて N * logN （ソート、コピーコンストラクト）。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- fix description about constructor complexity in map and set</title>
      <link href="https://cpprefjp.github.io/reference/set/set/op_constructor.html"/>
      <id>75e450d08d80a5cdbf2ca0648edd0172436062e9:reference/set/set/op_constructor.md</id>
      <updated>2024-07-27T17:57:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/op_constructor.md b/reference/set/set/op_constructor.md
index d87fbf344..22e8e1e44 100644
--- a/reference/set/set/op_constructor.md
+++ b/reference/set/set/op_constructor.md
@@ -62,7 +62,7 @@ set(initializer_list&amp;lt;value_type&amp;gt; init,
 - (4), (5) : `comp` によって既にソート済みである場合は、イテレータ間の距離（コピーコンストラクト）。未ソートのシーケンスの場合は、それらの距離について N * logN （ソート、コピーコンストラクト）。
 - (6), (8) : `x` の [`size`](size.md) に対して線形時間（全要素をコピー構築する）。
 - (7), (9) : 定数時間。ただし、`alloc` が与えられてかつ `alloc != y.`[`get_allocator`](get_allocator.md)`()` の場合は線形時間。
-- (10), (11) : `init` の要素数に対して線形時間。
+- (10), (11) : `comp` によって既にソート済みである場合は、`init` のサイズ（コピーコンストラクト）。未ソートの `init` の場合は、`init` のサイズについて N * logN （ソート、コピーコンストラクト）。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exclusive_scan -- partial_sum, inclusive_scan, exclusive_scanを相互に関連項目として記載</title>
      <link href="https://cpprefjp.github.io/reference/numeric/exclusive_scan.html"/>
      <id>1052eda6535c93d8971ab4e459cefc0043447725:reference/numeric/exclusive_scan.md</id>
      <updated>2024-07-26T11:57:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/exclusive_scan.md b/reference/numeric/exclusive_scan.md
index e7e5c35ce..fa857c0e9 100644
--- a/reference/numeric/exclusive_scan.md
+++ b/reference/numeric/exclusive_scan.md
@@ -181,6 +181,11 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 関連項目
+- [`std::inclusive_scan()`](inclusive_scan.md)
+- [`std::partial_sum()`](partial_sum.md)
+
+
 ## 参照
 - [P0024R2 The Parallelism TS Should be Standardized](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html)
 - [P0467R2 Iterator Concerns for Parallel Algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0467r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inclusive_scan -- partial_sum, inclusive_scan, exclusive_scanを相互に関連項目として記載</title>
      <link href="https://cpprefjp.github.io/reference/numeric/inclusive_scan.html"/>
      <id>1052eda6535c93d8971ab4e459cefc0043447725:reference/numeric/inclusive_scan.md</id>
      <updated>2024-07-26T11:57:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/inclusive_scan.md b/reference/numeric/inclusive_scan.md
index cd8fdfbc5..71d96dfa3 100644
--- a/reference/numeric/inclusive_scan.md
+++ b/reference/numeric/inclusive_scan.md
@@ -228,6 +228,11 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 関連項目
+- [`std::exclusive_scan()`](exclusive_scan.md)
+- [`std::partial_sum()`](partial_sum.md)
+
+
 ## 参照
 - [P0024R2 The Parallelism TS Should be Standardized](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0024r2.html)
 - [P0467R2 Iterator Concerns for Parallel Algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0467r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sum -- partial_sum, inclusive_scan, exclusive_scanを相互に関連項目として記載</title>
      <link href="https://cpprefjp.github.io/reference/numeric/partial_sum.html"/>
      <id>1052eda6535c93d8971ab4e459cefc0043447725:reference/numeric/partial_sum.md</id>
      <updated>2024-07-26T11:57:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/partial_sum.md b/reference/numeric/partial_sum.md
index f6305b306..ff5c8ce26 100644
--- a/reference/numeric/partial_sum.md
+++ b/reference/numeric/partial_sum.md
@@ -154,6 +154,11 @@ int main()
 ```
 
 
+## 関連項目
+- [`std::inclusive_scan()`](inclusive_scan.md)
+- [`std::exclusive_scan()`](exclusive_scan.md)
+
+
 ## 参照
 - [P0616R0 De-pessimize legacy `&amp;lt;numeric&amp;gt;` algorithms with `std::move`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0616r0.pdf)
 - [P1645R1 `constexpr` for `&amp;lt;numeric&amp;gt;` algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1645r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>