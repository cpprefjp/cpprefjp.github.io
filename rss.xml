<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-03-19T23:15:09.245838</updated>
  <id>aebfddd3-ad40-45c0-ac99-ad1d0ad4f65e</id>

  
    <entry>
      <title>algorithm -- ranges::nth_elementの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>f5ca01f77ff7ec3dd1d619d0c3309214bbb68421:reference/algorithm.md</id>
      <updated>2022-03-20T08:10:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 8949fa970..1ac82501f 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -286,7 +286,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------|----------------------------------------------------------|-------|
 | [`nth_element`](algorithm/nth_element.md) | 基準となる要素よりも小さい要素が、前に来るよう並べ替える | |
-| [`ranges::nth_element`](algorithm/ranges_nth_element.md.nolink) | 基準となる要素よりも小さい要素が、前に来るよう並べ替える | C++20 |
+| [`ranges::nth_element`](algorithm/ranges_nth_element.md) | 基準となる要素よりも小さい要素が、前に来るよう並べ替える | C++20 |
 
 
 ### &amp;lt;a id=&amp;#34;alg.binary.search&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;二分探索
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- ranges::nth_elementの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>f5ca01f77ff7ec3dd1d619d0c3309214bbb68421:reference/algorithm/ranges_nth_element.md</id>
      <updated>2022-03-20T08:10:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
new file mode 100644
index 000000000..df997c8e7
--- /dev/null
+++ b/reference/algorithm/ranges_nth_element.md
@@ -0,0 +1,90 @@
+# nth_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr I nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; nth_element(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; nth, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/iterator/iterator_t.md]
+* borrowed_iterator_t[link /reference/iterator/borrowed_iterator_t.md]
+
+
+## 概要
+基準となる要素よりも小さい要素が前に来るよう並べ替える。
+
+この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
+
+ある範囲に対して部分的な並び替えを行う場合、[`partial_sort()`](partial_sort.md)を使用する。また範囲全体に対して並び替えを行う場合、[`sort()`](sort.md)を使用する。
+
+## 効果
+`nth_element()` を呼び出した後、`nth` が指している位置の要素は、全ての範囲がソートされた場合の位置にある要素になる。そして、`[first,nth)` にあるイテレータ `i` と、`[nth,last)` にあるイテレータ `j` について、`!(*j &amp;lt; *i)` または `comp(*j, *i) == false` になる。
+
+
+## 戻り値
+`last`
+
+
+## 計算量
+平均で線形時間
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {5, 10, 4, 7, 1, 9, 8, 6, 2};
+
+  // 4番目に小さい値より小さい値を前に集める
+  std::ranges::nth_element(v, v.begin() + 3);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::nth_element[color ff0000]
+
+### 出力例
+```
+2
+1
+4
+5
+7
+6
+8
+9
+10
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- Range版を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>16973ba34d98191e0903aa167c948eb04a6064c4:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2022-03-20T08:06:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index 6ea70e671..6cec98e4c 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -9,6 +9,10 @@ namespace std::ranges {
   template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
   constexpr I partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; partial_sort(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, Comp comp = {}, Proj proj = {});
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -16,6 +20,9 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * identity[link /reference/functional/identity.md]
 * sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/iterator/iterator_t.md]
+* borrowed_iterator_t[link /reference/iterator/borrowed_iterator_t.md]
 
 
 ## 概要
@@ -47,7 +54,7 @@ int main()
   std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 2, 5};
 
   // 先頭2要素を並んだ状態にする
-  std::ranges::partial_sort(v.begin(), v.begin() + 2, v.end());
+  std::ranges::partial_sort(v, v.begin() + 2);
 
   for (int i : v) {
     std::cout &amp;lt;&amp;lt; i;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- 戻り値と計算量を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort_copy.html"/>
      <id>2c26367f2ad2158627d052cac1d7421607162ef4:reference/algorithm/ranges_partial_sort_copy.md</id>
      <updated>2022-03-20T08:00:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort_copy.md b/reference/algorithm/ranges_partial_sort_copy.md
index c7f2b0cef..9c7922ca3 100644
--- a/reference/algorithm/ranges_partial_sort_copy.md
+++ b/reference/algorithm/ranges_partial_sort_copy.md
@@ -47,15 +47,17 @@ namespace std::ranges {
 * (2): 範囲を直接指定する
 
 ## 効果
-`[first,last)` にある要素の中から、[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` 個の要素をソート済みの状態で `[result_first,result_first +` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first))` に配置する。
+`N = `[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` とする。
+
+`[first,last)` にある要素の中から、`N` 個の要素をソート済みの状態で `[result_first,result_first + N)` に配置する。
 
 
 ## 戻り値
-`result_last` と `result_first + (last - first)` で小さい方が返される
+`{last, result_first + N}`
 
 
 ## 計算量
-ほぼ `(last - first) * log(min(last - first, result_last - result_- first))` 回の比較を行う
+ほぼ `(last - first) * log(N)` 回の比較を行う
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ソート系関数の残りの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>93d43ae764c0123c6b7c46d86c77d709314000e4:reference/algorithm.md</id>
      <updated>2022-03-20T07:54:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 9f329068e..8949fa970 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -275,11 +275,11 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`is_sorted`](algorithm/is_sorted.md)                 | ソート済みか判定する | C++11 |
 | [`is_sorted_until`](algorithm/is_sorted_until.md)     | ソート済みか判定し、ソートされていない位置のイテレータを取得する | C++11 |
 | [`ranges::sort`](algorithm/ranges_sort.md)                           | 範囲を並べ替える                                                 | C++20 |
-| [`ranges::stable_sort`](algorithm/ranges_stable_sort.md.nolink)             | 範囲を安定ソートで並べ替える                                     | C++20 |
-| [`ranges::partial_sort`](algorithm/ranges_partial_sort.md.nolink)           | 範囲を部分的にソートし、先頭N個を並んだ状態にする                | C++20 |
-| [`ranges::partial_sort_copy`](algorithm/ranges_partial_sort_copy.md.nolink) | 範囲を部分的にソートした結果を他の範囲にコピーする               | C++20 |
-| [`ranges::is_sorted`](algorithm/ranges_is_sorted.md.nolink)                 | ソート済みか判定する                                             | C++20 |
-| [`ranges::is_sorted_until`](algorithm/ranges_is_sorted_until.md.nolink)     | ソート済みか判定し、ソートされていない位置のイテレータを取得する | C++20 |
+| [`ranges::stable_sort`](algorithm/ranges_stable_sort.md)             | 範囲を安定ソートで並べ替える                                     | C++20 |
+| [`ranges::partial_sort`](algorithm/ranges_partial_sort.md)           | 範囲を部分的にソートし、先頭N個を並んだ状態にする                | C++20 |
+| [`ranges::partial_sort_copy`](algorithm/ranges_partial_sort_copy.md) | 範囲を部分的にソートした結果を他の範囲にコピーする               | C++20 |
+| [`ranges::is_sorted`](algorithm/ranges_is_sorted.md)                 | ソート済みか判定する                                             | C++20 |
+| [`ranges::is_sorted_until`](algorithm/ranges_is_sorted_until.md)     | ソート済みか判定し、ソートされていない位置のイテレータを取得する | C++20 |
 
 ### N 番目の要素
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted -- ソート系関数の残りの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted.html"/>
      <id>93d43ae764c0123c6b7c46d86c77d709314000e4:reference/algorithm/ranges_is_sorted.md</id>
      <updated>2022-03-20T07:54:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted.md b/reference/algorithm/ranges_is_sorted.md
new file mode 100644
index 000000000..6b9bf9a3a
--- /dev/null
+++ b/reference/algorithm/ranges_is_sorted.md
@@ -0,0 +1,73 @@
+# is_sorted
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+* cpp11[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool is_sorted(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+与えられた範囲がソート済みか判定する。
+
+### 戻り値
+- (1) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(first, last, comp, proj) == last`
+- (2) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(r, comp, proj) == last`
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 2, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is sorted? &amp;#34; &amp;lt;&amp;lt; std::ranges::is_sorted(v) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::sort(v);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is sorted? &amp;#34; &amp;lt;&amp;lt; std::ranges::is_sorted(v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::sort[link ranges_sort.md]
+* std::ranges::is_sorted[color ff0000]
+
+### 出力
+```
+before: is sorted? false
+ after: is sorted? true
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- ソート系関数の残りの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted_until.html"/>
      <id>93d43ae764c0123c6b7c46d86c77d709314000e4:reference/algorithm/ranges_is_sorted_until.md</id>
      <updated>2022-03-20T07:54:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted_until.md b/reference/algorithm/ranges_is_sorted_until.md
new file mode 100644
index 000000000..56950e369
--- /dev/null
+++ b/reference/algorithm/ranges_is_sorted_until.md
@@ -0,0 +1,119 @@
+# is_sorted_until
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; is_sorted_until(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+ソート済みか判定し、ソートされていない位置のイテレータを取得する
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 戻り値
+[`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、`[first,last]` の中でソートされている範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
+
+
+## 計算量
+線形時間
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 2, 5};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is sorted? &amp;#34;
+            &amp;lt;&amp;lt; (std::ranges::is_sorted_until(v) == v.end()) &amp;lt;&amp;lt; std::endl;
+
+  std::sort(v.begin(), v.end());
+
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is sorted? &amp;#34;
+            &amp;lt;&amp;lt; (std::ranges::is_sorted_until(v) == v.end()) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_sorted_until[color ff0000]
+
+### 出力
+```
+before: is sorted? false
+ after: is sorted? true
+```
+
+
+## 実装例
+```cpp
+
+struct is_sorted_until_impl {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I operator()(I first, S last, Comp comp = {}, Proj proj = {}) {
+    auto it = first;
+    if (it == last || ++it == last)
+      return last;
+    while (it != last &amp;amp;&amp;amp; *first &amp;lt; *it)
+      ++first, ++it;
+    return it;
+  }
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {}) {
+    return (*this)(begin(r), end(r), ref(comp), ref(proj));
+  }
+};
+
+inline constexpr is_sorted_until_impl is_sorted_until;
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- ソート系関数の残りの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>93d43ae764c0123c6b7c46d86c77d709314000e4:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2022-03-20T07:54:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
new file mode 100644
index 000000000..6ea70e671
--- /dev/null
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -0,0 +1,76 @@
+# partial_sort
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr I partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+
+
+## 概要
+範囲を部分的にソートし、先頭 `N` 個を順に並んだ状態にする。`N` は `middle - first` で決まる。
+
+この関数は、「売り上げランキング トップ1位から10位まで」のように、全体ではなく最高順位から途中までの順位がわかればよい状況で、全体を並び替える[`sort()`](sort.md)関数の代わりに使用できる。
+
+なお、トップ10がどれかわかれば十分である（1位から10位までは順不同でよい）ような場合、[`nth_element()`](nth_element.md)が使用できる。
+
+## 効果
+`[first,last)` にある要素の中から、`middle - first` 個の要素をソート済みの状態で `[first,middle)` に配置する。残りの `[middle,last)` にある要素は unspecified order に配置される。
+
+
+## 戻り値
+`last`
+
+## 計算量
+ほぼ `(last - first) * log(middle - first)` 回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 2, 5};
+
+  // 先頭2要素を並んだ状態にする
+  std::ranges::partial_sort(v.begin(), v.begin() + 2, v.end());
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partial_sort[color ff0000]
+
+### 出力
+```
+12435
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- ソート系関数の残りの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort_copy.html"/>
      <id>93d43ae764c0123c6b7c46d86c77d709314000e4:reference/algorithm/ranges_partial_sort_copy.md</id>
      <updated>2022-03-20T07:54:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort_copy.md b/reference/algorithm/ranges_partial_sort_copy.md
new file mode 100644
index 000000000..c7f2b0cef
--- /dev/null
+++ b/reference/algorithm/ranges_partial_sort_copy.md
@@ -0,0 +1,99 @@
+# partial_sort_copy
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I, class O&amp;gt;
+  using partial_sort_copy_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, random_access_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp; sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+             indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+  constexpr partial_sort_copy_result&amp;lt;I1, I2&amp;gt;
+    partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;input_range R1, random_access_range R2,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+             indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;
+  constexpr partial_sort_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    partial_sort_copy(R1&amp;amp;&amp;amp; r, R2&amp;amp;&amp;amp; result_r, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                              // (2)
+}
+```
+* in_out_result[link in_out_result.md.nolink]
+* input_iterator[link /reference/iterator/input_iterator.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* sortable[link /reference/iterator/sortable.md]
+* input_range[link /reference/ranges/input_range.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+範囲を部分的にソートした結果を他の範囲にコピーする
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+`[first,last)` にある要素の中から、[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` 個の要素をソート済みの状態で `[result_first,result_first +` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first))` に配置する。
+
+
+## 戻り値
+`result_last` と `result_first + (last - first)` で小さい方が返される
+
+
+## 計算量
+ほぼ `(last - first) * log(min(last - first, result_last - result_- first))` 回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 2, 5};
+
+  // vから小さい順に2要素取り出す
+  std::vector&amp;lt;int&amp;gt; result(2);
+  std::ranges::partial_sort_copy(v, result);
+
+  for (int i : result) {
+    std::cout &amp;lt;&amp;lt; i;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partial_sort_copy[color ff0000]
+
+### 出力
+```
+12
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- ソート系関数の残りの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>93d43ae764c0123c6b7c46d86c77d709314000e4:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2022-03-20T07:54:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
new file mode 100644
index 000000000..2dc175e2c
--- /dev/null
+++ b/reference/algorithm/ranges_partition_copy.md
@@ -0,0 +1,125 @@
+# partition_copy
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+* cpp11[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class InputIterator,
+            class OutputIterator1,
+            class OutputIterator2,
+            class Predicate&amp;gt;
+  pair&amp;lt;OutputIterator1, OutputIterator2&amp;gt;
+    partition_copy(InputIterator first,
+                   InputIterator last,
+                   OutputIterator1 out_true,
+                   OutputIterator2 out_false,
+                   Predicate pred);            // (1) C++11
+
+  template &amp;lt;class InputIterator,
+            class OutputIterator1,
+            class OutputIterator2,
+            class Predicate&amp;gt;
+  constexpr pair&amp;lt;OutputIterator1, OutputIterator2&amp;gt;
+    partition_copy(InputIterator first,
+                   InputIterator last,
+                   OutputIterator1 out_true,
+                   OutputIterator2 out_false,
+                   Predicate pred);            // (1) C++20
+
+  template &amp;lt;class ExecutionPolicy,
+            class ForwardIterator,
+            class ForwardIterator1,
+            class ForwardIterator2,
+            class Predicate&amp;gt;
+  pair&amp;lt;ForwardIterator1, ForwardIterator2&amp;gt;
+    partition_copy(ExecutionPolicy&amp;amp;&amp;amp; exec,
+                   ForwardIterator first,
+                   ForwardIterator last,
+                   ForwardIterator1 out_true,
+                   ForwardIterator2 out_false,
+                   Predicate pred);            // (2) C++17
+}
+```
+* pair[link /reference/utility/pair.md]
+
+## 概要
+与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする。
+
+
+## 要件
+- `InputIterator` の value type は `Assignable` で、`out_true` と `out_false` の `OutputIterator` へ書き込み可能で、`Predicate` の argument type へ変換可能でなければならない。
+- 入力範囲は出力範囲のどちらとも重なっていてはならない。
+
+
+## 効果
+`[first,last)` 内にあるそれぞれのイテレータ `i` について、`pred(*i)` が `true` なら `*i` を `out_true` へコピーし、そうでない場合は `out_false` へコピーする。
+
+
+## 戻り値
+`first` には `out_true` の終端が、`second` には `out_false` の終端が格納された[`pair`](/reference/utility/pair.md)オブジェクトを返す。
+
+
+## 計算量
+正確に `last - first` 回述語が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+void print(const std::string&amp;amp; name, const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
+{
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; : &amp;#34;;
+  std::for_each(v.begin(), v.end(), [](int x) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;,&amp;#34;;
+  });
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+bool is_even(int x) { return x % 2 == 0; }
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 偶数グループと奇数グループに分ける
+  std::vector&amp;lt;int&amp;gt; evens;
+  std::vector&amp;lt;int&amp;gt; odds;
+  std::partition_copy(v.begin(), v.end(),
+                      std::back_inserter(evens),
+                      std::back_inserter(odds),
+                      is_even);
+
+  print(&amp;#34;v&amp;#34;, v);
+  print(&amp;#34;evens&amp;#34;, evens);
+  print(&amp;#34;odds&amp;#34;, odds);
+}
+```
+* std::partition_copy[color ff0000]
+
+### 出力
+```
+v : 1,2,3,4,5,
+evens : 2,4,
+odds : 1,3,5,
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_sort -- ソート系関数の残りの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_sort.html"/>
      <id>93d43ae764c0123c6b7c46d86c77d709314000e4:reference/algorithm/ranges_stable_sort.md</id>
      <updated>2022-03-20T07:54:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_sort.md b/reference/algorithm/ranges_stable_sort.md
new file mode 100644
index 000000000..b65a6a10c
--- /dev/null
+++ b/reference/algorithm/ranges_stable_sort.md
@@ -0,0 +1,86 @@
+# stable_sort
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});            // (1)
+
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt; stable_sort(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {}); // (2)
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+範囲を安定ソートで並べ替える
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+`[first,last)` の範囲をソートする
+
+
+## 戻り値
+`last`
+
+## 計算量
+最大で N log^2(N) （N == `last - first`）回の比較を行う。ただし、十分なメモリがあれば N log(N) になる。
+
+
+## 備考
+同じ値が複数あった場合に、ソート前の位置関係が保たれる、「安定ソート」を行う。
+一般的にマージソートで実装される。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 2, 5};
+
+  // 並べ替える
+  std::ranges::stable_sort(v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::stable_sort[color ff0000]
+
+### 出力
+```
+12345
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::sortの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>7874a832d37c9a712c92f4c8e0c22598eb380aa2:reference/algorithm.md</id>
      <updated>2022-03-20T07:22:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index c8c52e457..9f329068e 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -274,7 +274,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`partial_sort_copy`](algorithm/partial_sort_copy.md) | 範囲を部分的にソートした結果を他の範囲にコピーする | |
 | [`is_sorted`](algorithm/is_sorted.md)                 | ソート済みか判定する | C++11 |
 | [`is_sorted_until`](algorithm/is_sorted_until.md)     | ソート済みか判定し、ソートされていない位置のイテレータを取得する | C++11 |
-| [`ranges::sort`](algorithm/ranges_sort.md.nolink)                           | 範囲を並べ替える                                                 | C++20 |
+| [`ranges::sort`](algorithm/ranges_sort.md)                           | 範囲を並べ替える                                                 | C++20 |
 | [`ranges::stable_sort`](algorithm/ranges_stable_sort.md.nolink)             | 範囲を安定ソートで並べ替える                                     | C++20 |
 | [`ranges::partial_sort`](algorithm/ranges_partial_sort.md.nolink)           | 範囲を部分的にソートし、先頭N個を並んだ状態にする                | C++20 |
 | [`ranges::partial_sort_copy`](algorithm/ranges_partial_sort_copy.md.nolink) | 範囲を部分的にソートした結果を他の範囲にコピーする               | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- ranges::sortの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort.html"/>
      <id>7874a832d37c9a712c92f4c8e0c22598eb380aa2:reference/algorithm/ranges_sort.md</id>
      <updated>2022-03-20T07:22:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort.md b/reference/algorithm/ranges_sort.md
new file mode 100644
index 000000000..c18c8c166
--- /dev/null
+++ b/reference/algorithm/ranges_sort.md
@@ -0,0 +1,171 @@
+# sort
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr I sort(I first, S last, Comp comp = {}, Proj proj = {});            // (1)
+
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; sort(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {}); // (2)
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+範囲を並べ替える
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+`[first,last)` の範囲をソートする
+
+## 戻り値
+`last`
+
+## 計算量
+- O(N log N) (N == `last - first`) 回の比較
+
+## 備考
+- この関数には、特定のアルゴリズムで実装すべきという規定はない
+- 実装のアルゴリズムとしては、クイックソートの改良版であるイントロソートが使われることが多い
+
+## 例
+### 基本的な使い方
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 2, 5};
+
+  // 昇順に並べ替える
+  std::ranges::sort(v);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  // 降順に並べ替える
+  std::ranges::sort(v, std::ranges::greater());
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::sort[color ff0000]
+
+#### 出力
+```
+12345
+54321
+```
+
+### ユーザー定義型の配列を並べ替える
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+// 要素がひとつの場合
+struct MyInt {
+  int value;
+
+  friend auto operator&amp;lt;=&amp;gt;(const MyInt&amp;amp;, const MyInt&amp;amp;) = default;
+};
+
+// 要素が複数の場合
+struct Person {
+  int id;
+  int age;
+  std::string name;
+
+  friend auto operator&amp;lt;=&amp;gt;(const Person&amp;amp;, const Person&amp;amp;) = default;
+};
+
+int main() {
+  std::vector&amp;lt;MyInt&amp;gt; v1 {
+    MyInt{3},
+    MyInt{1},
+    MyInt{2},
+  };
+  std::ranges::sort(v1);
+
+  std::vector&amp;lt;Person&amp;gt; v2 {
+    Person{3, 30, &amp;#34;Carol&amp;#34;},
+    Person{1, 18, &amp;#34;Alice&amp;#34;},
+    Person{2, 32, &amp;#34;Bob&amp;#34;},
+  };
+  std::ranges::sort(v2);
+
+  std::vector&amp;lt;Person&amp;gt; v3 {
+    Person{3, 30, &amp;#34;Carol&amp;#34;},
+    Person{1, 18, &amp;#34;Alice&amp;#34;},
+    Person{2, 32, &amp;#34;Bob&amp;#34;},
+  };
+  // 特定のメンバでソート
+  std::ranges::sort(v2, {}, &amp;amp;Person::age);
+
+  for (const MyInt&amp;amp; x : v1) {
+    std::cout &amp;lt;&amp;lt; x.value &amp;lt;&amp;lt; std::endl;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  for (const Person&amp;amp; x : v2) {
+    std::cout &amp;lt;&amp;lt; x.name &amp;lt;&amp;lt; std::endl;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  for (const Person&amp;amp; x : v3) {
+    std::cout &amp;lt;&amp;lt; x.name &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::sort[color ff0000]
+
+#### 出力
+```
+1
+2
+3
+
+Alice
+Bob
+Carol
+
+Alice
+Carol
+Bob
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>