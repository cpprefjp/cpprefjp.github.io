<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-27T14:41:19.354651</updated>
  <id>fe668fbd-dc76-4524-993f-78964d9b380b</id>

  
    <entry>
      <title>is_iec559 -- numeric_limits::is_iec559 : C++23対応 #1022</title>
      <link href="https://cpprefjp.github.io/reference/limits/numeric_limits/is_iec559.html"/>
      <id>3607e5ab6eb5bf25b32929dc2426d78672ab5e9f:reference/limits/numeric_limits/is_iec559.md</id>
      <updated>2023-02-27T18:24:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/limits/numeric_limits/is_iec559.md b/reference/limits/numeric_limits/is_iec559.md
index 1c563ec06..b08d9d4cc 100644
--- a/reference/limits/numeric_limits/is_iec559.md
+++ b/reference/limits/numeric_limits/is_iec559.md
@@ -5,17 +5,18 @@
 * variable[meta id-type]
 
 ```cpp
-// C++03
-static const bool is_iec559;
-
-// C++11
-static constexpr bool is_iec559;
+static const bool is_iec559;     // (1) C++03
+static constexpr bool is_iec559; // (1) C++11
 ```
 
 ## 概要
 浮動小数点数型において、型`T`がIEC 559 (IEEE 754) に準拠しているかを判定する。
 
 
+## 備考
+- C++23 : [`float16_t`](/reference/stdfloat/float16_t.md)、[`float32_t`](/reference/stdfloat/float32_t.md)、[`float64_t`](/reference/stdfloat/float64_t.md)、[`float128_t`](/reference/stdfloat/float128_t.md)が存在する場合、この値は`true`となる
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float128_t -- numeric_limits::is_iec559 : C++23対応 #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/float128_t.html"/>
      <id>3607e5ab6eb5bf25b32929dc2426d78672ab5e9f:reference/stdfloat/float128_t.md</id>
      <updated>2023-02-27T18:24:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/float128_t.md b/reference/stdfloat/float128_t.md
index c0547e7de..a3802e2db 100644
--- a/reference/stdfloat/float128_t.md
+++ b/reference/stdfloat/float128_t.md
@@ -174,6 +174,7 @@ int main() {
 - [`std::float32_t`](float32_t.md)
 - [`std::float64_t`](float64_t.md)
 - [`std::bfloat16_t`](bfloat16_t.md)
+- [`std::numeric_limits&amp;lt;T&amp;gt;::is_iec559`](/reference/limits/numeric_limits/is_iec559.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float16_t -- numeric_limits::is_iec559 : C++23対応 #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/float16_t.html"/>
      <id>3607e5ab6eb5bf25b32929dc2426d78672ab5e9f:reference/stdfloat/float16_t.md</id>
      <updated>2023-02-27T18:24:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/float16_t.md b/reference/stdfloat/float16_t.md
index 1e6f2eb83..38896bf40 100644
--- a/reference/stdfloat/float16_t.md
+++ b/reference/stdfloat/float16_t.md
@@ -174,6 +174,7 @@ int main() {
 - [`std::float64_t`](float64_t.md)
 - [`std::float128_t`](float128_t.md)
 - [`std::bfloat16_t`](bfloat16_t.md)
+- [`std::numeric_limits&amp;lt;T&amp;gt;::is_iec559`](/reference/limits/numeric_limits/is_iec559.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float32_t -- numeric_limits::is_iec559 : C++23対応 #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/float32_t.html"/>
      <id>3607e5ab6eb5bf25b32929dc2426d78672ab5e9f:reference/stdfloat/float32_t.md</id>
      <updated>2023-02-27T18:24:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/float32_t.md b/reference/stdfloat/float32_t.md
index ff19acbd0..de37aa6a8 100644
--- a/reference/stdfloat/float32_t.md
+++ b/reference/stdfloat/float32_t.md
@@ -174,6 +174,7 @@ int main() {
 - [`std::float64_t`](float64_t.md)
 - [`std::float128_t`](float128_t.md)
 - [`std::bfloat16_t`](bfloat16_t.md)
+- [`std::numeric_limits&amp;lt;T&amp;gt;::is_iec559`](/reference/limits/numeric_limits/is_iec559.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float64_t -- numeric_limits::is_iec559 : C++23対応 #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/float64_t.html"/>
      <id>3607e5ab6eb5bf25b32929dc2426d78672ab5e9f:reference/stdfloat/float64_t.md</id>
      <updated>2023-02-27T18:24:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/float64_t.md b/reference/stdfloat/float64_t.md
index c477a8ace..e696fd9c8 100644
--- a/reference/stdfloat/float64_t.md
+++ b/reference/stdfloat/float64_t.md
@@ -174,6 +174,7 @@ int main() {
 - [`std::float32_t`](float32_t.md)
 - [`std::float128_t`](float128_t.md)
 - [`std::bfloat16_t`](bfloat16_t.md)
+- [`std::numeric_limits&amp;lt;T&amp;gt;::is_iec559`](/reference/limits/numeric_limits/is_iec559.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>variant -- Merge pull request #1129 from cpprefjp/sakujiro-inagaki-patch-1</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant.html"/>
      <id>1a85749125767560b89ee47d346006157bd320a0:reference/variant/variant.md</id>
      <updated>2023-02-25T19:25:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant.md b/reference/variant/variant.md
index fa7cd33db..fb0dae86a 100644
--- a/reference/variant/variant.md
+++ b/reference/variant/variant.md
@@ -43,7 +43,7 @@ std::visit([](auto&amp;amp; x) {
 
 このクラスと同様のことは共用体を使用しても達成できるが、このクラスはより使いやすいよう設計されている。
 
-このクラスは動的メモリ確保は行わず、スタック領域のみを使用する。
+このクラスは追加の動的メモリ確保は行わず、保持するオブジェクトを自身のオブジェクト表現内に直接割り当てる。
 
 
 ### 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>variant -- variantが追加の動的メモリ確保を行わないことを説明する文を修正</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant.html"/>
      <id>9116a9393d60707981347afccd127578fd47f374:reference/variant/variant.md</id>
      <updated>2023-02-25T12:56:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant.md b/reference/variant/variant.md
index fa7cd33db..fb0dae86a 100644
--- a/reference/variant/variant.md
+++ b/reference/variant/variant.md
@@ -43,7 +43,7 @@ std::visit([](auto&amp;amp; x) {
 
 このクラスと同様のことは共用体を使用しても達成できるが、このクラスはより使いやすいよう設計されている。
 
-このクラスは動的メモリ確保は行わず、スタック領域のみを使用する。
+このクラスは追加の動的メモリ確保は行わず、保持するオブジェクトを自身のオブジェクト表現内に直接割り当てる。
 
 
 ### 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>sakujiro-inagaki</name>
        <email>81898143+sakujiro-inagaki@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 未初期化領域への暗黙的なオブジェクト構築 : ご指摘反映 #1117</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>16e1d9768ef71370827c7cdb4a2a6c7d338d4914:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-24T18:03:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index 032c88222..5d41421f9 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -118,9 +118,9 @@ struct Vec {
     std::uninitialized_copy(begin(), end(), (T*)newbuf); // #a 💀 UB
 
     ::operator delete(buf, std::align_val_t(alignof(T)));
+    buf = newbuf;
     buf_end_size = newbuf + sizeof(T) * size(); // #b 💀 UB
     buf_end_capacity = newbuf + sizeof(T) * n;  // #c 💀 UB
-    buf = newbuf;
   }
 
   void push_back(T t) {
@@ -367,13 +367,17 @@ void process(Stream *stream) {
   std::unique_ptr&amp;lt;char[]&amp;gt; buffer = stream-&amp;gt;read();
 
   // 先頭バイトの状態によって適切なオブジェクトがStream::read()内で構築されている
+  // ただし、reinterpret_castの代わりにstd::launder()を使用する必要がある
   if (buffer[0] == FOO) {
-    process_foo(reinterpret_cast&amp;lt;Foo*&amp;gt;(buffer.get())); // ✅ ok
+    process_foo(std::launder&amp;lt;Foo&amp;gt;(buffer.get())); // ✅ ok
   } else {
-    process_bar(reinterpret_cast&amp;lt;Bar*&amp;gt;(buffer.get())); // ✅ ok
+    process_bar(std::launder&amp;lt;Bar&amp;gt;(buffer.get())); // ✅ ok
   }
 }
 ```
+* std::launder[link /reference/new/launder.md]
+
+追加で、各分岐においては返された`buffer`ポインタ（`char(*)[]`）から、それぞれの場合で適切なオブジェクト（`Foo`/`Bar`）へのポインタを[`std::launder()`](/reference/new/launder.md)によって取得する必要がある。`reinterpret_cast`はポインタの変換のみを行うため、この場合に
 
 ### 動的配列の実装
 
@@ -393,14 +397,14 @@ struct Vec {
 
     // newbufにはT[]のオブジェクトが生存期間内にあるため、ポインタT*をイテレータとして使用可能となる
     // ここで、T[]の要素のTのオブジェクトが構築される（明示的）
-    std::uninitialized_copy(begin(), end(), (T*)newbuf); // #a ✅ ok
+    std::uninitialized_copy(begin(), end(), std::launder&amp;lt;T&amp;gt;(newbuf)); // #a ✅ ok
 
     ::operator delete(buf, std::align_val_t(alignof(T)));
     
+    buf = newbuf;
     // newbufにはchar[]のオブジェクトが生存期間内にあるため、newbuf(char*)をイテレータとして使用可能となる
     buf_end_size = newbuf + sizeof(T) * size(); // #b ✅ ok
     buf_end_capacity = newbuf + sizeof(T) * n;  // #c ✅ ok
-    buf = newbuf;
   }
 
   void push_back(T t) {
@@ -412,9 +416,9 @@ struct Vec {
     buf_end_size += sizeof(T); // #d ✅ ok
   }
 
-  T *begin() { return (T*)buf; }
+  T *begin() { return std::launder&amp;lt;T&amp;gt;(buf); }
 
-  T *end() { return (T*)buf_end_size; }
+  T *end() { return std::launder&amp;lt;T&amp;gt;(buf_end_size); }
 
   // buf及びbuf_end_sizeの指す領域にはT[]のオブジェクトが生存期間内にあるため、ポインタをイテレータとして使用可能
   std::size_t size() { return end() - begin(); } // #e ✅ ok
@@ -433,6 +437,8 @@ int main() {
 
 この例では、`reserve()`内`newbuf`及びそれを保存している`Vec::buf`の領域に`T[]`（`T`の配列型）と`char[]`のオブジェクトが暗黙的に構築され、同時に生存期間内にあることで、問題（配列オブジェクトを指さないポインタのイテレータとしての使用）が解消され、すべての箇所で定義された振る舞いをもたらしている。
 
+ここでも同様に、`newbuf`及び`Vec::buf`から都度適切なオブジェクトへのポインタを得るのに[`std::launder()`](/reference/new/launder.md)を使用する必要がある。
+
 ## この機能が必要になった背景・経緯
 (執筆中)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>barrier -- barrier: P2588R3対応</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier.html"/>
      <id>54c77480d6285273fddf16893c874817017ce004:reference/barrier/barrier.md</id>
      <updated>2023-02-24T13:43:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier.md b/reference/barrier/barrier.md
index 30647f3fc..61d1f3577 100644
--- a/reference/barrier/barrier.md
+++ b/reference/barrier/barrier.md
@@ -31,9 +31,9 @@ namespace std {
 
 各バリアフェーズ(barrier phase)は下記のステップで構成される：
 
-- [`arrive()`](barrier/arrive.md)または[`arrive_and_drop`](barrier/arrive_and_drop.md)呼び出しによって、予定カウントを減算する。
-- 予定カウントが`0`に到達したら、完了ステップを実行する。テンプレートパラメータ`CompletionFunction`のデフォルト値に対する特殊化では、完了ステップは予定カウントを`0`とした[`arrive()`](barrier/arrive.md)または[`arrive_and_drop`](barrier/arrive_and_drop.md)呼び出しの一部として実行される。それ以外の特殊化では、完了ステップはそのフェーズ内でバリア到達したスレッドのいずれか1つの上で実行される。
-- 完了ステップが終了したのち、予定カウントをコンストラクタ実引数`expected`でリセットし、[`arrive_and_drop`](barrier/arrive_and_drop.md)呼び出しの場合は調整を行って、次のフェーズを開始する。
+- [`arrive()`](barrier/arrive.md)または[`arrive_and_drop()`](barrier/arrive_and_drop.md)呼び出しによって、予定カウントを減算する。
+- 予定カウントが`0`に到達した後、[`arrive()`](barrier/arrive.md)／[`arrive_and_drop()`](barrier/arrive_and_drop.md)／[`wait()`](barrier/wait.md)いずれかの呼び出しの間に、いずれかのスレッドにより正確に1回だけ完了ステップが実行される。だだし[`wait()`](barrier/wait.md)呼び出しを行うスレッドがない場合に、完了ステップが実行されるか否かは処理系定義とされる。
+- 完了ステップが終了したのち、予定カウントをコンストラクタ実引数`expected`でリセットし、[`arrive_and_drop()`](barrier/arrive_and_drop.md)呼び出しの場合は調整を行って、次のフェーズを開始する。
 
 各フェーズは、フェーズ同期ポイント(phase synchronization point)を定義する。
 フェーズ内でバリアに到達したスレッドは、[`wait()`](barrier/wait.md)呼び出しによりフェーズ同期ポイント上でブロックされ、フェーズ完了ステップが実行されるまでブロック状態は継続する。
@@ -160,10 +160,14 @@ Main     3
 
 
 ## 関連項目
-- [`&amp;lt;latch&amp;gt;`](/reference/latch.md)
+- [`latch`](/reference/latch/latch.md)
 
 
 ## 参照
+- [P0666R2 Revised Latches and Barriers for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0666r2.pdf)
+- [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P2588R3 `barrier`&amp;#39;s phase completion guarantees](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2588r3.html)
+    - バリアフェーズ動作仕様の完了ステップを呼び出すスレッド要件が緩和された。
 - [Boost.Threadライブラリ, Barriers](https://www.boost.org/doc/libs/1_73_0/doc/html/thread/synchronization.html#thread.synchronization.barriers)
 - [Java標準ライブラリ, java.util.concurrent.CyclicBarrier](https://docs.oracle.com/javase/jp/6/api/java/util/concurrent/CyclicBarrier.html)
 - [C#標準ライブラリ, System.Threading.Barrier](https://docs.microsoft.com/en-us/dotnet/api/system.threading.barrier)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>