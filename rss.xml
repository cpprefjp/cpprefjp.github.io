<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-02-12T14:38:29.615759</updated>
  <id>881a0597-3e6d-4340-9827-bfa13b798ae1</id>

  
    <entry>
      <title>has_unique_object_representations -- has_unique_object_representations: 浮動小数点数の説明を増補</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/has_unique_object_representations.html"/>
      <id>d5055610e0384774da91acbf8fe477d9d261639e:reference/type_traits/has_unique_object_representations.md</id>
      <updated>2021-02-12T13:37:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/has_unique_object_representations.md b/reference/type_traits/has_unique_object_representations.md
index 15d50be02..af63374bf 100644
--- a/reference/type_traits/has_unique_object_representations.md
+++ b/reference/type_traits/has_unique_object_representations.md
@@ -29,7 +29,7 @@ namespace std {
 
 以下、もう少し詳細な解説。
 
-まず、型`T`のオブジェクト表現とは、`T`を`unsigned char[N]`で参照したときのバイト配列のことである（`N == sizeof(T)`）。  
+まず、型`T`のオブジェクト表現とは、`T`のオブジェクトを型`unsigned char[N]`で参照したときのバイト列のことである（`N == sizeof(T)`）。
 次に、型`T`の値表現とは、`T`の値を保持するビット列のことである。  
 そして、`T`が[*TriviallyCopyable*](is_trivially_copyable.md)であれば、値表現はオブジェクト表現内に含まれる。
 
@@ -38,9 +38,9 @@ namespace std {
 
 [スカラー型](is_scalar.md)がこの性質を満たすかは処理系定義となるが、符号なし整数型は一意なオブジェクト表現を持つ。  
 またC++20以降、符号付整数型は2の補数表現であると規定されるため、C++20以降は（現在でも多くの処理系がそうであるが）符号付も含めた整数型がこの性質を満たすようになる。  
-また、多くの処理系では浮動小数点型はこの性質を満たさない。
+また、多くの処理系において IEC 559 (IEEE 754) に準拠する浮動小数点型がこの性質を満たさない。
 
-ビットフィールドも処理系によってバイト表現が異なるため処理系定義となる（主に、Itenium ABIとMSVC ABI間で異なる）。
+ビットフィールドも処理系によってバイト表現が異なるため処理系定義となる（主に、Itanium ABIとMSVC ABI間で異なる）。
 
 `T`型の二つのオブジェクトが同じ値を持つとは、以下の場合である：
 
@@ -82,6 +82,9 @@ int main()
 
   std::cout &amp;lt;&amp;lt; std::has_unique_object_representations&amp;lt;int&amp;gt;::value &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; std::has_unique_object_representations&amp;lt;unsigned int&amp;gt;::value &amp;lt;&amp;lt; std::endl;
+
+  // IEC 559(IEEE 754)準拠の浮動小数点型では、異なるバイト列であっても等価となるケースが存在する。
+  // 正のゼロ(+0.0)と負のゼロ(-0.0)は等価と評価されるが、それぞれの値を表すバイト列は異なっている。
   std::cout &amp;lt;&amp;lt; std::has_unique_object_representations&amp;lt;float&amp;gt;::value &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; std::has_unique_object_representations&amp;lt;double&amp;gt;::value &amp;lt;&amp;lt; std::endl;
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>has_unique_object_representations -- has_unique_object_representations: 例示を&#34;出力例&#34;に変更</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/has_unique_object_representations.html"/>
      <id>3baf8f05ad899e1529f50fbedf1c2e04daa8fe2a:reference/type_traits/has_unique_object_representations.md</id>
      <updated>2021-02-12T11:41:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/has_unique_object_representations.md b/reference/type_traits/has_unique_object_representations.md
index 75a0212ad..15d50be02 100644
--- a/reference/type_traits/has_unique_object_representations.md
+++ b/reference/type_traits/has_unique_object_representations.md
@@ -69,9 +69,11 @@ struct unique_object_representations {
 };
 
 struct not_unique_object_representations {
-  char a;/*
-  ここにパディングが3バイトある
-  */int b;
+  char a;
+  // 後続メンバbが配置されるメモリアドレスをint型にとって自然なアライメントとするため、
+  // 多くの処理系ではここにパディングを挿入する。例：sizeof(int)==4環境では3バイト。
+  // pragmaやコンパイルオプションなど処理系独自の手段でパディング量は調整できることが多い。
+  int b;
 };
 
 int main()
@@ -89,7 +91,7 @@ int main()
 ```
 * std::has_unique_object_representations[color ff0000]
 
-### 出力
+### 出力例
 ```
 true
 true
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_nothrow_convertible -- is_nothrow_convertible: 要件の表記調整, 例示ハイライト修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_nothrow_convertible.html"/>
      <id>9f254b9ba28faa9f96a7ec50cb3aa3152ea4b905:reference/type_traits/is_nothrow_convertible.md</id>
      <updated>2021-02-12T11:16:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_nothrow_convertible.md b/reference/type_traits/is_nothrow_convertible.md
index 4f14840ba..dfd05b4ca 100644
--- a/reference/type_traits/is_nothrow_convertible.md
+++ b/reference/type_traits/is_nothrow_convertible.md
@@ -20,7 +20,7 @@ namespace std {
 
 
 ## 要件
-型`T`は完全型であるか、`const`/`volatile`修飾された(あるいはされていない)`void`か、要素数不明の配列型でなければならない。
+型`From`と型`To`は完全型であるか、`const`/`volatile`修飾された(あるいはされていない)`void`か、要素数不明の配列型でなければならない。
 
 
 ## 効果
@@ -68,7 +68,7 @@ static_assert(std::is_nothrow_convertible_v&amp;lt;int, D&amp;gt; == false);
 
 int main() {}
 ```
-* std::is_nothrow_convertible[color ff0000]
+* std::is_nothrow_convertible_v[color ff0000]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_member_pointer -- is_member_pointer: 例示コードを修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_member_pointer.html"/>
      <id>725e24133c61ba90fd461f88f3731d52b9eab1f8:reference/type_traits/is_member_pointer.md</id>
      <updated>2021-02-12T11:08:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_member_pointer.md b/reference/type_traits/is_member_pointer.md
index 156db988e..f35aafe83 100644
--- a/reference/type_traits/is_member_pointer.md
+++ b/reference/type_traits/is_member_pointer.md
@@ -35,27 +35,27 @@ struct s
   static void static_member_function(){} // decltype(&amp;amp;s::static_member_function) は void (*)()
 };
 
-static_assert(std::is_member_object_pointer&amp;lt;int s::*&amp;gt;::value == true, &amp;#34;value == true, int s::* is member pointer&amp;#34;);
-static_assert(std::is_same&amp;lt;std::is_member_object_pointer&amp;lt;int s::*&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_type == bool&amp;#34;);
-static_assert(std::is_same&amp;lt;std::is_member_object_pointer&amp;lt;int s::*&amp;gt;::type, std::true_type&amp;gt;::value, &amp;#34;type == true_type&amp;#34;);
-static_assert(std::is_member_object_pointer&amp;lt;int s::*&amp;gt;() == true, &amp;#34;is_member_object_pointer&amp;lt;int s::*&amp;gt;() == true&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int s::*&amp;gt;::value == true, &amp;#34;value == true, int s::* is member pointer&amp;#34;);
+static_assert(std::is_same&amp;lt;std::is_member_pointer&amp;lt;int s::*&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_type == bool&amp;#34;);
+static_assert(std::is_same&amp;lt;std::is_member_pointer&amp;lt;int s::*&amp;gt;::type, std::true_type&amp;gt;::value, &amp;#34;type == true_type&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int s::*&amp;gt;() == true, &amp;#34;is_member_pointer&amp;lt;int s::*&amp;gt;() == true&amp;#34;);
 
-static_assert(std::is_member_object_pointer&amp;lt;int&amp;gt;::value == false, &amp;#34;value == false, int is not member pointer&amp;#34;);
-static_assert(std::is_same&amp;lt;std::is_member_object_pointer&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_type == bool&amp;#34;);
-static_assert(std::is_same&amp;lt;std::is_member_object_pointer&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
-static_assert(std::is_member_object_pointer&amp;lt;int&amp;gt;() == false, &amp;#34;is_member_object_pointer&amp;lt;int&amp;gt;() == false&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int&amp;gt;::value == false, &amp;#34;value == false, int is not member pointer&amp;#34;);
+static_assert(std::is_same&amp;lt;std::is_member_pointer&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_type == bool&amp;#34;);
+static_assert(std::is_same&amp;lt;std::is_member_pointer&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int&amp;gt;() == false, &amp;#34;is_member_pointer&amp;lt;int&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_member_object_pointer&amp;lt;int s::* const&amp;gt;::value == true, &amp;#34;int s::* const is member pointer&amp;#34;);
-static_assert(std::is_member_object_pointer&amp;lt;const int s::*&amp;gt;::value == true, &amp;#34;const int s::* is member pointer&amp;#34;);
-static_assert(std::is_member_object_pointer&amp;lt;int* s::*&amp;gt;::value == true, &amp;#34;int* s::* is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int s::* const&amp;gt;::value == true, &amp;#34;int s::* const is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;const int s::*&amp;gt;::value == true, &amp;#34;const int s::* is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int* s::*&amp;gt;::value == true, &amp;#34;int* s::* is member pointer&amp;#34;);
 
-static_assert(std::is_member_function_pointer&amp;lt;void (s::* const)()&amp;gt;::value == true, &amp;#34;void (s::* const)() is member pointer&amp;#34;);
-static_assert(std::is_member_function_pointer&amp;lt;void (s::*)() const&amp;gt;::value == true, &amp;#34;void (s::*)() const is member pointer&amp;#34;);
-static_assert(std::is_member_function_pointer&amp;lt;const int* (s::*)()&amp;gt;::value == true, &amp;#34;const int* (s::*)() is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;void (s::* const)()&amp;gt;::value == true, &amp;#34;void (s::* const)() is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;void (s::*)() const&amp;gt;::value == true, &amp;#34;void (s::*)() const is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;const int* (s::*)()&amp;gt;::value == true, &amp;#34;const int* (s::*)() is member pointer&amp;#34;);
 
 int main(){}
 ```
-* std::is_member_object_pointer[color ff0000]
+* std::is_member_pointer[color ff0000]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>要素数不明の配列への変換を許可 -- 要素数不明の配列への変換を許可 : 例の間違いを修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.html"/>
      <id>f1fbc50a6f8940c23e744d0a0dc784b0f82c212e:lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md</id>
      <updated>2021-02-10T14:14:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md b/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
index 584cf486d..b540cc2b1 100644
--- a/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
+++ b/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
@@ -49,7 +49,7 @@ int main()
 void f(int(&amp;amp;&amp;amp;)[]){ std::cout &amp;lt;&amp;lt; &amp;#34;unknown bound\n&amp;#34;; }
 void f(int(&amp;amp;&amp;amp;)[0]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 0\n&amp;#34;; }
 void f(int(&amp;amp;&amp;amp;)[2]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 2\n&amp;#34;; }
-void f(int(&amp;amp;&amp;amp;)[4]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 3\n&amp;#34;; }
+void f(int(&amp;amp;&amp;amp;)[4]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 4\n&amp;#34;; }
 
 void g(int(&amp;amp;&amp;amp;)[]){ std::cout &amp;lt;&amp;lt; &amp;#34;unknown bound\n&amp;#34;; }
 void g(double(&amp;amp;&amp;amp;)[0]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 0\n&amp;#34;; }
@@ -69,6 +69,7 @@ int main()
   g({0});
   g({0, 0});
   g({0, 0, 0});
+  g({0.0, 0.0});
 }
 ```
 
@@ -79,7 +80,7 @@ bound 0
 unknown bound
 bound 2
 unknown bound
-bound 3
+bound 4
 unknown bound
 g:
 unknown bound
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>lpha</name>
        <email>sphenocorona@gmail.com</email>
      </author>
    </entry>
  
</feed>