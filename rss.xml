<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-12-18T07:44:26.447126</updated>
  <id>efe7e658-74ec-486c-9ea8-b4ad56360616</id>

  
    <entry>
      <title>gcd -- added a sample implementation for gcd and lcm function</title>
      <link href="https://cpprefjp.github.io/reference/numeric/gcd.html"/>
      <id>5b5cd374f837f54793bc5f633d6926211370a230:reference/numeric/gcd.md</id>
      <updated>2024-12-18T16:39:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/gcd.md b/reference/numeric/gcd.md
index 1e2049b6d..5bf7c51aa 100644
--- a/reference/numeric/gcd.md
+++ b/reference/numeric/gcd.md
@@ -129,6 +129,7 @@ int main() {
 ```
 ```
 
+
 ## バージョン
 ### 言語
 - C++17
@@ -167,3 +168,22 @@ $$ \mathrm{gcd}(m, n) = \begin{cases}
   |m| &amp;amp; \text{if } n = 0 \\
   \mathrm{gcd}(n, m \bmod n) &amp;amp; \text{otherwise}
 \end{cases} $$
+
+
+```cpp
+template &amp;lt;class M, class N&amp;gt;
+constexpr std::common_type_t&amp;lt;M, N&amp;gt; gcd(M m, N n) {
+  if (m == 0 &amp;amp;&amp;amp; n == 0) {
+    return 0;
+  }
+  while (m != 0 &amp;amp;&amp;amp; n != 0) {
+    if (m &amp;gt; n) {
+      m %= n;
+    }
+    else {
+      n %= m;
+    }
+  }
+  return m &amp;lt; n ? n : m;
+}
+```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>rotarymars</name>
        <email>s.goto2050@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lcm -- added a sample implementation for gcd and lcm function</title>
      <link href="https://cpprefjp.github.io/reference/numeric/lcm.html"/>
      <id>5b5cd374f837f54793bc5f633d6926211370a230:reference/numeric/lcm.md</id>
      <updated>2024-12-18T16:39:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/lcm.md b/reference/numeric/lcm.md
index fb9a9f5c1..cdea96876 100644
--- a/reference/numeric/lcm.md
+++ b/reference/numeric/lcm.md
@@ -171,3 +171,26 @@ int main() {
 
 ## 実装例
 $$ \mathrm{lcm}(m, n) = \frac{|mn|}{\mathrm{gcd}(m, n)} $$
+
+```cpp
+template &amp;lt;class M, class N&amp;gt;
+constexpr std::common_type_t&amp;lt;M, N&amp;gt; gcd(M m, N n) {
+  if (m == 0 &amp;amp;&amp;amp; n == 0) {
+    return 0;
+  }
+  while (m != 0 &amp;amp;&amp;amp; n != 0) {
+    if (m &amp;gt; n) {
+      m %= n;
+    }
+    else {
+      n %= m;
+    }
+  }
+  return m &amp;lt; n ? n : m;
+}
+
+template &amp;lt;class M, class N&amp;gt;
+constexpr std::common_type_t&amp;lt;M, N&amp;gt; lcm(M m, N n) {
+  return m / gcd(m, n) * n;
+}
+```
\ No newline at end of file
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>rotarymars</name>
        <email>s.goto2050@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_istringstream -- Merge pull request #1370 from rotarymars/master</title>
      <link href="https://cpprefjp.github.io/reference/sstream/basic_istringstream.html"/>
      <id>f702e61c13ad056112757ce7c82e6a7e4614e189:reference/sstream/basic_istringstream.md</id>
      <updated>2024-12-18T14:16:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/sstream/basic_istringstream.md b/reference/sstream/basic_istringstream.md
index 82c8acc69..4b8565091 100644
--- a/reference/sstream/basic_istringstream.md
+++ b/reference/sstream/basic_istringstream.md
@@ -53,11 +53,24 @@ namespace std {
 | `allocator_type` | テンプレート仮引数`Allocator` | |
 
 ## 例
-```cpp
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;sstream&amp;gt;
+int main() {
+  std::string text = &amp;#34;ABCDEFG&amp;#34;;
+  std::istringstream stream(text);
+  char c;
+  while (stream &amp;gt;&amp;gt; c) {
+    std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;&amp;#39; &amp;#39;;
+  }
+  std::cout&amp;lt;&amp;lt;std::endl;
+}
 ```
-
+* std::istringstream[color ff0000]
 ### 出力
 ```
+A B C D E F G 
+
 ```
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_istringstream -- new sample code for istringstream</title>
      <link href="https://cpprefjp.github.io/reference/sstream/basic_istringstream.html"/>
      <id>dbd4b9d90511bfe6df1bf0cdda1798338fc044d1:reference/sstream/basic_istringstream.md</id>
      <updated>2024-12-18T13:33:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/sstream/basic_istringstream.md b/reference/sstream/basic_istringstream.md
index 82c8acc69..4b8565091 100644
--- a/reference/sstream/basic_istringstream.md
+++ b/reference/sstream/basic_istringstream.md
@@ -53,11 +53,24 @@ namespace std {
 | `allocator_type` | テンプレート仮引数`Allocator` | |
 
 ## 例
-```cpp
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;sstream&amp;gt;
+int main() {
+  std::string text = &amp;#34;ABCDEFG&amp;#34;;
+  std::istringstream stream(text);
+  char c;
+  while (stream &amp;gt;&amp;gt; c) {
+    std::cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;&amp;#39; &amp;#39;;
+  }
+  std::cout&amp;lt;&amp;lt;std::endl;
+}
 ```
-
+* std::istringstream[color ff0000]
 ### 出力
 ```
+A B C D E F G 
+
 ```
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>rotarymars</name>
        <email>s.goto2050@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gps_clock -- Merge pull request #1369 from cpprefjp/refine-tai-gps-clock</title>
      <link href="https://cpprefjp.github.io/reference/chrono/gps_clock.html"/>
      <id>b8d44bcf4e1b1bbb6f9aff5e3c6093f8e704d91b:reference/chrono/gps_clock.md</id>
      <updated>2024-12-17T23:16:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/gps_clock.md b/reference/chrono/gps_clock.md
index 3cdab5a04..5a1dac30e 100644
--- a/reference/chrono/gps_clock.md
+++ b/reference/chrono/gps_clock.md
@@ -13,19 +13,23 @@ namespace std::chrono {
 ## 概要
 `gps_clock`は、GPS時間 (GPST) を表現するためのクロックである。この時刻系は、カーナビや携帯端末などで使用される。
 
+GPS時間ではうるう秒 (leap second) 補正が行われないため、2017年1月1日以降～2024年現在ではUTC (世界協定時) よりも18秒進んだ時間をとる。
+つまり 2024-01-01 00:00:18 GPS と 2024-01-01 00:00:00 UTC は等価である。
+
 このクラスの[`now()`](gps_clock/now.md)静的メンバ関数は、標準では`noexcept(false)`である。実装が`noexcept(true)`である保証をしない限り、このクラスはTrivialClock要件を満たさない。
 
 
 ### エポック
 クロックごとの初期時間 (内部的にカウンタがあれば値ゼロ) をエポックと呼ぶ。
 
-`gps_clock`のエポックは、1980年1月6日 (この年の最初の日曜日) 0時0分0秒である。
+`gps_clock`のエポックは、1980年1月6日 (同年の最初の日曜日) 0時0分0秒である。
 
 
 ### うるう秒の扱い
-このクロックではうるう秒は挿入されず、うるう秒の数だけ時間が進む。そのため、UTCにうるう秒が挿入されるたびに、UTCはGPSよりも1秒ずつずれていく。
+`gps_clock`ではうるう秒は考慮されず、UTCに対してうるう秒分だけ時間がシフトする。そのため、UTCに正のうるう秒が挿入されるたびに、UTC時間はGPS時間よりも1秒ずつ遅れていく。
 
-GPS時間とTAI時間は19秒ずれていて、このずれは時間が経過しても変わらない。GPS時間のエポックが[`1958y`](year/op_y.md)`/`[`January`](month_constants.md)`/1`、TAI時間のエポックが[`1980y`](year/op_y.md)`/`[`January`](month_constants.md)`/`[`Sunday`](weekday_constants.md)`[1]`であるが、1958年から1970年までのオフセットが10秒と、1970年から1980年までに挿入されたうるう秒が9秒あるためだ。
+同じくうるう秒を考慮しない[TAI時間](tai_clock.md)に対してGPS時間は19秒遅れており、このずれは時間が経過しても変わらない。これはTAI時間のエポックが[`1958y`](year/op_y.md)`/`[`January`](month_constants.md)`/1`、GPS時間のエポックが[`1980y`](year/op_y.md)`/`[`January`](month_constants.md)`/`[`Sunday`](weekday_constants.md)`[1]`であるが、1958年から1970年までのオフセットが10秒と、1970年から1980年までに挿入されたうるう秒が9秒あるためだ。
+(1970年はTAI時間が定められた年である。)
 
 
 ## メンバ関数
@@ -56,6 +60,7 @@ GPS時間とTAI時間は19秒ずれていて、このずれは時間が経過し
 
 
 ## 例
+### 例1: 現在GPS時間
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;chrono&amp;gt;
@@ -68,20 +73,47 @@ int main()
   std::cout &amp;lt;&amp;lt; tp &amp;lt;&amp;lt; std::endl;
 }
 ```
+* chrono::gps_clock[color ff0000]
 * now()[link gps_clock/now.md]
 
-### 出力例
+#### 出力例
 ```
 2019-10-24 11:15:37.493236171
 ```
 
+### 例2: うるう秒の影響
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+
+namespace chrono = std::chrono;
+using namespace std::literals::chrono_literals;
+
+int main() {
+  auto utc_tp = chrono::utc_clock::from_sys(chrono::sys_days{2024y/1/1});
+  auto gps_tp = chrono::gps_clock::from_utc(utc_tp);
+  std::cout &amp;lt;&amp;lt; utc_tp &amp;lt;&amp;lt; &amp;#34; UTC&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; gps_tp &amp;lt;&amp;lt; &amp;#34; GPS&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* chrono::gps_clock[color ff0000]
+* from_sys[link utc_clock/from_sys.md]
+* from_utc[link gps_clock/from_utc.md]
+
+#### 出力
+```
+2024-01-01 00:00:00 UTC
+2024-01-01 00:00:18 GPS
+```
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): 9.0 [mark noimpl]
-- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.1 [mark verified]
+- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.2 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 3 [mark noimpl]
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tai_clock -- Merge pull request #1369 from cpprefjp/refine-tai-gps-clock</title>
      <link href="https://cpprefjp.github.io/reference/chrono/tai_clock.html"/>
      <id>b8d44bcf4e1b1bbb6f9aff5e3c6093f8e704d91b:reference/chrono/tai_clock.md</id>
      <updated>2024-12-17T23:16:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/tai_clock.md b/reference/chrono/tai_clock.md
index 5d281f66e..30d8cfa41 100644
--- a/reference/chrono/tai_clock.md
+++ b/reference/chrono/tai_clock.md
@@ -13,7 +13,8 @@ namespace std::chrono {
 ## 概要
 `tai_clock`は、TAI時間 (国際原子時、International Atomic Time) を表現するためのクロックである。
 
-このクロックは、UTCよりも10秒進んでいる。そのため、1958-01-01 00:00:00 TAIと1957-12-31 23:59:50 UTCは等価である。
+TAIではうるう秒 (leap second) 補正が行われないため、2017年1月1日以降～2024年現在ではUTC (世界協定時) よりも37秒進んだ時間をとる。
+つまり 2024-01-01 00:00:37 TAI と 2024-01-01 00:00:00 UTC は等価である。
 
 
 このクラスの[`now()`](tai_clock/now.md)静的メンバ関数は、標準では`noexcept(false)`である。実装が`noexcept(true)`である保証をしない限り、このクラスはTrivialClock要件を満たさない。
@@ -23,12 +24,13 @@ namespace std::chrono {
 クロックごとの初期時間 (内部的にカウンタがあれば値ゼロ) をエポックと呼ぶ。
 
 `tai_clock`のエポックは、1958年1月1日0時0分0秒である。
+これはUTC時間1957年12月31日23時59分50秒に対応する。
 
 
 ### うるう秒の扱い
-このクロックではうるう秒は挿入されず、うるう秒の数だけ時間が進む。そのため、UTCにうるう秒が挿入されるたびに、UTCはTAIよりも1秒ずつずれていく。
+`tai_clock`ではうるう秒は考慮されず、UTCに対してうるう秒数分だけ時間がシフトする。そのため、UTCに正のうるう秒が挿入されるたびに、UTC時間はTAI時間よりも1秒ずつ遅れていく。
 
-例として、2000年01月01日までに正のうるう秒が22回、負のうるう秒が0回挿入されたため、TAIがUTCより10秒進んでいることも含めて、2000-01-01 00:00:00 UTCと2000-01-01 00:00:32 TAIは等価となる。
+例として、`tai_clock`エポック日 (1958年1月1日) 時点ではUTCには正のうるう秒が10回挿入されており、さらに2000年01月01日までに正のうるう秒が22回、負のうるう秒が0回挿入されたため、2000-01-01 00:00:00 UTCと2000-01-01 00:00:32 TAIは等価となる。
 
 
 ## メンバ関数
@@ -59,6 +61,7 @@ namespace std::chrono {
 
 
 ## 例
+### 例1: 現在TAI時間
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;chrono&amp;gt;
@@ -71,23 +74,51 @@ int main()
   std::cout &amp;lt;&amp;lt; tp &amp;lt;&amp;lt; std::endl;
 }
 ```
+* chrono::tai_clock[color ff0000]
 * now()[link tai_clock/now.md]
 
-### 出力例
+#### 出力例
 ```
-2019-10-24 11:15:47 TAI
+2019-10-24 11:15:47.519957239
 ```
 
+### 例2: うるう秒の影響
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+
+namespace chrono = std::chrono;
+using namespace std::literals::chrono_literals;
+
+int main() {
+  auto utc_tp = chrono::utc_clock::from_sys(chrono::sys_days{2024y/1/1});
+  auto tai_tp = chrono::tai_clock::from_utc(utc_tp);
+  std::cout &amp;lt;&amp;lt; utc_tp &amp;lt;&amp;lt; &amp;#34; UTC&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; tai_tp &amp;lt;&amp;lt; &amp;#34; TAI&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* chrono::tai_clock[color ff0000]
+* from_sys[link utc_clock/from_sys.md]
+* from_utc[link tai_clock/from_utc.md]
+
+#### 出力
+```
+2024-01-01 00:00:00 UTC
+2024-01-01 00:00:37 TAI
+```
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): 9.0 [mark noimpl]
-- [GCC](/implementation.md#gcc): 9.2 [mark noimpl]
+- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.2 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 3 [mark noimpl]
 
 
 ## 参照
 - [国際原子時 - Wikipedia](https://ja.wikipedia.org/wiki/国際原子時)
+- [国立天文台 水沢, うるう秒について](https://www.miz.nao.ac.jp/vlbi/leapsec.html)
 - [LWG Issue 3359. `&amp;lt;chrono&amp;gt;` leap second support should allow for negative leap seconds](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2117r0.html#3359)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gps_clock -- chrono/{tai,gps}_clock: クラス説明を増補</title>
      <link href="https://cpprefjp.github.io/reference/chrono/gps_clock.html"/>
      <id>86f0c41afc9742a6aca155df7cdcce3f5ddb08ff:reference/chrono/gps_clock.md</id>
      <updated>2024-12-16T17:44:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/gps_clock.md b/reference/chrono/gps_clock.md
index 3cdab5a04..5a1dac30e 100644
--- a/reference/chrono/gps_clock.md
+++ b/reference/chrono/gps_clock.md
@@ -13,19 +13,23 @@ namespace std::chrono {
 ## 概要
 `gps_clock`は、GPS時間 (GPST) を表現するためのクロックである。この時刻系は、カーナビや携帯端末などで使用される。
 
+GPS時間ではうるう秒 (leap second) 補正が行われないため、2017年1月1日以降～2024年現在ではUTC (世界協定時) よりも18秒進んだ時間をとる。
+つまり 2024-01-01 00:00:18 GPS と 2024-01-01 00:00:00 UTC は等価である。
+
 このクラスの[`now()`](gps_clock/now.md)静的メンバ関数は、標準では`noexcept(false)`である。実装が`noexcept(true)`である保証をしない限り、このクラスはTrivialClock要件を満たさない。
 
 
 ### エポック
 クロックごとの初期時間 (内部的にカウンタがあれば値ゼロ) をエポックと呼ぶ。
 
-`gps_clock`のエポックは、1980年1月6日 (この年の最初の日曜日) 0時0分0秒である。
+`gps_clock`のエポックは、1980年1月6日 (同年の最初の日曜日) 0時0分0秒である。
 
 
 ### うるう秒の扱い
-このクロックではうるう秒は挿入されず、うるう秒の数だけ時間が進む。そのため、UTCにうるう秒が挿入されるたびに、UTCはGPSよりも1秒ずつずれていく。
+`gps_clock`ではうるう秒は考慮されず、UTCに対してうるう秒分だけ時間がシフトする。そのため、UTCに正のうるう秒が挿入されるたびに、UTC時間はGPS時間よりも1秒ずつ遅れていく。
 
-GPS時間とTAI時間は19秒ずれていて、このずれは時間が経過しても変わらない。GPS時間のエポックが[`1958y`](year/op_y.md)`/`[`January`](month_constants.md)`/1`、TAI時間のエポックが[`1980y`](year/op_y.md)`/`[`January`](month_constants.md)`/`[`Sunday`](weekday_constants.md)`[1]`であるが、1958年から1970年までのオフセットが10秒と、1970年から1980年までに挿入されたうるう秒が9秒あるためだ。
+同じくうるう秒を考慮しない[TAI時間](tai_clock.md)に対してGPS時間は19秒遅れており、このずれは時間が経過しても変わらない。これはTAI時間のエポックが[`1958y`](year/op_y.md)`/`[`January`](month_constants.md)`/1`、GPS時間のエポックが[`1980y`](year/op_y.md)`/`[`January`](month_constants.md)`/`[`Sunday`](weekday_constants.md)`[1]`であるが、1958年から1970年までのオフセットが10秒と、1970年から1980年までに挿入されたうるう秒が9秒あるためだ。
+(1970年はTAI時間が定められた年である。)
 
 
 ## メンバ関数
@@ -56,6 +60,7 @@ GPS時間とTAI時間は19秒ずれていて、このずれは時間が経過し
 
 
 ## 例
+### 例1: 現在GPS時間
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;chrono&amp;gt;
@@ -68,20 +73,47 @@ int main()
   std::cout &amp;lt;&amp;lt; tp &amp;lt;&amp;lt; std::endl;
 }
 ```
+* chrono::gps_clock[color ff0000]
 * now()[link gps_clock/now.md]
 
-### 出力例
+#### 出力例
 ```
 2019-10-24 11:15:37.493236171
 ```
 
+### 例2: うるう秒の影響
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+
+namespace chrono = std::chrono;
+using namespace std::literals::chrono_literals;
+
+int main() {
+  auto utc_tp = chrono::utc_clock::from_sys(chrono::sys_days{2024y/1/1});
+  auto gps_tp = chrono::gps_clock::from_utc(utc_tp);
+  std::cout &amp;lt;&amp;lt; utc_tp &amp;lt;&amp;lt; &amp;#34; UTC&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; gps_tp &amp;lt;&amp;lt; &amp;#34; GPS&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* chrono::gps_clock[color ff0000]
+* from_sys[link utc_clock/from_sys.md]
+* from_utc[link gps_clock/from_utc.md]
+
+#### 出力
+```
+2024-01-01 00:00:00 UTC
+2024-01-01 00:00:18 GPS
+```
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): 9.0 [mark noimpl]
-- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.1 [mark verified]
+- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.2 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 3 [mark noimpl]
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tai_clock -- chrono/{tai,gps}_clock: クラス説明を増補</title>
      <link href="https://cpprefjp.github.io/reference/chrono/tai_clock.html"/>
      <id>86f0c41afc9742a6aca155df7cdcce3f5ddb08ff:reference/chrono/tai_clock.md</id>
      <updated>2024-12-16T17:44:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/tai_clock.md b/reference/chrono/tai_clock.md
index 5d281f66e..30d8cfa41 100644
--- a/reference/chrono/tai_clock.md
+++ b/reference/chrono/tai_clock.md
@@ -13,7 +13,8 @@ namespace std::chrono {
 ## 概要
 `tai_clock`は、TAI時間 (国際原子時、International Atomic Time) を表現するためのクロックである。
 
-このクロックは、UTCよりも10秒進んでいる。そのため、1958-01-01 00:00:00 TAIと1957-12-31 23:59:50 UTCは等価である。
+TAIではうるう秒 (leap second) 補正が行われないため、2017年1月1日以降～2024年現在ではUTC (世界協定時) よりも37秒進んだ時間をとる。
+つまり 2024-01-01 00:00:37 TAI と 2024-01-01 00:00:00 UTC は等価である。
 
 
 このクラスの[`now()`](tai_clock/now.md)静的メンバ関数は、標準では`noexcept(false)`である。実装が`noexcept(true)`である保証をしない限り、このクラスはTrivialClock要件を満たさない。
@@ -23,12 +24,13 @@ namespace std::chrono {
 クロックごとの初期時間 (内部的にカウンタがあれば値ゼロ) をエポックと呼ぶ。
 
 `tai_clock`のエポックは、1958年1月1日0時0分0秒である。
+これはUTC時間1957年12月31日23時59分50秒に対応する。
 
 
 ### うるう秒の扱い
-このクロックではうるう秒は挿入されず、うるう秒の数だけ時間が進む。そのため、UTCにうるう秒が挿入されるたびに、UTCはTAIよりも1秒ずつずれていく。
+`tai_clock`ではうるう秒は考慮されず、UTCに対してうるう秒数分だけ時間がシフトする。そのため、UTCに正のうるう秒が挿入されるたびに、UTC時間はTAI時間よりも1秒ずつ遅れていく。
 
-例として、2000年01月01日までに正のうるう秒が22回、負のうるう秒が0回挿入されたため、TAIがUTCより10秒進んでいることも含めて、2000-01-01 00:00:00 UTCと2000-01-01 00:00:32 TAIは等価となる。
+例として、`tai_clock`エポック日 (1958年1月1日) 時点ではUTCには正のうるう秒が10回挿入されており、さらに2000年01月01日までに正のうるう秒が22回、負のうるう秒が0回挿入されたため、2000-01-01 00:00:00 UTCと2000-01-01 00:00:32 TAIは等価となる。
 
 
 ## メンバ関数
@@ -59,6 +61,7 @@ namespace std::chrono {
 
 
 ## 例
+### 例1: 現在TAI時間
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;chrono&amp;gt;
@@ -71,23 +74,51 @@ int main()
   std::cout &amp;lt;&amp;lt; tp &amp;lt;&amp;lt; std::endl;
 }
 ```
+* chrono::tai_clock[color ff0000]
 * now()[link tai_clock/now.md]
 
-### 出力例
+#### 出力例
 ```
-2019-10-24 11:15:47 TAI
+2019-10-24 11:15:47.519957239
 ```
 
+### 例2: うるう秒の影響
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+
+namespace chrono = std::chrono;
+using namespace std::literals::chrono_literals;
+
+int main() {
+  auto utc_tp = chrono::utc_clock::from_sys(chrono::sys_days{2024y/1/1});
+  auto tai_tp = chrono::tai_clock::from_utc(utc_tp);
+  std::cout &amp;lt;&amp;lt; utc_tp &amp;lt;&amp;lt; &amp;#34; UTC&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; tai_tp &amp;lt;&amp;lt; &amp;#34; TAI&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* chrono::tai_clock[color ff0000]
+* from_sys[link utc_clock/from_sys.md]
+* from_utc[link tai_clock/from_utc.md]
+
+#### 出力
+```
+2024-01-01 00:00:00 UTC
+2024-01-01 00:00:37 TAI
+```
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): 9.0 [mark noimpl]
-- [GCC](/implementation.md#gcc): 9.2 [mark noimpl]
+- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.2 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 3 [mark noimpl]
 
 
 ## 参照
 - [国際原子時 - Wikipedia](https://ja.wikipedia.org/wiki/国際原子時)
+- [国立天文台 水沢, うるう秒について](https://www.miz.nao.ac.jp/vlbi/leapsec.html)
 - [LWG Issue 3359. `&amp;lt;chrono&amp;gt;` leap second support should allow for negative leap seconds](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2117r0.html#3359)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>