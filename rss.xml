<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-11-25T19:47:02.983619</updated>
  <id>f0920a77-a148-47a9-b463-99974deda27c</id>

  
    <entry>
      <title>C++20 -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:lang/cpp20.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++20&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20とは、2020年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++2aと呼ばれることがあった。「202a年にリリースされる」という伏せ字として「a」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;クラス&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html&#34;&gt;一貫比較&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;三方比較演算子によって比較演算子の自動生成を行うようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_member_initializers_for_bit_fields.html&#34;&gt;ビットフィールドのメンバ変数初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ビットフィールドメンバ変数のデフォルト値を設定する構文を追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/explicit_bool.html&#34;&gt;関数を条件付きで&lt;code&gt;explicit&lt;/code&gt;にする構文を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;explicit(true)&lt;/code&gt;のように&lt;code&gt;explicit&lt;/code&gt;に真理値パラメータを指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/fixing_const_qualified_pointers_to_members.html&#34;&gt;&lt;code&gt;const&lt;/code&gt;修飾されたメンバポインタの制限を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.*&lt;/code&gt;演算子での左辺値の&lt;code&gt;const&lt;/code&gt;メンバ関数呼び出しを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;デフォルトのコピーコンストラクタと非&lt;code&gt;const&lt;/code&gt;なコンストラクタが衝突する問題を修正&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;特殊化のアクセスチェック&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/language_support_for_empty_objects.html&#34;&gt;空オブジェクトに対する最適化を支援する属性&lt;code&gt;[[no_unique_address]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[no_unique_address]]&lt;/code&gt;属性を導入し、空の型のオブジェクトをほかのオブジェクトと共有する最適化を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_structured_bindings_to_accessible_members.html&#34;&gt;friend指定された関数内から構造化束縛を使用して非公開メンバ変数にアクセスすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛の仕様として公開メンバ変数のみを取り出せるようになっていたが、friend指定された関数からは非公開メンバ変数にもアクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_structured_bindings_customization_point_finding_rules.html&#34;&gt;構造化束縛がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非テンプレートの&lt;code&gt;get()&lt;/code&gt;メンバ関数が見つかった場合は、非メンバ関数の&lt;code&gt;get()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/checking_for_abstract_class_types.md.nolink&#34;&gt;抽象型のチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の宣言段階では、パラメータおよび戻り値型が抽象型かどうかをチェックしないようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md.nolink&#34;&gt;可変長データを扱うクラスの効率的な&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラスの&lt;code&gt;delete&lt;/code&gt;演算子が呼び出される前にデストラクタが呼ばれないようにするオプションを追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/conditionally_trivial_special_member_functions.md.nolink&#34;&gt;条件付きで特殊メンバ関数をトリビアルに定義するように&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;制約によってトリビアルな特殊メンバ関数と非トリビアルな特殊メンバ関数をオーバーロードできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;列挙型&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/using_enum.html&#34;&gt;スコープ付き列挙型のusing宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;using enum EnumType;&lt;/code&gt;もしくは&lt;code&gt;using EnumType::enumerator&lt;/code&gt;とすることで、列挙値のスコープ指定を省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/designated_initialization.html&#34;&gt;指示付き初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波カッコによる集成体初期化でメンバ名を指定して初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/extending_structured_bindings_to_be_more_like_variable_declarations.html&#34;&gt;構造化束縛を拡張して通常の変数宣言のように使用できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;記憶域指定子として&lt;code&gt;static&lt;/code&gt;と&lt;code&gt;thread_local&lt;/code&gt;の指定を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html&#34;&gt;丸カッコの値リストからの集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T x{1, 2, 3};&lt;/code&gt;と同様に&lt;code&gt;T x(1, 2, 3);&lt;/code&gt;でも集成体初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/array_size_deduction_in_new-expressions.md.nolink&#34;&gt;&lt;code&gt;new&lt;/code&gt;式での配列要素数の推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double* p = new double[]{1,2,3};&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md.nolink&#34;&gt;要素数不明の配列への変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;要素数が判明している配列から、要素数が不明の配列への変換を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.md.nolink&#34;&gt;ほとんどの&lt;code&gt;volatile&lt;/code&gt;を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;volatile&lt;/code&gt;の有用な機能のみを残し、効果が疑わしい、または壊れている機能を非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;整数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html&#34;&gt;符号付き整数型が2の補数表現であることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;符号付き整数型のビット表現を2の補数に規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/char8_t.html&#34;&gt;UTF-8エンコーディングされた文字の型として&lt;code&gt;char8_t&lt;/code&gt;を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-8エンコードされた文字かどうかでオーバーロード・特殊化をできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/make_char16t_char32t_string_literals_be_utf16_32.md.nolink&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;の文字・文字列リテラルを、文字コードUTF-16/32に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__STDC_UTF_16__&lt;/code&gt;、&lt;code&gt;__STDC_UTF_32__&lt;/code&gt;の定義に関係なく、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のリテラルをUTF-16/32文字コードに規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nodiscard_should_have_a_reason.md.nolink&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性に理由となる文字列を付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値を無視してはならない理由を関数宣言に持たせ、警告メッセージに役立てる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;制御構文&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/range-based_for_statements_with_initializer.html&#34;&gt;初期化式をともなう範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;範囲for文スコープで使用する変数の初期化のための構文を追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.html&#34;&gt;範囲for文がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;メンバ関数のどちらかが見つからなかった場合に非メンバ関数の&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/likely_and_unlikely_attributes.html&#34;&gt;確率が高い分岐と低い分岐を伝える属性 &lt;code&gt;[[likely]]&lt;/code&gt;, &lt;code&gt;[[unlikely]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;条件分岐の最適化ヒントを与える属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/concepts.html&#34;&gt;コンセプト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータに対する制約を行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/function_templates_with_auto_parameters.html&#34;&gt;autoパラメータによる関数テンプレートの簡易定義&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダと同様、関数パラメータをの型を&lt;code&gt;auto&lt;/code&gt;にすることで簡易的に関数テンプレートを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/down_with_typename.html&#34;&gt;型の文脈で&lt;code&gt;typename&lt;/code&gt;の省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型しか現れない文脈では、依存名を解決するための&lt;code&gt;typename&lt;/code&gt;キーワードを省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_types_in_non-type_template_parameters.md.nolink&#34;&gt;非型テンプレートパラメータとしてクラス型を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;に変換可能な非メンバ関数&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;をもつ型を、非型テンプレートパラメータとして使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_aggregates.md.nolink&#34;&gt;集成体クラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートのテンプレート引数推論はコンストラクタ引数から推論されるが、集成体初期化からも推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_alias_templates.md.nolink&#34;&gt;エイリアステンプレートに対するクラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エイリアステンプレートからクラステンプレートのテンプレート引数を推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;評価されない文脈で&lt;code&gt;constexpr&lt;/code&gt;関数が定数式評価されることを規定&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_virtual_function_calls_in_constant_expressions.html&#34;&gt;定数式からの仮想関数の呼び出しを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;仮想関数に&lt;code&gt;constexpr&lt;/code&gt;を付けられない制限を解除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allowing_dynamic_cast_polymorphic_typeid_in_constant_expressions.md.nolink&#34;&gt;定数式での&lt;code&gt;dynamic_cast&lt;/code&gt;、多態的な&lt;code&gt;typeid&lt;/code&gt;を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式での動的多態を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/try-catch_blocks_in_constexpr_functions.md.nolink&#34;&gt;constexpr関数内でのtry-catchブロックを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内での例外の捕捉を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/immediate_functions.md.nolink&#34;&gt;即時関数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;consteval&lt;/code&gt;キーワードを追加し、常に定数式評価されるよう指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/changing_the_active_member_of_a_union_inside_constexpr.md.nolink&#34;&gt;定数式内での共用体のアクティブメンバの変更を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体メンバの書き換えを定数式内で行えるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.md.nolink&#34;&gt;constexprの文脈でのトリビアルなデフォルト初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内でのデフォルト初期化を許可し、未初期化値を読むことのみ禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.md.nolink&#34;&gt;constexpr関数内で未評価のインラインアセンブリを許可することによる組み込み関数のconstexpr有効化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に評価されない場合にconstexpr関数にasm定義を含めることを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/constinit.md.nolink&#34;&gt;コンパイル時初期化を強制する&lt;code&gt;constinit&lt;/code&gt;キーワードを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化のみコンパイル時におわらせたい場合に使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.md.nolink&#34;&gt;可変サイズをもつコンテナの&lt;code&gt;constexpr&lt;/code&gt;化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;記憶域をもつメモリアロケータの存在を考慮することで、可変サイズをもつコンテナをコンパイル時に使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ラムダ式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/familiar_template_syntax_for_generic_lambdas.html&#34;&gt;ジェネリックラムダのテンプレート構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダでテンプレートパラメータを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_lambda_capture_equal_this.html&#34;&gt;ラムダ式のキャプチャとして&lt;code&gt;[=, this]&lt;/code&gt;を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトコピーキャプチャと&lt;code&gt;this&lt;/code&gt;ポインタのコピーキャプチャを両方指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタをキャプチャされなくする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ラムダ式の制約&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;暗黙のラムダキャプチャを簡略化&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_constructible_and_assignable_stateless_lambdas.html&#34;&gt;状態を持たないラムダ式を、デフォルト構築可能、代入可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャしていないラムダ式をデフォルト構築・代入可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html&#34;&gt;評価されない文脈でのラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;評価されない文脈でもラムダ式を書くことができるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_pack_expansion_in_lambda_init_capture.html&#34;&gt;ラムダ式の初期化キャプチャでのパック展開を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[...args = std::move(args)]&lt;/code&gt;のようなキャプチャを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reference_capture_of_structured_bindings.md.nolink&#34;&gt;構造化束縛したビットフィールドの参照キャプチャ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ビットフィールドを含む構造化束縛をした場合にラムダ式で参照キャプチャできない規定を緩和し、ビットフィールドを直接参照キャプチャ、もしくはデフォルト参照キャプチャして使用しなければ適格とする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;名前空間&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nested_inline_mamespaces.md.nolink&#34;&gt;入れ子名前空間定義でのインライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;namespace ns1::inline ns2::ns3 {}&lt;/code&gt;のように、入れ子名前空間を定義する式にインライン名前空間の指定を含められるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;モジュール化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/modules.html&#34;&gt;モジュール&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ヘッダファイル・ソースファイル、インクルードに変わる仕組みとしてモジュールを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/coroutines.html&#34;&gt;コルーチン&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数実行を中断・再開する仕組みとしてコルーチンを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;プリプロセッサ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/va_opt.html&#34;&gt;可変引数が空でない場合のトークン置換&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサの置換で可変引数が空の場合に余計なカンマが付いてしまう問題に対処&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PODを非推奨化&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタをキャプチャされなくする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_uses_of_the_comma_operator_in_subscripting_expressions.md.nolink&#34;&gt;添字演算子内でのカンマ演算子の使用を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ar[i, j]&lt;/code&gt;を非推奨化。&lt;code&gt;ar[(i, j)]&lt;/code&gt;はOK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;throw()&lt;/code&gt;による例外送出しない指定を削除&lt;/td&gt;
&lt;td&gt;代わりに&lt;code&gt;noexcept&lt;/code&gt;を使用すること&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/prohibit_aggregates_with_user-declared_constructors.md.nolink&#34;&gt;ユーザー宣言したコンストラクタを持つクラスの集成体初期化を禁止&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタが&lt;code&gt;delete&lt;/code&gt;宣言されているクラスを、集成体初期化によってコンストラクタ呼び出しを回避して構築できてしまっていた技法を禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/update_the_reference_to_the_unicode_standard.md.nolink&#34;&gt;Unicode標準への参照を更新&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準C++からISO/IEC 10646への参照を更新し、古い固定バージョンへの参照をやめる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reserving_attribute_namespaces_for_future_use.html&#34;&gt;属性の名前空間を予約&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将来の使用のために属性の名前空間を予約&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;バージョン情報ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/version.html&#34;&gt;&amp;lt;version&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。ここでは、実装依存の情報 (バージョンやリリース日付など) が標準ライブラリの実装によって定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;ライブラリに、カレンダーとタイムゾーンの機能を拡張&lt;/li&gt;
&lt;li&gt;任意のシーケンスの部分シーケンスを参照するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/span.html&#34;&gt;&amp;lt;span&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;文字列フォーマットライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format.html&#34;&gt;&amp;lt;format&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;出力ストリームを同期するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/syncstream.html&#34;&gt;&amp;lt;syncstream&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;三方比較ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numbers.html&#34;&gt;&amp;lt;numbers&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。数学定数が定義される&lt;/li&gt;
&lt;li&gt;ビット操作ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit.html&#34;&gt;&amp;lt;bit&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;Strict Aliasing規則に抵触しないビットレベルの再解釈キャストである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_cast.html&#34;&gt;std::bit_cast()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;2の乗数関係の関数として、整数値が2の累乗かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/has_single_bit.html&#34;&gt;std::has_single_bit()&lt;/a&gt;&lt;/code&gt;関数、整数値を2の累乗値に切り上げる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_ceil.html&#34;&gt;std::bit_ceil()&lt;/a&gt;&lt;/code&gt;関数、整数値を2の累乗値に切り下げる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_floor.html&#34;&gt;std::bit_floor()&lt;/a&gt;&lt;/code&gt;関数、2を底とした整数値の対数を求めて1を足す&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_width.html&#34;&gt;std::bit_width()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;循環ビットシフトを行う&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/rotl.html&#34;&gt;std::rotl()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/rotr.html&#34;&gt;std::rotr()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;連続した0もしくは1のビットを数える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countl_zero.html&#34;&gt;std::countl_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countl_one.html&#34;&gt;std::countl_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countr_zero.html&#34;&gt;std::countr_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countr_one.html&#34;&gt;std::countr_one()&lt;/a&gt;&lt;/code&gt;、および立っているビットを数える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/popcount.html&#34;&gt;std::popcount()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;エンディアンを表す列挙型として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/endian.html&#34;&gt;std::endian&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;型制約のための要件ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts.html&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;言語機能であるコルーチンを制御するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/coroutine.html&#34;&gt;&amp;lt;coroutine&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッドの実行を停止させるメカニズムとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stop_token.html&#34;&gt;&amp;lt;stop_token&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加し、停止に対応したスレッドクラスとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread.html&#34;&gt;&amp;lt;thread&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/jthread.html&#34;&gt;std::jthread&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;軽量な同期プリミティブであるセマフォのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/semaphore.html&#34;&gt;&amp;lt;semaphore&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッド調整メカニズムとして、ラッチライブラリの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/latch.html&#34;&gt;&amp;lt;latch&amp;gt;&lt;/a&gt;&lt;/code&gt;、バリアライブラリの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/barrier.html&#34;&gt;&amp;lt;barrier&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータの組ではなく、コンテナや配列、部分的なコンテナなどを扱う範囲ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.md.nolink&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;既存のイテレータの組を扱うアルゴリズムは、&lt;code&gt;std::ranges&lt;/code&gt;名前空間に範囲版アルゴリズムが追加される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ソースコードの位置を取得するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/source_location.html&#34;&gt;&amp;lt;source_location&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;取り決め&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std&lt;/code&gt;名前空間以下の関数テンプレートをユーザーが特殊化することを禁止する (参照 : &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf&#34; target=&#34;_blank&#34;&gt;P0551R3&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;連想コンテナに、要素がコンテナに含まれているかを判定する&lt;code&gt;contains()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;順序付き連想コンテナと同様に、非順序連想コンテナの検索処理で、一時オブジェクトが生成されるコストを抑える拡張を追加。ハッシュ計算を行う関数オブジェクトに&lt;code&gt;transparent_key_equal&lt;/code&gt;が定義されていれば、透過的な検索が使用できる。&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;クラスのページを参照&lt;/li&gt;
&lt;li&gt;各コンテナの非メンバ関数として、要素を削除する&lt;code&gt;std::erase()&lt;/code&gt;関数と&lt;code&gt;std::erase_if()&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;のメンバ関数&lt;code&gt;remove()&lt;/code&gt;、&lt;code&gt;remove_if()&lt;/code&gt;、&lt;code&gt;unique()&lt;/code&gt;の戻り値型を、&lt;code&gt;void&lt;/code&gt;から&lt;code&gt;Container::size_type&lt;/code&gt;に変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;クラスの比較演算子、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/fill.html&#34;&gt;fill()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;組み込み配列を&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;に変換する関数として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/to_array.html&#34;&gt;std::to_array()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数としてコンテナの要素数を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ssize.html&#34;&gt;std::ssize()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;、および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/vector/vector.html&#34;&gt;std::vector&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;の多くの関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素位置をシフトする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shift_left.html&#34;&gt;std::shift_left()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shift_right.html&#34;&gt;std::shift_right()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に三方比較による辞書順比較アルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/lexicographical_compare_three_way.html&#34;&gt;std::lexicographical_compare_three_way()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値とポインタの中点を求める関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/midpoint.html&#34;&gt;std::midpoint()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;浮動小数点数を線形補間する関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/lerp.html&#34;&gt;std::lerp()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムをムーブに対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムに&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_insert_iterator.html&#34;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_insert_iterator.html&#34;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/insert_iterator.html&#34;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt;クラスのコンストラクタ、代入演算子、間接参照演算子、インクリメント演算子、および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_inserter.html&#34;&gt;std::back_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_inserter.html&#34;&gt;std::front_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/inserter.html&#34;&gt;std::inserter()&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;constexpr&lt;/code&gt;を追加。これらのクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/ref.html&#34;&gt;std::ref()&lt;/a&gt;&lt;/code&gt;関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/cref.html&#34;&gt;std::cref()&lt;/a&gt;&lt;/code&gt;関数のテンプレートパラメータ&lt;code&gt;T&lt;/code&gt;型に不完全型を指定することを許可&lt;/li&gt;
&lt;li&gt;メンバ関数の部分適用をかんたんにするために、プレースホルダーの指定なく引数を先頭から順に束縛する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;の各操作、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;std::not_fn()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;std::bind()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;std::mem_fn()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;li&gt;コンセプトの導入にともない、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った値をそのまま返す関数オブジェクト&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/identity.html&#34;&gt;std::identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;クラスに、先頭の部分文字列を判定する&lt;code&gt;starts_with()&lt;/code&gt;メンバ関数、末尾の部分文字列を判定する&lt;code&gt;ends_with()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数の、メモリの縮小機能を削除し、伸長のみとする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits.html&#34;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/move.html&#34;&gt;move()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/copy.html&#34;&gt;copy()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/assign.html&#34;&gt;assign()&lt;/a&gt;&lt;/code&gt;静的メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが、値初期化するよう動作変更。これまではC言語との互換性のために未初期化となっていた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの浮動小数点数型に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;アトミッククラスに対するブロッキング同期の機能として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/wait.html&#34;&gt;wait()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html&#34;&gt;notify_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/notify_all.html&#34;&gt;notify_all()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ロックフリーであることが保証されたアトミック整数型の別名として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;atomic_signed_lock_free&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;atomic_unsigned_lock_free&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/memory_order.html&#34;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;の列挙子にスコープをもたせた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスに、&lt;code&gt;bool&lt;/code&gt;値を読み込むメンバ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag/test.html&#34;&gt;test()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;非アトミックなオブジェクトにアトミック操作を適用するためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ベクトル化の実行ポリシーとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unsequenced_policy&lt;/a&gt;&lt;/code&gt;型と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unseq&lt;/a&gt;&lt;/code&gt;タグを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同期ストリームの追加にともなって、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream.html&#34;&gt;&amp;lt;ostream&amp;gt;&lt;/a&gt;&lt;/code&gt;に、同期ストリーム関係の出力マニピュレータを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/istream/basic_istream/op_istream_free.html&#34;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;(basic_istream&amp;amp;, CharT*)&lt;/code&gt;を&lt;code&gt;operator&amp;gt;&amp;gt;(basic_istream&amp;amp;, CharT (&amp;amp;)[N])&lt;/code&gt;に修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream/basic_ostream/op_ostream_free.html&#34;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;wchar_t&lt;/code&gt; (&lt;code&gt;char&lt;/code&gt;版のみ)、&lt;code&gt;char8_t&lt;/code&gt;、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のdelete宣言を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/istream_iterator.html&#34;&gt;std::istream_iterator&lt;/a&gt;&lt;/code&gt;について、要件の書き方を整理し、振る舞いをより明確化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::basic_stringbuf&lt;/code&gt;、&lt;code&gt;std::basic_istringstream&lt;/code&gt;、&lt;code&gt;std::basic_ostringstream&lt;/code&gt;クラスに、アロケータを伝播させるためのインタフェースを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_shared.html&#34;&gt;std::make_shared()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocate_shared.html&#34;&gt;std::allocate_shared()&lt;/a&gt;&lt;/code&gt;を配列に対応&lt;/li&gt;
&lt;li&gt;スマートポインタをデフォルト初期化で構築するヘルパ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_unique_for_overwrite.html&#34;&gt;std::make_unique_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_shared_for_overwrite.html&#34;&gt;std::make_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocate_shared_for_overwrite.html&#34;&gt;std::allocate_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ポインタを生ポインタに変換する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/to_address.html&#34;&gt;std::to_address()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_traits.html&#34;&gt;std::pointer_traits&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_traits/pointer_to.html&#34;&gt;pointer_to()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Nバイトアライメントされたポインタであることをコンパイラに伝える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/assume_aligned.html&#34;&gt;std::assume_aligned()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、uses allocator構築をサポートするユーティリティ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/uses_allocator_construction_args.html&#34;&gt;std::uses_allocator_construction_args()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_obj_using_allocator.html&#34;&gt;std::make_obj_using_allocator()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/uninitialized_construct_using_allocator.html&#34;&gt;std::uninitialized_construct_using_allocator()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator.html&#34;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;に、以下の変更を追加：&lt;ul&gt;
&lt;li&gt;クラステンプレートのデフォルトテンプレート引数を&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;&lt;/code&gt;型とした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt;のバイト列をメモリ確保する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/allocate_bytes.html&#34;&gt;allocate_bytes()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/deallocate_bytes.html&#34;&gt;deallocate_bytes()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリを確保する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/allocate_object.html&#34;&gt;allocate_object()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/deallocate_object.html&#34;&gt;deallocate_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリ確保と構築をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/new_object.html&#34;&gt;new_object()&lt;/a&gt;&lt;/code&gt;、破棄と解放をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/delete_object.html&#34;&gt;delete_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数と符号なし整数の安全な比較関数として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_equal.html&#34;&gt;std::cmp_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_not_equal.html&#34;&gt;std::cmp_not_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less.html&#34;&gt;std::cmp_less()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less_equal.html&#34;&gt;std::cmp_less_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater.html&#34;&gt;std::cmp_greater()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater_equal.html&#34;&gt;std::cmp_greater_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_range.html&#34;&gt;std::in_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/swap.html&#34;&gt;std::swap()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/exchange.html&#34;&gt;std::exchange()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;クラスを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイルシステム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/filesystem/create_directory.html&#34;&gt;std::filesystem::create_directory()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/filesystem/create_directories.html&#34;&gt;std::filesystem::create_directories()&lt;/a&gt;&lt;/code&gt;の仕様が直感的ではなく、すでにディレクトリが存在している場合にエラーとなっていた。C++20ではその状況ではエラーにならないようにする (エラーではなく&lt;code&gt;false&lt;/code&gt;が返る)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、constexpr関数が定数式評価されたかを判定する特殊な関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_constant_evaluated.html&#34;&gt;std::is_constant_evaluated()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、型のCV修飾と参照を除去する型特性クラスとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;std::remove_cvref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った型をそのまま返す&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/type_identity.html&#34;&gt;std::type_identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、例外送出せずに暗黙の型変換が可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_convertible.html&#34;&gt;std::is_nothrow_convertible&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素数が判明している配列型かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_bounded_array.html&#34;&gt;std::is_bounded_array&lt;/a&gt;&lt;/code&gt;、要素数が不明な配列型かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_unbounded_array.html&#34;&gt;std::is_unbounded_array&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、レイアウト互換性、ポインタ変換可能性を判定する以下の型特性を追加：&lt;ul&gt;
&lt;li&gt;2つの型にレイアウト互換があるかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_layout_compatible.md.nolink&#34;&gt;std::is_layout_compatible&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基底クラスと派生クラスの間でポインタ変換可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_base_of.md.nolink&#34;&gt;std::is_pointer_interconvertible_base_of&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メンバポインタがクラスのポインタに変換可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_with_class.md.nolink&#34;&gt;is_pointer_interconvertible_with_class()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2つの互換レイアウトをもつメンバポインタが共通位置にあるかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_corresponding_member.md.nolink&#34;&gt;std::is_corresponding_member()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型を&lt;code&gt;T&amp;amp;&lt;/code&gt;型に展開する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_reference.html&#34;&gt;std::unwrap_reference&lt;/a&gt;&lt;/code&gt;型特性、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;std::decay&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型の展開をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_ref_decay.html&#34;&gt;std::unwrap_ref_decay&lt;/a&gt;&lt;/code&gt;型特性を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一貫比較非機能によって比較演算子の定義が容易になったため、不要になった演算子の簡潔定義機能である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/rel_ops.html&#34;&gt;std::rel_ops&lt;/a&gt;&lt;/code&gt;を非推奨化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数が、メモリの縮小をしなくなったため、デフォルト引数&lt;code&gt;0&lt;/code&gt;を非推奨可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが値初期化するようになったため、不要になった以下のアトミックオブジェクトの初期化機能を非推奨化：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_init.html&#34;&gt;std::atomic_init()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_var_init.html&#34;&gt;ATOMIC_VAR_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag_init.html&#34;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;allocator&lt;/a&gt;&lt;/code&gt;の以下のメンバを削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;difference_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rebind&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/address.html&#34;&gt;address()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/allocate.html&#34;&gt;allocate()&lt;/a&gt;&lt;/code&gt;メンバ関数の&lt;code&gt;hint&lt;/code&gt;パラメータ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/max_size.html&#34;&gt;max_size()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/construct.html&#34;&gt;construct()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/destroy.html&#34;&gt;destroy()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、要素型を再束縛するための&lt;code&gt;allocator&amp;lt;void&amp;gt;&lt;/code&gt;特殊化を非推奨化&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、&lt;code&gt;constexpr&lt;/code&gt;で扱える型の分類である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_literal_type.html&#34;&gt;is_literal_type&lt;/a&gt;&lt;/code&gt;型特性を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、一時的なメモリ確保のための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/get_temporary_buffer.html&#34;&gt;std::get_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/return_temporary_buffer.html&#34;&gt;std::return_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/raw_storage_iterator.html&#34;&gt;raw_storage_iterator&lt;/a&gt;&lt;/code&gt;クラスを削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた以下の機能を削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;not1()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;not2()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;unary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;binary_nagate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;標準関数オブジェクトの&lt;code&gt;result_type&lt;/code&gt;、&lt;code&gt;argument_type&lt;/code&gt;、&lt;code&gt;first_argument_type&lt;/code&gt;、&lt;code&gt;second_argument_type&lt;/code&gt;型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;shared_ptr&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr/unique.html&#34;&gt;unique()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/invoke_result.html&#34;&gt;invoke_result&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/result_of.html&#34;&gt;result_of&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17での&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exception/uncaught_exceptions.html&#34;&gt;uncaught_exceptions()&lt;/a&gt;&lt;/code&gt;の追加にともない、非推奨化していた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exception/uncaught_exception.html&#34;&gt;uncaught_exception()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていたC互換ライブラリ&lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt;を削除。また、C++ではなにも定義されないC互換ライブラリ&lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2131r0.html&#34; target=&#34;_blank&#34;&gt;P2131R0 Changes between C++17 and C++20 DIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>utility -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/reference/utility.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:reference/utility.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;utility&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;utility&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;ヘッダでは、その他のライブラリの至る所で使用される、幾つかの基本的な関数やクラステンプレートを定義する。&lt;/p&gt;
&lt;p&gt;このヘッダでは、以下の標準ヘッダをインクルードする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/initializer_list.html&#34;&gt;&amp;lt;initializer_list&amp;gt;&lt;/a&gt;&lt;/code&gt; (C++11)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt; (C++20)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;演算子定義&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/rel_ops.html&#34;&gt;rel_ops&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関係演算子(namespace)&lt;/td&gt;
&lt;td&gt;C++20から非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;値の入れ替え&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/swap.html&#34;&gt;swap&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;二つのオブジェクトの値を交換する(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/exchange.html&#34;&gt;exchange&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値を書き換え、書き換え前の値を返す(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;転送と移動&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;forward&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数テンプレートの引数を転送する(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/move.html&#34;&gt;move&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左辺値を右辺値にキャストする(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/move_if_noexcept.html&#34;&gt;move_if_noexcept&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例外を投げないオブジェクトをムーブする(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;型の修飾&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/as_const.html&#34;&gt;as_const&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左辺値参照を&lt;code&gt;const&lt;/code&gt;左辺値参照にする (function template)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;型の値&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/declval.html&#34;&gt;declval&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された型の値を得る(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;整数比較&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_equal.html&#34;&gt;cmp_equal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等値比較 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_not_equal.html&#34;&gt;cmp_not_equal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非等値比較 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less.html&#34;&gt;cmp_less&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左辺が右辺より小さいかを比較 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less_equal.html&#34;&gt;cmp_less_equal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左辺が右辺以下かを比較 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater.html&#34;&gt;cmp_greater&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左辺が右辺より大きいかを比較 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater_equal.html&#34;&gt;cmp_greater_equal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左辺が右辺以上かを比較 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_range.html&#34;&gt;in_range&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値が型のとりうる範囲内か判定する (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;組&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;pair&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;異なる型の二つの値の組(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/make_pair.html&#34;&gt;make_pair&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pair&lt;/code&gt;を構築するヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/piecewise_construct_t.html&#34;&gt;piecewise_construct_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pair&lt;/code&gt;や&lt;code&gt;tuple&lt;/code&gt;の要素型のコンストラクタ引数を直接受け取って構築するためのタグ型(class)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/piecewise_construct_t.html&#34;&gt;piecewise_construct&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pair&lt;/code&gt;や&lt;code&gt;tuple&lt;/code&gt;の要素型のコンストラクタ引数を直接受け取って構築するためのタグ値(constant variable)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;tuple&lt;/code&gt;型の先行宣言(class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;直接構築&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_place_t.html&#34;&gt;in_place_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素型のコンストラクタ引数を直接受け取って構築するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_place_t.html&#34;&gt;in_place&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素型のコンストラクタ引数を直接受け取って構築するためのタグ値 (constant variable)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_place_type_t.html&#34;&gt;in_place_type_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定した要素型のコンストラクタ引数を直接受け取って構築するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_place_type_t.html&#34;&gt;in_place_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定した要素型のコンストラクタ引数を直接受け取って構築するためのタグ値 (constant variable)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_place_index_t.html&#34;&gt;in_place_index_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定位置にある要素型のコンストラクタ引数を直接受け取って構築するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_place_index_t.html&#34;&gt;in_place_index&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定位置にある要素型のコンストラクタ引数を直接受け取って構築するためのタグ値 (constant variable)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;コンパイル時の整数シーケンス&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/integer_sequence.html&#34;&gt;integer_sequence&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意の整数型のシーケンス(class template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/make_integer_sequence.html&#34;&gt;make_integer_sequence&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素数を指定して、0から始まる整数シーケンスを生成する(type-alias)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/index_sequence.html&#34;&gt;index_sequence&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;size_t&lt;/code&gt;型の整数シーケンス(class template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/make_index_sequence.html&#34;&gt;make_index_sequence&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素数を指定して、0から始まる&lt;code&gt;size_t&lt;/code&gt;型整数シーケンスを生成する(type-alias)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/index_sequence_for.html&#34;&gt;index_sequence_for&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型のシーケンスを、0から始まる&lt;code&gt;size_t&lt;/code&gt;型整数シーケンスに変換する(type-alias)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2051r0.html&#34; target=&#34;_blank&#34;&gt;P2051R0 C++ Standard Library Issues to be moved in Prague&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmp_equal -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/cmp_equal.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:reference/utility/cmp_equal.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/cmp_equal.md b/reference/utility/cmp_equal.md
new file mode 100644
index 000000000..7bd6d53ce
--- /dev/null
+++ b/reference/utility/cmp_equal.md
@@ -0,0 +1,92 @@
+# cmp_equal
+* utility[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T, class U&amp;gt;
+  constexpr bool cmp_equal(T t, U u) noexcept;
+}
+```
+
+## 概要
+整数を安全に等値比較する。
+
+この関数は、型`T`と型`U`がそれぞれ符号付き整数と符号なし整数のどちらであったとしても、安全に比較できる関数である。以下のように符号付き整数のインデックス変数と符号なし整数の配列要素数の比較によってコンパイラに警告が出力されてしまうような状況で使用できる：
+
+```cpp
+std::vector&amp;lt;X&amp;gt; v;
+
+// 警告：式`i &amp;lt; v.size()`で、符号付き整数と符号なし整数の間で比較しようとした
+for (int i = 0; i &amp;lt; v.size(); ++i) {}
+```
+
+
+## 適格要件
+- 型`T`と型`U`はどちらも、符号なし整数型もしくは符号付き整数型であること
+
+
+## 効果
+以下と等価：
+
+```cpp
+using UT = make_unsigned_t&amp;lt;T&amp;gt;;
+using UU = make_unsigned_t&amp;lt;U&amp;gt;;
+if constexpr (is_signed_v&amp;lt;T&amp;gt; == is_signed_v&amp;lt;U&amp;gt;)
+  return t == u;
+else if constexpr (is_signed_v&amp;lt;T&amp;gt;)
+  return t &amp;lt; 0 ? false : UT(t) == u;
+else
+  return u &amp;lt; 0 ? false : t == UU(u);
+```
+* make_unsigned_t[link /reference/type_traits/make_unsigned.md]
+* is_signed_v[link /reference/type_traits/is_signed.md]
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main() {
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 符号付き整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_equal(1, 1) &amp;lt;&amp;lt; std::endl;
+
+  // 符号なし整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_equal(1u, 1u) &amp;lt;&amp;lt; std::endl;
+
+  // 符号付き整数型と符号なし整数型の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_equal(1, 1u) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::cmp_equal(1u, 1) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::cmp_equal[color ff0000]
+
+### 出力
+```
+true
+true
+true
+true
+```
+
+## バージョン
+### 言語
+- C++20
+
+## 処理系
+- [Clang](/implementation.md#clang):
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 7
+
+
+## 参照
+- [P0586R2 Safe integral comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmp_greater -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/cmp_greater.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:reference/utility/cmp_greater.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/cmp_greater.md b/reference/utility/cmp_greater.md
new file mode 100644
index 000000000..78e8c92e3
--- /dev/null
+++ b/reference/utility/cmp_greater.md
@@ -0,0 +1,84 @@
+# cmp_greater
+* utility[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T, class U&amp;gt;
+  constexpr bool cmp_greater(T t, U u) noexcept;
+}
+```
+
+## 概要
+整数に対して安全に、左辺が右辺より大きいかを比較する。
+
+この関数は、型`T`と型`U`がそれぞれ符号付き整数と符号なし整数のどちらであったとしても、安全に比較できる関数である。以下のように符号付き整数のインデックス変数と符号なし整数の配列要素数の比較によってコンパイラに警告が出力されてしまうような状況で使用できる：
+
+```cpp
+std::vector&amp;lt;X&amp;gt; v;
+
+// 警告：式`i &amp;lt; v.size()`で、符号付き整数と符号なし整数の間で比較しようとした
+for (int i = 0; i &amp;lt; v.size(); ++i) {}
+```
+
+
+## 適格要件
+- 型`T`と型`U`はどちらも、符号なし整数型もしくは符号付き整数型であること
+
+
+## 効果
+以下と等価：
+
+```cpp
+return cmp_less(u, t);
+```
+* cmp_less[link cmp_less.md]
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main() {
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 符号付き整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_greater(2, 1) &amp;lt;&amp;lt; std::endl;
+
+  // 符号なし整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_greater(2u, 1u) &amp;lt;&amp;lt; std::endl;
+
+  // 符号付き整数型と符号なし整数型の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_greater(2, 1u) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::cmp_greater(2u, 1) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::cmp_greater[color ff0000]
+
+### 出力
+```
+true
+true
+true
+true
+```
+
+## バージョン
+### 言語
+- C++20
+
+## 処理系
+- [Clang](/implementation.md#clang):
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 7
+
+
+## 参照
+- [P0586R2 Safe integral comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmp_greater_equal -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/cmp_greater_equal.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:reference/utility/cmp_greater_equal.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/cmp_greater_equal.md b/reference/utility/cmp_greater_equal.md
new file mode 100644
index 000000000..e85ea8eb9
--- /dev/null
+++ b/reference/utility/cmp_greater_equal.md
@@ -0,0 +1,84 @@
+# cmp_greater_equal
+* utility[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T, class U&amp;gt;
+  constexpr bool cmp_greater_equal(T t, U u) noexcept;
+}
+```
+
+## 概要
+整数に対して安全に、左辺が右辺以上かを比較する。
+
+この関数は、型`T`と型`U`がそれぞれ符号付き整数と符号なし整数のどちらであったとしても、安全に比較できる関数である。以下のように符号付き整数のインデックス変数と符号なし整数の配列要素数の比較によってコンパイラに警告が出力されてしまうような状況で使用できる：
+
+```cpp
+std::vector&amp;lt;X&amp;gt; v;
+
+// 警告：式`i &amp;lt; v.size()`で、符号付き整数と符号なし整数の間で比較しようとした
+for (int i = 0; i &amp;lt; v.size(); ++i) {}
+```
+
+
+## 適格要件
+- 型`T`と型`U`はどちらも、符号なし整数型もしくは符号付き整数型であること
+
+
+## 効果
+以下と等価：
+
+```cpp
+return !cmp_less(t, u);
+```
+* cmp_less[link cmp_less.md]
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main() {
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 符号付き整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_greater_equal(2, 1) &amp;lt;&amp;lt; std::endl;
+
+  // 符号なし整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_greater_equal(2u, 1u) &amp;lt;&amp;lt; std::endl;
+
+  // 符号付き整数型と符号なし整数型の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_greater_equal(2, 1u) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::cmp_greater_equal(2u, 1) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::cmp_greater_equal[color ff0000]
+
+### 出力
+```
+true
+true
+true
+true
+```
+
+## バージョン
+### 言語
+- C++20
+
+## 処理系
+- [Clang](/implementation.md#clang):
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 7
+
+
+## 参照
+- [P0586R2 Safe integral comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmp_less -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/cmp_less.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:reference/utility/cmp_less.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/cmp_less.md b/reference/utility/cmp_less.md
new file mode 100644
index 000000000..d8188d72d
--- /dev/null
+++ b/reference/utility/cmp_less.md
@@ -0,0 +1,91 @@
+# cmp_less
+* utility[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T, class U&amp;gt;
+  constexpr bool cmp_less(T t, U u) noexcept;
+}
+```
+
+## 概要
+整数に対して安全に、左辺が右辺より小さいかを比較する。
+
+この関数は、型`T`と型`U`がそれぞれ符号付き整数と符号なし整数のどちらであったとしても、安全に比較できる関数である。以下のように符号付き整数のインデックス変数と符号なし整数の配列要素数の比較によってコンパイラに警告が出力されてしまうような状況で使用できる：
+
+```cpp
+std::vector&amp;lt;X&amp;gt; v;
+
+// 警告：式`i &amp;lt; v.size()`で、符号付き整数と符号なし整数の間で比較しようとした
+for (int i = 0; i &amp;lt; v.size(); ++i) {}
+```
+
+
+## 適格要件
+- 型`T`と型`U`はどちらも、符号なし整数型もしくは符号付き整数型であること
+
+
+## 効果
+以下と等価：
+
+```cpp
+using UU = make_unsigned_t&amp;lt;U&amp;gt;;
+if constexpr (is_signed_v&amp;lt;T&amp;gt; == is_signed_v&amp;lt;U&amp;gt;)
+  return t &amp;lt; u;
+else if constexpr (is_signed_v&amp;lt;T&amp;gt;)
+  return t &amp;lt; 0 ? true : UT(t) &amp;lt; u;
+else
+  return u &amp;lt; 0 ? false : t &amp;lt; UU(u);
+```
+* make_unsigned_t[link /reference/type_traits/make_unsigned.md]
+* is_signed_v[link /reference/type_traits/is_signed.md]
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main() {
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 符号付き整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_less(1, 2) &amp;lt;&amp;lt; std::endl;
+
+  // 符号なし整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_less(1u, 2u) &amp;lt;&amp;lt; std::endl;
+
+  // 符号付き整数型と符号なし整数型の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_less(1, 2u) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::cmp_less(1u, 2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::cmp_less[color ff0000]
+
+### 出力
+```
+true
+true
+true
+true
+```
+
+## バージョン
+### 言語
+- C++20
+
+## 処理系
+- [Clang](/implementation.md#clang):
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 7
+
+
+## 参照
+- [P0586R2 Safe integral comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmp_less_equal -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/cmp_less_equal.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:reference/utility/cmp_less_equal.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/cmp_less_equal.md b/reference/utility/cmp_less_equal.md
new file mode 100644
index 000000000..22b3897bb
--- /dev/null
+++ b/reference/utility/cmp_less_equal.md
@@ -0,0 +1,84 @@
+# cmp_less_equal
+* utility[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T, class U&amp;gt;
+  constexpr bool cmp_less_equal(T t, U u) noexcept;
+}
+```
+
+## 概要
+整数に対して安全に、左辺が右辺以下かを比較する。
+
+この関数は、型`T`と型`U`がそれぞれ符号付き整数と符号なし整数のどちらであったとしても、安全に比較できる関数である。以下のように符号付き整数のインデックス変数と符号なし整数の配列要素数の比較によってコンパイラに警告が出力されてしまうような状況で使用できる：
+
+```cpp
+std::vector&amp;lt;X&amp;gt; v;
+
+// 警告：式`i &amp;lt; v.size()`で、符号付き整数と符号なし整数の間で比較しようとした
+for (int i = 0; i &amp;lt; v.size(); ++i) {}
+```
+
+
+## 適格要件
+- 型`T`と型`U`はどちらも、符号なし整数型もしくは符号付き整数型であること
+
+
+## 効果
+以下と等価：
+
+```cpp
+return !cmp_greater(t, u);
+```
+* cmp_greater[link cmp_greater.md]
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main() {
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 符号付き整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_less_equal(1, 2) &amp;lt;&amp;lt; std::endl;
+
+  // 符号なし整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_less_equal(1u, 2u) &amp;lt;&amp;lt; std::endl;
+
+  // 符号付き整数型と符号なし整数型の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_less_equal(1, 2u) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::cmp_less_equal(1u, 2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::cmp_less_equal[color ff0000]
+
+### 出力
+```
+true
+true
+true
+true
+```
+
+## バージョン
+### 言語
+- C++20
+
+## 処理系
+- [Clang](/implementation.md#clang):
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 7
+
+
+## 参照
+- [P0586R2 Safe integral comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmp_not_equal -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/cmp_not_equal.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:reference/utility/cmp_not_equal.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/cmp_not_equal.md b/reference/utility/cmp_not_equal.md
new file mode 100644
index 000000000..0368fc409
--- /dev/null
+++ b/reference/utility/cmp_not_equal.md
@@ -0,0 +1,80 @@
+# cmp_not_equal
+* utility[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T, class U&amp;gt;
+  constexpr bool cmp_not_equal(T t, U u) noexcept;
+}
+```
+
+## 概要
+整数を安全に非等値比較する。
+
+この関数は、型`T`と型`U`がそれぞれ符号付き整数と符号なし整数のどちらであったとしても、安全に比較できる関数である。以下のように符号付き整数のインデックス変数と符号なし整数の配列要素数の比較によってコンパイラに警告が出力されてしまうような状況で使用できる：
+
+```cpp
+std::vector&amp;lt;X&amp;gt; v;
+
+// 警告：式`i &amp;lt; v.size()`で、符号付き整数と符号なし整数の間で比較しようとした
+for (int i = 0; i &amp;lt; v.size(); ++i) {}
+```
+
+
+## 効果
+以下と等価：
+
+```cpp
+return cmp_equal(t, u);
+```
+* cmp_equal[link cmp_equal.md]
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main() {
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  // 符号付き整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_not_equal(1, 2) &amp;lt;&amp;lt; std::endl;
+
+  // 符号なし整数型同士の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_not_equal(1u, 2u) &amp;lt;&amp;lt; std::endl;
+
+  // 符号付き整数型と符号なし整数型の比較
+  std::cout &amp;lt;&amp;lt; std::cmp_not_equal(1, 2u) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::cmp_not_equal(1u, 2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::cmp_not_equal[color ff0000]
+
+### 出力
+```
+true
+true
+true
+true
+```
+
+## バージョン
+### 言語
+- C++20
+
+## 処理系
+- [Clang](/implementation.md#clang):
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 7
+
+
+## 参照
+- [P0586R2 Safe integral comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_range -- &lt;utility&gt;に、安全な整数比較の関数を追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/in_range.html"/>
      <id>44ae2cb503d46505b7741f944ede541a4e38051b:reference/utility/in_range.md</id>
      <updated>2020-11-26T04:42:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/in_range.md b/reference/utility/in_range.md
new file mode 100644
index 000000000..96638e1d0
--- /dev/null
+++ b/reference/utility/in_range.md
@@ -0,0 +1,81 @@
+# in_range
+* utility[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class R, class T&amp;gt;
+  constexpr bool in_range(T t) noexcept;
+}
+```
+
+## 概要
+値が型のとりうる範囲内か判定する。
+
+この関数は、任意の整数型`T`の値`t`が、指定した整数型`R`のとりうる範囲内かを判定する。
+
+
+## 適格要件
+- 型`T`と型`U`はどちらも、符号なし整数型もしくは符号付き整数型であること
+
+
+## 効果
+以下と等価：
+
+```cpp
+return cmp_greater_equal(t, numeric_limits&amp;lt;R&amp;gt;::min()) &amp;amp;&amp;amp;
+       cmp_less_equal(t, numeric_limits&amp;lt;R&amp;gt;::max());
+```
+* cmp_greater_equal[link cmp_greater_equal.md]
+* cmp_less_equal[link cmp_less_equal.md]
+* numeric_limits[link /reference/limits/numeric_limits.md]
+* min()[link /reference/limits/numeric_limits/min.md]
+* max()[link /reference/limits/numeric_limits/max.md]
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;cstdint&amp;gt;
+
+int main() {
+  // -1は、符号付き整数型intのとりうる範囲内である
+  assert(std::in_range&amp;lt;int&amp;gt;(-1));
+
+  // -1は、符号なし整数型unsigned intのとりうる範囲内ではない
+  assert(!std::in_range&amp;lt;unsigned int&amp;gt;(-1));
+
+  // 255は、符号なし8ビット整数の範囲内である
+  assert(std::in_range&amp;lt;std::uint8_t&amp;gt;(255));
+
+  // 255は、符号付き8ビット整数の範囲内ではない
+  assert(!std::in_range&amp;lt;std::int8_t&amp;gt;(255));
+}
+```
+* std::in_range[color ff0000]
+* std::uint8_t[link /reference/cstdint/uint8_t.md]
+* std::int8_t[link /reference/cstdint/int8_t.md]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+## 処理系
+- [Clang](/implementation.md#clang):
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 7
+
+
+## 参照
+- [P0586R2 Safe integral comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0586r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>処理系 -- Visual C++ : 2019 Update 7と8を追加</title>
      <link href="https://cpprefjp.github.io/implementation.html"/>
      <id>0fb2b6ee002a1aa7786dabd70137bf7899d999aa:implementation.md</id>
      <updated>2020-11-26T04:26:19+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;処理系&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GNU Compiler Collection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#icc&#34;&gt;Intel C++ Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;Microsoft Visual C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;本サイトにおける処理系バージョンに記載&lt;/h2&gt;
&lt;p&gt;本サイトのリファレンスページでは、「処理系」の項目にバージョン番号を記載している。これは、処理系がその機能をサポート開始した厳密なバージョンではなく、リファレンス執筆者が動作確認できたバージョンである。&lt;/p&gt;
&lt;p&gt;古くからサポートされている機能だが、古い処理系を入手することが難しい場合などがあるため、本サイトではこのようなルールになっている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34; id=&#34;clang&#34;&gt;Clang&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このサイトでは Clang と呼ぶ。「クラン(グ)」と読む。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://clang.llvm.org/&#34; target=&#34;_blank&#34;&gt;&#34;clang&#34; C Language Family Frontend for LLVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;別名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clang&lt;/li&gt;
&lt;li&gt;clang++&lt;/li&gt;
&lt;li&gt;Apple LLVMコンパイラ&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++11の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-std=c++11&lt;/code&gt;オプションを使用する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++14の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Clang 3.2から3.4までは、&lt;code&gt;-std=c++1y&lt;/code&gt;オプションを使用する。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++1y&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Clang 3.5以降は、&lt;code&gt;-std=c++14&lt;/code&gt;オプションを使用する(以前までのオプションも使用できる)。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++14&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Clang 6.0以降は、C++14がデフォルトとなる。デフォルトバージョンのコンパイルオプションは&lt;code&gt;-std=gnu++14&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++17の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Clang 3.5から4.0までは、&lt;code&gt;-std=c++1z&lt;/code&gt;オプションを使用する。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++1z&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Clang 5.0以降は、&lt;code&gt;-std=c++17&lt;/code&gt;オプションを使用する(以前までのオプションも使用できる)。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++17&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++20の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Clang 6.0以降は、&lt;code&gt;-std=c++2a&lt;/code&gt;オプションを使用する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34; id=&#34;gcc&#34;&gt;GNU Compiler Collection&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このサイトでは GCC と呼ぶ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gcc.gnu.org/&#34; target=&#34;_blank&#34;&gt;GCC, the GNU Compiler Collection - GNU Project - Free Software Foundation (FSF)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mingw.org/&#34; target=&#34;_blank&#34;&gt;MinGW | Minimalist GNU for Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.equation.com/servlet/equation.cmd?fa=fortran&#34; target=&#34;_blank&#34;&gt;Fortran, C, C++ for Windows&lt;/a&gt; (MinGW バイナリ)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;別名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;gcc&lt;/li&gt;
&lt;li&gt;g++&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++11の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;GCC 4.3から4.6までは、&lt;code&gt;-std=c++0x&lt;/code&gt;オプションを使用する。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++0x&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GCC 4.7以降は、&lt;code&gt;-std=c++11&lt;/code&gt;オプションを使用する (旧オプションは非推奨)。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++11&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++14の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;GCC 4.8から4.9までは、&lt;code&gt;-std=c++1y&lt;/code&gt;オプションを使用する。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++1y&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GCC 5.1以降は、&lt;code&gt;-std=c++14&lt;/code&gt;オプションを使用する (旧オプションは非推奨)。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++14&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GCC 6.1以降は、C++14がデフォルトとなる。デフォルトバージョンのコンパイルオプションは&lt;code&gt;-std=gnu++14&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++17の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;GCC 6.1以降は、&lt;code&gt;-std=c++1z&lt;/code&gt;オプションを使用する。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++1z&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GCC 7.1以降は、&lt;code&gt;-std=c++17&lt;/code&gt;オプションを使用する。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++17&lt;/code&gt;オプションもある (旧オプションは非推奨)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GCC 11.1以降は、C++17がデフォルトとなる。デフォルトバージョンのコンパイルオプションは&lt;code&gt;-std=gnu++17&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++20の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;GCC 8.1以降は、&lt;code&gt;-std=c++2a&lt;/code&gt;オプションを使用する。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++2a&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GCC 10.1以降は、&lt;code&gt;-std=c++20&lt;/code&gt;オプションを使用する。&lt;ul&gt;
&lt;li&gt;GNU拡張を有効にする&lt;code&gt;-std=gnu++20&lt;/code&gt;オプションもある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#icc&#34; id=&#34;icc&#34;&gt;Intel C++ Compiler&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このサイトでは ICC と呼ぶ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xlsoft.com/jp/products/intel/compilers/ccl/index.html?tab=0&#34; target=&#34;_blank&#34;&gt;XLsoft エクセルソフト : インテル C++ Composer XE Linux 版/インテル C++ コンパイラー XE Linux 版 製品紹介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xlsoft.com/jp/products/intel/compilers/ccl/index.html?tab=0&#34; target=&#34;_blank&#34;&gt;XLsoft エクセルソフト : インテル C++ Composer XE Mac OS 版/インテル C++ コンパイラー XE Mac OS 版 製品紹介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xlsoft.com/jp/products/intel/compilers/ccw/index.html?tab=0&#34; target=&#34;_blank&#34;&gt;XLsoft エクセルソフト : インテル C++ Composer XE Windows 版/インテル C++ コンパイラー XE Windows 版 製品紹介&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;別名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ICC&lt;/li&gt;
&lt;li&gt;ICL&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++11の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Windowsでは&lt;code&gt;/Qstd:c++11&lt;/code&gt;、Linux/macOSでは&lt;code&gt;-std=c++11&lt;/code&gt;オプションを使用する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++14の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ICC 16.0からは、Windowsでは&lt;code&gt;/Qstd:c++14&lt;/code&gt;オプション、Linux/macOSでは&lt;code&gt;-std=c++14&lt;/code&gt;オプションを使用する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++17の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ICC 17.0からは、Windowsでは&lt;code&gt;/Qstd:c++17&lt;/code&gt;オプション、Linux/macOSでは&lt;code&gt;-std=c++17&lt;/code&gt;オプションを使用する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34; id=&#34;visual_cpp&#34;&gt;Microsoft Visual C++&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このサイトでは Visual C++ と呼ぶ。Visual Studio 2012 以降、Visual C++は独立した製品名ではなくなり製品Visual Studioのみに含まれるようになったが、当サイトでは製品に含まれているコンポーネント名としてのVisual C++を採用する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.visualstudio.com/ja-jp/visual-studio-homepage-vs.aspx&#34; target=&#34;_blank&#34;&gt;Visual Studio - Microsoft Developer Tools&lt;/a&gt;: Visual C++を含む統合開発環境。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://visualstudio.microsoft.com/ja/downloads/&#34; target=&#34;_blank&#34;&gt;Build Tools for Visual Studio&lt;/a&gt;: コマンドラインのみからコンパイルするために必要な環境を構築するもの。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;別名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;VC&lt;/li&gt;
&lt;li&gt;VC++&lt;/li&gt;
&lt;li&gt;MSVC&lt;/li&gt;
&lt;li&gt;cl&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp_ver&#34; id=&#34;visual_cpp_ver&#34;&gt;バージョンの表記&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以下に当サイトにおけるバージョン表記と、製品・バージョン等の対応を示す。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表記&lt;/th&gt;
&lt;th&gt;製品名 [Visual Studio バージョン] &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note-t1-1&#34; id=&#34;note_ref-t1-1&#34;&gt;†1&lt;/a&gt;&lt;/sup&gt;&lt;/th&gt;
&lt;th&gt;VC++ バージョン &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note-t1-2&#34; id=&#34;note_ref-t1-2&#34;&gt;†2&lt;/a&gt;&lt;/sup&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;_MSC_VER&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;_MSC_FULL_VER&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2019 Update 8&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.8&lt;/td&gt;
&lt;td&gt;14.28&lt;/td&gt;
&lt;td&gt;1928&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.7&lt;/td&gt;
&lt;td&gt;14.27&lt;/td&gt;
&lt;td&gt;1927&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2019 Update 6&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.6.2&lt;/td&gt;
&lt;td&gt;14.26&lt;/td&gt;
&lt;td&gt;1926&lt;/td&gt;
&lt;td&gt;192628806&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.5.1&lt;/td&gt;
&lt;td&gt;14.25&lt;/td&gt;
&lt;td&gt;1925&lt;/td&gt;
&lt;td&gt;192528611&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2019 Update 4&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.4.0&lt;/td&gt;
&lt;td&gt;14.24&lt;/td&gt;
&lt;td&gt;1924&lt;/td&gt;
&lt;td&gt;192428314&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2019 Update 3&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.3.2&lt;/td&gt;
&lt;td&gt;14.23&lt;/td&gt;
&lt;td&gt;1923&lt;/td&gt;
&lt;td&gt;192328105&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2019 Update 2&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.2.3&lt;/td&gt;
&lt;td&gt;14.22&lt;/td&gt;
&lt;td&gt;1922&lt;/td&gt;
&lt;td&gt;192227905&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2019 Update 1&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.1.2&lt;/td&gt;
&lt;td&gt;14.21&lt;/td&gt;
&lt;td&gt;1921&lt;/td&gt;
&lt;td&gt;192127702&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2019&lt;/td&gt;
&lt;td&gt;Visual Studio 2019 バージョン 16.0.0&lt;/td&gt;
&lt;td&gt;14.20&lt;/td&gt;
&lt;td&gt;1920&lt;/td&gt;
&lt;td&gt;192027508&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 9&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.9.11&lt;/td&gt;
&lt;td&gt;14.16&lt;/td&gt;
&lt;td&gt;1916&lt;/td&gt;
&lt;td&gt;191627030&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 9&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.9.7&lt;/td&gt;
&lt;td&gt;14.16&lt;/td&gt;
&lt;td&gt;1916&lt;/td&gt;
&lt;td&gt;191627027&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 9&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.9.5&lt;/td&gt;
&lt;td&gt;14.16&lt;/td&gt;
&lt;td&gt;1916&lt;/td&gt;
&lt;td&gt;191627026&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 9&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.9.4&lt;/td&gt;
&lt;td&gt;14.16&lt;/td&gt;
&lt;td&gt;1916&lt;/td&gt;
&lt;td&gt;191627025&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 9&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.9.1&lt;/td&gt;
&lt;td&gt;14.16&lt;/td&gt;
&lt;td&gt;1916&lt;/td&gt;
&lt;td&gt;191627023&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 9&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.9.0&lt;/td&gt;
&lt;td&gt;14.16&lt;/td&gt;
&lt;td&gt;1916&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 8&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.8.0&lt;/td&gt;
&lt;td&gt;14.15&lt;/td&gt;
&lt;td&gt;1915&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.7.5&lt;/td&gt;
&lt;td&gt;14.14&lt;/td&gt;
&lt;td&gt;1914&lt;/td&gt;
&lt;td&gt;191426433&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.7.3&lt;/td&gt;
&lt;td&gt;14.14&lt;/td&gt;
&lt;td&gt;1914&lt;/td&gt;
&lt;td&gt;191426430&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.7.2&lt;/td&gt;
&lt;td&gt;14.14&lt;/td&gt;
&lt;td&gt;1914&lt;/td&gt;
&lt;td&gt;191426429&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.7.1&lt;/td&gt;
&lt;td&gt;14.14&lt;/td&gt;
&lt;td&gt;1914&lt;/td&gt;
&lt;td&gt;191426428&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 6&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.6.7&lt;/td&gt;
&lt;td&gt;14.13&lt;/td&gt;
&lt;td&gt;1913&lt;/td&gt;
&lt;td&gt;191326132&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 6&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.6.6&lt;/td&gt;
&lt;td&gt;14.13&lt;/td&gt;
&lt;td&gt;1913&lt;/td&gt;
&lt;td&gt;191326131&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 6&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.6.4&lt;/td&gt;
&lt;td&gt;14.13&lt;/td&gt;
&lt;td&gt;1913&lt;/td&gt;
&lt;td&gt;191326129&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 6&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.6.3&lt;/td&gt;
&lt;td&gt;14.13&lt;/td&gt;
&lt;td&gt;1913&lt;/td&gt;
&lt;td&gt;191326129&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 6&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.6.2&lt;/td&gt;
&lt;td&gt;14.13&lt;/td&gt;
&lt;td&gt;1913&lt;/td&gt;
&lt;td&gt;191326128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 6&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.6.1&lt;/td&gt;
&lt;td&gt;14.13&lt;/td&gt;
&lt;td&gt;1913&lt;/td&gt;
&lt;td&gt;191326128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 6&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.6.0&lt;/td&gt;
&lt;td&gt;14.13&lt;/td&gt;
&lt;td&gt;1913&lt;/td&gt;
&lt;td&gt;191326128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.5.7&lt;/td&gt;
&lt;td&gt;14.12&lt;/td&gt;
&lt;td&gt;1912&lt;/td&gt;
&lt;td&gt;191225835&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.5.6&lt;/td&gt;
&lt;td&gt;14.12&lt;/td&gt;
&lt;td&gt;1912&lt;/td&gt;
&lt;td&gt;191225835&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.5.4&lt;/td&gt;
&lt;td&gt;14.12&lt;/td&gt;
&lt;td&gt;1912&lt;/td&gt;
&lt;td&gt;191225834&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.5.3&lt;/td&gt;
&lt;td&gt;14.12&lt;/td&gt;
&lt;td&gt;1912&lt;/td&gt;
&lt;td&gt;191225834&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.5.2&lt;/td&gt;
&lt;td&gt;14.12&lt;/td&gt;
&lt;td&gt;1912&lt;/td&gt;
&lt;td&gt;191225831&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 4&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.4.5&lt;/td&gt;
&lt;td&gt;14.11&lt;/td&gt;
&lt;td&gt;1911&lt;/td&gt;
&lt;td&gt;191125547&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 4&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.4.4&lt;/td&gt;
&lt;td&gt;14.11&lt;/td&gt;
&lt;td&gt;1911&lt;/td&gt;
&lt;td&gt;191125542&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.3.3&lt;/td&gt;
&lt;td&gt;14.11&lt;/td&gt;
&lt;td&gt;1911&lt;/td&gt;
&lt;td&gt;191125507&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 2 &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note-t1-3&#34; id=&#34;note_ref-t1-3-a&#34;&gt;†3&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.2&lt;/td&gt;
&lt;td&gt;14.10&lt;/td&gt;
&lt;td&gt;1910&lt;/td&gt;
&lt;td&gt;191025017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017 Update 1 &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note-t1-3&#34; id=&#34;note_ref-t1-3-b&#34;&gt;†3&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.1&lt;/td&gt;
&lt;td&gt;14.10&lt;/td&gt;
&lt;td&gt;1910&lt;/td&gt;
&lt;td&gt;191025017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017&lt;/td&gt;
&lt;td&gt;Visual Studio 2017 バージョン 15.0&lt;/td&gt;
&lt;td&gt;14.10 &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note-t1-4&#34; id=&#34;note_ref-t1-4&#34;&gt;†4&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;1910&lt;/td&gt;
&lt;td&gt;191025017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2015 Update 3&lt;/td&gt;
&lt;td&gt;Visual Studio 2015 Update 3 [14.0]&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;1900&lt;/td&gt;
&lt;td&gt;190024210&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2015 Update 2&lt;/td&gt;
&lt;td&gt;Visual Studio 2015 Update 2 [14.0]&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;1900&lt;/td&gt;
&lt;td&gt;190023918&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2015 Update 1&lt;/td&gt;
&lt;td&gt;Visual Studio 2015 Update 1 [14.0]&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;1900&lt;/td&gt;
&lt;td&gt;190023506&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;td&gt;Visual Studio 2015          [14.0]&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;1900&lt;/td&gt;
&lt;td&gt;190023026&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2013 Update 5&lt;/td&gt;
&lt;td&gt;Visual Studio 2013 Update 5 [12.0]&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;1800&lt;/td&gt;
&lt;td&gt;180040629&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2013 Update 4&lt;/td&gt;
&lt;td&gt;Visual Studio 2013 Update 4 [12.0]&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;1800&lt;/td&gt;
&lt;td&gt;180031101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2013 Update 3&lt;/td&gt;
&lt;td&gt;Visual Studio 2013 Update 3 [12.0]&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;1800&lt;/td&gt;
&lt;td&gt;180030723&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2013 Update 2&lt;/td&gt;
&lt;td&gt;Visual Studio 2013 Update 2 [12.0]&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;1800&lt;/td&gt;
&lt;td&gt;180030501&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2013 Update 1 &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note-t1-3&#34; id=&#34;note_ref-t1-3-c&#34;&gt;†3&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;Visual Studio 2013 Update 1 [12.0]&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;1800&lt;/td&gt;
&lt;td&gt;180021005&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;td&gt;Visual Studio 2013          [12.0]&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;1800&lt;/td&gt;
&lt;td&gt;180021005&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2012 Update 4&lt;/td&gt;
&lt;td&gt;Visual Studio 2012 Update 4 [11.0]&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;1700&lt;/td&gt;
&lt;td&gt;170061030&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2012 Update 3&lt;/td&gt;
&lt;td&gt;Visual Studio 2012 Update 3 [11.0]&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;1700&lt;/td&gt;
&lt;td&gt;170060610&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2012 Update 2&lt;/td&gt;
&lt;td&gt;Visual Studio 2012 Update 2 [11.0]&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;1700&lt;/td&gt;
&lt;td&gt;170060315&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2012 Update 1&lt;/td&gt;
&lt;td&gt;Visual Studio 2012 Update 1 [11.0]&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;1700&lt;/td&gt;
&lt;td&gt;170051106&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2012&lt;/td&gt;
&lt;td&gt;Visual Studio 2012          [11.0]&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;1700&lt;/td&gt;
&lt;td&gt;170050727&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2010 SP1&lt;/td&gt;
&lt;td&gt;Visual Studio 2010 SP1      [10.0]&lt;br /&gt;Visual C++ 2010 SP1     [10.0]&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;td&gt;1600&lt;/td&gt;
&lt;td&gt;160040219&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2010&lt;/td&gt;
&lt;td&gt;Visual Studio 2010          [10.0]&lt;br /&gt;Visual C++ 2010         [10.0]&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;td&gt;1600&lt;/td&gt;
&lt;td&gt;160030319&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2008 SP1&lt;/td&gt;
&lt;td&gt;Visual Studio 2008 SP1      [9.0] &lt;br /&gt;Visual C++ 2008 SP1     [9.0]&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;1500&lt;/td&gt;
&lt;td&gt;150030729&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2008&lt;/td&gt;
&lt;td&gt;Visual Studio 2008          [9.0] &lt;br /&gt;Visual C++ 2008         [9.0]&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;1500&lt;/td&gt;
&lt;td&gt;150021022&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2005 SP1&lt;/td&gt;
&lt;td&gt;Visual Studio 2005 SP1      [8.0] &lt;br /&gt;Visual C++ 2005 SP1     [8.0]&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;1400&lt;/td&gt;
&lt;td&gt;140050727&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2005&lt;/td&gt;
&lt;td&gt;Visual Studio 2005          [8.0] &lt;br /&gt;Visual C++ 2005         [8.0]&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;1400&lt;/td&gt;
&lt;td&gt;140050320&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Windows Server 2003 SP1 DDK (for AMD64)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1400&lt;/td&gt;
&lt;td&gt;140040310&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2003 SP1&lt;/td&gt;
&lt;td&gt;Visual Studio .NET 2003 SP1 [7.1]&lt;br /&gt;Visual C++ .NET 2003 SP1 [7.1]&lt;/td&gt;
&lt;td&gt;7.1&lt;/td&gt;
&lt;td&gt;1310&lt;/td&gt;
&lt;td&gt;13106030&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Windows Server 2003 SP1 DDK&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1310&lt;/td&gt;
&lt;td&gt;13104035&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2003&lt;/td&gt;
&lt;td&gt;Visual Studio .NET 2003     [7.1]&lt;br /&gt;Visual C++ .NET 2003     [7.1]&lt;/td&gt;
&lt;td&gt;7.1&lt;/td&gt;
&lt;td&gt;1310&lt;/td&gt;
&lt;td&gt;13103077&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Visual Studio Toolkit 2003  [7.1]&lt;/td&gt;
&lt;td&gt;7.1&lt;/td&gt;
&lt;td&gt;1310&lt;/td&gt;
&lt;td&gt;13103052&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Windows Server 2003 DDK&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1310&lt;/td&gt;
&lt;td&gt;13102179&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2002&lt;/td&gt;
&lt;td&gt;Visual Studio .NET 2002     [7.0]&lt;br /&gt;Visual C++ .NET 2002     [7.0]&lt;/td&gt;
&lt;td&gt;7.0&lt;/td&gt;
&lt;td&gt;1300&lt;/td&gt;
&lt;td&gt;13009466&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Windows XP SP1 DDK&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1300&lt;/td&gt;
&lt;td&gt;13009176&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.0 SP6&lt;/td&gt;
&lt;td&gt;Visual Studio 6.0 SP6&lt;br /&gt;Visual C++ 6.0 SP6&lt;/td&gt;
&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;1200&lt;/td&gt;
&lt;td&gt;12008804&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.0 SP5&lt;/td&gt;
&lt;td&gt;Visual Studio 6.0 SP5&lt;br /&gt;Visual C++ 6.0 SP5&lt;/td&gt;
&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;1200&lt;/td&gt;
&lt;td&gt;12008804&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Visual Studio 97 [5.0]&lt;br /&gt;Visual C++ 5.0&lt;/td&gt;
&lt;td&gt;5.0&lt;/td&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Visual C++ 4.2&lt;/td&gt;
&lt;td&gt;4.2&lt;/td&gt;
&lt;td&gt;1020&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Visual C++ 4.1&lt;/td&gt;
&lt;td&gt;4.1&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Visual C++ 4.0&lt;/td&gt;
&lt;td&gt;4.0&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Visual C++ 2.0&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;900&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Visual C++ 1.0&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;800&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Microsoft C/C++ 7.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;700&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Microsoft C 6.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note_ref-t1-1&#34; id=&#34;note-t1-1&#34;&gt;^&lt;/a&gt;&lt;/strong&gt; 製品名の列にはVisual C++コンパイラを含む実際に入手する製品の名称を示す。製品のエディション (Express/Standard/Professional/Enterprise/Community 他) は省略する。Visual Studioの製品バージョンは、製品名に現れていないときは &lt;code&gt;[ ～ ]&lt;/code&gt; 内に記す。製品バージョンは、2017以降、メインメニューの [ヘルプ]-[Microsoft Visual Studio のバージョン情報] から確認できるものを指す。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note_ref-t1-2&#34; id=&#34;note-t1-2&#34;&gt;^&lt;/a&gt;&lt;/strong&gt; VC++バージョンの列にはVisual C++ツールセットのバージョンを記述する。この表では特にVisual C++を入れた時に既定で選択されるツールセットのみについて扱う。&lt;/li&gt;
&lt;li&gt;&lt;a id=&#34;note-t1-3&#34;&gt;^&lt;/a&gt; &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note_ref-t1-3-a&#34;&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/a&gt;&lt;/sup&gt; &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note_ref-t1-3-b&#34;&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/a&gt;&lt;/sup&gt; &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note_ref-t1-3-c&#34;&gt;&lt;strong&gt;c&lt;/strong&gt;&lt;/a&gt;&lt;/sup&gt; IDEのみ修正され、コンパイラ、ヘッダー、ライブラリ等は変更されなかった。&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/vcblog/2017/08/11/c17-features-and-stl-fixes-in-vs-2017-15-3/&#34; target=&#34;_blank&#34;&gt;C++17 Features And STL Fixes In VS 2017 15.3 | Visual C++ Team Blog&lt;/a&gt; - &#34;&lt;em&gt;After VS 2017 RTM, the 15.1 and 15.2 updates improved the IDE. The 15.3 update improves both the IDE and the toolset.&lt;/em&gt;&#34;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://support.microsoft.com/en-us/help/2911573/description-of-visual-studio-2013-update-1&#34; target=&#34;_blank&#34;&gt;Description of Visual Studio 2013 Update 1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#note_ref-t1-4&#34; id=&#34;note-t1-4&#34;&gt;^&lt;/a&gt;&lt;/strong&gt; 2017は2015とバイナリ互換が保たれているためメジャーバージョンアップは行われなかった。その結果、製品バージョンとVisual C++バージョンが一致しなくなった。
  &lt;a href=&#34;https://blogs.msdn.microsoft.com/vcblog/2017/03/07/binary-compatibility-and-pain-free-upgrade-why-moving-to-visual-studio-2017-is-almost-too-easy/&#34; target=&#34;_blank&#34;&gt;Binary Compatibility and Pain-free Upgrade: Why Moving to Visual Studio 2017 is almost “too easy”&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015以降、Visual Studioの既定のインストールではVisual C++は入らなくなった。Visual StudioのインストーラでVisual C++コンポーネントを選択する必要がある。
  &lt;a href=&#34;https://docs.microsoft.com/ja-JP/previous-versions/60k1461a(v=vs.140)?redirectedfrom=MSDN&#34; target=&#34;_blank&#34;&gt;Visual Studio 2015 の Visual C++&lt;/a&gt; の [警告] を参照。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;2017 Update 5からside-by-sideがサポートされ、一つの製品内で同時に複数のVisual C++ツールセットを選択できるようになった。
  &lt;a href=&#34;https://blogs.msdn.microsoft.com/vcblog/2017/11/15/side-by-side-minor-version-msvc-toolsets-in-visual-studio-2017/&#34; target=&#34;_blank&#34;&gt;Side-by-side minor version MSVC toolsets in Visual Studio 2017 | Visual C++ Team Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;C++11の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11は常に有効である&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++14の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++14は常に有効である&lt;/li&gt;
&lt;li&gt;2015 Update 3から&lt;code&gt;/std:c++14&lt;/code&gt;オプションが導入されたが既定値でありC++14を無効化する機能は提供されていない。&lt;code&gt;_MSVC_LANG&lt;/code&gt;マクロの値は&lt;code&gt;201402&lt;/code&gt;になる&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++17の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2015 Update 2以前に実装された機能については、互換性の観点から常に有効である&lt;/li&gt;
&lt;li&gt;2015 Update 3以降に実装された機能については、&lt;code&gt;/std:c++17&lt;/code&gt;オプションを使用する。&lt;code&gt;_MSVC_LANG&lt;/code&gt;マクロの値は&lt;code&gt;201703&lt;/code&gt;になる&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++20の機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2019以降に実行に実装された機能については、&lt;code&gt;/std:c++latest&lt;/code&gt;オプションを使用する&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;最新バージョンの言語機能を有効にする&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2015 Update 3以降は&lt;code&gt;/std:c++latest&lt;/code&gt;オプションを使用する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version&#34; target=&#34;_blank&#34;&gt;-std (Specify Language Standard Version) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros&#34; target=&#34;_blank&#34;&gt;Predefined Macros | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/vcblog/2016/06/07/standards-version-switches-in-the-compiler/&#34; target=&#34;_blank&#34;&gt;Standards version switches in the compiler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_exchange_strong -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/compare_exchange_strong.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/compare_exchange_strong.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/compare_exchange_strong.md b/reference/atomic/atomic/compare_exchange_strong.md
index 301f4d777..e11d0078f 100644
--- a/reference/atomic/atomic/compare_exchange_strong.md
+++ b/reference/atomic/atomic/compare_exchange_strong.md
@@ -10,21 +10,21 @@ bool compare_exchange_strong(T&amp;amp; expected,
                              T desired,
                              memory_order success,
                              memory_order failure
-                             ) volatile noexcept;  // (1)
+                             ) volatile noexcept;  // (1) C++11
 bool compare_exchange_strong(T&amp;amp; expected,
                              T desired,
                              memory_order success,
                              memory_order failure
-                             ) noexcept;           // (2)
+                             ) noexcept;           // (2) C++11
 
 bool compare_exchange_strong(T&amp;amp; expected,
                              T desired,
                              memory_order order = memory_order_seq_cst
-                             ) volatile noexcept;  // (3)
+                             ) volatile noexcept;  // (3) C++11
 bool compare_exchange_strong(T&amp;amp; expected,
                              T desired,
                              memory_order order = memory_order_seq_cst
-                             ) noexcept;           // (4)
+                             ) noexcept;           // (4) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -36,7 +36,12 @@ bool compare_exchange_strong(T&amp;amp; expected,
 - (3), (4) : 現在の値と`expected`が等値である場合に、現在の値を`desired`で置き換え、そうでなければ`expected`を現在の値で置き換える。どちらの値置き換えの場合でも`order`メモリオーダーが使用される
 
 
-## 要件
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 事前条件
 - `failure`が[`memory_order_release`](/reference/atomic/memory_order.md), [`memory_order_acq_rel`](/reference/atomic/memory_order.md)ではないこと
 
 
@@ -162,6 +167,10 @@ true
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [atomic compare_exchange_weak/strong関数 - yohhoyの日記](http://d.hatena.ne.jp/yohhoy/20120725/p1)
 - [N2748 Strong Compare and Exchange](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2748.html)
@@ -169,3 +178,5 @@ true
 - [What does &amp;#39;spurious failure&amp;#39; on a CAS mean? - StackOverflow](http://stackoverflow.com/q/355365/463412)
 - [“Strong” and “weak” hardware memory models - Sutter’s Mill](https://herbsutter.com/2012/08/02/strong-and-weak-hardware-memory-models/)
 - [Understand `std::atomic::compare_exchange_weak()` in C++11 - Eric Z&amp;#39;s blog](https://tonywearme.wordpress.com/2014/08/15/understand-stdatomiccompare_exchange_weak-in-c11/)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_exchange_weak -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/compare_exchange_weak.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/compare_exchange_weak.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/compare_exchange_weak.md b/reference/atomic/atomic/compare_exchange_weak.md
index ccb6edbba..cbbde0b05 100644
--- a/reference/atomic/atomic/compare_exchange_weak.md
+++ b/reference/atomic/atomic/compare_exchange_weak.md
@@ -10,21 +10,21 @@ bool compare_exchange_weak(T&amp;amp; expected,
                            T desired,
                            memory_order success,
                            memory_order failure
-                           ) volatile noexcept;  // (1)
+                           ) volatile noexcept;  // (1) C++11
 bool compare_exchange_weak(T&amp;amp; expected,
                            T desired,
                            memory_order success,
                            memory_order failure
-                           ) noexcept;           // (2)
+                           ) noexcept;           // (2) C++11
 
 bool compare_exchange_weak(T&amp;amp; expected,
                            T desired,
                            memory_order order = memory_order_seq_cst
-                           ) volatile noexcept;  // (3)
+                           ) volatile noexcept;  // (3) C++11
 bool compare_exchange_weak(T&amp;amp; expected,
                            T desired,
                            memory_order order = memory_order_seq_cst
-                           ) noexcept;           // (4)
+                           ) noexcept;           // (4) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -36,7 +36,12 @@ bool compare_exchange_weak(T&amp;amp; expected,
 - (3), (4) : 現在の値と`expected`が等値である場合に、現在の値を`desired`で置き換え、そうでなければ`expected`を現在の値で置き換える。どちらの値置き換えの場合でも`order`メモリオーダーが使用される
 
 
-## 要件
+## テンプレートパラメータ制約
+- (1), (3) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 事前条件
 - `failure`が[`memory_order_release`](/reference/atomic/memory_order.md), [`memory_order_acq_rel`](/reference/atomic/memory_order.md)ではないこと
 
 
@@ -187,6 +192,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [atomic compare_exchange_weak/strong関数 - yohhoyの日記](http://d.hatena.ne.jp/yohhoy/20120725/p1)
 - [N2748 Strong Compare and Exchange](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2748.html)
@@ -194,3 +203,5 @@ int main()
 - [What does &amp;#39;spurious failure&amp;#39; on a CAS mean? - StackOverflow](http://stackoverflow.com/q/355365/463412)
 - [“Strong” and “weak” hardware memory models - Sutter’s Mill](https://herbsutter.com/2012/08/02/strong-and-weak-hardware-memory-models/)
 - [Understand `std::atomic::compare_exchange_weak()` in C++11 - Eric Z&amp;#39;s blog](https://tonywearme.wordpress.com/2014/08/15/understand-stdatomiccompare_exchange_weak-in-c11/)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exchange -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/exchange.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/exchange.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/exchange.md b/reference/atomic/atomic/exchange.md
index 711816b98..6c70b364b 100644
--- a/reference/atomic/atomic/exchange.md
+++ b/reference/atomic/atomic/exchange.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T exchange(T desired, memory_order order = memory_order_seq_cst) volatile noexcept;
-T exchange(T desired, memory_order order = memory_order_seq_cst) noexcept;
+T exchange(T desired,
+           memory_order order = memory_order_seq_cst
+           ) volatile noexcept;                      // (1) C++11
+T exchange(T desired,
+           memory_order order = memory_order_seq_cst
+           ) noexcept;                               // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,6 +20,11 @@ T exchange(T desired, memory_order order = memory_order_seq_cst) noexcept;
 値を入れ替える
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 `order`で指定されたメモリオーダーにしたがって、現在の値を`desired`でアトミックに置き換える
 
@@ -65,6 +74,10 @@ replaced 1 by 2
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
-## 参照
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
 
 
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_add -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_add.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_add.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_add.md b/reference/atomic/atomic/fetch_add.md
index 0fddfa384..797396e86 100644
--- a/reference/atomic/atomic/fetch_add.md
+++ b/reference/atomic/atomic/fetch_add.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_add(difference_type operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_add(difference_type operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_add(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) volatile noexcept;                       // (1) C++11
+T fetch_add(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,8 +20,10 @@ T fetch_add(difference_type operand, memory_order order = memory_order_seq_cst)
 加算を行う
 
 
-## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+## テンプレートパラメータ制約
+- (1), (2) : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -136,5 +142,15 @@ int main()
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
+- [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
 - [P0020R6 Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)
+    - C++20での、浮動小数点数版の追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_and -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_and.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_and.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_and.md b/reference/atomic/atomic/fetch_and.md
index 8129ac1e5..82ca4710d 100644
--- a/reference/atomic/atomic/fetch_and.md
+++ b/reference/atomic/atomic/fetch_and.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_and(T operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_and(T operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_and(T operand,
+            memory_order order = memory_order_seq_cst
+            ) volatile noexcept;                       // (1) C++11
+T fetch_and(T operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,8 +20,11 @@ T fetch_and(T operand, memory_order order = memory_order_seq_cst) noexcept;
 AND演算を行う
 
 
-## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+## テンプレートパラメータ制約
+- (1), (2) :
+    - C++17 : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -115,5 +122,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_or -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_or.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_or.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_or.md b/reference/atomic/atomic/fetch_or.md
index 27869f7de..804dbcfd2 100644
--- a/reference/atomic/atomic/fetch_or.md
+++ b/reference/atomic/atomic/fetch_or.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_or(T operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_or(T operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_or(T operand,
+           memory_order order = memory_order_seq_cst
+           ) volatile noexcept;                      // (1) C++11
+T fetch_or(T operand,
+           memory_order order = memory_order_seq_cst
+           ) noexcept;                               // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,8 +20,11 @@ T fetch_or(T operand, memory_order order = memory_order_seq_cst) noexcept;
 OR演算を行う
 
 
-## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+## テンプレートパラメータ制約
+- (1), (2) :
+    - C++17 : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -115,5 +122,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_sub -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_sub.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_sub.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_sub.md b/reference/atomic/atomic/fetch_sub.md
index acba5bdb6..5ae73031c 100644
--- a/reference/atomic/atomic/fetch_sub.md
+++ b/reference/atomic/atomic/fetch_sub.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_sub(difference_type operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_sub(difference_type operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_sub(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) volatile noexcept;                       // (1) C++11
+T fetch_sub(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -17,7 +21,10 @@ T fetch_sub(difference_type operand, memory_order order = memory_order_seq_cst)
 
 
 ## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+- (1), (2) :
+    - C++17 : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -133,6 +140,14 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
 - [P0020R6 Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)
+    - C++20での、浮動小数点数版の追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_xor -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_xor.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_xor.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_xor.md b/reference/atomic/atomic/fetch_xor.md
index 41aedb508..55beb9a61 100644
--- a/reference/atomic/atomic/fetch_xor.md
+++ b/reference/atomic/atomic/fetch_xor.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_xor(T operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_xor(T operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_xor(T operand,
+            memory_order order = memory_order_seq_cst
+            ) volatile noexcept;                      // (1) C++11
+T fetch_xor(T operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                               // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -17,7 +21,10 @@ XOR演算を行う
 
 
 ## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+- (1), (2) :
+    - C++17 : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -117,5 +124,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>load -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/load.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/load.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/load.md b/reference/atomic/atomic/load.md
index b9ac82574..5696ea0bf 100644
--- a/reference/atomic/atomic/load.md
+++ b/reference/atomic/atomic/load.md
@@ -6,8 +6,10 @@
 * cpp11[meta cpp]
 
 ```cpp
-T load(memory_order order = memory_order_seq_cst) const volatile noexcept;
-T load(memory_order order = memory_order_seq_cst) const noexcept;
+T load(memory_order order = memory_order_seq_cst
+      ) const volatile noexcept;                 // (1) C++11
+T load(memory_order order = memory_order_seq_cst
+      ) const noexcept;                          // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,7 +18,12 @@ T load(memory_order order = memory_order_seq_cst) const noexcept;
 値を読み込む
 
 
-## 要件
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 事前条件
 `order`が以下のメモリオーダーではないこと：
 
 - [`memory_order_release`](/reference/atomic/memory_order.md)
@@ -68,6 +75,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
-## 参照
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
 
 
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_all -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/notify_all.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/notify_all.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/notify_all.md b/reference/atomic/atomic/notify_all.md
index 3dcd23f01..c25cd96ba 100644
--- a/reference/atomic/atomic/notify_all.md
+++ b/reference/atomic/atomic/notify_all.md
@@ -6,8 +6,8 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_all() volatile noexcept;
-void notify_all() noexcept;
+void notify_all() volatile noexcept; // (1) C++20
+void notify_all() noexcept;          // (2) C++20
 ```
 
 ## 概要
@@ -16,6 +16,11 @@ void notify_all() noexcept;
 この関数は、[`wait()`](wait.md)関数によるブロッキング待機を解除する。
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 起床待機している全てのアトミックオブジェクトの待機を解除する
 
@@ -77,6 +82,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): (2019 Update 3時点で実装なし)
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_one -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/notify_one.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/notify_one.md b/reference/atomic/atomic/notify_one.md
index 7fce75cb6..28029f4a5 100644
--- a/reference/atomic/atomic/notify_one.md
+++ b/reference/atomic/atomic/notify_one.md
@@ -6,8 +6,8 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_one() volatile noexcept;
-void notify_one() noexcept;
+void notify_one() volatile noexcept; // (1) C++20
+void notify_one() noexcept;          // (2) C++20
 ```
 
 ## 概要
@@ -16,6 +16,11 @@ void notify_one() noexcept;
 この関数は、[`wait()`](wait.md)関数によるブロッキング待機を解除する。
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 起床待機している少なくともひとつのアトミックオブジェクトの待機を解除する
 
@@ -103,6 +108,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): (2019 Update 3時点で実装なし)
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&amp;= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_and_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_and_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_and_assign.md b/reference/atomic/atomic/op_and_assign.md
index d6c6ec0a3..f4df9f3a5 100644
--- a/reference/atomic/atomic/op_and_assign.md
+++ b/reference/atomic/atomic/op_and_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator&amp;amp;=(T operand) volatile noexcept;
-T operator&amp;amp;=(T operand) noexcept;
+T operator&amp;amp;=(T operand) volatile noexcept; // (1) C++11
+T operator&amp;amp;=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 AND演算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -109,3 +114,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_assign.md b/reference/atomic/atomic/op_assign.md
index c06c0716a..e46cf78c8 100644
--- a/reference/atomic/atomic/op_assign.md
+++ b/reference/atomic/atomic/op_assign.md
@@ -6,17 +6,22 @@
 * cpp11[meta cpp]
 
 ```cpp
-atomic&amp;amp; operator=(const atomic&amp;amp;) = delete;
-atomic&amp;amp; operator=(const atomic&amp;amp;) volatile = delete;
+atomic&amp;amp; operator=(const atomic&amp;amp;) = delete;          // (1) C++11
+atomic&amp;amp; operator=(const atomic&amp;amp;) volatile = delete; // (2) C++11
 
-T operator=(T desired) volatile noexcept;
-T operator=(T desired) noexcept;
+T operator=(T desired) volatile noexcept;           // (3) C++11
+T operator=(T desired) noexcept;                    // (4) C++11
 ```
 
 ## 概要
 値を書き込む
 
 
+## テンプレートパラメータ制約
+- (3) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 [`store`](/reference/atomic/atomic/store.md)`(desired)`
 
@@ -62,9 +67,13 @@ int main()
 - [GCC](/implementation.md#gcc): 4.7.0
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
-	- 2012はコピー代入演算子のdeleteに対応していないため、代わりにprivateで宣言のみ行う手法で代用されている。
+    - 2012はコピー代入演算子のdeleteに対応していないため、代わりにprivateで宣言のみ行う手法で代用されている。
 
 
-## 参照
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
 
 
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-- -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_decrement.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_decrement.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_decrement.md b/reference/atomic/atomic/op_decrement.md
index d36840698..001c00659 100644
--- a/reference/atomic/atomic/op_decrement.md
+++ b/reference/atomic/atomic/op_decrement.md
@@ -6,21 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator--() volatile noexcept;
-T operator--() noexcept;
-T operator--(int) volatile noexcept;
-T operator--(int) noexcept;
+T operator--() volatile noexcept;    // (1) C++11
+T operator--() noexcept;             // (2) C++11
+
+T operator--(int) volatile noexcept; // (3) C++11
+T operator--(int) noexcept;          // (4) C++11
 ```
 
 ## 概要
-値をデクリメントする
+値をデクリメントする。
+
+- (1) : `volatile`オブジェクトに対する前置デクリメント
+- (2) : 非`volatile`オブジェクトに対する前置デクリメント
+- (3) : `volatile`オブジェクトに対する後置デクリメント
+- (4) : 非`volatile`オブジェクトに対する後置デクリメント
+
+
+## テンプレートパラメータ制約
+- (1), (3) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 戻り値
 以下と等価：
 
-- 前置`operator--`： [`fetch_sub`](fetch_sub.md)`(1) - 1`
-- 後置`operator--`： [`fetch_sub`](fetch_sub.md)`(1)`
+- (1), (2) : [`fetch_sub`](fetch_sub.md)`(1) - 1`
+- (3), (4) : [`fetch_sub`](fetch_sub.md)`(1)`
 
 
 ## 例外
@@ -95,3 +106,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator++ -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_increment.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_increment.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_increment.md b/reference/atomic/atomic/op_increment.md
index d5e162d30..8494218c2 100644
--- a/reference/atomic/atomic/op_increment.md
+++ b/reference/atomic/atomic/op_increment.md
@@ -6,22 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator++() volatile noexcept;
-T operator++() noexcept;
+T operator++() volatile noexcept;    // (1) C++11
+T operator++() noexcept;             // (2) C++11
 
-T operator++(int) volatile noexcept;
-T operator++(int) noexcept;
+T operator++(int) volatile noexcept; // (3) C++11
+T operator++(int) noexcept;          // (4) C++11
 ```
 
 ## 概要
-値をインクリメントする
+値をインクリメントする。
+
+- (1) : `volatile`オブジェクトに対する前置インクリメント
+- (2) : 非`volatile`オブジェクトに対する前置インクリメント
+- (3) : `volatile`オブジェクトに対する後置インクリメント
+- (4) : 非`volatile`オブジェクトに対する後置インクリメント
+
+
+## テンプレートパラメータ制約
+- (1), (3) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 戻り値
 以下と等価：
 
-- 前置`operator++`：[`fetch_add`](fetch_add.md)`(1) + 1`
-- 後置`operator++`：[`fetch_add`](fetch_add.md)`(1)`
+- (1), (2) : [`fetch_add`](fetch_add.md)`(1) + 1`
+- (3), (4) : [`fetch_add`](fetch_add.md)`(1)`
 
 
 ## 例外
@@ -99,3 +109,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_minus_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_minus_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_minus_assign.md b/reference/atomic/atomic/op_minus_assign.md
index 32d9b296a..13cd1d67c 100644
--- a/reference/atomic/atomic/op_minus_assign.md
+++ b/reference/atomic/atomic/op_minus_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator-=(T operand) volatile noexcept;
-T operator-=(T operand) noexcept;
+T operator-=(T operand) volatile noexcept; // (1) C++11
+T operator-=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 加算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -130,5 +135,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0020R6 Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)
+    - C++20での、浮動小数点数版の追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator|= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_or_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_or_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_or_assign.md b/reference/atomic/atomic/op_or_assign.md
index 6a23da19d..ccc8c3da6 100644
--- a/reference/atomic/atomic/op_or_assign.md
+++ b/reference/atomic/atomic/op_or_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator|=(T operand) volatile noexcept;
-T operator|=(T operand) noexcept;
+T operator|=(T operand) volatile noexcept; // (1) C++11
+T operator|=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 OR演算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -110,3 +115,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_plus_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_plus_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_plus_assign.md b/reference/atomic/atomic/op_plus_assign.md
index a42590f08..8ff774824 100644
--- a/reference/atomic/atomic/op_plus_assign.md
+++ b/reference/atomic/atomic/op_plus_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator+=(T operand) volatile noexcept;
-T operator+=(T operand) noexcept;
+T operator+=(T operand) volatile noexcept; // (1) C++11
+T operator+=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 加算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -128,5 +133,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0020R6 Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)
+    - C++20での、浮動小数点数版の追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator T -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_t.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_t.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_t.md b/reference/atomic/atomic/op_t.md
index 4afe6a3ba..80d7f87b0 100644
--- a/reference/atomic/atomic/op_t.md
+++ b/reference/atomic/atomic/op_t.md
@@ -6,17 +6,23 @@
 * cpp11[meta cpp]
 
 ```cpp
-operator T() const volatile noexcept;
-operator T() const noexcept;
+operator T() const volatile noexcept; // (1) C++11
+operator T() const noexcept;          // (2) C++11
 ```
 
 ## 概要
 型`T`への暗黙の型変換
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 [`load()`](load.md)
 
+
 ## 例外
 投げない
 
@@ -51,6 +57,12 @@ int main()
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [N2514 Implicit Conversion Operators for Atomics](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2514.html)
-
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator^= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_xor_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_xor_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_xor_assign.md b/reference/atomic/atomic/op_xor_assign.md
index 40dcad417..fc3e8630d 100644
--- a/reference/atomic/atomic/op_xor_assign.md
+++ b/reference/atomic/atomic/op_xor_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator^=(T operand) volatile noexcept;
-T operator^=(T operand) noexcept;
+T operator^=(T operand) volatile noexcept; // (1) C++11
+T operator^=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 XOR演算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -112,3 +117,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>store -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/store.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/store.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/store.md b/reference/atomic/atomic/store.md
index c1f464255..89da0aed0 100644
--- a/reference/atomic/atomic/store.md
+++ b/reference/atomic/atomic/store.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-void store(T desired, memory_order order = memory_order_seq_cst) volatile noexcept;
-void store(T desired, memory_order order = memory_order_seq_cst) noexcept;
+void store(T desired,
+           memory_order order = memory_order_seq_cst
+           ) volatile noexcept;                      // (1) C++11
+void store(T desired,
+           memory_order order = memory_order_seq_cst
+           ) noexcept;                               // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,13 +20,19 @@ void store(T desired, memory_order order = memory_order_seq_cst) noexcept;
 値を書き込む
 
 
-## 要件
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 事前条件
 `order`が以下のメモリオーダーではないこと：
 
 - [`memory_order_consume`](/reference/atomic/memory_order.md)
 - [`memory_order_acquire`](/reference/atomic/memory_order.md)
 - [`memory_order_acq_rel`](/reference/atomic/memory_order.md)
 
+
 ## 効果
 `order`で指定されたメモリオーダーにしたがって、現在の値を`desired`でアトミックに置き換える。
 この関数は、戻り値のない[`exchange()`](exchange.md)と見なせる。
@@ -70,6 +80,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
-## 参照
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
 
 
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/wait.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/wait.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/wait.md b/reference/atomic/atomic/wait.md
index 06bfe2b91..77dbc1205 100644
--- a/reference/atomic/atomic/wait.md
+++ b/reference/atomic/atomic/wait.md
@@ -6,8 +6,12 @@
 * cpp20[meta cpp]
 
 ```cpp
-void wait(T old, memory_order order = memory_order::seq_cst) const volatile noexcept;
-void wait(T old, memory_order order = memory_order::seq_cst) const noexcept;
+void wait(T old,
+          memory_order order = memory_order::seq_cst
+          ) const volatile noexcept;                 // (1) C++20
+void wait(T old,
+          memory_order order = memory_order::seq_cst
+          ) const noexcept;                          // (2) C++20
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
@@ -19,6 +23,11 @@ void wait(T old, memory_order order = memory_order::seq_cst) const noexcept;
 この関数によってブロッキング待機をしたら、対応する起床関数である[`notify_one()`](notify_one.md)、[`notify_all()`](notify_all.md)によってブロッキング待機を解除できる。
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 - 以下のステップを順に繰り返し実行する：
     - [`load`](load.md)`(order)`によって現在の値を読み込み、`old`と値を比較する
@@ -114,6 +123,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): (2019 Update 3時点で実装なし)
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dynamic_pointer_cast -- fix(dynamic_pointer_cast): virtual destructor will be required</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html"/>
      <id>841eb4872eeff75942f55dc7b524968a768c624c:reference/memory/shared_ptr/dynamic_pointer_cast.md</id>
      <updated>2020-11-26T00:30:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/dynamic_pointer_cast.md b/reference/memory/shared_ptr/dynamic_pointer_cast.md
index 8f442b9e1..aa1c77dff 100644
--- a/reference/memory/shared_ptr/dynamic_pointer_cast.md
+++ b/reference/memory/shared_ptr/dynamic_pointer_cast.md
@@ -51,10 +51,11 @@ struct A {
   virtual void call() const {
     std::cout &amp;lt;&amp;lt; &amp;#34;A::call&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
+  virtual ~A() = default;
 };
 
 struct B : A {
-  void call() const {
+  void call() const override {
     std::cout &amp;lt;&amp;lt; &amp;#34;B::call()&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>variant_alternative -- variant_size, variant_alternative : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant_alternative.html"/>
      <id>fb2a6a91cfbb622788c45e2c8d02c89022045145:reference/variant/variant_alternative.md</id>
      <updated>2020-11-25T18:14:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant_alternative.md b/reference/variant/variant_alternative.md
index 7c38bb42a..5d3e11d5d 100644
--- a/reference/variant/variant_alternative.md
+++ b/reference/variant/variant_alternative.md
@@ -7,23 +7,25 @@
 ```cpp
 namespace std {
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative;                       // (1) 先行宣言
+  struct variant_alternative;                       // (1) C++17 先行宣言
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, const T&amp;gt;;           // (2)
+  struct variant_alternative&amp;lt;I, const T&amp;gt;;           // (2) C++17
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, volatile T&amp;gt;;        // (3)
+  struct variant_alternative&amp;lt;I, volatile T&amp;gt;;        // (3) C++17
+                                                    // C++20で非推奨
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, const volatile T&amp;gt;;  // (4)
+  struct variant_alternative&amp;lt;I, const volatile T&amp;gt;;  // (4) C++17
+                                                    // C++20で非推奨
 
   template &amp;lt;std::size_t I, class T&amp;gt;
   using variant_alternative_t =
-    typename variant_alternative&amp;lt;I, T&amp;gt;::type;       // (5)
+    typename variant_alternative&amp;lt;I, T&amp;gt;::type;       // (5) C++17
 
   template &amp;lt;std::size_t I, class... Types&amp;gt;
-  struct variant_alternative&amp;lt;I, variant&amp;lt;Types...&amp;gt;&amp;gt;; // (6)
+  struct variant_alternative&amp;lt;I, variant&amp;lt;Types...&amp;gt;&amp;gt;; // (6) C++17
 }
 ```
 * variant[link variant.md]
@@ -50,6 +52,10 @@ namespace std {
 - (6) : `std::variant&amp;lt;Types...&amp;gt;`の`Types...`のうち、`I`番目の型`T`を取得し、その型をメンバ型`type`とする
 
 
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
+
+
 ## 例
 ```cpp example
 #include &amp;lt;variant&amp;gt;
@@ -120,3 +126,11 @@ int main()
 - [Clang](/implementation.md#clang): 4.0
 - [GCC](/implementation.md#gcc): 7.3
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>variant_size -- variant_size, variant_alternative : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant_size.html"/>
      <id>fb2a6a91cfbb622788c45e2c8d02c89022045145:reference/variant/variant_size.md</id>
      <updated>2020-11-25T18:14:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant_size.md b/reference/variant/variant_size.md
index d21b0cb71..47ffda0ab 100644
--- a/reference/variant/variant_size.md
+++ b/reference/variant/variant_size.md
@@ -6,19 +6,27 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class T&amp;gt; struct variant_size;                   // (1) 先行宣言
+  template &amp;lt;class T&amp;gt;
+  struct variant_size;                   // (1) C++17 先行宣言
 
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;const T&amp;gt;;          // (2)
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;volatile T&amp;gt;;       // (3)
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;const volatile T&amp;gt;; // (4)
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;const T&amp;gt;;          // (2) C++17
+
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;volatile T&amp;gt;;       // (3) C++17
+                                         // C++20で非推奨
+
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;const volatile T&amp;gt;; // (4) C++17
+                                         // C++20で非推奨
 
   template &amp;lt;class T&amp;gt;
   inline constexpr size_t variant_size_v
-    = variant_size&amp;lt;T&amp;gt;::value;                               // (5)
+    = variant_size&amp;lt;T&amp;gt;::value;            // (5) C++17
 
   template&amp;lt;class... Types&amp;gt;
   struct variant_size&amp;lt;variant&amp;lt;Types...&amp;gt;&amp;gt;
-    : integral_constant&amp;lt;std::size_t, sizeof...(Types)&amp;gt; {};  // (6)
+    : integral_constant&amp;lt;std::size_t, sizeof...(Types)&amp;gt; {}; // (6) C++17
 }
 ```
 * variant[link variant.md]
@@ -38,6 +46,10 @@ namespace std {
 - (6) : 修飾なしの[`std::variant`](variant.md)型の、候補型の数を取得する
 
 
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
+
+
 ## 例
 ```cpp example
 #include &amp;lt;variant&amp;gt;
@@ -55,16 +67,6 @@ int main()
     const std::variant&amp;lt;int, std::string, double&amp;gt;
   &amp;gt;::value == 3);
 
-  // (3) volatile修飾付きのstd::variant型の、候補型の数を取得する
-  static_assert(std::variant_size&amp;lt;
-    volatile std::variant&amp;lt;int, std::string, double&amp;gt;
-  &amp;gt;::value == 3);
-
-  // (4) const volatile修飾付きのstd::variant型の、候補型の数を取得する
-  static_assert(std::variant_size&amp;lt;
-    const volatile std::variant&amp;lt;int, std::string, double&amp;gt;
-  &amp;gt;::value == 3);
-
   // (5) 変数テンプレート版
   static_assert(std::variant_size_v&amp;lt;
     std::variant&amp;lt;int, std::string, double&amp;gt;
@@ -87,3 +89,11 @@ int main()
 - [Clang](/implementation.md#clang): 4.0
 - [GCC](/implementation.md#gcc): 7.3
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>