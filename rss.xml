<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-07-17T05:42:40.863979</updated>
  <id>1d36ff7b-1315-43fc-b0cc-7d04f95d1881</id>

  
    <entry>
      <title>triangular_matrix_matrix_left_solve -- linalg : 例を修正 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/triangular_matrix_matrix_left_solve.html"/>
      <id>c84c78865ce78853654b463989873ec034c97296:reference/linalg/triangular_matrix_matrix_left_solve.md</id>
      <updated>2024-07-17T14:39:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/triangular_matrix_matrix_left_solve.md b/reference/linalg/triangular_matrix_matrix_left_solve.md
index 89c1074e8..f8c68987a 100644
--- a/reference/linalg/triangular_matrix_matrix_left_solve.md
+++ b/reference/linalg/triangular_matrix_matrix_left_solve.md
@@ -138,10 +138,10 @@ void print_mat(const Matrix&amp;amp; A) {
 }
 
 template &amp;lt;class Matrix&amp;gt;
-void init_mat(Matrix&amp;amp; A, typename Matrix::value_type geta = 1) {
+void init_mat(Matrix&amp;amp; A) {
   for(int i = 0; i &amp;lt; A.extent(0); ++i) {
     for(int j = 0; j &amp;lt; A.extent(1); ++j) {
-      A[i, j] = i * A.extent(1) + j + geta;
+      A[i, j] = i * A.extent(1) + j;
     }
   }
 }
@@ -173,7 +173,7 @@ int main()
   std::mdspan X(X_vec.data(), N, N);
   std::mdspan B(B_vec.data(), N, N);
 
-  init_mat(A)
+  init_tria_mat(A);
   init_mat(B);
 
   // (1)
@@ -197,7 +197,7 @@ int main()
     B,
     X,
     std::divides&amp;lt;void&amp;gt;{});
-  print(X);
+  print_mat(X);
 
   // (3)
   std::cout &amp;lt;&amp;lt; &amp;#34;(3)\n&amp;#34;;
@@ -207,7 +207,7 @@ int main()
     std::linalg::implicit_unit_diagonal,
     B,
     X);
-  print(X);
+  print_mat(X);
 
   // (4)
   std::cout &amp;lt;&amp;lt; &amp;#34;(4)\n&amp;#34;;
@@ -218,13 +218,12 @@ int main()
     std::linalg::implicit_unit_diagonal,
     B,
     X);
-  print(X);
+  print_mat(X);
 
   return 0;
 }
 ```
 * A.extent[link /reference/mdspan/extents/extent.md]
-* v.extent[link /reference/mdspan/extents/extent.md]
 * std::mdspan[link /reference/mdspan/mdspan.md]
 * std::extents[link /reference/mdspan/extents.md]
 * std::linalg::layout_blas_packed[link /reference/linalg/layout_blas_packed.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>triangular_matrix_vector_solve -- linalg : fix typo. (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/triangular_matrix_vector_solve.html"/>
      <id>fe869d5b73f73b4743bd7df6c91772a8eef3746b:reference/linalg/triangular_matrix_vector_solve.md</id>
      <updated>2024-07-17T14:31:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/triangular_matrix_vector_solve.md b/reference/linalg/triangular_matrix_vector_solve.md
index d4c71663b..b587f9ad5 100644
--- a/reference/linalg/triangular_matrix_vector_solve.md
+++ b/reference/linalg/triangular_matrix_vector_solve.md
@@ -125,11 +125,11 @@ namespace std::linalg {
 
 - (1): 連立一次方程式 $Ay = b$ を解き、`y`を`x`に代入する。もし解が存在しないなら、`x`は有効だが未規定。
 - (2): (1)を指定された実行ポリシーで実行する。
-- (3): 割り算に[`std::divedes`](/reference/functional/divides.md)`&amp;lt;void&amp;gt;`を用いて、(1)を行う。
+- (3): 割り算に[`std::divides`](/reference/functional/divides.md)`&amp;lt;void&amp;gt;`を用いて、(1)を行う。
 - (4): (3)を指定された実行ポリシーで実行する。
 - (5): `x`に`b`を使って、in-placeに(1)を行う。
 - (6): (5)を指定された実行ポリシーで実行する。
-- (7): 割り算に[`std::divedes`](/reference/functional/divides.md)`&amp;lt;void&amp;gt;`を用いて、(5)を行う。
+- (7): 割り算に[`std::divides`](/reference/functional/divides.md)`&amp;lt;void&amp;gt;`を用いて、(5)を行う。
 - (8): (7)を指定された実行ポリシーで実行する。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>linalg -- linalg : triangular_matrix_matrix_left_solveを追加 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg.html"/>
      <id>dae7d3d3ac1b7babdf79a975931548f08dba78ba:reference/linalg.md</id>
      <updated>2024-07-17T14:31:13+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;linalg&lt;/span&gt;&lt;span class=&#34;cpp cpp26&#34; title=&#34;C++26で追加&#34;&gt;(C++26)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダでは、線形代数(linear algebra)に関する基礎的な演算アルゴリズムを提供する。
ベクトルや行列の成分にアクセスするアルゴリズムは、多次元配列ビュー&lt;a href=&#34;mdspan/mdspan.html&#34;&gt; &lt;code&gt;std::mdspan&lt;/code&gt; &lt;/a&gt;を通してその要素にアクセスする。
本ヘッダが提供するエンティティは、すべて名前空間&lt;code&gt;std::linalg&lt;/code&gt;に属する。&lt;/p&gt;
&lt;p&gt;1次元データであるベクトル(vector)や2次元データである行列(matrix)に対して、線形代数分野のデファクトスタンダードとされる BLAS(Basic Linear Algebra Subprograms) 互換のアルゴリズム群、いくつかの LAPACK(Linear Algebra PACKage) 互換のアルゴリズムが提供される。
BLAS互換アルゴリズムは、演算対象データの次元数や計算オーダーに応じて3段階に区分される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Level 1 BLAS : ベクトルーベクトルの演算&lt;/li&gt;
&lt;li&gt;Level 2 BLAS : 行列ーベクトルの演算&lt;/li&gt;
&lt;li&gt;Level 3 BLAS : 行列ー行列の演算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例えば、2個の一般行列の積を求める&lt;code&gt;std::linalg::matrix_product&lt;/code&gt;はLevel 3 BLASルーチン&lt;code&gt;xGEMM&lt;/code&gt;に対応する。
（実際のBLASルーチン名は、浮動小数点数型の単精度&lt;code&gt;S&lt;/code&gt;／倍精度&lt;code&gt;D&lt;/code&gt;とそれぞれの複素数版&lt;code&gt;C&lt;/code&gt;,&lt;code&gt;Z&lt;/code&gt;として、プレフィックス&lt;code&gt;x&lt;/code&gt;部は文字4種類のいずれか。）&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;std::mdspan&lt;/code&gt;と組み合わせて利用する拡張機能が提供される。&lt;/p&gt;
&lt;h2&gt;共通要件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダが提供する演算アルゴリズムは、スカラ値およびベクトル／行列の要素型として線形代数値型(linear algebra value types)を取り扱う。&lt;/p&gt;
&lt;p&gt;線形代数値型はBLASが取り扱う&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;をはじめ、&lt;code&gt;&lt;a href=&#34;concepts/semiregular.html&#34;&gt;semiregular&lt;/a&gt;&lt;/code&gt;のモデルであれば良い。
また、線形代数値型の値初期化は加法元（算術型であれば値&lt;code&gt;0&lt;/code&gt;）であること。&lt;/p&gt;
&lt;p&gt;プログラム定義型を利用する場合、演算アルゴリズムはカスタマイゼーションポイントとして&lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;imag&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;を非修飾名で呼び出す。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;std::mdspan&lt;/code&gt;向け機能拡張&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/layout_blas_packed.html&#34;&gt;layout_blas_packed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列要素のBLAS互換パックレイアウトに対応する&lt;a href=&#34;mdspan/LayoutMappingPolicy.html&#34;&gt;レイアウトマッピングポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/scaled_accessor.html&#34;&gt;scaled_accessor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scaled&lt;/code&gt;関数用の&lt;a href=&#34;mdspan/AccessorPolicy.html&#34;&gt;アクセサポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/scaled.html&#34;&gt;scaled&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素値をスカラー倍した読み取り専用&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/conjugated_accessor.html&#34;&gt;conjugated_accessor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;conjugated&lt;/code&gt;関数用の&lt;a href=&#34;mdspan/AccessorPolicy.html&#34;&gt;アクセサポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/conjugated.html&#34;&gt;conjugated&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取り専用の複素共役ビュー&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/layout_transpose.html&#34;&gt;layout_transpose&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;transposed&lt;/code&gt;関数用の&lt;a href=&#34;mdspan/LayoutMappingPolicy.html&#34;&gt;レイアウトマッピングポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/transposed.html&#34;&gt;transposed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2次元&lt;code&gt;std::mdspan&lt;/code&gt;の行列転置ビューを作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/conjugate_transposed.html&#34;&gt;conjugate_transposed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取り専用の複素共役転置ビュー&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLASの要件&lt;/h2&gt;
&lt;p&gt;BLAS 1, 2, 3のアルゴリズムでテンプレートパラメータが特に制約されていない場合、テンプレートパラメータの名前によって以下の制約を満たすとする。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;制約&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ExecutionPolicy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;is_execution_policy&amp;lt;ExecutionPolicy&amp;gt;::value == true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;complex&amp;lt;Real&amp;gt;&lt;/code&gt;が規定できる型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Triangle&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;upper_triangle_t&lt;/code&gt;または&lt;code&gt;lower_triangle_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DiagonalStorage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;implicit_unit_diagonal_t&lt;/code&gt;または&lt;code&gt;explicit_diagonal_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 1アルゴリズム&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;std::mpspan&lt;/code&gt;をパラメータに持つ、この節の全てのアルゴリズムの計算量は渡された&lt;code&gt;std::mdspan&lt;/code&gt;の&lt;code&gt;extents&lt;/code&gt;の積の最大値、つまりベクトルや行列の要素数の最大値に線形である。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/setup_givens_rotation_result.html&#34;&gt;setup_givens_rotation_result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;setup_givens_rotation&lt;/code&gt;の結果型 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/setup_givens_rotation.html&#34;&gt;setup_givens_rotation&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xLARTG: ギブンス回転をセットアップする (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/apply_givens_rotation.html&#34;&gt;apply_givens_rotation&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xROT: ベクトルにギブンス回転を適用する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/swap_elements.html&#34;&gt;swap_elements&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSWAP: 2つのベクトル／行列の要素を交換する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/scale.html&#34;&gt;scale&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSCAL: ベクトル／行列の要素にスカラ値を乗算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/copy.html&#34;&gt;copy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xCOPY: ベクトル／行列の要素をコピーする (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/add.html&#34;&gt;add&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xAXPY: 2つのベクトル／行列の要素を加算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/dot.html&#34;&gt;dot&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xDOT, xDOTU: 2つのベクトルのドット積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/dotc.html&#34;&gt;dotc&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xDOTC: 2つのベクトルの複素共役ドット積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/sum_of_squares_result.html&#34;&gt;sum_of_squares_result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector_sum_of_squares&lt;/code&gt;の結果型 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/vector_sum_of_squares.html&#34;&gt;vector_sum_of_squares&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xLASSQ: ベクトル要素の平方和を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/vector_two_norm.html&#34;&gt;vector_two_norm&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xNRM2: ベクトルのユークリッドノルム(Euclidean norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/vector_abs_sum.html&#34;&gt;vector_abs_sum&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xASUM: ベクトル要素の絶対値和を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/vector_idx_abs_max.html&#34;&gt;vector_idx_abs_max&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xIAMAX: ベクトル要素のうち最大絶対値インデクスを返す (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_frob_norm.html&#34;&gt;matrix_frob_norm&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列のフロベニウスノルム(Frobenius norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_one_norm.html&#34;&gt;matrix_one_norm&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列の1ノルム(One norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_inf_norm.html&#34;&gt;matrix_inf_norm&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列の無限大ノルム(Infinity norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 2アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_vector_product.html&#34;&gt;matrix_vector_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGEMV: 一般行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/symmetric_matrix_vector_product.html&#34;&gt;symmetric_matrix_vector_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYMV: 対称行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/hermitian_matrix_vector_product.html&#34;&gt;hermitian_matrix_vector_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHEMV: ハミルトニアン行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/triangular_matrix_vector_product.html&#34;&gt;triangular_matrix_vector_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMV: 三角行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/triangular_matrix_vector_solve.html&#34;&gt;triangular_matrix_vector_solve&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSV: 三角行列を係数とする行列方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_rank_1_update.html&#34;&gt;matrix_rank_1_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGER, xGERU: 行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_rank_1_update_c.html&#34;&gt;matrix_rank_1_update_c&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGERC: 複素行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/symmetric_matrix_rank_1_update.html&#34;&gt;symmetric_matrix_rank_1_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR: 対称行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/hermitian_matrix_rank_1_update.html&#34;&gt;hermitian_matrix_rank_1_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER: ハミルトニアン行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/symmetric_matrix_rank_2_update.html&#34;&gt;symmetric_matrix_rank_2_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR2: 対称行列のRank-2更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/hermitian_matrix_rank_2_update.html&#34;&gt;hermitian_matrix_rank_2_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER2: ハミルトニアン行列のRank-2更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 3アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_product.html&#34;&gt;matrix_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGEMM: 2つの一般行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/symmetric_matrix_product.html&#34;&gt;symmetric_matrix_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYMM: 対称行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/hermitian_matrix_product.html&#34;&gt;hermitian_matrix_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHEMM: ハミルトニアン行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/triangular_matrix_product.html&#34;&gt;triangular_matrix_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: 三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/triangular_matrix_left_product.html&#34;&gt;triangular_matrix_left_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: In-placeに三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/triangular_matrix_right_product.html&#34;&gt;triangular_matrix_right_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: In-placeに三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/symmetric_matrix_rank_k_update.html&#34;&gt;symmetric_matrix_rank_k_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYRK: 対称行列のRank-k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/hermitian_matrix_rank_k_update.html&#34;&gt;hermitian_matrix_rank_k_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHERK: ハミルトニアン行列のRank-k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/symmetric_matrix_rank_2k_update.html&#34;&gt;symmetric_matrix_rank_2k_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR2K: 対称行列のRank-2k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/hermitian_matrix_rank_2k_update.html&#34;&gt;hermitian_matrix_rank_2k_update&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER2K: ハミルトニアン行列のRank-2k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/triangular_matrix_matrix_left_solve.html&#34;&gt;triangular_matrix_matrix_left_solve&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSM: 三角行列の連立一次方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_matrix_right_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSM: 三角行列の連立一次方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;タグ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダでは、行列の格納順序や三角行列の上下をタグを使って表現している。&lt;/p&gt;
&lt;h3&gt;格納順序&lt;/h3&gt;
&lt;p&gt;行列の格納順序を表すタグ。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/column_major_t.html&#34;&gt;column_major_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(column-major)を表すタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/column_major_t.html&#34;&gt;column_major&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(column-major)を表すタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/row_major_t.html&#34;&gt;row_major_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(row-major)を表すタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/row_major_t.html&#34;&gt;row_major&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(row-major)を表すタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;三角行列&lt;/h3&gt;
&lt;p&gt;上三角行列か下三角行列かを表すタグ。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/upper_triangle_t.html&#34;&gt;upper_triangle_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上三角行列を表すタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/upper_triangle_t.html&#34;&gt;upper_triangle&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上三角行列を表すタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/lower_triangle_t.html&#34;&gt;lower_triangle_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下三角行列を表すタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/lower_triangle_t.html&#34;&gt;lower_triangle&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下三角行列を表すタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;対角成分&lt;/h3&gt;
&lt;p&gt;行列の全ての対角成分を暗黙に乗法における単位元とみなすかどうかを表すタグ。みなした場合、行列の対角成分にはアクセスせず、値が乗法における単位元であるとして計算する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/implicit_unit_diagonal_t.html&#34;&gt;implicit_unit_diagonal_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての対角成分を暗黙に乗法における単位元とみなすタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/implicit_unit_diagonal_t.html&#34;&gt;implicit_unit_diagonal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての対角成分を暗黙に乗法における単位元とみなすタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/explicit_diagonal_t.html&#34;&gt;explicit_diagonal_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての対角成分にアクセスするタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/explicit_diagonal_t.html&#34;&gt;explicit_diagonal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての対角成分にアクセスするタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++26&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html&#34; target=&#34;_blank&#34;&gt;P1673R13 A free function linear algebra interface based on the BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1674r2.html&#34; target=&#34;_blank&#34;&gt;P1674R2: Evolving a Standard C++ Linear Algebra Library from the BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CppCon/CppCon2023/blob/main/Presentations/stdlinalg_linear_algebra_coming_to_standard_cpp.pdf&#34; target=&#34;_blank&#34;&gt;std::linalg: Linear Algebra Coming to Standard C++&lt;/a&gt;, CppCon 2023&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.netlib.org/blas/&#34; target=&#34;_blank&#34;&gt;BLAS (Basic Linear Algebra Subprograms)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eel.is/c++draft/complex.numbers&#34; target=&#34;_blank&#34;&gt;Numerics library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>triangular_matrix_matrix_left_solve -- linalg : triangular_matrix_matrix_left_solveを追加 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/triangular_matrix_matrix_left_solve.html"/>
      <id>dae7d3d3ac1b7babdf79a975931548f08dba78ba:reference/linalg/triangular_matrix_matrix_left_solve.md</id>
      <updated>2024-07-17T14:31:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/triangular_matrix_matrix_left_solve.md b/reference/linalg/triangular_matrix_matrix_left_solve.md
new file mode 100644
index 000000000..89c1074e8
--- /dev/null
+++ b/reference/linalg/triangular_matrix_matrix_left_solve.md
@@ -0,0 +1,279 @@
+# triangular_matrix_matrix_left_solve
+
+
+* [mathjax enable]
+* linalg[meta header]
+* function template[meta id-type]
+* std::linalg[meta namespace]
+* cpp26[meta cpp]
+
+
+```cpp
+namespace std::linalg {
+  template&amp;lt;in-matrix InMat1,
+           class Triangle,
+           class DiagonalStorage,
+           in-matrix InMat2,
+           out-matrix OutMat,
+           class BinaryDivideOp&amp;gt;
+  void triangular_matrix_matrix_left_solve(
+    InMat1 A,
+    Triangle t,
+    DiagonalStorage d,
+    InMat2 B,
+    OutMat X,
+    BinaryDivideOp divide); // (1)
+
+  template&amp;lt;class ExecutionPolicy,
+           in-matrix InMat1,
+           class Triangle,
+           class DiagonalStorage,
+           in-matrix InMat2,
+           out-matrix OutMat,
+           class BinaryDivideOp&amp;gt;
+  void triangular_matrix_matrix_left_solve(
+    ExecutionPolicy&amp;amp;&amp;amp; exec,
+    InMat1 A,
+    Triangle t,
+    DiagonalStorage d,
+    InMat2 B,
+    OutMat X,
+    BinaryDivideOp divide); // (2)
+
+  template&amp;lt;in-matrix InMat1,
+           class Triangle,
+           class DiagonalStorage,
+           in-matrix InMat2,
+           out-matrix OutMat&amp;gt;
+  void triangular_matrix_matrix_left_solve(
+    InMat1 A,
+    Triangle t,
+    DiagonalStorage d,
+    InMat2 B,
+    OutMat X); // (3)
+
+  template&amp;lt;class ExecutionPolicy,
+           in-matrix InMat1,
+           class Triangle,
+           class DiagonalStorage,
+           in-matrix InMat2,
+           out-matrix OutMat&amp;gt;
+  void triangular_matrix_matrix_left_solve(
+    ExecutionPolicy&amp;amp;&amp;amp; exec,
+    InMat1 A,
+    Triangle t,
+    DiagonalStorage d,
+    InMat2 B,
+    OutMat X); // (4)
+}
+```
+
+
+## 概要
+三角行列に対して、連立一次方程式を解く。
+引数`t`は対称行列の成分が上三角にあるのか、それとも下三角にあるのかを示す。
+引数`d`には対称行列の対角成分を暗黙に乗法における単位元とみなすかどうかを指定する。
+引数`divide`には値の割り算を指定する。この引数は非可換な掛け算を持つ値型をサポートするためにある。
+
+- (1): 連立一次方程式 $AY = B$ を解き、`Y`を`X`に代入する。もし解が存在しないなら、`X`は有効だが未規定。
+- (2): (1)を指定された実行ポリシーで実行する。
+- (3): 割り算に[`std::divides`](/reference/functional/divides.md)`&amp;lt;void&amp;gt;`を用いて、(1)を行う。
+- (4): (3)を指定された実行ポリシーで実行する。
+
+
+## 適格要件
+- 共通:
+    + `Triangle`は[`upper_triangle_t`](upper_triangle_t.md)または[`lower_triangle_t`](lower_triangle_t.md)
+    + `DiagonalStorage`は[`implicit_unit_diagonal_t`](implicit_unit_diagonal_t.md)または[`explicit_diagonal_t`](explicit_diagonal_t.md)
+    + `InMat1`(`A`の型)が[`layout_blas_packed`](layout_blas_packed.md)を持つなら、レイアウトの`Triangle`テンプレート引数とこの関数の`Triangle`テンプレート引数が同じ型
+    + [`possibly-multipliable`](possibly-multipliable.md)`&amp;lt;decltype(A), decltype(X), decltype(B)&amp;gt;()`が`true`
+    + [`compatible-static-extents`](compatible-static-extents.md)`&amp;lt;decltype(A), decltype(A)&amp;gt;(0, 1)`が`true` (つまり`A`が正方行列であること)
+- (2), (4): [`is_execution_policy`](/reference/execution/is_execution_policy.md)`&amp;lt;ExecutionPolicy&amp;gt;::value`が`true`
+
+
+## 事前条件
+- [`multipliable`](multipliable.md)`(A, X, B)`が`true`
+- `A.extent(0) == A.extent(1)` (つまり`A`が正方行列であること)
+
+
+## 効果
+対称行列の成分の位置を示す`t`と対角成分へアクセスするかどうかを示す`d`を考慮して、連立一次方程式の解を求める。
+
+- (1), (2): 連立一次方程式 $AY = B$ を解き、`Y`を`X`に代入する。もし解が存在しないなら、`X`は有効だが未規定。
+- (3): `triangular_matrix_matrix_left_solve(A, t, d, B, X, divides&amp;lt;void&amp;gt;{})`と同じ。
+- (4): `triangular_matrix_matrix_left_solve(std::forward&amp;lt;ExecutionPolicy&amp;gt;(exec), A, t, d, B, X, divides&amp;lt;void&amp;gt;{})`と同じ。
+
+
+## 戻り値
+なし
+
+
+## 計算量
+$O(\verb|A.extent(0)| \times (\verb|X.extent(0)|)^2)$
+
+
+## 備考
+- 三角行列が左側にあるので、非可換な掛け算の場合の`divide`の望ましい実装は数学では$y^{-1}x$と同等と思われる。ここで`x`は最初の引数で`y`は2番目の引数、$y^{-1}$は`y`の掛け算での逆元である。
+
+
+## 例
+**[注意] 処理系にあるコンパイラで確認していないため、間違っているかもしれません。**
+
+```cpp example
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;linalg&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+template &amp;lt;class Matrix&amp;gt;
+void print_mat(const Matrix&amp;amp; A) {
+  for(int i = 0; i &amp;lt; A.extent(0); ++i) {
+    for(int j = 0; j &amp;lt; A.extent(1) - 1; ++j) {
+      std::cout &amp;lt;&amp;lt; A[i, j] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+    }
+    std::cout &amp;lt;&amp;lt; A[i, A.extent(1) - 1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+  }
+}
+
+template &amp;lt;class Matrix&amp;gt;
+void init_mat(Matrix&amp;amp; A, typename Matrix::value_type geta = 1) {
+  for(int i = 0; i &amp;lt; A.extent(0); ++i) {
+    for(int j = 0; j &amp;lt; A.extent(1); ++j) {
+      A[i, j] = i * A.extent(1) + j + geta;
+    }
+  }
+}
+
+template &amp;lt;class Matrix&amp;gt;
+void init_tria_mat(Matrix&amp;amp; A) {
+  for(int i = 0; i &amp;lt; A.extent(0); ++i) {
+    for(int j = i + 1; j &amp;lt; A.extent(1); ++j) {
+      A[i, j] = i * A.extent(1) + j;
+    }
+  }
+}
+
+int main()
+{
+  constexpr size_t N = 4;
+
+  std::vector&amp;lt;double&amp;gt; A_vec(N * N);
+  std::vector&amp;lt;double&amp;gt; X_vec(N * N);
+  std::vector&amp;lt;double&amp;gt; B_vec(N * N);
+
+  std::mdspan&amp;lt;
+    double,
+    std::extents&amp;lt;size_t, N, N&amp;gt;,
+    std::linalg::layout_blas_packed&amp;lt;
+      std::linalg::upper_triangle_t,
+      std::linalg::row_major_t&amp;gt;
+  &amp;gt; A(A_vec.data());
+  std::mdspan X(X_vec.data(), N, N);
+  std::mdspan B(B_vec.data(), N, N);
+
+  init_mat(A)
+  init_mat(B);
+
+  // (1)
+  std::cout &amp;lt;&amp;lt; &amp;#34;(1)\n&amp;#34;;
+  std::linalg::triangular_matrix_matrix_left_solve(
+    A,
+    std::linalg::upper_triangle,
+    std::linalg::implicit_unit_diagonal,
+    B,
+    X,
+    std::divides&amp;lt;void&amp;gt;{});
+  print_mat(X);
+
+  // (2)
+  std::cout &amp;lt;&amp;lt; &amp;#34;(2)\n&amp;#34;;
+  std::linalg::triangular_matrix_matrix_left_solve(
+    std::execution::par,
+    A,
+    std::linalg::upper_triangle,
+    std::linalg::implicit_unit_diagonal,
+    B,
+    X,
+    std::divides&amp;lt;void&amp;gt;{});
+  print(X);
+
+  // (3)
+  std::cout &amp;lt;&amp;lt; &amp;#34;(3)\n&amp;#34;;
+  std::linalg::triangular_matrix_matrix_left_solve(
+    A,
+    std::linalg::upper_triangle,
+    std::linalg::implicit_unit_diagonal,
+    B,
+    X);
+  print(X);
+
+  // (4)
+  std::cout &amp;lt;&amp;lt; &amp;#34;(4)\n&amp;#34;;
+  std::linalg::triangular_matrix_matrix_left_solve(
+    std::execution::par,
+    A,
+    std::linalg::upper_triangle,
+    std::linalg::implicit_unit_diagonal,
+    B,
+    X);
+  print(X);
+
+  return 0;
+}
+```
+* A.extent[link /reference/mdspan/extents/extent.md]
+* v.extent[link /reference/mdspan/extents/extent.md]
+* std::mdspan[link /reference/mdspan/mdspan.md]
+* std::extents[link /reference/mdspan/extents.md]
+* std::linalg::layout_blas_packed[link /reference/linalg/layout_blas_packed.md]
+* std::linalg::upper_triangle_t[link /reference/linalg/upper_triangle_t.md]
+* std::linalg::row_major_t[link /reference/linalg/row_major_t.md]
+* std::linalg::upper_triangle[link /reference/linalg/upper_triangle_t.md]
+* std::linalg::implicit_unit_diagonal[link /reference/linalg/implicit_unit_diagonal_t.md]
+* std::execution::par[link /reference/execution/execution/execution_policy.md]
+* std::linalg::triangular_matrix_matrix_left_solve[color ff0000]
+
+
+### 出力
+```
+(1)
+-2 -2
+2 3
+(2)
+-2 -2
+2 3
+(3)
+-2 -2
+2 3
+(4)
+-2 -2
+2 3
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution`](/reference/execution.md)
+- [`mdspan`](/reference/mdspan.md)
+- [`upper_triangle_t`](upper_triangle_t.md)
+- [`lower_triangle_t`](lower_triangle_t.md)
+- [`implicit_unit_diagonal`](implicit_unit_diagonal_t.md)
+- [`explicit_diagonal`](explicit_diagonal_t.md)
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
+- [LAPACK: trsm](https://netlib.org/lapack/explore-html/d9/de5/group__trsm.html)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>全ての非型テンプレート引数の定数式評価を許可 [N4268] -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/allow_constant_evaluation_for_all_non-type_template_arguments.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:lang/cpp17/allow_constant_evaluation_for_all_non-type_template_arguments.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/allow_constant_evaluation_for_all_non-type_template_arguments.md b/lang/cpp17/allow_constant_evaluation_for_all_non-type_template_arguments.md
index dce9e1fb0..6e348ae5f 100644
--- a/lang/cpp17/allow_constant_evaluation_for_all_non-type_template_arguments.md
+++ b/lang/cpp17/allow_constant_evaluation_for_all_non-type_template_arguments.md
@@ -44,7 +44,7 @@ C++14からC++17にかけて、次の表のような変更があったと考え
 | 整数または列挙 |	任意の定数式 |
 | ポインタ型 | 正確な構文と実体、配列、関数、リンケージを使用して静的記憶期間オブジェクトまたは関数を参照する。NULLポインタに評価される任意の定数式 |
 | 参照型 |	正確な構文とオブジェクト、関数、リンケージを使用して静的記憶期間オブジェクトまたは関数を参照する |
-| メンバへのポインタ | 正確な構文と`＆X::y` 、またはメンバへのポインタが`NULL`に評価される任意の定数式 |
+| メンバへのポインタ | 正確な構文と`&amp;amp;X::y` 、またはメンバへのポインタが`NULL`に評価される任意の定数式 |
 | [`std::nullptr_t`](/reference/cstddef/nullptr_t.md) | 任意の定数式 |
 
 から
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator++ -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/istream_iterator/op_increment.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/iterator/istream_iterator/op_increment.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/istream_iterator/op_increment.md b/reference/iterator/istream_iterator/op_increment.md
index d2baaefc5..d3d5b03a7 100644
--- a/reference/iterator/istream_iterator/op_increment.md
+++ b/reference/iterator/istream_iterator/op_increment.md
@@ -16,12 +16,12 @@ istream_iterator&amp;lt;T, CharT, Traits, Distance&amp;gt; operator++(int);
 
 ## 効果
 前置`operator++`：
-`*in_stream ≫ value;`
+`*in_stream &amp;gt;&amp;gt; value;`
 `return *this;`
 
 後置`operator++`：
 `istream_iterator&amp;lt;T, CharT, Traits, Distance&amp;gt; tmp = *this;`
-`*in_stream ≫ value;`
+`*in_stream &amp;gt;&amp;gt; value;`
 `return tmp;`
 
 ※`in_stream`は、メンバ変数として保持している入力ストリームオブジェクトへのポインタ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocate_shared -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocate_shared.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/memory/allocate_shared.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocate_shared.md b/reference/memory/allocate_shared.md
index 17a5ac19a..9c2faaf86 100644
--- a/reference/memory/allocate_shared.md
+++ b/reference/memory/allocate_shared.md
@@ -63,13 +63,13 @@ namespace std {
 
 それぞれ、`pv`は型`U`のオブジェクトを保持するのに適したストレージを指し、型`A2`の`a2`は、`value_type`が`remove_cv_t&amp;lt;U&amp;gt;`になるように`allocate_shared`に渡されるアロケーター`a`のリバウンドコピーである。ここで、リバウンドコピーとは、参照カウンタと型`T`の本体を連続メモリ領域に配置するためには`T`のサイズより大きい領域をアロケートする必要があるために`allocator_traits&amp;lt;Alloc&amp;gt;::rebind_alloc&amp;lt;value_type&amp;gt;`を用いて再束縛されたものである。
 
-非配列型Uの（サブ）オブジェクトがデフォルトの初期値を持つように指定されている場合、この関数は、式 `allocator_traits&amp;lt;A2&amp;gt;::construct(a2、pv)`を介してこの（サブ）オブジェクトを初期化する。ここで、`pv`は、型`U`のオブジェクトを保持するのに適したストレージを指し、タイプ`A2`の`a2`は、`value_type`が`remove_cv_t&amp;lt;U&amp;gt;`になるように、`allocate_shared`に渡されるアロケーター`a`のリバウンドコピーである。
+非配列型Uの（サブ）オブジェクトがデフォルトの初期値を持つように指定されている場合、この関数は、式 `allocator_traits&amp;lt;A2&amp;gt;::construct(a2, pv)`を介してこの（サブ）オブジェクトを初期化する。ここで、`pv`は、型`U`のオブジェクトを保持するのに適したストレージを指し、タイプ`A2`の`a2`は、`value_type`が`remove_cv_t&amp;lt;U&amp;gt;`になるように、`allocate_shared`に渡されるアロケーター`a`のリバウンドコピーである。
 
 配列要素は、アドレスの昇順で初期化される。
 
 戻り値によって管理されるオブジェクトの`lifetime`が終了するか、配列要素の初期化が例外をスローすると、初期化された要素は元の構造の逆の順序で破棄される。
 
-この関数によって初期化された非配列型`U`の（サブ）オブジェクトが破棄される場合、式`allocator_traits&amp;lt;A2&amp;gt;::destroy(a2、pv)`によって破棄される。`pv`はその型のオブジェクトを指す。`remove_cv_t&amp;lt;U&amp;gt;`および型`A2`の`a2`は、`value_type`が`remove_cv_t&amp;lt;U&amp;gt;`になるように`allocate_shared`に渡されるアロケーター`a`の再束縛されたコピーである。
+この関数によって初期化された非配列型`U`の（サブ）オブジェクトが破棄される場合、式`allocator_traits&amp;lt;A2&amp;gt;::destroy(a2, pv)`によって破棄される。`pv`はその型のオブジェクトを指す。`remove_cv_t&amp;lt;U&amp;gt;`および型`A2`の`a2`は、`value_type`が`remove_cv_t&amp;lt;U&amp;gt;`になるように`allocate_shared`に渡されるアロケーター`a`の再束縛されたコピーである。
 
 - (1) : 初期値`T(forward&amp;lt;Args&amp;gt;(args)...)`を持つ型`T`のオブジェクトへの`shared_ptr`を返す。Tが配列型でない場合にのみ、このオーバーロードはオーバーロード解決に関与する。この関数によって呼び出される`shared_ptr`コンストラクタは、型`T`の新しく構築されたオブジェクトのアドレスで`shared_from_this`を有効にする。
 - (2) : デフォルトの初期値を持つ`U[N]`型のオブジェクトへの`shared_ptr`を返す。ここで、`U`は`remove_extent_t&amp;lt;T&amp;gt;`である。`T`の形式が`U[]`の場合にのみ、このオーバーロードはオーバーロード解決に関与する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator/destroy.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/memory/allocator/destroy.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator/destroy.md b/reference/memory/allocator/destroy.md
index 381c88ff5..cf65df1d4 100644
--- a/reference/memory/allocator/destroy.md
+++ b/reference/memory/allocator/destroy.md
@@ -23,8 +23,8 @@ void destroy(U* p);
 
 
 ## 効果
-- C++03 : `((T*)p)-&amp;gt;˜T()`
-- C++11 : `p-&amp;gt;˜U()`
+- C++03 : `((T*)p)-&amp;gt;~T()`
+- C++11 : `p-&amp;gt;~U()`
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>デストラクタ -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/node_handle/node_handle/op_destructor.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/node_handle/node_handle/op_destructor.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/node_handle/node_handle/op_destructor.md b/reference/node_handle/node_handle/op_destructor.md
index 3c5632e36..3db26cae4 100644
--- a/reference/node_handle/node_handle/op_destructor.md
+++ b/reference/node_handle/node_handle/op_destructor.md
@@ -14,7 +14,7 @@
 
 
 ## 効果
-`ptr_！= nullptr` の場合、`std::allocator_traits&amp;lt;allocator_type&amp;gt;::destroy` を呼び出して `ptr_` が指す `container_node_type` オブジェクト内の `value_type` サブオブジェクトを破棄し、次に `std::allocator_traits&amp;lt;allocator_type&amp;gt;::template rebind_traits&amp;lt;container_node_type&amp;gt;::deallocate` を呼び出して `ptr_` の割り当てを解除する。
+`ptr_ != nullptr` の場合、`std::allocator_traits&amp;lt;allocator_type&amp;gt;::destroy` を呼び出して `ptr_` が指す `container_node_type` オブジェクト内の `value_type` サブオブジェクトを破棄し、次に `std::allocator_traits&amp;lt;allocator_type&amp;gt;::template rebind_traits&amp;lt;container_node_type&amp;gt;::deallocate` を呼び出して `ptr_` の割り当てを解除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emit_on_flush -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/ostream/emit_on_flush.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/ostream/emit_on_flush.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ostream/emit_on_flush.md b/reference/ostream/emit_on_flush.md
index ebc7eba73..01414bdb2 100644
--- a/reference/ostream/emit_on_flush.md
+++ b/reference/ostream/emit_on_flush.md
@@ -17,7 +17,7 @@ namespace std {
 
 
 ## 効果
-`os.rdbuf()`が`std::basic_syncbuf&amp;lt;charT、traits、Allocator&amp;gt;*`である場合、これを`buf`とすると、`buf-&amp;gt;set_emit_on_sync(true)`を呼び出す。  
+`os.rdbuf()`が`std::basic_syncbuf&amp;lt;charT, traits, Allocator&amp;gt;*`である場合、これを`buf`とすると、`buf-&amp;gt;set_emit_on_sync(true)`を呼び出す。  
 それ以外の場合、このマニピュレータは効果がない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flush_emit -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/ostream/flush_emit.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/ostream/flush_emit.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ostream/flush_emit.md b/reference/ostream/flush_emit.md
index bd68d98fd..240bbd380 100644
--- a/reference/ostream/flush_emit.md
+++ b/reference/ostream/flush_emit.md
@@ -19,7 +19,7 @@ namespace std {
 
 ## 効果
 `os.flush()`を呼び出す。
-続いて`os.rdbuf()`が`std::basic_syncbuf&amp;lt;charT、traits、Allocator&amp;gt;*`である場合、これを`buf`とすると、`buf-&amp;gt;emit()`を呼び出す。
+続いて`os.rdbuf()`が`std::basic_syncbuf&amp;lt;charT, traits, Allocator&amp;gt;*`である場合、これを`buf`とすると、`buf-&amp;gt;emit()`を呼び出す。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>noemit_on_flush -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/ostream/noemit_on_flush.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/ostream/noemit_on_flush.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ostream/noemit_on_flush.md b/reference/ostream/noemit_on_flush.md
index 8196112fc..acb6018b8 100644
--- a/reference/ostream/noemit_on_flush.md
+++ b/reference/ostream/noemit_on_flush.md
@@ -17,7 +17,7 @@ namespace std {
 
 
 ## 効果
-`os.rdbuf()`が`std::basic_syncbuf&amp;lt;charT、traits、Allocator&amp;gt;*`である場合、これを`buf`とすると、`buf-&amp;gt;set_emit_on_sync(false)`を呼び出す。  
+`os.rdbuf()`が`std::basic_syncbuf&amp;lt;charT, traits, Allocator&amp;gt;*`である場合、これを`buf`とすると、`buf-&amp;gt;set_emit_on_sync(false)`を呼び出す。  
 それ以外の場合、このマニピュレータは効果がない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/syncstream/basic_osyncstream/op_constructor.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/syncstream/basic_osyncstream/op_constructor.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/syncstream/basic_osyncstream/op_constructor.md b/reference/syncstream/basic_osyncstream/op_constructor.md
index 803947860..bd81a85a2 100644
--- a/reference/syncstream/basic_osyncstream/op_constructor.md
+++ b/reference/syncstream/basic_osyncstream/op_constructor.md
@@ -29,7 +29,7 @@ basic_osyncstream(basic_osyncstream&amp;amp;&amp;amp; other) noexcept;
 - (1) : 提供されるストリームバッファ（`buf`）、アロケータ（`allocator`）を使用してプライベートメンバの[`std::basic_syncbuf`](../basic_syncbuf.md)を初期化し、そのポインタを用いて基底クラスである[`std::basic_ostream`](../../ostream/basic_ostream.md)を初期化する。
 - (2)(3) : (1)に委譲。
 - (4) : (3)に委譲。
-- (5) : 対応する`other`のサブオブジェクトから基底クラスとプライベートメンバの`std::basic_syncbuf`をムーブ構築し、基底クラスの初期化を完了するために`std::basic_ostream&amp;lt;charT、traits&amp;gt;::set_rdbuf(addressof(sb))`を呼び出す。
+- (5) : 対応する`other`のサブオブジェクトから基底クラスとプライベートメンバの`std::basic_syncbuf`をムーブ構築し、基底クラスの初期化を完了するために`std::basic_ostream&amp;lt;charT, traits&amp;gt;::set_rdbuf(addressof(sb))`を呼び出す。
 
 
 ## 事後条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>aligned_union -- インラインコードブロックの全角文字の typo を修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/aligned_union.html"/>
      <id>ddd80639fd55a326d4c38a1b70f1b5b203540f02:reference/type_traits/aligned_union.md</id>
      <updated>2024-07-16T18:44:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/aligned_union.md b/reference/type_traits/aligned_union.md
index f72c04b43..606f7d2a5 100644
--- a/reference/type_traits/aligned_union.md
+++ b/reference/type_traits/aligned_union.md
@@ -53,9 +53,9 @@ namespace std {
 
 - 第1テンプレートパラメータが無意味
     - この機能は、可変個のすべての型のサイズとアライメントを推論し、それらの最大値を実際のストレージとして使用する。先頭のテンプレートパラメータはストレージの最小サイズである。すべての型がそれより小さい場合でも、ストレージは第1テンプレートパラメータより小さくならない
-    - 最小サイズを必要とすることはめずらしいことであり、ほとんどの場合は`aligned_union_t&amp;lt;0、Ts...&amp;gt;`のように使用する。この引数`0`は機能に精通していなければ理解しにくい
+    - 最小サイズを必要とすることはめずらしいことであり、ほとんどの場合は`aligned_union_t&amp;lt;0, Ts...&amp;gt;`のように使用する。この引数`0`は機能に精通していなければ理解しにくい
 - サイズとアライメントの推論が[`aligned_storage`](aligned_storage.md)と一貫していない
-    - 一貫した仕様であるならば、`aligned_union_t&amp;lt;0、T&amp;gt;`のような型をひとつだけ指定する用途につながるが、現在の仕様は何を意図していたのか不明である
+    - 一貫した仕様であるならば、`aligned_union_t&amp;lt;0, T&amp;gt;`のような型をひとつだけ指定する用途につながるが、現在の仕様は何を意図していたのか不明である
 
 この機能を以下のように置き換えることを推奨する：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>属性構文 [N2761] -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/attributes.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:lang/cpp11/attributes.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/attributes.md b/lang/cpp11/attributes.md
index 803308f06..0259f3a4a 100644
--- a/lang/cpp11/attributes.md
+++ b/lang/cpp11/attributes.md
@@ -154,7 +154,7 @@ C++11で採用されたもの以外で検討された以下の機能は、属性
 以下の属性は、C++11時点では採用されていない：
 
 - 関数が同じ引数に対して同じ戻り値を返すことを明示する`pure`属性
-- `if`文や`switch文`の`case`に指定する条件式のヒット率が高いことを指示する`probably`属性
+- `if`文や`switch`文の`case`に指定する条件式のヒット率が高いことを指示する`probably`属性
 - 関数が非推奨であることを指示する`deprecated`属性
 - 基底クラスによって関数を隠蔽しないことを明示する`not_hiding`属性
 - ポインタの所有者(解放する責任を持つユーザー)であることを明示する`owner`属性
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/bitset/bitset/op_constructor.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/bitset/bitset/op_constructor.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/bitset/bitset/op_constructor.md b/reference/bitset/bitset/op_constructor.md
index 03fe984b9..3cd4a189b 100644
--- a/reference/bitset/bitset/op_constructor.md
+++ b/reference/bitset/bitset/op_constructor.md
@@ -68,7 +68,7 @@ constexpr explicit bitset(
 - (1) : デフォルトコンストラクタ
 - (2) : 整数値を受け取るコンストラクタ
 - (3) : `&amp;#39;0&amp;#39;`と`&amp;#39;1&amp;#39;`の文字で構成される`basic_string`文字列からビット列を構築する
-- (4) : `&amp;#39;0&amp;#39;と`&amp;#39;1&amp;#39;`の文字で構成される`[`basic_string_view`](/reference/string_view/basic_string_view.md)オブジェクトからビット列を構築する
+- (4) : `&amp;#39;0&amp;#39;`と`&amp;#39;1&amp;#39;`の文字で構成される[`basic_string_view`](/reference/string_view/basic_string_view.md)オブジェクトからビット列を構築する
 - (5) : `&amp;#39;0&amp;#39;`と`&amp;#39;1&amp;#39;`の文字で構成される文字配列からビット列を構築する
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>next -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/ranges_next.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/iterator/ranges_next.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/ranges_next.md b/reference/iterator/ranges_next.md
index 58c578ee4..66c57e8af 100644
--- a/reference/iterator/ranges_next.md
+++ b/reference/iterator/ranges_next.md
@@ -144,7 +144,7 @@ int main() {
 | [`prev()`](prev.md) | `n`回後方に進めたイテレータを返す |
 | [`advance()`](advance.md) | `n`回イテレータを進める |
 | [`rangse::prev()`](ranges_prev.md) | `n`回後方に進めたイテレータを返す |
-| [`ranges::advance()`](ranges_advance.md) |`n`回あるいは`boundまで`イテレータを進める |
+| [`ranges::advance()`](ranges_advance.md) |`n`回あるいは`bound`までイテレータを進める |
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>prev -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/ranges_prev.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/iterator/ranges_prev.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/ranges_prev.md b/reference/iterator/ranges_prev.md
index 2fea54213..639f46329 100644
--- a/reference/iterator/ranges_prev.md
+++ b/reference/iterator/ranges_prev.md
@@ -126,7 +126,7 @@ int main() {
 | [`prev()`](prev.md) | `n`回後方に進めたイテレータを返す |
 | [`advance()`](advance.md) | `n`回イテレータを進める |
 | [`ranges::next()`](ranges_next.md) | `n`回あるいは`bound`まで前方に進めたイテレータを返す |
-| [`ranges::advance()`](ranges_advance.md) |`n`回あるいは`boundまで`イテレータを進める |
+| [`ranges::advance()`](ranges_advance.md) |`n`回あるいは`bound`までイテレータを進める |
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_lock_until -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/mutex/recursive_timed_mutex/try_lock_until.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/mutex/recursive_timed_mutex/try_lock_until.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mutex/recursive_timed_mutex/try_lock_until.md b/reference/mutex/recursive_timed_mutex/try_lock_until.md
index 3503cc146..b2a860485 100644
--- a/reference/mutex/recursive_timed_mutex/try_lock_until.md
+++ b/reference/mutex/recursive_timed_mutex/try_lock_until.md
@@ -24,7 +24,7 @@ bool try_lock_until(const chrono::time_point&amp;lt;Clock, Duration&amp;gt;&amp;amp; abs_time);
 
 所有権が取得できるまで、もしくは`abs_time`時間に到達するまでこの関数はブロッキングする。
 
-`abs_timeにすでに到達していた場合`、この関数は[`try_lock()`](try_lock.md)と同じ効果をもち、ブロッキングせずにミューテックスの所有権取得を試みる。
+`abs_time`にすでに到達していた場合、この関数は[`try_lock()`](try_lock.md)と同じ効果をもち、ブロッキングせずにミューテックスの所有権取得を試みる。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_lock_until -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/mutex/timed_mutex/try_lock_until.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/mutex/timed_mutex/try_lock_until.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mutex/timed_mutex/try_lock_until.md b/reference/mutex/timed_mutex/try_lock_until.md
index b6d08cd6d..d087e83b1 100644
--- a/reference/mutex/timed_mutex/try_lock_until.md
+++ b/reference/mutex/timed_mutex/try_lock_until.md
@@ -28,7 +28,7 @@ bool try_lock_until(const chrono::time_point&amp;lt;Clock, Duration&amp;gt;&amp;amp; abs_time);
 
 所有権が取得できるまで、もしくは`abs_time`時間に到達するまでこの関数はブロッキングする。
 
-`abs_timeにすでに到達していた場合`、この関数は[`try_lock()`](try_lock.md)と同じ効果をもち、ブロッキングせずにミューテックスの所有権取得を試みる。
+`abs_time`にすでに到達していた場合、この関数は[`try_lock()`](try_lock.md)と同じ効果をもち、ブロッキングせずにミューテックスの所有権取得を試みる。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inner_product -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/numeric/inner_product.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/numeric/inner_product.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/inner_product.md b/reference/numeric/inner_product.md
index a15b27bd9..1631e9b95 100644
--- a/reference/numeric/inner_product.md
+++ b/reference/numeric/inner_product.md
@@ -60,11 +60,11 @@ namespace std {
 
 ## 効果
 - (1) :
-    - C++03 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = acc + (*i) * (*j);` の演算を行い、`acc`を返す
-    - C++20 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc =` [`std::move`](/reference/utility/move.md)`(acc) + (*i) * (*j);` の演算を行い、`acc`を返す
+    - C++03 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータを`j`として、`acc = acc + (*i) * (*j);` の演算を行い、`acc`を返す
+    - C++20 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータを`j`として、`acc =` [`std::move`](/reference/utility/move.md)`(acc) + (*i) * (*j);` の演算を行い、`acc`を返す
 - (2) :
-    - C++03 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(acc, binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
-    - C++20 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(`[`std::move`](/reference/utility/move.md)`(acc), binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
+    - C++03 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータを`j`として、`acc = binary_op1(acc, binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
+    - C++20 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータを`j`として、`acc = binary_op1(`[`std::move`](/reference/utility/move.md)`(acc), binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/optional/optional/emplace.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/optional/optional/emplace.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/optional/optional/emplace.md b/reference/optional/optional/emplace.md
index 526f276e6..6d8b578cb 100644
--- a/reference/optional/optional/emplace.md
+++ b/reference/optional/optional/emplace.md
@@ -32,7 +32,7 @@ constexpr T&amp;amp; emplace(std::initializer_list&amp;lt;U&amp;gt; il, Args&amp;amp;&amp;amp;... args); // (2) C++23
 まず、共通の動作として、[`reset()`](reset.md)メンバ関数を呼び出す。
 
 - (1) : 型`T`の有効値を、[`std::forward&amp;lt;Args&amp;gt;`](/reference/utility/forward.md)`(args)...`を引数として構築する
-- (2) : 型`T`の有効値を、`ilと`[`std::forward&amp;lt;Args&amp;gt;`](/reference/utility/forward.md)`(args)...`を引数として構築する
+- (2) : 型`T`の有効値を、`il`と[`std::forward&amp;lt;Args&amp;gt;`](/reference/utility/forward.md)`(args)...`を引数として構築する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_lock_shared_until -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/shared_mutex/shared_timed_mutex/try_lock_shared_until.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/shared_mutex/shared_timed_mutex/try_lock_shared_until.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/shared_mutex/shared_timed_mutex/try_lock_shared_until.md b/reference/shared_mutex/shared_timed_mutex/try_lock_shared_until.md
index de53869e9..6d7e43ff1 100644
--- a/reference/shared_mutex/shared_timed_mutex/try_lock_shared_until.md
+++ b/reference/shared_mutex/shared_timed_mutex/try_lock_shared_until.md
@@ -28,7 +28,7 @@ bool try_lock_shared_until(const chrono::time_point&amp;lt;Clock, Duration&amp;gt;&amp;amp; abs_time);
 
 共有所有権が取得できるまで、もしくは`abs_time`時間に到達するまでこの関数はブロッキングする。
 
-`abs_timeにすでに到達していた場合`、この関数は[`try_lock_shared()`](try_lock_shared.md)と同じ効果をもち、ブロッキングせずにミューテックスの共有所有権の取得を試みる。
+`abs_time`にすでに到達していた場合、この関数は[`try_lock_shared()`](try_lock_shared.md)と同じ効果をもち、ブロッキングせずにミューテックスの共有所有権の取得を試みる。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_lock_until -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/shared_mutex/shared_timed_mutex/try_lock_until.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/shared_mutex/shared_timed_mutex/try_lock_until.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/shared_mutex/shared_timed_mutex/try_lock_until.md b/reference/shared_mutex/shared_timed_mutex/try_lock_until.md
index ef560189d..06401b21f 100644
--- a/reference/shared_mutex/shared_timed_mutex/try_lock_until.md
+++ b/reference/shared_mutex/shared_timed_mutex/try_lock_until.md
@@ -28,7 +28,7 @@ bool try_lock_until(const chrono::time_point&amp;lt;Clock, Duration&amp;gt;&amp;amp; abs_time);
 
 排他所有権が取得できるまで、もしくは`abs_time`時間に到達するまでこの関数はブロッキングする。
 
-`abs_timeにすでに到達していた場合`、この関数は[`try_lock()`](try_lock.md)と同じ効果をもち、ブロッキングせずにミューテックスの排他所有の権取得を試みる。
+`abs_time`にすでに到達していた場合、この関数は[`try_lock()`](try_lock.md)と同じ効果をもち、ブロッキングせずにミューテックスの排他所有の権取得を試みる。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/reference/span/span/op_constructor.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:reference/span/span/op_constructor.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/op_constructor.md b/reference/span/span/op_constructor.md
index 797d6c265..5b084d70e 100644
--- a/reference/span/span/op_constructor.md
+++ b/reference/span/span/op_constructor.md
@@ -80,7 +80,7 @@ constexpr explicit(extent != dynamic_extent)
 - (4), (5), (6) :
     - `extent ==` [`dynamic_extent`](/reference/span/dynamic_extent.md) `|| N == extent`が`true`であること
     - [`remove_pointer_t`](/reference/type_traits/remove_pointer.md)`&amp;lt;decltype(`[`data`](/reference/iterator/data.md)`(arr)))&amp;gt;`を型`U`であるとして、
-        - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U(*)[], element_type(*)[]&amp;gt;`が`trueであること` (この制約の意図は、配列の要素型から`element_type`へ、修飾の変換のみを許可すること)
+        - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U(*)[], element_type(*)[]&amp;gt;`が`true`であること (この制約の意図は、配列の要素型から`element_type`へ、修飾の変換のみを許可すること)
 - (7) :
     - 型 `U` を [`std::remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;`[`std::iter_reference_t`](/reference/iterator/iter_reference_t.md)`&amp;lt;R&amp;gt;&amp;gt;`とするとき
         - 型 `R` はコンセプト `std::ranges::contiguous_range` 及び `std::ranges::sized_range` を満たしていること
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ディレクトリ構造 -- インラインコードブロックの範囲を修正</title>
      <link href="https://cpprefjp.github.io/start_editing/directory_structure.html"/>
      <id>0b27920eb5f0d83dfdaee394f727eef78daa770d:start_editing/directory_structure.md</id>
      <updated>2024-07-16T18:43:27+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;ディレクトリ構造&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;lang&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cpp{version}.mdの形式で、各C++バージョンの言語機能ページを作る&lt;/li&gt;
&lt;li&gt;future.mdは、将来のC++で検討されている言語機能を記載するところである。導入予定だった機能が再検討になった場合などに使用する&lt;/li&gt;
&lt;li&gt;archive.mdは、廃案になったC++機能だが解説として残す価値のあるものがある場合に、記載するところである&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;reference / module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;reference階層は、ヘッダベースのライブラリリファレンスで、その階層直下にはヘッダページを置く&lt;/li&gt;
&lt;li&gt;module階層は、モジュールベースのライブラリリファレンスで、その階層直下にはモジュールページを置く&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reference階層とmodule階層は上記以外は同じであるため、以下、共通のルールを書きます。&lt;/p&gt;
&lt;h3&gt;ヘッダ・モジュール階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ヘッダ・モジュール階層以下に、それに所属している機能のページを置く&lt;/li&gt;
&lt;li&gt;どのヘッダ・モジュールにも属さない機能の場合は、以下のように対応する&lt;ul&gt;
&lt;li&gt;全体で使用する説明専用の機能は、仮のヘッダ&lt;code&gt;&amp;lt;exposition-only&amp;gt;&lt;/code&gt;に属するものとして記載する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;クラス階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;クラスに属するメンバ関数と型は、クラス階層の下に置く&lt;/li&gt;
&lt;li&gt;オーバーロードを意図している関数、そのクラス向けに特殊化した機能も、クラス階層の下に置き、機能の列挙としてもクラスページで行う&lt;ul&gt;
&lt;li&gt;オーバーロードを意図している関数の例は以下：&lt;ul&gt;
&lt;li&gt;非メンバ関数の演算子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::get()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::begin()&lt;/code&gt;/&lt;code&gt;std::end()&lt;/code&gt;/&lt;code&gt;std::data()&lt;/code&gt;/&lt;code&gt;std::size()&lt;/code&gt;およびそれに類するもの&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::swap()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::erase()&lt;/code&gt;/&lt;code&gt;std::erase_if()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor()&lt;/code&gt;/&lt;code&gt;ceil()&lt;/code&gt;/&lt;code&gt;round()&lt;/code&gt; (chrono)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;../reference/expected/expected.html&#34;&gt;std::expected&lt;/a&gt;&lt;/code&gt;では&lt;a href=&#34;../reference/expected/expected.void.html&#34;&gt;部分特殊化&lt;/a&gt;のためにクラス階層を分離している。これは各メンバ説明の差分が大きいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;演算子オーバーロードは、&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; (出力ストリームへの出力) と &lt;code&gt;std::operator&amp;gt;&amp;gt;&lt;/code&gt; (入力ストリームからの入力) を除き、左辺のクラスに属するものとする&lt;ul&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;../reference/system_error/error_code.html&#34;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/system_error/error_condition.html&#34;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;の比較演算子は、クラス階層ではなくヘッダ階層としている。これは所属関係がむずかしいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンセプト階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;コンセプトによってオーバーロード・特殊化されている場合は、コンセプトの階層を作って、その下に置く。機能の列挙としてはヘッダページで行う&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;名前空間階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;名前空間の階層は基本的に導入しない。例外は以下：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/thread/this_thread.html&#34;&gt;std::this_thread&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;名前空間に特殊な意味をもたせている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
</feed>