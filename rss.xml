<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-20T07:56:32.615004</updated>
  <id>c0e15f35-f0c7-4c85-9b35-122bbc59d239</id>

  
    <entry>
      <title>formatter -- formatter : C++23仕様に対応し、サンプルコードのコンパイルエラーを修正 (constが抜けてた) #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/formatter.html"/>
      <id>53880060961c5a4400ef61ee610bd6077224c070:reference/format/formatter.md</id>
      <updated>2023-01-20T16:51:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/formatter.md b/reference/format/formatter.md
index e40791996..5d167a515 100644
--- a/reference/format/formatter.md
+++ b/reference/format/formatter.md
@@ -7,15 +7,34 @@
 
 ```cpp
 namespace std {
-  template&amp;lt;class T, class U = char&amp;gt;
-  struct formatter;
+  template &amp;lt;class T, class U = char&amp;gt;
+  struct formatter;                                          // (1) C++20
+
+  template &amp;lt;ranges::input_range R, class charT&amp;gt;
+    requires (format_kind&amp;lt;R&amp;gt; != range_format::disabled) &amp;amp;&amp;amp;
+             formattable&amp;lt;ranges::range_reference_t&amp;lt;R&amp;gt;, charT&amp;gt;
+  struct formatter&amp;lt;R, charT&amp;gt;
+    : range-default-formatter&amp;lt;format_kind&amp;lt;R&amp;gt;, R, charT&amp;gt; { }; // (2) C++23
+
+  template &amp;lt;class charT, formattable&amp;lt;charT&amp;gt;... Ts&amp;gt;
+  struct formatter&amp;lt;pair-or-tuple&amp;lt;Ts...&amp;gt;, charT&amp;gt;;             // (3) C++23
 }
 ```
+* ranges::input_range[link /reference/ranges/input_range.md]
+* format_kind[link format_kind.md]
+* range_format[link range_format.md]
+* formattable[link formattable.md]
+* ranges::range_reference_t[link /reference/ranges/range_reference_t.md]
+* range-default-formatter[link range-default-formatter.md.nolink]
 
 ## 概要
 フォーマット引数の個々の型に対応する書式文字列の解析と値のフォーマットを担うクラス。
 
-`charT`を`char`または`wchar_t`とすると、標準で以下の特殊化が利用できる。
+- (1) : デフォルトのフォーマット
+- (2) : Range用のフォーマット。実装は[`range-default-formatter`](range-default-formatter.md.nolink)クラスが行う
+- (3) : [`std::pair`](/reference/utility/pair.md)と[`std::tuple`](/reference/tuple/tuple.md)に対する特殊化
+
+(1)は、`charT`を`char`または`wchar_t`とすると、標準で以下の特殊化が利用できる。
 
 - 1 以下のもの。
     ```cpp
@@ -46,43 +65,67 @@ namespace std {
 
 ワイド文字列とマルチバイト文字列を相互に変換するような特殊化は意図的に用意されていないが、ユーザーが用意することは禁止していない。
 
-## Formatter要件
+## ユーザーの型で`formatter`を特殊化する場合の要件
 
 `formatter`の有効な特殊化はFormatter要件を満たす必要がある。
 
 型`F`がFormatter要件を満たすとは、次のことをいう。
 
-* `F`は`Cpp17DefaultConstructible`、`Cpp17CopyConstructible`、`Cpp17CopyAssignable`、`Cpp17Destructible`であること
+- `F`は`Cpp17DefaultConstructible`、`Cpp17CopyConstructible`、`Cpp17CopyAssignable`、`Cpp17Destructible`であること
 
 さらに、以下の条件を満たすこと
 
 1. 式 `f.parse(pc)` が有効であり、
-    * 戻り値の型が`PC::iterator`である
-    * イテレータ範囲`[pc.begin(), pc.end())`を解析して`format_error`を投げるか、解析が終わった位置を指すイテレータを返す
+    - 戻り値の型が`PC::iterator`である
+    - イテレータ範囲`[pc.begin(), pc.end())`を解析して`format_error`を投げるか、解析が終わった位置を指すイテレータを返す
 2. 式 `f.format(t, fc)` が有効であり、
-    * 戻り値の型が`FC::iterator`である
-    * フォーマット結果を`fc.out()`へ出力し、出力後のイテレータを返す
-    * 出力は`t`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
+    - 戻り値の型が`FC::iterator`である
+    - フォーマット結果を`fc.out()`へ出力し、出力後のイテレータを返す
+    - 出力は`t`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
 3. 式 `f.format(u, fc)` が有効であり、
-    * 戻り値が`FC::iterator`である
-    * フォーマット結果を`fc.out()`へ出力し、出力後のイテレータを返す
-    * 出力は`u`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
-    * `u`を変更しない
+    - 戻り値が`FC::iterator`である
+    - フォーマット結果を`fc.out()`へ出力し、出力後のイテレータを返す
+    - 出力は`u`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
+    - `u`を変更しない
 
 条件内の各要素を、以下のように定義する
 
-* 文字の型を`charT`
-* 出力イテレータの型を`Out`
-* フォーマット引数の型を`T`
-* `f`を`F`のオブジェクト
-* `u`を`T`のlvalue
-* `t`を`T`または`const T`へ変換できる型のオブジェクト
-* `PC`を`basic_format_parse_context&amp;lt;charT&amp;gt;`
-* `FC`を`basic_format_context&amp;lt;Out, charT&amp;gt;`
-* `pc`を`PC`のlvalue
-* `fc`を`FC`のlvalue
-* `pc.begin()`は書式文字列中の対応する置換フィールドのオプションの先頭を指す
-* オプションが空なら、`pc.begin() == pc.end()`または`*pc.begin() == &amp;#39;}&amp;#39;`である
+- 文字の型を`charT`
+- 出力イテレータの型を`Out`
+- フォーマット引数の型を`T`
+- `f`を`F`のオブジェクト
+- `u`を`T`のlvalue
+- `t`を`T`または`const T`へ変換できる型のオブジェクト
+- `PC`を[`basic_format_parse_context`](basic_format_parse_context.md)`&amp;lt;charT&amp;gt;`
+- `FC`を[`basic_format_context`](basic_format_context.md)`&amp;lt;Out, charT&amp;gt;`
+- `pc`を`PC`のlvalue
+- `fc`を`FC`のlvalue
+- `pc.begin()`は書式文字列中の対応する置換フィールドのオプションの先頭を指す
+- オプションが空なら、`pc.begin() == pc.end()`または`*pc.begin() == &amp;#39;}&amp;#39;`である
+
+
+## メンバ関数
+
+| メンバ関数 | 説明 | 対応バージョン |
+|------------|------|----------------|
+| [`parse`](formatter/parse.md.nolink)   | 書式の解析を行う | C++20 |
+| [`format`](formatter/format.md.nolink) | 書式化を行う | C++20 |
+
+
+### 文字・文字列に対する特殊化
+
+| メンバ関数 | 説明 | 対応バージョン |
+|------------|------|----------------|
+| [`set_debug_format`](formatter/set_debug_format.md.nolink) | デバッグ書式を有効にする | C++23 |
+
+
+### pair / tuple向けの特殊化
+
+| メンバ関数 | 説明 | 対応バージョン |
+|------------|------|----------------|
+| [`set_separator`](formatter/set_separator.md.nolink) | 要素の区切り文字を設定する | C++23 |
+| [`set_brackets`](formatter/set_brackets.md.nolink)   | 全体の囲み文字を設定する | C++23 |
+
 
 ## 例
 ```cpp example
@@ -93,15 +136,15 @@ enum color { red, green, blue };
 
 const char* color_names[] = { &amp;#34;red&amp;#34;, &amp;#34;green&amp;#34;, &amp;#34;blue&amp;#34; };
 
-template&amp;lt;&amp;gt; struct std::formatter&amp;lt;color&amp;gt; : std::formatter&amp;lt;const char*&amp;gt; {
-  auto format(color c, format_context&amp;amp; ctx) {
-    return formatter&amp;lt;const char*&amp;gt;::format(color_names[c], ctx);
+template&amp;lt;&amp;gt;
+struct std::formatter&amp;lt;color&amp;gt; : std::formatter&amp;lt;const char*&amp;gt; {
+  auto format(color c, std::format_context&amp;amp; ctx) const {
+    return std::formatter&amp;lt;const char*&amp;gt;::format(color_names[c], ctx);
   }
 };
 
 int main()
 {
-  int variable = 0;
   std::cout &amp;lt;&amp;lt; std::format(&amp;#34;{}&amp;#34;, red) &amp;lt;&amp;lt; std::endl;
 }
 ```
@@ -117,11 +160,13 @@ red
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): ??
+- [GCC](/implementation.md#gcc): 13
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 ## 参照
-
-* [P0645R10 Text Formatting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html)
-* [{fmt}](https://github.com/fmtlib/fmt)
+- [P0645R10 Text Formatting](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html)
+- [{fmt}](https://github.com/fmtlib/fmt)
+- [P2286R8 Formatting Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html)
+- [P2585R1 Improve default container formatting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2585r1.html)
+    - C++23から、Range・コンテナ、`pair`、`tuple`のフォーマット出力、および文字・文字列のデバッグ指定 (`&amp;#34;?&amp;#34;`) が追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iterator -- Fix typo</title>
      <link href="https://cpprefjp.github.io/reference/ranges/repeat_view/iterator.html"/>
      <id>8d68f98f82d54011721eac4667dd508b81c457ac:reference/ranges/repeat_view/iterator.md</id>
      <updated>2023-01-20T00:26:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/repeat_view/iterator.md b/reference/ranges/repeat_view/iterator.md
index 45f671b71..8116fd500 100644
--- a/reference/ranges/repeat_view/iterator.md
+++ b/reference/ranges/repeat_view/iterator.md
@@ -24,7 +24,7 @@ namespace std::ranges {
   class repeat_view&amp;lt;T, Bound&amp;gt;::iterator {
   private:
     using index_type = conditional_t&amp;lt;same_as&amp;lt;Bound, unreachable_sentinel_t&amp;gt;, ptrdiff_t, Bound&amp;gt;;
-    const T* value_ = nullptr;P
+    const T* value_ = nullptr;
     index_type current_ = index_type();
 
     constexpr explicit iterator(const T* value, index_type b = index_type())
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iterator -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/ranges/repeat_view/iterator.html"/>
      <id>8b51996ff3b9a4b68106d943313e89569da65069:reference/ranges/repeat_view/iterator.md</id>
      <updated>2023-01-19T23:48:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/repeat_view/iterator.md b/reference/ranges/repeat_view/iterator.md
index 69b53a5a0..45f671b71 100644
--- a/reference/ranges/repeat_view/iterator.md
+++ b/reference/ranges/repeat_view/iterator.md
@@ -114,7 +114,7 @@ namespace std::ranges {
 * is-integer-like[link /reference/iterator/is_integer_like.md]
 * repeat_view[link ../repeat_view.md]
 * conditional_t[link /reference/type_traits/conditional.md]
-* ptrdiff_t[link /reference/stddef/ptrdiff_t.md]
+* ptrdiff_t[link /reference/cstddef/ptrdiff_t.md]
 * random_access_iterator_tag[link /reference/iterator/iterator_tag.md]
 * is-signed-integer-like[link /reference/iterator/is_integer_like.md]
 * iota_diff_t[link /reference/ranges/iota_view/iota_diff_t.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges -- repeat_viewの説明を追加</title>
      <link href="https://cpprefjp.github.io/reference/ranges.html"/>
      <id>6634d8587f5b9dbb4dc46f1c792f5d3246fd3fea:reference/ranges.md</id>
      <updated>2023-01-19T23:43:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges.md b/reference/ranges.md
index 855273b0f..cbe100bf3 100644
--- a/reference/ranges.md
+++ b/reference/ranges.md
@@ -150,6 +150,13 @@ Rangeファクトリは、Rangeではないオブジェクトから[`view`](rang
 | [`iota_view`](ranges/iota_view.md)        | 単調増加列であるRange (class template)              | C++20          |
 | [`views::iota`](ranges/iota_view.md)      | `iota_view`を生成する (customization point object)  | C++20          |
 
+### repeat view
+
+| 名前                                          | 説明                                                  | 対応バージョン |
+|-----------------------------------------------|-------------------------------------------------------|----------------|
+| [`repeat_view`](ranges/repeat_view.md)        | 指定した値を指定回数繰り返すRange (class template)    | C++23          |
+| [`views::repeat`](ranges/repeat_view.md)      | `repeat_view`を生成する (customization point object)  | C++23          |
+
 ### istream view
 
 | 名前                                                   | 説明                                                         | 対応バージョン |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>repeat_view -- repeat_viewの説明を追加</title>
      <link href="https://cpprefjp.github.io/reference/ranges/repeat_view.html"/>
      <id>6634d8587f5b9dbb4dc46f1c792f5d3246fd3fea:reference/ranges/repeat_view.md</id>
      <updated>2023-01-19T23:43:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/repeat_view.md b/reference/ranges/repeat_view.md
new file mode 100644
index 000000000..214318809
--- /dev/null
+++ b/reference/ranges/repeat_view.md
@@ -0,0 +1,108 @@
+# repeat_view
+* ranges[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;move_constructible T, semiregular Bound = unreachable_sentinel_t&amp;gt;
+    requires (is_object_v&amp;lt;T&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;T, remove_cv_t&amp;lt;T&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+              (is-integer-like&amp;lt;Bound&amp;gt; || same_as&amp;lt;Bound, unreachable_sentinel_t&amp;gt;))
+  class repeat_view : public view_interface&amp;lt;repeat_view&amp;lt;T, Bound&amp;gt;&amp;gt; { …… }; // (1)
+
+  namespace views {
+    inline constexpr /*unspecified*/ repeat = /*unspecified*/; // (2)
+  }
+}
+```
+* move_constructible[link /reference/concepts/move_constructible.md]
+* semiregular[link /reference/concepts/semiregular.md]
+* unreachable_sentinel_t[link /reference/iterator/unreachable_sentinel_t.md]
+* is_object_v[link /reference/type_traits/is_object.md]
+* same_as[link /reference/concepts/same_as.md]
+* remove_cv_t[link /reference/type_traits/remove_cv.md]
+* is-integer-like[link /reference/iterator/is_integer_like.md]
+* view_interface[link view_interface.md]
+
+## 概要
+- (1): 指定した値を指定回数繰り返す[`view`](view.md)
+- (2): `repeat_view`を生成するカスタマイゼーションポイントオブジェクト
+
+回数を省略した場合、無限長となる。
+
+### Rangeコンセプト
+
+| borrowed | sized | output | input | forward | bidirectional | random_access | contiguous | common | viewable | view |
+|----------|-------|--------|-------|---------|---------------|---------------|------------|--------|----------|------|
+|          | (1)   |        | ○    | ○      | ○            | ○            |            | (1)    | ○       | ○   |
+
+- (1) `Bound = unreachable_sentinel_t` ではない場合
+
+## 効果
+- 式`views::repear(E)`の効果は`repeat_view(E)`と等しい。
+- 式`views::repear(E, F)`の効果は`repeat_view(E, F)`と等しい。
+
+## メンバ関数
+
+| 名前                                             | 説明                             | 対応バージョン |
+|--------------------------------------------------|----------------------------------|----------------|
+| [`(constructor)`](repeat_view/op_constructor.md.nolink)  | コンストラクタ                   | C++23          |
+| [`begin`](repeat_view/begin.md.nolink)                   | 先頭を指すイテレータを取得する   | C++23          |
+| [`end`](repeat_view/end.md.nolink)                       | 番兵を取得する                   | C++23          |
+| [`size`](repeat_view/data.md.nolink)                     | 配列の先頭へのポインタを取得する | C++23          |
+
+## 継承しているメンバ関数
+
+| 名前                                         | 説明                              | 対応バージョン |
+|----------------------------------------------|------------------------------ ----|----------------|
+| [`operator bool`](view_interface/op_bool.md) | Rangeが空でないかどうかを判定する | C++23          |
+| [`front`](view_interface/front.md)           | 先頭要素への参照を取得する        | C++23          |
+| [`back`](view_interface/back.md)             | 末尾要素への参照を取得する        | C++23          |
+| [`operator[]`](view_interface/op_at.md)      | 要素へアクセスする                | C++23          |
+
+## メンバ型
+
+| 名前                                      | 説明                         | 対応バージョン |
+|-------------------------------------------|------------------------------|----------------|
+| [`iterator`](repeat_view/iterator.md)     | イテレータ型(説明専用)       | C++23          |
+
+
+## 推論補助
+
+| 名前                                                  | 説明                         | 対応バージョン |
+|-------------------------------------------------------|------------------------------|----------------|
+| [`(deduction_guide)`](repeat_view/op_deduction_guide.md.nolink) | クラステンプレートの推論補助 | C++23          |
+
+## 例
+```cpp example
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main() {
+  using namespace std;
+
+  for(int n : views::repeat(42, 3)) {
+    cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+}
+```
+* views::repeat[color ff0000]
+
+### 出力
+```
+42 42 42
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ?
+- [GCC](/implementation.md#gcc): ?
+- [ICC](/implementation.md#icc): ?
+- [Visual C++](/implementation.md#visual_cpp): ?
+
+## 参照
+- [N4917 26 Ranges library](https://timsong-cpp.github.io/cppwp/ranges)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iterator -- repeat_viewの説明を追加</title>
      <link href="https://cpprefjp.github.io/reference/ranges/repeat_view/iterator.html"/>
      <id>6634d8587f5b9dbb4dc46f1c792f5d3246fd3fea:reference/ranges/repeat_view/iterator.md</id>
      <updated>2023-01-19T23:43:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/repeat_view/iterator.md b/reference/ranges/repeat_view/iterator.md
new file mode 100644
index 000000000..69b53a5a0
--- /dev/null
+++ b/reference/ranges/repeat_view/iterator.md
@@ -0,0 +1,135 @@
+# iterator
+* ranges[meta header]
+* std::ranges[meta namespace]
+* repeat_view[meta class]
+* class template[meta id-type]
+* cpp23[meta cpp]
+
+## 概要
+
+[`repeat_view`](../repeat_view.md)のイテレータ。
+
+このクラスの名前は規定されておらず、振る舞いのみが規定されている。
+
+このクラスの型を取得したい場合、[`iterator_t`](../iterator_t.md)を使用できる。
+
+
+## 実装例
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;move_constructible T, semiregular Bound = unreachable_sentinel_t&amp;gt;
+    requires (is_object_v&amp;lt;T&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;T, remove_cv_t&amp;lt;T&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+              (is-integer-like&amp;lt;Bound&amp;gt; || same_as&amp;lt;Bound, unreachable_sentinel_t&amp;gt;))
+  class repeat_view&amp;lt;T, Bound&amp;gt;::iterator {
+  private:
+    using index_type = conditional_t&amp;lt;same_as&amp;lt;Bound, unreachable_sentinel_t&amp;gt;, ptrdiff_t, Bound&amp;gt;;
+    const T* value_ = nullptr;P
+    index_type current_ = index_type();
+
+    constexpr explicit iterator(const T* value, index_type b = index_type())
+      : value_{value}
+      , current_{b}
+    {
+    }
+
+  public:
+    using iterator_concept = random_access_iterator_tag;
+    using iterator_category = random_access_iterator_tag;
+    using value_type = T;
+    using difference_type = conditional_t&amp;lt;is-signed-integer-like&amp;lt;index_type&amp;gt;,
+        index_type,
+        iota_diff_t(index_type)&amp;gt;;
+
+    iterator() = default;
+
+    constexpr const T&amp;amp; operator*() const noexcept {
+      return *value_;
+    }
+
+    constexpr iterator&amp;amp; operator++() {
+      ++current_;
+      return *this;
+    }
+    constexpr iterator operator++(int) {
+      auto tmp = *this;
+      ++*this;
+      return tmp;
+    }
+
+    constexpr iterator&amp;amp; operator--() {
+      --current_;
+      return *this;
+    }
+    constexpr iterator operator--(int) {
+      auto tmp = *this;
+      --*this;
+      return tmp;
+    }
+
+    constexpr iterator&amp;amp; operator+=(difference_type n) {
+      current_ += n;
+      return *this;
+    }
+    constexpr iterator&amp;amp; operator-=(difference_type n) {
+      current_ -= n;
+      return *this;
+    }
+    constexpr const T&amp;amp; operator[](difference_type n) const noexcept {
+      return *(*this + n);
+    }
+
+    friend constexpr bool operator==(const iterator&amp;amp; x, const iterator&amp;amp; y) {
+      return x.current_ == y.current_;
+    }
+    friend constexpr auto operator&amp;lt;=&amp;gt;(const iterator&amp;amp; x, const iterator&amp;amp; y) {
+      return x.current_ &amp;lt;=&amp;gt; y.current_;
+    }
+
+    friend constexpr iterator operator+(iterator i, difference_type n) {
+      i += n;
+      return i;
+    }
+    friend constexpr iterator operator+(difference_type n, iterator i) {
+      i += n;
+      return i;
+    }
+
+    friend constexpr iterator operator-(iterator i, difference_type n) {
+      i -= n;
+      return i;
+    }
+    friend constexpr difference_type operator-(const iterator&amp;amp; x, const iterator&amp;amp; y) {
+      return static_cast&amp;lt;difference_type&amp;gt;(x.current_) - static_cast&amp;lt;difference_type&amp;gt;(y.current_);
+    }
+  };
+}
+```
+* move_constructible[link /reference/concepts/move_constructible.md]
+* semiregular[link /reference/concepts/semiregular.md]
+* unreachable_sentinel_t[link /reference/iterator/unreachable_sentinel_t.md]
+* is_object_v[link /reference/type_traits/is_object.md]
+* same_as[link /reference/concepts/same_as.md]
+* remove_cv_t[link /reference/type_traits/remove_cv.md]
+* is-integer-like[link /reference/iterator/is_integer_like.md]
+* repeat_view[link ../repeat_view.md]
+* conditional_t[link /reference/type_traits/conditional.md]
+* ptrdiff_t[link /reference/stddef/ptrdiff_t.md]
+* random_access_iterator_tag[link /reference/iterator/iterator_tag.md]
+* is-signed-integer-like[link /reference/iterator/is_integer_like.md]
+* iota_diff_t[link /reference/ranges/iota_view/iota_diff_t.md]
+* incrementable[link /reference/iterator/incrementable.md]
+* weakly-equality-comparable-with[link /reference/concepts/equality_comparable.md]
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ?
+- [GCC](/implementation.md#gcc): ?
+- [ICC](/implementation.md#icc): ?
+- [Visual C++](/implementation.md#visual_cpp): ?
+
+## 参照
+- [N4917 26 Ranges library](https://timsong-cpp.github.io/cppwp/ranges)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変長データを扱うクラスの効率的な`delete` -- 可変長データを扱うクラスの効率的なdelete : 修正と追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.html"/>
      <id>84f996ba10e58682f9cb49fa77382f745e3b71a9:lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md</id>
      <updated>2023-01-19T18:27:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md b/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
index 913238ea8..2d16ae931 100644
--- a/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
+++ b/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
@@ -14,7 +14,7 @@ struct S {
   // #1 Sのための operator delete オーバーロード
   void operator delete(void* p) {
     // Sのオブジェクトは破棄済みのため、未定義動作となる
-    const S&amp;amp; self = *p;       // UB
+    const S* self = reinterpret_cast&amp;lt;const S*&amp;gt;(p);  // UB
     std::cout &amp;lt;&amp;lt; self-&amp;gt;str;   // UB
 
     // メモリ領域の解放
@@ -69,7 +69,7 @@ int main() {
 
 ## 仕様
 
-クラススコープで定義された`operator delete()`で、第二引数が`std::destroying_delete_t`であるものを*destroying operator delete*と呼ぶ。クラス`C`に対する*destroying operator delete*の第一引数は`C*`でなければならず、その2点以外は通常の`operator delete`オーバーロードの制約に従う。
+クラススコープで定義された`operator delete()`で、第二引数が`std::destroying_delete_t`であるものを*destroying operator delete*と呼ぶ。クラス`C`に対する*destroying operator delete*の第一引数は`C*`でなければならず、それらの点以外は通常の`operator delete`オーバーロードの制約に従う。
 
 ```cpp
 struct S {
@@ -126,7 +126,7 @@ struct S {
 
 *destroying operator delete*が`operator delete`として使用される`delete`式の実行において、`delete`式は`delete`対象オブジェクトのデストラクタを呼び出さないで`operator delete`を呼び出す。また、その際の*destroying operator delete*の第二引数（`std::destroying_delete_t`に対応する引数）に渡される値は未規定。
 
-`delete`式に指定されているポインタの指すオブジェクトがクラス型であり、そのデストラクタが仮想デストラクタである場合、その`delete`式の実行に伴う`operator delete`の探索はそのオブジェクトの動的型（実行時の実際のクラス型）のスコープで行われる。この探索は、クラスの仮想関数を基底クラスから呼び出す時と同じものである。
+*destroying operator delete*に限らず全ての`operator delete`オーバーロードにおいて、`delete`式に指定されているポインタの指すオブジェクトがクラス型であり、そのデストラクタが仮想デストラクタである場合、その`delete`式の実行に伴う`operator delete`の探索はそのオブジェクトの動的型（実行時の実際のクラス型）のスコープで行われる。この探索は、クラスの仮想関数を基底クラスから呼び出す時と同じものである。
 
 ```cpp
 // 基底クラス
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>