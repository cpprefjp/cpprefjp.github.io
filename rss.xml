<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-12-17T14:44:25.002240</updated>
  <id>81716fa6-cb8e-42c9-ab50-87744d149f54</id>

  
    <entry>
      <title>gps_clock -- Merge pull request #1369 from cpprefjp/refine-tai-gps-clock</title>
      <link href="https://cpprefjp.github.io/reference/chrono/gps_clock.html"/>
      <id>b8d44bcf4e1b1bbb6f9aff5e3c6093f8e704d91b:reference/chrono/gps_clock.md</id>
      <updated>2024-12-17T23:16:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/gps_clock.md b/reference/chrono/gps_clock.md
index 3cdab5a04..5a1dac30e 100644
--- a/reference/chrono/gps_clock.md
+++ b/reference/chrono/gps_clock.md
@@ -13,19 +13,23 @@ namespace std::chrono {
 ## 概要
 `gps_clock`は、GPS時間 (GPST) を表現するためのクロックである。この時刻系は、カーナビや携帯端末などで使用される。
 
+GPS時間ではうるう秒 (leap second) 補正が行われないため、2017年1月1日以降～2024年現在ではUTC (世界協定時) よりも18秒進んだ時間をとる。
+つまり 2024-01-01 00:00:18 GPS と 2024-01-01 00:00:00 UTC は等価である。
+
 このクラスの[`now()`](gps_clock/now.md)静的メンバ関数は、標準では`noexcept(false)`である。実装が`noexcept(true)`である保証をしない限り、このクラスはTrivialClock要件を満たさない。
 
 
 ### エポック
 クロックごとの初期時間 (内部的にカウンタがあれば値ゼロ) をエポックと呼ぶ。
 
-`gps_clock`のエポックは、1980年1月6日 (この年の最初の日曜日) 0時0分0秒である。
+`gps_clock`のエポックは、1980年1月6日 (同年の最初の日曜日) 0時0分0秒である。
 
 
 ### うるう秒の扱い
-このクロックではうるう秒は挿入されず、うるう秒の数だけ時間が進む。そのため、UTCにうるう秒が挿入されるたびに、UTCはGPSよりも1秒ずつずれていく。
+`gps_clock`ではうるう秒は考慮されず、UTCに対してうるう秒分だけ時間がシフトする。そのため、UTCに正のうるう秒が挿入されるたびに、UTC時間はGPS時間よりも1秒ずつ遅れていく。
 
-GPS時間とTAI時間は19秒ずれていて、このずれは時間が経過しても変わらない。GPS時間のエポックが[`1958y`](year/op_y.md)`/`[`January`](month_constants.md)`/1`、TAI時間のエポックが[`1980y`](year/op_y.md)`/`[`January`](month_constants.md)`/`[`Sunday`](weekday_constants.md)`[1]`であるが、1958年から1970年までのオフセットが10秒と、1970年から1980年までに挿入されたうるう秒が9秒あるためだ。
+同じくうるう秒を考慮しない[TAI時間](tai_clock.md)に対してGPS時間は19秒遅れており、このずれは時間が経過しても変わらない。これはTAI時間のエポックが[`1958y`](year/op_y.md)`/`[`January`](month_constants.md)`/1`、GPS時間のエポックが[`1980y`](year/op_y.md)`/`[`January`](month_constants.md)`/`[`Sunday`](weekday_constants.md)`[1]`であるが、1958年から1970年までのオフセットが10秒と、1970年から1980年までに挿入されたうるう秒が9秒あるためだ。
+(1970年はTAI時間が定められた年である。)
 
 
 ## メンバ関数
@@ -56,6 +60,7 @@ GPS時間とTAI時間は19秒ずれていて、このずれは時間が経過し
 
 
 ## 例
+### 例1: 現在GPS時間
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;chrono&amp;gt;
@@ -68,20 +73,47 @@ int main()
   std::cout &amp;lt;&amp;lt; tp &amp;lt;&amp;lt; std::endl;
 }
 ```
+* chrono::gps_clock[color ff0000]
 * now()[link gps_clock/now.md]
 
-### 出力例
+#### 出力例
 ```
 2019-10-24 11:15:37.493236171
 ```
 
+### 例2: うるう秒の影響
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+
+namespace chrono = std::chrono;
+using namespace std::literals::chrono_literals;
+
+int main() {
+  auto utc_tp = chrono::utc_clock::from_sys(chrono::sys_days{2024y/1/1});
+  auto gps_tp = chrono::gps_clock::from_utc(utc_tp);
+  std::cout &amp;lt;&amp;lt; utc_tp &amp;lt;&amp;lt; &amp;#34; UTC&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; gps_tp &amp;lt;&amp;lt; &amp;#34; GPS&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* chrono::gps_clock[color ff0000]
+* from_sys[link utc_clock/from_sys.md]
+* from_utc[link gps_clock/from_utc.md]
+
+#### 出力
+```
+2024-01-01 00:00:00 UTC
+2024-01-01 00:00:18 GPS
+```
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): 9.0 [mark noimpl]
-- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.1 [mark verified]
+- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.2 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 3 [mark noimpl]
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tai_clock -- Merge pull request #1369 from cpprefjp/refine-tai-gps-clock</title>
      <link href="https://cpprefjp.github.io/reference/chrono/tai_clock.html"/>
      <id>b8d44bcf4e1b1bbb6f9aff5e3c6093f8e704d91b:reference/chrono/tai_clock.md</id>
      <updated>2024-12-17T23:16:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/tai_clock.md b/reference/chrono/tai_clock.md
index 5d281f66e..30d8cfa41 100644
--- a/reference/chrono/tai_clock.md
+++ b/reference/chrono/tai_clock.md
@@ -13,7 +13,8 @@ namespace std::chrono {
 ## 概要
 `tai_clock`は、TAI時間 (国際原子時、International Atomic Time) を表現するためのクロックである。
 
-このクロックは、UTCよりも10秒進んでいる。そのため、1958-01-01 00:00:00 TAIと1957-12-31 23:59:50 UTCは等価である。
+TAIではうるう秒 (leap second) 補正が行われないため、2017年1月1日以降～2024年現在ではUTC (世界協定時) よりも37秒進んだ時間をとる。
+つまり 2024-01-01 00:00:37 TAI と 2024-01-01 00:00:00 UTC は等価である。
 
 
 このクラスの[`now()`](tai_clock/now.md)静的メンバ関数は、標準では`noexcept(false)`である。実装が`noexcept(true)`である保証をしない限り、このクラスはTrivialClock要件を満たさない。
@@ -23,12 +24,13 @@ namespace std::chrono {
 クロックごとの初期時間 (内部的にカウンタがあれば値ゼロ) をエポックと呼ぶ。
 
 `tai_clock`のエポックは、1958年1月1日0時0分0秒である。
+これはUTC時間1957年12月31日23時59分50秒に対応する。
 
 
 ### うるう秒の扱い
-このクロックではうるう秒は挿入されず、うるう秒の数だけ時間が進む。そのため、UTCにうるう秒が挿入されるたびに、UTCはTAIよりも1秒ずつずれていく。
+`tai_clock`ではうるう秒は考慮されず、UTCに対してうるう秒数分だけ時間がシフトする。そのため、UTCに正のうるう秒が挿入されるたびに、UTC時間はTAI時間よりも1秒ずつ遅れていく。
 
-例として、2000年01月01日までに正のうるう秒が22回、負のうるう秒が0回挿入されたため、TAIがUTCより10秒進んでいることも含めて、2000-01-01 00:00:00 UTCと2000-01-01 00:00:32 TAIは等価となる。
+例として、`tai_clock`エポック日 (1958年1月1日) 時点ではUTCには正のうるう秒が10回挿入されており、さらに2000年01月01日までに正のうるう秒が22回、負のうるう秒が0回挿入されたため、2000-01-01 00:00:00 UTCと2000-01-01 00:00:32 TAIは等価となる。
 
 
 ## メンバ関数
@@ -59,6 +61,7 @@ namespace std::chrono {
 
 
 ## 例
+### 例1: 現在TAI時間
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;chrono&amp;gt;
@@ -71,23 +74,51 @@ int main()
   std::cout &amp;lt;&amp;lt; tp &amp;lt;&amp;lt; std::endl;
 }
 ```
+* chrono::tai_clock[color ff0000]
 * now()[link tai_clock/now.md]
 
-### 出力例
+#### 出力例
 ```
-2019-10-24 11:15:47 TAI
+2019-10-24 11:15:47.519957239
 ```
 
+### 例2: うるう秒の影響
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+
+namespace chrono = std::chrono;
+using namespace std::literals::chrono_literals;
+
+int main() {
+  auto utc_tp = chrono::utc_clock::from_sys(chrono::sys_days{2024y/1/1});
+  auto tai_tp = chrono::tai_clock::from_utc(utc_tp);
+  std::cout &amp;lt;&amp;lt; utc_tp &amp;lt;&amp;lt; &amp;#34; UTC&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; tai_tp &amp;lt;&amp;lt; &amp;#34; TAI&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* chrono::tai_clock[color ff0000]
+* from_sys[link utc_clock/from_sys.md]
+* from_utc[link tai_clock/from_utc.md]
+
+#### 出力
+```
+2024-01-01 00:00:00 UTC
+2024-01-01 00:00:37 TAI
+```
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): 9.0 [mark noimpl]
-- [GCC](/implementation.md#gcc): 9.2 [mark noimpl]
+- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.2 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 3 [mark noimpl]
 
 
 ## 参照
 - [国際原子時 - Wikipedia](https://ja.wikipedia.org/wiki/国際原子時)
+- [国立天文台 水沢, うるう秒について](https://www.miz.nao.ac.jp/vlbi/leapsec.html)
 - [LWG Issue 3359. `&amp;lt;chrono&amp;gt;` leap second support should allow for negative leap seconds](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2117r0.html#3359)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gps_clock -- chrono/{tai,gps}_clock: クラス説明を増補</title>
      <link href="https://cpprefjp.github.io/reference/chrono/gps_clock.html"/>
      <id>86f0c41afc9742a6aca155df7cdcce3f5ddb08ff:reference/chrono/gps_clock.md</id>
      <updated>2024-12-16T17:44:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/gps_clock.md b/reference/chrono/gps_clock.md
index 3cdab5a04..5a1dac30e 100644
--- a/reference/chrono/gps_clock.md
+++ b/reference/chrono/gps_clock.md
@@ -13,19 +13,23 @@ namespace std::chrono {
 ## 概要
 `gps_clock`は、GPS時間 (GPST) を表現するためのクロックである。この時刻系は、カーナビや携帯端末などで使用される。
 
+GPS時間ではうるう秒 (leap second) 補正が行われないため、2017年1月1日以降～2024年現在ではUTC (世界協定時) よりも18秒進んだ時間をとる。
+つまり 2024-01-01 00:00:18 GPS と 2024-01-01 00:00:00 UTC は等価である。
+
 このクラスの[`now()`](gps_clock/now.md)静的メンバ関数は、標準では`noexcept(false)`である。実装が`noexcept(true)`である保証をしない限り、このクラスはTrivialClock要件を満たさない。
 
 
 ### エポック
 クロックごとの初期時間 (内部的にカウンタがあれば値ゼロ) をエポックと呼ぶ。
 
-`gps_clock`のエポックは、1980年1月6日 (この年の最初の日曜日) 0時0分0秒である。
+`gps_clock`のエポックは、1980年1月6日 (同年の最初の日曜日) 0時0分0秒である。
 
 
 ### うるう秒の扱い
-このクロックではうるう秒は挿入されず、うるう秒の数だけ時間が進む。そのため、UTCにうるう秒が挿入されるたびに、UTCはGPSよりも1秒ずつずれていく。
+`gps_clock`ではうるう秒は考慮されず、UTCに対してうるう秒分だけ時間がシフトする。そのため、UTCに正のうるう秒が挿入されるたびに、UTC時間はGPS時間よりも1秒ずつ遅れていく。
 
-GPS時間とTAI時間は19秒ずれていて、このずれは時間が経過しても変わらない。GPS時間のエポックが[`1958y`](year/op_y.md)`/`[`January`](month_constants.md)`/1`、TAI時間のエポックが[`1980y`](year/op_y.md)`/`[`January`](month_constants.md)`/`[`Sunday`](weekday_constants.md)`[1]`であるが、1958年から1970年までのオフセットが10秒と、1970年から1980年までに挿入されたうるう秒が9秒あるためだ。
+同じくうるう秒を考慮しない[TAI時間](tai_clock.md)に対してGPS時間は19秒遅れており、このずれは時間が経過しても変わらない。これはTAI時間のエポックが[`1958y`](year/op_y.md)`/`[`January`](month_constants.md)`/1`、GPS時間のエポックが[`1980y`](year/op_y.md)`/`[`January`](month_constants.md)`/`[`Sunday`](weekday_constants.md)`[1]`であるが、1958年から1970年までのオフセットが10秒と、1970年から1980年までに挿入されたうるう秒が9秒あるためだ。
+(1970年はTAI時間が定められた年である。)
 
 
 ## メンバ関数
@@ -56,6 +60,7 @@ GPS時間とTAI時間は19秒ずれていて、このずれは時間が経過し
 
 
 ## 例
+### 例1: 現在GPS時間
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;chrono&amp;gt;
@@ -68,20 +73,47 @@ int main()
   std::cout &amp;lt;&amp;lt; tp &amp;lt;&amp;lt; std::endl;
 }
 ```
+* chrono::gps_clock[color ff0000]
 * now()[link gps_clock/now.md]
 
-### 出力例
+#### 出力例
 ```
 2019-10-24 11:15:37.493236171
 ```
 
+### 例2: うるう秒の影響
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+
+namespace chrono = std::chrono;
+using namespace std::literals::chrono_literals;
+
+int main() {
+  auto utc_tp = chrono::utc_clock::from_sys(chrono::sys_days{2024y/1/1});
+  auto gps_tp = chrono::gps_clock::from_utc(utc_tp);
+  std::cout &amp;lt;&amp;lt; utc_tp &amp;lt;&amp;lt; &amp;#34; UTC&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; gps_tp &amp;lt;&amp;lt; &amp;#34; GPS&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* chrono::gps_clock[color ff0000]
+* from_sys[link utc_clock/from_sys.md]
+* from_utc[link gps_clock/from_utc.md]
+
+#### 出力
+```
+2024-01-01 00:00:00 UTC
+2024-01-01 00:00:18 GPS
+```
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): 9.0 [mark noimpl]
-- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.1 [mark verified]
+- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.2 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 3 [mark noimpl]
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tai_clock -- chrono/{tai,gps}_clock: クラス説明を増補</title>
      <link href="https://cpprefjp.github.io/reference/chrono/tai_clock.html"/>
      <id>86f0c41afc9742a6aca155df7cdcce3f5ddb08ff:reference/chrono/tai_clock.md</id>
      <updated>2024-12-16T17:44:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/tai_clock.md b/reference/chrono/tai_clock.md
index 5d281f66e..30d8cfa41 100644
--- a/reference/chrono/tai_clock.md
+++ b/reference/chrono/tai_clock.md
@@ -13,7 +13,8 @@ namespace std::chrono {
 ## 概要
 `tai_clock`は、TAI時間 (国際原子時、International Atomic Time) を表現するためのクロックである。
 
-このクロックは、UTCよりも10秒進んでいる。そのため、1958-01-01 00:00:00 TAIと1957-12-31 23:59:50 UTCは等価である。
+TAIではうるう秒 (leap second) 補正が行われないため、2017年1月1日以降～2024年現在ではUTC (世界協定時) よりも37秒進んだ時間をとる。
+つまり 2024-01-01 00:00:37 TAI と 2024-01-01 00:00:00 UTC は等価である。
 
 
 このクラスの[`now()`](tai_clock/now.md)静的メンバ関数は、標準では`noexcept(false)`である。実装が`noexcept(true)`である保証をしない限り、このクラスはTrivialClock要件を満たさない。
@@ -23,12 +24,13 @@ namespace std::chrono {
 クロックごとの初期時間 (内部的にカウンタがあれば値ゼロ) をエポックと呼ぶ。
 
 `tai_clock`のエポックは、1958年1月1日0時0分0秒である。
+これはUTC時間1957年12月31日23時59分50秒に対応する。
 
 
 ### うるう秒の扱い
-このクロックではうるう秒は挿入されず、うるう秒の数だけ時間が進む。そのため、UTCにうるう秒が挿入されるたびに、UTCはTAIよりも1秒ずつずれていく。
+`tai_clock`ではうるう秒は考慮されず、UTCに対してうるう秒数分だけ時間がシフトする。そのため、UTCに正のうるう秒が挿入されるたびに、UTC時間はTAI時間よりも1秒ずつ遅れていく。
 
-例として、2000年01月01日までに正のうるう秒が22回、負のうるう秒が0回挿入されたため、TAIがUTCより10秒進んでいることも含めて、2000-01-01 00:00:00 UTCと2000-01-01 00:00:32 TAIは等価となる。
+例として、`tai_clock`エポック日 (1958年1月1日) 時点ではUTCには正のうるう秒が10回挿入されており、さらに2000年01月01日までに正のうるう秒が22回、負のうるう秒が0回挿入されたため、2000-01-01 00:00:00 UTCと2000-01-01 00:00:32 TAIは等価となる。
 
 
 ## メンバ関数
@@ -59,6 +61,7 @@ namespace std::chrono {
 
 
 ## 例
+### 例1: 現在TAI時間
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;chrono&amp;gt;
@@ -71,23 +74,51 @@ int main()
   std::cout &amp;lt;&amp;lt; tp &amp;lt;&amp;lt; std::endl;
 }
 ```
+* chrono::tai_clock[color ff0000]
 * now()[link tai_clock/now.md]
 
-### 出力例
+#### 出力例
 ```
-2019-10-24 11:15:47 TAI
+2019-10-24 11:15:47.519957239
 ```
 
+### 例2: うるう秒の影響
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+
+namespace chrono = std::chrono;
+using namespace std::literals::chrono_literals;
+
+int main() {
+  auto utc_tp = chrono::utc_clock::from_sys(chrono::sys_days{2024y/1/1});
+  auto tai_tp = chrono::tai_clock::from_utc(utc_tp);
+  std::cout &amp;lt;&amp;lt; utc_tp &amp;lt;&amp;lt; &amp;#34; UTC&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; tai_tp &amp;lt;&amp;lt; &amp;#34; TAI&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* chrono::tai_clock[color ff0000]
+* from_sys[link utc_clock/from_sys.md]
+* from_utc[link tai_clock/from_utc.md]
+
+#### 出力
+```
+2024-01-01 00:00:00 UTC
+2024-01-01 00:00:37 TAI
+```
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): 9.0 [mark noimpl]
-- [GCC](/implementation.md#gcc): 9.2 [mark noimpl]
+- [GCC](/implementation.md#gcc): 9.2 [mark noimpl], 13.2 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): 2019 Update 3 [mark noimpl]
 
 
 ## 参照
 - [国際原子時 - Wikipedia](https://ja.wikipedia.org/wiki/国際原子時)
+- [国立天文台 水沢, うるう秒について](https://www.miz.nao.ac.jp/vlbi/leapsec.html)
 - [LWG Issue 3359. `&amp;lt;chrono&amp;gt;` leap second support should allow for negative leap seconds](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2117r0.html#3359)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>属性構文 [N2761] -- C++11 属性構文 : indeterminate属性の解説ページにリンク</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/attributes.html"/>
      <id>b956b7708095b80da1c364a4d68cc66d65bde231:lang/cpp11/attributes.md</id>
      <updated>2024-12-16T16:36:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/attributes.md b/lang/cpp11/attributes.md
index 1a15b8ba0..b48a93794 100644
--- a/lang/cpp11/attributes.md
+++ b/lang/cpp11/attributes.md
@@ -170,6 +170,7 @@ C++11で採用されたもの以外で検討された以下の機能は、属性
 - [C++20 属性の名前空間を予約](/lang/cpp20/reserving_attribute_namespaces_for_future_use.md)
 - [C++23 ラムダ式に対する属性](/lang/cpp23/attributes_on_lambda_expressions.md)
 - [C++26 構造化束縛への属性を許可](/lang/cpp26/attributes_for_structured_bindings.md)
+- [C++26 未初期化変数の読み取りをエラー性動作とする (`[[indeterminate]]`属性)](/lang/cpp26/erroneous_behavior_for_uninitialized_reads.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化変数の読み取りをエラー性動作とする [P2795R5] -- C++11 属性構文 : indeterminate属性の解説ページにリンク</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/erroneous_behavior_for_uninitialized_reads.html"/>
      <id>b956b7708095b80da1c364a4d68cc66d65bde231:lang/cpp26/erroneous_behavior_for_uninitialized_reads.md</id>
      <updated>2024-12-16T16:36:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/erroneous_behavior_for_uninitialized_reads.md b/lang/cpp26/erroneous_behavior_for_uninitialized_reads.md
index 79b80c7ac..4f118a77d 100644
--- a/lang/cpp26/erroneous_behavior_for_uninitialized_reads.md
+++ b/lang/cpp26/erroneous_behavior_for_uninitialized_reads.md
@@ -137,5 +137,8 @@ int main() {
 | 契約違反 | 契約に関する現在の策定作業では、契約違反時になにが起こるべきかという問題に直面している。エラー性動作という概念は有用な回答を与えてくれる可能性がある |
 
 
+## 関連項目
+- [C++11 属性構文](/lang/cpp11/attributes.md)
+
 ## 参照
 - [P2795R5 Erroneous behaviour for uninitialized reads](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2795r5.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>jthread -- jthread: コード修飾ミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/thread/jthread.html"/>
      <id>073c4bc6ac4734a56d512f81872f87fa12538db3:reference/thread/jthread.md</id>
      <updated>2024-12-16T10:59:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/thread/jthread.md b/reference/thread/jthread.md
index 9ba75dc41..bd9afa005 100644
--- a/reference/thread/jthread.md
+++ b/reference/thread/jthread.md
@@ -114,7 +114,7 @@ int main()
 ```
 * std::uint64_t[link /reference/cstdint/uint64_t.md]
 * std::stop_token[link /reference/stop_token/stop_token.md]
-* token.stop_requested()[link /reference/stop_token/stop_token/stop_requested.md]
+* stoken.stop_requested()[link /reference/stop_token/stop_token/stop_requested.md]
 * std::this_thread::sleep_for[link /reference/thread/this_thread/sleep_for.md]
 * t1.request_stop()[link jthread/request_stop.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- jthread: コード修飾ミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/thread/jthread/op_constructor.html"/>
      <id>073c4bc6ac4734a56d512f81872f87fa12538db3:reference/thread/jthread/op_constructor.md</id>
      <updated>2024-12-16T10:59:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/thread/jthread/op_constructor.md b/reference/thread/jthread/op_constructor.md
index d6d6cee7a..f8f6b19ef 100644
--- a/reference/thread/jthread/op_constructor.md
+++ b/reference/thread/jthread/op_constructor.md
@@ -145,7 +145,7 @@ int main()
 ```
 * std::uint64_t[link /reference/cstdint/uint64_t.md]
 * std::stop_token[link /reference/stop_token/stop_token.md]
-* token.stop_requested()[link /reference/stop_token/stop_token/stop_requested.md]
+* stoken.stop_requested()[link /reference/stop_token/stop_token/stop_requested.md]
 * std::this_thread::sleep_for[link /reference/thread/this_thread/sleep_for.md]
 * t1.request_stop()[link request_stop.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- jthread::コンストラクタ : 表示崩れを修正</title>
      <link href="https://cpprefjp.github.io/reference/thread/jthread/op_constructor.html"/>
      <id>8cf3afda9d84d4b11909769986c644ae3095976c:reference/thread/jthread/op_constructor.md</id>
      <updated>2024-12-16T10:51:53+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/thread/jthread/op_constructor.md b/reference/thread/jthread/op_constructor.md
index e56789e7a..d6d6cee7a 100644
--- a/reference/thread/jthread/op_constructor.md
+++ b/reference/thread/jthread/op_constructor.md
@@ -60,14 +60,11 @@ jthread(jthread&amp;amp;&amp;amp;) noexcept;             // (4) C++20
         * std::forward[link /reference/utility/forward.md]
 
     - この呼び出しでの戻り値は無視される。この関数呼び出しが例外を送出する場合、呼び出し元スレッドで[`std::terminate`](/reference/exception/terminate.md)が呼び出される
-- (3) :
 
 
 ## 同期
 - (2) : コンストラクタ呼び出しの完了は、`f`のコピーの呼び出し開始と同期する
-
-
-新しいスレッドを生成し、[`INVOKE`](/reference/concepts/Invoke.md)`(DECAY_COPY(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;F&amp;gt;(f)), DECAY_COPY(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args))...)`を実行する。ただし`DECAY_COPY`は同コンストラクタを呼び出したスレッド上にて評価される。また`f`のコピーの戻り値は無視される。
+    新しいスレッドを生成し、[`INVOKE`](/reference/concepts/Invoke.md)`(DECAY_COPY(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;F&amp;gt;(f)), DECAY_COPY(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args))...)`を実行する。ただし`DECAY_COPY`は同コンストラクタを呼び出したスレッド上にて評価される。また`f`のコピーの戻り値は無視される。
     - `DECAY_COPY(x)`は `template &amp;lt;class T&amp;gt; typename std::decay&amp;lt;T&amp;gt;::type decay_copy(T&amp;amp;&amp;amp; v) { return` [`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(v); }` と定義される。おおよそ、`x`が配列型なら先頭要素へのポインタ、`x`が関数型ならその関数ポインタ、`x`がコピーコンストラクト可能な型なら`x`からコピーされたオブジェクト、`x`がムーブコンストラクト可能な型なら`x`からムーブされたオブジェクトとなる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>