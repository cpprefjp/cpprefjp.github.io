<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-27T09:18:52.125406</updated>
  <id>3ef65a4c-03d4-4a47-b5c1-dfc380a500b7</id>

  
    <entry>
      <title>厳密な式の評価順 -- expression_evaluation_order: 調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/expression_evaluation_order.html"/>
      <id>8dbd27843b8385284a601eed184bf5e25e6f4d23:lang/cpp17/expression_evaluation_order.md</id>
      <updated>2021-05-27T18:13:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/expression_evaluation_order.md b/lang/cpp17/expression_evaluation_order.md
index 9be20dc13..ba082317b 100644
--- a/lang/cpp17/expression_evaluation_order.md
+++ b/lang/cpp17/expression_evaluation_order.md
@@ -4,18 +4,19 @@
 ## 概要
 
 C++14までは式の評価順序が未規定（unspecified）であったが、
-C++17では次の式は全てa, bの順で評価されるように定義された。
+C++17では次の式は全て`a`, `b`の順で評価されるように定義された。
 
-1. a.b
-1. a-&amp;gt;b
-1. a-&amp;gt;*b
-1. a(b1, b2, b3)
-1. b @= a
-1. a[b]
-1. a &amp;lt;&amp;lt; b
-1. a &amp;gt;&amp;gt; b
+1. `a.b`
+1. `a-&amp;gt;b`
+1. `a-&amp;gt;*b`
+1. `a(b1, b2, b3)`
+1. `b @= a`
+1. `a[b]`
+1. `a &amp;lt;&amp;lt; b`
+1. `a &amp;gt;&amp;gt; b`
 
-関数の引数リスト内の式（上記例で言えばb1, b2, b3）の評価順序は未規定である。
+関数の引数リスト内の式（上記例で言えば`b1`, `b2`, `b3`）の評価順序は未規定である。
+`@=`は代入演算子`=`や任意の複合代入演算子（`+=`, `-=`など）を表す。
 
 
 ## 仕様
@@ -36,7 +37,7 @@ C++17では式の評価順序が下記の通りに定められた。
 
 3番目の規則については、
 代入演算子`operator=`をオーバーロードした場合を考えるとわかりやすいと思う。
-代入演算子は右から左の順、つまりa, bの順で評価される。
+代入演算子は右から左の順、つまり`a`, `b`の順で評価される。
 
 ```cpp
 struct Hoge {
@@ -52,7 +53,7 @@ int main()
 Hogeクラスの代入演算子をオーバーロードすると、
 `b = a;`は`b.operator=(a);`となりメンバ関数呼び出しと等価になる。
 このとき3番目の規則が存在しなかったとすると、メンバ関数呼び出しの規則が適用される。
-メンバ関数呼び出しの評価順序は左から右の順、つまりb, aの順で評価され、
+メンバ関数呼び出しの評価順序は左から右の順、つまり`b`, `a`の順で評価され、
 代入式の評価順序と逆になってしまう。
 
 ```cpp
@@ -117,8 +118,8 @@ int main() {
 ```
 
 下記のプログラムの動作を考える。
-`std::cout`, f, g, hが互いに作用する
-（例えばf, g, h内で`std::cout`に何か出力するなど）場合、
+`std::cout`, `f`, `g`, `h`が互いに作用する
+（例えば`f`, `g`, `h`内で`std::cout`に何か出力するなど）場合、
 このプログラムの動作は不定であった。
 
 シフト演算子は左結合なので`(((std::cout &amp;lt;&amp;lt; f) &amp;lt;&amp;lt; g) &amp;lt;&amp;lt; h)`の順に評価されそうだが、
@@ -137,8 +138,8 @@ std::cout.operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g()).operator&amp;lt;&amp;lt;(h());
 
 このとき`operator&amp;lt;&amp;lt;(f()).operator&amp;lt;&amp;lt;(g())`のように、
 メンバ関数呼び出しの連鎖が発生するが、この評価順は未規定であり、
-右から左、すなわちg, fの順で評価されるかも知れないし、
-左から右、すなわちf, gの順に評価されるかも知れない。
+右から左、すなわち`g`, `f`の順で評価されるかも知れないし、
+左から右、すなわち`f`, `g`の順に評価されるかも知れない。
 
 以上のように、シンプルな代入演算やメンバ関数の連鎖などC++で広く使われている手法でさえ、
 動作結果が不定となってしまう問題がある。
@@ -157,4 +158,4 @@ C++の既存のプログラムを壊すこと無く、なおかつ、
 
 ## 参照
 - [P0145R3 Refining Expression Evaluation Order for Idiomatic C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf)
-- [Wording for Order of Evaluation of Function Arguments](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0400r0.html)
+- [P0400R0 Wording for Order of Evaluation of Function Arguments](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0400r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- P0784R7 : operator newの省略について修正と追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>c44228943d181c419c872b3f3e7ae02c9a6f99ba:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-27T01:00:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index f43fcc721..bae99d54e 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -134,7 +134,7 @@ int main () {
 
 したがって、C++20のコンパイル時動的メモリ確保の仕様では、コンパイル時に確保したメモリ領域を実行時へ持ち越すことはできない。
 
-実際には、これらの定数式中の`new`式の評価は常に省略されている。この省略はC++14より許可されている最適化の一環として行われ、スタック領域などのストレージを別途割り当てることで動的メモリ確保を避けるものである。対応する`delete`式の呼び出しも同様に省略され、定数式においてはメモリの確保と解放が一貫していることのマーカーとしての役割しか持たない。
+実際には、これらの定数式中の`new`式において呼び出される`::operator new()`の評価は常に省略されている。この省略はC++14より許可されている最適化の一環として行われ、スタック領域などのストレージを別途あてがうことで動的メモリ確保を避けるものである。対応する`delete`式における`::operator delete()`の呼び出しも同様に省略され、定数式における`new/delete`式はメモリの確保と解放が一貫していることのマーカーとしての側面が強くなっている。
 
 ```cpp
 constexpr void f() {
@@ -142,12 +142,12 @@ constexpr void f() {
   int* d = new int{2};
   delete d;
 
-  // 次のようなコードと等価になる
+  // たとえば次のようなコードと等価になる
   int d{2};
 }
 ```
 
-実際にはどこのストレージが提供されるかは規定されていない。
+実際にはどこのストレージが提供されるかは実装定義である。
 
 ### `std::allocator/std::allocator_traits`
 
@@ -245,6 +245,10 @@ constexpr int g() {
 
 `destroy_at`には類似のファミリとして[`destroy_n`](/reference/memory/destroy_n.md)と、それらの`range`版があり（あるいは追加され）、`construct_at`も`range`版が同時に追加されるが、それらについても`construct_at/destroy_at`と同様の扱いが可能となる。
 
+`std::allocator::allocate()`はグローバルの`::operator new()`を呼び出すが、この呼び出しは`new`式の時と同様に省略されており、`std::allocator::deallocate()`における`::operator delete()`の呼び出しも省略されている。この2つもまた`new/delete`式と同様に、メモリの確保と解放が一貫していることのマーカーとしての側面が強くなっている。
+
+結局、C++20のコンパイル時動的メモリ確保は定数式にヒープ領域を導入するものではなく、デフォルトの`::operator new`による動的メモリ確保を別の領域をあてがう形に置換することで行われている。
+
 ## この機能が必要になった背景・経緯
 
 `std::vector`をはじめとする可変サイズのコンテナは実行時に非常に有用であるため、同様に定数式においても有用である可能性があり、その必要性がC++コミュニティからも示されいていた（[C++Now 2017: Ben Deane &amp;amp; Jason Turner &amp;#34;constexpr ALL the things!&amp;#34;](https://youtu.be/HMB9oXFobJc)、[P0810R0 constexpr in Practice](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0810r0.pdf)など）。
@@ -341,4 +345,5 @@ int main() {
 - [P0784R6 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r6.html)
 - [P0784R7 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html)
 - [動的メモリー確保 - 江添亮の入門C++](https://ezoeryou.github.io/cpp-intro/#動的メモリー確保)
+- [N3664 Clarifying Memory Allocation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html)
 - [P1974R0 Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- P0784R7 : 追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>ad0646b0e078c6894772d1f63968ee54458d3baf:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-26T17:18:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index fd5182681..f43fcc721 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -155,7 +155,7 @@ constexpr void f() {
 
 `std::allocator/std::allocator_traits`では`new/delete`式とは異なり、メモリの確保・解放（[`allocate`](/reference/memory/allocator/allocate.md)/[`deallocate`](/reference/memory/allocator/deallocate.md)）とその領域へのオブジェクト構築・破棄（[`construct`](/reference/memory/allocator_traits/construct.md)/[`destroy`](/reference/memory/allocator_traits/destroy.md)）の操作が複合していない。オブジェクト構築・破棄においては*placement new*と*pseudo-destructor call*が必要となるが、*placement new*はポインタの再解釈が必要となることから許可されず、そのために不必要であるので*pseudo-destructor call*も許可されない。
 
-代わりに、*placement new*を行うライブラリ機能である[`construct_at`](/reference/memory/construct.md.nolink)を追加し、*pseudo-destructor call*を行う[`destroy_at`](/reference/memory/destroy_at.md)と共に`constexpr`を付加し定数式で使用可能とする。これによって、ポインタ再解釈を回避しつつ*placement new*と*pseudo-destructor call*が定数式で使用可能となる。
+代わりに、*placement new*を行うライブラリ機能である[`construct_at`](/reference/memory/construct.md.nolink)を追加し、*pseudo-destructor call*を行う[`destroy_at`](/reference/memory/destroy_at.md)と共に`constexpr`を付加し定数式で使用可能とする。これらの関数は`void*`ではなく`T*`を取るため、これによってポインタ再解釈を回避しつつ*placement new*と*pseudo-destructor call*が定数式で使用可能となる。
 
 そして、`std::allocator_traits`の`construct`と`destroy`は`construct_at/destroy_at`を呼び出して処理を行うように変更される。なお、これによって実行時の振る舞いが変化することはない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stacktrace_entry -- stacktrace_entry : デストラクタ名のコピペミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/stacktrace/stacktrace_entry.html"/>
      <id>6073b3654bda9980d72c9dd0216737f5270da6b1:reference/stacktrace/stacktrace_entry.md</id>
      <updated>2021-05-26T16:31:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stacktrace/stacktrace_entry.md b/reference/stacktrace/stacktrace_entry.md
index 73e0ded6b..6e0f5e375 100644
--- a/reference/stacktrace/stacktrace_entry.md
+++ b/reference/stacktrace/stacktrace_entry.md
@@ -20,7 +20,7 @@ namespace std {
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
 | [`(constructor)`](stacktrace_entry/op_constructor.md.nolink) | コンストラクタ | C++23 |
-| `~basic_stacktrace();` | デストラクタ | C++23 |
+| `~stacktrace_entry();` | デストラクタ | C++23 |
 | [`operator=`](stacktrace_entry/op_assign.md.nolink) | 代入演算子 | C++23 |
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- 微追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>2cbb478b667ef0d92b5981e72d29e10f77c800bc:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-26T15:30:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index a57a4fb8a..fd5182681 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -321,7 +321,7 @@ int main() {
 
 `std::unique_ptr`ではそれ自身の`const`性が内部のポインタの参照するオブジェクトまで伝播しないため、コンパイル時に確保されたメモリ領域を参照するような`std::unique_ptr`からは、可変な参照を取得できてしまう。上記例のように`std::unique_ptr`がネストしていれば、そのような領域を`delete`することもできてしまっていた。
 
-`std::mark_immutable_if_constexpr()`によるアプローチを標準化委員会が嫌ったことと、2つ目の問題の解決が簡単ではなかった（時間がかかり得た）事から、コンパイル時に確保したメモリを実行時に持ち越すことについてはC++20への導入を見送ることとなった。
+これらの問題について、`std::mark_immutable_if_constexpr()`によるアプローチを標準化委員会が嫌ったことと、2つ目の問題の解決が簡単ではなかった（時間がかかり得た）事から、コンパイル時に確保したメモリを実行時に持ち越すことについてはC++20への導入を見送ることとなった。
 
 ## 関連項目
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>