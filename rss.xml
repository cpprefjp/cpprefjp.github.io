<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-12-28T02:18:02.846208</updated>
  <id>d07ced19-03c5-443b-9a0a-19cb219aea5a</id>

  
    <entry>
      <title>スタイル -- 訳語： rangeの使い分けを記載 #1011</title>
      <link href="https://cpprefjp.github.io/working_style.html"/>
      <id>60acb8b5126f8d3548b943d8934b3bd6f721c085:working_style.md</id>
      <updated>2022-12-28T11:13:33+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;スタイル&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本サイトで作業を行う上でのスタイルです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「である」調&lt;/li&gt;
&lt;li&gt;句読点は「、」「。」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型修飾のスタイル：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A) const T &amp;amp;v&lt;/li&gt;
&lt;li&gt;B) const T&amp;amp; v&lt;/li&gt;
&lt;li&gt;C) const T &amp;amp; v&lt;/li&gt;
&lt;li&gt;D) T const &amp;amp;v&lt;/li&gt;
&lt;li&gt;E) T const&amp;amp; v&lt;/li&gt;
&lt;li&gt;F) T const &amp;amp; v&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本サイトでは、Bのスタイルで型修飾を行います。&lt;/p&gt;
&lt;h2&gt;バージョンの表記&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;p&gt;C++11以降対応については対応バージョンを明記します。バージョン表記が省略されている場合、C++03、C++98対応であることを表します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;li&gt;C++14&lt;/li&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;li&gt;C++03&lt;/li&gt;
&lt;li&gt;C++98&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;p&gt;開発環境の表記がない場合は、C++98対応のあらゆる環境で使用できるものとします。 
処理系の記載は、作業者が確認できたものを記載します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Clang: 2.1, 2.8&lt;/li&gt;
&lt;li&gt;GCC: 4.3.4, 4.4.3, 4.4.4, 4.5.2&lt;/li&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1, 12.0&lt;/li&gt;
&lt;li&gt;PathScale: 3.2&lt;/li&gt;
&lt;li&gt;QCC&lt;/li&gt;
&lt;li&gt;Visual C++: 2003, 2008, 2010&lt;/li&gt;
&lt;li&gt;pgCC: 11.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それと、訳語表を随時更新していってください。&lt;/p&gt;
&lt;h3&gt;訳語表&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英語&lt;/th&gt;
&lt;th&gt;日本語&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abstract class&lt;/td&gt;
&lt;td&gt;抽象クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;aggregate&lt;/td&gt;
&lt;td&gt;集成体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alignment&lt;/td&gt;
&lt;td&gt;アライメント (表示位置ではなくメモリの文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;apply, application&lt;/td&gt;
&lt;td&gt;適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arithmetic type&lt;/td&gt;
&lt;td&gt;算術型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;associative container(s)&lt;/td&gt;
&lt;td&gt;連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;base class&lt;/td&gt;
&lt;td&gt;基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bidirectional iterator&lt;/td&gt;
&lt;td&gt;双方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bucket&lt;/td&gt;
&lt;td&gt;バケット&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;complexity&lt;/td&gt;
&lt;td&gt;計算量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compound type&lt;/td&gt;
&lt;td&gt;複合型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const iterator&lt;/td&gt;
&lt;td&gt;読み取り専用イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const reverse iterator&lt;/td&gt;
&lt;td&gt;読み取り専用逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;covariant&lt;/td&gt;
&lt;td&gt;共変的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data member&lt;/td&gt;
&lt;td&gt;メンバ変数 (ユーザー視点ではデータメンバより一般的のため)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereference&lt;/td&gt;
&lt;td&gt;間接参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereferenceable&lt;/td&gt;
&lt;td&gt;間接参照可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;derived class&lt;/td&gt;
&lt;td&gt;派生クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;direct base class&lt;/td&gt;
&lt;td&gt;直接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delegate&lt;/td&gt;
&lt;td&gt;委譲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;effects&lt;/td&gt;
&lt;td&gt;効果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emplace&lt;/td&gt;
&lt;td&gt;直接構築&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equal&lt;/td&gt;
&lt;td&gt;等値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence class&lt;/td&gt;
&lt;td&gt;同値分類 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence relation&lt;/td&gt;
&lt;td&gt;同値関係 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalent&lt;/td&gt;
&lt;td&gt;同値 (数学的文脈)、等価 (その他文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forward iterator&lt;/td&gt;
&lt;td&gt;前方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fundamental type&lt;/td&gt;
&lt;td&gt;単純型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ill-formed&lt;/td&gt;
&lt;td&gt;&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;implementation-defined&lt;/td&gt;
&lt;td&gt;処理系定義&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indirect base class&lt;/td&gt;
&lt;td&gt;間接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;inherited&lt;/td&gt;
&lt;td&gt;継承&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input iterator&lt;/td&gt;
&lt;td&gt;入力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;literal type&lt;/td&gt;
&lt;td&gt;リテラル型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load factor&lt;/td&gt;
&lt;td&gt;負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lvalue reference&lt;/td&gt;
&lt;td&gt;左辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max load factor&lt;/td&gt;
&lt;td&gt;最大負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;member&lt;/td&gt;
&lt;td&gt;メンバ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move&lt;/td&gt;
&lt;td&gt;(std::move 的な意味で)ムーブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move assignment&lt;/td&gt;
&lt;td&gt;ムーブ代入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move constructor&lt;/td&gt;
&lt;td&gt;ムーブコンストラクタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mutable iterator&lt;/td&gt;
&lt;td&gt;可変イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;non-virtual base class&lt;/td&gt;
&lt;td&gt;非仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;note&lt;/td&gt;
&lt;td&gt;注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output iterator&lt;/td&gt;
&lt;td&gt;出力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overload&lt;/td&gt;
&lt;td&gt;オーバーロード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(proposal) paper&lt;/td&gt;
&lt;td&gt;提案文書&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partial ordering&lt;/td&gt;
&lt;td&gt;半順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partition&lt;/td&gt;
&lt;td&gt;区分化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ポインタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;polymorphic&lt;/td&gt;
&lt;td&gt;多相的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;power of N&lt;/td&gt;
&lt;td&gt;Nの累乗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;predicate&lt;/td&gt;
&lt;td&gt;述語&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;propagation, propagate&lt;/td&gt;
&lt;td&gt;伝播&lt;br /&gt; (伝搬は誤用が広まったものなので使わない)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pure virtual function&lt;/td&gt;
&lt;td&gt;純粋仮想関数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;random access iterator&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;一般用途の場合：範囲&lt;br /&gt; Rangeアルゴリズム・Rangeアダプタ・Rangeオブジェクトの場合：Range&lt;br /&gt; range-based for：範囲for文&lt;br /&gt; 2つのイテレータによる範囲：イテレータ範囲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;remarks&lt;/td&gt;
&lt;td&gt;備考&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;requires&lt;/td&gt;
&lt;td&gt;要件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;returns&lt;/td&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reverse iterator&lt;/td&gt;
&lt;td&gt;逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rvalue reference&lt;/td&gt;
&lt;td&gt;右辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sequence container(s)&lt;/td&gt;
&lt;td&gt;シーケンスコンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;signed&lt;/td&gt;
&lt;td&gt;符号付き&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop request&lt;/td&gt;
&lt;td&gt;停止要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop state&lt;/td&gt;
&lt;td&gt;停止状態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spurious Failure&lt;/td&gt;
&lt;td&gt;見かけ上の失敗&lt;br /&gt; &lt;a href=&#34;https://togetter.com/li/430770&#34; target=&#34;_blank&#34;&gt;https://togetter.com/li/430770&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strict weak ordering&lt;/td&gt;
&lt;td&gt;狭義の弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strong ordering&lt;/td&gt;
&lt;td&gt;全順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;structural type&lt;/td&gt;
&lt;td&gt;構造的型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;synchronization&lt;/td&gt;
&lt;td&gt;同期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;total ordering relationalship&lt;/td&gt;
&lt;td&gt;全順序関係&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trailing return type&lt;/td&gt;
&lt;td&gt;後置戻り値型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trait&lt;/td&gt;
&lt;td&gt;トレイト&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trivial&lt;/td&gt;
&lt;td&gt;トリビアル (逆は非トリビアル)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underlying type&lt;/td&gt;
&lt;td&gt;基底型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unordered associative container(s)&lt;/td&gt;
&lt;td&gt;非順序連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unspecified&lt;/td&gt;
&lt;td&gt;未規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;virtual base class&lt;/td&gt;
&lt;td&gt;仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;weak ordering&lt;/td&gt;
&lt;td&gt;弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;well-formed&lt;/td&gt;
&lt;td&gt;適格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eligible&lt;/td&gt;
&lt;td&gt;資格のある&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_find -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/adjacent_find.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/adjacent_find.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/adjacent_find.md b/reference/algorithm/adjacent_find.md
index a8a3d83d6..f6050f8b4 100644
--- a/reference/algorithm/adjacent_find.md
+++ b/reference/algorithm/adjacent_find.md
@@ -43,7 +43,7 @@ namespace std {
 ```
 
 ## 概要
-隣接する要素で条件を満たしている最初の要素を検索する。
+イテレータ範囲`[first, last)`から、隣接する要素で条件を満たしている最初の要素を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/binary_search.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/binary_search.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/binary_search.md b/reference/algorithm/binary_search.md
index 9bf8bd586..2eeb4495d 100644
--- a/reference/algorithm/binary_search.md
+++ b/reference/algorithm/binary_search.md
@@ -30,7 +30,7 @@ namespace std {
 ```
 
 ## 概要
-二分探索法による検索を行う。
+イテレータ範囲`[first, last)`から、二分探索法によって条件一致する要素の検索を行う。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/copy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/copy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/copy_n.md b/reference/algorithm/copy_n.md
index efcd1a4e1..529f8ce0c 100644
--- a/reference/algorithm/copy_n.md
+++ b/reference/algorithm/copy_n.md
@@ -30,7 +30,7 @@ namespace std {
 ```
 
 ## 概要
-指定された数の要素をコピーする。
+イテレータ範囲`[first, first + n)` (範囲の先頭N個) の要素をコピーする。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/count.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/count.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/count.md b/reference/algorithm/count.md
index 2ce75bc80..afedd7ede 100644
--- a/reference/algorithm/count.md
+++ b/reference/algorithm/count.md
@@ -28,11 +28,11 @@ namespace std {
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-指定された値と等値な要素の数を数える。
+イテレータ範囲`[first, last)`から、指定された値と等値な要素の数を数える。
 
 
 ## 戻り値
-`[first,last)` 内のイテレータ `i` について、`*i == value` であるイテレータの数を返す
+イテレータ範囲`[first,last)` 内のイテレータ `i` について、`*i == value` であるイテレータの数を返す
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/count_if.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/count_if.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/count_if.md b/reference/algorithm/count_if.md
index 9f9b8885f..a8bc4938a 100644
--- a/reference/algorithm/count_if.md
+++ b/reference/algorithm/count_if.md
@@ -28,11 +28,11 @@ namespace std {
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-条件を満たしている要素の数を数える。
+イテレータ範囲`[first, last)`から、条件を満たしている要素の数を数える。
 
 
 ## 戻り値
-`[first,last)` 内のイテレータ `i` について、`pred(*i) != false` であるイテレータの数を返す
+イテレータ範囲`[first,last)` 内のイテレータ `i` について、`pred(*i) != false` であるイテレータの数を返す
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/find.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find.md b/reference/algorithm/find.md
index 6eae74b7a..958f3f53a 100644
--- a/reference/algorithm/find.md
+++ b/reference/algorithm/find.md
@@ -24,7 +24,7 @@ namespace std {
 ```
 
 ## 概要
-指定された値を検索する。
+イテレータ範囲`[first, last)`から、指定された値を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find_first_of.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/find_first_of.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find_first_of.md b/reference/algorithm/find_first_of.md
index 0ff2d6b78..be67c0a13 100644
--- a/reference/algorithm/find_first_of.md
+++ b/reference/algorithm/find_first_of.md
@@ -71,7 +71,7 @@ namespace std {
 ```
 
 ## 概要
-ある集合の1つとマッチする最初の要素を検索する。
+イテレータ範囲`[first1, last1)`から、集合`[first2, last2)`のいずれかの要素とマッチする最初の要素を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iter_swap -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/iter_swap.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/iter_swap.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/iter_swap.md b/reference/algorithm/iter_swap.md
index 3e678b73e..aa599262d 100644
--- a/reference/algorithm/iter_swap.md
+++ b/reference/algorithm/iter_swap.md
@@ -6,10 +6,10 @@
 ```cpp
 namespace std {
   template &amp;lt;class ForwardIterator1, class ForwardIterator2&amp;gt;
-  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);           // C++03
+  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);           // (1) C++03
 
   template &amp;lt;class ForwardIterator1, class ForwardIterator2&amp;gt;
-  constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b); // C++20
+  constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b); // (1) C++20
 }
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_binary_search.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/ranges_binary_search.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_binary_search.md b/reference/algorithm/ranges_binary_search.md
index 49266fd76..744e28660 100644
--- a/reference/algorithm/ranges_binary_search.md
+++ b/reference/algorithm/ranges_binary_search.md
@@ -6,13 +6,30 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool binary_search(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool binary_search(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    binary_search(I first,
+                  S last,
+                  const T&amp;amp; value,
+                  Comp comp = {},
+                  Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    binary_search(R&amp;amp;&amp;amp; r,
+                  const T&amp;amp; value,
+                  Comp comp = {},
+                  Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,6 +45,9 @@ namespace std::ranges {
 ## 概要
 二分探索法による検索を行う。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 `[first,last)` の要素 `e` は `e &amp;lt; value` および `!(value &amp;lt; e)`、または `comp(e, value)` および `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/ranges_copy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_n.md b/reference/algorithm/ranges_copy_n.md
index 9aa2645ef..817d7ef2c 100644
--- a/reference/algorithm/ranges_copy_n.md
+++ b/reference/algorithm/ranges_copy_n.md
@@ -7,9 +7,13 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_iterator I,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
-  constexpr copy_n_result&amp;lt;I, O&amp;gt; copy_n(I first, iter_difference_t&amp;lt;I&amp;gt; n, O result);
+  constexpr copy_n_result&amp;lt;I, O&amp;gt;
+    copy_n(I first,
+           iter_difference_t&amp;lt;I&amp;gt; n,
+           O result); // (1) C++20
 }
 ```
 * copy_n_result[link ranges_in_out_result.md]
@@ -20,6 +24,8 @@ namespace std::ranges {
 ## 概要
 指定された数の要素をコピーする。
 
+- (1): イテレータ範囲を指定する
+
 
 ## 効果
 0 以上 `n` 未満であるそれぞれの `i` について、`*(result + i) = *(first + i)` を行う。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_upper_bound.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/ranges_upper_bound.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_upper_bound.md b/reference/algorithm/ranges_upper_bound.md
index 37d48b82a..393ea4619 100644
--- a/reference/algorithm/ranges_upper_bound.md
+++ b/reference/algorithm/ranges_upper_bound.md
@@ -6,13 +6,30 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I upper_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; upper_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    upper_bound(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    upper_bound(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,6 +45,9 @@ namespace std::ranges {
 ## 概要
 指定された要素より大きい値が現れる最初の位置のイテレータを取得する
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 - `[first,last)` の要素 `e` は `!(value &amp;lt; e)` または `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。  
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/array/array/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/array/array/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/array/array/op_equal.md b/reference/array/array/op_equal.md
index 7b890f066..1cfd8b7da 100644
--- a/reference/array/array/op_equal.md
+++ b/reference/array/array/op_equal.md
@@ -77,7 +77,7 @@ equal
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1023R0 `constexpr` comparison operators for `std::array`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1023r0.pdf)
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_chars -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/charconv/from_chars.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/charconv/from_chars.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/from_chars.md b/reference/charconv/from_chars.md
index 54c5e3dea..98dbda731 100644
--- a/reference/charconv/from_chars.md
+++ b/reference/charconv/from_chars.md
@@ -21,13 +21,13 @@ namespace std {
 ```
 
 ## 概要
-与えられた`[first, last)`内の文字列から、オーバーロードと基数・フォーマット指定によって決まるパターンにマッチングする最初の数字文字列を見つけて、数値へ変換する。  
+与えられたイテレータ範囲`[first, last)`内の文字列から、オーバーロードと基数・フォーマット指定によって決まるパターンにマッチングする最初の数字文字列を見つけて、数値へ変換する。  
 変換に際し、メモリ確保を行わず例外を投げることもない。
 
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
 ## 要件
-- 全て : 出力範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
+- 全て : 出力イテレータ範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
 - (2)～(4)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>to_chars -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/charconv/to_chars.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/charconv/to_chars.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/to_chars.md b/reference/charconv/to_chars.md
index fef05dad3..cb05cd2f4 100644
--- a/reference/charconv/to_chars.md
+++ b/reference/charconv/to_chars.md
@@ -41,7 +41,7 @@ namespace std {
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
 ## 要件
-- 全て : 出力範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
+- 全て : 出力イテレータ範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
 - (5)～(10)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/deque/deque/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/assign.md b/reference/deque/deque/assign.md
index 3db3876d7..21c062e0d 100644
--- a/reference/deque/deque/assign.md
+++ b/reference/deque/deque/assign.md
@@ -19,7 +19,7 @@ void assign(initializer_list&amp;lt;T&amp;gt; init);                // (3) C++11
 
 
 ## 効果
-- (1) : `*this`の全ての要素を解放し、`[first, last)`の範囲の要素のコピーを`*this`にコピーする。
+- (1) : `*this`の全ての要素を解放し、イテレータ範囲`[first, last)`の要素のコピーを`*this`にコピーする。
 - (2) : `*this`の全ての要素が解放され、`t`オブジェクトの`n`個のコピーから`*this`を再構築する。
 - (3) : `*this`の全ての要素を解放し、`x`の全ての要素を`*this`にコピーする。
 
@@ -43,7 +43,7 @@ int main ()
 {
   std::deque&amp;lt;int&amp;gt; c = {1, 2, 3};
 
-  // 範囲の代入
+  // イテレータ範囲の代入
   std::deque&amp;lt;int&amp;gt; c1;
   c1.assign(c.begin(), c.end());
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/deque/deque/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/erase.md b/reference/deque/deque/erase.md
index 1db733248..303d0facb 100644
--- a/reference/deque/deque/erase.md
+++ b/reference/deque/deque/erase.md
@@ -18,7 +18,7 @@ iterator erase(const_iterator first, const_iterator last); // (2) C++11
 
 ## 効果
 - (1) : `position`が指す要素を削除する。
-- (2) : `[first, last)`で示される範囲の要素を削除する。
+- (2) : イテレータ範囲`[first, last)`の要素を削除する。
 
 もし削除がシーケンスの先頭または末尾から行われた場合、削除された要素へのイテレータと参照は無効化される。もし削除が中間位置から行われた場合、全てのイテレータと削除は無効化される。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/deque/deque/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/insert.md b/reference/deque/deque/insert.md
index 21de19dbb..57ad542bd 100644
--- a/reference/deque/deque/insert.md
+++ b/reference/deque/deque/insert.md
@@ -43,7 +43,7 @@ iterator insert(const_iterator position, initializer_list&amp;lt;T&amp;gt; init); // (5) C++11
 - `x`挿入される要素の初期化に使われる値。`T`はひとつめのテンプレートパラメータ（コンテナに格納される要素の型）である。
 - `y`直接挿入される値。`T`はひとつめのテンプレートパラメータ（コンテナに格納される要素の型）である。
 - `n`挿入する要素の数。それぞれの要素は x の値によって初期化される。メンバ型`size_type`は符号なし整数型である。
-- `first, last`要素の範囲を指定する。範囲 `[first, last)` の中にある要素のコピーが位置`position`に挿入される。`first`と`last`の間の範囲は、`first`で指定された要素を含むが、`last`で指定された要素を含まない点に注意。テンプレート型はどんな入力イテレータでも構わない。
+- `first, last`要素のイテレータ範囲を指定する。イテレータ範囲 `[first, last)` の中にある要素のコピーが位置`position`に挿入される。`first`と`last`の間の範囲は、`first`で指定された要素を含むが、`last`で指定された要素を含まない点に注意。テンプレート型はどんな入力イテレータでも構わない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/deque/deque/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/op_equal.md b/reference/deque/deque/op_equal.md
index 8c3f42d56..f4310152c 100644
--- a/reference/deque/deque/op_equal.md
+++ b/reference/deque/deque/op_equal.md
@@ -83,6 +83,6 @@ false
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>directory_iterator -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/directory_iterator.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/directory_iterator.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/directory_iterator.md b/reference/filesystem/directory_iterator.md
index cf9f44763..844f2da3b 100644
--- a/reference/filesystem/directory_iterator.md
+++ b/reference/filesystem/directory_iterator.md
@@ -43,7 +43,7 @@ namespace std::filesystem {
 
 
 ## 非メンバ関数
-### 範囲
+### イテレータ範囲
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/path/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/assign.md b/reference/filesystem/path/assign.md
index 415223703..aded291aa 100644
--- a/reference/filesystem/path/assign.md
+++ b/reference/filesystem/path/assign.md
@@ -35,7 +35,7 @@ path&amp;amp; assign(InputIterator first, InputIterator last); // (3)
 ## 効果
 - (1) : `source`のパスフォーマットを検出して内部用に変換し、`*this`にムーブ代入する。この関数を呼び出したあと、`source`は「有効だが未規定の状態」となる
 - (2) : `source`のパスフォーマットを検出して内部用に変換し、`*this`にそのパスのコピーを保持する
-- (3) : 範囲`[first, last)`を`path source{first, last};`として、`source`のパスフォーマットを検出して内部用に変換し、`*this`にそのパスのコピーを保持する
+- (3) : イテレータ範囲`[first, last)`を`path source{first, last};`として、`source`のパスフォーマットを検出して内部用に変換し、`*this`にそのパスのコピーを保持する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexically_relative -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/lexically_relative.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/path/lexically_relative.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/lexically_relative.md b/reference/filesystem/path/lexically_relative.md
index 4d73b888a..efd8b4fe1 100644
--- a/reference/filesystem/path/lexically_relative.md
+++ b/reference/filesystem/path/lexically_relative.md
@@ -23,11 +23,11 @@ path lexically_relative(const path&amp;amp; base) const;
 2. 以下の式で、`*this`と`base`が異なる最初の位置を見つける：
     - `auto [a, b] =` [`std::mismatch`](/reference/algorithm/mismatch.md)`(`[`begin()`](begin.md)`,` [`end()`](end.md)`, base.`[`begin()`](begin.md)`, base.`[`end()`](end.md)`);`
 3. `a ==` [`end()`](end.md)かつ`b == base.`[`end()`](end.md)の場合、`path(&amp;#34;.&amp;#34;)`が返る
-4. 範囲`[b, base.`[`end()`](end.md)`)`の非`&amp;#34;.&amp;#34;` (ドットx1) かつ非`&amp;#34;..&amp;#34;` (ドットx2) の数から、同範囲内の `&amp;#34;..&amp;#34;` の数を引いたものを`n`とする
+4. イテレータ範囲`[b, base.`[`end()`](end.md)`)`の非`&amp;#34;.&amp;#34;` (ドットx1) かつ非`&amp;#34;..&amp;#34;` (ドットx2) の数から、同範囲内の `&amp;#34;..&amp;#34;` の数を引いたものを`n`とする
 5. `n &amp;lt; 0`であれば、空のパスが返る
 6. 新たな`path`型オブジェクト`p`をデフォルト構築し、
 7. 式`p /= path(&amp;#34;..&amp;#34;)`をn回を適用する
-8. 範囲`[a,` [`end()`](end.md)`)`の各要素`x`を、式`p /= x`で加算する
+8. イテレータ範囲`[a,` [`end()`](end.md)`)`の各要素`x`を、式`p /= x`で加算する
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/path/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/op_constructor.md b/reference/filesystem/path/op_constructor.md
index dd5ce9489..71b931945 100644
--- a/reference/filesystem/path/op_constructor.md
+++ b/reference/filesystem/path/op_constructor.md
@@ -59,12 +59,12 @@ path(InputIterator first, InputIterator last,
 - (3) : `p`の保持するパスを`*this`に移動する。このコンストラクタ呼び出しのあと、`p`は「有効だが未規定の状態」となる
 - (4) : 必要であればパスのフォーマットを変換し、`source`を`*this`に移動する。このコンストラクタ呼び出しのあと、`source`は「有効だが未規定の状態」となる
 - (5) : 必要であればパスのフォーマットを変換し、`source`を`*this`にコピーする
-- (6) : 範囲`[first, last)`をパス文字列とし、必要であればパスのフォーマットを変換て、そのコピーを`*this`にコピーする
+- (6) : イテレータ範囲`[first, last)`をパス文字列とし、必要であればパスのフォーマットを変換て、そのコピーを`*this`にコピーする
 - (7) :
     - `path`クラスの`value_type`が`wchar_t`であれば、[`std::codecvt`](/reference/locale/codecvt.md)`&amp;lt;wchar_t, char, mbstate_t&amp;gt;`ファセットを使用して、`source`をシステムのワイド文字コードに変換をする。そうでなければ、同ファセットを使用して、システムのマルチバイト文字コードに変換をする
     - さらに必要であればパスのフォーマットを変換し、その結果を`*this`にコピーする
 - (8) :
-    - `path`クラスの`value_type`が`wchar_t`であれば、[`std::codecvt`](/reference/locale/codecvt.md)`&amp;lt;wchar_t, char, mbstate_t&amp;gt;`ファセットを使用して、範囲`[first, last)`のパス文字列をシステムのワイド文字コードに変換をする。そうでなければ、同ファセットを使用して、システムのマルチバイト文字コードに変換をする
+    - `path`クラスの`value_type`が`wchar_t`であれば、[`std::codecvt`](/reference/locale/codecvt.md)`&amp;lt;wchar_t, char, mbstate_t&amp;gt;`ファセットを使用して、イテレータ範囲`[first, last)`のパス文字列をシステムのワイド文字コードに変換をする。そうでなければ、同ファセットを使用して、システムのマルチバイト文字コードに変換をする
     - さらに必要であればパスのフォーマットを変換し、その結果を`*this`にコピーする
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>recursive_directory_iterator -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/recursive_directory_iterator.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/recursive_directory_iterator.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/recursive_directory_iterator.md b/reference/filesystem/recursive_directory_iterator.md
index 77db2aec7..65e497b1a 100644
--- a/reference/filesystem/recursive_directory_iterator.md
+++ b/reference/filesystem/recursive_directory_iterator.md
@@ -61,7 +61,7 @@ namespace std::filesystem {
 
 
 ## 非メンバ関数
-### 範囲
+### イテレータ範囲
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/format/format.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/format/format.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format.md b/reference/format/format.md
index b847d6fb8..35dec427a 100644
--- a/reference/format/format.md
+++ b/reference/format/format.md
@@ -100,7 +100,7 @@ string s3 = format(&amp;#34;{} {1}&amp;#34;,  &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;); // コンパイルエラー
 
 #### 文字型 / `bool`型 / 整数型の場合
 
-`[first, last)`を[`to_chars`](/reference/charconv/to_chars.md)の結果を格納するのに十分な範囲、`value`をフォーマットする値、`charT`を`char`または`wchar_t`とする。
+イテレータ範囲`[first, last)`を[`to_chars`](/reference/charconv/to_chars.md)の結果を格納するのに十分な範囲、`value`をフォーマットする値、`charT`を`char`または`wchar_t`とする。
 
 * 以下の表の通りに[`to_chars`](/reference/charconv/to_chars.md)を呼び出したあと、その結果を出力へコピーするかのような振る舞いをする。ただし、実際に[`to_chars`](/reference/charconv/to_chars.md)を呼び出すかどうかは規定されていない。
 * 実際には、出力へコピーする際にパディングなども行われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>formatter -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/format/formatter.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/format/formatter.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/formatter.md b/reference/format/formatter.md
index b32d4e61d..e40791996 100644
--- a/reference/format/formatter.md
+++ b/reference/format/formatter.md
@@ -58,15 +58,15 @@ namespace std {
 
 1. 式 `f.parse(pc)` が有効であり、
     * 戻り値の型が`PC::iterator`である
-    * `[pc.begin(), pc.end())`の範囲を解析して`format_error`を投げるか、解析が終わった位置を指すイテレータを返す
+    * イテレータ範囲`[pc.begin(), pc.end())`を解析して`format_error`を投げるか、解析が終わった位置を指すイテレータを返す
 2. 式 `f.format(t, fc)` が有効であり、
     * 戻り値の型が`FC::iterator`である
     * フォーマット結果を`fc.out()`へ出力し、出力後のイテレータを返す
-    * 出力は`t`、`fc.locale()`、最後に呼び出された`f.parse(pc)`の`[pc.begin(), pc.end())`の範囲以外に依存しない
+    * 出力は`t`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
 3. 式 `f.format(u, fc)` が有効であり、
     * 戻り値が`FC::iterator`である
     * フォーマット結果を`fc.out()`へ出力し、出力後のイテレータを返す
-    * 出力は`u`、`fc.locale()`、最後に呼び出された`f.parse(pc)`の`[pc.begin(), pc.end())`の範囲以外に依存しない
+    * 出力は`u`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
     * `u`を変更しない
 
 条件内の各要素を、以下のように定義する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>vformat_to -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/format/vformat_to.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/format/vformat_to.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/vformat_to.md b/reference/format/vformat_to.md
index d7d696d9a..ce3287278 100644
--- a/reference/format/vformat_to.md
+++ b/reference/format/vformat_to.md
@@ -54,7 +54,7 @@ namespace std {
 
 ## 効果
 
-書式文字列`fmt`に従ったフォーマットで`args`の文字列表現を出力イテレータ`out`の`[out, out + N)`の範囲に出力する。ロケール`loc`が指定された場合は、ロケール依存のフォーマットにおいて使用される。
+書式文字列`fmt`に従ったフォーマットで`args`の文字列表現を出力イテレータ`out`の`[out, out + N)`のイテレータ範囲に出力する。ロケール`loc`が指定された場合は、ロケール依存のフォーマットにおいて使用される。
 (ただし、`N`=`formatted_size(fmt, args...)` または `formatted_size(loc, fmt, args...)`)
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/assign.md b/reference/forward_list/forward_list/assign.md
index 0e4172c29..8c423c557 100644
--- a/reference/forward_list/forward_list/assign.md
+++ b/reference/forward_list/forward_list/assign.md
@@ -19,9 +19,9 @@ void assign(initializer_list&amp;lt;T&amp;gt; init);                // (3)
 
 コンテナの再代入
 
-- (1) : 範囲を代入。
-- (2) : `n`個の値`t`を代入。
-- (3) : 初期化子リストを代入。
+- (1) : イテレータ範囲を代入
+- (2) : `n`個の値`t`を代入
+- (3) : 初期化子リストを代入
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace_after -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/emplace_after.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/emplace_after.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/emplace_after.md b/reference/forward_list/forward_list/emplace_after.md
index 67b376ee2..ebfd19ceb 100644
--- a/reference/forward_list/forward_list/emplace_after.md
+++ b/reference/forward_list/forward_list/emplace_after.md
@@ -19,7 +19,7 @@ iterator emplace_after(const_iterator position, Args&amp;amp;&amp;amp;... args);
 
 
 ## 要件
-第1パラメータ`position`が、[`before_begin()`](before_begin.md)もしくは`[`[`begin()`](begin.md)`,` [`end()`](end.md)`)`の範囲の間接参照可能なイテレータであること。
+第1パラメータ`position`が、[`before_begin()`](before_begin.md)もしくはイテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md)`)`の間接参照可能なイテレータであること。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase_after -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/erase_after.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/erase_after.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/erase_after.md b/reference/forward_list/forward_list/erase_after.md
index 4f59c9396..dfff5301e 100644
--- a/reference/forward_list/forward_list/erase_after.md
+++ b/reference/forward_list/forward_list/erase_after.md
@@ -19,12 +19,12 @@ iterator erase_after(const_iterator position,
 第1引数`position`の次が間接参照可能なイテレータであること
 
 - (1) : `position`イテレータが指す次の要素単体を削除する
-- (2) : 範囲`(position, last)`の要素を削除する
+- (2) : イテレータ範囲`(position, last)`の要素を削除する
 
 
 ## 効果
 - (1) : `position`が指す次の要素が削除される
-- (2) : `(position, last)`で示される範囲の要素が削除される
+- (2) : イテレータ範囲`(position, last)`の要素が削除される
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_after -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/insert_after.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/insert_after.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/insert_after.md b/reference/forward_list/forward_list/insert_after.md
index 043969cbd..2352f90bf 100644
--- a/reference/forward_list/forward_list/insert_after.md
+++ b/reference/forward_list/forward_list/insert_after.md
@@ -28,12 +28,12 @@ iterator insert_after(const_iterator position,
 
 - (1), (2) : 新たな要素をひとつ挿入する
 - (3) : 新たな要素`x`のコピーを`n`個挿入する
-- (4) : `[first, last)`の範囲の要素を挿入する
+- (4) : イテレータ範囲`[first, last)`の要素を挿入する
 - (5) : `initializer_list`の全て要素を挿入する
 
 
 ## 要件
-- 第1パラメータ`position`が、[`before_begin()`](/reference/forward_list/forward_list/before_begin.md)もしくは`[`[`begin()`](begin.md)`,` [`end()`](/reference/forward_list/forward_list/end.md)`)`の範囲の間接参照可能なイテレータであること。
+- 第1パラメータ`position`が、[`before_begin()`](/reference/forward_list/forward_list/before_begin.md)もしくはイテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](/reference/forward_list/forward_list/end.md)`)`の間接参照可能なイテレータであること。
 - `first`、`last`は`*this`のイテレータではないこと。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/merge.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/merge.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/merge.md b/reference/forward_list/forward_list/merge.md
index fedb6c7c2..b15d163e3 100644
--- a/reference/forward_list/forward_list/merge.md
+++ b/reference/forward_list/forward_list/merge.md
@@ -26,7 +26,7 @@ void merge(forward_list&amp;amp;&amp;amp; x, Compare comp); // (4)
 
 
 ## 効果
-2つのソート済み範囲`[begin(), end())`と`[x.begin(), x.end())`をマージする。2つの`forward_list`オブジェクトの要素を`*this`に併合し、`x`はマージ後に空となる。
+2つのソート済みイテレータ範囲`[begin(), end())`と`[x.begin(), x.end())`をマージする。2つの`forward_list`オブジェクトの要素を`*this`に併合し、`x`はマージ後に空となる。
 
 マージ後、`x`の要素に対するイテレータおよび参照は無効にならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/op_constructor.md b/reference/forward_list/forward_list/op_constructor.md
index 541f2dc30..128c2807e 100644
--- a/reference/forward_list/forward_list/op_constructor.md
+++ b/reference/forward_list/forward_list/op_constructor.md
@@ -47,7 +47,7 @@ forward_list(initializer_list&amp;lt;T&amp;gt; il,
 - (4)
     - C++11 : `n` 個の `T()` で初期化された要素を保持した `forward_list` オブジェクトを構築する。
     - C++14 : アロケータを指定して `n` 個の `T()` で初期化された要素を保持した `forward_list` オブジェクトを構築する。
-- (5) : `[first, last)` の範囲を要素としてコピーした `forward_list` オブジェクトを構築する。
+- (5) : イテレータ範囲`[first, last)` を要素としてコピーした `forward_list` オブジェクトを構築する。
 - (6) : コピーコンストラクタ。`x` と同じ要素を保持した `forward_list` オブジェクトを構築する。
 - (7) : ムーブコンストラクタ。`x` の指す先を自分の領域として `forward_list` オブジェクトを構築する。
 - (8) : アロケータを指定したコピーコンストラクタ  
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/op_equal.md b/reference/forward_list/forward_list/op_equal.md
index df415d350..5cd8904ce 100644
--- a/reference/forward_list/forward_list/op_equal.md
+++ b/reference/forward_list/forward_list/op_equal.md
@@ -79,5 +79,5 @@ false
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>splice_after -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/splice_after.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/splice_after.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/splice_after.md b/reference/forward_list/forward_list/splice_after.md
index 712bd8cfd..c49b9f8fb 100644
--- a/reference/forward_list/forward_list/splice_after.md
+++ b/reference/forward_list/forward_list/splice_after.md
@@ -28,7 +28,7 @@ void splice_after(const_iterator position, forward_list&amp;amp;&amp;amp; x,
 
 
 ## 要件
-- 第1パラメータ`position`が、[`before_begin()`](before_begin.md)もしくは`[`[`begin()`](begin.md)`,` [`end()`](end.md))の範囲の間接参照可能なイテレータであること。
+- 第1パラメータ`position`が、[`before_begin()`](before_begin.md)もしくはイテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md))の間接参照可能なイテレータであること。
 - `i`, `first`, `last`が、`x`のイテレータであること。
 - [`get_allocator()`](get_allocator.md) `== x.`[`get_allocator()`](get_allocator.md)であること。(C++14)
 - [`addressof`](/reference/memory/addressof.md)`(x) != this`であること
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/unique.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/unique.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/unique.md b/reference/forward_list/forward_list/unique.md
index 890463007..340c86a39 100644
--- a/reference/forward_list/forward_list/unique.md
+++ b/reference/forward_list/forward_list/unique.md
@@ -25,7 +25,7 @@ size_type unique(BinaryPredicate pred); // (2) C++20
 
 
 ## 効果
-範囲`[first + 1, last)`の全てのイテレータ`i`について、
+イテレータ範囲`[first + 1, last)`の全てのイテレータ`i`について、
 
 - (1) : `*i == *(i - 1)`
 - (2) : `pred(*i, *(i - 1))`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/boyer_moore_horspool_searcher/op_call.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/boyer_moore_horspool_searcher/op_call.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/boyer_moore_horspool_searcher/op_call.md b/reference/functional/boyer_moore_horspool_searcher/op_call.md
index 3c51883d4..b9cea812b 100644
--- a/reference/functional/boyer_moore_horspool_searcher/op_call.md
+++ b/reference/functional/boyer_moore_horspool_searcher/op_call.md
@@ -26,7 +26,7 @@ std::pair&amp;lt;RandomAccessIterator2, RandomAccessIterator2&amp;gt;
 ## 戻り値
 - 部分シーケンス`[pat_first, pat_last)`が空である場合、[`make_pair`](/reference/utility/make_pair.md)`(first, first)`を返す
 - イテレータ`i`と`j`として以下を定義し、
-    - `i` : 範囲`[first, last)`のうち、部分範囲`[pat_first, pat_last)`が現れる最初の位置を指すイテレータ。各要素の等値比較は、`pred(*(i + n), *(pat_first + n)) != false`で判定する
+    - `i` : イテレータ範囲`[first, last)`のうち、部分範囲`[pat_first, pat_last)`が現れる最初の位置を指すイテレータ。各要素の等値比較は、`pred(*(i + n), *(pat_first + n)) != false`で判定する
     - `j` : [`next`](/reference/iterator/next.md)`(i,` [`distance`](/reference/iterator/distance.md)`(pat_first, pat_last))`
     - 合致する部分シーケンスが見つかった場合、[`make_pair`](/reference/utility/make_pair.md)`(i, j)`を返す
 - 合致する部分シーケンスが見つからなかった場合、[`make_pair`](/reference/utility/make_pair.md)`(last, last)`を返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/boyer_moore_horspool_searcher/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/boyer_moore_horspool_searcher/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/boyer_moore_horspool_searcher/op_constructor.md b/reference/functional/boyer_moore_horspool_searcher/op_constructor.md
index 1070c2d26..54a33d62f 100644
--- a/reference/functional/boyer_moore_horspool_searcher/op_constructor.md
+++ b/reference/functional/boyer_moore_horspool_searcher/op_constructor.md
@@ -21,7 +21,7 @@ boyer_moore_horspool_searcher(boyer_moore_horspool_searcher&amp;amp;&amp;amp; other) = default;
 
 このクラスにデフォルトコンストラクタは定義されない。
 
-- (1) : 検索対象 (pattern) の範囲`[pat_first, pat_last)`を登録する
+- (1) : 検索対象 (pattern) のイテレータ範囲`[pat_first, pat_last)`を登録する
 - (2) : コピーコンストラクタ
 - (3) : ムーブコンストラクタ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/boyer_moore_searcher/op_call.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/boyer_moore_searcher/op_call.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/boyer_moore_searcher/op_call.md b/reference/functional/boyer_moore_searcher/op_call.md
index 7d5843e45..82134094e 100644
--- a/reference/functional/boyer_moore_searcher/op_call.md
+++ b/reference/functional/boyer_moore_searcher/op_call.md
@@ -26,7 +26,7 @@ std::pair&amp;lt;RandomAccessIterator2, RandomAccessIterator2&amp;gt;
 ## 戻り値
 - 部分シーケンス`[pat_first, pat_last)`が空である場合、[`make_pair`](/reference/utility/make_pair.md)`(first, first)`を返す
 - イテレータ`i`と`j`として以下を定義し、
-    - `i` : 範囲`[first, last)`のうち、部分範囲`[pat_first, pat_last)`が現れる最初の位置を指すイテレータ。各要素の等値比較は、`pred(*(i + n), *(pat_first + n)) != false`で判定する
+    - `i` : イテレータ範囲`[first, last)`のうち、部分範囲`[pat_first, pat_last)`が現れる最初の位置を指すイテレータ。各要素の等値比較は、`pred(*(i + n), *(pat_first + n)) != false`で判定する
     - `j` : [`next`](/reference/iterator/next.md)`(i,` [`distance`](/reference/iterator/distance.md)`(pat_first, pat_last))`
     - 合致する部分シーケンスが見つかった場合、[`make_pair`](/reference/utility/make_pair.md)`(i, j)`を返す
 - 合致する部分シーケンスが見つからなかった場合、[`make_pair`](/reference/utility/make_pair.md)`(last, last)`を返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/boyer_moore_searcher/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/boyer_moore_searcher/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/boyer_moore_searcher/op_constructor.md b/reference/functional/boyer_moore_searcher/op_constructor.md
index 04f65d5de..21595bb6e 100644
--- a/reference/functional/boyer_moore_searcher/op_constructor.md
+++ b/reference/functional/boyer_moore_searcher/op_constructor.md
@@ -21,7 +21,7 @@ boyer_moore_searcher(boyer_moore_searcher&amp;amp;&amp;amp; other) = default;      // (3)
 
 このクラスにデフォルトコンストラクタは定義されない。
 
-- (1) : 検索対象 (pattern) の範囲`[pat_first, pat_last)`を登録する
+- (1) : 検索対象 (pattern) のイテレータ範囲`[pat_first, pat_last)`を登録する
 - (2) : コピーコンストラクタ
 - (3) : ムーブコンストラクタ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/default_searcher/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/default_searcher/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/default_searcher/op_constructor.md b/reference/functional/default_searcher/op_constructor.md
index fd3e348c8..ea787ffa7 100644
--- a/reference/functional/default_searcher/op_constructor.md
+++ b/reference/functional/default_searcher/op_constructor.md
@@ -23,7 +23,7 @@ default_searcher(default_searcher&amp;amp;&amp;amp; other) = default;       // (3) C++17
 
 このクラスにデフォルトコンストラクタは定義されない。
 
-- (1) : 検索対象 (pattern) の範囲`[pat_first, pat_last)`を登録する
+- (1) : 検索対象 (pattern) のイテレータ範囲`[pat_first, pat_last)`を登録する
 - (2) : コピーコンストラクタ
 - (3) : ムーブコンストラクタ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>identity -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/identity.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/identity.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/identity.md b/reference/functional/identity.md
index 4e00fc7ae..4bb18e412 100644
--- a/reference/functional/identity.md
+++ b/reference/functional/identity.md
@@ -39,7 +39,7 @@ namespace std {
 
 ## 備考
 
-これは主に範囲（`range`）をとるアルゴリズムにおいて、カスタマイズ可能な射影操作のデフォルトとして利用される。
+これは主にRangeをとるアルゴリズムにおいて、カスタマイズ可能な射影操作のデフォルトとして利用される。
 
 ## 例
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>advance -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/iterator/ranges_advance.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/iterator/ranges_advance.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/ranges_advance.md b/reference/iterator/ranges_advance.md
index 0c05e2ad9..9b67945fb 100644
--- a/reference/iterator/ranges_advance.md
+++ b/reference/iterator/ranges_advance.md
@@ -35,11 +35,11 @@ namespace std::ranges {
 ## 事前条件
 
 - (1) : `I`が[`bidirectional_iterator`](bidirectional_iterator.md)のモデルとならない場合、`n`は負数ではない
-- (2) : `[i, bound)`は有効な範囲である
+- (2) : `[i, bound)`は有効なイテレータ範囲である
 - (3) : 次のいずれか
-    - `n &amp;gt;  0` : `[i, bound)`は有効な範囲である
-    - `n == 0` : `[i, bound)`もしくは`[bound, i)`は有効な範囲である
-    - `n &amp;lt;  0` : `[bound, i)`は有効な範囲であり、`I`は[`bidirectional_iterator`](bidirectional_iterator.md)のモデルであり、`I, S`は[`same_as`](/reference/concepts/same_as.md)`&amp;lt;I, S&amp;gt;`のモデルとなる。
+    - `n &amp;gt;  0` : `[i, bound)`は有効なイテレータ範囲である
+    - `n == 0` : `[i, bound)`もしくは`[bound, i)`は有効なイテレータ範囲である
+    - `n &amp;lt;  0` : `[bound, i)`は有効なイテレータ範囲であり、`I`は[`bidirectional_iterator`](bidirectional_iterator.md)のモデルであり、`I, S`は[`same_as`](/reference/concepts/same_as.md)`&amp;lt;I, S&amp;gt;`のモデルとなる。
 
 ## 効果
 
@@ -133,4 +133,4 @@ diff : 2
 
 ## 参照
 
-- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
\ No newline at end of file
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>distance -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/iterator/ranges_distance.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/iterator/ranges_distance.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/ranges_distance.md b/reference/iterator/ranges_distance.md
index a8f36ef0f..e058d313b 100644
--- a/reference/iterator/ranges_distance.md
+++ b/reference/iterator/ranges_distance.md
@@ -32,8 +32,8 @@ namespace std::ranges {
 ## 事前条件
 
 - (1) : 次のいずれか
-    - `[first, last)`は有効な範囲である
-    - `[last, first)`は有効な範囲であり、`S, I`は[`same_as`](/reference/concepts/same_as.md)`&amp;lt;S, I&amp;gt;`および[`sized_sentinel_for`](sized_sentinel_for.md)`&amp;lt;S, I&amp;gt;`のモデルとなる
+    - `[first, last)`は有効なイテレータ範囲である
+    - `[last, first)`は有効なイテレータ範囲であり、`S, I`は[`same_as`](/reference/concepts/same_as.md)`&amp;lt;S, I&amp;gt;`および[`sized_sentinel_for`](sized_sentinel_for.md)`&amp;lt;S, I&amp;gt;`のモデルとなる
 
 ## 効果
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/assign.md b/reference/list/list/assign.md
index 9793cc0ff..b86075321 100644
--- a/reference/list/list/assign.md
+++ b/reference/list/list/assign.md
@@ -16,9 +16,9 @@ void assign(initializer_list&amp;lt;T&amp;gt; init); // (3) C++11
 ## 概要
 コンテナの再代入
 
-- (1) : 範囲を代入。
-- (2) : `n` 個の値 `t` を代入。
-- (3) : 初期化子リストを代入。
+- (1) : イテレータ範囲を代入
+- (2) : `n` 個の値 `t` を代入
+- (3) : 初期化子リストを代入
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/emplace.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/emplace.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/emplace.md b/reference/list/list/emplace.md
index 984761bbe..f8b80f2a4 100644
--- a/reference/list/list/emplace.md
+++ b/reference/list/list/emplace.md
@@ -18,7 +18,7 @@ iterator emplace(const_iterator position, Args&amp;amp;&amp;amp;... args);
 
 
 ## 要件
-第1パラメータ`position`が、`[`[`begin()`](begin.md)`,` [`end()`](end.md)`]`の範囲の間接参照可能なイテレータであること。
+第1パラメータ`position`が、イテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md)`]`の間接参照可能なイテレータであること。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/erase.md b/reference/list/list/erase.md
index ac038a40b..536f40022 100644
--- a/reference/list/list/erase.md
+++ b/reference/list/list/erase.md
@@ -23,7 +23,7 @@ iterator erase(const_iterator position,
 
 ## 効果
 - (1) : `position`が指す要素が削除される。
-- (2) : `[position, last)`で示される範囲の要素が削除される。
+- (2) : イテレータ範囲`[position, last)`の要素が削除される。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/insert.md b/reference/list/list/insert.md
index e1da4ea24..70f3fb176 100644
--- a/reference/list/list/insert.md
+++ b/reference/list/list/insert.md
@@ -36,12 +36,12 @@ iterator insert(const_iterator position,
 
 - (1), (2) : 新たな要素をひとつ挿入する
 - (3) : 新たな要素`x`のコピーを`n`個挿入する
-- (4) : `[first, last)`の範囲の要素を挿入する
+- (4) : イテレータ範囲`[first, last)`の要素を挿入する
 - (5) : `initializer_list`の全て要素を挿入する
 
 
 ## 要件
-第1パラメータ`position`が、`[`[`begin()`](begin.md)`,` [`end()`](end.md)`]`の範囲の間接参照可能なイテレータであること。
+第1パラメータ`position`が、イテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md)`]`の間接参照可能なイテレータであること。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/op_constructor.md b/reference/list/list/op_constructor.md
index 24ceb7194..2ec356e95 100644
--- a/reference/list/list/op_constructor.md
+++ b/reference/list/list/op_constructor.md
@@ -42,7 +42,7 @@ list オブジェクトの構築
 - (2) : アロケータを指定して空のコンテナを作る。
 - (3) : `value` のコピーを `n` 個要素として保持した `list` を構築する。
 - (4) : `n` 個の `T()` 初期化された要素を保持した `list` を構築する。
-- (5) : `[first, last)` の範囲を要素としてコピーした `list` を構築する。
+- (5) : イテレータ範囲`[first, last)`を要素としてコピーした `list` を構築する。
 - (6) : コピーコンストラクタ。`x` と同じ要素を保持した `list` を構築する。
 - (7) : ムーブコンストラクタ。`x` の指す先を自分の領域として `list` を構築する。
 - (8) : アロケータを指定したコピーコンストラクタ。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/op_equal.md b/reference/list/list/op_equal.md
index ada8d47a5..5da792d08 100644
--- a/reference/list/list/op_equal.md
+++ b/reference/list/list/op_equal.md
@@ -67,6 +67,6 @@ false
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>splice -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/splice.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/splice.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/splice.md b/reference/list/list/splice.md
index 23a7f3947..044bd84f6 100644
--- a/reference/list/list/splice.md
+++ b/reference/list/list/splice.md
@@ -30,13 +30,13 @@ void splice(const_iterator position, list&amp;amp;&amp;amp; x,
 ## 概要
 他の`list`オブジェクトから、要素を移動する。
 
-- (1), (2) : `position`の指す要素の前に、`x`の全ての要素を移動する。  
-- (3), (4) : `position`の指す要素の前に、`x`の要素のうち`i`の指す要素を移動する。  
-- (5), (6) : `position`の指す要素の前に、`x`の要素のうち`[first, last)`の範囲を移動する。  
+- (1), (2) : `position`の指す要素の前に、`x`の全ての要素を移動する
+- (3), (4) : `position`の指す要素の前に、`x`の要素のうち`i`の指す要素を移動する
+- (5), (6) : `position`の指す要素の前に、`x`の要素のうち`[first, last)`の範囲を移動する
 
 
 ## 要件
-- 第1パラメータ`position`が、`[`[`begin()`](begin.md)`,` [`end()`](end.md)`)`の範囲の間接参照可能なイテレータであること。
+- 第1パラメータ`position`が、イテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md)`)`の間接参照可能なイテレータであること。
 - `i`, `first`, `last`が、`x`のイテレータであること。
 - (1), (2) :
     - C++03 : `&amp;amp;x != this`であること
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/unique.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/unique.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/unique.md b/reference/list/list/unique.md
index 6ad371e02..3384c7698 100644
--- a/reference/list/list/unique.md
+++ b/reference/list/list/unique.md
@@ -24,7 +24,7 @@ size_type unique(BinaryPredicate pred); // (2) C++20
 
 
 ## 効果
-範囲`[first + 1, last)`の全てのイテレータ`i`について、オーバーロードごとに、以下の条件が`true`となる要素を削除する。
+イテレータ範囲`[first + 1, last)`の全てのイテレータ`i`について、オーバーロードごとに、以下の条件が`true`となる要素を削除する。
 
 - (1) : `*i == *(i - 1)`
 - (2) : `pred(*i, *(i - 1))`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/map/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/map/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/erase.md b/reference/map/map/erase.md
index 6db545f7f..b0105266c 100644
--- a/reference/map/map/erase.md
+++ b/reference/map/map/erase.md
@@ -15,7 +15,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 ```
 
 ## 概要
-単一要素または要素範囲（`[first, last)`）を `map` コンテナから削除する。
+単一要素またはイテレータ範囲`[first, last)`を `map` コンテナから削除する。
 
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
@@ -23,7 +23,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 ## パラメータ
 - `position` : `map` から削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
 - `x` : `map` から削除される値のキー。`key_type` はメンバ型であり、`map` コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素のキーの型である。
-- `first, last` : `map` コンテナ内の、削除される範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+- `first, last` : `map` コンテナ内の、削除されるイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/map/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/map/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/insert.md b/reference/map/map/insert.md
index 809d7025f..67fa49823 100644
--- a/reference/map/map/insert.md
+++ b/reference/map/map/insert.md
@@ -48,7 +48,7 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (8) C++17か
 - (2) : `value_type` は、コンテナに対してムーブ挿入可能でなければならない。
 - (3) : `value_type` は、コンテナに対してコピー挿入可能でなければならない。
 - (4) : `value_type` は、コンテナに対してムーブ挿入可能でなければならない。
-- (5) : 範囲`[first, last)`の各イテレータが、`*this`の要素を指さないこと。
+- (5) : イテレータ範囲`[first, last)`の各イテレータが、`*this`の要素を指さないこと。
 - (6) : (5)の要件と同じである。
 - (7) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`である。
 - (8) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`である。
@@ -59,7 +59,7 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (8) C++17か
 - (2) : [`emplace`](emplace.md)`(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
 - (3) : `x`を`*this`の要素としてコピー挿入する。ただし、`x`のキーと等価のキーを持つ要素が`*this`に存在する場合には、挿入されない。可能であれば、挿入位置のヒントを表すイテレータ`position`のすぐ前に挿入する。
 - (4) : [`emplace_hint`](emplace_hint.md)`(position,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
-- (5) : 範囲`[first, last)`の各要素を`*this`の要素として挿入する。ただし、`*this`にすでに存在するキーと等価なキーを持つ要素については、挿入されない。
+- (5) : イテレータ範囲`[first, last)`の各要素を`*this`の要素として挿入する。ただし、`*this`にすでに存在するキーと等価なキーを持つ要素については、挿入されない。
 - (6) : `insert(init.begin(), init.end())`と等価。
 - (7) : `nh`が空の場合、効果はない。
 それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/map/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/map/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/op_equal.md b/reference/map/map/op_equal.md
index a0e188ba0..e520b4dd3 100644
--- a/reference/map/map/op_equal.md
+++ b/reference/map/map/op_equal.md
@@ -67,6 +67,6 @@ int main()
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/multimap/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/erase.md b/reference/map/multimap/erase.md
index b2e280818..3a5579f7f 100644
--- a/reference/map/multimap/erase.md
+++ b/reference/map/multimap/erase.md
@@ -16,7 +16,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 
 ## 概要
-単一要素または要素範囲（`[first, last)`）を `multimap` コンテナから削除する。
+単一要素またはイテレータ範囲`[first, last)`を `multimap` コンテナから削除する。
 
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
@@ -24,7 +24,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 ## パラメータ
 - `position` : `multimap` から削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
 - `x` : `multimap` から削除される値のキー。`key_type` はメンバ型であり、`multimap` コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素のキーの型である。
-- `first, last` : `multimap` コンテナ内の、削除される範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+- `first, last` : `multimap` コンテナ内の、削除されるイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/multimap/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/insert.md b/reference/map/multimap/insert.md
index b7a5a6370..1005aac1a 100644
--- a/reference/map/multimap/insert.md
+++ b/reference/map/multimap/insert.md
@@ -43,7 +43,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
 - (1), (4) : `value_type` は、コンテナに対してコピー挿入可能でなければならない。
 - (2), (5) : `value_type` は、コンテナに対してムーブ挿入可能でなければならない。
 - (3), (6) : `P`から`value_type`が構築可能であること。
-- (7), (8) : 範囲`[first, last)`（`[list.begin(), list.end())`）の各イテレータが、`*this` の要素を指さないこと。また `value_type` は `*first` から`multimap` コンテナへの`Cpp17EmplaceConstructible`であること。
+- (7), (8) : イテレータ範囲`[first, last)`の各イテレータが、`*this` の要素を指さないこと。また `value_type` は `*first` から`multimap` コンテナへの`Cpp17EmplaceConstructible`であること。
 - (9), (10) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`である。
 
 ## 効果
@@ -53,7 +53,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
 - (4) : 新たな要素`x`を`position`より前の出来るだけ近い位置にコピー挿入する。`position`パラメータに適切な挿入位置を指定すれば、高速に挿入できる。
 - (5) : 新たな要素`y`を`position`より前の出来るだけ近い位置にムーブ挿入する。`position`パラメータに適切な挿入位置を指定すれば、高速に挿入できる。
 - (6) : [`emplace_hint`](emplace_hint.md)`(position,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
-- (7) : 範囲`[first, last)`の各要素を`*this`の要素として挿入する。
+- (7) : イテレータ範囲`[first, last)`の各要素を`*this`の要素として挿入する。
 - (8) : `insert(init.begin(), init.end())`と等価（(7)へ委譲）。
 - (9) : `nh`が空の場合、効果はない。そうでなければ、`nh`によって所有されている要素を挿入する。`nh.key()` と等価なキーを持つ要素を含む範囲がコンテナ内に存在する場合、要素はその範囲の終端に挿入される。
 - (10) : `nh`が空の場合、効果はない。そうでなければ、`nh` によって所有されている要素を`p`より前の出来るだけ近い位置に挿入する。 `nh.key()` と等価なキーを持つ要素を含む範囲がコンテナ内に存在する場合、要素はその範囲の終端に挿入される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/multimap/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/op_equal.md b/reference/map/multimap/op_equal.md
index 71c3b4e9a..99363d07d 100644
--- a/reference/map/multimap/op_equal.md
+++ b/reference/map/multimap/op_equal.md
@@ -68,6 +68,6 @@ int main()
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/destroy.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/destroy.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/destroy.md b/reference/memory/destroy.md
index c383726a7..294969c83 100644
--- a/reference/memory/destroy.md
+++ b/reference/memory/destroy.md
@@ -27,7 +27,7 @@ namespace std {
 ```
 
 ## 概要
-範囲`[first, last)`の各要素に対してデストラクタを呼び出す。
+イテレータ範囲`[first, last)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトの配列を破棄するために使用する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/destroy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/destroy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/destroy_n.md b/reference/memory/destroy_n.md
index 6e52010ee..22b9947c3 100644
--- a/reference/memory/destroy_n.md
+++ b/reference/memory/destroy_n.md
@@ -27,7 +27,7 @@ namespace std {
 ```
 
 ## 概要
-範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
+イテレータ範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトの配列を破棄するために使用する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-forward-range -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-forward-range.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/no-throw-forward-range.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-forward-range.md b/reference/memory/no-throw-forward-range.md
index acf22d09e..97f2dc755 100644
--- a/reference/memory/no-throw-forward-range.md
+++ b/reference/memory/no-throw-forward-range.md
@@ -18,7 +18,7 @@ namespace std {
 
 ## 概要
 
-`no-throw-forward-range`は、`R`型のオブジェクトに対する以下の操作で例外を投げない入力範囲の説明用コンセプトである：
+`no-throw-forward-range`は、`R`型のオブジェクトに対する以下の操作で例外を投げない入力Rangeの説明用コンセプトである：
 
 - [`std::ranges::begin`](/reference/ranges/begin.md)
 - [`std::ranges::end`](/reference/ranges/end.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-input-range -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-input-range.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/no-throw-input-range.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-input-range.md b/reference/memory/no-throw-input-range.md
index ef4654724..55347cf01 100644
--- a/reference/memory/no-throw-input-range.md
+++ b/reference/memory/no-throw-input-range.md
@@ -21,7 +21,7 @@ namespace std {
 
 ## 概要
 
-`no-throw-input-range`は、`R`型のオブジェクトに対する以下の操作で例外を投げない入力範囲の説明用コンセプトである：
+`no-throw-input-range`は、`R`型のオブジェクトに対する以下の操作で例外を投げない入力Rangeの説明用コンセプトである：
 
 - [`std::ranges::begin`](/reference/ranges/begin.md)
 - [`std::ranges::end`](/reference/ranges/end.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_destroy.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy.md b/reference/memory/ranges_destroy.md
index 95430df99..22139a999 100644
--- a/reference/memory/ranges_destroy.md
+++ b/reference/memory/ranges_destroy.md
@@ -27,8 +27,8 @@ namespace std::ranges {
 
 この関数は、配置`new`で構築したオブジェクトを破棄するために使用する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_destroy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy_n.md b/reference/memory/ranges_destroy_n.md
index 54064c431..5b89f82e9 100644
--- a/reference/memory/ranges_destroy_n.md
+++ b/reference/memory/ranges_destroy_n.md
@@ -17,7 +17,7 @@ namespace std::ranges {
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 
 ## 概要
-範囲 (`[first, first + n)`) の各要素に対してデストラクタを呼び出す。
+イテレータ範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトを破棄するために使用する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_copy.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy.md b/reference/memory/ranges_uninitialized_copy.md
index b829fd24b..dea3cc027 100644
--- a/reference/memory/ranges_uninitialized_copy.md
+++ b/reference/memory/ranges_uninitialized_copy.md
@@ -35,10 +35,10 @@ namespace std::ranges {
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 
 ## 概要
-未初期化領域の範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
+未初期化領域のイテレータ範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力イテレータ範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
@@ -56,7 +56,7 @@ namespace std::ranges {
 
 ## 事前条件
 
-- 範囲`[ofirst, olast)`が範囲`[ifirst, ilast)`と重ならないこと
+- イテレータ範囲`[ofirst, olast)`が`[ifirst, ilast)`と重ならないこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_copy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy_n.md b/reference/memory/ranges_uninitialized_copy_n.md
index b82f8c4c1..499506e34 100644
--- a/reference/memory/ranges_uninitialized_copy_n.md
+++ b/reference/memory/ranges_uninitialized_copy_n.md
@@ -31,9 +31,9 @@ namespace std::ranges {
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 
 ## 概要
-未初期化領域の範囲`[ofirst, ofirst + n)`を配置`new`で`[ifirst, ifirst + n)`の対応する要素から初期化してコピー出力する。
+未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してコピー出力する。
 
-- (1): イテレータペアで範囲を指定する
+- (1): イテレータ範囲を指定する
 
 
 ## テンプレートパラメータ制約
@@ -46,7 +46,7 @@ namespace std::ranges {
 
 ## 事前条件
 
-- 範囲`[ofirst, olast)`が範囲`ifirst + [0, n)`と重ならないこと
+- イテレータ範囲`[ofirst, olast)`が`ifirst + [0, n)`と重ならないこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_default_construct.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_default_construct.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_default_construct.md b/reference/memory/ranges_uninitialized_default_construct.md
index b6da9354d..1003a3096 100644
--- a/reference/memory/ranges_uninitialized_default_construct.md
+++ b/reference/memory/ranges_uninitialized_default_construct.md
@@ -26,8 +26,8 @@ namespace std::ranges {
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素をデフォルト構築する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_fill.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_fill.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_fill.md b/reference/memory/ranges_uninitialized_fill.md
index 2a8869e3e..a4df77097 100644
--- a/reference/memory/ranges_uninitialized_fill.md
+++ b/reference/memory/ranges_uninitialized_fill.md
@@ -29,8 +29,8 @@ namespace std::ranges {
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) を、指定された値で配置`new`で初期化する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_move.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move.md b/reference/memory/ranges_uninitialized_move.md
index edba00187..37ae4a90f 100644
--- a/reference/memory/ranges_uninitialized_move.md
+++ b/reference/memory/ranges_uninitialized_move.md
@@ -37,8 +37,8 @@ namespace std::ranges {
 ## 概要
 未初期化領域の範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
@@ -56,7 +56,7 @@ namespace std::ranges {
 
 ## 事前条件
 
-- 範囲`[ofirst, olast)`が範囲`[ifirst, ilast)`と重ならないこと
+- イテレータ範囲`[ofirst, olast)`が`[ifirst, ilast)`と重ならないこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_move_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move_n.md b/reference/memory/ranges_uninitialized_move_n.md
index f7a925e0d..70f40c0c6 100644
--- a/reference/memory/ranges_uninitialized_move_n.md
+++ b/reference/memory/ranges_uninitialized_move_n.md
@@ -31,9 +31,9 @@ namespace std::ranges {
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 
 ## 概要
-未初期化領域の範囲`[ofirst, ofirst + n)`を配置`new`で`[ifirst, ifirst + n)`の対応する要素から初期化してムーブ出力する。
+未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してムーブ出力する。
 
-- (1): イテレータペアで範囲を指定する
+- (1): イテレータ範囲を指定する
 
 
 ## テンプレートパラメータ制約
@@ -46,7 +46,7 @@ namespace std::ranges {
 
 ## 事前条件
 
-- 範囲`[ofirst, olast)`が範囲`ifirst + [0, n)`と重ならないこと
+- イテレータ範囲`[ofirst, olast)`が`ifirst + [0, n)`と重ならないこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_value_construct.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_value_construct.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_value_construct.md b/reference/memory/ranges_uninitialized_value_construct.md
index e71e07a6f..32ae40a9f 100644
--- a/reference/memory/ranges_uninitialized_value_construct.md
+++ b/reference/memory/ranges_uninitialized_value_construct.md
@@ -26,8 +26,8 @@ namespace std::ranges {
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素を値構築する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_copy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_copy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_copy_n.md b/reference/memory/uninitialized_copy_n.md
index f2def28be..374055f2a 100644
--- a/reference/memory/uninitialized_copy_n.md
+++ b/reference/memory/uninitialized_copy_n.md
@@ -24,7 +24,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち、先頭`N`個の要素を配置`new`で初期化してコピー出力する。
 
-入力範囲`[first, first + n)`のコピーを未初期化出力範囲`[result, result + n)`に書き込む。
+入力イテレータ範囲`[first, first + n)`のコピーを未初期化出力イテレータ範囲`[result, result + n)`に書き込む。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_default_construct.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_default_construct.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_default_construct.md b/reference/memory/uninitialized_default_construct.md
index cc3b84cd9..6fdf2633f 100644
--- a/reference/memory/uninitialized_default_construct.md
+++ b/reference/memory/uninitialized_default_construct.md
@@ -20,7 +20,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲の各要素をデフォルト構築する。
 
-未初期化領域の入力範囲`[first, last)`の各要素をデフォルト構築する (ゼロ初期化しない)。
+未初期化領域の入力イテレータ範囲`[first, last)`の各要素をデフォルト構築する (ゼロ初期化しない)。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_default_construct_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_default_construct_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_default_construct_n.md b/reference/memory/uninitialized_default_construct_n.md
index 4500d7e0b..18919f615 100644
--- a/reference/memory/uninitialized_default_construct_n.md
+++ b/reference/memory/uninitialized_default_construct_n.md
@@ -22,7 +22,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち、先頭N個の要素をデフォルト構築する。
 
-未初期化領域の入力範囲`[first, first + n)`の各要素をデフォルト構築する (ゼロ初期化しない)。
+未初期化領域の入力イテレータ範囲`[first, first + n)`の各要素をデフォルト構築する (ゼロ初期化しない)。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_fill.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_fill.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_fill.md b/reference/memory/uninitialized_fill.md
index 0e51a40a4..59d8a5dcd 100644
--- a/reference/memory/uninitialized_fill.md
+++ b/reference/memory/uninitialized_fill.md
@@ -21,7 +21,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲を、指定された値で配置`new`する。
 
-未初期化入力範囲`[first, last)`を初期化しつつ値`x`で埋める。
+未初期化入力イテレータ範囲`[first, last)`を初期化しつつ値`x`で埋める。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_fill_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_fill_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_fill_n.md b/reference/memory/uninitialized_fill_n.md
index 7c896d2b7..5e362ff29 100644
--- a/reference/memory/uninitialized_fill_n.md
+++ b/reference/memory/uninitialized_fill_n.md
@@ -23,7 +23,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち、先頭`N`個の要素を指定された値で配置`new`する。
 
-未初期化入力範囲`[first, first + n)`を初期化しつつ値`x`で埋める。
+未初期化入力イテレータ範囲`[first, first + n)`を初期化しつつ値`x`で埋める。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_move_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_move_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_move_n.md b/reference/memory/uninitialized_move_n.md
index ef0ff491e..8352c6f19 100644
--- a/reference/memory/uninitialized_move_n.md
+++ b/reference/memory/uninitialized_move_n.md
@@ -24,7 +24,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち先頭`N`個の要素を配置`new`で初期化してムーブ出力する。
 
-入力範囲`[first, first + n)`からムーブして未初期化出力範囲`[result, )`に書き込む。
+入力イテレータ範囲`[first, first + n)`からムーブして未初期化出力イテレータ範囲`[result, )`に書き込む。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_value_construct.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_value_construct.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_value_construct.md b/reference/memory/uninitialized_value_construct.md
index 40a40f771..4f27319ed 100644
--- a/reference/memory/uninitialized_value_construct.md
+++ b/reference/memory/uninitialized_value_construct.md
@@ -20,7 +20,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲の各要素を値構築する。
 
-未初期化領域の入力範囲`[first, last)`の各要素を値構築する (ゼロ初期化する)。
+未初期化領域の入力イテレータ範囲`[first, last)`の各要素を値構築する (ゼロ初期化する)。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_value_construct_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_value_construct_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_value_construct_n.md b/reference/memory/uninitialized_value_construct_n.md
index f6ce9b8ff..5645f1872 100644
--- a/reference/memory/uninitialized_value_construct_n.md
+++ b/reference/memory/uninitialized_value_construct_n.md
@@ -22,7 +22,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち、先頭N個の要素を値構築する。
 
-未初期化領域の入力範囲`[first, first + n)`の各要素を値構築する (ゼロ初期化する)。
+未初期化領域の入力イテレータ範囲`[first, first + n)`の各要素を値構築する (ゼロ初期化する)。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>accumulate -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/accumulate.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/accumulate.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/accumulate.md b/reference/numeric/accumulate.md
index 55fafa2c1..0e1324c5f 100644
--- a/reference/numeric/accumulate.md
+++ b/reference/numeric/accumulate.md
@@ -20,9 +20,9 @@ namespace std{
 ```
 
 ## 概要
-`accumulate()`は、範囲を集計する関数である。
+`accumulate()`は、イテレータ範囲`[first, last)`を集計する関数である。
 
-初期値(`init`)に対して、範囲`[first, last)`の各要素`i`を前から順番に、任意の二項演算関数`binary_op`を`init = f(init, *i)`のように適用していき、範囲の全ての要素を集計した結果を戻り値として返す。
+初期値(`init`)に対して、イテレータ範囲`[first, last)`の各要素`i`を前から順番に、任意の二項演算関数`binary_op`を`init = f(init, *i)`のように適用していき、範囲の全ての要素を集計した結果を戻り値として返す。
 
 他の言語でこのような処理は、`foldL` (Haskell)、`reduce` (Common Lisp, Ruby)、`aggregate` (C#)などと呼ばれている。
 
@@ -32,7 +32,7 @@ namespace std{
 
 ## 要件
 - C++03まで : `binary_op`は副作用を起こしてはならない
-- C++11から : `binary_op`は、範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
+- C++11から : `binary_op`は、イテレータ範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
@@ -52,7 +52,7 @@ namespace std{
 
 
 ## 計算量
-範囲`[first, last)`の要素数に対して線形時間
+イテレータ範囲`[first, last)`の要素数に対して線形時間
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_difference -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/adjacent_difference.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/adjacent_difference.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/adjacent_difference.md b/reference/numeric/adjacent_difference.md
index bc3f0e93a..561c6f3e3 100644
--- a/reference/numeric/adjacent_difference.md
+++ b/reference/numeric/adjacent_difference.md
@@ -50,7 +50,7 @@ namespace std {
 ## 概要
 隣接する要素間の差を計算する。
 
-この関数に与えられた範囲`[first, last)`を`r`として、その範囲の隣接する要素同士の差を、`{r[0], r[1] - r[0], r[2] - r[1], r[3] - r[2], r[4] - r[3]}`のように演算して求められた新たな範囲を返す。
+この関数に与えられたイテレータ範囲`[first, last)`を`r`として、その範囲の隣接する要素同士の差を、`{r[0], r[1] - r[0], r[2] - r[1], r[3] - r[2], r[4] - r[3]}`のように演算して求められた新たな範囲を返す。
 
 - (1), (3) : 各隣接要素`a`と`b`を`operator-(b, a)`で減算した結果を、`result`出力イテレータに書き込む
 - (2), (4) : 各隣接要素`a`と`b`を`binary_op(b, a)`で減算した結果を、`result`出力イテレータに書き込む
@@ -59,9 +59,9 @@ namespace std {
 ## 要件
 - (2) :
     - C++03まで : 関数オブジェクト`binary_op`の呼び出しは、副作用を起こしてはならない
-    - C++11から : 関数オブジェクト`binary_op`の呼び出しが、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更、イテレータの無効化をしてはならない
+    - C++11から : 関数オブジェクト`binary_op`の呼び出しが、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更、イテレータの無効化をしてはならない
 - (3), (4) :
-    - 範囲`[first, last)`と範囲`[result, result + (last - first))`は重なってはならない
+    - イテレータ範囲`[first, last)`とイテレータ範囲`[result, result + (last - first))`は重なってはならない
 
 
 ## テンプレートパラメータ制約
@@ -82,14 +82,14 @@ namespace std {
 
 
 ## 効果
-- (1), (2) : 非空の範囲`[first, last)`について、
+- (1), (2) : 非空のイテレータ範囲`[first, last)`について、
     1. `*result = *first`で結果の初期値を書き込む。`acc = *first`としてひとつ前の位置の値を保持する
-    2. 範囲`[first + 1, last)`の各イテレータを`i`、そのイテレータが指す値を`val`として定義する
+    2. イテレータ範囲`[first + 1, last)`の各イテレータを`i`、そのイテレータが指す値を`val`として定義する
     3.
         - C++17 : (1)であれば`val - acc`、(2)であれば`binary_op(val, acc)`で隣接値を求めて、その結果を`*result`に代入する
         - C++20 : (1)であれば`val -` [`std::move`](/reference/utility/move.md)`(acc)`、(2)であれば`binary_op(val,` [`std::move`](/reference/utility/move.md)`d(acc))`で隣接値を求めて、その結果を`*result`に代入する
     4. `val`を`acc`にムーブ代入し、ひとつ前の位置の値を更新する
-- (3), (4) : 非空の範囲`[first, last)`について、
+- (3), (4) : 非空のイテレータ範囲`[first, last)`について、
     1. `*result = *first`で結果の初期値を代入する
     2. インデックス範囲`[1, last - first - 1]`のそれぞれの値`d`として定義する
     3. (3)であれば`val = *(first + d) - *(first + d - 1)`、(4)であれば`val = binary_op(*(first + d), *(first + d - 1))`として、隣接値を求める
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exclusive_scan -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/exclusive_scan.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/exclusive_scan.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/exclusive_scan.md b/reference/numeric/exclusive_scan.md
index c2d383d83..c3ea1ad86 100644
--- a/reference/numeric/exclusive_scan.md
+++ b/reference/numeric/exclusive_scan.md
@@ -55,7 +55,7 @@ namespace std{
 ```
 
 ## 概要
-範囲の部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含めず範囲`[0, i)`までの部分和を計算する。
+イテレータ範囲`[first, last)`の部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含めず範囲`[0, i)`までの部分和を計算する。
 
 `exclusive_scan()`の引数として初期値`0`、およびシーケンス`{1, 2, 3}`が与えられた場合、以下のような結果が行われる：
 
@@ -75,7 +75,7 @@ namespace std{
 
 ## 要件
 - (2), (4) :
-    - 関数オブジェクト`binary_op`の呼び出しは、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
+    - 関数オブジェクト`binary_op`の呼び出しは、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inclusive_scan -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/inclusive_scan.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/inclusive_scan.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/inclusive_scan.md b/reference/numeric/inclusive_scan.md
index 17092d984..1ec04f407 100644
--- a/reference/numeric/inclusive_scan.md
+++ b/reference/numeric/inclusive_scan.md
@@ -74,7 +74,7 @@ namespace std{
 ```
 
 ## 概要
-範囲の部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含め、範囲`[0, i]`までの部分和を計算する。
+イテレータ範囲`[first, last)`の部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含め、範囲`[0, i]`までの部分和を計算する。
 
 `inclusive_scan()`の引数として、初期値`0`、およびシーケンス`{1, 2, 3}`が与えられた場合、以下のような結果が行われる：
 
@@ -97,7 +97,7 @@ namespace std{
 
 
 ## 要件
-- (2), (3), (5), (6) : 関数オブジェクト`binary_op`の呼び出しは、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
+- (2), (3), (5), (6) : 関数オブジェクト`binary_op`の呼び出しは、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inner_product -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/inner_product.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/inner_product.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/inner_product.md b/reference/numeric/inner_product.md
index e0f5578c9..a15b27bd9 100644
--- a/reference/numeric/inner_product.md
+++ b/reference/numeric/inner_product.md
@@ -40,9 +40,9 @@ namespace std {
 ## 概要
 2つのシーケンスの内積(inner product)を計算する。
 
-この関数は、範囲`[first1, last1)`および範囲`[first2, first2 + (last1 - first1))`をそれぞれ任意次元のベクトルとみなし、その2つのベクトルの内積を計算する。
+この関数は、イテレータ範囲`[first1, last1)`およびイテレータ範囲`[first2, first2 + (last1 - first1))`をそれぞれ任意次元のベクトルとみなし、その2つのベクトルの内積を計算する。
 
-範囲`[first1, last1)`をベクトル`v`、範囲`[first2, first2 + (last1 - first1))`をベクトル`u`として、この関数は以下の効果を持つ：
+イテレータ範囲`[first1, last1)`をベクトル`v`、イテレータ範囲`[first2, first2 + (last1 - first1))`をベクトル`u`として、この関数は以下の効果を持つ：
 
 - (1) : `init + (v[0] * u[0]) + (v[1] * u[1]) + … (v[N - 1] * u[N - 1])`
 - (2) : `operator()+`を`binary_op1`、`operator*()`を`binary_op2`で代用して、(1)の演算を行う
@@ -50,7 +50,7 @@ namespace std {
 
 ## 要件
 - C++03まで : `binary_op1`および`binary_op2`は、副作用を起こしてはならない
-- C++11から : `binary_op1`および`binary_op2`が、範囲`[first1, last1]`と範囲`[first2, first2 + (last1 - first2)]`の要素変更およびイテレータの無効化をしてはならない
+- C++11から : `binary_op1`および`binary_op2`が、イテレータ範囲`[first1, last1]`とイテレータ範囲`[first2, first2 + (last1 - first2)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
@@ -60,11 +60,11 @@ namespace std {
 
 ## 効果
 - (1) :
-    - C++03 : `acc = init;`、範囲`[first1, last1)`の各イテレータを`i`、範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = acc + (*i) * (*j);` の演算を行い、`acc`を返す
-    - C++20 : `acc = init;`、範囲`[first1, last1)`の各イテレータを`i`、範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc =` [`std::move`](/reference/utility/move.md)`(acc) + (*i) * (*j);` の演算を行い、`acc`を返す
+    - C++03 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = acc + (*i) * (*j);` の演算を行い、`acc`を返す
+    - C++20 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc =` [`std::move`](/reference/utility/move.md)`(acc) + (*i) * (*j);` の演算を行い、`acc`を返す
 - (2) :
-    - C++03 : `acc = init;`、範囲`[first1, last1)`の各イテレータを`i`、範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(acc, binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
-    - C++20 : `acc = init;`、範囲`[first1, last1)`の各イテレータを`i`、範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(`[`std::move`](/reference/utility/move.md)`(acc), binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
+    - C++03 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(acc, binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
+    - C++20 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(`[`std::move`](/reference/utility/move.md)`(acc), binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iota -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/iota.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/iota.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/iota.md b/reference/numeric/iota.md
index 7da16a1d3..86800506e 100644
--- a/reference/numeric/iota.md
+++ b/reference/numeric/iota.md
@@ -29,7 +29,7 @@ namespace std{
 
 
 ## 効果
-範囲`[first, last)`の各要素`it`について、先頭から順番に `*it = value; ++value;` を行う
+イテレータ範囲`[first, last)`の各要素`it`について、先頭から順番に `*it = value; ++value;` を行う
 
 
 ## 戻り値
@@ -37,7 +37,7 @@ namespace std{
 
 
 ## 計算量
-範囲`[first, last)`の要素数をnとして、n回のインクリメントと代入が行われる。
+イテレータ範囲`[first, last)`の要素数をnとして、n回のインクリメントと代入が行われる。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sum -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/partial_sum.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/partial_sum.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/partial_sum.md b/reference/numeric/partial_sum.md
index 2c3a8a341..f6305b306 100644
--- a/reference/numeric/partial_sum.md
+++ b/reference/numeric/partial_sum.md
@@ -32,7 +32,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の値の部分和を計算する。
+イテレータ範囲`[first, last)`の値の部分和を計算する。
 
 [`accumulate()`](accumulate.md)は最終結果のみを得るが、`partial_sum()`は計算の途中結果のシーケンスを得る。
 
@@ -67,12 +67,12 @@ namespace std {
 - C++11から : `InputIterator`の値型は、`*first`の型から構築可能でなければならない
 - C++11から : `binary_op`の戻り値が、`InputIterator`の値型に変換可能でなければならない
 - C++11から : `binary_op`の戻り値が、`result`出力イテレータに書き込めなければならない
-- C++11から : `binary_op`は入力範囲`[first, last]`および出力範囲`[result, result + (last - first)]`の要素を変更してはならず、そのイテレータと部分範囲を無効化してはならない
+- C++11から : `binary_op`は入力イテレータ範囲`[first, last]`および出力イテレータ範囲`[result, result + (last - first)]`の要素を変更してはならず、そのイテレータと部分範囲を無効化してはならない
 
 
 ## 効果
 - (1) : `binary_op`を`operator+`として、(2)の演算を行う
-- (2) : 出力結果の範囲`[result, result + (last - first))`には、以下が書き込まれる：
+- (2) : 出力結果のイテレータ範囲`[result, result + (last - first))`には、以下が書き込まれる：
     - C++03 :
 
     ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iota -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/ranges_iota.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/ranges_iota.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/ranges_iota.md b/reference/numeric/ranges_iota.md
index 07df75b5f..afd8ae3e7 100644
--- a/reference/numeric/ranges_iota.md
+++ b/reference/numeric/ranges_iota.md
@@ -28,8 +28,8 @@ namespace std::ranges {
 ## 概要
 指定された値から始まる、インクリメント演算子による増加列を生成する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 `iota()`関数は、値の範囲`[value, value + (last - first))`を前から順番に範囲`[first, last)`の各要素に代入する。
 
@@ -37,7 +37,7 @@ namespace std::ranges {
 
 
 ## 効果
-範囲`[first, last)`の各要素`it`について、先頭から順番に `*it = value; ++value;` を行う
+イテレータ範囲`[first, last)`の各要素`it`について、先頭から順番に `*it = value; ++value;` を行う
 
 
 ## 戻り値
@@ -45,7 +45,7 @@ namespace std::ranges {
 
 
 ## 計算量
-範囲`[first, last)`の要素数をnとして、n回のインクリメントと代入が行われる。
+イテレータ範囲`[first, last)`の要素数をnとして、n回のインクリメントと代入が行われる。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reduce -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/reduce.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/reduce.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/reduce.md b/reference/numeric/reduce.md
index 755e20e55..c49640fea 100644
--- a/reference/numeric/reduce.md
+++ b/reference/numeric/reduce.md
@@ -50,11 +50,11 @@ namespace std{
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-`reduce()`は、範囲を集計する関数である。[`accumulate()`](accumulate.md)関数は範囲の先頭から順に要素を集計するが、この関数は並列計算のために集計順を規定しない。
+`reduce()`は、イテレータ範囲`[first, last)`を集計する関数である。[`accumulate()`](accumulate.md)関数は範囲の先頭から順に要素を集計するが、この関数は並列計算のために集計順を規定しない。
 
-初期値(`init`)と範囲`[first, last)`を合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
+初期値(`init`)とイテレータ範囲`[first, last)`を合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
 
-- (1) : 集計の初期値を範囲の要素型の値初期化値 (算術型なら`0`) とし、二項演算に`operator+`を使用する。それによって、このオーバーロードは、範囲の合計値を求める処理となる
+- (1) : 集計の初期値をイテレータ範囲の要素型の値初期化値 (算術型なら`0`) とし、二項演算に`operator+`を使用する。それによって、このオーバーロードは、範囲の合計値を求める処理となる
 - (2) : 初期値をパラメータ`init`として受け取り、二項演算は`operator+`を使用する
 - (3) : 初期値をパラメータ`init`として受け取り、任意の二項演算`binary_op`を使用して集計を行う
 - (4) : (1)の並列アルゴリズム版。第1パラメータとして実行ポリシーをとる
@@ -63,7 +63,7 @@ namespace std{
 
 
 ## 要件
-- (3), (6) : 関数オブジェクト`binary_op`の呼び出しは、範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
+- (3), (6) : 関数オブジェクト`binary_op`の呼び出しは、イテレータ範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
@@ -89,7 +89,7 @@ namespace std{
     ```
     * plus[link /reference/functional/plus.md]
 
-- (3), (6) : 範囲`[first, last)`について、リスト`[init, *first, *(first + 1), *(first + 2), ... *(first + (last - first - 1))]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op(sum1, sum2)`のように集計して返す
+- (3), (6) : イテレータ範囲`[first, last)`について、リスト`[init, *first, *(first + 1), *(first + 2), ... *(first + (last - first - 1))]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op(sum1, sum2)`のように集計して返す
 
 - (4) : 以下と等価
     ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform_exclusive_scan -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/transform_exclusive_scan.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/transform_exclusive_scan.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/transform_exclusive_scan.md b/reference/numeric/transform_exclusive_scan.md
index 52fd1d58c..1ec2938fc 100644
--- a/reference/numeric/transform_exclusive_scan.md
+++ b/reference/numeric/transform_exclusive_scan.md
@@ -40,7 +40,7 @@ namespace std{
 ```
 
 ## 概要
-範囲の要素を変換しながら部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含めず範囲`[0, i)`までの部分和を計算する。
+イテレータ範囲`[first, last)`の要素を変換しながら部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含めず範囲`[0, i)`までの部分和を計算する。
 
 `transform_exclusive_scan()`の引数として初期値`0`、シーケンス`{1, 2, 3}`が与えられ、和に相当する二項演算関数オブジェクト`binary_op`を`operator+`、要素変換の関数オブジェクト`unary_op`をパラメータをそのまま返す関数`f()`であるとして、、以下のような結果が行われる：
 
@@ -58,7 +58,7 @@ namespace std{
 
 ## 要件
 - (1), (2) :
-    - 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
+    - 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform_inclusive_scan -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/transform_inclusive_scan.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/transform_inclusive_scan.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/transform_inclusive_scan.md b/reference/numeric/transform_inclusive_scan.md
index 86a5fd071..8c604ea5d 100644
--- a/reference/numeric/transform_inclusive_scan.md
+++ b/reference/numeric/transform_inclusive_scan.md
@@ -68,7 +68,7 @@ namespace std{
 ```
 
 ## 概要
-範囲の要素を変換しながら部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含め、範囲`[0, i]`までの部分和を計算する。
+イテレータ範囲`[first, last)`の要素を変換しながら部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含め、範囲`[0, i]`までの部分和を計算する。
 
 `transform_inclusive_scan()`の引数として、初期値`0`、シーケンス`{1, 2, 3}`が与えられ、和に相当する二項演算関数オブジェクト`binary_op`を`operator+`、要素変換の関数オブジェクト`unary_op`をパラメータをそのまま返す関数`f()`であるとして、以下のような結果が行われる：
 
@@ -89,7 +89,7 @@ namespace std{
 
 
 ## 要件
-- (1), (2), (3), (4) : 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
+- (1), (2), (3), (4) : 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform_reduce -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/transform_reduce.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/transform_reduce.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/transform_reduce.md b/reference/numeric/transform_reduce.md
index ae05eaadd..0c5a6d108 100644
--- a/reference/numeric/transform_reduce.md
+++ b/reference/numeric/transform_reduce.md
@@ -84,11 +84,11 @@ namespace std{
 ```
 
 ## 概要
-`transform_reduce()`は、範囲の要素を変換しながら集計する関数である。
+`transform_reduce()`は、イテレータ範囲の要素を変換しながら集計する関数である。
 
-(1)、(2)、(4)、(5)は、範囲`[first1, last1)`の各要素を`x`、範囲`[first2, first2+(last1 - first1))`の各要素を`y`として、初期値(`init`)と`binary_op2(x, y)`した各要素を合算したリストの任意の組み合わせに、順不同で`binary_op1(binary_op1(a, b), binary_op1(c, d))`のように適用していき、集計値を計算する。
+(1)、(2)、(4)、(5)は、イテレータ範囲`[first1, last1)`の各要素を`x`、イテレータ範囲`[first2, first2+(last1 - first1))`の各要素を`y`として、初期値(`init`)と`binary_op2(x, y)`した各要素を合算したリストの任意の組み合わせに、順不同で`binary_op1(binary_op1(a, b), binary_op1(c, d))`のように適用していき、集計値を計算する。
 
-(3)と(6)は、初期値(`init`)と、範囲`[first, last)`の各要素に関数オブジェクト`unary_op`を適用して合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
+(3)と(6)は、初期値(`init`)と、イテレータ範囲`[first, last)`の各要素に関数オブジェクト`unary_op`を適用して合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
 
 - (1) : リスト集計の二項演算に`operator+`を使用し、2つの範囲の要素を掛け合わせる二項演算に`operator*`を使用する
 - (2) : リスト集計の二項演算に`binary_op1`を使用し、2つの範囲の要素を掛け合わせる二項演算に`binary_op2`を使用する
@@ -99,8 +99,8 @@ namespace std{
 
 
 ## 要件
-- (1), (2), (4), (5) : 関数オブジェクト`binary_op1`と`binary_op2`の呼び出しは、範囲`[first1, last1]`と`[first2, first2 + (last1 - first1)]`の要素変更およびイテレータの無効化をしてはならない
-- (3), (6) : 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
+- (1), (2), (4), (5) : 関数オブジェクト`binary_op1`と`binary_op2`の呼び出しは、イテレータ範囲`[first1, last1]`と`[first2, first2 + (last1 - first1)]`の要素変更およびイテレータの無効化をしてはならない
+- (3), (6) : 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、イテレータ範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
@@ -125,9 +125,9 @@ namespace std{
     * plus[link /reference/functional/plus.md]
     * multiplies[link /reference/functional/multiplies.md]
 
-- (2), (5) : 範囲`[first1, last1)`と`[first2, first2+(last1 - first1))`について、リスト`[init, binary_op2(*first1, *first2), binary_op2(*(first1 + 1), *(first2 + 1)), binary_op2(*(first1 + 2), *(first2 + 2)), ...]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op1(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op1(sum1, sum2)`のように集計して返す
+- (2), (5) : イテレータ範囲`[first1, last1)`と`[first2, first2+(last1 - first1))`について、リスト`[init, binary_op2(*first1, *first2), binary_op2(*(first1 + 1), *(first2 + 1)), binary_op2(*(first1 + 2), *(first2 + 2)), ...]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op1(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op1(sum1, sum2)`のように集計して返す
 
-- (3), (6) : 範囲`[first, last)`について、リスト`[init, unary_op(*first), unary_op(*(first + 1)), unary_op(*(first + 2)), ... unary_op(*(first + (last - first - 1)))]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op(sum1, sum2)`のように集計して返す
+- (3), (6) : イテレータ範囲`[first, last)`について、リスト`[init, unary_op(*first), unary_op(*(first + 1)), unary_op(*(first + 2)), ... unary_op(*(first + (last - first - 1)))]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op(sum1, sum2)`のように集計して返す
 
 - (4) : 以下と等価
     ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/queue/priority_queue/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/queue/priority_queue/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/queue/priority_queue/op_constructor.md b/reference/queue/priority_queue/op_constructor.md
index 6ea308258..12aebaeb3 100644
--- a/reference/queue/priority_queue/op_constructor.md
+++ b/reference/queue/priority_queue/op_constructor.md
@@ -174,11 +174,11 @@ int main()
   // que2からムーブ構築
   std::priority_queue&amp;lt;int&amp;gt; que3 = std::move(que2);
 
-  // イテレータの範囲から構築
+  // イテレータ範囲から構築
   const std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
   std::priority_queue&amp;lt;int&amp;gt; que4(v.begin(), v.end());
 
-  // イテレータの範囲、比較関数オブジェクト、コンテナから構築
+  // イテレータ範囲、比較関数オブジェクト、コンテナから構築
   const std::vector&amp;lt;int&amp;gt; v2 = {5, 2};
   std::priority_queue&amp;lt;int&amp;gt; que5(v.begin(), v.end(), {}, v2);
 
@@ -208,4 +208,4 @@ que5 : 5 4 3 2 1
 
 ## 参照
 
-- [P0935R0 Eradicating unnecessarily explicit default constructors from the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0935r0.html)
\ No newline at end of file
+- [P0935R0 Eradicating unnecessarily explicit default constructors from the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0935r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>subrange -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/ranges/subrange.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange.md b/reference/ranges/subrange.md
index 6d5d3a8ce..816694692 100644
--- a/reference/ranges/subrange.md
+++ b/reference/ranges/subrange.md
@@ -18,7 +18,7 @@ namespace std::ranges {
 * view_interface[link view_interface.md]
 
 ## 概要
-`subrange`は、イテレータ`i`と番兵`s`が表す範囲`[i, s)`をRangeとして扱うクラステンプレート。
+`subrange`は、イテレータ`i`と番兵`s`が表すイテレータ範囲`[i, s)`をRangeとして扱うクラステンプレート。
 
 `subrange`は[`borrowed_range`](borrowed_range.md)、[`view`](view.md)のモデルであり、また、大きさ2のtuple-likeな型である。第0要素はイテレータ、第1要素は番兵。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/ranges/subrange/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/op_constructor.md b/reference/ranges/subrange/op_constructor.md
index 4f5a4a2d3..6abc563de 100644
--- a/reference/ranges/subrange/op_constructor.md
+++ b/reference/ranges/subrange/op_constructor.md
@@ -40,8 +40,8 @@ constexpr subrange(R&amp;amp;&amp;amp; r, make-unsigned-like-t&amp;lt;iter_difference_t&amp;lt;I&amp;gt;&amp;gt; n)
 
 ## 概要
 - (1) : 空の`subrange`を構築する(デフォルトコンストラクタ)
-- (2) : イテレータ`i`と番兵`s`が表す範囲`[i, s)`で初期化する
-- (3) : イテレータ`i`と番兵`s`が表す範囲`[i, s)`で初期化し、`subrange`の長さを`n`にする
+- (2) : イテレータ`i`と番兵`s`が表すイテレータ範囲`[i, s)`で初期化する
+- (3) : イテレータ`i`と番兵`s`が表すイテレータ範囲`[i, s)`で初期化し、`subrange`の長さを`n`にする
 - (4) : 範囲 `r` で初期化する
 - (5) : 範囲 `r` で初期化し、`subrange`の長さを`n`にする ((3)へ委譲)
 
@@ -65,8 +65,8 @@ static constexpr bool StoreSize = (K == subrange_kind::sized &amp;amp;&amp;amp; !sized_sentinel_
 
 ## 事前条件
 
-- (2): `[i, s)`は有効な範囲であること
-- (3): `[i, s)`は有効な範囲であり、`n`はその範囲の長さ([`ranges::distance](/reference/iterator/ranges_distance.md)`(i, s)`)と等しいこと
+- (2): `[i, s)`は有効なイテレータ範囲であること
+- (3): `[i, s)`は有効なイテレータ範囲であり、`n`はその範囲の長さ([`ranges::distance](/reference/iterator/ranges_distance.md)`(i, s)`)と等しいこと
 - (4): `r`は有効な範囲であること
 - (5): `r`は有効な範囲であり、`n`はその範囲の長さと等しいこと
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/multiset/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/erase.md b/reference/set/multiset/erase.md
index d306aa296..5d22911a4 100644
--- a/reference/set/multiset/erase.md
+++ b/reference/set/multiset/erase.md
@@ -16,14 +16,14 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 概要
-単一要素または要素範囲（`[first, last)`）を `multiset` コンテナから削除する。 
+単一要素またはイテレータ範囲`[first, last)`を `multiset` コンテナから削除する。 
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 
 ## パラメータ
 - `position` : `multiset` から削除する単一要素を指すイテレータ。`iterator`、および、`const_iterator` はメンバ型であり、双方向イテレータとして定義される。
 - `x` : `set` から削除される値。`key_type` はメンバ型であり、`multiset` コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素の型である。
-- `first, last` : `multiset` コンテナ内の、削除される範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+- `first, last` : `multiset` コンテナ内の、削除されるイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/multiset/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/op_equal.md b/reference/set/multiset/op_equal.md
index 4ec2134ac..1c3cc1ac2 100644
--- a/reference/set/multiset/op_equal.md
+++ b/reference/set/multiset/op_equal.md
@@ -62,6 +62,6 @@ int main()
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/set/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/set/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/erase.md b/reference/set/set/erase.md
index 3ab8a206e..7dfa75ab7 100644
--- a/reference/set/set/erase.md
+++ b/reference/set/set/erase.md
@@ -16,14 +16,14 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 概要
-単一要素または要素範囲（`[first, last)`）を `set` コンテナから削除する。 
+単一要素またはイテレータ範囲`[first, last)`を `set` コンテナから削除する。 
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 
 ## パラメータ
 - `position` : `set` から削除する単一要素を指すイテレータ。`iterator`、および、`const_iterator` はメンバ型であり、双方向イテレータとして定義される。
 - `x` : `set` から削除される値。`key_type` はメンバ型であり、`set` コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素の型である。
-- `first, last` : `set` コンテナ内の、削除される範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+- `first, last` : `set` コンテナ内の、削除されるイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/set/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/set/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/op_constructor.md b/reference/set/set/op_constructor.md
index cb27c3e8b..d87fbf344 100644
--- a/reference/set/set/op_constructor.md
+++ b/reference/set/set/op_constructor.md
@@ -49,7 +49,7 @@ set(initializer_list&amp;lt;value_type&amp;gt; init,
 - (2) : 比較関数オブジェクトを受け取るコンストラクタ。受け取った比較関数オブジェクトを、このコンテナでの要素比較に使用する。要素数が空の`set`オブジェクトを構築する。
 - (1) + (2) : デフォルトコンストラクタ。空のコンテナを構築する。
 - (3) : アロケータを別で受け取り、要素数が空の`set`オブジェクトを構築する。
-- (4) : 範囲 `[first, last)` のコンテンツで構築する。
+- (4) : イテレータ範囲 `[first, last)` のコンテンツで構築する。
 - (5) : (4)のコンストラクタを `set(first, last, Compare(), a)` のように呼び出して、`set`オブジェクトを構築する。
 - (6), (8) : コピーコンストラクタ。`x`のコンテンツのコピーでコンテナを構築する。もし `alloc` が与えられなかった場合、アロケータを `std::`[`allocator_traits`](../../memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`select_on_container_copy_construction`](../../memory/allocator_traits/select_on_container_copy_construction.md)`(x.`[`get_allocator`](get_allocator.md)`())` の呼び出しによって取得する。
 - (7), (9) : ムーブコンストラクタ。`y` のコンテンツをムーブすることでコンテナを構築する。もし `alloc` が与えられなかった場合、アロケータを `y` に属しているアロケータをムーブして取得する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/set/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/set/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/op_equal.md b/reference/set/set/op_equal.md
index 8c0fd1e0e..187e927cb 100644
--- a/reference/set/set/op_equal.md
+++ b/reference/set/set/op_equal.md
@@ -62,6 +62,6 @@ int main()
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/span/span/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/span/span/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/op_constructor.md b/reference/span/span/op_constructor.md
index 06765a532..39633c584 100644
--- a/reference/span/span/op_constructor.md
+++ b/reference/span/span/op_constructor.md
@@ -92,11 +92,11 @@ constexpr explicit(extent != dynamic_extent &amp;amp;&amp;amp; OtherExtent == dynamic_extent)
 
 ## 事前条件
 - (2) :
-    - `[first, first + count)`が妥当な範囲であること
+    - `[first, first + count)`が妥当なイテレータ範囲であること
     - 型 `It` はコンセプト [`std::contiguous_iterator`](/reference/iterator/contiguous_iterator.md) のモデルであること
     - メンバ定数`extent`が[`dynamic_extent`](/reference/span/dynamic_extent.md)と等値ではない場合、`count`と`extent`が等値であること
 - (3) :
-    - `[first, last)`が妥当な範囲であること
+    - `[first, last)`が妥当なイテレータ範囲であること
     - メンバ定数`extent`が[`dynamic_extent`](/reference/span/dynamic_extent.md)と等値ではない場合、`last - first`と`extent`が等値であること
     - 型 `It` はコンセプト [`std::contiguous_iterator`](/reference/iterator/contiguous_iterator.md) のモデルであること
     - 型 `End` はコンセプト [`std::sized_sentinel_for`](/reference/iterator/sized_sentinel_for.md)`&amp;lt;It&amp;gt;` のモデルであること
@@ -109,8 +109,8 @@ constexpr explicit(extent != dynamic_extent &amp;amp;&amp;amp; OtherExtent == dynamic_extent)
 
 
 ## 効果
-- (2) : 範囲`[first, first + count)`を参照する`span`オブジェクトを構築する
-- (3) : 範囲`[first, last)`を参照する`span`オブジェクトを構築する
+- (2) : イテレータ範囲`[first, first + count)`を参照する`span`オブジェクトを構築する
+- (3) : イテレータ範囲`[first, last)`を参照する`span`オブジェクトを構築する
 - (4), (5), (6) : 範囲`[`[`data`](/reference/iterator/data.md)`(arr),` [`data`](/reference/iterator/data.md)`(arr) + N)`を参照する`span`オブジェクトを構築する
 - (7) : 範囲`[std::ranges::data(r), std::ranges::data(r) + std::ranges::size(r))`を参照する`span`オブジェクトを構築する
 - (9) : 範囲`[s.`[`data()`](data.md)`, s.`[`data()`](data.md) `+ s.`[`size()`](size.md)`)`を参照する`span`オブジェクトを構築する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>current -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/stacktrace/basic_stacktrace/current.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/stacktrace/basic_stacktrace/current.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stacktrace/basic_stacktrace/current.md b/reference/stacktrace/basic_stacktrace/current.md
index 9e18a3e87..f1a5e8f9b 100644
--- a/reference/stacktrace/basic_stacktrace/current.md
+++ b/reference/stacktrace/basic_stacktrace/current.md
@@ -37,10 +37,10 @@ static basic_stacktrace
     - `alloc`は[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数に渡される
 - (2) :
     - `basic_stacktrace::current(alloc)`で構築されたオブジェクト`st`の[`st.size()`](size.md)を`n`として、
-    - 範囲`[st.begin() + min(n, skip), st.end())`と`alloc`を、[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数として保持する。ただし、その初期化に失敗した場合、`basic_stacktrace`オブジェクトは空になる
+    - イテレータ範囲`[st.begin() + min(n, skip), st.end())`と`alloc`を、[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数として保持する。ただし、その初期化に失敗した場合、`basic_stacktrace`オブジェクトは空になる
 - (3) :
     - `basic_stacktrace::current(alloc)`で構築されたオブジェクト`st`の[`st.size()`](size.md)を`n`として、
-    - 範囲`[st.begin() + min(n, skip), st.begin() + min(n, skip + max_depth))`と`alloc`を、[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数として保持する。ただし、その初期化に失敗した場合、`basic_stacktrace`オブジェクトは空になる
+    - イテレータ範囲`[st.begin() + min(n, skip), st.begin() + min(n, skip + max_depth))`と`alloc`を、[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数として保持する。ただし、その初期化に失敗した場合、`basic_stacktrace`オブジェクトは空になる
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>append -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/append.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/append.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/append.md b/reference/string/basic_string/append.md
index 593e99a65..8ebc7b88d 100644
--- a/reference/string/basic_string/append.md
+++ b/reference/string/basic_string/append.md
@@ -73,10 +73,10 @@ constexpr basic_string&amp;amp;
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const T&amp;amp;, const charT*&amp;gt; == false`
 
 ## 要件
-- (2) では、`pos &amp;lt;=` [`size`](size.md)`()` であること。
-- (3) では、`s` は少なくとも `n` の長さを持つ `charT` 型の配列を指していること。
-- (4) では、`s` は少なくとも `traits_type::length(s) + 1` の長さを持つ `charT` 型の配列を指していること。
-- (6) では、`[first, last)` が有効な範囲であること。
+- (2) : `pos &amp;lt;=` [`size`](size.md)`()` であること。
+- (3) : `s` は少なくとも `n` の長さを持つ `charT` 型の配列を指していること。
+- (4) : `s` は少なくとも `traits_type::length(s) + 1` の長さを持つ `charT` 型の配列を指していること。
+- (6) : `[first, last)` が有効なイテレータ範囲であること。
 
 
 ## 効果
@@ -100,7 +100,7 @@ constexpr basic_string&amp;amp;
 - (5) 対象オブジェクトの末尾に、文字 `c` が `n` 文字追加（コピー）される。
     * `append(`[`basic_string`](op_constructor.md)`&amp;lt;value_type, traits_type, allocator_type&amp;gt;(n, c))` と等価。
 
-- (6) 対象オブジェクトの末尾に、範囲 `[first, last)` の文字列が追加（コピー）される。
+- (6) 対象オブジェクトの末尾に、イテレータ範囲 `[first, last)` の文字列が追加（コピー）される。
     * `append(`[`basic_string`](op_constructor.md)`&amp;lt;value_type, traits_type, allocator_type&amp;gt;(first, last))` と等価。
 
 - (7) 対象オブジェクトの末尾に初期化リスト `il` で表された文字列が追加される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/assign.md b/reference/string/basic_string/assign.md
index 0e5cb3015..cb7ef5d7c 100644
--- a/reference/string/basic_string/assign.md
+++ b/reference/string/basic_string/assign.md
@@ -93,7 +93,7 @@ constexpr basic_string&amp;amp;
     - `assign(s,` [`traits::length`](/reference/string/char_traits/length.md)`(s))`を呼び出す。
 - (6) : 文字`c`の`n`回繰り返した文字列からなる`basic_string`オブジェクトを構築する。
     - `assign(basic_string(n, c))`と等価。
-- (7) : 文字列の範囲`[begin, end)`から`basic_string`オブジェクトを構築する。
+- (7) : 文字列のイテレータ範囲`[begin, end)`から`basic_string`オブジェクトを構築する。
     - `assign(basic_string(first, last))`と等価。
 - (8) : 文字の初期化子リストから`basic_string`オブジェクトを構築する。
     - `assign(il.begin(), il.end())`を呼び出す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/erase.md b/reference/string/basic_string/erase.md
index ae00ecada..3c66ba808 100644
--- a/reference/string/basic_string/erase.md
+++ b/reference/string/basic_string/erase.md
@@ -42,7 +42,7 @@ constexpr iterator
 ## 効果
 - (1) : `n`と[`size()`](size.md) `- pos`のうち小さい方を`xlen`とし、`pos`番目から`xlen`個の要素を削除する。
 - (2) : イテレータ`p`が指す要素を削除する。
-- (3) : 範囲`[first, last)`の文字列を削除する。
+- (3) : イテレータ範囲`[first, last)`の文字列を削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_constructor.md b/reference/string/basic_string/op_constructor.md
index cae297a95..b64ae154e 100644
--- a/reference/string/basic_string/op_constructor.md
+++ b/reference/string/basic_string/op_constructor.md
@@ -113,7 +113,7 @@ basic_string(nullptr_t) = delete; // (16) C++23
 - (7) : 文字配列`s`の先頭`n`文字からなる部分文字列のコピーから`basic_string`オブジェクトを構築する。
 - (8) : 文字配列`s`のコピーから`basic_string`オブジェクトを構築する。
 - (9) : 文字`c`の`n`回繰り返した文字列からなる`basic_string`オブジェクトを構築する。
-- (10) : 文字列の範囲`[begin, end)`から`basic_string`オブジェクトを構築する。
+- (10) : 文字列のイテレータ範囲`[begin, end)`から`basic_string`オブジェクトを構築する。
 - (11) : 文字の初期化子リストから`basic_string`オブジェクトを構築する。
 - (12) : アロケータを受け取るコピーコンストラクタ。
 - (13) : アロケータを受け取るムーブコンストラクタ。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/replace.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/replace.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/replace.md b/reference/string/basic_string/replace.md
index 47abcbde2..1ffedb7c8 100644
--- a/reference/string/basic_string/replace.md
+++ b/reference/string/basic_string/replace.md
@@ -201,13 +201,13 @@ constexpr basic_string&amp;amp;
 - (2) : `pos1 &amp;lt;=` [`size()`](size.md)、および`pos2 &amp;lt;= str.`[`size()`](size.md)であること。
 - (3) : `pos1 &amp;lt;=` [`size()`](size.md)、および文字配列へのポインタ`s`が、少なくても`n2`個の要素を持つ配列を指していること。
 - (4) : `pos &amp;lt;=` [`size()`](size.md)、および文字配列へのポインタ`s`が、少なくても[`traits::length`](/reference/string/char_traits/length.md)`(s) + 1`個の要素を指す配列を指していること。
-- (6) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。
-- (7) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。また、文字配列へのポインタ`s`が、少なくても`n`個の要素を持つ配列を指していること。
-- (8) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。および文字配列へのポインタ`s`が、少なくても[`traits::length`](/reference/string/char_traits/length.md)`(s) + 1`個の要素を指す配列を指していること。
-- (9) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。
-- (10) : `[`[`begin()`](begin.md)`, i1)`、`[i1, i2)`、および`[j1, j2)`が有効な範囲であること。
-- (11) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。
-- (14) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。
+- (6) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。
+- (7) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。また、文字配列へのポインタ`s`が、少なくても`n`個の要素を持つ配列を指していること。
+- (8) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。および文字配列へのポインタ`s`が、少なくても[`traits::length`](/reference/string/char_traits/length.md)`(s) + 1`個の要素を指す配列を指していること。
+- (9) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。
+- (10) : `[`[`begin()`](begin.md)`, i1)`、`[i1, i2)`、および`[j1, j2)`が有効なイテレータ範囲であること。
+- (11) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。
+- (14) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;&lt; -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string_view/basic_string_view/op_ostream.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string_view/basic_string_view/op_ostream.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string_view/basic_string_view/op_ostream.md b/reference/string_view/basic_string_view/op_ostream.md
index 2ae0c4d97..bce2a8bc2 100644
--- a/reference/string_view/basic_string_view/op_ostream.md
+++ b/reference/string_view/basic_string_view/op_ostream.md
@@ -16,7 +16,7 @@ namespace std {
 文字列をストリームへ出力する。
 
 ## 効果
-`[sv.`[`begin()`](begin.md)`, sv.`[`end()`](end.md)`)`の範囲の文字を`os`に出力する。
+イテレータ範囲`[sv.`[`begin()`](begin.md)`, sv.`[`end()`](end.md)`)`の文字を`os`に出力する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_map/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/erase.md b/reference/unordered_map/unordered_map/erase.md
index 1e94b8032..cfbdeb6f0 100644
--- a/reference/unordered_map/unordered_map/erase.md
+++ b/reference/unordered_map/unordered_map/erase.md
@@ -26,7 +26,7 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 ## 効果
 - (1) : `position` で指定された要素を削除する。
 - (2) : `k` と等価なキーの要素を削除する。
-- (3) : `[first, last)` の範囲にある要素を全て削除する。
+- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_map/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/insert.md b/reference/unordered_map/unordered_map/insert.md
index 3f6c2052f..81f309137 100644
--- a/reference/unordered_map/unordered_map/insert.md
+++ b/reference/unordered_map/unordered_map/insert.md
@@ -42,7 +42,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
         - なお、C++11 では「`P` が `value_type` に暗黙変換可能」という、より厳しい条件の記載になってしまっていた。これは規格の誤りとして C++14 で修正されたが、使用する処理系やバージョンによる挙動の差異に注意が必要である
 - (4), (6) : `position` は、このコンテナの有効な読み取り専用イテレータであること
 - (7) :
-    - 引数 `first`、および、`last`は、入力イテレータの要件を満たし、参照先の要素は `value_type` 型で、かつ、範囲 `[first, last)` がこのコンテナ **以外を指す** 有効な範囲であること
+    - 引数 `first`、および、`last`は、入力イテレータの要件を満たし、参照先の要素は `value_type` 型で、かつ、イテレータ範囲 `[first, last)` がこのコンテナ **以外を指す** 有効な範囲であること
     - このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能であること
 - (8) : `value_type` はこのコンテナに対してコピー挿入可能であること
 - (9), (10) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`でなければならない
@@ -62,7 +62,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
     - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない
     - このバージョンの動作は、[`emplace_hint`](emplace_hint.md)`(hint,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(obj))` を呼び出した場合と等価である
 - (7) :
-    - 範囲 `[first, last)` のすべての要素 `t` に対して、`insert(t)` を呼び出した場合と等価である（`*first` の型によって (1)、あるいは(3)の形式が呼び出される）。
+    - イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、`insert(t)` を呼び出した場合と等価である（`*first` の型によって (1)、あるいは(3)の形式が呼び出される）。
 - (8) :
     - (7)の形式を `insert(il.`[`begin`](/reference/initializer_list/initializer_list/begin.md)`(), il.`[`end`](/reference/initializer_list/initializer_list/end.md)`())` として呼び出した場合と等価である
 - (9) :
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_map/op_assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_assign.md b/reference/unordered_map/unordered_map/op_assign.md
index a037e044f..78d4f8134 100644
--- a/reference/unordered_map/unordered_map/op_assign.md
+++ b/reference/unordered_map/unordered_map/op_assign.md
@@ -40,7 +40,7 @@ unordered_map&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 	[`max_load_factor`](max_load_factor.md)`()` の値はコピーされる。
 	アロケータオブジェクトは、`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value` が `true` の場合に限りムーブされる。コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
-- (3) : 範囲 `[il.begin(), il.end())` がコピー代入される。
+- (3) : イテレータ範囲 `[il.begin(), il.end())` がコピー代入される。
 	コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_map/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_constructor.md b/reference/unordered_map/unordered_map/op_constructor.md
index f284dac00..460492d9c 100644
--- a/reference/unordered_map/unordered_map/op_constructor.md
+++ b/reference/unordered_map/unordered_map/op_constructor.md
@@ -97,7 +97,7 @@ unordered_map(initializer_list&amp;lt;value_type&amp;gt; il,
 - (1) + (2) バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で、要素を持たない空の `unordered_map` を構築する。
     引数 `n` のデフォルト値は実装依存である。
 
-- (3) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で `unordered_map` が構築された後、`[first, last)` の範囲の要素が挿入される。
+- (3) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で `unordered_map` が構築された後、イテレータ範囲`[first, last)` の要素が挿入される。
 
 - (4) : コピーコンストラクタ。`v` の全ての要素をコピーした、`unordered_map` を構築する。
     ハッシュ関数オブジェクトとキー比較関数オブジェクト、および、[`max_load_factor`](max_load_factor.md)`()` の値も `v` からコピーされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_multimap/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/erase.md b/reference/unordered_map/unordered_multimap/erase.md
index f8761b3eb..804e96d93 100644
--- a/reference/unordered_map/unordered_multimap/erase.md
+++ b/reference/unordered_map/unordered_multimap/erase.md
@@ -26,7 +26,7 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 ## 効果
 - (1) : `position` で指定された要素を削除する。
 - (2) : `k` と等価なキーの要素を削除する。
-- (3) : `[first, last)` の範囲にある要素を全て削除する。
+- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_multimap/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/insert.md b/reference/unordered_map/unordered_multimap/insert.md
index c38f54adb..ddac0d8b6 100644
--- a/reference/unordered_map/unordered_multimap/insert.md
+++ b/reference/unordered_map/unordered_multimap/insert.md
@@ -41,7 +41,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
     - [`std::constructible_from`](/reference/concepts/constructible_from.md)`&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;`要件を満たすこと
         - なお、C++11 では「`P` が `value_type` に暗黙変換可能」という、より厳しい条件の記載になってしまっていた。これは規格の誤りとして C++14 で修正されたが、使用する処理系やバージョンによる挙動の差異に注意が必要である
 - (7) :
-    - 引数 `first`、および、`last`は、入力イテレータの要件を満たし、参照先の要素は `value_type` 型で、かつ、範囲 `[first, last)` が当該コンテナ **以外を指す** 有効な範囲であること
+    - 引数 `first`、および、`last`は、入力イテレータの要件を満たし、参照先の要素は `value_type` 型で、かつ、イテレータ範囲 `[first, last)` が当該コンテナ **以外を指す** 有効な範囲であること
     - このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能であること
 - (8) : `value_type` はこのコンテナに対してコピー挿入可能であること
 - (9), (10)の形式では、 `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`でなければならない。
@@ -61,7 +61,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
     - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない
     - このバージョンの動作は、[`emplace_hint`](emplace_hint.md)`(hint,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(obj))` を呼び出した場合と等価である
 - (7) :
-    - 範囲 `[first, last)` のすべての要素 `t` に対して、`insert(t)` を呼び出した場合と等価である（`*first` の型によって (1)、あるいは(2)の形式が呼び出される）
+    - イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、`insert(t)` を呼び出した場合と等価である（`*first` の型によって (1)、あるいは(2)の形式が呼び出される）
 - (8) :
     - (7)の形式を `insert(il.`[`begin`](/reference/initializer_list/initializer_list/begin.md)`(), il.`[`end`](/reference/initializer_list/initializer_list/end.md)`())` として呼び出した場合と等価である
 - (9) :
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/op_assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_multimap/op_assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/op_assign.md b/reference/unordered_map/unordered_multimap/op_assign.md
index 7a522d6c0..dc4d79ae0 100644
--- a/reference/unordered_map/unordered_multimap/op_assign.md
+++ b/reference/unordered_map/unordered_multimap/op_assign.md
@@ -40,7 +40,7 @@ unordered_multimap&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 	[`max_load_factor`](max_load_factor.md)`()` の値はコピーされる。
 	アロケータオブジェクトは、`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value` が `true` の場合に限りムーブされる。コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
-- (3) : 範囲 `[il.begin(), il.end())` がコピー代入される。
+- (3) : イテレータ範囲 `[il.begin(), il.end())` がコピー代入される。
 	コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_multimap/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/op_constructor.md b/reference/unordered_map/unordered_multimap/op_constructor.md
index e766357df..16246a678 100644
--- a/reference/unordered_map/unordered_multimap/op_constructor.md
+++ b/reference/unordered_map/unordered_multimap/op_constructor.md
@@ -100,7 +100,7 @@ unordered_multimap(initializer_list&amp;lt;value_type&amp;gt; il,
 - (1) + (2) バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で、要素を持たない空の `unordered_multimap` を構築する。
     引数 `n` のデフォルト値は実装依存である。
 
-- (3) : (1)と同様に `unordered_multimap` が構築された後、`[first, last)` の範囲の要素が挿入される。
+- (3) : (1)と同様に `unordered_multimap` が構築された後、イテレータ範囲`[first, last)`の要素が挿入される。
 
 - (4) : コピーコンストラクタ。`v` の全ての要素をコピーした、`unordered_multimap` を構築する。
     ハッシュ関数オブジェクトとキー比較関数オブジェクト、および、[`max_load_factor`](max_load_factor.md)`()` の値も `v` からコピーされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_multiset/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/erase.md b/reference/unordered_set/unordered_multiset/erase.md
index 54c3d5456..683a634b6 100644
--- a/reference/unordered_set/unordered_multiset/erase.md
+++ b/reference/unordered_set/unordered_multiset/erase.md
@@ -26,7 +26,7 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 ## 効果
 - (1) : `position` で指定された要素を削除する。
 - (2) : `k` と等価なキーの要素を削除する。
-- (3) : `[first, last)` の範囲にある要素を全て削除する。
+- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_multiset/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/insert.md b/reference/unordered_set/unordered_multiset/insert.md
index 06f836c4f..5847a7f22 100644
--- a/reference/unordered_set/unordered_multiset/insert.md
+++ b/reference/unordered_set/unordered_multiset/insert.md
@@ -40,7 +40,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 - 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。  
 	なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
 
-- 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
+- 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
 	また、引数 `first`、および、`last` を引数にとる形式（(3)）では、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。  
 	ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
 
@@ -57,7 +57,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 - (1) : 引数 `v`、あるいは `rv` で指定した値の要素を追加する。
 - (2) : 引数 `v`、あるいは `rv` で指定した値の要素を追加する。  
 	引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
-- (3) : 範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
+- (3) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
 - (4) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
 - (5) : `nh`が空の場合、効果はない。そうでなければ、`nh`が所有する要素を挿入し、新しく挿入された要素を指すイテレータを返す。`nh.key()` と等価なキーを持つ要素を含む範囲がコンテナ内に存在する場合、要素はその範囲の終端に挿入される。
 - (6) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。そうでなければ、 `nh` によって所有されている要素をコンテナに挿入し、 `nh.key()` と等価なキーを持つ要素を指すイテレータを返す。 `nh.key()` と等しいキーを持つ要素を含む範囲がコンテナ内に存在する場合、要素はその範囲の終端に挿入される。要素は、`p`の直前の位置のできるだけ近くに挿入される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/op_assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_multiset/op_assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/op_assign.md b/reference/unordered_set/unordered_multiset/op_assign.md
index a12394850..881f7f268 100644
--- a/reference/unordered_set/unordered_multiset/op_assign.md
+++ b/reference/unordered_set/unordered_multiset/op_assign.md
@@ -40,7 +40,7 @@ unordered_multiset&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 	[`max_load_factor`](max_load_factor.md)`()` の値はコピーされる。
 	アロケータオブジェクトは、`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value` が `true` の場合に限りムーブされる。コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
-- (3) : 範囲 `[il.begin(), il.end())` がコピー代入される。
+- (3) : イテレータ範囲 `[il.begin(), il.end())` がコピー代入される。
 	コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_multiset/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/op_constructor.md b/reference/unordered_set/unordered_multiset/op_constructor.md
index 76dd75338..45cc19700 100644
--- a/reference/unordered_set/unordered_multiset/op_constructor.md
+++ b/reference/unordered_set/unordered_multiset/op_constructor.md
@@ -101,7 +101,7 @@ unordered_multiset(initializer_list&amp;lt;value_type&amp;gt; il,
 - (1) + (2) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で、要素を持たない空の `unordered_multiset` を構築する。
 	引数 `n` のデフォルト値は実装依存である。
 
-- (3) : (2)と同様に `unordered_multiset` が構築された後、`[first, last)` の範囲の要素が挿入される。
+- (3) : (2)と同様に `unordered_multiset` が構築された後、イテレータ範囲`[first, last)`の要素が挿入される。
 
 - (4) : コピーコンストラクタ。`v` の全ての要素をコピーした、`unordered_multiset` を構築する。
 	ハッシュ関数オブジェクトとキー比較関数オブジェクト、および、[`max_load_factor`](max_load_factor.md)`()` の値も `v` からコピーされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_set/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/erase.md b/reference/unordered_set/unordered_set/erase.md
index 4131c3ee2..835a8e0e1 100644
--- a/reference/unordered_set/unordered_set/erase.md
+++ b/reference/unordered_set/unordered_set/erase.md
@@ -26,7 +26,7 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 ## 効果
 - (1) : `position` で指定された要素を削除する。
 - (2) : `k` と等価なキーの要素を削除する。
-- (3) : `[first, last)` の範囲にある要素を全て削除する。
+- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_set/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/insert.md b/reference/unordered_set/unordered_set/insert.md
index 846ddf212..245d184a8 100644
--- a/reference/unordered_set/unordered_set/insert.md
+++ b/reference/unordered_set/unordered_set/insert.md
@@ -41,7 +41,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 - 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。  
 	なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
 
-- 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
+- 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
 	また、引数 `first`、および、`last` を引数にとる形式（(3)）では、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。  
 	ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
 
@@ -58,7 +58,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 - (1) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
 - (2) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。  
 	引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
-- (3) : 範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
+- (3) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
 - (4) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
 - (5) : `nh`が空の場合、効果はない。
 それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/op_assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_set/op_assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/op_assign.md b/reference/unordered_set/unordered_set/op_assign.md
index 82730726c..ab7b61faa 100644
--- a/reference/unordered_set/unordered_set/op_assign.md
+++ b/reference/unordered_set/unordered_set/op_assign.md
@@ -40,7 +40,7 @@ unordered_set&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 	[`max_load_factor`](max_load_factor.md)`()` の値はコピーされる。
 	アロケータオブジェクトは、`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value` が `true` の場合に限りムーブされる。コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
-- (3) : 範囲 `[il.begin(), il.end())` がコピー代入される。
+- (3) : イテレータ範囲 `[il.begin(), il.end())` がコピー代入される。
 	コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_set/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/op_constructor.md b/reference/unordered_set/unordered_set/op_constructor.md
index ed0988551..35b256e33 100644
--- a/reference/unordered_set/unordered_set/op_constructor.md
+++ b/reference/unordered_set/unordered_set/op_constructor.md
@@ -101,7 +101,7 @@ unordered_set(initializer_list&amp;lt;value_type&amp;gt; il,
 - (1) + (2) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で、要素を持たない空の `unordered_set` を構築する。
     引数 `n` のデフォルト値は実装依存である。
 
-- (3) : (2)と同様に `unordered_set` が構築された後、`[first, last)` の範囲の要素が挿入される。
+- (3) : (2)と同様に `unordered_set` が構築された後、イテレータ範囲`[first, last)`の要素が挿入される。
 
 - (4) : コピーコンストラクタ。`v` の全ての要素をコピーした、`unordered_set` を構築する。
     ハッシュ関数オブジェクトとキー比較関数オブジェクト、および、[`max_load_factor`](max_load_factor.md)`()` の値も `v` からコピーされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/valarray/valarray/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_constructor.md b/reference/valarray/valarray/op_constructor.md
index 7d4a314af..d8270d06b 100644
--- a/reference/valarray/valarray/op_constructor.md
+++ b/reference/valarray/valarray/op_constructor.md
@@ -28,7 +28,7 @@ valarray(initializer_list&amp;lt;T&amp;gt; init);   // (11) C++11 から
 - (1) : デフォルトコンストラクタ
 - (2) : `n`個の`T()`初期化された要素を保持した`valarray`オブジェクトを構築する。
 - (3) : `value`のコピーを`n`個要素として保持した`valarray`オブジェクトを構築する。
-- (4) : `[first, first + n)`の範囲を要素としてコピーした`valarray`オブジェクトを構築する。
+- (4) : イテレータ範囲`[first, first + n)`を要素としてコピーした`valarray`オブジェクトを構築する。
 - (5) : コピーコンストラクタ
 - (6) : ムーブコンストラクタ
 - (7) : [`slice_array`](/reference/valarray/slice_array.md)オブジェクトから`valarray`への変換を行う。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/vector/vector/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector/assign.md b/reference/vector/vector/assign.md
index a4457cbd4..677211063 100644
--- a/reference/vector/vector/assign.md
+++ b/reference/vector/vector/assign.md
@@ -32,7 +32,7 @@ constexpr void assign(initializer_list&amp;lt;T&amp;gt;); // (3) C++20
 
 
 ## 効果
-- (1) : `[first, last)`の範囲の要素のコピーで`*this`の要素を置き換える。
+- (1) : イテレータ範囲`[first, last)`の要素のコピーで`*this`の要素を置き換える。
 - (2) : `*this`の要素をすべて`n`個の`u`のコピーに置き換える。
 - (3) : `assign(il.begin(), il.end())`と等価。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/vector/vector/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector/erase.md b/reference/vector/vector/erase.md
index 5c8d8a31a..30b9ce33d 100644
--- a/reference/vector/vector/erase.md
+++ b/reference/vector/vector/erase.md
@@ -26,7 +26,7 @@ constexpr iterator erase(const_iterator first,
 
 ## 効果
 - (1) : `position`が指す要素が削除される。
-- (2) : `[first, last)`で示される範囲の要素が削除される。
+- (2) : `[first, last)`で示されるイテレータ範囲の要素が削除される。
 
 削除された要素またはそれ以降の要素を指すイテレータや参照は無効になる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/vector/vector/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector/op_constructor.md b/reference/vector/vector/op_constructor.md
index 963fb6a69..6c76bec67 100644
--- a/reference/vector/vector/op_constructor.md
+++ b/reference/vector/vector/op_constructor.md
@@ -73,7 +73,7 @@ constexpr vector(initializer_list&amp;lt;T&amp;gt; il,
 	- C++14 : アロケータ `a` を使用して、`n` 個の `T()` で初期化された要素を保持した `vector` オブジェクトを構築する。
 - (4) : 繰り返しシーケンスコンストラクタ。アロケータ `a` を使用して、`value` のコピーを `n` 個要素として保持した `vector` オブジェクトを構築する。
 - (3) + (4) : 繰り返しシーケンスコンストラクタ。アロケータ `a` を使用して、`value` のコピーを `n` 個要素として保持した `vector` オブジェクトを構築する。
-- (5) : イテレータ範囲コンストラクタ。アロケータ `a` を使用して、`[first, last)` の範囲を要素としてコピーした `vector` オブジェクトを構築する。
+- (5) : イテレータ範囲コンストラクタ。アロケータ `a` を使用して、イテレータ範囲`[first, last)` を要素としてコピーした `vector` オブジェクトを構築する。
 - (6) : コピーコンストラクタ。`x` と同じ要素を保持した `vector` オブジェクトを構築する。
 - (7) : ムーブコンストラクタ。`x` の指す先を自分の領域として `vector` オブジェクトを構築する。
 - (8) : アロケータを別で受け取り、`vector` オブジェクトをコピー構築する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>インライン変数 -- C++17インライン変数 : 名前のないクラスオブジェクトをインライン指定しても同じ実体にはならないことを記載</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/inline_variables.html"/>
      <id>e68299bcaf7535ffe11dcb21247647dd980bd6e7:lang/cpp17/inline_variables.md</id>
      <updated>2022-12-28T00:53:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/inline_variables.md b/lang/cpp17/inline_variables.md
index bb89382a8..10e98f1bb 100644
--- a/lang/cpp17/inline_variables.md
+++ b/lang/cpp17/inline_variables.md
@@ -94,6 +94,10 @@ function-specifier:
   explicit
 ```
 
+## 備考
+- 名前のないクラスのオブジェクトは、インライン指定しても同じ実体にはならない
+
+
 ## 例
 
 ```cpp example
@@ -264,3 +268,4 @@ func
 - [P0386R2 - Inline Variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf), 2016-06-24
 - [P0607R0 - Inline Variables for the Standard Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0607r0.html), 2017-02-27
 - [C++1z インライン変数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/11/11/172954)
+- [インライン変数が翻訳単位毎に別々の実体となってしまう - Stackoverflow](https://ja.stackoverflow.com/questions/93046/)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++11 -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/lang/cpp11.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:lang/cpp11.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++11&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++11とは、2011年8月に改訂され、ISO/IEC 14882:2011で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;前バージョンであるC++03からメジャーバージョンアップされ、多くの有用な機能が追加された。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++0xと呼ばれていた。これは、2009年中までに策定を完了させることを目指して、下一桁を伏せ字にしたものである。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;一般的な機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/auto.html&#34;&gt;auto&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型推論&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/decltype.html&#34;&gt;decltype&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;式の型を取得&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/range_based_for.html&#34;&gt;範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;配列やコンテナといった範囲を表すオブジェクトを、簡潔に走査する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/initializer_lists.html&#34;&gt;初期化子リスト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波括弧による初期化をユーザー定義する。&lt;code&gt;vector&amp;lt;int&amp;gt; v = {1, 2, 3};&lt;/code&gt;など。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/uniform_initialization.html&#34;&gt;一様初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタの呼び出しを、波カッコで行う。&lt;code&gt;T x {a, b, c};&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html&#34;&gt;右辺値参照・ムーブセマンティクス&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;右辺値によるオーバーロード、およびそれによるリソースの所有権移動&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/lambda_expressions.html&#34;&gt;ラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクトをその場に書く&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/noexcept.html&#34;&gt;noexcept&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の例外指定、例外を投げる可能性のある式か&lt;code&gt;bool&lt;/code&gt;値を返す演算子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/constexpr.html&#34;&gt;constexpr&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定数式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/nullptr.html&#34;&gt;nullptr&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ヌルポインタを表すポインタリテラル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/inline_namespaces.html&#34;&gt;インライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ネストした名前空間に、透過的にアクセスする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/user_defined_literals.html&#34;&gt;ユーザー定義リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リテラルのサフィックスをユーザー定義する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/defaulted_and_deleted_functions.html&#34;&gt;関数の&lt;code&gt;default&lt;/code&gt;／&lt;code&gt;delete&lt;/code&gt;宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;自動定義される特殊関数の制御&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/delegating_constructors.html&#34;&gt;委譲コンストラクタ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタから他のコンストラクタに処理を委譲する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/non_static_data_member_initializers.html&#34;&gt;非静的メンバ変数の初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ変数を、宣言と同時に初期値指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/inheriting_constructors.html&#34;&gt;継承コンストラクタ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;基底クラスのコンストラクタを継承する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/override_final.html&#34;&gt;&lt;code&gt;override&lt;/code&gt;と&lt;code&gt;final&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ関数のオーバーライド指定、および派生クラスでのオーバーライドの禁止を指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/explicit_conversion_operator.html&#34;&gt;明示的な型変換演算子のオーバーロード&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;明示的な型変換が行われる場合にのみ呼び出される演算子をオーバーロードできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/extend_friend_targets.html&#34;&gt;&lt;code&gt;friend&lt;/code&gt;宣言できる対象を拡張&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータや型の別名を&lt;code&gt;friend&lt;/code&gt;宣言する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/ref_qualifier_for_this.html&#34;&gt;メンバ関数の左辺値／右辺値修飾&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;オブジェクトが左辺値／右辺値の場合のみ呼び出し可能であることの指定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス以外の型に関する機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/scoped_enum.html&#34;&gt;スコープを持つ列挙型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;強い型付けとスコープを持つ列挙型の導入と、それにともなって従来の列挙型を機能拡張&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/unrestricted_unions.html&#34;&gt;共用体の制限解除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体のメンバ変数として、クラスオブジェクトを持てるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/right_angle_brackets.html&#34;&gt;テンプレートの右山カッコ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector&amp;lt;basic_string&amp;lt;char&amp;gt;&amp;gt;&lt;/code&gt;のように、&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;をスペースを空けずに記述可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/extern_template.html&#34;&gt;extern template&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートのインスタンス化を抑止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alias_templates.html&#34;&gt;エイリアステンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートによって型の別名を定義する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/variadic_templates.html&#34;&gt;可変引数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;任意の数のテンプレートパラメータを受け取れるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/local_and_unnamed_type_as_template_arguments.html&#34;&gt;ローカル型と無名型を、テンプレート引数として使用することを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ローカルおよび無名として定義したクラスや列挙型を、テンプレート引数として渡せるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/sfinae_expressions.html&#34;&gt;任意の式によるSFINAE&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;特定の式が有効かどうかで、その関数をオーバーロード解決に含めるかどうかを決定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/remove_export_templates.html&#34;&gt;テンプレートのエクスポート機能を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレート定義をエクスポートする機能を削除する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;並行関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/thread_local_storage.html&#34;&gt;スレッドローカルストレージ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;スレッドごとに異なる静的記憶域に保持される変数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/static_initialization_thread_safely.html&#34;&gt;ブロックスコープを持つ&lt;code&gt;static&lt;/code&gt;変数初期化のスレッドセーフ化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数ローカルで定義した&lt;code&gt;static&lt;/code&gt;変数の初期化を、スレッドセーフにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;その他様々なユーティリティ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/trailing_return_types.html&#34;&gt;戻り値の型を後置する関数宣言構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;戻り値の型を後ろに書けるようにすることで、パラメータオブジェクトを戻り値型の文脈で使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/static_assert.html&#34;&gt;コンパイル時アサート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に条件式が真であることを表明する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/raw_string_literals.html&#34;&gt;生文字列リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルにRプレフィックスを付けることで、エスケープシーケンスを無視する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/char16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-16とUTF-32の文字型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/utf8_string_literals.html&#34;&gt;UTF-8文字列リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char&lt;/code&gt;の文字列をUTF-8エンコーディングするプレフィックス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/attributes.html&#34;&gt;属性構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[attr]]&lt;/code&gt;構文による、クラス、関数、変数の属性指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alignas.html&#34;&gt;alignas&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメントを指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alignof.html&#34;&gt;alignof&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメントを取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;p&gt;ここでは、コア言語作業グループへ問題報告され、その解決策として導入された言語仕様の変更を解説する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/feature_test_macros.html&#34;&gt;機能テストマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++11 の機能がサポートされているかどうかをテストするためのマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/recursive_template_limit.html&#34;&gt;テンプレート再帰回数の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;17回から1024回に制限緩和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/dependent_name_specifier_outside_of_templates.html&#34;&gt;依存名に対する&lt;code&gt;typename&lt;/code&gt;と&lt;code&gt;template&lt;/code&gt;の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレート外でも&lt;code&gt;typename&lt;/code&gt;と&lt;code&gt;template&lt;/code&gt;を付けられるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/global_scope_syntax_in_nested_name_specifier.html&#34;&gt;入れ子名の指定にグローバルスコープ&lt;code&gt;::&lt;/code&gt;を付加することを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;struct ::A {};&lt;/code&gt;のように入れ子名を指定する際にグローバルスコープから指定できるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/earlier_declarated_array_bounds.html&#34;&gt;宣言時に要素数を指定した配列オブジェクトの、定義時の要素数を規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static&lt;/code&gt;メンバや&lt;code&gt;extern&lt;/code&gt;として宣言した配列を定義した際、宣言時に指定した要素数として定義されることが規定された&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/reserved_namespaces_for_posix.html&#34;&gt;POSIX用の名前空間を予約&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将来の標準化のためにPOSIX用の名前空間を予約し、ユーザーがその名前空間で機能を定義することを禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/extending_sizeof_to_apply_to_non_static_data_members_without_an_object.html&#34;&gt;&lt;code&gt;sizeof&lt;/code&gt;演算子にクラスの非静的メンバを、オブジェクトを作らずに指定できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof(T::data_member)&lt;/code&gt;のように指定して非静的メンバのサイズを取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/deprecation_of_the_register_keyword.html&#34;&gt;&lt;code&gt;register&lt;/code&gt;キーワードを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイラに使われなくなった最適化用の機能を非推奨化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/reference_collapsing.html&#34;&gt;参照への参照を折りたたむ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp;&lt;/code&gt;型に参照を足しても&lt;code&gt;T&amp;amp;&lt;/code&gt;となる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;C99互換機能&lt;/h3&gt;
&lt;p&gt;C99は、1999年に改訂され、ISO/IEC 9899:1999で標準規格化されたC言語バージョンの通称である。&lt;/p&gt;
&lt;p&gt;C++11では、参照するC言語の規格がC89からC99に変更となり、C99の言語機能が一部、C++に導入された。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/variadic_macros.html&#34;&gt;可変引数マクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;マクロで任意の数の引数を受け取る&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/pragma_operator.html&#34;&gt;Pragma演算子&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;処理系定義の機能を使用する単項演算子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/c99_predefined_macros.html&#34;&gt;定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C99互換で導入された定義済みマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/string_literal_concatenation.html&#34;&gt;文字列リテラルとワイド文字列リテラルの結合&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ワイド文字列定数として結合する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/long_long_type.html&#34;&gt;&lt;code&gt;long long&lt;/code&gt;型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;64ビット以上の大きさを持つ整数型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/func.html&#34;&gt;事前定義識別子&lt;code&gt;__func__&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;現在いる関数名が格納されている識別子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/trailing_comma_following_enumerator_list.html&#34;&gt;列挙子の末尾へのカンマ付加を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;末尾の列挙子の後ろにカンマを書くことが許可された&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/result_of_integer_division_and_modulo.html&#34;&gt;整数に対する除算と剰余算の丸め結果を規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;これまで実装定義だった整数の除算と剰余算に対する丸め方法を、標準で規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;固定長配列クラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;単方向リンクリストの実装である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ハッシュ表の連想コンテナである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_map.html&#34;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_set/unordered_set.html&#34;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;クラス、およびその重複を許可するバージョンを追加&lt;/li&gt;
&lt;li&gt;コンテナ全般がムーブセマンティクスに対応&lt;ul&gt;
&lt;li&gt;クラステンプレートのパラメータ&lt;code&gt;T&lt;/code&gt;が、コピー構築可能な型だけでなく、ムーブ構築のみ可能な型も受け付けるようになった&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push_back()&lt;/code&gt;や&lt;code&gt;insert()&lt;/code&gt;等の要素追加のためのメンバ関数が、新たな要素のコピーだけでなく、一時オブジェクトも受け取れて、ムーブで挿入ができるようになった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要素追加のためのメンバ関数として、クラステンプレートのパラメータ&lt;code&gt;T&lt;/code&gt;のコンストラクタ引数を受け取り、一時オブジェクトの生成コストを減らせるものが追加された。これらは、以下のように命名されたメンバ関数である：&lt;code&gt;emplace()&lt;/code&gt;、&lt;code&gt;emplace_back()&lt;/code&gt;、&lt;code&gt;emplace_front()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;コンテナのメモリアロケータが状態を持てるようになった&lt;/li&gt;
&lt;li&gt;初期化子リストでコンテナを初期化できるようになった&lt;/li&gt;
&lt;li&gt;初期化子リストをパラメータで受け取れるようにするためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;型情報型を連想コンテナのキーとして使用するための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/typeindex/type_index.html&#34;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;イテレータを進める関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/next.html&#34;&gt;std::next()&lt;/a&gt;&lt;/code&gt;、イテレータを逆に進める関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/prev.html&#34;&gt;std::prev()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;要素をムーブするイテレータとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/move_iterator.html&#34;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;先頭イテレータと末尾イテレータを取得する非メンバ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/begin.html&#34;&gt;std::begin()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/end.html&#34;&gt;std::end()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;イテレータ範囲が特定の条件を満たしているか調べる、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/all_of.html&#34;&gt;std::all_of()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/any_of.html&#34;&gt;std::any_of()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/none_of.html&#34;&gt;std::none_of&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件を満たしていない最初の要素を検索する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/find_if_not.html&#34;&gt;std::find_if_not()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定された数の要素をコピーする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/copy_n.html&#34;&gt;std::copy_n()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件を満たす要素のみをコピーする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/copy_if.html&#34;&gt;std::copy_if()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータ範囲の要素をムーブする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/move.html&#34;&gt;std::move()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/move_backward.html&#34;&gt;std::move_backward()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;新たな乱数ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に対応したイテレータ範囲のシャッフルアルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shuffle.html&#34;&gt;std::shuffle()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータ範囲がソート済みか調べる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/is_sorted.html&#34;&gt;std::is_sorted()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;2つの値の最小値を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/min.html&#34;&gt;std::min()&lt;/a&gt;&lt;/code&gt;、最大値を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/max.html&#34;&gt;std::max()&lt;/a&gt;&lt;/code&gt;に、初期化子リストによる可変引数版を追加&lt;/li&gt;
&lt;li&gt;最小値と最大値を同時に取得する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/minmax.html&#34;&gt;std::minmax()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/minmax_element.html&#34;&gt;std::minmax_element()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定された値から始まる整数列を生成する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/iota.html&#34;&gt;std::iota()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;メモリアロケータの実装をより容易にするために、コンテナとメモリアロケータの中間インタフェースとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スマートポインタの実装として、所有権共有方式の&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;クラスと、所有権専有方式の&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/unique_ptr.html&#34;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;従来のスマートポインタ&lt;code&gt;auto_ptr&lt;/code&gt;クラスを、非推奨とする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator&amp;amp;()&lt;/code&gt;がオーバーロードされていたとしても正しく変数のアドレスを取得する関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/addressof.html&#34;&gt;std::addressof()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;標準ライブラリ中の入力ストリーム演算子&lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;と出力ストリーム演算子&lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;がムーブセマンティクスに対応。ストリームの一時オブジェクトを受け取れるようになった&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UTF-16の文字列型&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::u16string&lt;/a&gt;&lt;/code&gt;、UTF-32の文字列型&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::u32string&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;UTF-8とUTF-16、UTF-8とUTF-32といった、マルチバイト文字とワイド文字列の相互変換を行うクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/locale/wstring_convert.html&#34;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値から文字列オブジェクトに変換する関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/to_string.html&#34;&gt;std::to_string()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/to_wstring.html&#34;&gt;std::to_wstring()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;文字列オブジェクトから数値に変換する、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/stoi.html&#34;&gt;std::stoi()&lt;/a&gt;&lt;/code&gt;や&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/stof.html&#34;&gt;std::stof()&lt;/a&gt;&lt;/code&gt;といった関数を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;関数ポインタと関数オブジェクトを統一的に扱えるクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;関数の引数を束縛して部分適用する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;std::bind()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;メンバ関数ポインタを関数オブジェクトにアダプトする関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;std::mem_fn()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;テンプレートに、明示的に左辺値参照を渡すための渡すためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;と、そのヘルパ関数である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/ref.html&#34;&gt;std::ref()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/cref.html&#34;&gt;std::cref()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ハッシュ表コンテナの追加にともない、オブジェクトのハッシュ値を計算する関数オブジェクト&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;ビット演算の関数オブジェクトとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bit_and.html&#34;&gt;std::bit_and&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bit_or.html&#34;&gt;std::bit_or&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bit_xor.html&#34;&gt;std::bit_xor&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;従来の関数オブジェクトアダプタ&lt;code&gt;std::unary_function&lt;/code&gt;、&lt;code&gt;std::binary_function&lt;/code&gt;、&lt;code&gt;std::mem_fun()&lt;/code&gt;、&lt;code&gt;std::mem_fun_ref()&lt;/code&gt;等を非推奨とする&lt;/li&gt;
&lt;li&gt;従来の関数バインダ&lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;等を非推奨とする&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;スレッドを管理するクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/thread.html&#34;&gt;std::thread&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッド間での排他制御を行うミューテックスの実装である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/mutex.html&#34;&gt;std::mutex&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/recursive_mutex.html&#34;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt;クラス等を追加&lt;ul&gt;
&lt;li&gt;ミューテックスの所有権放棄を自動的に行うためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/lock_guard.html&#34;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/unique_lock.html&#34;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;スレッドセーフに一度だけ処理を呼び出す関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/call_once.html&#34;&gt;std::call_once()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件変数の実装である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/condition_variable/condition_variable.html&#34;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/condition_variable/condition_variable_any.html&#34;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;Futureデザインパターンをサポートする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/future.html&#34;&gt;std::future&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/promise.html&#34;&gt;std::promise&lt;/a&gt;&lt;/code&gt;クラス、およびその補助機能を追加&lt;/li&gt;
&lt;li&gt;アトミック操作のライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic.html&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;汎用的なユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::swap()&lt;/code&gt;関数を、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;から&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に移動&lt;/li&gt;
&lt;li&gt;ムーブセマンティクスのために、左辺値を右辺値に変換する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/move.html&#34;&gt;std::move()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;引数転送のための関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;が、それぞれの要素型のコンストラクタ引数を直接受け取れるようになった&lt;/li&gt;
&lt;li&gt;タプルの実装である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;SFINAEのために、型の値を取得する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/declval.html&#34;&gt;std::declval()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;時間ユーティリティライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;型特性ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;エラー報告&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OSのエラー値を扱うライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error.html&#34;&gt;&amp;lt;system_error&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;正規表現ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正規表現ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/regex.html&#34;&gt;&amp;lt;regex&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ECMAScript、POSIX、AWK、grepなどの構文を切り替えて使用できるのが特徴。デフォルトではECMAScript&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;乱数ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;乱数ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;複数定義されている乱数生成器と分布アルゴリズムを、組み合わせて使用するのが特徴&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C互換ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ビット幅規定の整数型ライブラリである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstdint.html&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/cpp11&#34; target=&#34;_blank&#34;&gt;C++11 Overview - Standard C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>範囲for文 -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/range_based_for.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:lang/cpp11/range_based_for.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/range_based_for.md b/lang/cpp11/range_based_for.md
index 3ae95f0cc..f053c3af2 100644
--- a/lang/cpp11/range_based_for.md
+++ b/lang/cpp11/range_based_for.md
@@ -42,7 +42,7 @@ for (const auto&amp;amp; e : v) {
 
 
 ## 仕様
-範囲for文は配列または、`begin()`および`end()`で表される範囲内の全ての要素に対して、処理を実行する。
+範囲for文は配列または、`begin()`および`end()`で表されるイテレータ範囲に含まれる全ての要素に対して、処理を実行する。
 
 範囲for文は以下の構文を持つ：
 
@@ -54,7 +54,7 @@ for-range-declarationには変数宣言を書く。ここで宣言した変数
 
 for-range-initializerにはfor文が処理すべき範囲を表す値を書く。
 
-値の型が配列の場合、配列のサイズが分かるものでなければエラーとなる。値の型が配列以外（クラスなど）の場合、`begin()`と`end()`で範囲の先頭と終端が表せるものでなければエラーとなる。
+値の型が配列の場合、配列のサイズが分かるものでなければエラーとなる。値の型が配列以外（クラスなど）の場合、`begin()`と`end()`でイテレータ範囲の先頭と終端が表せるものでなければエラーとなる。
 
 語弊を恐れず言えば、メンバ関数に`begin()`および`end()`を持つクラスであれば、何でも範囲for文の範囲として指定できる。
 
@@ -86,7 +86,7 @@ C++11、C++14において、範囲for文は以下のように通常のfor文へ
 
 展開後に現れる変数名は仮のものであり、実際に変数として見えるわけではない。しかし、デバッガーにこれらの変数が現れることがある。
 
-begin-exprとend-exprの具体的な内容は、範囲として何を渡すかによって3通りに分かれる。いずれの場合も、begin-exprとend-exprは同じ型でなければならない。
+begin-exprとend-exprの具体的な内容は、イテレータ範囲として何を渡すかによって3通りに分かれる。いずれの場合も、begin-exprとend-exprは同じ型でなければならない。
 
 配列を範囲として渡したとき、以下のように展開される：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++14 -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/lang/cpp14.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:lang/cpp14.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++14&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++14とは、2014年12月に改訂され、ISO/IEC 14882:2014で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;前バージョンであるC++11からマイナーバージョンアップされ、小さな機能拡張が行われた。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++1yと呼ばれていた。前バージョンであるC++11が策定中、C++0xと呼ばれていたことから、「xの次」という意味で「y」が使われていた。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/binary_literals.html&#34;&gt;2進数リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2進数を表す&lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;プレフィックスを付けた数値リテラルの記述を可能とする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/return_type_deduction_for_normal_functions.html&#34;&gt;通常関数の戻り値型推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値型を&lt;code&gt;auto&lt;/code&gt;にすることで、&lt;code&gt;return&lt;/code&gt;文から戻り値の型を推論させる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/decltype_auto.html&#34;&gt;decltype(auto)&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;decltype&lt;/code&gt;の規則による変数の型推論&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/placeholder_type_in_trailing_return_type.html&#34;&gt;後置戻り値型をプレースホルダーにすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;戻り値の型を後置する関数宣言構文とラムダ式の戻り値型に&lt;code&gt;auto&lt;/code&gt;を使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/initialize_capture.html&#34;&gt;ラムダ式の初期化キャプチャ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャに代入構文を導入し、一つの変数に複数のキャプチャ方法を指定可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/generic_lambdas.html&#34;&gt;ジェネリックラムダ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式のパラメータを&lt;code&gt;auto&lt;/code&gt;にすることで、ジェネリックな関数呼び出し演算子を持つ関数オブジェクトを生成する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/variable_templates.html&#34;&gt;変数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数定義時のテンプレート指定を可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/relaxing_constraints_on_constexpr.html&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if&lt;/code&gt;文、&lt;code&gt;switch&lt;/code&gt;文による条件分岐の許可。&lt;br /&gt;&lt;code&gt;for&lt;/code&gt;文、&lt;code&gt;while&lt;/code&gt;文、&lt;code&gt;do-while&lt;/code&gt;文によるループの許可。&lt;br /&gt;&lt;code&gt;void&lt;/code&gt;戻り値型の許可&lt;br /&gt;初期化を伴う変数宣言の許可。&lt;br /&gt;変数書き換えの許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/member_initializers_and_aggregates.md.nolink&#34;&gt;宣言時のメンバ初期化を持つ型の集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;集成体において、宣言時に初期化されているメンバを持つことを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/brace_elision_in_array_temporary_initialization.html&#34;&gt;ネストする集成体初期化における波カッコ省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;一様初期化と初期化子リストを組み合わせた際、二重に波カッコが必要となっていた仕様を緩和し、波カッコを省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/deprecated_attr.html&#34;&gt;&lt;code&gt;[[deprecated]]&lt;/code&gt;属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非推奨の機能であることを示す属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/digit_separators.html&#34;&gt;数値リテラルの桁区切り文字&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;シングルクォーテーションで数値リテラルを桁区切りする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/sized_deallocation.html&#34;&gt;サイズ付きデアロケーション&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;サイズをとる&lt;code&gt;delete&lt;/code&gt;演算子のオーバーロードを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/clarifying_memory_allocation.html&#34;&gt;動的メモリ確保の省略の許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトの&lt;code&gt;::operator new&lt;/code&gt;による動的メモリ確保を省略したりまとめたりする事を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;p&gt;ここでは、コア言語作業グループへ問題報告され、その解決策として導入された言語仕様の変更を解説する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/feature_test_macros.html&#34;&gt;機能テストマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++14 の機能がサポートされているかどうかをテストするためのマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/no_whitespace_literal_operators.html&#34;&gt;リテラル演算子のスペースを省略可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator&#34;&#34;&lt;/code&gt;とサフィックス名の間にスペースを入力しなくてもよくなった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/nontype_template_parameters_of_type_nullptr_t.html&#34;&gt;&lt;code&gt;nullptr_t&lt;/code&gt;型の定数式を非型テンプレートパラメータとすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;nullptr_t&lt;/code&gt;型の値をテンプレート引数として渡せるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;順序付き連想コンテナのルックアップ処理で、一時オブジェクトが生成されるコストを抑える拡張が行われた&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/find.html&#34;&gt;std::map::find()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/count.html&#34;&gt;std::map::count()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/lower_bound.html&#34;&gt;std::map::lower_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/upper_bound.html&#34;&gt;std::map::upper_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/equal_range.html&#34;&gt;std::map::equal_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::map&lt;/code&gt;クラスのほか、&lt;code&gt;std::set&lt;/code&gt;、&lt;code&gt;std::multiset&lt;/code&gt;、&lt;code&gt;std::multimap&lt;/code&gt;の上記メンバ関数も対象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Forward Iteratorを値初期化した場合に、どこも指さないヌルイテレータになる、という規定が追加された(参照 : &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf&#34; target=&#34;_blank&#34;&gt;N3644 Null Forward Iterators&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以下のアルゴリズムに、2つ目のイテレータ範囲の終端イテレータをパラメータにとるバージョンを追加。これにより、2つの範囲が同じ長さかを事前にユーザーがチェックする必要がなくなった&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/mismatch.html&#34;&gt;std::mismatch()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/equal.html&#34;&gt;std::equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/is_permutation.html&#34;&gt;std::is_permutation()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;乱数生成を行うアルゴリズム、&lt;code&gt;std::rand()&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/random_shuffle.html&#34;&gt;std::random_shuffle()&lt;/a&gt;&lt;/code&gt;を非推奨とする。&lt;code&gt;std::rand()&lt;/code&gt;の代わりに&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダで定義される乱数生成器と分布クラスを、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/random_shuffle.html&#34;&gt;std::random_shuffle()&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shuffle.html&#34;&gt;std::shuffle()&lt;/a&gt;&lt;/code&gt;を使用すること&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/unique_ptr.html&#34;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;を生成するヘルパ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_unique.html&#34;&gt;std::make_unique()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字列をクォート修飾する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iomanip/quoted.html&#34;&gt;std::quoted&lt;/a&gt;&lt;/code&gt;マニピュレータを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;汎用的なユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2つの値を入れ替える関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/exchange.html&#34;&gt;std::exchange()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;コンパイル時整数シーケンス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/integer_sequence.html&#34;&gt;std::integer_sequence&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;タプルを型の集合と見なし、型を指定して対応する値を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/get.html&#34;&gt;std::get()&lt;/a&gt;&lt;/code&gt;のオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの、メンバ型&lt;code&gt;type&lt;/code&gt;を定義するクラステンプレートに、エイリアステンプレート版を追加。そのバージョンには、&lt;code&gt;_t&lt;/code&gt;サフィックスが付く&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;リテラル演算子&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;の&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/op_s.html&#34;&gt;リテラル演算子&lt;code&gt;s&lt;/code&gt;&lt;/a&gt;を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#34;hello&#34;s&lt;/code&gt;は、文字コード未規定の&lt;code&gt;std::string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&#34;hello&#34;s&lt;/code&gt;は、文字コード未規定の&lt;code&gt;std::wstring&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u8&#34;hello&#34;s&lt;/code&gt;は、UTF-8文字コードの&lt;code&gt;std::string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&#34;hello&#34;s&lt;/code&gt;は、UTF-16文字コードの&lt;code&gt;std::u16string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U&#34;hello&#34;s&lt;/code&gt;は、UTF-32文字コードの&lt;code&gt;std::u32string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration.html&#34;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;の、各時間単位を表す、以下のリテラルを追加&lt;ul&gt;
&lt;li&gt;ナノ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_ns.html&#34;&gt;&lt;code&gt;ns&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;マイクロ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_us.html&#34;&gt;&lt;code&gt;us&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ミリ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_ms.html&#34;&gt;&lt;code&gt;ms&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_s.html&#34;&gt;&lt;code&gt;s&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_min.html&#34;&gt;&lt;code&gt;min&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;時単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_h.html&#34;&gt;&lt;code&gt;h&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;の、各要素型を表す、以下のリテラルを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_i.html&#34;&gt;&lt;code&gt;i&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_if.html&#34;&gt;&lt;code&gt;if&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_il.html&#34;&gt;&lt;code&gt;il&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Readers-writer lockと呼ばれる、書き込みを行うユーザーが1人、読み込みを行うユーザーが複数いる状況で効率的に振る舞うミューテックスの実装として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/shared_mutex.html&#34;&gt;&amp;lt;shared_mutex&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/cpp14&#34; target=&#34;_blank&#34;&gt;C++14 Overview - Standard C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>畳み込み式 -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/folding_expressions.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:lang/cpp17/folding_expressions.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/folding_expressions.md b/lang/cpp17/folding_expressions.md
index ba37f5a0f..91dfaec80 100644
--- a/lang/cpp17/folding_expressions.md
+++ b/lang/cpp17/folding_expressions.md
@@ -234,7 +234,7 @@ auto res =  (std::string(args) + ...);
 
 ## 関連項目
 - [C++11 可変引数テンプレート](/lang/cpp11/variadic_templates.md)
-- [`std::accumulate`](/reference/numeric/accumulate.md) — イテレータの範囲について累積的に二項演算を行う
+- [`std::accumulate`](/reference/numeric/accumulate.md) — イテレータ範囲について累積的に二項演算を行う
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/all_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/all_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/all_of.md b/reference/algorithm/all_of.md
index 7d4047d14..ec04e3446 100644
--- a/reference/algorithm/all_of.md
+++ b/reference/algorithm/all_of.md
@@ -25,7 +25,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の全ての要素が条件を満たすかを判定する。
+イテレータ範囲`[first, last)`の全ての要素が条件を満たすかを判定する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/any_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/any_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/any_of.md b/reference/algorithm/any_of.md
index 6ac75cb0d..bed217753 100644
--- a/reference/algorithm/any_of.md
+++ b/reference/algorithm/any_of.md
@@ -25,12 +25,12 @@ namespace std {
 ```
 
 ## 概要
-範囲のいずれかの要素が条件を満たすかを判定する。
+イテレータ範囲`[first, last)`のいずれかの要素が条件を満たすかを判定する。
 
 
 ## 戻り値
-`[first,last)` 内のイテレータ `i` について `pred(*i)` が `true` になるような要素があれば`true`を返し、そうでなければ`false`を返す。
-`[first,last)`の範囲が空の場合は`false`を返す。
+イテレータ範囲`[first,last)` 内のイテレータ `i` について `pred(*i)` が `true` になるような要素があれば`true`を返し、そうでなければ`false`を返す。
+イテレータ範囲`[first,last)`が空の場合は`false`を返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/copy.md b/reference/algorithm/copy.md
index 0285d4f09..8ba431a17 100644
--- a/reference/algorithm/copy.md
+++ b/reference/algorithm/copy.md
@@ -27,11 +27,11 @@ namespace std {
 ```
 
 ## 概要
-指定された範囲の要素をコピーする。
+指定されたイテレータ範囲`[first, last)`の要素を出力イテレータにコピーする。
 
 
 ## 要件
-`result` は `[first,last)` の範囲に含まれてはならない。
+`result` はイテレータ範囲 `[first,last)` に含まれてはならない。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_backward -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/copy_backward.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/copy_backward.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/copy_backward.md b/reference/algorithm/copy_backward.md
index fc7c7a2ad..e28d07b41 100644
--- a/reference/algorithm/copy_backward.md
+++ b/reference/algorithm/copy_backward.md
@@ -20,11 +20,11 @@ namespace std {
 ```
 
 ## 概要
-指定された範囲の要素を後ろからコピーする。
+指定されたイテレータ範囲`[first, last)`の要素を、出力イテレータ範囲に後ろからコピーする。
 
 
 ## 要件
-`result` は `(first,last]` の範囲に含まれてはならない。
+`result` はイテレータ範囲 `(first,last]` に含まれてはならない。
 
 
 ## 効果
@@ -42,7 +42,7 @@ namespace std {
 
 
 ## 備考
-`last` が `[result - (last-first), result)` の範囲内にあるときには、`copy()` の代わりに `copy_backward()` を使うべきである。
+`last` がイテレータ範囲 `[result - (last-first), result)` に含まれる場合には、`copy()` の代わりに `copy_backward()` を使うべきである。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/copy_if.md b/reference/algorithm/copy_if.md
index a3d4d5eec..c6584609a 100644
--- a/reference/algorithm/copy_if.md
+++ b/reference/algorithm/copy_if.md
@@ -32,11 +32,11 @@ namespace std {
 ```
 
 ## 概要
-条件を満たす要素のみをコピーする。
+イテレータ範囲`[first, last)`のうち、条件を満たす要素のみを出力イテレータ範囲にコピーする。
 
 
 ## 要件
-`[first,last)` の範囲と、`[result,result + (last - first))` の範囲は重なっていてはならない。
+イテレータ範囲`[first,last)`と、イテレータ範囲`[result,result + (last - first))`は重なっていてはならない。
 
 
 ## 効果
@@ -44,7 +44,7 @@ namespace std {
 
 
 ## 戻り値
-コピー先の範囲の終端を返す。
+コピー先のイテレータ範囲の終端を返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/equal.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/equal.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/equal.md b/reference/algorithm/equal.md
index cfd70a295..1d5fc2195 100644
--- a/reference/algorithm/equal.md
+++ b/reference/algorithm/equal.md
@@ -86,16 +86,16 @@ namespace std {
 ```
 
 ## 概要
-2つの範囲を等値比較する。
+2つのイテレータ範囲を等値比較する。
 
-- (1) : 範囲`[first1, last1)`と範囲`[first2, first2 + (last1 - first1))`が等値かを判定する
+- (1) : イテレータ範囲`[first1, last1)`とイテレータ範囲`[first2, first2 + (last1 - first1))`が等値かを判定する
 - (2) : (1)の等値比較を任意の2引数関数オブジェクトで行う
-- (3) : 範囲`[first1, last1)`と範囲`[first2, last2)`が等値かを判定する
+- (3) : イテレータ範囲`[first1, last1)`とイテレータ範囲`[first2, last2)`が等値かを判定する
 - (4) : (3)の等値比較を任意の2引数関数オブジェクトで行う
 
-2つの範囲が異なる要素数であった場合、`false`を返す。
+2つのイテレータ範囲が異なる要素数であった場合、`false`を返す。
 
-2つの範囲が要素数および各要素が等値であった場合、`true`を返す。
+2つのイテレータ範囲が要素数および各要素が等値であった場合、`true`を返す。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/fill.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/fill.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/fill.md b/reference/algorithm/fill.md
index 8c50f137e..d37db4a8e 100644
--- a/reference/algorithm/fill.md
+++ b/reference/algorithm/fill.md
@@ -25,7 +25,7 @@ namespace std {
 ```
 
 ## 概要
-指定された値で出力の範囲に書き込む。
+イテレータ範囲`[first, last)`のすべての要素に指定された値を書き込む。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/fill_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/fill_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/fill_n.md b/reference/algorithm/fill_n.md
index 6f43b16fd..4cecdfdad 100644
--- a/reference/algorithm/fill_n.md
+++ b/reference/algorithm/fill_n.md
@@ -34,7 +34,7 @@ namespace std {
 ```
 
 ## 概要
-指定された値で出力の範囲に `n` 個を書き込む。
+イテレータ範囲`[first, first + n)`のすべての要素に指定された値を書き込む。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find_end.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/find_end.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find_end.md b/reference/algorithm/find_end.md
index 4c3d607ea..675a49353 100644
--- a/reference/algorithm/find_end.md
+++ b/reference/algorithm/find_end.md
@@ -52,7 +52,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の中から、特定のサブシーケンスを検索する。
+イテレータ範囲`[first1, last1)`の中から、特定のサブシーケンス`[first2, last2)`を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/find_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find_if.md b/reference/algorithm/find_if.md
index 0b73a788a..c3cb3a8ad 100644
--- a/reference/algorithm/find_if.md
+++ b/reference/algorithm/find_if.md
@@ -24,7 +24,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の中から、指定された条件を満たす最初の要素を検索する。
+イテレータ範囲`[first, last)`の中から、指定された条件を満たす最初の要素を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find_if_not.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/find_if_not.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find_if_not.md b/reference/algorithm/find_if_not.md
index 30dbf612c..352e17c24 100644
--- a/reference/algorithm/find_if_not.md
+++ b/reference/algorithm/find_if_not.md
@@ -25,7 +25,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の中から、指定された条件を満たさない最初の要素を検索する。
+イテレータ範囲`[first, last)`の中から、指定された条件を満たさない最初の要素を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/for_each.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/for_each.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/for_each.md b/reference/algorithm/for_each.md
index 9abf51cfe..5f705128b 100644
--- a/reference/algorithm/for_each.md
+++ b/reference/algorithm/for_each.md
@@ -24,7 +24,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の全ての要素に、指定された関数を適用する。
+イテレータ範囲`[first, last)`の全ての要素に、指定された関数を適用する。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/for_each_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/for_each_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/for_each_n.md b/reference/algorithm/for_each_n.md
index 3c2a8da39..b8f688506 100644
--- a/reference/algorithm/for_each_n.md
+++ b/reference/algorithm/for_each_n.md
@@ -28,7 +28,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の先頭N個の要素に、指定された関数を適用する。
+イテレータ範囲`[first, first + n)` (範囲の先頭N要素) のすべての要素に、指定された関数を適用する。
 
 
 ## 要件
@@ -37,7 +37,7 @@ namespace std {
 
 
 ## 効果
-範囲`[first, first + n)` 内の全てのイテレータ `i` に `f(*i)` という操作を行う。
+イテレータ範囲`[first, first + n)` 内の全てのイテレータ `i` に `f(*i)` という操作を行う。
 
 このアルゴリズムはその他のアルゴリズムと違い、関数 `f` の内部で `*i` の値を書き換えても構わない（もちろんイテレータの型が `mutable iterator` の要件を満たしている場合に限る）。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/generate.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/generate.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/generate.md b/reference/algorithm/generate.md
index 2059fc699..17aacb71a 100644
--- a/reference/algorithm/generate.md
+++ b/reference/algorithm/generate.md
@@ -24,15 +24,15 @@ namespace std {
 ```
 
 ## 概要
-出力の範囲へ関数の結果を書き込む。
+イテレータ範囲`[first, last)`に、引数なしの関数`gen`の結果を書き込む。
 
 
-## 要件
-`gen` は引数を取らないこと。
+## テンプレートパラメータ制約
+- `gen` は引数をとらないこと
 
 
 ## 効果
-`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
+イテレータ範囲`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/generate_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/generate_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/generate_n.md b/reference/algorithm/generate_n.md
index dc71f1e24..4d40bb1c4 100644
--- a/reference/algorithm/generate_n.md
+++ b/reference/algorithm/generate_n.md
@@ -33,16 +33,16 @@ namespace std {
 ```
 
 ## 概要
-出力の範囲へ関数の結果を `n` 個書き込む。
+イテレータ範囲`[first, first + n)` (範囲の先頭N要素) に関数`gen`の結果を書き込む。
 
 
-## 要件
+## テンプレートパラメータ制約
 - `gen` は引数をとらないこと。
-- `Size` は integral type に変換可能であること。
+- `Size` は整数型に変換可能であること。
 
 
 ## 効果
-`n` が 1 以上の場合、`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
+`n` が 1 以上の場合、イテレータ範囲`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
 
 そうでない場合、何もしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>includes -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/includes.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/includes.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/includes.md b/reference/algorithm/includes.md
index aab15412b..82b393e2c 100644
--- a/reference/algorithm/includes.md
+++ b/reference/algorithm/includes.md
@@ -50,7 +50,9 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
+2つのソート済みイテレータ範囲`[first1, last1)`と`[first2, last2)`において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
+
+この関数は、イテレータ範囲`[first1, last1)`にイテレータ範囲`[first2, last2)`が含まれていれば`true`を返す。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/inplace_merge.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/inplace_merge.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/inplace_merge.md b/reference/algorithm/inplace_merge.md
index 8d75f70c6..72932b0df 100644
--- a/reference/algorithm/inplace_merge.md
+++ b/reference/algorithm/inplace_merge.md
@@ -32,19 +32,24 @@ namespace std {
 ```
 
 ## 概要
-2つの連続したソート済み範囲をマージする。
+2つの連続したソート済みイテレータ範囲`[first, middle)`と`[middle, last)`をマージする。
 
+この関数は、ソート済みイテレータ範囲`[first, middle)`と、ソート済み範囲`[middle, last)`のように大きいイテレータ範囲`[first, last)`内に2つのソート済みイテレータ範囲が含まれている場合に、それらをマージしてソートする。
 
-## 要件
-- `[first,middle)` と `[middle,last)` の範囲はそれぞれ `operator&amp;lt;` か `comp` でソートされていること。
+
+## テンプレートパラメータ制約
 - `BidirectionalIterator` は `ValueSwappable` の要件を満たしていること。
 - `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること。
 
 
+## 事前条件
+- イテレータ範囲`[first,middle)` と イテレータ範囲`[middle,last)` はそれぞれ `operator&amp;lt;` か `comp` でソートされていること。
+
+
 ## 効果
 `[first,middle)`, `[middle,last)` という、連続した２つの範囲をマージし、結果を `[first,last)` へ格納する。
 
-結果の範囲 `[first,last)` は昇順になる。つまり、`first` を除く `[first,last)` 内の全てのイテレータ `i` について、`*i &amp;lt; *(i - 1)` または `comp(*i, *(i - 1))` が `false` になる。
+結果のイテレータ範囲 `[first,last)` は昇順になる。つまり、`first` を除く `[first,last)` 内の全てのイテレータ `i` について、`*i &amp;lt; *(i - 1)` または `comp(*i, *(i - 1))` が `false` になる。
 
 
 ## 戻り値
@@ -68,7 +73,7 @@ int main()
 {
   std::vector&amp;lt;int&amp;gt; v = {1,4,5,  2,3,6};
 
-  // ソートされた2つの範囲をマージ
+  // ソートされた2つのイテレータ範囲をマージ
   std::inplace_merge(v.begin(), v.begin() + 3, v.end());
 
   std::for_each(v.begin(), v.end(), [](int x) {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_heap.md b/reference/algorithm/is_heap.md
index 9bce6b6fa..ac5d29bc5 100644
--- a/reference/algorithm/is_heap.md
+++ b/reference/algorithm/is_heap.md
@@ -38,7 +38,7 @@ namespace std {
 ```
 
 ## 概要
-範囲がヒープ化されているか判定する。
+イテレータ範囲`[first, last)`がヒープ化されているか判定する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap_until -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_heap_until.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_heap_until.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_heap_until.md b/reference/algorithm/is_heap_until.md
index a5c09417e..693f05478 100644
--- a/reference/algorithm/is_heap_until.md
+++ b/reference/algorithm/is_heap_until.md
@@ -44,7 +44,7 @@ namespace std {
 ```
 
 ## 概要
-範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
+イテレータ範囲`[first, last)`がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_partitioned -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_partitioned.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_partitioned.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_partitioned.md b/reference/algorithm/is_partitioned.md
index 5f08741d3..f1e7a758d 100644
--- a/reference/algorithm/is_partitioned.md
+++ b/reference/algorithm/is_partitioned.md
@@ -25,17 +25,16 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
+イテレータ範囲`[first, last)`が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
 
 
-## 要件
-`InputIterator`のvalue typeは `Predicate` の引数型へ変換可能でなければならない。
-
-つまり `pred(*first)` という式が有効でなければならない。
+## テンプレートパラメータ制約
+- `InputIterator`のvalue typeは `Predicate` の引数型へ変換可能でなければならない
+    - つまり `pred(*first)` という式が有効でなければならない
 
 
 ## 戻り値
-`[first,last)` が空、 または `[first,last)` が `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているなら `true` 、そうでなければ `false` を返す。
+イテレータ範囲`[first,last)` が空、 または `[first,last)` が `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているなら `true` 、そうでなければ `false` を返す。
 
 つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現するなら `true` を返す。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_permutation.md b/reference/algorithm/is_permutation.md
index 6eac4d907..bfab19d41 100644
--- a/reference/algorithm/is_permutation.md
+++ b/reference/algorithm/is_permutation.md
@@ -57,17 +57,17 @@ namespace std {
 ```
 
 ## 概要
-`first2` で始まる範囲を並べ替えたものが、`[first1, last1)` の範囲と一致するか判定する。
+`first2` で始まる範囲を並べ替えたものが、イテレータ範囲`[first1, last1)`と一致するか判定する。
 
 
-## 要件
+## テンプレートパラメータ制約
 - `decltype(*first1)` と `decltype(*first2)` の型が同じであること。
 - `BinaryPredicate` は同値関係を持っていること。
 
 
 ## 戻り値
 `last2` が与えられている形式の場合、`last1 - first1 != last2 - first2` であれば `false` を返す。  
-そうでなければ、`[first1, last1)` の範囲と `[first2, first2 + (last1 - first1))` の範囲を並び変えたもので、[`equal`](equal.md)`(first1, last1, first2)`、あるいは [`equal`](equal.md)`(first1, last1, first2, pred)` が `true` を返すようなものがあれば `true` を、そうでなければ `false` を返す。  
+そうでなければ、イテレータ範囲`[first1, last1)`とイテレータ範囲`[first2, first2 + (last1 - first1))`を並び変えたもので、[`equal`](equal.md)`(first1, last1, first2)`、あるいは [`equal`](equal.md)`(first1, last1, first2, pred)` が `true` を返すようなものがあれば `true` を、そうでなければ `false` を返す。  
 なお、実際に並べ替えが行われるわけではない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_sorted.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_sorted.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_sorted.md b/reference/algorithm/is_sorted.md
index 2627aedf8..e318ba717 100644
--- a/reference/algorithm/is_sorted.md
+++ b/reference/algorithm/is_sorted.md
@@ -38,7 +38,7 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲がソート済みか判定する。
+イテレータ範囲`[first, last)`がソート済みか判定する。
 
 ### 戻り値
 - (1) : [`is_sorted_until`](/reference/algorithm/is_sorted_until.md)`(first, last) == last`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_sorted_until.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_sorted_until.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_sorted_until.md b/reference/algorithm/is_sorted_until.md
index ac89b6381..01bda45f7 100644
--- a/reference/algorithm/is_sorted_until.md
+++ b/reference/algorithm/is_sorted_until.md
@@ -44,11 +44,11 @@ namespace std {
 ```
 
 ## 概要
-ソート済みか判定し、ソートされていない位置のイテレータを取得する
+イテレータ範囲`[first, last)`がソート済みか判定し、ソートされていない位置のイテレータを取得する
 
 
 ## 戻り値
-[`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、`[first,last]` の中でソートされている範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
+[`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、イテレータ範囲`[first,last]` の中でソートされているイテレータ範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/lexicographical_compare.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/lexicographical_compare.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/lexicographical_compare.md b/reference/algorithm/lexicographical_compare.md
index 9ded8eb18..b486aed5d 100644
--- a/reference/algorithm/lexicographical_compare.md
+++ b/reference/algorithm/lexicographical_compare.md
@@ -56,7 +56,8 @@ namespace std {
 ```
 
 ## 概要
-`[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
+2つのイテレータ範囲`[first1, last1)`と`[first2, last2)`を辞書式順序で比較する。
+
 このアルゴリズムは、コンテナの`operator&amp;lt;()`の実装で使用される。
 
 
@@ -71,7 +72,7 @@ return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
 
 
 ## 戻り値
-範囲`[first1, last1)`が、辞書式比較で範囲`[first2, last2)`より小さい場合`true`を返し、そうでなければ`false`を返す。
+イテレータ範囲`[first1, last1)`が、辞書式比較でイテレータ範囲`[first2, last2)`より小さい場合`true`を返し、そうでなければ`false`を返す。
 
 
 ## 計算量
@@ -81,7 +82,7 @@ return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
 ## 備考
 空のシーケンスは、空でないシーケンスより小さいと判断されるが、空のシーケンスに対しては小さくないと判断される。
 
-どちらかのシーケンスの横断が先に終わる場合(つまり、範囲の長さが合わない場合)、先に終わった方が小さいと判断される。
+どちらかのシーケンスの横断が先に終わる場合(つまり、イテレータ範囲の長さが合わない場合)、先に終わった方が小さいと判断される。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare_three_way -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/lexicographical_compare_three_way.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/lexicographical_compare_three_way.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/lexicographical_compare_three_way.md b/reference/algorithm/lexicographical_compare_three_way.md
index f0349739a..6897cc909 100644
--- a/reference/algorithm/lexicographical_compare_three_way.md
+++ b/reference/algorithm/lexicographical_compare_three_way.md
@@ -29,7 +29,8 @@ namespace std {
 
 ## 概要
 
-`[first1, last1)`および`[first2, last2)`の2つの範囲を[辞書式順序](lexicographical_compare.md)による三方比較によって比較する。
+2つのイテレータ範囲`[first1, last1)`と`[first2, last2)`を[辞書式順序](lexicographical_compare.md)による三方比較によって比較する。
+
 このアルゴリズムは、コンテナの`operator&amp;lt;=&amp;gt;()`の実装で使用される。
 
 
@@ -39,10 +40,10 @@ namespace std {
 
 ## 引数
 
-- `first1` -- 比較する1つ目の範囲の先頭のイテレータ。
-- `last1` -- 比較する1つ目の範囲の終端のイテレータ。
-- `first2` -- 比較する2つ目の範囲の先頭のイテレータ。
-- `last2` -- 比較する2つ目の範囲の終端のイテレータ。
+- `first1` -- 比較する1つ目のイテレータ範囲の先頭イテレータ。
+- `last1` -- 比較する1つ目のイテレータ範囲の終端イテレータ。
+- `first2` -- 比較する2つ目のイテレータ範囲の先頭イテレータ。
+- `last2` -- 比較する2つ目のイテレータ範囲の終端イテレータ。
 - `comp` -- 使用する三方比較をカスタマイズする関数オブジェクト。
 
 ## 効果
@@ -65,7 +66,7 @@ namespace std {
 ## 戻り値
 
 戻り値型となる比較カテゴリ型を`Cat`とすると、  
-範囲`[first1, last1)`が、辞書式比較で範囲`[first2, last2)`より大きい場合は`Cat::greator`を返し、小さい場合`Cat::less`を返し、等しいのならば`Cat::equivalent`を返す。
+イテレータ範囲`[first1, last1)`が、辞書式比較でイテレータ範囲`[first2, last2)`より大きい場合は`Cat::greator`を返し、小さい場合`Cat::less`を返し、等しいのならば`Cat::equivalent`を返す。
 
 ## 計算量
 
@@ -100,13 +101,13 @@ int main() {
 
   std::cout &amp;lt;&amp;lt; std::boolalpha;
 
-  //カスタマイズした比較による同じ長さの範囲の比較
+  //カスタマイズした比較による同じ長さのイテレータ範囲の比較
   {
     auto comp = std::lexicographical_compare_three_way(str1.begin(), str1.end(), str2.begin(), str2.end(), weak_comp);
     std::cout &amp;lt;&amp;lt; (comp == 0) &amp;lt;&amp;lt; std::endl;
   }
 
-  //デフォルトの比較による異なる長さの範囲の比較
+  //デフォルトの比較による異なる長さのイテレータ範囲の比較
   {
     auto comp = std::lexicographical_compare_three_way(str1.begin(), str1.end(), str3.begin(), str3.end());
     std::cout &amp;lt;&amp;lt; (comp &amp;gt; 0) &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/lower_bound.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/lower_bound.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/lower_bound.md b/reference/algorithm/lower_bound.md
index 5f458df8e..24bc996d4 100644
--- a/reference/algorithm/lower_bound.md
+++ b/reference/algorithm/lower_bound.md
@@ -34,9 +34,9 @@ namespace std {
 ```
 
 ## 概要
-指定された要素以上の値が現れる最初の位置のイテレータを取得する。
+イテレータ範囲`[first, last)`のうち、指定された要素以上の値が現れる最初の位置のイテレータを取得する。
 
-この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::equal_range()`](equal_range.md)関数を使用できる。
+この関数の用途としては、ソート済みイテレータ範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::equal_range()`](equal_range.md)関数を使用できる。
 
 
 ## 要件
@@ -45,11 +45,11 @@ namespace std {
 	- `comp` は 2 引数の関数オブジェクトで、結果の型は `bool` 型に変換可能であること。また、引数に非 `const` の関数を適用しないこと。
 	- `T` は `LessThanComparable` であること。
 	- `operator&amp;lt;` または `comp` は「[狭義の弱順序](../algorithm.md#strict-weak-ordering)」であること。
-	- 範囲 `[first, last)` は `operator&amp;lt;` または `comp` を基準として昇順に並んでいること。
+	- イテレータ範囲 `[first, last)` は `operator&amp;lt;` または `comp` を基準として昇順に並んでいること。
 - C++11 から  
 	- `first`、`last` は前方向イテレータの要件を満たすこと。
 	- `comp` は 2 引数の関数オブジェクトで、結果の型は `bool` 型に変換可能であること。また、引数に非 `const` の関数を適用しないこと。
-	- `[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
+	- イテレータ範囲`[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
 		つまり、`e &amp;lt; value` または `comp(e, value)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
 
 
@@ -103,7 +103,7 @@ int main()
   }
 
   // 基本的な用途
-  // ソート済み範囲から、特定の値を二分探索で見つける
+  // ソート済みイテレータ範囲から、特定の値を二分探索で見つける
   {
     std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
     std::sort(v.begin(), v.end());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/make_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/make_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/make_heap.md b/reference/algorithm/make_heap.md
index 915d67408..a57a55f69 100644
--- a/reference/algorithm/make_heap.md
+++ b/reference/algorithm/make_heap.md
@@ -26,11 +26,11 @@ namespace std {
 ```
 
 ## 概要
-範囲をヒープ化する。
+イテレータ範囲`[first, last)`をヒープ化する。
 
 
-## 要件
-`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+## テンプレートパラメータ制約
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/max_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/max_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/max_element.md b/reference/algorithm/max_element.md
index 6099b0efb..5b042cb16 100644
--- a/reference/algorithm/max_element.md
+++ b/reference/algorithm/max_element.md
@@ -32,12 +32,12 @@ namespace std {
 ```
 
 ## 概要
-`[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
+イテレータ範囲`[first, last)`のうち、最大要素を指す最初のイテレータを取得する。
 
 
 
 ## 戻り値
-`*j &amp;lt; *i`もしくは`comp(*j, *i)`の比較によって最大と判断された最初の要素を指すイテレータ
+`*j &amp;lt; *i`もしくは`comp(*j, *i)`の比較によって最大と判断された最初の要素を指すイテレータを返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/merge.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/merge.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/merge.md b/reference/algorithm/merge.md
index 09087bd18..824b2114a 100644
--- a/reference/algorithm/merge.md
+++ b/reference/algorithm/merge.md
@@ -65,20 +65,22 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲をマージする。
+2つのソート済みイテレータ範囲`[first1, last1)`と`[first2, last2)`をマージする。
 
 
-## 要件
+## 事前条件
 - `[first1,last1)` と `[first2,last2)` は `operator&amp;lt;` または `comp` でソートされていること。
-- 結果の範囲と入力の範囲は重なっていてはならない。
+- 結果のイテレータ範囲と入力のイテレータ範囲は重なっていてはならない。
 
 
 ## 効果
-`[first1,last1)` と `[first2,last2)` の２つの要素を全て `[result,result_last)` へコピーする。その際に、[`is_sorted`](is_sorted.md)`(result, result_last)` または [`is_sorted`](is_sorted.md)`(result, result_last, comp)` の条件を満たすようにコピーする（`result_last` は `result + (last1 - first1) + (last2 - first2)` とする）。
+イテレータ範囲`[first1,last1)`とイテレータ範囲`[first2,last2)` の２つの要素を全て `[result,result_last)` へコピーする。その際に、[`is_sorted`](is_sorted.md)`(result, result_last)` または [`is_sorted`](is_sorted.md)`(result, result_last, comp)` の条件を満たすようにコピーする（`result_last` は `result + (last1 - first1) + (last2 - first2)` とする）。
 
 
 ## 戻り値
-`result + (last1 - first1) + (last2 - first2)`
+```cpp
+return result + (last1 - first1) + (last2 - first2);
+```
 
 
 ## 計算量
@@ -89,7 +91,7 @@ namespace std {
 
 
 ## 備考
-この操作は安定である。つまり、各入力範囲内の要素の前後関係は保たれ、また、1 番目の範囲と 2 番目に等値の要素があった場合には、1 番目の範囲の要素の方が先に来る。
+この操作は安定である。つまり、各入力イテレータ範囲内の要素の前後関係は保たれ、また、1 番目の範囲と 2 番目に等値の要素があった場合には、1 番目の範囲の要素の方が先に来る。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/min_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/min_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/min_element.md b/reference/algorithm/min_element.md
index 59b85f788..53fe86498 100644
--- a/reference/algorithm/min_element.md
+++ b/reference/algorithm/min_element.md
@@ -32,11 +32,11 @@ namespace std {
 ```
 
 ## 概要
-`[first, last)`の範囲において、最小要素を指す最初のイテレータを取得する。
+イテレータ範囲`[first, last)`のうち、最小要素を指す最初のイテレータを取得する。
 
 
 ## 戻り値
-`*i &amp;lt; *j`もしくは`comp(*i, *j)`の比較によって最小と判断された最初の要素を指すイテレータ
+`*i &amp;lt; *j`もしくは`comp(*i, *j)`の比較によって最小と判断された最初の要素を指すイテレータを返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/minmax_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/minmax_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/minmax_element.md b/reference/algorithm/minmax_element.md
index a6527a3ab..793742cea 100644
--- a/reference/algorithm/minmax_element.md
+++ b/reference/algorithm/minmax_element.md
@@ -34,7 +34,9 @@ namespace std {
 * pair[link /reference/utility/pair.md]
 
 ## 概要
-`[first, last)` の範囲において、最小要素を指すイテレータと最大要素を指すイテレータの組を取得する。
+イテレータ範囲`[first, last)`のうち、最小要素を指すイテレータと最大要素を指すイテレータの組を取得する。
+
+この関数の戻り値となるイテレータの[`pair`](/reference/utility/pair.md)では、`first`に最小要素を指すイテレータ、`second`に最大要素を指すイテレータが代入される。
 
 
 ## 戻り値
@@ -92,7 +94,7 @@ minmax_element(ForwardIterator first, ForwardIterator last, Compare comp)
   // 結果用オブジェクト
   std::pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt; result(first, first);
 
-  // 範囲の要素数が 0 か 1 だったら、そのまま result を返す
+  // イテレータ範囲の要素数が 0 か 1 だったら、そのまま result を返す
   if (first != last &amp;amp;&amp;amp; ++first != last) {
     // 最初の 2 個を比較して、小さい方を .first に、大きい方を .second に設定
     if (comp(*first, *result.first))
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/mismatch.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/mismatch.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/mismatch.md b/reference/algorithm/mismatch.md
index 5fa0f9834..836f18368 100644
--- a/reference/algorithm/mismatch.md
+++ b/reference/algorithm/mismatch.md
@@ -90,7 +90,7 @@ namespace std {
 
 
 ## 概要
-2つのシーケンスが一致していない場所を検索する。
+2つのシーケンス`[first1, last1)`と`[first2, last2)`が一致していない位置を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/move.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/move.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/move.md b/reference/algorithm/move.md
index 3f4d632ee..ce9929e35 100644
--- a/reference/algorithm/move.md
+++ b/reference/algorithm/move.md
@@ -29,15 +29,15 @@ namespace std {
 ```
 
 ## 概要
-指定された範囲の要素をムーブする。
+イテレータ範囲`[first, last)`の要素を出力イテレータ範囲にムーブする。
 
 
-## 要件
-`result` は `[first,last)` の範囲に含まれてはならない。
+## 事前条件
+`result` はイテレータ範囲`[first,last)`に含まれてはならない。
 
 
 ## 効果
-`[first,last)` 内の要素を、それぞれ `[result,result + (last - first))` へムーブする。
+イテレータ範囲`[first,last)` 内の要素を、それぞれ出力イテレータ範囲`[result,result + (last - first))` へムーブする。
 
 ムーブは `first` から順番に行い、0 以上 `last - first` 未満であるそれぞれの `n` について、`*(result + n) = std::move(*(first + n))` を行う。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_backward -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/move_backward.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/move_backward.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/move_backward.md b/reference/algorithm/move_backward.md
index 4a912d3b1..693928b9c 100644
--- a/reference/algorithm/move_backward.md
+++ b/reference/algorithm/move_backward.md
@@ -21,15 +21,15 @@ namespace std {
 ```
 
 ## 概要
-指定された範囲の要素を後ろからムーブする。
+イテレータ範囲`[first, last)`の要素を出力イテレータ範囲に後ろからムーブする。
 
 
-## 要件
-`result` は `(first,last]` の範囲に含まれてはならない。
+## 事前条件
+- `result` はイテレータ範囲`(first,last]` に含まれてはならない
 
 
 ## 効果
-`[first,last)` 内にある要素を、それぞれ `[result - (last-first),result)` へムーブする。
+イテレータ範囲`[first,last)` 内にある要素を、それぞれ出力イテレータ範囲`[result - (last-first),result)` へムーブする。
 
 ムーブは `last - 1` から順番に行い、1 以上 `last - first` 以下であるそれぞれの `n` について、`*(result - n) = std::move(*(last - n))` を行う。
 
@@ -68,7 +68,7 @@ int main() {
   std::move_backward(v.begin(), v.begin() + 3, v.end());
 
   // 以下のコードだと期待した結果にならないことを確認しよう。
-  // 移動元の後方と移動先の前方で範囲が重なっている場合は、move_backwardを使わないといけない
+  // 移動元の後方と移動先の前方でイテレータ範囲が重なっている場合は、move_backwardを使わないといけない
   // std::move(v.begin(), v.begin() + 3, v.begin() + 2);
 
   std::for_each(v.begin(), v.end(), &amp;amp;print);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>next_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/next_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/next_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/next_permutation.md b/reference/algorithm/next_permutation.md
index 0f1ebaac2..c1938dfe8 100644
--- a/reference/algorithm/next_permutation.md
+++ b/reference/algorithm/next_permutation.md
@@ -26,21 +26,23 @@ namespace std {
 ```
 
 ## 概要
-与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその次の順列を生成する。
+与えられた時点のイテレータ範囲`[first, last)`を起点の順列として、辞書順によるその次の順列を生成する。
 
 
-## 要件
+## テンプレートパラメータ制約
 `BidriectionalIterator`が`ValueSwappable`の要件を満たしていること。
 
 
 ## 効果
-`[first, last)`の範囲を次の順列に変換する。
+イテレータ範囲`[first, last)`の範囲を次の順列に変換する。
+
 `operator&amp;lt;`または`comp`によって辞書順に並んでいる全ての順列の集合があると仮定すると、次の順列が発見される。
 
 順列の辞書順とは、同じ長さ`N`の順列`a, b`があった時、その最上位の項から見た時に`ai != bi`となる最初の`i`番目の項について、`ai &amp;lt; bi`（もしくは`comp(ai, bi) == true`）となる時に`a &amp;lt; b`とするように定めた順序のことである。例えばこれは、各項（`ai, bi`）が`0 ~ 9`の数であるとすれば、それらをそのまま並べて構成した数の通常の大小関係に等しい。
 
 辞書順による次の順列とは、現在の順列（`[first, last)`）よりも（上記の意味の順序で）大きい順列のうち取り得る最小のもののことである。
 
+
 ## 戻り値
 次の順列が存在する場合は`true`を返し、そうでなければ`false`を返す。
 
@@ -50,8 +52,9 @@ namespace std {
 
 
 ## 備考
-全ての順列を取得したい場合は、この関数に最初に与える範囲が、昇順にソート済みになっていること。  
-順列の長さを`N`（`N = last - first`）とすれば、そのような順列は`N!`個存在する。
+- 全ての順列を取得したい場合は、この関数に最初に与えるイテレータ範囲が、昇順にソート済みになっていること
+    - 順列の長さを`N`（`N = last - first`）とすれば、そのような順列は`N!`個存在する
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/none_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/none_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/none_of.md b/reference/algorithm/none_of.md
index 09a9ab168..4af4718ed 100644
--- a/reference/algorithm/none_of.md
+++ b/reference/algorithm/none_of.md
@@ -25,11 +25,11 @@ namespace std {
 ```
 
 ## 概要
-範囲の全ての要素が条件を満たさないかを判定する。
+イテレータ範囲`[first, last)`の全ての要素が条件を満たさないかを判定する。
 
 
 ## 戻り値
-`[first,last)` が空であったり、`[first,last)` 内の全てのイテレータ `i` について `pred(*i)` が `false` である場合は `true` を返し、そうでない場合は `false` を返す。
+イテレータ範囲`[first,last)` が空であったり、イテレータ範囲`[first,last)` 内の全てのイテレータ `i` について `pred(*i)` が `false` である場合は `true` を返し、そうでない場合は `false` を返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/nth_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/nth_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/nth_element.md b/reference/algorithm/nth_element.md
index 8050f7f4b..6c0ddf375 100644
--- a/reference/algorithm/nth_element.md
+++ b/reference/algorithm/nth_element.md
@@ -45,13 +45,13 @@ namespace std {
 ## 概要
 基準となる要素よりも小さい要素が前に来るよう並べ替える。
 
-この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
+この関数はイテレータ範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半のイテレータ範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、そのイテレータ範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
 
-ある範囲に対して部分的な並び替えを行う場合、[`partial_sort()`](partial_sort.md)を使用する。また範囲全体に対して並び替えを行う場合、[`sort()`](sort.md)を使用する。
+あるイテレータ範囲に対して部分的な並び替えを行う場合は、[`partial_sort()`](partial_sort.md)を使用する。また範囲全体に対して並び替えを行う場合は、[`sort()`](sort.md)を使用する。
 
 
-## 要件
-`RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partial_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partial_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partial_sort.md b/reference/algorithm/partial_sort.md
index e09f81350..4c0d67336 100644
--- a/reference/algorithm/partial_sort.md
+++ b/reference/algorithm/partial_sort.md
@@ -43,18 +43,19 @@ namespace std {
 ```
 
 ## 概要
-範囲を部分的にソートし、先頭 `N` 個を順に並んだ状態にする。`N` は `middle - first` で決まる。
+イテレータ範囲`[first, last)`を部分的にソートし、先頭 `N` 個を順に並んだ状態にする。`N` は `middle - first` で決まる。
 
 この関数は、「売り上げランキング トップ1位から10位まで」のように、全体ではなく最高順位から途中までの順位がわかればよい状況で、全体を並び替える[`sort()`](sort.md)関数の代わりに使用できる。
 
 なお、トップ10がどれかわかれば十分である（1位から10位までは順不同でよい）ような場合、[`nth_element()`](nth_element.md)が使用できる。
 
-## 要件
-`RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
-`[first,last)` にある要素の中から、`middle - first` 個の要素をソート済みの状態で `[first,middle)` に配置する。残りの `[middle,last)` にある要素は unspecified order に配置される。
+イテレータ範囲`[first,last)`にある要素の中から、`middle - first` 個の要素をソート済みの状態で `[first,middle)` に配置する。残りの `[middle,last)` にある要素は未規定の順序に配置される。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partial_sort_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partial_sort_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partial_sort_copy.md b/reference/algorithm/partial_sort_copy.md
index 7695e6f5e..f70f56d01 100644
--- a/reference/algorithm/partial_sort_copy.md
+++ b/reference/algorithm/partial_sort_copy.md
@@ -56,15 +56,15 @@ namespace std {
 ```
 
 ## 概要
-範囲を部分的にソートした結果を他の範囲にコピーする
+イテレータ範囲`[first, last)`を部分的にソートした結果を他の範囲`[result_first, result_last)`にコピーする。
 
 
-## 要件
-`RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*result_first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*result_first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
-`[first,last)` にある要素の中から、[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` 個の要素をソート済みの状態で `[result_first,result_first +` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first))` に配置する。
+イテレータ範囲`[first,last)` にある要素の中から、[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` 個の要素をソート済みの状態で `[result_first,result_first +` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first))` に配置する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partition.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partition.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partition.md b/reference/algorithm/partition.md
index 0d4e57d0c..f58de2d53 100644
--- a/reference/algorithm/partition.md
+++ b/reference/algorithm/partition.md
@@ -33,7 +33,7 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
+イテレータ範囲`[first, last)`を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partition_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partition_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partition_copy.md b/reference/algorithm/partition_copy.md
index 8373da620..adf6fc812 100644
--- a/reference/algorithm/partition_copy.md
+++ b/reference/algorithm/partition_copy.md
@@ -45,16 +45,21 @@ namespace std {
 * pair[link /reference/utility/pair.md]
 
 ## 概要
-与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする。
+イテレータ範囲`[first, last)`を条件を満たすか満たさないかで、2つの出力範囲へ分けてコピーする。
 
+この関数は、入力のイテレータ範囲のうち、条件を満たす要素を出力イテレータ範囲`out_true`、条件を満たさない要素を出力イテレータ範囲`out_false`にコピーする。
 
-## 要件
-- `InputIterator` の value type は `Assignable` で、`out_true` と `out_false` の `OutputIterator` へ書き込み可能で、`Predicate` の argument type へ変換可能でなければならない。
-- 入力範囲は出力範囲のどちらとも重なっていてはならない。
+
+## テンプレートパラメータ制約
+- `InputIterator` の value type は `Assignable` で、`out_true` と `out_false` の `OutputIterator` へ書き込み可能で、`Predicate` の引数型へ変換可能であること
+
+
+## 事前条件
+- 入力範囲は出力範囲のどちらとも重なっていてはならない
 
 
 ## 効果
-`[first,last)` 内にあるそれぞれのイテレータ `i` について、`pred(*i)` が `true` なら `*i` を `out_true` へコピーし、そうでない場合は `out_false` へコピーする。
+イテレータ範囲`[first,last)` 内にあるそれぞれのイテレータ `i` について、`pred(*i)` が `true` なら `*i` を `out_true` へコピーし、そうでない場合は `out_false` へコピーする。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_point -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partition_point.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partition_point.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partition_point.md b/reference/algorithm/partition_point.md
index 31c83e155..433353398 100644
--- a/reference/algorithm/partition_point.md
+++ b/reference/algorithm/partition_point.md
@@ -21,12 +21,15 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る。
+イテレータ範囲`[first, last)`から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る。
 
 
-## 要件
-- `ForwardIterator` の value type は `Predicate` の argument type へ変換可能でなければならない。
-- `[first,last)` は `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現してなければならない。
+## テンプレートパラメータ制約
+- `ForwardIterator` の value type は `Predicate` の引数型へ変換可能であること
+
+
+## 事前条件
+- イテレータ範囲`[first,last)` は `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現してなければならない
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pop_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/pop_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/pop_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/pop_heap.md b/reference/algorithm/pop_heap.md
index 771c760b5..56cb4179d 100644
--- a/reference/algorithm/pop_heap.md
+++ b/reference/algorithm/pop_heap.md
@@ -26,13 +26,16 @@ namespace std {
 ```
 
 ## 概要
-ヒープ化された範囲の先頭と末尾を入れ替え、ヒープ範囲を作り直す
+ヒープ化されたイテレータ範囲`[first, last)`の先頭と末尾を入れ替え、ヒープ範囲を作り直す
 
 
-## 要件
-- `[first,last)` は空でない heap でなければならない。
-- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+
+
+## 事前条件
+- `[first,last)` は空でないヒープであること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>prev_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/prev_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/prev_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/prev_permutation.md b/reference/algorithm/prev_permutation.md
index e6f0f03d7..dbdea5b98 100644
--- a/reference/algorithm/prev_permutation.md
+++ b/reference/algorithm/prev_permutation.md
@@ -34,7 +34,7 @@ namespace std {
 
 
 ## 効果
-`[first, last)`の範囲を前の順列に変換する。
+イテレータ範囲`[first, last)`を前の順列に変換する。
 
 `operator&amp;lt;`または`comp`によって辞書順に並んでいる全ての順列の集合があると仮定すると、前の順列が発見される。
 
@@ -48,7 +48,7 @@ namespace std {
 
 
 ## 備考
-全ての順列を取得したい場合は、この関数に最初に与える範囲が、降順にソート済みになっていること。
+全ての順列を取得したい場合は、この関数に最初に与えるイテレータ範囲が、降順にソート済みになっていること。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>push_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/push_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/push_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/push_heap.md b/reference/algorithm/push_heap.md
index 9395576cb..3e1cdf5f7 100644
--- a/reference/algorithm/push_heap.md
+++ b/reference/algorithm/push_heap.md
@@ -26,16 +26,21 @@ namespace std {
 ```
 
 ## 概要
-ヒープ化された範囲に要素を追加する
+ヒープ化されたイテレータ範囲`[first, last - 1)`に要素を追加する。
 
+この関数は、イテレータ範囲の末尾要素`*(last - 1)`を、範囲全体がヒープとなるよう配置し直す。
 
-## 要件
-- `[first,last - 1)` は有効な heap である必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+
+## テンプレートパラメータ制約
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+
+
+## 事前条件
+- `[first,last - 1)` は有効なヒープであること
 
 
 ## 効果
-`last - 1` の値を、`[first,last)` が有効な heap となるように配置する
+`last - 1` の値を、`[first,last)` が有効なヒープとなるように配置する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>random_shuffle -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/random_shuffle.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/random_shuffle.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/random_shuffle.md b/reference/algorithm/random_shuffle.md
index df449d0d5..fc8e3c332 100644
--- a/reference/algorithm/random_shuffle.md
+++ b/reference/algorithm/random_shuffle.md
@@ -27,7 +27,7 @@ namespace std {
 
 
 ## 概要
-`[first,last)` のそれぞれの要素を同じ確率で並び替える。
+イテレータ範囲`[first,last)`のそれぞれの要素を同じ確率で並び替える。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_find -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
index 2261d308b..61184e75b 100644
--- a/reference/algorithm/ranges_adjacent_find.md
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -6,11 +6,20 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr I adjacent_find(I first, S last, Pred pred = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;,
+            projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr I
+    adjacent_find(I first, S last, Pred pred = {}, Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});           // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -27,8 +36,8 @@ namespace std::ranges {
 ## 概要
 隣接する要素で条件を満たしている最初の要素を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_all_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_all_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_all_of.md b/reference/algorithm/ranges_all_of.md
index 730b223ea..f7e7fa8d9 100644
--- a/reference/algorithm/ranges_all_of.md
+++ b/reference/algorithm/ranges_all_of.md
@@ -6,11 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool all_of(I first, S last, Pred pred, Proj proj = {}); // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool all_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    all_of(I first, S last, Pred pred, Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    all_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -23,8 +30,8 @@ namespace std::ranges {
 ## 概要
 範囲の全ての要素が条件を満たすかを判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_any_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_any_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_any_of.md b/reference/algorithm/ranges_any_of.md
index ec433feda..ef983c43d 100644
--- a/reference/algorithm/ranges_any_of.md
+++ b/reference/algorithm/ranges_any_of.md
@@ -6,11 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool any_of(I first, S last, Pred pred, Proj proj = {}); // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool any_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    any_of(I first, S last, Pred pred, Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    any_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -23,8 +30,8 @@ namespace std::ranges {
 ## 概要
 範囲のいずれかの要素が条件を満たすかを判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clamp -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_clamp.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_clamp.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_clamp.md b/reference/algorithm/ranges_clamp.md
index 732d1e6da..a4098951c 100644
--- a/reference/algorithm/ranges_clamp.md
+++ b/reference/algorithm/ranges_clamp.md
@@ -6,9 +6,11 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr const T&amp;amp; clamp(const T&amp;amp; v, const T&amp;amp; lo, const T&amp;amp; hi, Comp comp = {}, Proj proj = {});
+  template &amp;lt;class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp;
+    clamp(const T&amp;amp; v, const T&amp;amp; lo, const T&amp;amp; hi, Comp comp = {}, Proj proj = {}); // (1) C++20
 }
 ```
 * identity[link /reference/functional/identity.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy.md b/reference/algorithm/ranges_copy.md
index d59127a00..2e773767f 100644
--- a/reference/algorithm/ranges_copy.md
+++ b/reference/algorithm/ranges_copy.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
-  constexpr copy_result&amp;lt;I, O&amp;gt; copy(I first, S last, O result);            // (1)
+  constexpr copy_result&amp;lt;I, O&amp;gt;
+    copy(I first, S last, O result); // (1) C++20
 
-  template&amp;lt;input_range R, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_range R,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-  constexpr copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt; copy(R&amp;amp;&amp;amp; r, O result); // (2)
+  constexpr copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    copy(R&amp;amp;&amp;amp; r, O result);           // (2) C++20
 }
 ```
 * copy_result[link ranges_in_out_result.md]
@@ -27,8 +32,8 @@ namespace std::ranges {
 ## 概要
 指定された範囲の要素をコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_backward -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_backward.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_copy_backward.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_backward.md b/reference/algorithm/ranges_copy_backward.md
index 653eaa176..23684cd66 100644
--- a/reference/algorithm/ranges_copy_backward.md
+++ b/reference/algorithm/ranges_copy_backward.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, bidirectional_iterator I2&amp;gt;
+  template &amp;lt;bidirectional_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            bidirectional_iterator I2&amp;gt;
     requires indirectly_copyable&amp;lt;I1, I2&amp;gt;
-  constexpr copy_backward_result&amp;lt;I1, I2&amp;gt; copy_backward(I1 first, S1 last, I2 result);       // (1)
+  constexpr copy_backward_result&amp;lt;I1, I2&amp;gt;
+    copy_backward(I1 first, S1 last, I2 result); // (1) C++20
 
-  template&amp;lt;bidirectional_range R, bidirectional_iterator I&amp;gt;
+  template &amp;lt;bidirectional_range R,
+            bidirectional_iterator I&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
-  constexpr copy_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt; copy_backward(R&amp;amp;&amp;amp; r, I result); // (2)
+  constexpr copy_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+    copy_backward(R&amp;amp;&amp;amp; r, I result);              // (2) C++20
 }
 ```
 * copy_backward_result[link ranges_in_out_result.md]
@@ -26,8 +31,8 @@ namespace std::ranges {
 ## 概要
 指定された範囲の要素を後ろからコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_if.md b/reference/algorithm/ranges_copy_if.md
index 68437521d..228372a26 100644
--- a/reference/algorithm/ranges_copy_if.md
+++ b/reference/algorithm/ranges_copy_if.md
@@ -6,13 +6,22 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
-  constexpr copy_if_result&amp;lt;I, O&amp;gt; copy_if(I first, S last, O result, Pred pred, Proj proj = {});            // (1)
+  constexpr copy_if_result&amp;lt;I, O&amp;gt;
+    copy_if(I first, S last, O result, Pred pred, Proj proj = {}); // (1) C++20
 
-  template&amp;lt;input_range R, weakly_incrementable O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-  constexpr copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt; copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {}); // (2)
+  constexpr copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {});           // (2) C++20
 }
 ```
 * copy_if_result[link ranges_in_out_result.md]
@@ -29,8 +38,9 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素のみをコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 `[first,last)` の範囲と、`[result,result + (last - first))` の範囲は重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_count.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 49d338d93..b8977916e 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -6,13 +6,20 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr iter_difference_t&amp;lt;I&amp;gt; count(I first, S last, const T&amp;amp; value, Proj proj = {}); // (1)
+  constexpr iter_difference_t&amp;lt;I&amp;gt;
+    count(I first, S last, const T&amp;amp; value, Proj proj = {}); // (1) C++20
 
-  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr range_difference_t&amp;lt;R&amp;gt; count(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});          // (2)
+  constexpr range_difference_t&amp;lt;R&amp;gt;
+    count(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});           // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -29,8 +36,8 @@ namespace std::ranges {
 ## 概要
 指定された値と等値な要素の数を数える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_count_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 2cf414f54..c7510032d 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -6,11 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr iter_difference_t&amp;lt;I&amp;gt; count_if(I first, S last, Pred pred, Proj proj = {}); // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr range_difference_t&amp;lt;R&amp;gt; count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});          // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt;
+    count_if(I first, S last, Pred pred, Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt;
+    count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -27,8 +34,8 @@ namespace std::ranges {
 ## 概要
 条件を満たしている要素の数を数える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ends_with -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_ends_with.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_ends_with.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_ends_with.md b/reference/algorithm/ranges_ends_with.md
index 99ea4bd30..e5cd294ea 100644
--- a/reference/algorithm/ranges_ends_with.md
+++ b/reference/algorithm/ranges_ends_with.md
@@ -6,17 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires (forward_iterator&amp;lt;I1&amp;gt; || sized_sentinel_for&amp;lt;S1, I1&amp;gt;) &amp;amp;&amp;amp;
              (forward_iterator&amp;lt;I2&amp;gt; || sized_sentinel_for&amp;lt;S2, I2&amp;gt;) &amp;amp;&amp;amp;
              indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr bool
+    ends_with(I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires (forward_range&amp;lt;R1&amp;gt; || sized_range&amp;lt;R1&amp;gt;) &amp;amp;&amp;amp;
              (forward_range&amp;lt;R2&amp;gt; || sized_range&amp;lt;R2&amp;gt;) &amp;amp;&amp;amp;
              indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool ends_with(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+  constexpr bool
+    ends_with(R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -34,8 +56,8 @@ namespace std::ranges {
 ## 概要
 シーケンスの末尾が指定されたシーケンスと一致するかを調べる
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_equal.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
index 13b23e4d8..57026ce10 100644
--- a/reference/algorithm/ranges_equal.md
+++ b/reference/algorithm/ranges_equal.md
@@ -6,13 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr bool
+    equal(I1 first1,
+          S1 last1,
+          I2 first2,
+          S2 last2,
+          Pred pred = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool equal(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr bool
+    equal(R1&amp;amp;&amp;amp; r1,
+          R2&amp;amp;&amp;amp; r2,
+          Pred pred = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -30,8 +52,8 @@ namespace std::ranges {
 ## 概要
 2つの範囲を等値比較する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 2つの範囲の要素数および各要素が等値であった場合、`true`を返す。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_equal_range.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index 72e98876f..a3a94c713 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; equal_range(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; equal_range(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    equal_range(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    equal_range(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -30,6 +44,10 @@ namespace std::ranges {
 ## 概要
 指定した値と等しい範囲を取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
+
 ## 事前条件
 `[first,last)` の要素 `e` は `e &amp;lt; value` および `!(value &amp;lt; e)` 、あるいは `comp(e, value)` および `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_fill.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill.md b/reference/algorithm/ranges_fill.md
index 2eddb09d0..cf639f76f 100644
--- a/reference/algorithm/ranges_fill.md
+++ b/reference/algorithm/ranges_fill.md
@@ -6,13 +6,16 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O, sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
-    constexpr O fill(O first, S last, const T&amp;amp; value);
+  template &amp;lt;class T,
+            output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
+            sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
+  constexpr O
+    fill(O first, S last, const T&amp;amp; value); // (1) C++20
 
-  // (2)
-  template&amp;lt;class T, output_range&amp;lt;const T&amp;amp;&amp;gt; R&amp;gt;
-    constexpr borrowed_iterator_t&amp;lt;R&amp;gt; fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);
+  template &amp;lt;class T,
+            output_range&amp;lt;const T&amp;amp;&amp;gt; R&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);           // (2) C++20
 
 }
 ```
@@ -24,8 +27,8 @@ namespace std::ranges {
 ## 概要
 指定された値で出力の範囲に書き込む。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_fill_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill_n.md b/reference/algorithm/ranges_fill_n.md
index 75b9209e0..4916416db 100644
--- a/reference/algorithm/ranges_fill_n.md
+++ b/reference/algorithm/ranges_fill_n.md
@@ -7,7 +7,8 @@
 ```cpp
 namespace std::ranges {
   template&amp;lt;class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O&amp;gt;
-    constexpr O fill_n(O first, iter_difference_t&amp;lt;O&amp;gt; n, const T&amp;amp; value);
+  constexpr O
+    fill_n(O first, iter_difference_t&amp;lt;O&amp;gt; n, const T&amp;amp; value); // (1) C++20
 }
 ```
 * output_iterator[link /reference/iterator/output_iterator.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 0d20a1b04..d7d1df6a9 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr I find(I first, S last, const T&amp;amp; value, Proj proj = {});
-
-  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+  constexpr I
+    find(I first,
+         S last,
+         const T&amp;amp; value,
+         Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    find(R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value,
+         Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -28,8 +40,8 @@ namespace std::ranges {
 ## 概要
 指定された値を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find_end.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
index fb67c4655..758502647 100644
--- a/reference/algorithm/ranges_find_end.md
+++ b/reference/algorithm/ranges_find_end.md
@@ -6,21 +6,43 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;forward_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            forward_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt;
+    find_end(I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;forward_range R1,
+            forward_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; find_end(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt;
+    find_end(R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (2) C++20
 }
 ```
 
 ## 概要
 範囲の中から、特定のサブシーケンスを検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index c71d9979b..d91734951 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -6,13 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            forward_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr I1
+    find_first_of(I1 first1,
+                  S1 last1,
+                  I2 first2,
+                  S2 last2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            forward_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; find_first_of(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt;
+    find_first_of(R1&amp;amp;&amp;amp; r1,
+                  R2&amp;amp;&amp;amp; r2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -29,8 +51,8 @@ namespace std::ranges {
 ## 概要
 ある集合の1つとマッチする最初の要素を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+* (1): イテレータ範囲を指定する
+* (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
index 97cc69aee..94d46985f 100644
--- a/reference/algorithm/ranges_find_if.md
+++ b/reference/algorithm/ranges_find_if.md
@@ -6,11 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I
+    find_if(I first,
+            S last,
+            Pred pred,
+            Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if(R&amp;amp;&amp;amp; r,
+            Pred pred,
+            Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -25,8 +37,8 @@ namespace std::ranges {
 ## 概要
 範囲の中から、指定された条件を満たす最初の要素を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+* (1): イテレータ範囲を指定する
+* (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
index 5423c1f33..64d460c45 100644
--- a/reference/algorithm/ranges_find_if_not.md
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -6,11 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find_if_not(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I
+    find_if_not(I first,
+                S last,
+                Pred pred,
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if_not(R&amp;amp;&amp;amp; r,
+                Pred pred,
+                Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -25,8 +37,8 @@ namespace std::ranges {
 ## 概要
 範囲の中から、指定された条件を満たさない最初の要素を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_for_each.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each.md b/reference/algorithm/ranges_for_each.md
index 85795f2be..946d867c6 100644
--- a/reference/algorithm/ranges_for_each.md
+++ b/reference/algorithm/ranges_for_each.md
@@ -6,11 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
-  constexpr for_each_result&amp;lt;I, Fun&amp;gt; for_each(I first, S last, Fun f, Proj proj = {});                     // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
-  constexpr for_each_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, Fun&amp;gt; for_each(R&amp;amp;&amp;amp; r, Fun f, Proj proj = {});          // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  constexpr for_each_result&amp;lt;I, Fun&amp;gt;
+    for_each(I first,
+             S last,
+             Fun f,
+             Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  constexpr for_each_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, Fun&amp;gt;
+    for_each(R&amp;amp;&amp;amp; r,
+             Fun f,
+             Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -27,8 +39,8 @@ namespace std::ranges {
 ## 概要
 範囲の全ての要素に、指定された関数を適用する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+* (1): イテレータ範囲を指定する
+* (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index af7a4db63..dd7b328cc 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -6,8 +6,14 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
-  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; for_each_n(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt;
+    for_each_n(I first,
+               iter_difference_t&amp;lt;I&amp;gt; n,
+               Fun f,
+               Proj proj = {}); // (1) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -31,7 +37,7 @@ namespace std::ranges {
 `n &amp;gt;= 0`
 
 ## 効果
-範囲`[first, first + n)` 内の全てのイテレータ `i` に [`invoke`](/reference/functional/invoke.md)`(f, `[`invoke`](/reference/functional/invoke.md)`(proj, *i))` という操作を行う。
+イテレータ範囲`[first, first + n)` 内の全てのイテレータ `i` に [`invoke`](/reference/functional/invoke.md)`(f, `[`invoke`](/reference/functional/invoke.md)`(proj, *i))` という操作を行う。
 
 このアルゴリズムはその他のアルゴリズムと違い、[`invoke`](/reference/functional/invoke.md)`(proj, *i)` が書き換え可能な参照であれば、関数 `f` の内部でその値を書き換えても構わない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_generate.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate.md b/reference/algorithm/ranges_generate.md
index 323e24417..c07e9c82b 100644
--- a/reference/algorithm/ranges_generate.md
+++ b/reference/algorithm/ranges_generate.md
@@ -6,15 +6,21 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_or_output_iterator O, sentinel_for&amp;lt;O&amp;gt; S, copy_constructible F&amp;gt;
+  template &amp;lt;input_or_output_iterator O,
+            sentinel_for&amp;lt;O&amp;gt; S,
+            copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
-  constexpr O generate(O first, S last, F gen);
+  constexpr O
+    generate(O first,
+             S last,
+             F gen); // (1) C++20
 
-  // (2)
-  template&amp;lt;class R, copy_constructible F&amp;gt;
+  template &amp;lt;class R,
+            copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; output_range&amp;lt;R, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; generate(R&amp;amp;&amp;amp; r, F gen);
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    generate(R&amp;amp;&amp;amp; r,
+             F gen); // (2) C++20
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
@@ -29,8 +35,8 @@ namespace std::ranges {
 ## 概要
 出力の範囲へ関数の結果を書き込む。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_generate_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate_n.md b/reference/algorithm/ranges_generate_n.md
index fa2808156..04ff5213f 100644
--- a/reference/algorithm/ranges_generate_n.md
+++ b/reference/algorithm/ranges_generate_n.md
@@ -6,9 +6,13 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_or_output_iterator O, copy_constructible F&amp;gt;
+  template &amp;lt;input_or_output_iterator O,
+            copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
-  constexpr O generate_n(O first, iter_difference_t&amp;lt;O&amp;gt; n, F gen);
+  constexpr O
+    generate_n(O first,
+               iter_difference_t&amp;lt;O&amp;gt; n,
+               F gen);                  // (1) C++20
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>includes -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_includes.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_includes.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_includes.md b/reference/algorithm/ranges_includes.md
index 7ca3c4303..9d0571aab 100644
--- a/reference/algorithm/ranges_includes.md
+++ b/reference/algorithm/ranges_includes.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, input_range R2, class Proj1 = identity, class Proj2 = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool ranges::includes(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                 // (2)
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    includes(I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    includes(R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -27,8 +53,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 `[first2,last2)` が `empty` であるか、`[first2,last2)` の全ての要素が `[first1,last1)` に含まれている場合は `true`、そうでない場合は `false` を返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_inplace_merge.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_inplace_merge.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_inplace_merge.md b/reference/algorithm/ranges_inplace_merge.md
index a6365fb9c..8127d7be7 100644
--- a/reference/algorithm/ranges_inplace_merge.md
+++ b/reference/algorithm/ranges_inplace_merge.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  I
+    inplace_merge(I first,
+                  I middle,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (1) C++20
+
+  template &amp;lt;bidirectional_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  borrowed_iterator_t&amp;lt;R&amp;gt; inplace_merge(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, Comp comp = {}, Proj proj = {});
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    inplace_merge(R&amp;amp;&amp;amp; r,
+                  iterator_t&amp;lt;R&amp;gt; middle,
+                  Comp comp = {},
+                  Proj proj = {}); // (2) C++20
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -27,8 +41,8 @@ namespace std::ranges {
 ## 概要
 2つの連続したソート済み範囲をマージする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` の範囲はそれぞれソートされていること。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap.md b/reference/algorithm/ranges_is_heap.md
index 1cdbba857..3d7cffe21 100644
--- a/reference/algorithm/ranges_is_heap.md
+++ b/reference/algorithm/ranges_is_heap.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool is_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    is_heap(I first,
+            S last,
+            Comp comp = {},
+            Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    is_heap(R&amp;amp;&amp;amp; r,
+            Comp comp = {},
+            Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -26,8 +36,8 @@ namespace std::ranges {
 ## 概要
 範囲がヒープ化されているか判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap_until -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap_until.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_heap_until.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap_until.md b/reference/algorithm/ranges_is_heap_until.md
index 786dfc408..76bcc3e58 100644
--- a/reference/algorithm/ranges_is_heap_until.md
+++ b/reference/algorithm/ranges_is_heap_until.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; is_heap_until(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    is_heap_until(I first,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_heap_until(R&amp;amp;&amp;amp; r,
+                  Comp comp = {},
+                  Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -26,8 +36,8 @@ namespace std::ranges {
 ## 概要
 範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_partitioned -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_partitioned.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_partitioned.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_partitioned.md b/reference/algorithm/ranges_is_partitioned.md
index b4cdf7976..7ae74b210 100644
--- a/reference/algorithm/ranges_is_partitioned.md
+++ b/reference/algorithm/ranges_is_partitioned.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool is_partitioned(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    is_partitioned(I first,
+                   S last,
+                   Pred pred,
+                   Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    is_partitioned(R&amp;amp;&amp;amp; r,
+                   Pred pred,
+                   Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -26,6 +36,9 @@ namespace std::ranges {
 ## 概要
 与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 `[first,last)` が空、 または `[first,last)` が `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているなら `true` 、そうでなければ `false` を返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_permutation.md b/reference/algorithm/ranges_is_permutation.md
index 9f7ade40f..c361920db 100644
--- a/reference/algorithm/ranges_is_permutation.md
+++ b/reference/algorithm/ranges_is_permutation.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
-           indirect_equivalence_relation&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;forward_range R1, forward_range R2, class Proj1 = identity, class Proj2 = identity,
-           indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr bool is_permutation(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+  template &amp;lt;forward_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            forward_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_equivalence_relation&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr bool
+    is_permutation(I1 first1,
+                   S1 last1,
+                   I2 first2,
+                   S2 last2,
+                   Pred pred = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;forward_range R1,
+            forward_range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_equivalence_relation&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr bool
+    is_permutation(R1&amp;amp;&amp;amp; r1,
+                   R2&amp;amp;&amp;amp; r2,
+                   Pred pred = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -27,8 +53,8 @@ namespace std::ranges {
 ## 概要
 範囲 `[first2, last2)` を並べ替えたものが、`[first1, last1)` の範囲と一致するか判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 `last2` が与えられている形式の場合、`last1 - first1 != last2 - first2` であれば `false` を返す。  
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_sorted.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted.md b/reference/algorithm/ranges_is_sorted.md
index 0a2b6e8fe..586de7658 100644
--- a/reference/algorithm/ranges_is_sorted.md
+++ b/reference/algorithm/ranges_is_sorted.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    is_sorted(I first,
+              S last,
+              Comp comp = {},
+              Proj proj = {}); // (1) C++20
 
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool is_sorted(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    is_sorted(R&amp;amp;&amp;amp; r,
+              Comp comp = {},
+              Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -27,6 +37,10 @@ namespace std::ranges {
 ## 概要
 与えられた範囲がソート済みか判定する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
+
 ### 戻り値
 - (1) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(first, last, comp, proj) == last`
 - (2) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(r, comp, proj) == last`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted_until.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_sorted_until.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted_until.md b/reference/algorithm/ranges_is_sorted_until.md
index 5bc17f503..ff1c746c0 100644
--- a/reference/algorithm/ranges_is_sorted_until.md
+++ b/reference/algorithm/ranges_is_sorted_until.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; is_sorted_until(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    is_sorted_until(I first,
+                    S last,
+                    Comp comp = {},
+                    Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_sorted_until(R&amp;amp;&amp;amp; r,
+                    Comp comp = {},
+                    Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,8 +38,8 @@ namespace std::ranges {
 ## 概要
 ソート済みか判定し、ソートされていない位置のイテレータを取得する
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 [`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、`[first,last]` の中でソートされている範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lexicographical_compare.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_lexicographical_compare.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lexicographical_compare.md b/reference/algorithm/ranges_lexicographical_compare.md
index 16096a9bc..e85bdc772 100644
--- a/reference/algorithm/ranges_lexicographical_compare.md
+++ b/reference/algorithm/ranges_lexicographical_compare.md
@@ -7,13 +7,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, input_range R2, class Proj1 = identity, class Proj2 = identity,
-          indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool lexicographical_compare(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    lexicographical_compare(I1 first1,
+                            S1 last1,
+                            I2 first2,
+                            S2 last2,
+                            Comp comp = {},
+                            Proj1 proj1 = {},
+                            Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    lexicographical_compare(R1&amp;amp;&amp;amp; r1,
+                            R2&amp;amp;&amp;amp; r2,
+                            Comp comp = {},
+                            Proj1 proj1 = {},
+                            Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -28,8 +54,8 @@ namespace std::ranges {
 ## 概要
 `[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
index 78c61d462..096e3675b 100644
--- a/reference/algorithm/ranges_lower_bound.md
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I lower_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; lower_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    lower_bound(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    lower_bound(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,6 +42,9 @@ namespace std::ranges {
 ## 概要
 指定された要素以上の値が現れる最初の位置のイテレータを取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::ranges::equal_range()`](ranges_equal_range.md)関数を使用できる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_make_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_make_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_make_heap.md b/reference/algorithm/ranges_make_heap.md
index 0e2118aa8..4679c8fc0 100644
--- a/reference/algorithm/ranges_make_heap.md
+++ b/reference/algorithm/ranges_make_heap.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I make_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    make_heap(I first,
+              S last,
+              Comp comp = {},
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; make_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    make_heap(R&amp;amp;&amp;amp; r,
+              Comp comp = {},
+              Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 範囲をヒープ化する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_max.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max.md b/reference/algorithm/ranges_max.md
index 3c18d2a68..1fe53446f 100644
--- a/reference/algorithm/ranges_max.md
+++ b/reference/algorithm/ranges_max.md
@@ -6,18 +6,31 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr const T&amp;amp; max(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {}); // (1)
-
-  template&amp;lt;copyable T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr T max(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});         // (2)
-
-  template&amp;lt;input_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  template &amp;lt;class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp;
+    max(const T&amp;amp; a,
+        const T&amp;amp; b,
+        Comp comp = {},
+        Proj proj = {}); // (1) C++20
+
+  template &amp;lt;copyable T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr T
+    max(initializer_list&amp;lt;T&amp;gt; r,
+        Comp comp = {},
+        Proj proj = {}); // (2) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
     requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
-  constexpr range_value_t&amp;lt;R&amp;gt; max(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});          // (3)
+  constexpr range_value_t&amp;lt;R&amp;gt;
+    max(R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (3) C++20
 }
 ```
 * identity[link /reference/functional/identity.md]
@@ -33,6 +46,11 @@ namespace std::ranges {
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最大値を取得する。
 
+- (1): 2つの値を指定する
+- (2): 初期化子リストを指定する
+- (3): Rangeを指定する
+
+
 ## 戻り値
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最大と判断された最初の値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
index fdcacd74e..267aee7f7 100644
--- a/reference/algorithm/ranges_max_element.md
+++ b/reference/algorithm/ranges_max_element.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; max_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    max_element(I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    max_element(R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,6 +38,9 @@ namespace std::ranges {
 ## 概要
 `[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最大と判断された最初の要素を指すイテレータ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_merge.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
index 226e863ab..234e721e6 100644
--- a/reference/algorithm/ranges_merge.md
+++ b/reference/algorithm/ranges_merge.md
@@ -6,15 +6,43 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
-  constexpr merge_result&amp;lt;I1, I2, O&amp;gt; merge(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                    // (1)
-
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr merge_result&amp;lt;I1, I2, O&amp;gt;
+    merge(I1 first1,
+          S1 last1,
+          I2 first2,
+          S2 last2,
+          O result,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
-  constexpr merge_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt; merge(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (2)
+  constexpr merge_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;,
+    O
+  &amp;gt;
+    merge(R1&amp;amp;&amp;amp; r1,
+          R2&amp;amp;&amp;amp; r2,
+          O result,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {});  // (2) C++20
 }
 ```
 * merge_result[link ranges_in_in_out_result.md]
@@ -31,8 +59,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲をマージして、出力イテレータへ出力する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_min.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min.md b/reference/algorithm/ranges_min.md
index 254a4e8b3..67f024c65 100644
--- a/reference/algorithm/ranges_min.md
+++ b/reference/algorithm/ranges_min.md
@@ -6,18 +6,31 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr const T&amp;amp; min(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {}); // (1)
-
-  template&amp;lt;copyable T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr T min(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});         // (2)
-
-  template&amp;lt;input_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  template &amp;lt;class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp;
+    min(const T&amp;amp; a,
+        const T&amp;amp; b,
+        Comp comp = {},
+        Proj proj = {}); // (1) C++20
+
+  template &amp;lt;copyable T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr T
+    min(initializer_list&amp;lt;T&amp;gt; r,
+        Comp comp = {},
+        Proj proj = {}); // (2) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
     requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
-  constexpr range_value_t&amp;lt;R&amp;gt; min(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});          // (3)
+  constexpr range_value_t&amp;lt;R&amp;gt;
+    min(R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (3) C++20
 }
 ```
 * identity[link /reference/functional/identity.md]
@@ -33,6 +46,11 @@ namespace std::ranges {
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値を取得する。
 
+- (1): 2つの値を指定する
+- (2): 初期化子リストを指定する
+- (3): Rangeを指定する
+
+
 ## 戻り値
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最小と判断された最初の値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_min_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
index 1ce557869..27966205a 100644
--- a/reference/algorithm/ranges_min_element.md
+++ b/reference/algorithm/ranges_min_element.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; min_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    min_element(I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    min_element(R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -29,6 +39,9 @@ namespace std::ranges {
 ## 概要
 `[first, last)`の範囲において、最小要素を指す最初のイテレータを取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最小と判断された最初の要素を指すイテレータ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_minmax.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax.md b/reference/algorithm/ranges_minmax.md
index da743ed64..2cbda0b5a 100644
--- a/reference/algorithm/ranges_minmax.md
+++ b/reference/algorithm/ranges_minmax.md
@@ -6,18 +6,31 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_result&amp;lt;const T&amp;amp;&amp;gt; minmax(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;copyable T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_result&amp;lt;T&amp;gt; minmax(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;input_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  template &amp;lt;class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;const T&amp;amp;&amp;gt;
+    minmax(const T&amp;amp; a,
+           const T&amp;amp; b,
+           Comp comp = {},
+           Proj proj = {}); // (1) C++20
+
+  template &amp;lt;copyable T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;T&amp;gt;
+    minmax(initializer_list&amp;lt;T&amp;gt; r,
+           Comp comp = {},
+           Proj proj = {}); // (2) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
     requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
-  constexpr minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt; minmax(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax(R&amp;amp;&amp;amp; r,
+           Comp comp = {},
+           Proj proj = {}); // (3) C++20
 }
 ```
 * minmax_result[link ranges_min_max_result.md]
@@ -34,6 +47,11 @@ namespace std::ranges {
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値と最大値の組を取得する。
 
+- (1): 2つの値を指定する
+- (2): 初期化子リストを指定する
+- (3): Rangeを指定する
+
+
 ## 戻り値
 ```cpp
 minmax_result {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
index 32bbf40e1..cb0d2b76e 100644
--- a/reference/algorithm/ranges_minmax_element.md
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_element_result&amp;lt;I&amp;gt; minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_element_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; minmax_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_element_result&amp;lt;I&amp;gt;
+    minmax_element(I first,
+                   S last,
+                   Comp comp = {},
+                   Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_element_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax_element(R&amp;amp;&amp;amp; r,
+                   Comp comp = {},
+                   Proj proj = {}); // (2) C++20
 }
 ```
 * minmax_element_result[link ranges_min_max_result.md]
@@ -30,6 +40,9 @@ namespace std::ranges {
 ## 概要
 `[first, last)` の範囲において、最小要素を指すイテレータと最大要素を指すイテレータの組を取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_mismatch.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index bf6754050..71f550a11 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -6,13 +6,38 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;I1, I2&amp;gt; mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                      // (1)
-
-  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr mismatch_result&amp;lt;I1, I2&amp;gt;
+    mismatch(I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; mismatch(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    // (2)
+  constexpr mismatch_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;
+  &amp;gt;
+    mismatch(R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * mismatch_result[link ranges_in_in_result.md]
@@ -34,8 +59,9 @@ namespace std::ranges {
 ## 概要
 2つのシーケンスが一致していない場所を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_move.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move.md b/reference/algorithm/ranges_move.md
index 5e8937914..7b4fe35e0 100644
--- a/reference/algorithm/ranges_move.md
+++ b/reference/algorithm/ranges_move.md
@@ -6,13 +6,21 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O&amp;gt;
     requires indirectly_movable&amp;lt;I, O&amp;gt;
-  constexpr move_result&amp;lt;I, O&amp;gt; move(I first, S last, O result);            // (1)
+  constexpr move_result&amp;lt;I, O&amp;gt;
+    move(I first,
+         S last,
+         O result); // (1) C++20
 
-  template&amp;lt;input_range R, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_range R,
+            weakly_incrementable O&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-  constexpr move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt; move(R&amp;amp;&amp;amp; r, O result); // (2)
+  constexpr move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    move(R&amp;amp;&amp;amp; r,
+         O result); // (2) C++20
 }
 ```
 * move_result[link ranges_in_out_result.md]
@@ -27,8 +35,9 @@ namespace std::ranges {
 ## 概要
 指定された範囲の要素をムーブする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 `result` は `[first,last)` の範囲に含まれてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_backward -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move_backward.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_move_backward.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move_backward.md b/reference/algorithm/ranges_move_backward.md
index 2e6f08a14..a49dc8227 100644
--- a/reference/algorithm/ranges_move_backward.md
+++ b/reference/algorithm/ranges_move_backward.md
@@ -6,13 +6,21 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, bidirectional_iterator I2&amp;gt;
+  template &amp;lt;bidirectional_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            bidirectional_iterator I2&amp;gt;
     requires indirectly_movable&amp;lt;I1, I2&amp;gt;
-  constexpr move_backward_result&amp;lt;I1, I2&amp;gt; move_backward(I1 first, S1 last, I2 result);       // (1)
+  constexpr move_backward_result&amp;lt;I1, I2&amp;gt;
+    move_backward(I1 first,
+                  S1 last,
+                  I2 result); // (1) C++20
 
-  template&amp;lt;bidirectional_range R, bidirectional_iterator I&amp;gt;
+  template &amp;lt;bidirectional_range R,
+            bidirectional_iterator I&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
-  constexpr move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt; move_backward(R&amp;amp;&amp;amp; r, I result); // (2)
+  constexpr move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+    move_backward(R&amp;amp;&amp;amp; r,
+                  I result); // (2) C++20
 }
 ```
 * move_backward_result[link ranges_in_out_result.md]
@@ -26,8 +34,8 @@ namespace std::ranges {
 ## 概要
 指定された範囲の要素を後ろからムーブする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 `result` は `(first,last]` の範囲に含まれてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>next_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_next_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_next_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_next_permutation.md b/reference/algorithm/ranges_next_permutation.md
index 3f3f123a1..1d8b6a8aa 100644
--- a/reference/algorithm/ranges_next_permutation.md
+++ b/reference/algorithm/ranges_next_permutation.md
@@ -7,13 +7,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr next_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
-
-  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr next_permutation_result&amp;lt;I&amp;gt;
+    next_permutation(I first,
+                     S last,
+                     Comp comp = {},
+                     Proj proj = {}); // (1) C++20
+
+  template &amp;lt;bidirectional_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr next_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
+  constexpr next_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    next_permutation(R&amp;amp;&amp;amp; r,
+                     Comp comp = {},
+                     Proj proj = {}); // (2) C++20
 }
 ```
 * next_permutation_result[link ranges_in_found_result.md]
@@ -29,8 +41,8 @@ namespace std::ranges {
 ## 概要
 与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその次の順列を生成する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `[first, last)`の範囲を次の順列に変換する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_none_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_none_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_none_of.md b/reference/algorithm/ranges_none_of.md
index 28fa19168..e90173df9 100644
--- a/reference/algorithm/ranges_none_of.md
+++ b/reference/algorithm/ranges_none_of.md
@@ -6,11 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool none_of(I first, S last, Pred pred, Proj proj = {}); // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool none_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    none_of(I first,
+            S last,
+            Pred pred,
+            Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    none_of(R&amp;amp;&amp;amp; r,
+            Pred pred,
+            Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -23,8 +35,8 @@ namespace std::ranges {
 ## 概要
 範囲の全ての要素が条件を満たさないかを判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_nth_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
index e44cb9b34..a606db096 100644
--- a/reference/algorithm/ranges_nth_element.md
+++ b/reference/algorithm/ranges_nth_element.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    nth_element(I first,
+                I nth,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; nth_element(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; nth, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    nth_element(R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; nth,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -28,6 +42,9 @@ namespace std::ranges {
 ## 概要
 基準となる要素よりも小さい要素が前に来るよう並べ替える。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
 
 ある範囲に対して部分的な並び替えを行う場合、[`partial_sort()`](partial_sort.md)を使用する。また範囲全体に対して並び替えを行う場合、[`sort()`](sort.md)を使用する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index 07cd26fd8..9d5748cf8 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    partial_sort(I first,
+                 I middle,
+                 S last,
+                 Comp comp = {},
+                 Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; partial_sort(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    partial_sort(R&amp;amp;&amp;amp; r,
+                 iterator_t&amp;lt;R&amp;gt; middle,
+                 Comp comp = {},
+                 Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -28,6 +42,9 @@ namespace std::ranges {
 ## 概要
 範囲を部分的にソートし、先頭 `N` 個を順に並んだ状態にする。`N` は `middle - first` で決まる。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 この関数は、「売り上げランキング トップ1位から10位まで」のように、全体ではなく最高順位から途中までの順位がわかればよい状況で、全体を並び替える[`sort()`](sort.md)関数の代わりに使用できる。
 
 なお、トップ10がどれかわかれば十分である（1位から10位までは順不同でよい）ような場合、[`nth_element()`](nth_element.md)が使用できる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partial_sort_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort_copy.md b/reference/algorithm/ranges_partial_sort_copy.md
index 5301774bc..1078006a7 100644
--- a/reference/algorithm/ranges_partial_sort_copy.md
+++ b/reference/algorithm/ranges_partial_sort_copy.md
@@ -6,20 +6,42 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, random_access_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp; sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
              indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
   constexpr partial_sort_copy_result&amp;lt;I1, I2&amp;gt;
-    partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, random_access_range R2,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    partial_sort_copy(I1 first,
+                      S1 last,
+                      I2 result_first,
+                      S2 result_last,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            random_access_range R2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt; &amp;amp;&amp;amp;
              sortable&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
-             indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;
+             indirect_strict_weak_order&amp;lt;
+               Comp,
+               projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+             &amp;gt;
   constexpr partial_sort_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
-    partial_sort_copy(R1&amp;amp;&amp;amp; r, R2&amp;amp;&amp;amp; result_r, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                              // (2)
+    partial_sort_copy(R1&amp;amp;&amp;amp; r,
+                      R2&amp;amp;&amp;amp; result_r,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * partial_sort_copy_result[link ranges_in_out_result.md]
@@ -40,8 +62,8 @@ namespace std::ranges {
 ## 概要
 範囲を部分的にソートした結果を他の範囲にコピーする
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `N = `[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` とする。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partition.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition.md b/reference/algorithm/ranges_partition.md
index 4c18cae09..fdf8f06f6 100644
--- a/reference/algorithm/ranges_partition.md
+++ b/reference/algorithm/ranges_partition.md
@@ -6,14 +6,24 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; partition(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    partition(I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; partition(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    partition(R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
index ebd6fec68..92e2f44e3 100644
--- a/reference/algorithm/ranges_partition_copy.md
+++ b/reference/algorithm/ranges_partition_copy.md
@@ -6,17 +6,33 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O1, weakly_incrementable O2, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O1,
+            weakly_incrementable O2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;I, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;I, O2&amp;gt;
   constexpr partition_copy_result&amp;lt;I, O1, O2&amp;gt;
-    partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O1, weakly_incrementable O2, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O2&amp;gt;
+    partition_copy(I first,
+                   S last, O1 out_true,
+                   O2 out_false,
+                   Pred pred,
+                   Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O1,
+            weakly_incrementable O2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O1&amp;gt; &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O2&amp;gt;
   constexpr partition_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O1, O2&amp;gt;
-    partition_copy(R&amp;amp;&amp;amp; r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
+    partition_copy(R&amp;amp;&amp;amp; r,
+                   O1 out_true,
+                   O2 out_false,
+                   Pred pred,
+                   Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -35,8 +51,8 @@ namespace std::ranges {
 ## 概要
 与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_point -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_point.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partition_point.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_point.md b/reference/algorithm/ranges_partition_point.md
index 165001182..a6d4d9077 100644
--- a/reference/algorithm/ranges_partition_point.md
+++ b/reference/algorithm/ranges_partition_point.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; partition_point(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I
+    partition_point(I first,
+                    S last,
+                    Pred pred,
+                    Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    partition_point(R&amp;amp;&amp;amp; r,
+                    Pred pred,
+                    Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,8 +38,8 @@ namespace std::ranges {
 ## 概要
 与えられた範囲から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` は `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現してなければならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pop_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_pop_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_pop_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_pop_heap.md b/reference/algorithm/ranges_pop_heap.md
index ae6ec364f..de502d680 100644
--- a/reference/algorithm/ranges_pop_heap.md
+++ b/reference/algorithm/ranges_pop_heap.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    pop_heap(I first,
+             S last,
+             Comp comp = {},
+             Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; pop_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    pop_heap(R&amp;amp;&amp;amp; r,
+             Comp comp = {},
+             Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 ヒープ化された範囲の先頭と末尾を入れ替え、ヒープ範囲を作り直す
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>prev_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_prev_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_prev_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_prev_permutation.md b/reference/algorithm/ranges_prev_permutation.md
index 8cac1b54b..ae00858a1 100644
--- a/reference/algorithm/ranges_prev_permutation.md
+++ b/reference/algorithm/ranges_prev_permutation.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr prev_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
-
-  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr prev_permutation_result&amp;lt;I&amp;gt;
+    next_permutation(I first,
+                     S last,
+                     Comp comp = {},
+                     Proj proj = {}); // (1) C++20
+
+  template &amp;lt;bidirectional_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr prev_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
+  constexpr prev_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    next_permutation(R&amp;amp;&amp;amp; r,
+                     Comp comp = {},
+                     Proj proj = {}); // (2) C++20
 }
 ```
 * prev_permutation_result[link ranges_in_found_result.md]
@@ -28,8 +40,8 @@ namespace std::ranges {
 ## 概要
 与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその前の順列を生成する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `[first, last)`の範囲を前の順列に変換する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>push_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_push_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_push_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_push_heap.md b/reference/algorithm/ranges_push_heap.md
index a3b83cbcb..83356ad17 100644
--- a/reference/algorithm/ranges_push_heap.md
+++ b/reference/algorithm/ranges_push_heap.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I push_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    push_heap(I first,
+              S last,
+              Comp comp = {},
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; push_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    push_heap(R&amp;amp;&amp;amp; r,
+              Comp comp = {},
+              Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 ヒープ化された範囲に要素を追加する
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_remove.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove.md b/reference/algorithm/ranges_remove.md
index 4787437db..77087996f 100644
--- a/reference/algorithm/ranges_remove.md
+++ b/reference/algorithm/ranges_remove.md
@@ -6,15 +6,30 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; remove(I first, S last, const T&amp;amp; value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class T, class Proj = identity&amp;gt;
-    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; remove(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+  constexpr subrange&amp;lt;I&amp;gt;
+    remove(I first,
+           S last,
+           const T&amp;amp; value,
+           Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove(R&amp;amp;&amp;amp; r,
+           const T&amp;amp; value,
+           Proj proj = {}); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -31,8 +46,8 @@ namespace std::ranges {
 ## 概要
 指定された要素を取り除く。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_remove_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy.md b/reference/algorithm/ranges_remove_copy.md
index a047a5abf..7a63b402a 100644
--- a/reference/algorithm/ranges_remove_copy.md
+++ b/reference/algorithm/ranges_remove_copy.md
@@ -6,17 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class T, class Proj = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr remove_copy_result&amp;lt;I, O&amp;gt;
-    remove_copy(I first, S last, O result, const T&amp;amp; value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, class T, class Proj = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    remove_copy(I first,
+                S last,
+                O result,
+                const T&amp;amp; value,
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr remove_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    remove_copy(R&amp;amp;&amp;amp; r, O result, const T&amp;amp; value, Proj proj = {});
+    remove_copy(R&amp;amp;&amp;amp; r,
+                O result,
+                const T&amp;amp; value,
+                Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -35,8 +57,8 @@ namespace std::ranges {
 ## 概要
 指定された要素を除け、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first)` は重なってはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_remove_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy_if.md b/reference/algorithm/ranges_remove_copy_if.md
index 65ddfde49..f6a052879 100644
--- a/reference/algorithm/ranges_remove_copy_if.md
+++ b/reference/algorithm/ranges_remove_copy_if.md
@@ -6,17 +6,29 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
   constexpr remove_copy_if_result&amp;lt;I, O&amp;gt;
-    remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    remove_copy_if(I first,
+                   S last,
+                   O result,
+                   Pred pred,
+                   Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr remove_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    remove_copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {});
+    remove_copy_if(R&amp;amp;&amp;amp; r,
+                   O result,
+                   Pred pred,
+                   Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -34,8 +46,8 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素を除け、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first)` は重なってはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_remove_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_if.md b/reference/algorithm/ranges_remove_if.md
index 855660bd3..32b4e37fe 100644
--- a/reference/algorithm/ranges_remove_if.md
+++ b/reference/algorithm/ranges_remove_if.md
@@ -6,14 +6,24 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-    constexpr subrange&amp;lt;I&amp;gt; remove_if(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    remove_if(I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; remove_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove_if(R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -30,8 +40,8 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素を除ける。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_replace.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace.md b/reference/algorithm/ranges_replace.md
index c94e3b262..a40e83795 100644
--- a/reference/algorithm/ranges_replace.md
+++ b/reference/algorithm/ranges_replace.md
@@ -6,15 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T1, class T2, class Proj = identity&amp;gt;
-    requires indirectly_writable&amp;lt;I, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T1*&amp;gt;
-  constexpr I replace(I first, S last, const T1&amp;amp; old_value, const T2&amp;amp; new_value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T1, class T2, class Proj = identity&amp;gt;
-    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T1*&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; replace(R&amp;amp;&amp;amp; r, const T1&amp;amp; old_value, const T2&amp;amp; new_value, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;I, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T1*&amp;gt;
+  constexpr I
+    replace(I first,
+            S last,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace(R&amp;amp;&amp;amp; r,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -31,8 +51,8 @@ namespace std::ranges {
 ## 概要
 指定された値と一致する要素を指定された値に置き換える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_replace_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy.md b/reference/algorithm/ranges_replace_copy.md
index 406a3c318..642891e7e 100644
--- a/reference/algorithm/ranges_replace_copy.md
+++ b/reference/algorithm/ranges_replace_copy.md
@@ -6,17 +6,43 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T1, class T2, output_iterator&amp;lt;const T2&amp;amp;&amp;gt; O, class Proj = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T1*&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T1,
+            class T2,
+            output_iterator&amp;lt;const T2&amp;amp;&amp;gt; O,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
   constexpr replace_copy_result&amp;lt;I, O&amp;gt;
-    replace_copy(I first, S last, O result, const T1&amp;amp; old_value, const T2&amp;amp; new_value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T1, class T2, output_iterator&amp;lt;const T2&amp;amp;&amp;gt; O, class Proj = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T1*&amp;gt;
+    replace_copy(I first,
+                 S last,
+                 O result,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T1,
+            class T2,
+            output_iterator&amp;lt;const T2&amp;amp;&amp;gt; O,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
   constexpr replace_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    replace_copy(R&amp;amp;&amp;amp; r, O result, const T1&amp;amp; old_value, const T2&amp;amp; new_value, Proj proj = {});
+    replace_copy(R&amp;amp;&amp;amp; r,
+                 O result,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -35,8 +61,8 @@ namespace std::ranges {
 ## 概要
 指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_replace_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy_if.md b/reference/algorithm/ranges_replace_copy_if.md
index 2f3fefdde..6907413b8 100644
--- a/reference/algorithm/ranges_replace_copy_if.md
+++ b/reference/algorithm/ranges_replace_copy_if.md
@@ -6,17 +6,33 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
   constexpr replace_copy_if_result&amp;lt;I, O&amp;gt;
-    replace_copy_if(I first, S last, O result, Pred pred, const T&amp;amp; new_value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    replace_copy_if(I first,
+                    S last,
+                    O result,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T,
+            output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr replace_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    replace_copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, const T&amp;amp; new_value, Proj proj = {});
+    replace_copy_if(R&amp;amp;&amp;amp; r,
+                    O result,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -34,8 +50,8 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_replace_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_if.md b/reference/algorithm/ranges_replace_if.md
index 44222d628..be92ef555 100644
--- a/reference/algorithm/ranges_replace_if.md
+++ b/reference/algorithm/ranges_replace_if.md
@@ -6,15 +6,29 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_writable&amp;lt;I, const T&amp;amp;&amp;gt;
-  constexpr I replace_if(I first, S last, Pred pred, const T&amp;amp; new_value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I
+    replace_if(I first,
+               S last,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; replace_if(R&amp;amp;&amp;amp; r, Pred pred, const T&amp;amp; new_value, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace_if(R&amp;amp;&amp;amp; r,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -30,8 +44,8 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素を指定された値に置き換える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_reverse.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse.md b/reference/algorithm/ranges_reverse.md
index cb3f4c4bf..28caf6aa5 100644
--- a/reference/algorithm/ranges_reverse.md
+++ b/reference/algorithm/ranges_reverse.md
@@ -6,15 +6,17 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
     requires permutable&amp;lt;I&amp;gt;
-  constexpr I reverse(I first, S last);
+  constexpr I
+    reverse(I first,
+            S last); // (1) C++20
 
-  // (2)
-  template&amp;lt;bidirectional_range R&amp;gt;
+  template &amp;lt;bidirectional_range R&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; reverse(R&amp;amp;&amp;amp; r);
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    reverse(R&amp;amp;&amp;amp; r);  // (2) C++20
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -27,8 +29,8 @@ namespace std::ranges {
 ## 概要
 要素の並びを逆にする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_reverse_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse_copy.md b/reference/algorithm/ranges_reverse_copy.md
index 60fa353f1..063c8155d 100644
--- a/reference/algorithm/ranges_reverse_copy.md
+++ b/reference/algorithm/ranges_reverse_copy.md
@@ -6,17 +6,21 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
   constexpr reverse_copy_result&amp;lt;I, O&amp;gt;
-    reverse_copy(I first, S last, O result);
+    reverse_copy(I first,
+                 S last,
+                 O result); // (1) C++20
 
-  // (2)
-  template&amp;lt;bidirectional_range R, weakly_incrementable O&amp;gt;
+  template &amp;lt;bidirectional_range R,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr reverse_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    reverse_copy(R&amp;amp;&amp;amp; r, O result);
+    reverse_copy(R&amp;amp;&amp;amp; r,
+                 O result); // (2) C++20
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -31,8 +35,9 @@ namespace std::ranges {
 ## 概要
 要素の並びを逆にし、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 `[first,last)` と `[result,result+(last-first))` は領域が重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_rotate.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate.md b/reference/algorithm/ranges_rotate.md
index 057d5718b..6fbe6715f 100644
--- a/reference/algorithm/ranges_rotate.md
+++ b/reference/algorithm/ranges_rotate.md
@@ -6,14 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; rotate(I first, I middle, S last);
-
-  // (2)
-  template&amp;lt;forward_range R&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    rotate(I first,
+           I middle,
+           S last);               // (1) C++20
+
+  template &amp;lt;forward_range R&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; rotate(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle);
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    rotate(R&amp;amp;&amp;amp; r,
+           iterator_t&amp;lt;R&amp;gt; middle); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -26,8 +30,8 @@ namespace std::ranges {
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させる。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` は有効な範囲である必要がある。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_rotate_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate_copy.md b/reference/algorithm/ranges_rotate_copy.md
index 60a8e5a59..87cfa3d3e 100644
--- a/reference/algorithm/ranges_rotate_copy.md
+++ b/reference/algorithm/ranges_rotate_copy.md
@@ -6,17 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
- template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
   constexpr rotate_copy_result&amp;lt;I, O&amp;gt;
-    rotate_copy(I first, I middle, S last, O result);
+    rotate_copy(I first,
+                I middle,
+                S last,
+                O result); // (1) C++20
 
-  // (2)
-  template&amp;lt;forward_range R, weakly_incrementable O&amp;gt;
+  template &amp;lt;forward_range R,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr rotate_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    rotate_copy(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, O result);
+    rotate_copy(R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; middle,
+                O result); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -30,8 +36,8 @@ namespace std::ranges {
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sample -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sample.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_sample.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sample.md b/reference/algorithm/ranges_sample.md
index 9662516c3..0b65afd20 100644
--- a/reference/algorithm/ranges_sample.md
+++ b/reference/algorithm/ranges_sample.md
@@ -7,15 +7,31 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Gen&amp;gt;
-    requires (forward_iterator&amp;lt;I&amp;gt; || random_access_iterator&amp;lt;O&amp;gt;) &amp;amp;&amp;amp; indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp; uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
-  O sample(I first, S last, O out, iter_difference_t&amp;lt;I&amp;gt; n, Gen&amp;amp;&amp;amp; g);
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, class Gen&amp;gt;
-    requires (forward_range&amp;lt;R&amp;gt; || random_access_iterator&amp;lt;O&amp;gt;) &amp;amp;&amp;amp; indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp; uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
-  O sample(R&amp;amp;&amp;amp; r, O out, range_difference_t&amp;lt;R&amp;gt; n, Gen&amp;amp;&amp;amp; g);
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Gen&amp;gt;
+    requires (forward_iterator&amp;lt;I&amp;gt; || random_access_iterator&amp;lt;O&amp;gt;) &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
+  O
+    sample(I first,
+           S last,
+           O out,
+           iter_difference_t&amp;lt;I&amp;gt; n,
+           Gen&amp;amp;&amp;amp; g); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Gen&amp;gt;
+    requires (forward_range&amp;lt;R&amp;gt; || random_access_iterator&amp;lt;O&amp;gt;) &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
+             uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
+  O
+    sample(R&amp;amp;&amp;amp; r,
+           O out,
+           range_difference_t&amp;lt;R&amp;gt; n,
+           Gen&amp;amp;&amp;amp; g); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -32,8 +48,8 @@ namespace std::ranges {
 ## 概要
 範囲から指定された個数の要素をランダムに抽出する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `out`は範囲`[first, last)`に含まれてはならない
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_search.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index 3d474d81c..19bab6beb 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -6,14 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
-  sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;forward_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            forward_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt;
+    search(I1 first1,
+           S1 last1,
+           I2 first2,
+           S2 last2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;forward_range R1,
+            forward_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; search(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});              // (2)
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt;
+    search(R1&amp;amp;&amp;amp; r1,
+           R2&amp;amp;&amp;amp; r2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -29,8 +50,8 @@ namespace std::ranges {
 ## 概要
 あるシーケンスの中から、特定のサブシーケンスを探す
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 - (1) :
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_search_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search_n.md b/reference/algorithm/ranges_search_n.md
index 6ccb4346b..4cf0eca16 100644
--- a/reference/algorithm/ranges_search_n.md
+++ b/reference/algorithm/ranges_search_n.md
@@ -6,13 +6,31 @@
 
 ```cpp
 namespace std::ranges {]
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Pred = ranges::equal_to,
+            class Proj = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I, const T*, Pred, Proj&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; search_n(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    search_n(I first,
+             S last,
+             iter_difference_t&amp;lt;I&amp;gt; count,
+             const T&amp;amp; value,
+             Pred pred = {},
+             Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Pred = ranges::equal_to,
+            class Proj = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T*, Pred, Proj&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; search_n(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {});
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    search_n(R&amp;amp;&amp;amp; r,
+             range_difference_t&amp;lt;R&amp;gt; count,
+             const T&amp;amp; value,
+             Pred pred = {},
+             Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -30,8 +48,8 @@ namespace std::ranges {]
 ## 概要
 あるシーケンスの中から、指定の要素が連続するサブシーケンスを探す。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 `[first,last-count)` 内のイテレータ `i` があるとき、0 以上 `count` 未満の整数 `n` について、それぞれ [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *(i + n)), value)` であるようなサブシーケンスを探し、見つかった最初のサブシーケンスを返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_difference.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_set_difference.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_difference.md b/reference/algorithm/ranges_set_difference.md
index 5bf939271..d93ad1ab2 100644
--- a/reference/algorithm/ranges_set_difference.md
+++ b/reference/algorithm/ranges_set_difference.md
@@ -6,17 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_difference_result&amp;lt;I1, O&amp;gt;
-    set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    set_difference(I1 first1,
+                   S1 last1,
+                   I2 first2,
+                   S2 last2,
+                   O result,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, O&amp;gt;
-    set_difference(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+    set_difference(R1&amp;amp;&amp;amp; r1,
+                   R2&amp;amp;&amp;amp; r2,
+                   O result,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * set_difference_result[link ranges_in_out_result.md]
@@ -34,8 +56,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲の差集合を得る
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_intersection.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_set_intersection.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_intersection.md b/reference/algorithm/ranges_set_intersection.md
index bcea585c4..18d993c42 100644
--- a/reference/algorithm/ranges_set_intersection.md
+++ b/reference/algorithm/ranges_set_intersection.md
@@ -6,17 +6,43 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_intersection_result&amp;lt;I1, I2, O&amp;gt;
-    set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (1)
-
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    set_intersection(I1 first1,
+                     S1 last1,
+                     I2 first2,
+                     S2 last2,
+                     O result,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
-  constexpr set_intersection_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
-    set_intersection(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                          // (2)
+  constexpr set_intersection_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              O
+            &amp;gt;
+    set_intersection(R1&amp;amp;&amp;amp; r1,
+                     R2&amp;amp;&amp;amp; r2,
+                     O result,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * set_intersection_result[link ranges_in_in_out_result.md]
@@ -33,8 +59,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲の積集合を得る
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_symmetric_difference.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_set_symmetric_difference.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_symmetric_difference.md b/reference/algorithm/ranges_set_symmetric_difference.md
index 0d80425ab..e823c3f1e 100644
--- a/reference/algorithm/ranges_set_symmetric_difference.md
+++ b/reference/algorithm/ranges_set_symmetric_difference.md
@@ -6,22 +6,46 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_symmetric_difference_result&amp;lt;I1, I2, O&amp;gt;
-    set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  // (2)
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    set_symmetric_difference(I1 first1,
+                             S1 last1,
+                             I2 first2,
+                             S2 last2,
+                             O result,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
-  constexpr set_symmetric_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
-    set_symmetric_difference(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr set_symmetric_difference_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              O
+            &amp;gt;
+    set_symmetric_difference(R1&amp;amp;&amp;amp; r1,
+                             R2&amp;amp;&amp;amp; r2,
+                             O result,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (2) C++20
 }
 ```
-* set_symmetric_difference_result[link ranges_in_in_out_result.md] 
+* set_symmetric_difference_result[link ranges_in_in_out_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -35,8 +59,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_union.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_set_union.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_union.md b/reference/algorithm/ranges_set_union.md
index bce71361e..f35bf4bb3 100644
--- a/reference/algorithm/ranges_set_union.md
+++ b/reference/algorithm/ranges_set_union.md
@@ -6,17 +6,45 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_union_result&amp;lt;I1, I2, O&amp;gt;
-    set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});   // (1)
-
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
-    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
+    set_union(I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;
+               iterator_t&amp;lt;R1&amp;gt;,
+               iterator_t&amp;lt;R2&amp;gt;,
+               O,
+               Comp,
+               Proj1,
+               Proj2&amp;gt;
   constexpr set_union_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
-    set_union(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                           // (2)
+    set_union(R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              O result,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * set_union_result[link ranges_in_in_out_result.md]
@@ -33,8 +61,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲の和集合を得る
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_left -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_left.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_shift_left.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_left.md b/reference/algorithm/ranges_shift_left.md
index 2d0e8bf69..019b11dd2 100644
--- a/reference/algorithm/ranges_shift_left.md
+++ b/reference/algorithm/ranges_shift_left.md
@@ -6,14 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
-    constexpr subrange&amp;lt;I&amp;gt; shift_left(I first, S last, iter_difference_t&amp;lt;I&amp;gt; n);
-
-  // (2)
-  template&amp;lt;forward_range R&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    shift_left(I first,
+               S last,
+               iter_difference_t&amp;lt;I&amp;gt; n);  // (1) C++20
+
+  template &amp;lt;forward_range R&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; shift_left(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; n)
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_left(R&amp;amp;&amp;amp; r,
+               range_difference_t&amp;lt;R&amp;gt; n); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -28,8 +32,8 @@ namespace std::ranges {
 ## 概要
 範囲の要素をn個だけ左にシフトさせる。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_right -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_right.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_shift_right.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_right.md b/reference/algorithm/ranges_shift_right.md
index 0e41f9fc6..d536d557a 100644
--- a/reference/algorithm/ranges_shift_right.md
+++ b/reference/algorithm/ranges_shift_right.md
@@ -6,14 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
-    constexpr subrange&amp;lt;I&amp;gt; shift_right(I first, S last, iter_difference_t&amp;lt;I&amp;gt; n);
-
-  // (2)
-  template&amp;lt;forward_range R&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    shift_right(I first,
+                S last,
+                iter_difference_t&amp;lt;I&amp;gt; n); // (1) C++20
+
+  template &amp;lt;forward_range R&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; shift_right(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; n);
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_right(R&amp;amp;&amp;amp; r,
+                range_difference_t&amp;lt;R&amp;gt; n); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -29,8 +33,8 @@ namespace std::ranges {
 ## 概要
 範囲の要素をn個だけ右にシフトさせる。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shuffle -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shuffle.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_shuffle.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shuffle.md b/reference/algorithm/ranges_shuffle.md
index 662232a79..28130bad0 100644
--- a/reference/algorithm/ranges_shuffle.md
+++ b/reference/algorithm/ranges_shuffle.md
@@ -6,15 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Gen&amp;gt;
-    requires permutable&amp;lt;I&amp;gt; &amp;amp;&amp;amp; uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
-  I shuffle(I first, S last, Gen&amp;amp;&amp;amp; g);
-
-  // (2)
-  template&amp;lt;random_access_range R, class Gen&amp;gt;
-    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp; uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
-  borrowed_iterator_t&amp;lt;R&amp;gt; shuffle(R&amp;amp;&amp;amp; r, Gen&amp;amp;&amp;amp; g);
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Gen&amp;gt;
+    requires permutable&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+             uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
+  I
+    shuffle(I first,
+            S last,
+            Gen&amp;amp;&amp;amp; g); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Gen&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    shuffle(R&amp;amp;&amp;amp; r,
+            Gen&amp;amp;&amp;amp; g); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -28,10 +36,10 @@ namespace std::ranges {
 
 
 ## 概要
-`[first,last)` のそれぞれの要素を同じ確率で並び替える。
+範囲のそれぞれの要素を同じ確率で並び替える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort.md b/reference/algorithm/ranges_sort.md
index f4298012f..c5b53212b 100644
--- a/reference/algorithm/ranges_sort.md
+++ b/reference/algorithm/ranges_sort.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I sort(I first, S last, Comp comp = {}, Proj proj = {});            // (1)
-
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    sort(I first,
+         S last,
+         Comp comp = {},
+         Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; sort(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {}); // (2)
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    sort(R&amp;amp;&amp;amp; r,
+         Comp comp = {},
+         Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -27,8 +39,8 @@ namespace std::ranges {
 ## 概要
 範囲を並べ替える
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_sort_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort_heap.md b/reference/algorithm/ranges_sort_heap.md
index 30ba28e9c..99b319819 100644
--- a/reference/algorithm/ranges_sort_heap.md
+++ b/reference/algorithm/ranges_sort_heap.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    sort_heap(I first,
+              S last,
+              Comp comp = {},
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; sort_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    sort_heap(R&amp;amp;&amp;amp; r,
+              Comp comp = {},
+              Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 ヒープ化された範囲を並べ替える
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_partition -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_partition.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_stable_partition.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_partition.md b/reference/algorithm/ranges_stable_partition.md
index 8e013befc..8cfe53f6f 100644
--- a/reference/algorithm/ranges_stable_partition.md
+++ b/reference/algorithm/ranges_stable_partition.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires permutable&amp;lt;I&amp;gt;
-  subrange&amp;lt;I&amp;gt; stable_partition(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;bidirectional_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    stable_partition(I first,
+                     S last,
+                     Pred pred,
+                     Proj proj = {}); // (1) C++20
+
+  template &amp;lt;bidirectional_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  borrowed_subrange_t&amp;lt;R&amp;gt; stable_partition(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    stable_partition(R&amp;amp;&amp;amp; r,
+                     Pred pred,
+                     Proj proj = {}); // (2) C++20
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -32,8 +42,8 @@ namespace std::ranges {
 ## 概要
 与えられた範囲を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_stable_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_sort.md b/reference/algorithm/ranges_stable_sort.md
index ba21cfd28..2564b1bc7 100644
--- a/reference/algorithm/ranges_stable_sort.md
+++ b/reference/algorithm/ranges_stable_sort.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});            // (1)
-
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  I
+    stable_sort(I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  borrowed_iterator_t&amp;lt;R&amp;gt; stable_sort(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {}); // (2)
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    stable_sort(R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -27,8 +39,8 @@ namespace std::ranges {
 ## 概要
 範囲を安定ソートで並べ替える
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>starts_with -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_starts_with.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_starts_with.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_starts_with.md b/reference/algorithm/ranges_starts_with.md
index 2db8929a4..8331f84c9 100644
--- a/reference/algorithm/ranges_starts_with.md
+++ b/reference/algorithm/ranges_starts_with.md
@@ -6,13 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr bool
+    starts_with(I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool starts_with(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr bool
+    starts_with(R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -27,8 +49,8 @@ namespace std::ranges {
 ## 概要
 シーケンスの先頭が指定されたシーケンスと一致するかを調べる
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap_ranges -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_swap_ranges.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_swap_ranges.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_swap_ranges.md b/reference/algorithm/ranges_swap_ranges.md
index d70e346ff..78f4b5343 100644
--- a/reference/algorithm/ranges_swap_ranges.md
+++ b/reference/algorithm/ranges_swap_ranges.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2&amp;gt;
     requires indirectly_swappable&amp;lt;I1, I2&amp;gt;
-  constexpr swap_ranges_result&amp;lt;I1, I2&amp;gt; swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);                   // (1)
-
-  template&amp;lt;input_range R1, input_range R2&amp;gt;
+  constexpr swap_ranges_result&amp;lt;I1, I2&amp;gt;
+    swap_ranges(I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2&amp;gt;
     requires indirectly_swappable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt;
-  constexpr swap_ranges_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; swap_ranges(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2); // (2)
+  constexpr swap_ranges_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    swap_ranges(R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2); // (2) C++20
 }
 ```
 * swap_ranges_result[link ranges_in_in_result.md]
@@ -26,8 +38,8 @@ namespace std::ranges {
 ## 概要
 指定された2つの範囲同士を swap する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_transform.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_transform.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_transform.md b/reference/algorithm/ranges_transform.md
index 5521d8619..9586ce3e7 100644
--- a/reference/algorithm/ranges_transform.md
+++ b/reference/algorithm/ranges_transform.md
@@ -6,29 +6,80 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, copy_constructible F, class Proj = identity&amp;gt;
-    requires indirectly_writable&amp;lt;O, indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I, Proj&amp;gt;&amp;gt;&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I, Proj&amp;gt;&amp;gt;
+             &amp;gt;
   constexpr unary_transform_result&amp;lt;I, O&amp;gt;
-    transform(I first1, S last1, O result, F op, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, copy_constructible F, class Proj = identity&amp;gt;
-    requires indirectly_writable&amp;lt;O, indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;&amp;gt;
+    transform(I first1,
+              S last1,
+              O result,
+              F op,
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+             &amp;gt;
   constexpr unary_transform_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    transform(R&amp;amp;&amp;amp; r, O result, F op, Proj proj = {});
-
-  // (3)
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O, copy_constructible F, class Proj1 = identity, class Proj2 = identity&amp;gt;
-    requires indirectly_writable&amp;lt;O, indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;&amp;gt;
+    transform(R&amp;amp;&amp;amp; r,
+              O result,
+              F op,
+              Proj proj = {}); // (2) C++20
+
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
   constexpr binary_transform_result&amp;lt;I1, I2, O&amp;gt;
-    transform(I1 first1, S1 last1, I2 first2, S2 last2, O result, F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  // (4)
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O, copy_constructible F, class Proj1 = identity, class Proj2 = identity&amp;gt;
-    requires indirectly_writable&amp;lt;O, indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;&amp;gt;
-  constexpr binary_transform_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
-    transform(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
+    transform(I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (3) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
+  constexpr binary_transform_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              O
+            &amp;gt;
+    transform(R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              O result,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (4) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -49,11 +100,12 @@ namespace std::ranges {
 ## 概要
 全ての要素に関数を適用する。
 
-* (1), (2): 1つの範囲の要素に関数を適用し、結果を出力イテレータに出力する
-* (3), (4): 2つの範囲の要素を1つずつ取り出して関数を適用し、結果を出力イテレータに出力する
+- (1), (2): 1つの範囲の要素に関数を適用し、結果を出力イテレータに出力する
+- (3), (4): 2つの範囲の要素を1つずつ取り出して関数を適用し、結果を出力イテレータに出力する
+
+- (1), (3): イテレータ範囲を指定する
+- (2), (4): Rangeを直接指定する
 
-* (1), (3): イテレータペアで範囲を指定する
-* (2), (4): 範囲を直接指定する
 
 ## 事前条件
 - (1), (2) : `op` は、`[first,last]`, `[result,result + (last - first)]` 内のイテレータや subrange を無効にしたり、要素を書き換えてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_unique.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique.md b/reference/algorithm/ranges_unique.md
index 94dbae1b9..06b8f9d15 100644
--- a/reference/algorithm/ranges_unique.md
+++ b/reference/algorithm/ranges_unique.md
@@ -6,14 +6,24 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; unique(I first, S last, C comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    unique(I first,
+           S last,
+           C comp = {},
+           Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; unique(R&amp;amp;&amp;amp; r, C comp = {}, Proj proj = {});
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    unique(R&amp;amp;&amp;amp; r,
+           C comp = {},
+           Proj proj = {}); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -30,8 +40,8 @@ namespace std::ranges {
 ## 概要
 重複した要素を除ける。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 この関数は、隣り合った重複要素を除いた要素を、範囲の先頭に集める。この関数によってコンテナから直接要素が削除され、コンテナの要素数が減るようなことはない。コンテナから実際に要素を削除する場合は、この関数の戻り値として、先頭に集められた重複なし範囲の末尾の次を指すイテレータが返るため、そのイテレータを介してコンテナの`erase()`メンバ関数などを呼び出し、削除を行うこと。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_unique_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique_copy.md b/reference/algorithm/ranges_unique_copy.md
index f418c4473..ffea34d91 100644
--- a/reference/algorithm/ranges_unique_copy.md
+++ b/reference/algorithm/ranges_unique_copy.md
@@ -6,19 +6,37 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
-      (forward_iterator&amp;lt;I&amp;gt; || (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;iter_value_t&amp;lt;I&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) || indirectly_copyable_storable&amp;lt;I, O&amp;gt;)
+             (forward_iterator&amp;lt;I&amp;gt; ||
+               (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;iter_value_t&amp;lt;I&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) ||
+               indirectly_copyable_storable&amp;lt;I, O&amp;gt;
+             )
   constexpr unique_copy_result&amp;lt;I, O&amp;gt;
-    unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    unique_copy(I first,
+                S last,
+                O result,
+                C comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
-      (forward_iterator&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; || (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;range_value_t&amp;lt;R&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) || indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;)
+             (forward_iterator&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; ||
+               (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;range_value_t&amp;lt;R&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) ||
+               indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+             )
   constexpr unique_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    unique_copy(R&amp;amp;&amp;amp; r, O result, C comp = {}, Proj proj = {});
+    unique_copy(R&amp;amp;&amp;amp; r,
+                O result,
+                C comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -41,8 +59,8 @@ namespace std::ranges {
 ## 概要
 隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なっていてはならない
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/remove.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove.md b/reference/algorithm/remove.md
index 5621a18d6..69147c900 100644
--- a/reference/algorithm/remove.md
+++ b/reference/algorithm/remove.md
@@ -27,11 +27,11 @@ namespace std {
 ```
 
 ## 概要
-指定された要素を取り除く。
+イテレータ範囲`[first, last)`から`指定された要素を取り除く。
 
 
-## 要件
-`*first` の型は `MoveAssignable` の要件を満たす必要がある
+## テンプレートパラメータ制約
+- `*first` の型は `MoveAssignable` の要件を満たすこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/remove_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove_copy.md b/reference/algorithm/remove_copy.md
index a6a55fa99..2e9046c39 100644
--- a/reference/algorithm/remove_copy.md
+++ b/reference/algorithm/remove_copy.md
@@ -31,12 +31,16 @@ namespace std {
 ```
 
 ## 概要
-指定された要素を除け、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`から指定された要素を除け、その結果を出力の範囲へコピーする。
 
 
-## 要件
+## テンプレートパラメータ制約
+- `*result = *first` という式が有効であること
+
+
+## 事前条件
 - `[first,last)` と `[result,result + (last - first)` は重なってはならない。
-- `*result = *first` という式が有効でなければならない。
+
 
 ## 効果
 `[first,last)` 内にあるイテレータ `i` について、`*i == value` でない要素を `result` へコピーする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/remove_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove_copy_if.md b/reference/algorithm/remove_copy_if.md
index 392e2355d..aafd67fa6 100644
--- a/reference/algorithm/remove_copy_if.md
+++ b/reference/algorithm/remove_copy_if.md
@@ -31,12 +31,15 @@ namespace std {
 ```
 
 ## 概要
-条件を満たす要素を除け、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`から条件を満たす要素を除け、その結果を出力の範囲へコピーする。
 
 
-## 要件
-- `[first,last)` と `[result,result + (last - first)` は重なってはならない。
-- `*result = *first` という式が有効でなければならない。
+## テンプレートパラメータ制約
+- `*result = *first` という式が有効であること
+
+
+## 事前条件
+- `[first,last)` と `[result,result + (last - first)` は重なってはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/remove_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove_if.md b/reference/algorithm/remove_if.md
index 5491b2e78..3f1ecb2d9 100644
--- a/reference/algorithm/remove_if.md
+++ b/reference/algorithm/remove_if.md
@@ -27,11 +27,11 @@ namespace std {
 ```
 
 ## 概要
-条件を満たす要素を除ける。
+イテレータ範囲`[first, last)`から条件を満たす要素を除ける。
 
 
-## 要件
-`*first` の型は `MoveAssignable` の要件を満たす必要がある
+## テンプレートパラメータ制約
+- `*first` の型は `MoveAssignable` の要件を満たすこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/replace_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/replace_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/replace_copy.md b/reference/algorithm/replace_copy.md
index 80cdf9570..9b8e28518 100644
--- a/reference/algorithm/replace_copy.md
+++ b/reference/algorithm/replace_copy.md
@@ -33,12 +33,15 @@ namespace std {
 ```
 
 ## 概要
-指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`のうち、指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 
-## 要件
-- `*first` と `new_value` は `result` へ書き込み可能でなければならない。
-- また、`[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
+## テンプレートパラメータ制約
+- `*first` と `new_value` は `result` へ書き込み可能であること
+
+
+## 事前条件
+- `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/replace_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/replace_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/replace_copy_if.md b/reference/algorithm/replace_copy_if.md
index 7bb492d07..82635adc8 100644
--- a/reference/algorithm/replace_copy_if.md
+++ b/reference/algorithm/replace_copy_if.md
@@ -42,12 +42,15 @@ namespace std {
 ```
 
 ## 概要
-条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`のうち、条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 
-## 要件
-- `*first` と `new_value` は `result` へ書き込み可能でなければならない。
-- また、`[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
+## テンプレートパラメータ制約
+- `*first` と `new_value` は `result` へ書き込み可能であること
+
+
+## 事前条件
+- `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/reverse_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/reverse_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/reverse_copy.md b/reference/algorithm/reverse_copy.md
index 72bfed87f..6c8a9f7c9 100644
--- a/reference/algorithm/reverse_copy.md
+++ b/reference/algorithm/reverse_copy.md
@@ -27,11 +27,11 @@ namespace std {
 ```
 
 ## 概要
-要素の並びを逆にし、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`の要素順を逆にし、その結果を出力の範囲へコピーする。
 
 
-## 要件
-`[first,last)` と `[result,result+(last-first))` は領域が重なっていてはならない。
+## 事前条件
+- `[first,last)` と `[result,result+(last-first))` は領域が重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/rotate.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/rotate.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/rotate.md b/reference/algorithm/rotate.md
index b88dc9e12..9c70fa70e 100644
--- a/reference/algorithm/rotate.md
+++ b/reference/algorithm/rotate.md
@@ -33,13 +33,16 @@ namespace std {
 ```
 
 ## 概要
-`middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させる。
+`middle`の要素が先頭、`middle-1`の要素が末尾となるように、イテレータ範囲`[first,last)`の要素の並びを回転させる。
 
 
 ## 要件
-- `[first,middle)` と `[middle,last)` は有効な範囲である必要がある。
-- `ForwardIterator` は `ValueSwappable` の要件を満たしている必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+- `ForwardIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+
+
+## 事前条件
+- `[first,middle)` と `[middle,last)` は有効な範囲であること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/rotate_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/rotate_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/rotate_copy.md b/reference/algorithm/rotate_copy.md
index b754faaa9..f7c3e7c03 100644
--- a/reference/algorithm/rotate_copy.md
+++ b/reference/algorithm/rotate_copy.md
@@ -30,11 +30,11 @@ namespace std {
 ```
 
 ## 概要
-`middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
+`middle`の要素が先頭、`middle-1`の要素が末尾となるように、イテレータ範囲`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
 
 
-## 要件
-`[first,last)` と `[result,result + (last - first))` の範囲は重なっていてはならない。
+## 事前条件
+- `[first,last)` と `[result,result + (last - first))` の範囲は重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sample -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/sample.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/sample.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/sample.md b/reference/algorithm/sample.md
index 4ce288a1e..3e7e12ed7 100644
--- a/reference/algorithm/sample.md
+++ b/reference/algorithm/sample.md
@@ -7,30 +7,37 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class PopulationIterator, class SampleIterator,
-            class Distance, class UniformRandomBitGenerator&amp;gt;
-  SampleIterator sample(PopulationIterator first, PopulationIterator last,
-                        SampleIterator out, Distance n,
-                        UniformRandomBitGenerator&amp;amp;&amp;amp; g);
+  template &amp;lt;class PopulationIterator,
+            class SampleIterator,
+            class Distance,
+            class UniformRandomBitGenerator&amp;gt;
+  SampleIterator
+    sample(PopulationIterator first,
+           PopulationIterator last,
+           SampleIterator out, Distance n,
+           UniformRandomBitGenerator&amp;amp;&amp;amp; g);
 }
 ```
 
 ## 概要
-範囲から指定された個数の要素をランダムに抽出する。
+イテレータ範囲`[first, last)`から指定された個数の要素をランダムに抽出する。
 
 
-## 要件
+## テンプレートパラメータ制約
 - `PopulationIterator` は `InputIterator` の要件を満たしていること
 - `SampleIterator` は `OutputIterator` の要件を満たしていること
 - `PopulationIterator`が `ForwardIterator` の要件を満たさない限り、`SampleIterator`は`RandomAccessIterator`の要件を満たさなければならない
 - `PopulationIterator`の値型は`out`に対して書き込めなければならない
 - `Distance`は整数型であること
 - `UniformRandomBitGenerator` は uniform random bit generator の要件を満たさなければならず、その戻り値の型は`Distance`型へ変換可能でなければならない
-- `out`は範囲`[first, last)`に含まれてはならない
+
+
+## 事前条件
+- `out`はイテレータ範囲`[first, last)`に含まれてはならない
 
 
 ## 効果
-範囲`[first, last)`を母集団 (population) とし、そこから[`min`](min.md)`(last - first, n)`個の要素を標本 (sample) として `out` にコピーする (`n`が入力範囲の要素数より大きい場合は、最大で入力範囲の要素数がコピーされる)。
+イテレータ範囲`[first, last)`を母集団 (population) とし、そこから[`min`](min.md)`(last - first, n)`個の要素を標本 (sample) として `out` にコピーする (`n`が入力範囲の要素数より大きい場合は、最大で入力範囲の要素数がコピーされる)。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/search.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/search.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/search.md b/reference/algorithm/search.md
index 05fd1d429..ab73e1014 100644
--- a/reference/algorithm/search.md
+++ b/reference/algorithm/search.md
@@ -71,8 +71,8 @@ namespace std {
 ## 概要
 あるシーケンスの中から、特定のサブシーケンスを探す
 
-- (1) : 範囲`[first1, last1)`内からサブシーケンス`[first2, last2)`を検索する。各要素の等値比較として`operator==`を使用する
-- (2) : 範囲`[first1, last1)`内からサブシーケンス`[first2, last2)`を検索する。各要素の等値比較として二項述語関数オブジェクト`pred`を使用する
+- (1) : イテレータ範囲`[first1, last1)`内からサブシーケンス`[first2, last2)`を検索する。各要素の等値比較として`operator==`を使用する
+- (2) : イテレータ範囲`[first1, last1)`内からサブシーケンス`[first2, last2)`を検索する。各要素の等値比較として二項述語関数オブジェクト`pred`を使用する
 - (3) : (1)の並列アルゴリズム版。第1パラメータとして実行ポリシーをとる
 - (4) : (2)の並列アルゴリズム版。第1パラメータとして実行ポリシーをとる
 - (5) : 対象となるサブシーケンスを包含する`sercher`関数オブジェクトを使用して、範囲`[first, last)`から対象のサブシーケンスを検索する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/set_difference.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/set_difference.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/set_difference.md b/reference/algorithm/set_difference.md
index ed5ad3c05..453f1e21a 100644
--- a/reference/algorithm/set_difference.md
+++ b/reference/algorithm/set_difference.md
@@ -65,11 +65,11 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲の差集合を得る
+2つのソート済み範囲`[first1, last1)`と`[first2, last2)`の差集合を得る
 
 
-## 要件
-結果の範囲は両方の入力の範囲と重なっていてはならない。
+## 事前条件
+- 結果の範囲は両方の入力の範囲と重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/set_intersection.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/set_intersection.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/set_intersection.md b/reference/algorithm/set_intersection.md
index efa0e9c61..413e91de6 100644
--- a/reference/algorithm/set_intersection.md
+++ b/reference/algorithm/set_intersection.md
@@ -65,15 +65,15 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲の積集合を得る
+2つのソート済み範囲`[first1, last1)`と`[first2, last2)`の積集合を得る
 
 
-## 要件
-結果の範囲は両方の入力の範囲と重なっていてはならない。
+## 事前条件
+- 結果の範囲は両方の入力の範囲と重なっていてはならない
 
 
 ## 効果
-２つの範囲からソート済みの intersection を構築する。つまり、両方の範囲のみにある要素の集合を構築する。
+２つの範囲からソート済みの積集合を構築する。つまり、両方の範囲のみにある要素の集合を構築する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/set_symmetric_difference.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/set_symmetric_difference.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/set_symmetric_difference.md b/reference/algorithm/set_symmetric_difference.md
index ea0bc5923..3e5cd1a0f 100644
--- a/reference/algorithm/set_symmetric_difference.md
+++ b/reference/algorithm/set_symmetric_difference.md
@@ -67,11 +67,11 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
+2つのソート済み範囲`[first1, last1)`と`[first2, last2)`の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
 
 
-## 要件
-結果の範囲は両方の入力の範囲と重なっていてはならない。
+## 事前条件
+- 結果の範囲は両方の入力の範囲と重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/set_union.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/set_union.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/set_union.md b/reference/algorithm/set_union.md
index 4aeb00708..b33c11063 100644
--- a/reference/algorithm/set_union.md
+++ b/reference/algorithm/set_union.md
@@ -65,11 +65,11 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲の和集合を得る
+2つのソート済み範囲`[first1, last1)`と`[first2, last2)`の和集合を得る
 
 
-## 要件
-結果の範囲は両方の入力の範囲と重なっていてはならない。
+## 事前条件
+- 結果の範囲は両方の入力の範囲と重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_left -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/shift_left.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/shift_left.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/shift_left.md b/reference/algorithm/shift_left.md
index cccec8be0..25010f71a 100644
--- a/reference/algorithm/shift_left.md
+++ b/reference/algorithm/shift_left.md
@@ -23,7 +23,7 @@ namespace std {
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-範囲の要素をn個だけ左にシフトさせる。
+イテレータ範囲`[first, last)`の要素をn個だけ左にシフトさせる。
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_right -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/shift_right.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/shift_right.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/shift_right.md b/reference/algorithm/shift_right.md
index f4b82ff32..06fe7d1ac 100644
--- a/reference/algorithm/shift_right.md
+++ b/reference/algorithm/shift_right.md
@@ -23,7 +23,7 @@ namespace std {
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-範囲の要素をn個だけ右にシフトさせる。
+イテレータ範囲`[first, last)`の要素をn個だけ右にシフトさせる。
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/sort.md b/reference/algorithm/sort.md
index 40a654951..0336f637b 100644
--- a/reference/algorithm/sort.md
+++ b/reference/algorithm/sort.md
@@ -37,7 +37,7 @@ namespace std {
 ```
 
 ## 概要
-範囲を並べ替える
+イテレータ範囲`[first, last)`を並べ替える
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/sort_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/sort_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/sort_heap.md b/reference/algorithm/sort_heap.md
index 749084801..1d9fdf81a 100644
--- a/reference/algorithm/sort_heap.md
+++ b/reference/algorithm/sort_heap.md
@@ -26,13 +26,16 @@ namespace std {
 ```
 
 ## 概要
-ヒープ化された範囲を並べ替える
+ヒープ化されたイテレータ範囲`[first, last)`を並べ替える
 
 
-## 要件
-- `[first,last)` は有効なヒープである必要がある。
-- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+
+
+## 事前条件
+- `[first,last)` は有効なヒープであること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_partition -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/stable_partition.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/stable_partition.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/stable_partition.md b/reference/algorithm/stable_partition.md
index 523787490..38d2af6d8 100644
--- a/reference/algorithm/stable_partition.md
+++ b/reference/algorithm/stable_partition.md
@@ -21,12 +21,12 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
+与えられたイテレータ範囲`[first, last)`を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
 
-## 要件
-- `BidirectionalIterator` は `ValueSwappable` の要件を満たしている必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `BidirectionalIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/stable_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/stable_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/stable_sort.md b/reference/algorithm/stable_sort.md
index 259e69362..0f77c873b 100644
--- a/reference/algorithm/stable_sort.md
+++ b/reference/algorithm/stable_sort.md
@@ -28,11 +28,12 @@ namespace std {
 ```
 
 ## 概要
-範囲を安定ソートで並べ替える
+イテレータ範囲`[first, last)`を安定ソートで並べ替える
 
 
-## 要件
-`RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap_ranges -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/swap_ranges.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/swap_ranges.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/swap_ranges.md b/reference/algorithm/swap_ranges.md
index b9fa83591..bee7ceb7b 100644
--- a/reference/algorithm/swap_ranges.md
+++ b/reference/algorithm/swap_ranges.md
@@ -27,16 +27,16 @@ namespace std {
 ```
 
 ## 概要
-指定された2つの範囲同士を swap する。
+指定された2つの範囲`[first1, last1)`と`[first2, first2 + (last1 - first1))`を入れ替える。
 
 
-## 効果
-0 以上 `last1 - first1` 以下のそれぞれの `n` について [`swap`](/reference/utility/swap.md)`(*(first1 + n), *(first2 + n))` を行う
+## 事前条件
+- `[first1,last1)` と `[first2,first2 + (last1 - first1))` の範囲が重なってはならない。
+- 0 以上 `last1 - first1` 未満のそれぞれの `n` について、`*(first1 + n) と *(first2 + n)` は `Swappable` でなければならない。
 
 
-## 要件
-`[first1,last1)` と `[first2,first2 + (last1 - first1))` の範囲が重なってはならない。
-0 以上 `last1 - first1` 未満のそれぞれの `n` について、`*(first1 + n) と *(first2 + n)` は `Swappable` でなければならない。
+## 効果
+0 以上 `last1 - first1` 以下のそれぞれの `n` について [`swap`](/reference/utility/swap.md)`(*(first1 + n), *(first2 + n))` を行う
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/unique.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/unique.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/unique.md b/reference/algorithm/unique.md
index 9f03493b0..8bb57b3bf 100644
--- a/reference/algorithm/unique.md
+++ b/reference/algorithm/unique.md
@@ -43,7 +43,7 @@ namespace std {
 ```
 
 ## 概要
-重複した要素を除ける。
+イテレータ範囲`[first, last)`から重複した要素を除ける。
 
 この関数は、隣り合った重複要素を除いた要素を、範囲の先頭に集める。この関数によってコンテナから直接要素が削除され、コンテナの要素数が減るようなことはない。コンテナから実際に要素を削除する場合は、この関数の戻り値として、先頭に集められた重複なし範囲の末尾の次を指すイテレータが返るため、そのイテレータを介してコンテナの`erase()`メンバ関数などを呼び出し、削除を行うこと。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/unique_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/unique_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/unique_copy.md b/reference/algorithm/unique_copy.md
index 2bd79ada8..b2b33ae23 100644
--- a/reference/algorithm/unique_copy.md
+++ b/reference/algorithm/unique_copy.md
@@ -52,7 +52,7 @@ namespace std {
 ```
 
 ## 概要
-隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`から隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/upper_bound.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/upper_bound.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/upper_bound.md b/reference/algorithm/upper_bound.md
index 025155cfe..3ce4be90a 100644
--- a/reference/algorithm/upper_bound.md
+++ b/reference/algorithm/upper_bound.md
@@ -34,7 +34,7 @@ namespace std {
 ```
 
 ## 概要
-指定された要素より大きい値が現れる最初の位置のイテレータを取得する
+イテレータ範囲`[first, last)`のうち、指定された要素より大きい値が現れる最初の位置のイテレータを取得する
 
 
 ## 要件
@@ -43,11 +43,11 @@ namespace std {
 	- `comp` は 2 引数の関数オブジェクトで、結果の型は `bool` 型に変換可能であること。また、引数に非 `const` の関数を適用しないこと。
 	- `T` は `LessThanComparable` であること。
 	- `operator&amp;lt;` または `comp` は「[狭義の弱順序](../algorithm.md#strict-weak-ordering)」であること。
-	- 範囲 `[first, last)` は `operator&amp;lt;` または `comp` を基準として昇順に並んでいること。
+	- イテレータ範囲 `[first, last)` は `operator&amp;lt;` または `comp` を基準として昇順に並んでいること。
 - C++11 から
 	- `first`、`last` は前方向イテレータの要件を満たすこと。
 	- `comp` は 2 引数の関数オブジェクトで、結果の型は `bool` 型に変換可能であること。また、引数に非 `const` の関数を適用しないこと。
-	- `[first,last)` の要素 `e` は `!(value &amp;lt; e)` または `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。  
+	- イテレータ範囲`[first,last)` の要素 `e` は `!(value &amp;lt; e)` または `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。  
 		つまり、`!(value &amp;lt; e)` または `!comp(value, e)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>