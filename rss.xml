<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-22T05:45:00.969779</updated>
  <id>31574751-f68a-472b-9713-e856fdae155e</id>

  
    <entry>
      <title>insert_or_assign -- map::insert_or_assign : オーバーロード番号を振り直し #1189</title>
      <link href="https://cpprefjp.github.io/reference/map/map/insert_or_assign.html"/>
      <id>6b1650ab2dfc76432983b5162f80c9164883ea1c:reference/map/map/insert_or_assign.md</id>
      <updated>2025-05-22T14:41:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/insert_or_assign.md b/reference/map/map/insert_or_assign.md
index 9fddf5c7e..f6c5c07df 100644
--- a/reference/map/map/insert_or_assign.md
+++ b/reference/map/map/insert_or_assign.md
@@ -14,21 +14,20 @@ template &amp;lt;class M&amp;gt;
 pair&amp;lt;iterator, bool&amp;gt;
   insert_or_assign(key_type&amp;amp;&amp;amp; k,
                    M&amp;amp;&amp;amp; obj);          // (2) C++17
+template &amp;lt;class K, class M&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  insert_or_assign(K&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);          // (3) C++26
 template &amp;lt;class M&amp;gt;
 iterator
   insert_or_assign(const_iterator hint,
                    const key_type&amp;amp; k,
-                   M&amp;amp;&amp;amp; obj);          // (3) C++17
+                   M&amp;amp;&amp;amp; obj);          // (4) C++17
 template &amp;lt;class M&amp;gt;
 iterator
   insert_or_assign(const_iterator hint,
                    key_type&amp;amp;&amp;amp; k,
-                   M&amp;amp;&amp;amp; obj);          // (4) C++17
-
-template &amp;lt;class K, class M&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt;
-  insert_or_assign(K&amp;amp;&amp;amp; k,
-                   M&amp;amp;&amp;amp; obj);          // (5) C++26
+                   M&amp;amp;&amp;amp; obj);          // (5) C++17
 template &amp;lt;class K, class M&amp;gt;
 iterator
   insert_or_assign(const_iterator hint,
@@ -44,44 +43,44 @@ iterator
 
 - (1) : `key_type`型のキーをとって挿入もしくは代入する
 - (2) : `key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
-- (3) : 挿入位置のヒントをともない、`key_type`型のキーをとって挿入もしくは代入する
-- (4) : 挿入位置のヒントをともない、`key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
-- (5) : `key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
+- (3) : `key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
+- (4) : 挿入位置のヒントをともない、`key_type`型のキーをとって挿入もしくは代入する
+- (5) : 挿入位置のヒントをともない、`key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
 - (6) : 挿入位置のヒントをともない、`key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
 
 
 ## テンプレートパラメータ制約
-- (5), (6) : `key_compare::is_transparent` が妥当な式であること
+- (3), (6) : `key_compare::is_transparent` が妥当な式であること
 
 
 ## 適格要件
-- (1)、(3)、(5)、(6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
-- (2)、(4) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (1)、(3)、(4)、(6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (2)、(5) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
 
 なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
 
 
 ## 効果
-- (1)、(3)、(5)、(6) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1)、(3)、(4)、(6) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2)、(5) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2)、(5) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 代入された場合には、`first` に代入された要素へのイテレータ、`second` に `false` が設定される。
-- (3)、(4)、(6) :
+- (4)、(5)、(6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 代入された場合には、代入された要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2)、(5) : [`emplace`](emplace.md) と同じ。
-- (3)、(4)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1)、(2)、(3) : [`emplace`](emplace.md) と同じ。
+- (4)、(5)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
-- (5), (6) :
+- (3), (6) :
     - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
     - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_emplace -- unordered_map::try_emplace: C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/try_emplace.html"/>
      <id>e8b37eff3b349680414defd2a1dbc70547111eaa:reference/unordered_map/unordered_map/try_emplace.md</id>
      <updated>2025-05-20T19:21:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/try_emplace.md b/reference/unordered_map/unordered_map/try_emplace.md
index d172d00eb..b4a3ccbd2 100644
--- a/reference/unordered_map/unordered_map/try_emplace.md
+++ b/reference/unordered_map/unordered_map/try_emplace.md
@@ -7,16 +7,37 @@
 
 ```cpp
 template &amp;lt;class... Args&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; try_emplace(const key_type&amp;amp; k, Args&amp;amp;&amp;amp;... args);            // (1)
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(const key_type&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (1) C++17
 
 template &amp;lt;class... Args&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; try_emplace(key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);                 // (2)
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(key_type&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (2) C++17
+
+template&amp;lt;class K, class... Args&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(K&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (3) C++26
 
 template &amp;lt;class... Args&amp;gt;
-iterator try_emplace(const_iterator hint, const key_type&amp;amp; k, Args&amp;amp;&amp;amp;... args);   // (3)
+iterator
+  try_emplace(const_iterator hint,
+              const key_type&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (4) C++17
 
 template &amp;lt;class... Args&amp;gt;
-iterator try_emplace(const_iterator hint, key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);        // (4)
+iterator
+  try_emplace(const_iterator hint,
+              key_type&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (5) C++17
+
+template&amp;lt;class K, class... Args&amp;gt;
+iterator
+  try_emplace(const_iterator hint,
+              K&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (6) C++26
 ```
 * pair[link /reference/utility/pair.md]
 
@@ -26,46 +47,52 @@ iterator try_emplace(const_iterator hint, key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);
 
 引数 `hint` は、`k` を検索する際のヒントに使用される。（が、実際に使用されることはないものと思われる。[`emplace_hint`](emplace_hint.md) の備考を参照）
 
+- (1) : キーをコピーし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (2) : キーをムーブし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (3) : `key_type`型と比較可能なキーを転送し、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (4) : 検索位置のヒントを受け取ってキーをコピーし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (5) : 検索位置のヒントを受け取ってキーをムーブし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (6) : 検索位置のヒントを受け取って`key_type`型と比較可能なキーをムーブし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+
 
 ## テンプレートパラメータ制約
-- (1)、(3) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
-- (2)、(4) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
+- (1)、(3)、(4)、(6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
+- (2)、(5) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
+- (3)、(6) :
+    - `key_compare::is_transparent` が妥当な式であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`であること
 
 なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
 
 
 ## 効果
-- (1)、(3) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1)、(3)、(4)、(6) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2)、(5) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 挿入されなかった場合には、`first` に `k` と等価のキーを持つ既存の要素へのイテレータ、`second` に `false` が設定される。
-- (3)、(4) :
+- (4)、(5)、(6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 挿入されなかった場合には、`k` と等価のキーを持つ既存の要素へのイテレータを返す。
 
 
 ## 計算量
 - (1)、(2) : [`emplace`](emplace.md) と同じ。
-- (3)、(4) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (4)、(5) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
 - 概要に記載されているように、本メンバ関数は指定されたキーと等価の要素が既に存在する場合には、引数に副作用が発生しない。  
-    一方、[`emplace`](emplace.md)、[`emplace_hint`](emplace_hint.md)、[`insert`](insert.md) にはそのような規定は無く、挿入がされなかった場合でも引数に副作用（引数からのムーブ）が発生してしまう可能性があるため、注意が必要である。
-
+    - 一方、[`emplace`](emplace.md)、[`emplace_hint`](emplace_hint.md)、[`insert`](insert.md) にはそのような規定は無く、挿入がされなかった場合でも引数に副作用（引数からのムーブ）が発生してしまう可能性があるため、注意が必要である。
 - 規格にはこの関数の例外安全性についての記載が無いが、[`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) と等価と考えて問題ないと思われる。
-
 - 規格にはこの関数が呼ばれた後のイテレータや要素へのポインタ・参照の有効性についての記載が無いが、[`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) と等価と考えて問題ないと思われる。
-
-- このメンバ関数の[`機能テストマクロ`](/lang/cpp17/feature_test_macros.md)は以下の通り。
-
-    | マクロ名                              | 値       |
-    |---------------------------------------|----------|
-    | `__cpp_lib_unordered_map_try_emplace` | `201411` |
+- (3), (6) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -147,3 +174,5 @@ key = two, value = 2, is inserted = false, is empty = false
 - [N4006 An improved emplace() for unique-key maps](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html)
 - [N4240 Improved insertion interface for unique-key maps (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html)
 - [N4279 Improved insertion interface for unique-key maps (Revision 2.3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html)
+- [P2363R5: Extending associative containers with the remaining heterogeneous overloads](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- set::insert : C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/set/set/insert.html"/>
      <id>91f56d04fed8799683fe403a74714e85344256cb:reference/set/set/insert.md</id>
      <updated>2025-05-19T16:16:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/insert.md b/reference/set/set/insert.md
index c572100ea..5310bb901 100644
--- a/reference/set/set/insert.md
+++ b/reference/set/set/insert.md
@@ -5,21 +5,27 @@
 * function[meta id-type]
 
 ```cpp
-pair&amp;lt;iterator,bool&amp;gt; insert(const value_type&amp;amp; x);               // (1)
-pair&amp;lt;iterator,bool&amp;gt; insert(value_type&amp;amp;&amp;amp; y);                    // (2) C++11
+pair&amp;lt;iterator,bool&amp;gt; insert(const value_type&amp;amp; x);           // (1) C++03
+pair&amp;lt;iterator,bool&amp;gt; insert(value_type&amp;amp;&amp;amp; y);                // (2) C++11
 
-iterator insert(iterator position, const value_type&amp;amp; x);       // (3) C++03
-iterator insert(const_iterator position, const value_type&amp;amp; x); // (3) C++11
+template &amp;lt;class K&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt; insert(K&amp;amp;&amp;amp; x);                        // (3) C++26
 
-iterator insert(const_iterator position, value_type&amp;amp;&amp;amp; y);      // (4) C++11
+iterator insert(iterator hint, const value_type&amp;amp; x);       // (4) C++03
+iterator insert(const_iterator hint, const value_type&amp;amp; x); // (4) C++11
+
+iterator insert(const_iterator hint, value_type&amp;amp;&amp;amp; y);      // (5) C++11
+
+template &amp;lt;class K&amp;gt;
+iterator insert(const_iterator hint, K&amp;amp;&amp;amp; x);               // (6) C++26
 
 template &amp;lt;class InputIterator&amp;gt;
-void insert(InputIterator first, InputIterator last);          // (5)
+void insert(InputIterator first, InputIterator last);      // (7) C++03
 
-void insert(initializer_list&amp;lt;value_type&amp;gt; init);                // (6)
+void insert(initializer_list&amp;lt;value_type&amp;gt; init);            // (8) C++03
 
-insert_return_type insert(node_type&amp;amp;&amp;amp; nh);                      // (7) C++17
-iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (8) C++17
+insert_return_type insert(node_type&amp;amp;&amp;amp; nh);                      // (9) C++17
+iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (10) C++17
 ```
 * pair[link /reference/utility/pair.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
@@ -29,42 +35,55 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (8) C++17
 
  `set` コンテナは重複した値を許さないため、挿入操作はそれぞれの要素が他のコンテナ内の既存要素と同じ値かどうかをチェックし、同じ要素がすでにあれば挿入されない。`multiset`の場合には、同じ値の要素でも挿入される。
 
-
 - (1) : 新たな要素`x`をコピー挿入する
 - (2) : 新たな要素`y`をムーブ挿入する
-- (3) : 新たな要素`x`をコピー挿入する。`position`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
-- (4) : 新たな要素`y`をムーブ挿入する。`position`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
-- (5) : イテレータ範囲`[first, last)`の要素を挿入する
-- (6) : 初期化子リスト`init`の要素を挿入する
-- (7) : `nh`が空の場合、効果はない。
+- (3) : `value_type`に変換可能な`Key`型の新たな要素`x`を転送して挿入する
+- (4) : 新たな要素`x`をコピー挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (5) : 新たな要素`y`をムーブ挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (6) : `value_type`に変換可能な`Key`型の新たな要素`x`を転送して挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (7) : イテレータ範囲`[first, last)`の要素を挿入する
+- (8) : 初期化子リスト`init`の要素を挿入する
+- (9) : `nh`が空の場合、効果はない。
 それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
-- (8) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。
+- (10) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。
 それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。 `nh.key()`と同等のキーの要素を指すイテレータを常に返す。要素は、`hint`の直前の位置のできるだけ近くに挿入される。
 
 
+## テンプレートパラメータ制約
+- (3), (6) :
+    - `key_compare::is_transparent` が妥当な式であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`であること
+    - `value_type`が[`std::forward`](/reference/utility/forward.md)`&amp;lt;K&amp;gt;(x)`によって直接構築可能であること
+
+
 ## 戻り値
-- (1), (2) : `first` に新しく挿入された要素またはすでに `set` に格納されていた同じ値の要素を指すイテレータを設定する。`second` には、要素が挿入されたときに `true` を、同じ値の要素が存在したときに `false` を設定する。
-- (3), (4) : 新しく挿入された要素またはすでに `set` に格納されていた同じ値の要素を指すイテレータを返す。
-- (5), (6) : なし
-- (7) : [`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
+- (1), (2), (3) : `first` に新しく挿入された要素またはすでに `set` に格納されていた同じ値の要素を指すイテレータを設定する。`second` には、要素が挿入されたときに `true` を、同じ値の要素が存在したときに `false` を設定する。
+- (4), (5), (6) : 新しく挿入された要素またはすでに `set` に格納されていた同じ値の要素を指すイテレータを返す。
+- (7), (8) : なし
+- (9) : [`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
     - 挿入された場合には、空の[ノードハンドル](/reference/node_handle/node_handle.md)。
     - 挿入されなかった場合には、`nh`の値である。 
-- (8) : `nh`が空の場合、`(*this).end()`を返す。そうではない場合、`nh`と等価のキーの要素を指すイテレータを常に返す。
+- (10) : `nh`が空の場合、`(*this).end()`を返す。そうではない場合、`nh`と等価のキーの要素を指すイテレータを常に返す。
 
 
 ## 計算量
-- (1), (2) : 対数時間
-- (3), (4) : 一般に対数時間だが、`x` または `y` が `position` が指す要素の直前に挿入された場合は償却定数時間
-- (5), (6) : 一般に N log(size + N)
+- (1), (2), (3) : 対数時間
+- (4), (5), (6) : 一般に対数時間だが、`x` または `y` が `hint` が指す要素の直前に挿入された場合は償却定数時間
+- (7), (8) : 一般に N log(size + N)
     - ※ ここで `N` は `first` と `last` の間の距離であり `size` は挿入前のコンテナの [`size()`](size.md)
-- (7) : 対数時間
-- (8) : 一般に対数時間だが、指定された新たな要素が `hint` が指す要素の直前に挿入された場合は償却定数時間。
+- (9) : 対数時間
+- (10) : 一般に対数時間だが、指定された新たな要素が `hint` が指す要素の直前に挿入された場合は償却定数時間。
 
 
 ## 備考
 - これらの関数が呼ばれた後も、当該コンテナ内の要素を指す参照やイテレータは無効にはならない。  
 	なお、規格書に明確な記載は無いが、当該コンテナ内の要素を指すポインタも無効にはならない。
-- 内部的に `set` コンテナは、コンストラクト時に指定された比較オブジェクトによって要素を下位から上位へとソートして保持する。 (7), (8) の場合、要素はコピーもムーブもされない。
+- 内部的に `set` コンテナは、コンストラクト時に指定された比較オブジェクトによって要素を下位から上位へとソートして保持する。 (9), (10) の場合、要素はコピーもムーブもされない。
+- (3), (6) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
 
 ## 例
 ```cpp example
@@ -112,4 +131,6 @@ int main ()
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
 - [N2679 Initializer Lists for Standard Containers(Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2679.pdf)
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-    - (7), (8)経緯となる提案文書
\ No newline at end of file
+    - C++17で導入されたノード挿入(9), (10)の経緯となる提案文書
+- [P2363R5: Extending associative containers with the remaining heterogeneous overloads](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_emplace -- map::try_emplace : 要件を整理 #1189</title>
      <link href="https://cpprefjp.github.io/reference/map/map/try_emplace.html"/>
      <id>0036d1d6b893ee18fda33535962addd83a622a66:reference/map/map/try_emplace.md</id>
      <updated>2025-05-19T16:09:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/try_emplace.md b/reference/map/map/try_emplace.md
index 498af971b..c6b4b178b 100644
--- a/reference/map/map/try_emplace.md
+++ b/reference/map/map/try_emplace.md
@@ -57,10 +57,10 @@ iterator
 ## テンプレートパラメータ制約
 - (1)、(3)、(5)、(6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
 - (2)、(4) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
-- (5), (6) : `key_compare::is_transparent` が妥当な式であること
-- (5) : 以下のすべてを満たすこと：
-    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`
-    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`
+- (5)、(6) :
+    - `key_compare::is_transparent` が妥当な式であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`であること
 
 なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_emplace -- map::try_emplace : 要件を修正 #1189</title>
      <link href="https://cpprefjp.github.io/reference/map/map/try_emplace.html"/>
      <id>3175722cafabd80cce386bdfb2de0656b1ac46b8:reference/map/map/try_emplace.md</id>
      <updated>2025-05-18T14:59:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/try_emplace.md b/reference/map/map/try_emplace.md
index 7bb94f5dd..498af971b 100644
--- a/reference/map/map/try_emplace.md
+++ b/reference/map/map/try_emplace.md
@@ -55,16 +55,19 @@ iterator
 
 
 ## テンプレートパラメータ制約
-- (1)、(3)、(5) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
-- (2)、(4)、(6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
+- (1)、(3)、(5)、(6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
+- (2)、(4) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
 - (5), (6) : `key_compare::is_transparent` が妥当な式であること
+- (5) : 以下のすべてを満たすこと：
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`
 
 なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
 
 
 ## 効果
-- (1)、(3)、(5) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4)、(6) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1)、(3)、(5)、(6) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2)、(4) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>