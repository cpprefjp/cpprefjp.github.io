<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-26T14:53:58.960298</updated>
  <id>fb128bc1-d76a-4466-afdc-2232baf5aba2</id>

  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- P0784R7 : 追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>ad0646b0e078c6894772d1f63968ee54458d3baf:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-26T17:18:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index fd5182681..f43fcc721 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -155,7 +155,7 @@ constexpr void f() {
 
 `std::allocator/std::allocator_traits`では`new/delete`式とは異なり、メモリの確保・解放（[`allocate`](/reference/memory/allocator/allocate.md)/[`deallocate`](/reference/memory/allocator/deallocate.md)）とその領域へのオブジェクト構築・破棄（[`construct`](/reference/memory/allocator_traits/construct.md)/[`destroy`](/reference/memory/allocator_traits/destroy.md)）の操作が複合していない。オブジェクト構築・破棄においては*placement new*と*pseudo-destructor call*が必要となるが、*placement new*はポインタの再解釈が必要となることから許可されず、そのために不必要であるので*pseudo-destructor call*も許可されない。
 
-代わりに、*placement new*を行うライブラリ機能である[`construct_at`](/reference/memory/construct.md.nolink)を追加し、*pseudo-destructor call*を行う[`destroy_at`](/reference/memory/destroy_at.md)と共に`constexpr`を付加し定数式で使用可能とする。これによって、ポインタ再解釈を回避しつつ*placement new*と*pseudo-destructor call*が定数式で使用可能となる。
+代わりに、*placement new*を行うライブラリ機能である[`construct_at`](/reference/memory/construct.md.nolink)を追加し、*pseudo-destructor call*を行う[`destroy_at`](/reference/memory/destroy_at.md)と共に`constexpr`を付加し定数式で使用可能とする。これらの関数は`void*`ではなく`T*`を取るため、これによってポインタ再解釈を回避しつつ*placement new*と*pseudo-destructor call*が定数式で使用可能となる。
 
 そして、`std::allocator_traits`の`construct`と`destroy`は`construct_at/destroy_at`を呼び出して処理を行うように変更される。なお、これによって実行時の振る舞いが変化することはない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stacktrace_entry -- stacktrace_entry : デストラクタ名のコピペミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/stacktrace/stacktrace_entry.html"/>
      <id>6073b3654bda9980d72c9dd0216737f5270da6b1:reference/stacktrace/stacktrace_entry.md</id>
      <updated>2021-05-26T16:31:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stacktrace/stacktrace_entry.md b/reference/stacktrace/stacktrace_entry.md
index 73e0ded6b..6e0f5e375 100644
--- a/reference/stacktrace/stacktrace_entry.md
+++ b/reference/stacktrace/stacktrace_entry.md
@@ -20,7 +20,7 @@ namespace std {
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
 | [`(constructor)`](stacktrace_entry/op_constructor.md.nolink) | コンストラクタ | C++23 |
-| `~basic_stacktrace();` | デストラクタ | C++23 |
+| `~stacktrace_entry();` | デストラクタ | C++23 |
 | [`operator=`](stacktrace_entry/op_assign.md.nolink) | 代入演算子 | C++23 |
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- 微追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>2cbb478b667ef0d92b5981e72d29e10f77c800bc:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-26T15:30:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index a57a4fb8a..fd5182681 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -321,7 +321,7 @@ int main() {
 
 `std::unique_ptr`ではそれ自身の`const`性が内部のポインタの参照するオブジェクトまで伝播しないため、コンパイル時に確保されたメモリ領域を参照するような`std::unique_ptr`からは、可変な参照を取得できてしまう。上記例のように`std::unique_ptr`がネストしていれば、そのような領域を`delete`することもできてしまっていた。
 
-`std::mark_immutable_if_constexpr()`によるアプローチを標準化委員会が嫌ったことと、2つ目の問題の解決が簡単ではなかった（時間がかかり得た）事から、コンパイル時に確保したメモリを実行時に持ち越すことについてはC++20への導入を見送ることとなった。
+これらの問題について、`std::mark_immutable_if_constexpr()`によるアプローチを標準化委員会が嫌ったことと、2つ目の問題の解決が簡単ではなかった（時間がかかり得た）事から、コンパイル時に確保したメモリを実行時に持ち越すことについてはC++20への導入を見送ることとなった。
 
 ## 関連項目
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- P0784R7 : 検討された他の選択肢追記 #688</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>a7a91d5b6953171ce207a3a35419a9d61efe2855:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-26T15:15:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 1cd12f507..a57a4fb8a 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -261,7 +261,67 @@ std::vector&amp;lt;std::metainfo&amp;gt; args = std::meta::get_template_args(reflexpr(T));
 これらの流れを受けて、`std::vector`と`std::string`を定数式で使用可能とするために、その最大の障壁となっていたメモリの動的確保と解放周りの機能が定数式で使用可能となった。
 
 ## 検討されたほかの選択肢
-(執筆中)
+
+当初検討されていた仕様では、コンパイル時に確保したメモリ領域を実行時に持ち越すことが可能だった。そのようなメモリ領域の確保と解放はクラス型の内部で閉じている必要はあったが、その条件を満たせば静的ストレージに昇格され実行時環境から参照できるようになる。
+
+しかし、当初のアプローチには2つの問題があった。
+
+実行時に持ち越されるメモリ領域を管理するクラスであってもそのデストラクタでその領域を解放している事が求められていたが、それはコンパイラによるテスト要件であり実行時に領域を持ち越そうとする時、実際にそのデストラクタがコンパイル時に呼ばれることはない。しかしその場合、静的ストレージに昇格される領域の内容はいつどの時点のものが保持されるのかが不透明となる。
+
+当初の仕様ではそれに対処するために、`std::mark_immutable_if_constexpr()`という関数を導入し、この関数に領域へのポインタを渡して呼び出すことでコンパイラへのマーカーとし、呼ばれた時点でのメモリ領域を実行時に持ち越すアプローチをとっていた。
+
+```cpp
+template&amp;lt;typename T&amp;gt;
+struct sample {
+  std::allocator&amp;lt;T&amp;gt; m_alloc;
+  T* m_p;
+  size_t m_size;
+
+  // 非トリビアルconstexprコンストラクタでメモリ領域を確保
+  template&amp;lt;size_t N&amp;gt;
+  constexpr sample(T(&amp;amp;p)[N])
+    : m_alloc{}
+    , m_p{m_alloc.allocate(N)}
+    , m_size{N}
+  {
+    for(size_t i = 0; i &amp;lt; N; ++i) {
+      std::construct_at(m_p + i, p[i]);
+    }
+
+    // 実行時に持ち越す領域をコンパイラに伝える
+    // ここ以降は確保した領域は不変
+    std::mark_immutable_if_constexpr(m_p);
+  }
+
+  // constexprデストラクタでメモリ領域を解放
+  constexpr ~sample() {
+    for(size_t i = 0; i &amp;lt; N; ++i) {
+      std::destroy_at(m_p + i);
+    }
+    m_alloc.deallocate(m_p, m_size);
+  }
+}
+
+constexpr sample&amp;lt;char&amp;gt; str{&amp;#34;Hello.&amp;#34;};
+// 実行時、strは&amp;#34;Hello&amp;#34;を保持する静的配列を参照するようになる
+```
+
+2つ目の問題は、コンパイル時に確保された領域は実行時に`const`であり書き換えられてはならないが、クラス型の`const`伝播の問題から書き換えが可能となってしまっていたことである。
+
+```cpp
+// 当初の仕様ではOK（unique_ptrがconstexpr対応した場合）
+constexpr std::unique_ptr&amp;lt;std::unique_ptr&amp;lt;int&amp;gt;&amp;gt; uui 
+  = std::make_unique&amp;lt;std::unique_ptr&amp;lt;int&amp;gt;&amp;gt;(std::make_unique&amp;lt;int&amp;gt;());
+
+int main() {
+  std::unique_ptr&amp;lt;int&amp;gt;&amp;amp; ui = *uui; // これができてしまう
+  ui.reset(); // 静的ストレージの領域をdeleteする？
+}
+```
+
+`std::unique_ptr`ではそれ自身の`const`性が内部のポインタの参照するオブジェクトまで伝播しないため、コンパイル時に確保されたメモリ領域を参照するような`std::unique_ptr`からは、可変な参照を取得できてしまう。上記例のように`std::unique_ptr`がネストしていれば、そのような領域を`delete`することもできてしまっていた。
+
+`std::mark_immutable_if_constexpr()`によるアプローチを標準化委員会が嫌ったことと、2つ目の問題の解決が簡単ではなかった（時間がかかり得た）事から、コンパイル時に確保したメモリを実行時に持ち越すことについてはC++20への導入を見送ることとなった。
 
 ## 関連項目
 
@@ -281,4 +341,4 @@ std::vector&amp;lt;std::metainfo&amp;gt; args = std::meta::get_template_args(reflexpr(T));
 - [P0784R6 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r6.html)
 - [P0784R7 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html)
 - [動的メモリー確保 - 江添亮の入門C++](https://ezoeryou.github.io/cpp-intro/#動的メモリー確保)
-
+- [P1974R0 Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>宣言時のメンバ初期化を持つ型の集成体初期化を許可 -- C++14-宣言時のメンバ初期化を持つ型の集成体初期化を許可: プロポーザルNoのリンク追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp14/brace_elision_in_array_temporary_initialization.html"/>
      <id>8febff5d2c5021f81e4f7baa9cbfc06d502ddc51:lang/cpp14/brace_elision_in_array_temporary_initialization.md</id>
      <updated>2021-05-26T14:36:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp14/brace_elision_in_array_temporary_initialization.md b/lang/cpp14/brace_elision_in_array_temporary_initialization.md
index 8badda843..1e6a21d39 100644
--- a/lang/cpp14/brace_elision_in_array_temporary_initialization.md
+++ b/lang/cpp14/brace_elision_in_array_temporary_initialization.md
@@ -34,4 +34,5 @@ int x[2][2] = {1, 2, 3, 4};
 - [CWG Issue 1270. Brace elision in array temporary initialization](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1270)
 - [vector/arrayとUniform initialization+Initializer list - yohhoyの日記](http://d.hatena.ne.jp/yohhoy/20120724/p1)
 - [initializer-listによるaggregate初期化の制約緩和 - yohhoyの日記](http://d.hatena.ne.jp/yohhoy/20131116/p1)
+- [N3653 - Member initializers and aggregates](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653.html)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akiko Kawai</name>
        <email>haruka.sao@gmail.com</email>
      </author>
    </entry>
  
</feed>