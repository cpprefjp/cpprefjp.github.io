<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-17T07:30:20.186605</updated>
  <id>c78721cb-f2b7-4097-b1d1-ca0d901bc633</id>

  
    <entry>
      <title>hash -- functinoal/hash: 関連項目に特殊化版へのリンク列挙</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>bc842eccb3ea7ec2195a7d339994b4d9af21d4ea:reference/functional/hash.md</id>
      <updated>2023-02-17T16:25:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index f2bcb7730..f1b626178 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -38,7 +38,7 @@ namespace std {
 
 このクラスはそのものにデフォルトの定義は存在せず、ユーザーが任意の型で特殊化する際の要件を定義する。`hash`クラステンプレートを特殊化する場合、以下に記述するメンバ関数を持たせる必要がある。
 
-なお、`&amp;lt;functional&amp;gt;`ヘッダでは、以下の特殊化を提供する：
+`&amp;lt;functional&amp;gt;`ヘッダでは、以下の特殊化を提供する。これ以外の特殊化は、対象型を定義する各種ヘッダファイルにて提供される：
 
 | 型                   | 対応バージョン |
 |----------------------|----------------|
@@ -167,6 +167,26 @@ found : 3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+
+## 関連項目
+
+| ヘッダ | 特殊化対象 |
+|--------|------------|
+| [`&amp;lt;coroutine&amp;gt;`](/reference/coroutine.md) | [`std::coroutine_handle`](/reference/coroutine/coroutine_handle.md) |
+| [`&amp;lt;bitset&amp;gt;`](/reference/bitset.md) | [`std::bitset`](/reference/bitset/bitset.md) |
+| [`&amp;lt;filesystem&amp;gt;`](/reference/filesystem.md) | [`std::filesystem::path`](/reference/filesystem/path.md) |
+| [`&amp;lt;optional&amp;gt;`](/reference/optional.md) | [`std::optional`](/reference/optional/optional.md) |
+| [`&amp;lt;memory&amp;gt;`](/reference/memory.md) | [`std::shared_ptr`](/reference/memory/shared_ptr.md), [`std::unique_ptr`](/reference/memory/unique_ptr.md) |
+| [`&amp;lt;stacktrace&amp;gt;`](/reference/stacktrace.md) | [`std::basic_backtrace`](/reference/stacktrace/basic_stacktrace.md), [`std::stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md) |
+| [`&amp;lt;string&amp;gt;`](/reference/string.md) | `std::string`など |
+| [`&amp;lt;string_view&amp;gt;`](/reference/string_view.md) | `std::string_view`など |
+| [`&amp;lt;system_error&amp;gt;`](/reference/system_error.md) | [`std::error_code`](/reference/system_error/error_code.md), [`std::error_condition`](/reference/system_error/error_condition.md) |
+| [`&amp;lt;thread&amp;gt;`](/reference/thread.md) | [`std::thread:id`](/reference/thread/thread.md) |
+| [`&amp;lt;typeindex&amp;gt;`](/reference/typeindex.md) | [`std::type_index`](/reference/typeindex/type_index.md) |
+| [`&amp;lt;variant&amp;gt;`](/reference/variant.md) | [`std::variant`](/reference/variant/variant.md), [`std::monostate`](/reference/variant/monostate.md) |
+| [`&amp;lt;vector&amp;gt;`](/reference/vector.md) | [`std::vector&amp;lt;bool&amp;gt;`](/reference/vector/vector.md) |
+
+
 ## 参照
 - [ハッシュ関数 - Wikipedia](https://ja.wikipedia.org/wiki/ハッシュ関数)
 - [LWG 2148 - Hashing enums should be supported directly by std::hash](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functional/hash: メンバ型is_transparent 説明文を見直し</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>16cab03355668b5b677440ac2a954a3d72817aa2:reference/functional/hash.md</id>
      <updated>2023-02-17T14:51:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index a2df8a8dd..f2bcb7730 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -80,7 +80,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt; 標準ライブラリの`hash`クラスの特殊化がこの型を持つかは未規定。&amp;lt;br/&amp;gt; この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
+| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt;この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functional/hash: 透過的ハッシュ/等値比較の例示コードを改善</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>5415e29dfd912b953b8249e2d1b51dd18f57c4b5:reference/functional/hash.md</id>
      <updated>2023-02-17T14:13:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index 09717118b..a2df8a8dd 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -123,16 +123,25 @@ int main()
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;unordered_map&amp;gt;
 #include &amp;lt;string&amp;gt;
+#include &amp;lt;string_view&amp;gt;
+
+struct string_hash {
+  using is_transparent = void;
+  // string/string_view/const char*共用ハッシュ計算
+  size_t operator()(std::string_view sv) const {
+    return std::hash&amp;lt;std::string_view&amp;gt;{}(sv);
+  }
+};
 
 int main()
 {
-  std::unordered_map&amp;lt;std::string, int&amp;gt; um = {
+  std::unordered_map&amp;lt;std::string, int, string_hash, std::equal_to&amp;lt;&amp;gt;&amp;gt; um = {
     {&amp;#34;Alice&amp;#34;, 3},
     {&amp;#34;Bob&amp;#34;, 1},
     {&amp;#34;Carol&amp;#34;, 4}
   };
 
-  // std::equal_to&amp;lt;std::string&amp;gt;とstd::hash&amp;lt;std::string&amp;gt;がis_transparent型を持つ場合、
+  // string_hashおよびstd::equal_to&amp;lt;&amp;gt;はいずれもメンバ型にis_transparentを持つため、
   // find()などの検索関数に引数を渡す場合に、std::string一時オブジェクトが作られない
   auto it = um.find(&amp;#34;Alice&amp;#34;);
   if (it != um.end()) {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>畳み込み式 -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/folding_expressions.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:lang/cpp17/folding_expressions.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/folding_expressions.md b/lang/cpp17/folding_expressions.md
index 91dfaec80..a27b9224f 100644
--- a/lang/cpp17/folding_expressions.md
+++ b/lang/cpp17/folding_expressions.md
@@ -200,16 +200,16 @@ template&amp;lt;typename BinaryFunction&amp;gt; struct empty_fold
 
 この方法は可能な限りジェネリックであるが、以下のような問題があった:
 
-* 空のパラメータパックは型付けされていないが、返り値の型は他の型に文脈的に変換可能である (暗黙の型変換につながり得る)
+* 空のパラメータパックは型付けされていないが、戻り値の型は他の型に文脈的に変換可能である (暗黙の型変換につながり得る)
 * テンプレート特殊化だけのために関数をオブジェクトしなければならない
 * サポートする演算子と等価な関数オブジェクト間のマッピングを用意しなければならない
 
 結局のところこれは問題の解決にはつながらず、負担も大きいことから採用されなかった。
 
 
-##### 返り値の型推論
+##### 戻り値の型推論
 
-可能であれば空の畳み込みから返り値の型推論を行い、そうでなければプログラムを不適格とする。  
+可能であれば空の畳み込みから戻り値の型推論を行い、そうでなければプログラムを不適格とする。  
 例えば以下の例では `std::string` に推論する:
 ```cpp
 auto res =  (std::string(args) + ...);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cmath.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index a0b536acc..6104a3c3a 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -62,11 +62,11 @@
 	なお、C++11 の記載にある無条件のキャストは規格のバグとされたため、C++11 であってもスコープ付き列挙型や explicit な変換演算子のあるクラス型に、上記規則にある無条件のキャストが適用されると想定すべきではない。  
 	（[LWG 2086. Overly generic type support for math functions](http://cplusplus.github.io/LWG/lwg-defects.html#2086) 参照）
 
-	各関数の個別ページでは、上記のオーバーロード関数をコードで示す際には、引数や返値の型を斜体で示す。
+	各関数の個別ページでは、上記のオーバーロード関数をコードで示す際には、引数や戻り値の型を斜体で示す。
     ```cpp
     Integral      // 任意の整数型
     Arithmetic    // 任意の算術型
-    Promoted      // 決定された返値型
+    Promoted      // 決定された戻り値型
     ```
     * Integral[italic]
     * Arithmetic[italic]
@@ -447,8 +447,8 @@ NaN を返さなければならないが定義域エラーを報告してはな
 | [`FP_FAST_FMA`](cmath/fp_fast_fma.md)   | `double` 型の `fma` 関数がより高速な実装であるか | C++11 |
 | [`FP_FAST_FMAF`](cmath/fp_fast_fmaf.md) | `float` 型の `fma` 関数がより高速な実装であるか  | C++11 |
 | [`FP_FAST_FMAL`](cmath/fp_fast_fmal.md) | `long double` 型の `fma` 関数がより高速な実装であるか | C++11 |
-| [`FP_ILOGB0`](cmath/fp_ilogb0.md)       | `ilogb(0)` の返値を表す整数定数式 | C++11 |
-| [`FP_ILOGBNAN`](cmath/fp_ilogbnan.md)   | `ilogb(NaN)` の返値を表す整数定数式 | C++11 |
+| [`FP_ILOGB0`](cmath/fp_ilogb0.md)       | `ilogb(0)` の戻り値を表す整数定数式 | C++11 |
+| [`FP_ILOGBNAN`](cmath/fp_ilogbnan.md)   | `ilogb(NaN)` の戻り値を表す整数定数式 | C++11 |
 | [`MATH_ERRNO`](cmath/math_errno.md)             | 数学ライブラリ内で`errno`にエラーが設定されたかを表す整数定数 | C++11 |
 | [`MATH_ERREXCEPT`](cmath/math_errexcept.md)     | 数学ライブラリ内で浮動小数点例外が発生したかを表す整数定数 | C++11 |
 | [`math_errhandling`](cmath/math_errhandling.md) | `&amp;lt;cmath&amp;gt;` 内の関数がエラーをどのように取り扱うかを表すマクロ | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>beta -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cmath/beta.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cmath/beta.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/beta.md b/reference/cmath/beta.md
index a6750ca45..ef26eca01 100644
--- a/reference/cmath/beta.md
+++ b/reference/cmath/beta.md
@@ -64,7 +64,7 @@ beta(2, 4)      = 0.05
 GCC 7.1.0–8.0.0 では `beta` は [`exp`](exp.md) と [`lgamma`](lgamma.md) を用いて
 $ |\mathrm{B}(x, y)| = \exp(\ln |\Gamma(x) \Gamma(y) / \Gamma(x + y)|)) $
 を計算する。
-`x &amp;lt; 0 || y &amp;lt; 0` でも定義域エラーを報告せずに値を返すが、返り値は必ず正になる。
+`x &amp;lt; 0 || y &amp;lt; 0` でも定義域エラーを報告せずに値を返すが、戻り値は必ず正になる。
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>FP_ILOGB0 -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fp_ilogb0.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cmath/fp_ilogb0.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fp_ilogb0.md b/reference/cmath/fp_ilogb0.md
index c36b8665b..98b04c263 100644
--- a/reference/cmath/fp_ilogb0.md
+++ b/reference/cmath/fp_ilogb0.md
@@ -9,7 +9,7 @@
 * implementation_defined[italic]
 
 ## 概要
-`FP_ILOGB0` は、[`std::ilogb`](ilogb.md)`(0)` の返り値を表す整数定数式である。
+`FP_ILOGB0` は、[`std::ilogb`](ilogb.md)`(0)` の戻り値を表す整数定数式である。
 
 [`INT_MIN`](/reference/climits/int_min.md) と `-`[`INT_MAX`](/reference/climits/int_max.md) のうち少なくとも片方と等しい値でなければならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>FP_ILOGBNAN -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fp_ilogbnan.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cmath/fp_ilogbnan.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fp_ilogbnan.md b/reference/cmath/fp_ilogbnan.md
index 66243c1ef..1e45da9ec 100644
--- a/reference/cmath/fp_ilogbnan.md
+++ b/reference/cmath/fp_ilogbnan.md
@@ -9,7 +9,7 @@
 * implementation_defined[italic]
 
 ## 概要
-`FP_ILOGBNAN` は、[`std::ilogb()`](ilogb.md) に `NaN` を渡したときの返り値を表す整数定数式である。
+`FP_ILOGBNAN` は、[`std::ilogb()`](ilogb.md) に `NaN` を渡したときの戻り値を表す整数定数式である。
 
 [`INT_MIN`](/reference/climits/int_min.md) と [`INT_MAX`](/reference/climits/int_max.md) いずれかと等しい値でなければならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>size_t -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cstddef/size_t.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cstddef/size_t.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstddef/size_t.md b/reference/cstddef/size_t.md
index f669a2d23..55cd26b59 100644
--- a/reference/cstddef/size_t.md
+++ b/reference/cstddef/size_t.md
@@ -13,7 +13,7 @@ namespace std {
 `size_t`は、オブジェクトのバイト数を表現できる程度に十分に大きい符号なし整数型である。
 C++03まではC言語と同じく「`sizeof`演算子によって返される符号なし整数型」と規定されていた。
 
-オブジェクトのバイト数（例えば[`malloc`](/reference/cstdlib.md)の引数）やコンテナの要素数（例えば[`std::size()`](/reference/iterator/size.md)の返り値）を表現するために用いられる。
+オブジェクトのバイト数（例えば[`malloc`](/reference/cstdlib.md)の引数）やコンテナの要素数（例えば[`std::size()`](/reference/iterator/size.md)の戻り値）を表現するために用いられる。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_from_tuple -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/tuple/make_from_tuple.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/tuple/make_from_tuple.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/make_from_tuple.md b/reference/tuple/make_from_tuple.md
index b11772dab..5aca1111f 100644
--- a/reference/tuple/make_from_tuple.md
+++ b/reference/tuple/make_from_tuple.md
@@ -25,7 +25,7 @@ namespace std {
 
 また、型`T`の初期化はそのコンストラクタで行われ集成体初期化は考慮されない。つまり、`Tuple`に含まれる型が空かただ一つの`T`でない場合、型`T`は集成体（aggregate）であってはならない（C++17のみ、C++20以降はok）。
 
-更に、C++23以降は`make_from_tuple`の返り値が参照である場合でダングリング参照を生成しないために、`make_from_tuple`の内部で`T`が構築される際に、`Tuple`から取得されるオブジェクト（参照の初期化であるので、`Tuple`のサイズは1である必要がある）の寿命が延長されないことも要求され、これを満たさない場合はコンパイルエラーとなる。
+更に、C++23以降は`make_from_tuple`の戻り値が参照である場合でダングリング参照を生成しないために、`make_from_tuple`の内部で`T`が構築される際に、`Tuple`から取得されるオブジェクト（参照の初期化であるので、`Tuple`のサイズは1である必要がある）の寿命が延長されないことも要求され、これを満たさない場合はコンパイルエラーとなる。
 正確には、[`tuple_size_v`](tuple_size.md)`&amp;lt;`[`remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;Tuple&amp;gt;&amp;gt; == 1`である場合、[`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T, decltype(get&amp;lt;0&amp;gt;(`[`declval`](/reference/utility/declval.md)`&amp;lt;Tuple&amp;gt;()))&amp;gt; == false`であること。
 
 ## 引数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_cat -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_cat.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/tuple/tuple_cat.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_cat.md b/reference/tuple/tuple_cat.md
index 5827bea6e..095d19d56 100644
--- a/reference/tuple/tuple_cat.md
+++ b/reference/tuple/tuple_cat.md
@@ -28,7 +28,7 @@ namespace std {
     - `Tuples...`の全ての型が[`std::tuple`](tuple.md)`&amp;lt;Args...&amp;gt;`であること。
     - `Args...`の各型が左辺値参照であればコピー構築可能、そうでなければムーブ構築可能であること。
 - C++23から :
-    - 本関数の返り値の[`tuple`](tuple.md)のテンプレートパラメーターパックを`Ctypes`とし、`Ctypes`の全ての要素について、引数`tpls`において対応する要素の型から構築可能であること。
+    - 本関数の戻り値の[`tuple`](tuple.md)のテンプレートパラメーターパックを`Ctypes`とし、`Ctypes`の全ての要素について、引数`tpls`において対応する要素の型から構築可能であること。
     - より厳密には、次のように定義を行い、`(`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;CTypes, decltype(celems)&amp;gt; &amp;amp;&amp;amp; ...) == true`であること。
         - `n`を`sizeof...(Tuples)`とし、`i`を範囲`[0, n)`における整数値とする
         - `T(i)`を`Tuples`の`i`番目とする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_invocable_r -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_invocable_r.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/type_traits/is_invocable_r.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_invocable_r.md b/reference/type_traits/is_invocable_r.md
index 6620732bf..84996582c 100644
--- a/reference/type_traits/is_invocable_r.md
+++ b/reference/type_traits/is_invocable_r.md
@@ -66,8 +66,8 @@ int main()
 
   std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
 
-  // INVOKE、つまり std::invoke の返り値である S が
-  // R に束縛されて R の寿命と同じ寿命に延長された上で std::invoke_r の返り値となる
+  // INVOKE、つまり std::invoke の戻り値である S が
+  // R に束縛されて R の寿命と同じ寿命に延長された上で std::invoke_r の戻り値となる
   // しかし R の寿命はこの1文の間だけなので、S もこの1文が終了する際に破棄される
   const S&amp;amp; a = std::invoke_r&amp;lt;R&amp;gt;([]() { return S{}; });
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reference_constructs_from_temporary -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/reference_constructs_from_temporary.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/type_traits/reference_constructs_from_temporary.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/reference_constructs_from_temporary.md b/reference/type_traits/reference_constructs_from_temporary.md
index c02a78c88..05d91676b 100644
--- a/reference/type_traits/reference_constructs_from_temporary.md
+++ b/reference/type_traits/reference_constructs_from_temporary.md
@@ -37,9 +37,9 @@ namespace std {
 
 
 ## 備考
-多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「返り値の型が右辺値参照である関数」の返り値を束縛することを考える。（再現コードは、説明の最後に付す）
+多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「戻り値の型が右辺値参照である関数」の戻り値を束縛することを考える。（再現コードは、説明の最後に付す）
 
-この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は返り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
+この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は戻り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
 
 このような場面においては、本メタ関数が`pvalue`と`xvalue`を、`pvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
 
@@ -55,11 +55,11 @@ S&amp;amp;&amp;amp; f() { return S{}; }
 
 int main() {
   std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
-  
-  // f の返り値は s に束縛されて寿命が延長されたか？
-  // 実際にはこの宣言の1文が終了した際に f の返り値は破棄されている
+
+  // f の戻り値は s に束縛されて寿命が延長されたか？
+  // 実際にはこの宣言の1文が終了した際に f の戻り値は破棄されている
   S&amp;amp;&amp;amp; s(f());
-  
+
   std::cout &amp;lt;&amp;lt; &amp;#34;2&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reference_converts_from_temporary -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/type_traits/reference_converts_from_temporary.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/reference_converts_from_temporary.md b/reference/type_traits/reference_converts_from_temporary.md
index 0cff142fc..63ea01dea 100644
--- a/reference/type_traits/reference_converts_from_temporary.md
+++ b/reference/type_traits/reference_converts_from_temporary.md
@@ -33,9 +33,9 @@ namespace std {
 
 
 ## 備考
-多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「返り値の型が右辺値参照である関数」の返り値を束縛することを考える。（再現コードは、説明の最後に付す）
+多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「戻り値の型が右辺値参照である関数」の戻り値を束縛することを考える。（再現コードは、説明の最後に付す）
 
-この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は返り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
+この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は戻り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
 
 このような場面においては、本メタ関数が`pvalue`と`xvalue`を、`pvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
 
@@ -51,11 +51,11 @@ S&amp;amp;&amp;amp; f() { return S{}; }
 
 int main() {
   std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
-  
-  // f の返り値は s に束縛されて寿命が延長されたか？
-  // 実際にはこの宣言の1文が終了した際に f の返り値は破棄されている
+
+  // f の戻り値は s に束縛されて寿命が延長されたか？
+  // 実際にはこの宣言の1文が終了した際に f の戻り値は破棄されている
   S&amp;amp;&amp;amp; s = f();
-  
+
   std::cout &amp;lt;&amp;lt; &amp;#34;2&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : small fix</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>5419582e559fd5c88d719564587a9ca714844e5d:reference/cmath.md</id>
      <updated>2023-02-16T17:57:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index d444ed428..a0b536acc 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -94,9 +94,9 @@ C++23で`constexpr`対応する関数の条件は以下：
 1. 有理数の集合、または実数のどこにも密でない部分集合に作用すると見なされ、関数が閉じていること
 2. 関数が丸めモードに強く依存しないこと
 
-[`exp()`](cmath/exp.md)、[`sqrt()`](cmath/sqrt.md)、[`cos()`](cmath/cos.md)、[`sin()`](cmath/sin.md)は1. の条件を満たさないため、C++23では`constexpr`に対応しない。
+[`exp()`](cmath/exp.md)、[`log()`](cmath/log.md)、[`sqrt()`](cmath/sqrt.md)、[`cos()`](cmath/cos.md)、[`sin()`](cmath/sin.md)は1. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
-[`nearbyint`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
+[`nearbyint()`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
 ただし、コンパイラが先行して`constexpr`非対応の関数も対応している可能性がある。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>