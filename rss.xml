<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-17T10:52:38.532191</updated>
  <id>26853a84-b4fa-456a-803e-493e53617eb2</id>

  
    <entry>
      <title>format -- format : Rangeの要素に対する書式指定の例を記載 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/format.html"/>
      <id>2497046e4f89beeaffa4c0f7f3a014c4b6560e0e:reference/format/format.md</id>
      <updated>2023-01-17T19:47:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format.md b/reference/format/format.md
index a30e60934..ad5be5954 100644
--- a/reference/format/format.md
+++ b/reference/format/format.md
@@ -384,10 +384,14 @@ int main() {
   std::cout &amp;lt;&amp;lt; std::format(&amp;#34;3. {}&amp;#34;, s) &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; std::format(&amp;#34;4. {}&amp;#34;, r) &amp;lt;&amp;lt; std::endl;
 
+  // Rangeの書式指定のあと、:で区切って要素に対する書式指定ができる (ここでは16進数出力)
+  std::vector&amp;lt;int&amp;gt; vx = {0xf, 0x1e, 0x3c};
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;5. {::#x}&amp;#34;, vx) &amp;lt;&amp;lt; std::endl;
+
   // 文字を要素とするコンテナは文字列として出力させることもできる
   std::vector&amp;lt;char&amp;gt; vc = {&amp;#39;h&amp;#39;, &amp;#39;\n&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;};
-  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;5. {:s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
-  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;6. {:?s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;6. {:s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;7. {:?s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
 }
 ```
 * std::ranges::views::iota[link /reference/ranges/iota_view.md]
@@ -399,9 +403,10 @@ int main() {
 2. {1: &amp;#34;aaa&amp;#34;, 2: &amp;#34;bbb&amp;#34;}
 3. {1, 2, 3}
 4. [1, 2, 3, 4]
-5. h
+5. [0xf, 0x1e, 0x3c]
+6. h
 ello
-6. &amp;#34;h\nello&amp;#34;
+7. &amp;#34;h\nello&amp;#34;
 ```
 
 ### pair、tupleを出力する (C++23)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ios -- hexfloat : GCCで入力での使用にバグがあることを記載</title>
      <link href="https://cpprefjp.github.io/reference/ios.html"/>
      <id>44c43e183739ddba0b62ede3da2f5e5d4d9a38fe:reference/ios.md</id>
      <updated>2023-01-17T18:31:24+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;ios&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;ios&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;ios&amp;gt;&lt;/code&gt;ヘッダでは、入出力処理共通の基底クラスやマニピュレータ（の実体である関数）などが定義されている。&lt;/p&gt;
&lt;p&gt;このヘッダでは、以下の標準ヘッダをインクルードする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iosfwd.md.nolink&#34;&gt;&amp;lt;iosfwd&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;型と関数（マニピュレータを除く）&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/type-streamoff.html&#34;&gt;streamoff&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ファイルサイズの表現に適した符号付き整数型 (type-alias)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/type-streamsize.html&#34;&gt;streamsize&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入出力操作のバイト数などの表現に適した符号付き整数型 (type-alias)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/fpos.html&#34;&gt;fpos&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ストリーム上の位置を表現する型 (class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/ios_base.html&#34;&gt;ios_base&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入出力の最基底クラス (class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/basic_ios.html&#34;&gt;basic_ios&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入出力共通の基底クラス (class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/io_errc.html&#34;&gt;io_errc&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入出力のエラー値 (enum class)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/is_error_code_enum.html&#34;&gt;is_error_code_enum&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;io_errc&lt;/code&gt;をエラーコードとして扱うための特殊化 (class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/make_error_code.html&#34;&gt;make_error_code&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;io_errc&lt;/code&gt;から&lt;code&gt;error_code&lt;/code&gt;を生成する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/make_error_condition.html&#34;&gt;make_error_condition&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;io_errc&lt;/code&gt;から&lt;code&gt;error_condition&lt;/code&gt;を生成する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/iostream_category.html&#34;&gt;iostream_category&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;io_errc&lt;/code&gt;のためのエラーカテゴリを取得する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;マニピュレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/boolalpha.html&#34;&gt;boolalpha&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;bool値を文字列として入出力させる&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/noboolalpha.html&#34;&gt;noboolalpha&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;bool値を数値表記で入出力させる&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/showbase.html&#34;&gt;showbase&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基数などを表すプレフィックスを出力させる&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/noshowbase.html&#34;&gt;noshowbase&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基数などを表すプレフィックスを出力させない&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/showpoint.html&#34;&gt;showpoint&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小数点を常に出力させる&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/noshowpoint.html&#34;&gt;noshowpoint&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小数点を不要なら出力させない&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/showpos.html&#34;&gt;showpos&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正符号を出力させる&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/noshowpos.html&#34;&gt;noshowpos&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正符号を出力させない&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/skipws.html&#34;&gt;skipws&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;書式入力操作前に空白を読み飛ばさせる&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/noskipws.html&#34;&gt;noskipws&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;書式入力操作前の空白の読み飛ばしを行わない&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/uppercase.html&#34;&gt;uppercase&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;英大文字の表記で出力&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/nouppercase.html&#34;&gt;nouppercase&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;英小文字の表記で出力&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/unitbuf.html&#34;&gt;unitbuf&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力操作の都度バッファを吐き出す&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/nounitbuf.html&#34;&gt;nounitbuf&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力操作を終えても必要に応じてバッファに蓄える&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/internal.html&#34;&gt;internal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;両端揃え&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/left.html&#34;&gt;left&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左揃え&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/right.html&#34;&gt;right&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右揃え&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/dec.html&#34;&gt;dec&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;十進法で入出力（整数）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/hex.html&#34;&gt;hex&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;十六進法で入出力（整数）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/oct.html&#34;&gt;oct&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;八進法で入出力（整数）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/fixed.html&#34;&gt;fixed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小数点数表記で入出力（浮動小数点数）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/scientific.html&#34;&gt;scientific&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指数表記で入出力（浮動小数点数）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/hexfloat.html&#34;&gt;hexfloat&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;十六進法での指数表記で入出力（浮動小数点数）&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/defaultfloat.html&#34;&gt;defaultfloat&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小数点数・指数表記の自動切り替え（浮動小数点数）&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++98&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fixed -- hexfloat : GCCで入力での使用にバグがあることを記載</title>
      <link href="https://cpprefjp.github.io/reference/ios/fixed.html"/>
      <id>44c43e183739ddba0b62ede3da2f5e5d4d9a38fe:reference/ios/fixed.md</id>
      <updated>2023-01-17T18:31:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ios/fixed.md b/reference/ios/fixed.md
index 246c21118..05eacc1ef 100644
--- a/reference/ios/fixed.md
+++ b/reference/ios/fixed.md
@@ -10,7 +10,7 @@ namespace std {
 ```
 
 ## 概要
-浮動小数点数を固定小数点表記で出力することを指示するマニピュレータ。
+浮動小数点数を固定小数点表記で入出力することを指示するマニピュレータ。
 
 ## 効果
 `str.setf(ios_base::fixed, ios_base::floatfield)`を実行する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hexfloat -- hexfloat : GCCで入力での使用にバグがあることを記載</title>
      <link href="https://cpprefjp.github.io/reference/ios/hexfloat.html"/>
      <id>44c43e183739ddba0b62ede3da2f5e5d4d9a38fe:reference/ios/hexfloat.md</id>
      <updated>2023-01-17T18:31:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ios/hexfloat.md b/reference/ios/hexfloat.md
index 4b57d7672..9eae0997d 100644
--- a/reference/ios/hexfloat.md
+++ b/reference/ios/hexfloat.md
@@ -11,7 +11,7 @@ namespace std {
 ```
 
 ## 概要
-浮動小数点数を十六進法で出力することを指示するマニピュレータ。
+浮動小数点数を十六進法で入出力することを指示するマニピュレータ。
 
 [`printf()`](http://linuxjm.osdn.jp/html/LDP_man-pages/man3/printf.3.html)関数の`%a`／`%A`相当。
 
@@ -31,9 +31,14 @@ namespace std {
 ### 処理系
 - [Clang](/implementation.md#clang): 3.0
 - [GCC](/implementation.md#gcc): 5.0
-- [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2008, 2010, 2012
 
+
+#### 備考
+- GCCは12.0時点で、入力ストリームでの`hexfloat`の使用に対応していない。使用すると値0が入力される (エラーにならない)
+    - [Bug 81122 - [DR 2381] parsing f stopped after &amp;#39;0&amp;#39; when reading `std::hexfloat &amp;gt;&amp;gt; f;`](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81122)
+
+
 ## 参照
 - [`defaultfloat`](defaultfloat.md)
 - [`fixed`](fixed.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scientific -- hexfloat : GCCで入力での使用にバグがあることを記載</title>
      <link href="https://cpprefjp.github.io/reference/ios/scientific.html"/>
      <id>44c43e183739ddba0b62ede3da2f5e5d4d9a38fe:reference/ios/scientific.md</id>
      <updated>2023-01-17T18:31:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ios/scientific.md b/reference/ios/scientific.md
index 388f6a913..b6af30926 100644
--- a/reference/ios/scientific.md
+++ b/reference/ios/scientific.md
@@ -10,7 +10,7 @@ namespace std {
 ```
 
 ## 概要
-浮動小数点数を指数表記で出力することを指示するマニピュレータ。
+浮動小数点数を指数表記で入出力することを指示するマニピュレータ。
 
 ## 効果
 `str.setf(ios_base::scientific, ios_base::floatfield)`を実行する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変長データを扱うクラスの効率的な`delete` -- 仕様と例の追記 #1102</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.html"/>
      <id>f86e3825c89e743aedfdd3d66a1850cbd74d63f2:lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md</id>
      <updated>2023-01-17T18:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md b/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
index cffee868b..dc5424748 100644
--- a/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
+++ b/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
@@ -69,10 +69,62 @@ int main() {
 
 ## 仕様
 
-- クラス`C`に対する*destroying operator delete*の第一引数は`C*`でなければならない
-- *destroying operator delete*の戻り値型は`void`でなければならない
+クラススコープで定義された`operator delete()`で、第二引数が`std::destroying_delete_t`であるものを*destroying operator delete*と呼ぶ。クラス`C`に対する*destroying operator delete*の第一引数は`C*`でなければならず、その2点以外は通常の`operator delete`オーバーロードの制約に従う。
 
-（執筆中）
+```cpp
+struct S {
+  // これらの宣言はいずれも、destroying operator deleteではない（コンパイルエラーとなる）
+  void operator delete(void*, std::destroying_delete_t);      // 第一引数はS*
+  void operator delete(S*, auto);                             // 第二引数は std::destroying_delete_t
+  int* operator delete(S*, std::destroying_delete_t);         // 戻り値はvoid
+  virtual void operator delete(S*, std::destroying_delete_t); // 仮想関数にできない
+};
+```
+
+単一オブジェクトに対する`delete`式の実行に伴う`operator delete`の探索の結果、その候補の中に*destroying operator delete*が含まれている場合、*destroying operator delete*ではない`operator delete`は候補から外れる。
+
+```cpp
+struct S {
+  // destroying operator delete
+  void operator delete(S*, std::destroying_delete_t);
+
+  // destroying operator deleteが定義されている限り、こちらが呼び出されることはない
+  void operator delete(void*);
+};
+```
+
+ただし、配列に対する`delete`式の場合は、*destroying operator delete*は考慮されない。
+
+```cpp
+struct S {
+  // #1 destroying operator delete
+  void operator delete(S* p, std::destroying_delete_t) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;S::operator delete()\n&amp;#34;;
+
+    std::destroy_at(p);
+    ::operator delete(p);
+  }
+};
+
+int main() {
+  S* p = new S[1]{};
+
+  // #1は呼び出されず、要素ごとに破棄された後で配列の領域が解放される
+  delete[] p;
+}
+```
+
+また、配列板の`operator delete[]`を*destroying operator delete*としてオーバーロードすることもできない。
+
+```cpp
+struct S {
+  void operator delete[](S* p, std::destroying_delete_t); // ng
+};
+```
+
+単一オブジェクトに対する`delete`式においてそのオブジェクトの静的型と動的型が一致しない場合（つまり、基底クラスのポインタから派生クラスのオブジェクトを`delete`しようとする場合など）、その静的型はその動的型の基底クラスである必要があり両方の型に仮想デストラクタが必要となるが、*destroying operator delete*が`operator delete`として使用される場合にはその必要はない。したがって、*destroying operator delete*が使用されない場合に`delete`式が指定されたポインタの指す最も派生したオブジェクトを削除せず未定義動作になるような場合（仮想デストラクタの定義忘れなど）でも、*destroying operator delete*が使用された場合は未定義動作とならない（ただし、呼び出された*destroying operator delete*がそのオブジェクトを正しく破棄しない場合は未定義動作となりうる）。
+
+*destroying operator delete*が`operator delete`として使用される`delete`式の実行において、`delete`式は`delete`対象オブジェクトのデストラクタを呼び出さないで`operator delete`を呼び出す。また、その際の*destroying operator delete*の第二引数（`std::destroying_delete_t`に対応する引数）に渡される値は未規定。
 
 ## 例
 
@@ -159,7 +211,7 @@ int main() {
 * std::ranges::destroy[link /reference/memory/ranges_destroy.md]
 
 
-### 出力
+#### 出力
 
 ```
 inlined_fixed_string::Make() : 47 byte allocate.
@@ -167,6 +219,78 @@ C++20 destroying operator delete test.
 inlined_fixed_string::operator delete() : 47 byte deallocate.
 ```
 
+### 正しいデストラクタへのディスパッチ
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;new&amp;gt;
+
+// 仮想デストラクタを定義しない基底クラス
+struct base {
+  int kind = 0;
+
+  // destroying operator delete宣言 #1
+  void operator delete(base* p, std::destroying_delete_t);
+};
+
+struct derived1 : base {
+  derived1() : base{1} {}
+};
+
+struct derived2 : base {
+  derived2() : base{2} {}
+};
+
+// #1に対応する定義
+void base::operator delete(base* p, std::destroying_delete_t) {
+
+  switch(p-&amp;gt;kind) {
+    case 1:
+    {
+      auto* dp = static_cast&amp;lt;derived1*&amp;gt;(p);
+      std::destroy_at(dp);
+      ::operator delete(dp);
+      std::cout &amp;lt;&amp;lt; &amp;#34;destruct derived1\n&amp;#34;;
+      break;
+    }
+    case 2:
+    {
+      auto* dp = static_cast&amp;lt;derived2*&amp;gt;(p);
+      std::destroy_at(dp);
+      ::operator delete(dp);
+      std::cout &amp;lt;&amp;lt; &amp;#34;destruct derived2\n&amp;#34;;
+      break;
+    }
+    default:
+      std::destroy_at(p);
+      ::operator delete(p);
+      std::cout &amp;lt;&amp;lt; &amp;#34;destruct base\n&amp;#34;;
+  }
+}
+
+int main() {
+  {
+    base* p = new derived1{};
+    // #1によってderived1のデストラクタが呼ばれ、メモリが解放される
+    delete p;
+  }
+  {
+    base* p = new derived2{};
+    // #1によってderived2のデストラクタが呼ばれ、メモリが解放される
+    delete p;
+  }
+}
+```
+* destroying_delete_t[color ff0000]
+* std::destroy_at[link /reference/memory/destroy_at.md]
+
+#### 出力
+
+```
+destruct derived1
+destruct derived2
+```
+
 ## この機能が必要になった背景・経緯
 （執筆中）
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>INVOKE -- INVOKE: fix markup `INVOKE&lt;R&gt;`(#1055)</title>
      <link href="https://cpprefjp.github.io/reference/concepts/Invoke.html"/>
      <id>1f6c97ce954e86960f296aa7d95ef14b33d587b4:reference/concepts/Invoke.md</id>
      <updated>2023-01-17T17:32:08+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;named requirement&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace &#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;INVOKE&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;C++における関数呼び出しという性質を抽象化しまとめた、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt; を定義する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++17からは、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt; を実体化した&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;関数テンプレートが提供される。&lt;/li&gt;
&lt;li&gt;C++23からは、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;&lt;/code&gt; を実体化した&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke_r.html&#34;&gt;std::invoke_r&lt;/a&gt;&lt;/code&gt;関数テンプレートが提供される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;用語定義&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;call-signature&lt;/em&gt; とは、戻り値型に続けて丸括弧の中に0個以上の引数型を並べたものである。 &lt;em&gt;cf.&lt;/em&gt; &lt;code&gt;int ( std::string, int )&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-type&lt;/em&gt; とは、関数呼び出し演算子を適用できる型 ( 関数、関数への参照、関数へのポインタ、&lt;code&gt;operator ()&lt;/code&gt; をオーバーロードした型もしくはそれを(直接または間接的に) &lt;code&gt;public&lt;/code&gt; 継承した型 ) もしくはメンバへのポインタ型を指す。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-object&lt;/em&gt; は、 &lt;em&gt;callable-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper-type&lt;/em&gt; は、 &lt;em&gt;callable-object&lt;/em&gt; を保持し、自身に対する関数呼び出し操作が行われたとき、保持しているオブジェクトに委譲する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; は、 &lt;em&gt;call-wrapper-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;target-object&lt;/em&gt; とは、 &lt;em&gt;callable-object&lt;/em&gt; に保持されているオブジェクトのことである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;要件（C++14まで）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が T 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN, R)&lt;/code&gt; を、 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること、と定義する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; が &lt;em&gt;weak-result-type&lt;/em&gt; を用意している場合、メンバ型 &lt;code&gt;result_type&lt;/code&gt; は&lt;em&gt;target-object&lt;/em&gt; の型 &lt;code&gt;T&lt;/code&gt; に応じて次のように定義される。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; がメンバ関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;result_type&lt;/code&gt; という名前のメンバ型を持つとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T::result_type&lt;/code&gt; と等しい。&lt;/li&gt;
&lt;li&gt;どの条件にも当てはまらない場合、 &lt;code&gt;result_type&lt;/code&gt; は定義されない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveAssignable&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++17）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveConstructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++20）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;Cpp17MoveConstructible&lt;/em&gt; かつ &lt;em&gt;Cpp17Destructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/Cryolite/status/216814363221303296&#34; target=&#34;_blank&#34;&gt;第1引数がメンバ関数へのポインタの場合でも非静的メンバデータへのポインタの場合でも，第2引数がクラスオブジェクトへの参照の場合でもポインタの場合でもポインタっぽいものの場合でも，なんか知らんけどそれっぽく上手くいく&lt;/a&gt; ように取り計らった操作のことである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;function&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;bind&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/thread.html&#34;&gt;thread&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/async.html&#34;&gt;async&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/packaged_task.html&#34;&gt;packaged_task&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/call_once.html&#34;&gt;call_once&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf&#34; target=&#34;_blank&#34;&gt;P0777R1 Treating Unnecessary &lt;code&gt;decay&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++20から&lt;code&gt;decay_t&lt;/code&gt;を&lt;code&gt;remove_cvref_t&lt;/code&gt;へ変更。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2136r3.html&#34; target=&#34;_blank&#34;&gt;P2136R3 &lt;code&gt;invoke_r&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>invoke_r -- functinoal/invoke_r: delete forbidden chars(#1055)</title>
      <link href="https://cpprefjp.github.io/reference/functional/invoke_r.html"/>
      <id>30918b2308ad1932317002a995220d96cd0038d5:reference/functional/invoke_r.md</id>
      <updated>2023-01-17T17:18:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/invoke_r.md b/reference/functional/invoke_r.md
index 55114daef..c5d679bde 100644
--- a/reference/functional/invoke_r.md
+++ b/reference/functional/invoke_r.md
@@ -19,7 +19,7 @@ namespace std {
 
 
 ## テンプレートパラメータ制約
-[`is_­invocable_­r_­v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, F, Args...&amp;gt;`が`true`
+[`is_invocable_r_v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, F, Args...&amp;gt;`が`true`
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>