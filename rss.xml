<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-04-14T04:24:38.563603</updated>
  <id>c2e9a62d-e5f5-4899-a69f-2ff0f8e9a443</id>

  
    <entry>
      <title>unique -- Merge pull request #752 from cpprefjp/tshino-patch-1</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/unique.html"/>
      <id>386bc57e28d4f5b88c16a2af7334f2e40faf7803:reference/memory/shared_ptr/unique.md</id>
      <updated>2020-04-14T13:20:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/unique.md b/reference/memory/shared_ptr/unique.md
index 682022606..3cb4ef22c 100644
--- a/reference/memory/shared_ptr/unique.md
+++ b/reference/memory/shared_ptr/unique.md
@@ -14,7 +14,7 @@ bool unique() const noexcept;
 この関数は、C++17から非推奨となり、C++20で削除された。代わりに[`use_count()`](use_count.md)関数を使用すること。
 
 ## 概要
-有効なリソースを所有しているかを判定する。
+同じ所有権を共有する他のユーザーが存在しないかを判定する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equality_comparable -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/reference/concepts/equality_comparable.html"/>
      <id>9d0aaf10ba17673b1dc4f69cd5da961f30fea67c:reference/concepts/equality_comparable.md</id>
      <updated>2020-04-14T12:40:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/equality_comparable.md b/reference/concepts/equality_comparable.md
index f50ac85b2..fa14fd6e3 100644
--- a/reference/concepts/equality_comparable.md
+++ b/reference/concepts/equality_comparable.md
@@ -77,7 +77,7 @@ concept equality_comparable_with =
 
 ## 備考
 
-定義内の`a == b`等の各制約式に[等しさを保持](/reference/concepts.md)する事が要求されていることによって、これらコンセプトを満たす`== !=`演算子は推移的かつ対称的である事を表し、要求している。
+定義内の`t == u`等の各制約式に[等しさを保持](/reference/concepts.md)する事が要求されていることによって、これらコンセプトを満たす`== !=`演算子は推移的かつ対称的である事を表し、要求している。
 
 - 推移律 : `a == b`かつ`b == c`ならば`a == c`
 - 対称律 : `a == b`ならば`b == a`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- string::operator+ : P1165R1対応 #640</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>7f43be4e28ff7282bf9c10c825b6929a6c93f1c2:reference/string/basic_string/op_plus.md</id>
      <updated>2020-04-14T12:40:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index a26f079e3..9cba8ea23 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -46,23 +46,23 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 
 template &amp;lt;class charT, class traits, class Allocator&amp;gt;
 basic_string&amp;lt;charT, traits, Allocator&amp;gt;
-  operator+(const basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; rhs,
-            const charT* lhs);                                  // (9)
+  operator+(const basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; lhs,
+            const charT* rhs);                                  // (9)
 
 template &amp;lt;class charT, class traits, class Allocator&amp;gt;
 basic_string&amp;lt;charT, traits, Allocator&amp;gt;
-  operator+(basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp;&amp;amp; rhs,
-            const charT* lhs);                                  // (10) C++11 から
+  operator+(basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp;&amp;amp; lhs,
+            const charT* rhs);                                  // (10) C++11 から
 
 template &amp;lt;class charT, class traits, class Allocator&amp;gt;
 basic_string&amp;lt;charT, traits, Allocator&amp;gt;
-  operator+(const basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; rhs,
-            charT lhs);                                         // (11)
+  operator+(const basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; lhs,
+            charT rhs);                                         // (11)
 
 template &amp;lt;class charT, class traits, class Allocator&amp;gt;
 basic_string&amp;lt;charT, traits, Allocator&amp;gt;
-  operator+(basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp;&amp;amp; rhs,
-            charT lhs);                                         // (12) C++11 から
+  operator+(basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp;&amp;amp; lhs,
+            charT rhs);                                         // (12) C++11 から
 ```
 
 ## 概要
@@ -70,6 +70,9 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 
 
 ## 戻り値
+
+### C++17まで
+
 - (1) [`basic_string`](op_constructor.md)`&amp;lt;charT, traits, Allocator&amp;gt;(lhs).`[`append`](append.md)`(rhs)`
 
 - (2) `std::`[`move`](/reference/utility/move.md)`(lhs.`[`append`](append.md)`(rhs))`
@@ -95,10 +98,102 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 
 - (12) `std::`[`move`](/reference/utility/move.md)`(lhs.`[`append`](append.md)`(1, rhs))`
 
+### C++20から
+
+- (1)(9) : 以下と等価
+  ```cpp
+  basic_string&amp;lt;charT, traits, Allocator&amp;gt; r = lhs;
+  r.append(rhs);
+  return r;
+  ```
+  * append[link append.md]
+
+- (2)(10) : 以下と等価
+  ```cpp
+  lhs.append(rhs);
+  return std::move(lhs);
+  ```
+  * append[link append.md]
+
+- (3)(6) : 以下と等価
+  ```cpp
+  rhs.insert(0, lhs);
+  return std::move(rhs);
+  ```
+  * insert[link insert.md]
+
+- (4) : 呼び出しの後でも`lhs`と`rhs`は有効だが未規定な状態のままであることを除いて、以下と等価
+  ```cpp
+  lhs.append(rhs);
+  return std::move(lhs);
+  ```
+  * append[link append.md]
+
+- (5) : 以下と等価
+  ```cpp
+  basic_string&amp;lt;charT, traits, Allocator&amp;gt; r = rhs;
+  r.insert(0, lhs);
+  return r;
+  ```
+  * insert[link insert.md]
+
+- (7) : 以下と等価
+  ```cpp
+  basic_string&amp;lt;charT, traits, Allocator&amp;gt; r = rhs;
+  r.insert(r.begin(), lhs);
+  return r;
+  ```
+  * insert[link insert.md]
+  * begin[link begin.md]
+
+- (8) : 以下と等価
+  ```cpp
+  rhs.insert(rhs.begin(), lhs);
+  return std::move(rhs);
+  ```
+  * insert[link insert.md]
+  * begin[link begin.md]
+
+- (11) : 以下と等価
+  ```cpp
+  basic_string&amp;lt;charT, traits, Allocator&amp;gt; r = lhs;
+  r.push_back(rhs);
+  return r;
+  ```
+  * push_back[link push_back.md]
+
+- (12) : 以下と等価
+  ```cpp
+  lhs.push_back(rhs);
+  return std::move(lhs);
+  ```
+  * push_back[link push_back.md]
+
 
 ## 備考
 (5)、(6) の形式の `lhs`、および、(9)、(10) の形式の `rhs` の文字列長算出のために `traits::length()` が使用される
 
+## アロケータの伝搬
+
+C++20からこの演算子による文字列連結時にアロケータがどのように伝搬するかが変更された。C++17までの仕様及び各実装とC++20からの各オーバーロード利用時の結果オブジェクトへのアロケータ供給元は次のようになる。なお、SOCCCは[`select_on_container_copy_construction`](/reference/memory/allocator_traits/select_on_container_copy_construction.md)の略。
+
+|オーバーロード|C++17まで|GCC|clang|MSVC|C++20から|
+|----|----|----|----|----|----|
+|(1) : `lhs + rhs`|`lhs`からのSOCCC|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(3) : `lhs + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(2) : `std::move(lhs) + rhs`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(4) : `std::move(lhs) + std::move(rhs)`|`lhs`または`rhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(9) : `lhs + &amp;#34;rhs&amp;#34;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(11) : `lhs + &amp;#39;r&amp;#39;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(10) : `std::move(lhs) + &amp;#34;rhs&amp;#34;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(12) : `std::move(lhs) + &amp;#39;r&amp;#39;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(5) : `&amp;#34;lhs&amp;#34; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(7) : `&amp;#39;l&amp;#39; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(6) : `&amp;#34;lhs&amp;#34; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(8) : `&amp;#39;l&amp;#39; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+
+
+表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝搬仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
 
 ## 例
 ```cpp example
@@ -129,3 +224,6 @@ Hello, world!
 | [`append`](append.md)       | 文字／文字列を追加する |
 | [`push_back`](push_back.md) | 文字を追加する         |
 | [`insert`](insert.md)       | 文字／文字列を挿入する |
+
+## 参照
+- [P1165R1 Make stateful allocator propagation more consistent for operator+(basic_string)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1165r1.html)
\ No newline at end of file
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- uniqueの説明を修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/unique.html"/>
      <id>d1d4c019febe6adb96c84a0ce1c27c9b19d9c45d:reference/memory/shared_ptr/unique.md</id>
      <updated>2020-04-13T23:11:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/unique.md b/reference/memory/shared_ptr/unique.md
index 682022606..3cb4ef22c 100644
--- a/reference/memory/shared_ptr/unique.md
+++ b/reference/memory/shared_ptr/unique.md
@@ -14,7 +14,7 @@ bool unique() const noexcept;
 この関数は、C++17から非推奨となり、C++20で削除された。代わりに[`use_count()`](use_count.md)関数を使用すること。
 
 ## 概要
-有効なリソースを所有しているかを判定する。
+同じ所有権を共有する他のユーザーが存在しないかを判定する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equality_comparable -- equality_comparable : 微修正</title>
      <link href="https://cpprefjp.github.io/reference/concepts/equality_comparable.html"/>
      <id>5b38b9e96302a7903e2a3b86a8e81fe3c4f71674:reference/concepts/equality_comparable.md</id>
      <updated>2020-04-12T23:38:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/equality_comparable.md b/reference/concepts/equality_comparable.md
index f50ac85b2..fa14fd6e3 100644
--- a/reference/concepts/equality_comparable.md
+++ b/reference/concepts/equality_comparable.md
@@ -77,7 +77,7 @@ concept equality_comparable_with =
 
 ## 備考
 
-定義内の`a == b`等の各制約式に[等しさを保持](/reference/concepts.md)する事が要求されていることによって、これらコンセプトを満たす`== !=`演算子は推移的かつ対称的である事を表し、要求している。
+定義内の`t == u`等の各制約式に[等しさを保持](/reference/concepts.md)する事が要求されていることによって、これらコンセプトを満たす`== !=`演算子は推移的かつ対称的である事を表し、要求している。
 
 - 推移律 : `a == b`かつ`b == c`ならば`a == c`
 - 対称律 : `a == b`ならば`b == a`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>