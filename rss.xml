<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-04-19T09:07:31.722631</updated>
  <id>f3f3d628-5a71-4fd5-b46d-4947861557b0</id>

  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 参考リンク追加と修正 #1117</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>f81c873437dd6933e6a0668ba1b3959051b865b1:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-04-19T18:02:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index ac70f082a..9ade0289a 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -391,7 +391,7 @@ unique_ptr&amp;lt;char[]&amp;gt; Stream::read() {
 
 最終的には、暗黙的なオブジェクト構築のように、C++のオブジェクトモデルを修正する形でこの問題を解消することになった。
 
-ただし、２番目の特殊なライブラリ関数もC++23で`std::start_lifetime_as()`として追加されテイル。
+ただし、２番目の特殊なライブラリ関数もC++23で`std::start_lifetime_as()`として追加されている。
 
 ## 関連項目
 
@@ -402,6 +402,7 @@ unique_ptr&amp;lt;char[]&amp;gt; Stream::read() {
 ## 参照
 
 - [P0593R6 Implicit creation of objects for low-level object manipulation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0593r6.html)
+- [P0593R０ What to do with buffers that are not arrays, and undefined behavior thereof?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0593r0.html)
 - [CWG Issue 2325. `std::launder` and reuse of character buffers](https://cplusplus.github.io/CWG/issues/2325.html)
 - [CWG Issue 2605. Implicit-lifetime aggregates](https://cplusplus.github.io/CWG/issues/2605.html)
 - [P1839R5 Accessing Object Representations](https://wg21.link/p1839r5)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 背景とその他選択肢追記 #1117</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>1c743fb17397e72155bcdc8c3f60f431add22fce:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-04-19T18:00:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index a2e04f066..ac70f082a 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -369,15 +369,29 @@ unique_ptr&amp;lt;char[]&amp;gt; Stream::read() {
 
 この例では、`reserve()`内`newbuf`及びそれを保存している`Vec::buf`の領域に`T[]`（`T`の配列型）と`char[]`のオブジェクトが暗黙的に構築され、同時に生存期間内にあることで、問題（配列オブジェクトを指さないポインタのイテレータとしての使用）は解消される。
 
-ただし、`newbuf`及び`Vec::buf`から都度適切なオブジェクトへのポインタを得るのに[`std::launder()`](/reference/new/launder.md)を適切使用する必要がある。
+ただし、`newbuf`及び`Vec::buf`から都度適切なオブジェクトへのポインタを得るのに[`std::launder()`](/reference/new/launder.md)を適切に使用する必要がある。
 
 ## この機能が必要になった背景・経緯
-(執筆中)
 
+例に上がっているようなコードはC言語では一般的な操作であり、Cでは問題がない。このようなコードはCとC++のコード共有部分でC++コードとして現れる可能性があり、その場合には未定義動作となる。
+
+また、動的配列の例などは、`std::vector`の実装において問題となることで、そこは完全にC++のコードでありながらC++がサポートしてないことを行うことになってしまう。
+
+これらの問題は、影響を受けるコードが多すぎるため実装はこれを最適化に用いたりはしないと考えられるため、実際には問題とならない可能性が高かった。しかし、これらのよく書かれているコードをC++がサポートしていないという奇妙な状況を改善するため、暗黙的なオブジェクト構築という仕様が導入された。
 
 ## 検討されたほかの選択肢
-(執筆中)
 
+上記の問題を解決するための方法として、暗黙的なオブジェクト構築以外に
+
+- 問題となる操作を無条件で合法化
+- ライブラリ関数を追加して、それを介してコンパイラに意図を伝達
+- `std::span`を特別扱いして、関連する操作を合法化
+
+などが考案されていた。
+
+最終的には、暗黙的なオブジェクト構築のように、C++のオブジェクトモデルを修正する形でこの問題を解消することになった。
+
+ただし、２番目の特殊なライブラリ関数もC++23で`std::start_lifetime_as()`として追加されテイル。
 
 ## 関連項目
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- launder()が必要になる場合の解決コードを削除 #1117</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>45cd04b0f7f0abbdb7cfbc314a9354f0bf85b154:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-04-19T17:18:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index 5d41421f9..a2e04f066 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -361,83 +361,15 @@ unique_ptr&amp;lt;char[]&amp;gt; Stream::read() {
 
 この`read()`内の`new char[N]`によって呼ばれる`operator new[]`によって`Foo`/`Bar`のオブジェクトが暗黙的に構築される。この場合、`buffer[0] == FOO`による分岐によってプログラムに定義された振る舞いをもたらすオブジェクトは、`Foo`と`Bar`のオブジェクトとして2つ存在する。したがって、ここでは先頭バイトの状態に応じて適切なオブジェクトが構築される（そうすることでプログラムに定義された振る舞いをもたらす）ため、`process()`内では未定義動作は回避される。
 
-```cpp
-void process(Stream *stream) {
-  // バイト配列の読み出し
-  std::unique_ptr&amp;lt;char[]&amp;gt; buffer = stream-&amp;gt;read();
-
-  // 先頭バイトの状態によって適切なオブジェクトがStream::read()内で構築されている
-  // ただし、reinterpret_castの代わりにstd::launder()を使用する必要がある
-  if (buffer[0] == FOO) {
-    process_foo(std::launder&amp;lt;Foo&amp;gt;(buffer.get())); // ✅ ok
-  } else {
-    process_bar(std::launder&amp;lt;Bar&amp;gt;(buffer.get())); // ✅ ok
-  }
-}
-```
-* std::launder[link /reference/new/launder.md]
+ただし、`process()`内の各分岐においては、返された`buffer`ポインタ（`char(*)[]`）からそれぞれの場合で適切なオブジェクト（`Foo`/`Bar`）へのポインタを、[`std::launder()`](/reference/new/launder.md)を用いて取得する必要がある。
 
-追加で、各分岐においては返された`buffer`ポインタ（`char(*)[]`）から、それぞれの場合で適切なオブジェクト（`Foo`/`Bar`）へのポインタを[`std::launder()`](/reference/new/launder.md)によって取得する必要がある。`reinterpret_cast`はポインタの変換のみを行うため、この場合に
+`reinterpret_cast`はポインタ型の変換のみを行うが、型変換だけではそのポインタはその領域に生存期間内にあるオブジェクトと必ずしもリンクしない。`std::launder()`は、渡されたポインタの領域で生存期間内にあるオブジェクトへのポインタを生成して返す関数であり、これを用いることで暗黙的に構築されたオブジェクトへの適切なポインタを得ることができる。
 
 ### 動的配列の実装
 
-```cpp
-// std::vectorの様な動的配列型を実装したい
-template&amp;lt;typename T&amp;gt;
-struct Vec {
-  char *buf = nullptr;
-  char *buf_end_size = nullptr;
-  char *buf_end_capacity = nullptr;
-
-  void reserve(std::size_t n) {
-    // 後続の操作を適格にするためのオブジェクトを暗黙的に構築する
-    // ここでは、Tの配列型T[]のオブジェクトが暗黙的に構築される（要素のオブジェクトは構築されない）
-    // 同時に、char[]のオブジェクトも暗黙的に構築される
-    char *newbuf = (char*)::operator new(n * sizeof(T), std::align_val_t(alignof(T)));
-
-    // newbufにはT[]のオブジェクトが生存期間内にあるため、ポインタT*をイテレータとして使用可能となる
-    // ここで、T[]の要素のTのオブジェクトが構築される（明示的）
-    std::uninitialized_copy(begin(), end(), std::launder&amp;lt;T&amp;gt;(newbuf)); // #a ✅ ok
-
-    ::operator delete(buf, std::align_val_t(alignof(T)));
-    
-    buf = newbuf;
-    // newbufにはchar[]のオブジェクトが生存期間内にあるため、newbuf(char*)をイテレータとして使用可能となる
-    buf_end_size = newbuf + sizeof(T) * size(); // #b ✅ ok
-    buf_end_capacity = newbuf + sizeof(T) * n;  // #c ✅ ok
-  }
-
-  void push_back(T t) {
-    if (buf_end_size == buf_end_capacity)
-      reserve(std::max&amp;lt;std::size_t&amp;gt;(size() * 2, 1));
-    new (buf_end_size) T(t);
-
-    // buf_end_sizeの指す領域にはchar[]のオブジェクトが生存期間内にあるため、ポインタをイテレータとして使用可能
-    buf_end_size += sizeof(T); // #d ✅ ok
-  }
-
-  T *begin() { return std::launder&amp;lt;T&amp;gt;(buf); }
-
-  T *end() { return std::launder&amp;lt;T&amp;gt;(buf_end_size); }
-
-  // buf及びbuf_end_sizeの指す領域にはT[]のオブジェクトが生存期間内にあるため、ポインタをイテレータとして使用可能
-  std::size_t size() { return end() - begin(); } // #e ✅ ok
-};
-
-int main() {
-  Vec&amp;lt;int&amp;gt; v;
-  v.push_back(1);
-  v.push_back(2);
-  v.push_back(3);
-
-  // 実装内部で暗黙的に配列オブジェクトが構築されることでUBが回避される
-  for (int n : v) { /*...*/ } // #f ✅ ok
-}
-```
-
-この例では、`reserve()`内`newbuf`及びそれを保存している`Vec::buf`の領域に`T[]`（`T`の配列型）と`char[]`のオブジェクトが暗黙的に構築され、同時に生存期間内にあることで、問題（配列オブジェクトを指さないポインタのイテレータとしての使用）が解消され、すべての箇所で定義された振る舞いをもたらしている。
+この例では、`reserve()`内`newbuf`及びそれを保存している`Vec::buf`の領域に`T[]`（`T`の配列型）と`char[]`のオブジェクトが暗黙的に構築され、同時に生存期間内にあることで、問題（配列オブジェクトを指さないポインタのイテレータとしての使用）は解消される。
 
-ここでも同様に、`newbuf`及び`Vec::buf`から都度適切なオブジェクトへのポインタを得るのに[`std::launder()`](/reference/new/launder.md)を使用する必要がある。
+ただし、`newbuf`及び`Vec::buf`から都度適切なオブジェクトへのポインタを得るのに[`std::launder()`](/reference/new/launder.md)を適切使用する必要がある。
 
 ## この機能が必要になった背景・経緯
 (執筆中)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_map -- flat_map : 比較演算子とswapを非メンバ (Hidden Friends) 関数に分類 #1142</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map.html"/>
      <id>0ce85f3d6aa5f19188d506288f7f3101ee3313c3:reference/flat_map/flat_map.md</id>
      <updated>2023-04-18T17:02:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map.md b/reference/flat_map/flat_map.md
index b26f49554..ac96b9be4 100644
--- a/reference/flat_map/flat_map.md
+++ b/reference/flat_map/flat_map.md
@@ -90,18 +90,6 @@ namespace std {
 | [`key_comp`](flat_map/key_comp.md.nolink)     | キー比較用の関数オブジェクトを取得する | C++23 |
 | [`value_comp`](flat_map/value_comp.md.nolink) | 要素比較用の関数オブジェクトを取得する | C++23 |
 
-### 比較演算子
-
-| 名前 | 説明 | 対応バージョン |
-|------|------|----------------|
-| [`operator==`](flat_map/op_equal.md.nolink)         | 左辺と右辺が等しいかの判定を行う           | C++23 |
-| `bool operator!=(const flat_map&amp;amp; x, const flat_map&amp;amp; y);` | 左辺と右辺が等しくないかの判定を行う (`==`により使用可能) | C++23 |
-| [`operator&amp;lt;=&amp;gt;`](flat_map/op_compare_3way.md.nolink) | 三方比較を行う                             | C++23 |
-| `bool operator&amp;lt;(const flat_map&amp;amp; x, const flat_map&amp;amp; y);`  | 左辺が右辺より小さいかの判定を行う  (`&amp;lt;=&amp;gt;`により使用可能) | C++23 |
-| `bool operator&amp;lt;=(const flat_map&amp;amp; x, const flat_map&amp;amp; y);` | 左辺が右辺より小さいか等しいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能) | C++23 |
-| `bool operator&amp;gt;(const flat_map&amp;amp; x, const flat_map&amp;amp; y);`  | 左辺が右辺より大きいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能) | C++23 |
-| `bool operator&amp;gt;=(const flat_map&amp;amp; x, const flat_map&amp;amp; y);` | 左辺が右辺より大きいか等しいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能) | C++23 |
-
 
 ## メンバ型
 
@@ -126,18 +114,32 @@ namespace std {
 
 
 ## 非メンバ関数
-### 入れ替え
+### 要素削除
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| [`swap`](flat_map/swap_free.md.nolink) | 2つの`flat_map`オブジェクトを入れ替える | C++23 |
+| [`erase_if`](flat_map/erase_if_free.md.nolink) | 指定した条件に合致する要素とその分の領域を、コンテナから削除する | C++23 |
 
 
-### 要素削除
+## 非メンバ（*Hidden friends*）関数
+### 比較演算子
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| [`erase_if`](flat_map/erase_if_free.md.nolink) | 指定した条件に合致する要素とその分の領域を、コンテナから削除する | C++23 |
+| [`operator==`](flat_map/op_equal.md.nolink)         | 左辺と右辺が等しいかの判定を行う           | C++23 |
+| `bool operator!=(const flat_map&amp;amp; x, const flat_map&amp;amp; y);` | 左辺と右辺が等しくないかの判定を行う (`==`により使用可能) | C++23 |
+| [`operator&amp;lt;=&amp;gt;`](flat_map/op_compare_3way.md.nolink) | 三方比較を行う                             | C++23 |
+| `bool operator&amp;lt;(const flat_map&amp;amp; x, const flat_map&amp;amp; y);`  | 左辺が右辺より小さいかの判定を行う  (`&amp;lt;=&amp;gt;`により使用可能) | C++23 |
+| `bool operator&amp;lt;=(const flat_map&amp;amp; x, const flat_map&amp;amp; y);` | 左辺が右辺より小さいか等しいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能) | C++23 |
+| `bool operator&amp;gt;(const flat_map&amp;amp; x, const flat_map&amp;amp; y);`  | 左辺が右辺より大きいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能) | C++23 |
+| `bool operator&amp;gt;=(const flat_map&amp;amp; x, const flat_map&amp;amp; y);` | 左辺が右辺より大きいか等しいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能) | C++23 |
+
+
+### 入れ替え
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`swap`](flat_map/swap_free.md.nolink) | 2つの`flat_map`オブジェクトを入れ替える | C++23 |
 
 
 ## 推論補助
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_map -- コードブロックの消し忘れ</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map.html"/>
      <id>82cec00a8113857dd68414dc45d1b4803cf83a74:reference/flat_map/flat_map.md</id>
      <updated>2023-04-17T18:38:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map.md b/reference/flat_map/flat_map.md
index caea672f5..b26f49554 100644
--- a/reference/flat_map/flat_map.md
+++ b/reference/flat_map/flat_map.md
@@ -155,7 +155,6 @@ namespace std {
 
 
 ### ユーザー定義型をキーとして使用する (`operator&amp;lt;=&amp;gt;`を定義)
-```
 
 #### 出力
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>