<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-27T14:47:39.478243</updated>
  <id>eca98a8b-680b-4b6c-99cd-4c4fe3bd2f9f</id>

  
    <entry>
      <title>execution -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index ff06aaaa9..c103bdf8e 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -122,7 +122,7 @@ namespace std::execution {
 | [`execution::let_error`](execution/let_error.md.nolink) | エラー完了結果から入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::let_stopped`](execution/let_stopped.md.nolink) | 停止完了を入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::bulk`](execution/bulk.md.nolink) | インデクス空間上で指定関数を連続実行 (customization point object) | C++26 |
-| [`execution::split`](execution/split.md.nolink) | 入力Senderの値を複製送信 (customization point object) | C++26 |
+| [`execution::split`](execution/split.md) | 入力Senderの値を複製回送信可能とする (customization point object) | C++26 |
 | [`execution::when_all`](execution/when_all.md) | 全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::when_all_with_variant`](execution/when_all_with_variant.md) | 複数の値完了シグネチャをもつ全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::into_variant`](execution/into_variant.md) | 複数の値完了シグネチャを単一[`variant`](/reference/variant/variant.md)型の値完了シグネチャに変換 (customization point object) | C++26 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>into_variant -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/into_variant.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/into_variant.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/into_variant.md b/reference/execution/execution/into_variant.md
index 3e912ee22..afabb4205 100644
--- a/reference/execution/execution/into_variant.md
+++ b/reference/execution/execution/into_variant.md
@@ -203,4 +203,5 @@ int main()
 
 
 ## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>on-stop-request -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/on-stop-request.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/on-stop-request.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/on-stop-request.md b/reference/execution/execution/on-stop-request.md
index 06ad7d68c..447aa6986 100644
--- a/reference/execution/execution/on-stop-request.md
+++ b/reference/execution/execution/on-stop-request.md
@@ -24,6 +24,7 @@ struct on-stop-request {
 
 ## 関連項目
 - [`execution::when_all`](when_all.md)
+- [`execution::split`](split.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>split -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/split.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/split.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/split.md b/reference/execution/execution/split.md
new file mode 100644
index 000000000..0f68960cc
--- /dev/null
+++ b/reference/execution/execution/split.md
@@ -0,0 +1,404 @@
+# split
+* execution[meta header]
+* cpo[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  struct split_t { unspecified };
+  inline constexpr split_t split{};
+}
+```
+* unspecified[italic]
+
+## 概要
+`split`は、任意の入力[Sender](sender.md)を複数回[接続(connect)](connect.md)可能とするSenderアダプタである。
+
+`split`はパイプライン記法をサポートする。
+
+
+## 効果
+説明用の型`split-env`を、インスタンス`env`に対して式[`get_stop_token`](../get_stop_token.md)`(env)`が適格かつ型[`inplace_stop_token`](/reference/stop_token/inplace_stop_token.md)をもつ型とする。
+
+説明用の式`sndr`に対して、型`Sndr`を`decltype((sndr))`とする。[`sender_in`](sender_in.md)`&amp;lt;Sndr, split-env&amp;gt; == false`のとき、呼び出し式`split(sndr)`は不適格となる。
+
+そうでなければ、呼び出し式`split(sndr)`は`sndr`が1回だけ評価されることを除いて、下記と等価。
+
+```cpp
+transform_sender(get-domain-early(sndr), make-sender(split, {}, sndr))
+```
+* transform_sender[link transform_sender.md]
+* get-domain-early[link get-domain-early.md]
+* make-sender[link make-sender.md]
+
+
+### Senderアルゴリズムタグ `split`
+説明用のSenderアルゴリズムタグ型`split-impl-tag`を空の型とする。説明用の式`sndr`に対して、式`split.transform_sender(sndr)`は下記と等価。
+
+```cpp
+auto&amp;amp;&amp;amp; [tag, _, child] = sndr;
+auto* sh_state = new shared-state{std::forward_like&amp;lt;decltype((sndr))&amp;gt;(child)};
+return make-sender(split-impl-tag(), shared-wrapper{sh_state, tag});
+```
+* make-sender[link make-sender.md]
+
+説明用の型`shared-wrapper`は、`sh_state`が指す`shared-state`オブジェクトの参照カウントを管理するクラスである。
+
+- `shared-wrapper`は[`copyable`](/reference/concepts/copyable.md)のモデルである。
+- ムーブ操作 : 移動済みオブジェクトをヌルとする。
+- コピー操作 : `sh_state-&amp;gt;inc-ref()`を呼び出して参照カウントをインクリメントする。
+- 代入操作 : Copy-And-Swap操作を行う。
+- デストラクタ : `sh_state`がヌルのときは何もしない。そうでないとき、`sh_state-&amp;gt;dec-ref()`を評価して参照カウントをデクリメントする。
+
+
+### Senderアルゴリズムタグ `split-impl-tag`
+Senderアルゴリズム動作説明用のクラステンプレート[`impls-for`](impls-for.md)に対して、下記の特殊化が定義される。
+
+```cpp
+namespace std::execution {
+  template&amp;lt;&amp;gt;
+  struct impls-for&amp;lt;split-impl-tag&amp;gt; : default-impls {
+    static constexpr auto get-state = see below;
+    static constexpr auto start = see below;
+  };
+}
+```
+* impls-for[link impls-for.md]
+* default-impls[link impls-for.md]
+* see below[italic]
+
+`impls-for&amp;lt;split-impl-tag&amp;gt;::get-state`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[]&amp;lt;class Sndr&amp;gt;(Sndr&amp;amp;&amp;amp; sndr, auto&amp;amp; rcvr) noexcept {
+  return local-state{std::forward&amp;lt;Sndr&amp;gt;(sndr), rcvr};
+}
+```
+
+`impls-for&amp;lt;split-impl-tag&amp;gt;::start`メンバは、下記の関数呼び出し演算子をもつオブジェクトで初期化される。
+
+```cpp
+template&amp;lt;class Sndr, class Rcvr&amp;gt;
+void operator()(local-state&amp;lt;Sndr, Rcvr&amp;gt;&amp;amp; state, Rcvr&amp;amp; rcvr) const noexcept;
+```
+
+効果 : `state.sh_state-&amp;gt;completed == true`のとき、`state.notify()`を評価してリターンする。そうでなければ、下記を順番に行う。
+
+- 以下を評価する。
+
+    ```cpp
+    state.on_stop.emplace(
+      get_stop_token(get_env(rcvr)),
+      on-stop-request{state.sh_state-&amp;gt;stop_src});
+    ```
+    * emplace[link /reference/optional/optional/emplace.md]
+    * get_stop_token[link ../get_stop_token.md]
+    * get_env[link get_env.md]
+    * on-stop-request[link on-stop-request.md]
+
+- 下記をアトミックに行う。
+    - `state.sh_state-&amp;gt;completed`の値`c`を読み取り
+    - `c == false`のとき、`state.sh_state-&amp;gt;waiting_state`に[`addressof`](/reference/memory/addressof.md)`(state)`を挿入する
+- `c == true`ならば、`state.notify()`を呼び出してリターンする。
+- そうではなく、[`addressof`](/reference/memory/addressof.md)`(state)`が`state.sh_state-&amp;gt;waiting_state`に最初に追加されるアイテムならば、`state.sh_state-&amp;gt;start-op()`を評価する。
+
+
+## 説明専用エンティティ
+### `local-state`クラステンプレート
+
+```cpp
+namespace std::execution {
+  struct local-state-base {                // exposition only
+    virtual ~local-state-base() = default;
+    virtual void notify() noexcept = 0;    // exposition only
+  };
+
+  template&amp;lt;class Sndr, class Rcvr&amp;gt;
+  struct local-state : local-state-base {  // exposition only
+    using on-stop-callback =               // exposition only
+      stop_callback_for_t&amp;lt;stop_token_of_t&amp;lt;env_of_t&amp;lt;Rcvr&amp;gt;&amp;gt;, on-stop-request&amp;gt;;
+
+    local-state(Sndr&amp;amp;&amp;amp; sndr, Rcvr&amp;amp; rcvr) noexcept;
+    ~local-state();
+
+    void notify() noexcept override;
+
+  private:
+    optional&amp;lt;on-stop-callback&amp;gt; on_stop;    // exposition only
+    shared-state&amp;lt;Sndr&amp;gt;* sh_state;          // exposition only
+    Rcvr* rcvr;                            // exposition only
+  };
+}
+```
+* stop_callback_for_t[link /reference/stop_token/stop_callback_for_t.md]
+* stop_token_of_t[link ../stop_token_of_t.md]
+* env_of_t[link env_of_t.md]
+* on-stop-request[link on-stop-request.md]
+* optional[link /reference/optional/optional.md]
+
+```cpp
+local-state(Sndr&amp;amp;&amp;amp; sndr, Rcvr&amp;amp; rcvr) noexcept;
+```
+
+- 効果 : 下記と等価。
+
+    ```cpp
+    auto&amp;amp; [_, data, _] = sndr;
+    this-&amp;gt;sh_state = data.sh_state.get();
+    this-&amp;gt;sh_state-&amp;gt;inc-ref();
+    this-&amp;gt;rcvr = addressof(rcvr);
+    ```
+    * addressof[link /reference/memory/addressof.md]
+
+```cpp
+~local-state();
+```
+
+- 効果 : 下記と等価。
+
+    ```cpp
+    sh_state-&amp;gt;dec-ref();
+    ```
+
+```cpp
+void notify() noexcept override;
+```
+
+- 効果 : 下記と等価。
+
+    ```cpp
+    on_stop.reset();
+    visit(
+      [this](const auto&amp;amp; tupl) noexcept -&amp;gt; void {
+        apply(
+          [this](auto tag, const auto&amp;amp;... args) noexcept -&amp;gt; void {
+            tag(std::move(*rcvr), args...);
+          },
+          tupl);
+      },
+      sh_state-&amp;gt;result);
+    ```
+    * reset()[link /reference/optional/optional/reset.md]
+    * visit[link /reference/variant/visit.md]
+    * apply[link /reference/tuple/apply.md]
+    * std::move[link /reference/utility/move.md]
+
+
+### `split-receiver`クラステンプレート
+
+```cpp
+namespace std::execution {
+  template&amp;lt;class Sndr&amp;gt;
+  struct split-receiver {  // exposition only
+    using receiver_concept = receiver_t;
+
+    template&amp;lt;class Tag, class... Args&amp;gt;
+    void complete(Tag, Args&amp;amp;&amp;amp;... args) noexcept {  // exposition only
+      using tuple_t = decayed-tuple&amp;lt;Tag, Args...&amp;gt;;
+      try {
+        sh_state-&amp;gt;result.template emplace&amp;lt;tuple_t&amp;gt;(Tag(), std::forward&amp;lt;Args&amp;gt;(args)...);
+      } catch (...) {
+        using tuple_t = tuple&amp;lt;set_error_t, exception_ptr&amp;gt;;
+        sh_state-&amp;gt;result.template emplace&amp;lt;tuple_t&amp;gt;(set_error, current_exception());
+      }
+      sh_state-&amp;gt;notify();
+    }
+
+    template&amp;lt;class... Args&amp;gt;
+    void set_value(Args&amp;amp;&amp;amp;... args) &amp;amp;&amp;amp; noexcept {
+      complete(execution::set_value, std::forward&amp;lt;Args&amp;gt;(args)...);
+    }
+
+    template&amp;lt;class Error&amp;gt;
+    void set_error(Error&amp;amp;&amp;amp; err) &amp;amp;&amp;amp; noexcept {
+      complete(execution::set_error, std::forward&amp;lt;Error&amp;gt;(err));
+    }
+
+    void set_stopped() &amp;amp;&amp;amp; noexcept {
+      complete(execution::set_stopped);
+    }
+
+    struct env {                     // exposition only
+      shared-state&amp;lt;Sndr&amp;gt;* sh-state;  // exposition only
+
+      inplace_stop_token query(get_stop_token_t) const noexcept {
+        return sh-state-&amp;gt;stop_src.get_token();
+      }
+    };
+
+    env get_env() const noexcept {
+      return env{sh_state};
+    }
+
+    shared-state&amp;lt;Sndr&amp;gt;* sh_state;    // exposition only
+  };
+}
+```
+* receiver_t[link receiver.md]
+* decayed-tuple[link decayed-tuple.md]
+* template emplace[link /reference/variant/variant/emplace.md]
+* set_error_t[link set_error.md]
+* exception_ptr[link /reference/exception/exception_ptr.md]
+* current_exception()[link /reference/exception/current_exception.md]
+* execution::set_value[link set_value.md]
+* execution::set_error[link set_error.md]
+* execution::set_stopped[link set_stopped.md]
+* inplace_stop_token[link /reference/stop_token/inplace_stop_token.md]
+* get_stop_token_t[link ../get_stop_token.md]
+* get_token()[link /reference/stop_token/inplace_stop_source/get_token.md]
+
+
+### `shared-state`クラステンプレート
+
+```cpp
+namespace std::execution {
+  template&amp;lt;class Sndr&amp;gt;
+  struct shared-state {
+    using variant-type = see below;     // exposition only
+    using state-list-type = see below;  // exposition only
+
+    explicit shared-state(Sndr&amp;amp;&amp;amp; sndr);
+
+    void start-op() noexcept;           // exposition only
+    void notify() noexcept;             // exposition only
+    void inc-ref() noexcept;            // exposition only
+    void dec-ref() noexcept;            // exposition only
+
+    inplace_stop_source stop_src{};     // exposition only
+    variant-type result{};              // exposition only
+    state-list-type waiting_states;     // exposition only
+    atomic&amp;lt;bool&amp;gt; completed{false};      // exposition only
+    atomic&amp;lt;size_t&amp;gt; ref_count{1};        // exposition only
+    connect_result_t&amp;lt;Sndr, split-receiver&amp;lt;Sndr&amp;gt;&amp;gt; op_state;  // exposition only
+  };
+}
+```
+* inplace_stop_source[link /reference/stop_token/inplace_stop_source.md]
+* atomic[link /reference/atomic/atomic.md]
+* connect_result_t[link connect_result_t.md]
+* see below[italic]
+
+- 説明用のパック`Sigs`を[`completion_signatures_of_t`](completion_signatures_of_t.md)`&amp;lt;Sndr&amp;gt;`による[`completion_signatures`](completion_signatures.md)特殊化のテンプレートパラメータと定義する。説明用の型`Tag`とパック`Args`に対して、説明用のエイリアステンプレート`as-tuple&amp;lt;Tag(Args...)&amp;gt;`を[`decayed-tuple`](decayed-tuple.md)`&amp;lt;Tag, Args...&amp;gt;`と定義する。型`variant-type`は下記定義において重複削除した型となる。
+
+    ```cpp
+    variant&amp;lt;tuple&amp;lt;set_stopped_t&amp;gt;, tuple&amp;lt;set_error_t, exception_ptr&amp;gt;, as-tuple&amp;lt;Sigs&amp;gt;...&amp;gt;
+    ```
+    * variant[link /reference/variant/variant.md]
+    * tuple[link /reference/tuple/tuple.md]
+    * set_stopped_t[link set_stopped.md]
+    * set_error_t[link set_error.md]
+    * exception_ptr[link /reference/exception/exception_ptr.md]
+
+- 型`state-list-type`を、`local-state-base`オブジェクトへのポインタのリストを格納し、アトミックに要素挿入できる型とする。
+
+```cpp
+explicit shared-state(Sndr&amp;amp;&amp;amp; sndr);
+```
+
+- 効果 : `op_state`を[`connect`](connect.md)`(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;Sndr&amp;gt;(sndr), split-receiver{this})`の結果で初期化する。
+- 事後条件 : `waiting_states`が空、かつ`completed == false`
+
+```cpp
+void start-op() noexcept;
+```
+
+- 効果 : `inc-ref()`を評価する。`stop_src.`[`stop_requested()`](/reference/stop_token/inplace_stop_source/stop_requested.md) `== ture`のとき`notify()`を評価する。そうでなければ、[`start`](start.md)`(op_state)`を評価する。
+
+```cpp
+void notify() noexcept;
+```
+
+- 効果 : 下記をアトミックに行い、ローカル変数`prior_states`の各ポインタ`p`に対して`p-&amp;gt;notify()`を評価し、最後に`dec-ref()`を評価する。
+    - `completed`に`true`を設定し、
+    - `waiting_states`を空のリストと交換し、古い値をローカル変数`prior_states`に格納する。
+
+```cpp
+void inc-ref() noexcept;
+```
+
+- 効果 : `ref_count`をインクリメントする。
+
+```cpp
+void dec-ref() noexcept;
+```
+
+- 効果 : `ref_count`をデクリメントする。`ref_count`の新たな値が`0`のとき、`delete this`を呼び出す。
+- 同期操作 : `dec-ref()`の評価が`ref_count`を値`0`にデクリメントしないとき、`ref_count`を値`0`へデクリメントする`dec-ref()`の評価に対して同期する。
+
+
+## カスタマイゼーションポイント
+Senderアルゴリズム構築時に、[Sender](sender.md)`sndr`に[関連付けられた実行ドメイン](get-domain-early.md)に対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](default_domain.md)では`split.transform_sender(sndr)`が呼ばれ、前述仕様通りのSenderへと変換される。
+
+
+## 例
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+int main()
+{
+  { // 関数呼び出し
+    ex::sender auto snd0 = ex::just(21);
+    ex::sender auto snd1 = ex::then(snd0, [](int n) {
+        std::println(&amp;#34;then&amp;#34;);
+        return 2 * n;
+      });
+    ex::sender auto sndr = ex::split(snd1);
+
+    auto [val1] = std::this_thread::sync_wait(sndr).value();
+    std::println(&amp;#34;{}&amp;#34;, val1);
+    auto [val2] = std::this_thread::sync_wait(sndr).value();
+    std::println(&amp;#34;{}&amp;#34;, val2);
+  }
+
+  { // パイプライン記法
+    ex::sender auto sndr =
+      ex::just(21)
+      | ex::then([](int n) {
+          std::println(&amp;#34;then&amp;#34;);
+          return 2 * n;
+        })
+      | ex::split();
+
+    auto [val1] = std::this_thread::sync_wait(sndr).value();
+    std::println(&amp;#34;{}&amp;#34;, val1);
+    auto [val2] = std::this_thread::sync_wait(sndr).value();
+    std::println(&amp;#34;{}&amp;#34;, val2);
+  }
+}
+```
+* ex::split[color ff0000]
+* ex::sender[link sender.md]
+* ex::just[link just.md]
+* ex::then[link then.md]
+* std::this_thread::sync_wait[link ../this_thread/sync_wait.md]
+* value()[link /reference/optional/optional/value.md]
+
+### 出力
+```
+then
+42
+42
+then
+42
+42
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>then -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/then.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/then.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/then.md b/reference/execution/execution/then.md
index bdbbdb2a6..257d738ed 100644
--- a/reference/execution/execution/then.md
+++ b/reference/execution/execution/then.md
@@ -127,4 +127,5 @@ C++
 
 
 ## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>when_all -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/when_all.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/when_all.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/when_all.md b/reference/execution/execution/when_all.md
index d22c00b32..44a365383 100644
--- a/reference/execution/execution/when_all.md
+++ b/reference/execution/execution/when_all.md
@@ -16,7 +16,7 @@ namespace std::execution {
 `when_all`は、複数の入力[Sender](sender.md)が全て完了するまで待機するSenderアダプタである。
 
 `when_all`は全ての入力Senderが[値完了シグネチャ](set_value.md)を1個だけ持つことを要求する。
-値完了シグネチャが複数存在する場合は[`when_all_with_variant`](when_all_with_variant.md)アルゴリズムを利用する
+値完了シグネチャが複数存在する場合は[`when_all_with_variant`](when_all_with_variant.md)アルゴリズムを利用する。
 
 - 入力Sender全てが値完了のとき、全ての値完了結果を[`tuple`](/reference/tuple/tuple.md)に結合して値完了操作を行う。
 - いずれかがエラー完了のとき、同エラー値をもってエラー完了操作を行う。このとき停止要求が作成される。
@@ -319,6 +319,7 @@ variant&amp;lt;none-such, copy-fail, Es...&amp;gt;
     ```
     * set_stopped[link set_stopped.md]
     * reset()[link /reference/optional/optional/reset.md]
+    * std::move[link /reference/utility/move.md]
 
 
 ## カスタマイゼーションポイント
@@ -390,8 +391,8 @@ struct MySender {
     void start() noexcept {
       auto stok = ex::get_stop_token(ex::get_env(rcvr_));
       if (stok.stop_requested()) {
-   　　  // 接続先Receiverにおいて停止要求が行われていれば
-        // MySenderも停止完了により早期リターンする
+        // 接続先Receiverにおいて停止要求が行われていれば
+        // 非同期操作も停止完了により早期リターンさせる
         std::println(&amp;#34;{}: set_stopped&amp;#34;, val_);
         ex::set_stopped(std::move(rcvr_));
         return;
@@ -478,4 +479,5 @@ error=-2
 
 
 ## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>when_all_with_variant -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/when_all_with_variant.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/when_all_with_variant.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/when_all_with_variant.md b/reference/execution/execution/when_all_with_variant.md
index 7aef2d143..fb413fec8 100644
--- a/reference/execution/execution/when_all_with_variant.md
+++ b/reference/execution/execution/when_all_with_variant.md
@@ -16,7 +16,7 @@ namespace std::execution {
 `when_all_with_variant`は、複数の入力[Sender](sender.md)が全て完了するまで待機するSenderアダプタである。
 
 `when_all_with_variant`は入力Senderが複数の[値完了シグネチャ](set_value.md)を持つケースに対応する。
-全入力Senderの値完了シグネチャが1個だけの場合は[`when_all`](when_all.md)アルゴリズムを利用する
+全入力Senderの値完了シグネチャが1個だけの場合は[`when_all`](when_all.md)アルゴリズムを利用する。
 
 - 入力Sender全てが値完了のとき、全ての値完了結果を[`variant`](/reference/variant/variant.md)の[`tuple`](/reference/tuple/tuple.md)に結合して値完了操作を行う。
 - いずれかがエラー完了のとき、同エラー値をもってエラー完了操作を行う。このとき停止要求が作成される。
@@ -182,4 +182,5 @@ int main()
 
 
 ## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left -- fold_left, fold_right : 箇条書きの表示崩れを修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.html"/>
      <id>9094beb997b31879c2fe78a6249d4cddc5163ba6:reference/algorithm/ranges_fold_left.md</id>
      <updated>2025-05-27T17:59:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left.md b/reference/algorithm/ranges_fold_left.md
index 8c7651f38..cd35caa38 100644
--- a/reference/algorithm/ranges_fold_left.md
+++ b/reference/algorithm/ranges_fold_left.md
@@ -152,6 +152,7 @@ concept indirectly-binary-left-foldable =
 
     - すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
     - また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+
 - (1), (2) :
     - C++26 : 引数として波カッコ初期化`{}`を受け付ける
         ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_right -- fold_left, fold_right : 箇条書きの表示崩れを修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.html"/>
      <id>9094beb997b31879c2fe78a6249d4cddc5163ba6:reference/algorithm/ranges_fold_right.md</id>
      <updated>2025-05-27T17:59:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_right.md b/reference/algorithm/ranges_fold_right.md
index 2c418690b..89531d1fd 100644
--- a/reference/algorithm/ranges_fold_right.md
+++ b/reference/algorithm/ranges_fold_right.md
@@ -149,6 +149,7 @@ return accum;
 
     - すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
     - また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+
 - (1), (2) :
     - C++26 : 引数として波カッコ初期化`{}`を受け付ける
         ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- ranges::count, equal_range, lower_bound : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>1f87d6a9e341dd8e5fe7a0f74d7545a804e9895a:reference/algorithm/ranges_count.md</id>
      <updated>2025-05-27T17:23:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 0c3504815..294f0855b 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -142,6 +142,43 @@ int main() {
 count of {1,2}: 2
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct Item {
+  int id;
+  std::string label;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, &amp;#34;foo&amp;#34;},
+    {3, &amp;#34;bar&amp;#34;},
+    {5, &amp;#34;foo&amp;#34;},
+    {2, &amp;#34;baz&amp;#34;},
+  };
+
+  // メンバ変数ポインタを使って label==&amp;#34;foo&amp;#34; の要素数を数える
+  int n1 = std::ranges::count(v, std::string(&amp;#34;foo&amp;#34;), &amp;amp;Item::label);
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of label==\&amp;#34;foo\&amp;#34;: &amp;#34; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; std::endl;
+
+  // ラムダ式を使って id==1 の要素数を数える
+  int n2 = std::ranges::count(v, 1, [](const Item&amp;amp; p) { return p.id; });
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of id==1: &amp;#34; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count[color ff0000]
+
+#### 出力
+```
+count of label==&amp;#34;foo&amp;#34;: 2
+count of id==1: 2
+```
+
 
 ## 実装例
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- ranges::count, equal_range, lower_bound : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>1f87d6a9e341dd8e5fe7a0f74d7545a804e9895a:reference/algorithm/ranges_equal_range.md</id>
      <updated>2025-05-27T17:23:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index 225f563da..fa5266fb4 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -182,6 +182,62 @@ int main() {
 3,4
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct X {
+  int id;
+  std::string name;
+};
+
+int main() {
+  std::vector&amp;lt;X&amp;gt; v = {
+    {1, &amp;#34;Carol&amp;#34;},
+    {3, &amp;#34;Alice&amp;#34;},
+    {4, &amp;#34;Bob&amp;#34;},
+    {4, &amp;#34;Bob&amp;#34;},
+    {5, &amp;#34;Eve&amp;#34;},
+    {6, &amp;#34;Dave&amp;#34;}
+  };
+  const std::string key = &amp;#34;Bob&amp;#34;;
+
+  // メンバ変数nameをキーとして検索
+  // 1. メンバ変数ポインタを使う方法
+  auto result1 = std::ranges::equal_range(v, key, {}, &amp;amp;X::name);
+  std::cout &amp;lt;&amp;lt; &amp;#34;[メンバ変数ポインタ]&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const X&amp;amp; x : result1) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; x.id &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; x.name &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 2. ラムダ式を使う方法
+  auto result2 = std::ranges::equal_range(
+    v,
+    key,
+    {},
+    [](const X&amp;amp; x) { return x.name; }
+);
+  std::cout &amp;lt;&amp;lt; &amp;#34;[ラムダ式]&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const X&amp;amp; x : result2) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; x.id &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; x.name &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::equal_range[color ff0000]
+
+#### 出力
+```
+[メンバ変数ポインタ]
+id=4 name=Bob
+id=4 name=Bob
+[ラムダ式]
+id=4 name=Bob
+id=4 name=Bob
+```
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- ranges::count, equal_range, lower_bound : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>1f87d6a9e341dd8e5fe7a0f74d7545a804e9895a:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2025-05-27T17:23:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
index 9fb2c5659..9b4d1be4f 100644
--- a/reference/algorithm/ranges_lower_bound.md
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -230,6 +230,62 @@ int main() {
 pos=2
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct X {
+  int id;
+  std::string name;
+};
+
+int main() {
+  std::vector&amp;lt;X&amp;gt; v = {
+    {1, &amp;#34;Carol&amp;#34;},
+    {3, &amp;#34;Alice&amp;#34;},
+    {4, &amp;#34;Bob&amp;#34;},
+    {5, &amp;#34;Eve&amp;#34;},
+    {6, &amp;#34;Dave&amp;#34;}
+  };
+  const std::string key = &amp;#34;Bob&amp;#34;;
+
+  // nameメンバ変数をキーとして検索
+  // 1. メンバ変数ポインタを使う方法
+  auto it1 = std::ranges::lower_bound(v, key, {}, &amp;amp;X::name);
+  if (it1 != v.end() &amp;amp;&amp;amp; it1-&amp;gt;name == key) {
+    std::size_t pos = std::ranges::distance(v.begin(), it1);
+    std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it1-&amp;gt;id
+              &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it1-&amp;gt;name
+              &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 2. ラムダ式を使う方法
+  auto it2 = std::ranges::lower_bound(
+    v,
+    key,
+    {},
+    [](const X&amp;amp; x) { return x.name; }
+  );
+  if (it2 != v.end() &amp;amp;&amp;amp; it2-&amp;gt;name == key) {
+    std::size_t pos = std::ranges::distance(v.begin(), it2);
+    std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it2-&amp;gt;id
+              &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it2-&amp;gt;name
+              &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::lower_bound[color ff0000]
+* std::ranges::distance[link /reference/iterator/ranges_distance.md]
+
+#### 出力
+```
+id=4 name=Bob pos=2
+id=4 name=Bob pos=2
+```
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- ranges::find : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>0dfcb84d27bb4a6a4eed9c75a13522415335c80a:reference/algorithm/ranges_find.md</id>
      <updated>2025-05-27T17:08:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 7f76d5976..41dfe9d96 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -102,6 +102,62 @@ int main() {
 found: 1
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct Item {
+  int id;
+  std::string name;
+};
+
+int main() {
+  std::vector&amp;lt;Item&amp;gt; v = {
+    {1, &amp;#34;aaa&amp;#34;},
+	{3, &amp;#34;bbb&amp;#34;},
+	{5, &amp;#34;ccc&amp;#34;}
+  };
+
+  // メンバ変数ポインタを使って特定のメンバ変数で検索
+  {
+    auto it = std::ranges::find(
+      v,
+      std::string(&amp;#34;bbb&amp;#34;),
+      &amp;amp;Item::name
+    );
+    if (it == v.end()) {
+      std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+    } else {
+      std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; it-&amp;gt;name &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // ラムダ式で特定のメンバ変数を検索
+  {
+    auto it = std::ranges::find(
+      v,
+      std::string(&amp;#34;bbb&amp;#34;),
+      [](const Item&amp;amp; x) { return x.name; }
+    );
+    if (it == v.end()) {
+      std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+    } else {
+      std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; it-&amp;gt;name &amp;lt;&amp;lt; std::endl;
+    }
+  } 
+}
+```
+* std::ranges::find[color ff0000]
+
+#### 出力
+```
+found: 3,bbb
+found: 3,bbb
+```
+
 ### 波カッコ初期化を入力として使用する (C++26)
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- find_last, contains : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains.html"/>
      <id>1350ce71a23944efb2f73e7eabded20f52930d17:reference/algorithm/ranges_contains.md</id>
      <updated>2025-05-27T16:52:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains.md b/reference/algorithm/ranges_contains.md
index be782ad08..2f3e2ded3 100644
--- a/reference/algorithm/ranges_contains.md
+++ b/reference/algorithm/ranges_contains.md
@@ -6,16 +6,59 @@
 
 ```cpp
 namespace ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-    constexpr bool contains(I first, S last, const T&amp;amp; value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires
-      indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-    constexpr bool contains(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (2) C++23
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (2) C++26
 }
 ```
 
@@ -25,25 +68,72 @@ namespace ranges {
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
 
+
 ## 戻り値
 ```cpp
 ranges::find(std::move(first), last, value, proj) != last
 ```
 * ranges::find[link ranges_find.md]
 
+
 ## 計算量
 最大で `last - first` 回比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::ranges::contains(r, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;print&amp;gt;
 #include &amp;lt;array&amp;gt;
 
 int main() {
-  constexpr std::array v = { 3, 1, 4 };
-  if (std::ranges::contains(v, 1)) {
+  constexpr std::array ar = { 3, 1, 4 };
+  if (std::ranges::contains(ar, 1)) {
+    std::println(&amp;#34;found&amp;#34;);
+  } else {
+    std::println(&amp;#34;not found&amp;#34;);
+  }
+}
+```
+* std::ranges::contains[color ff0000]
+
+#### 出力
+```
+found
+```
+
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+	{1, 2},
+	{3, 4},
+	{5, 6}
+  };
+
+  bool found = std::ranges::contains(v, {3, 4});
+  if (found) {
     std::println(&amp;#34;found&amp;#34;);
   } else {
     std::println(&amp;#34;not found&amp;#34;);
@@ -52,7 +142,7 @@ int main() {
 ```
 * std::ranges::contains[color ff0000]
 
-### 出力
+#### 出力
 ```
 found
 ```
@@ -90,3 +180,5 @@ inline constexpr contains_impl contains;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last -- find_last, contains : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last.html"/>
      <id>1350ce71a23944efb2f73e7eabded20f52930d17:reference/algorithm/ranges_find_last.md</id>
      <updated>2025-05-27T16:52:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last.md b/reference/algorithm/ranges_find_last.md
index 47afea8da..a2c7878bc 100644
--- a/reference/algorithm/ranges_find_last.md
+++ b/reference/algorithm/ranges_find_last.md
@@ -10,21 +10,55 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr ranges::subrange&amp;lt;I&amp;gt;
     find_last(I first,
               S last,
               const T&amp;amp; value,
               Proj proj = {}); // (1) C++23
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr ranges::subrange&amp;lt;I&amp;gt;
+    find_last(I first,
+              S last,
+              const T&amp;amp; value,
+              Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
             class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
     find_last(R&amp;amp;&amp;amp; r,
               const T&amp;amp; value,
               Proj proj = {}); // (2) C++23
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last(R&amp;amp;&amp;amp; r,
+              const T&amp;amp; value,
+              Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -50,31 +84,82 @@ namespace std::ranges {
 最大で `last - first` 回比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::ranges::find_last(r, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;iostream&amp;gt;
 
 int main() {
-  constexpr std::array v = { 3, 1, 4, 1, 5 };
-  const auto result = std::ranges::find_last(v, 1);
-  if (result.begin() == v.end()) {
+  constexpr std::array ar = { 3, 1, 4, 1, 5 };
+  const std::ranges::subrange result = std::ranges::find_last(ar, 1);
+  if (result.begin() == ar.end()) {
     std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
   } else {
     std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
-    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(ar.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
   }
 }
 ```
 * std::ranges::find_last[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Point&amp;amp; p) {
+  return os &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; p.y;
+}
+
+int main() {
+  constexpr std::array&amp;lt;Point, 3&amp;gt; ar = {{
+    {1, 2},
+	{3, 4},
+	{5, 6}
+  }};
+
+  const std::ranges::subrange result = std::ranges::find_last(ar, {3, 4});
+  if (result.begin() == ar.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(ar.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last[color ff0000]
+
+#### 出力
+```
+found: 3,4
+  pos: 1
+```
+
 
 ## バージョン
 ### 言語
@@ -87,4 +172,8 @@ found: 1
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 ## 参照
-- [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P1223R5 `find_last`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3217R0 Adjoints to &amp;#34;Enabling list-initialization for algorithms&amp;#34;: `find_last`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3217r0.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
+    - 関連文書：
+        - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>