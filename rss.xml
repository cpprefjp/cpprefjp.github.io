<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-25T03:00:46.354837</updated>
  <id>64c59b8e-d050-47de-887a-a98d42b15eab</id>

  
    <entry>
      <title>range_formatter -- range_formatter : サンプルコードのコンパイルが通らなさそうなので見直し</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter.html"/>
      <id>373f49da92fb9c34115279a210f29067b6259e35:reference/format/range_formatter.md</id>
      <updated>2023-01-25T11:56:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter.md b/reference/format/range_formatter.md
index 5b0cec189..7f3190b22 100644
--- a/reference/format/range_formatter.md
+++ b/reference/format/range_formatter.md
@@ -41,7 +41,31 @@ namespace std {
 #include &amp;lt;vector&amp;gt;
 
 template &amp;lt;class T&amp;gt;
-class std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; : public std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; {
+class MyVector {
+  std::vector&amp;lt;T&amp;gt; v_;
+public:
+  using base_type = std::vector&amp;lt;T&amp;gt;;
+  using iterator = typename base_type::iterator;
+  using const_iterator = typename base_type::iterator;
+  using value_type = typename base_type::value_type;
+  using reference = typename base_type::reference;
+  using const_reference = typename base_type::const_reference;
+
+  MyVector() = default;
+  MyVector(std::initializer_list&amp;lt;T&amp;gt; init)
+      : v_(init.begin(), init.end()) {}
+
+  iterator begin() { v_.begin(); }
+  const_iterator begin() const { v_.begin(); }
+
+  iterator end() { v_.end(); }
+  const_iterator end() const { v_.end(); }
+
+  const std::vector&amp;lt;T&amp;gt;&amp;amp; base() const { return v_; }
+};
+
+template &amp;lt;class T&amp;gt;
+class std::range_formatter&amp;lt;MyVector&amp;lt;T&amp;gt;&amp;gt; : public std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; {
   bool is_colon = false;
   using base_type = std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt;;
 public:
@@ -63,7 +87,7 @@ public:
   // format()関数は書式の情報をもたない。
   // parse()関数で解析した書式をメンバ変数で保持しておいて、
   // それをもとに書式化する
-  auto format(const std::vector&amp;lt;T&amp;gt;&amp;amp; v, std::format_context&amp;amp; fctx) const {
+  auto format(const MyVector&amp;lt;T&amp;gt;&amp;amp; v, std::format_context&amp;amp; fctx) const {
     if (is_colon) {
       auto out = fctx.out();
       bool is_first = true;
@@ -80,10 +104,12 @@ public:
       }
       return out;
     }
-    return base_type::format(v, fctx);
+    return base_type::format(v.base(), fctx);
   }
 };
 
+#include &amp;lt;cstdint&amp;gt;
+
 int main()
 {
   std::vector&amp;lt;std::uint8_t&amp;gt; v = {0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- move_only_function/op_constructor: 全オーバーロードの例示コード追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function/op_constructor.html"/>
      <id>63e429d33d1a3e2f10ecbfe657d31a3c5b0eb41e:reference/functional/move_only_function/op_constructor.md</id>
      <updated>2023-01-25T11:29:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function/op_constructor.md b/reference/functional/move_only_function/op_constructor.md
index 1635fa0f5..d5bd1e25b 100644
--- a/reference/functional/move_only_function/op_constructor.md
+++ b/reference/functional/move_only_function/op_constructor.md
@@ -24,7 +24,12 @@ explicit move_only_function(in_place_type_t&amp;lt;T&amp;gt;, initializer_list&amp;lt;U&amp;gt;, Args&amp;amp;&amp;amp;...);
 `move_only_function`オブジェクトを構築する。
 
 
-`move_only_function`クラステンプレートパラメータのnoexcept例外指定 *noex* 特殊化に応じて、説明用の`bool`型テンプレート定数`is-callable-from&amp;lt;VT&amp;gt;`を下記のように定義する :
+`move_only_function`クラステンプレートパラメータのCV修飾子 *cv*, 参照修飾子 *ref*, noexcept例外指定 *noex* に応じて、説明用のプレースホルダ *inv-quals* を次のように定義する :
+
+- *ref* が空（参照修飾無し）ならば、*cv*`&amp;amp;`
+- そうでなければ、*cv* *ref*
+
+また、説明用の`bool`型テンプレート定数`is-callable-from&amp;lt;VT&amp;gt;`を下記のように定義する :
 
 - *noex* が`true`のとき : [`is_nothrow_invocable_r_v`](/reference/type_traits/is_nothrow_invocable_r.md)`&amp;lt;R, VT /*cv*/ /*ref*/, ArgTypes...&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_invocable_r_v`](/reference/type_traits/is_nothrow_invocable_r.md)`&amp;lt;R, VT /*inv-quals*/, ArgTypes...&amp;gt;`
 - *noex* が`false`のとき : [`is_invocable_r_v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, VT /*cv*/ /*ref*/, ArgTypes...&amp;gt; &amp;amp;&amp;amp;` [`is_invocable_r_v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, VT /*inv-quals*/, ArgTypes...&amp;gt;`
@@ -76,8 +81,10 @@ explicit move_only_function(in_place_type_t&amp;lt;T&amp;gt;, initializer_list&amp;lt;U&amp;gt;, Args&amp;amp;&amp;amp;...);
 ## 例
 ```cpp example
 #include &amp;lt;cassert&amp;gt;
-#include &amp;lt;iostream&amp;gt;
 #include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;numeric&amp;gt;
+#include &amp;lt;utility&amp;gt;
 
 struct ident_functor {
   int operator()(int x) const
@@ -89,77 +96,88 @@ int ident_func(int x)
 
 struct X {
   int value;
-  X() : value(3) {}
 
-  int ident_member_func(int x) const
-  { return x; }
+  int add_member_func(int x) const
+  { return value + x; }
 };
 
+struct add_functor {
+  int value;
+
+  add_functor(int v) : value(v) {}
+  add_functor(std::initializer_list&amp;lt;int&amp;gt; lst, int iv)
+    : value(std::accumulate(lst.begin(), lst.end(), iv)) {}
+
+  int operator()(int x) const
+  { return value + x; }
+};
+
+
 int main()
 {
-  // (1)
-  // デフォルトコンストラクタ
+  // (1) デフォルトコンストラクタ
+  // (2) ヌルポインタを受け取るコンストラクタ
   // 空のmove_only_functionオブジェクトを作る
   {
-    std::move_only_function&amp;lt;int(int)&amp;gt; f;
-    assert(!f);
-  }
-
-  // (2)
-  // ヌルポインタを受け取るコンストラクタ
-  // デフォルトコンストラクタと同様、空のmove_only_functionオブジェクトを作る
-  {
-    std::move_only_function&amp;lt;int(int)&amp;gt; f = nullptr;
-    assert(!f);
+    std::move_only_function&amp;lt;int(int)&amp;gt; f1;
+    assert(!f1);
+    std::move_only_function&amp;lt;int(int)&amp;gt; f2 = nullptr;
+    assert(!f2);
   }
 
-  // (3)
-  // ムーブ構築
+  // (3) ムーブ構築
   {
     std::move_only_function&amp;lt;int(int)&amp;gt; f = ident_functor();
     std::move_only_function&amp;lt;int(int)&amp;gt; g = std::move(f);
+    assert(g &amp;amp;&amp;amp; !f);
 
     int result = g(1);
     std::cout &amp;lt;&amp;lt; &amp;#34;(3) : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
 
-  // (4)
-  // 関数ポインタを受け取って構築
+  // (4) 関数ポインタを受け取って構築
   {
     std::function&amp;lt;int(int)&amp;gt; f = ident_func;
 
     int result = f(1);
     std::cout &amp;lt;&amp;lt; &amp;#34;(4) function pointer : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
-
-  // (4)
-  // 関数オブジェクトを受け取って構築
+  // (4) 関数オブジェクトを受け取って構築
   {
     std::function&amp;lt;int(int)&amp;gt; f = ident_functor();
 
     int result = f(1);
     std::cout &amp;lt;&amp;lt; &amp;#34;(4) function object : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
-
-  // (4)
-  // メンバ関数ポインタを受け取った構築
+  // (4) メンバ関数ポインタを受け取った構築
   {
-    std::function&amp;lt;int(const X&amp;amp;, int)&amp;gt; f = &amp;amp;X::ident_member_func;
+    std::function&amp;lt;int(const X&amp;amp;, int)&amp;gt; f = &amp;amp;X::add_member_func;
 
-    X x;
+    X x{2};
     int result = f(x, 1);
     std::cout &amp;lt;&amp;lt; &amp;#34;(4) member function pointer : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
-
-  // (4)
-  // メンバ変数ポインタを受け取った構築
+  // (4) メンバ変数ポインタを受け取った構築
   {
     std::function&amp;lt;int(const X&amp;amp;)&amp;gt; f = &amp;amp;X::value;
-
-    X x;
+    X x{2};
     int result = f(x);
     std::cout &amp;lt;&amp;lt; &amp;#34;(4) member variable pointer : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
   }
+
+  // (5) 引数リストによる直接構築コンストラクタ
+  {
+    std::move_only_function&amp;lt;int(int)&amp;gt; f(std::in_place_type&amp;lt;add_functor&amp;gt;, 2);
+    int result = f(1);
+    std::cout &amp;lt;&amp;lt; &amp;#34;(5) : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+  }
+
+  // (6) initializer_list＋引数リストによる直接構築コンストラクタ
+  {
+    std::move_only_function&amp;lt;int(int)&amp;gt; f(std::in_place_type&amp;lt;add_functor&amp;gt;, std::initializer_list&amp;lt;int&amp;gt;{1, 2, 3}, 4);
+    int result = f(5);
+    std::cout &amp;lt;&amp;lt; &amp;#34;(6) : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+  }
 }
 ```
 * std::move[link /reference/utility/move.md]
@@ -169,8 +187,10 @@ int main()
 (3) : 1
 (4) function pointer : 1
 (4) function object : 1
-(4) member function pointer : 1
-(4) member variable pointer : 3
+(4) member function pointer : 3
+(4) member variable pointer : 2
+(5) : 3
+(6) : 15
 ```
 
 
@@ -180,7 +200,7 @@ int main()
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): ??
+- [GCC](/implementation.md#gcc): 12.1
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unreachable -- utility/unreachable: 微調整</title>
      <link href="https://cpprefjp.github.io/reference/utility/unreachable.html"/>
      <id>da6808523e7c9835d8383ecb2480e4368a26fccb:reference/utility/unreachable.md</id>
      <updated>2023-01-25T10:47:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/unreachable.md b/reference/utility/unreachable.md
index 9ba4c982d..90ea2d775 100644
--- a/reference/utility/unreachable.md
+++ b/reference/utility/unreachable.md
@@ -15,7 +15,7 @@ namespace std {
 
 
 ## 事前条件
-`true`==`false`
+`false`==`true`
 
 
 ## 備考
@@ -44,9 +44,9 @@ int flip(int x)
 
 int main()
 {
-  std::cout &amp;lt;&amp;lt; f(0) &amp;lt;&amp;lt; std::endl;
-  std::cout &amp;lt;&amp;lt; f(1) &amp;lt;&amp;lt; std::endl;
-  // f(2)呼び出しは未定義動作
+  std::cout &amp;lt;&amp;lt; flip(0) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; flip(1) &amp;lt;&amp;lt; std::endl;
+  // 例えば f(2) 呼び出しは未定義動作となる。
 }
 ```
 * std::unreachable[color ff0000]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_only_function -- move_only_function: 推論補助を定義しない旨を明記</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function.html"/>
      <id>684d1f03ad7dfc7059d79909f078182c3bc58266:reference/functional/move_only_function.md</id>
      <updated>2023-01-25T10:14:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function.md b/reference/functional/move_only_function.md
index 448d26961..1d7619561 100644
--- a/reference/functional/move_only_function.md
+++ b/reference/functional/move_only_function.md
@@ -6,7 +6,8 @@
 
 ```cpp
 namespace std {
-  template&amp;lt;class... S&amp;gt; class move_only_function; // 宣言のみ
+  template&amp;lt;class... S&amp;gt;
+  class move_only_function; // 宣言のみ
 
   template&amp;lt;class R, class... ArgTypes&amp;gt;
   class move_only_function&amp;lt;R(ArgTypes...) /*cv*/ /*ref*/ noexcept(/*noex*/)&amp;gt;;
@@ -26,12 +27,13 @@ namespace std {
 [`std::function`](function.md)と比べて、`std::move_only_function`は下記の特徴をもつ。
 
 - ムーブのみ対応。コピー不可。
-- const性を正しく伝搬する。
 - 関数型のCV修飾／参照修飾／noexcept例外指定をサポートする。
+    - const性などを正しく伝搬することでバグ発生リスクを軽減する
 - [`target_type`](function/target_type.md)型と[`target()`](function/target.md)を提供しない。
     - 実行時型情報（RTTI）非依存
 - [関数呼び出し](move_only_function/op_call.md)は強い事前条件を持つ。
     - 関数呼び出し時のnullチェックが要求されない
+- クラステンプレート引数の[推論補助](/lang/cpp17/type_deduction_for_class_templates.md)を提供しない。
 
 
 ## メンバ関数
@@ -241,3 +243,4 @@ int main()
 - [P0288R9 move_only_function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0288r9.html)
 - [N4348 Making `std::function` safe for concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html)
     - `std::function`のconst性伝搬に関して、スレッドセーフ保証の観点からの問題指摘。
+- [Why does C++23 std::move_only_function not have deduction guides?](https://stackoverflow.com/questions/69509236/why-does-c23-stdmove-only-function-not-have-deduction-guides)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>range_formatter -- コード修飾ミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter.html"/>
      <id>258f393aeb27077ec21225cc177df1722c7529e5:reference/format/range_formatter.md</id>
      <updated>2023-01-24T19:48:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter.md b/reference/format/range_formatter.md
index 258c75156..5b0cec189 100644
--- a/reference/format/range_formatter.md
+++ b/reference/format/range_formatter.md
@@ -92,10 +92,10 @@ int main()
 ```
 * std::format_parse_context[link basic_format_parse_context.md]
 * pctx.begin()[link basic_format_parse_context/begin.md]
-* pctx.advance_to()[link basic_format_parse_context/advance_to.md]
+* pctx.advance_to[link basic_format_parse_context/advance_to.md]
 * std::format_context[link basic_format_context.md]
 * fctx.out()[link basic_format_context/out.md]
-* fctx.advance_to()[link basic_format_context/advance_to.md]
+* fctx.advance_to[link basic_format_context/advance_to.md]
 * std::format_to[link format_to.md]
 * std::format[link format.md]
 * underlying()[link range_formatter/underlying.md.nolink]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>