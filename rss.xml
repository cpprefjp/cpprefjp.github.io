<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-28T08:35:00.494341</updated>
  <id>826417d1-80c6-4de5-833d-14a1c5152fad</id>

  
    <entry>
      <title>basic_ifstream -- リンクミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/fstream/basic_ifstream.html"/>
      <id>fa3dcb5f9735b4013050ad5b0855e665144f7ef0:reference/fstream/basic_ifstream.md</id>
      <updated>2025-05-28T17:30:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/fstream/basic_ifstream.md b/reference/fstream/basic_ifstream.md
index c15e79c2c..e012d09da 100644
--- a/reference/fstream/basic_ifstream.md
+++ b/reference/fstream/basic_ifstream.md
@@ -75,7 +75,7 @@ int main() {
 }
 ```
 * std::ifstream[color ff0000]
-* ifs.is_open[link ifstream/is_open.md]
-* ifs.close[link ifstream/close.md]
+* ifs.is_open[link basic_ifstream/is_open.md]
+* ifs.close[link basic_ifstream/close.md]
 * std::getline[link /reference/string/basic_string/getline.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_ofstream -- リンクミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/fstream/basic_ofstream.html"/>
      <id>fa3dcb5f9735b4013050ad5b0855e665144f7ef0:reference/fstream/basic_ofstream.md</id>
      <updated>2025-05-28T17:30:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/fstream/basic_ofstream.md b/reference/fstream/basic_ofstream.md
index 34e226e4f..ddccc8f3c 100644
--- a/reference/fstream/basic_ofstream.md
+++ b/reference/fstream/basic_ofstream.md
@@ -72,6 +72,6 @@ int main() {
 }
 ```
 * std::ofstream[color ff0000]
-* ofs.is_open[link ofstream/is_open.md]
-* ofs.close[link ofstream/close.md]
+* ofs.is_open[link basic_ofstream/is_open.md]
+* ofs.close[link basic_ofstream/close.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_ifstream -- basic_ifstream, basic_ofstream : サンプルコードを追加</title>
      <link href="https://cpprefjp.github.io/reference/fstream/basic_ifstream.html"/>
      <id>3a27b55ef5f235a317e5a0e7767db1ad05b77998:reference/fstream/basic_ifstream.md</id>
      <updated>2025-05-28T17:27:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/fstream/basic_ifstream.md b/reference/fstream/basic_ifstream.md
index 5f0a699a6..c15e79c2c 100644
--- a/reference/fstream/basic_ifstream.md
+++ b/reference/fstream/basic_ifstream.md
@@ -50,3 +50,32 @@ namespace std {
 | `off_type`       | `Traits::off_type`            | |
 | `traits_type`    | テンプレート仮引数`Traits`    | |
 
+## 例
+```cpp example
+#include &amp;lt;fstream&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main() {
+  // example.txtファイルを読み取り専用で開く
+  std::ifstream ifs(&amp;#34;example.txt&amp;#34;);
+  if (!ifs.is_open()) {
+    std::cerr &amp;lt;&amp;lt; &amp;#34;ファイルを開けませんでした&amp;#34; &amp;lt;&amp;lt; std::endl;
+    return 1;
+  }
+
+  // ファイルの内容を1行ずつ読み取り、出力する
+  std::string line;
+  while (std::getline(ifs, line)) {
+    std::cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; std::endl;
+  }
+
+  // ファイルを閉じる (デストラクタでも自動的に閉じられる)
+  ifs.close();
+}
+```
+* std::ifstream[color ff0000]
+* ifs.is_open[link ifstream/is_open.md]
+* ifs.close[link ifstream/close.md]
+* std::getline[link /reference/string/basic_string/getline.md]
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_ofstream -- basic_ifstream, basic_ofstream : サンプルコードを追加</title>
      <link href="https://cpprefjp.github.io/reference/fstream/basic_ofstream.html"/>
      <id>3a27b55ef5f235a317e5a0e7767db1ad05b77998:reference/fstream/basic_ofstream.md</id>
      <updated>2025-05-28T17:27:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/fstream/basic_ofstream.md b/reference/fstream/basic_ofstream.md
index 4f02d74d5..34e226e4f 100644
--- a/reference/fstream/basic_ofstream.md
+++ b/reference/fstream/basic_ofstream.md
@@ -50,3 +50,28 @@ namespace std {
 | `off_type`       | `Traits::off_type`            | |
 | `traits_type`    | テンプレート仮引数`Traits`    | |
 
+## 例
+```cpp example
+#include &amp;lt;fstream&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main() {
+  // example.txtファイルを出力専用で開く
+  std::ofstream ofs(&amp;#34;example.txt&amp;#34;);
+  if (!ofs.is_open()) {
+    std::cerr &amp;lt;&amp;lt; &amp;#34;ファイルを開けませんでした&amp;#34; &amp;lt;&amp;lt; std::endl;
+    return 1;
+  }
+
+  // ファイルに文字列を書き込む
+  ofs &amp;lt;&amp;lt; &amp;#34;Hello, world!&amp;#34; &amp;lt;&amp;lt; std::endl;
+
+  // ファイルを閉じる (デストラクタでも自動的に閉じられる)
+  ofs.close();
+}
+```
+* std::ofstream[color ff0000]
+* ofs.is_open[link ofstream/is_open.md]
+* ofs.close[link ofstream/close.md]
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator -- allocator : C++26対応としてis_always_equalを削除 (close #1242)</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator.html"/>
      <id>c3e97ea8a80e4a22e82c6b943a35492f2894d99e:reference/memory/allocator.md</id>
      <updated>2025-05-28T17:09:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator.md b/reference/memory/allocator.md
index f38eef148..7d9970fe2 100644
--- a/reference/memory/allocator.md
+++ b/reference/memory/allocator.md
@@ -64,7 +64,7 @@ C++11から：
 | `reference`       | 要素の参照型 `T&amp;amp;`                            | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `const_reference` | 読み取り専用の要素の参照型 `const T&amp;amp;`        | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `rebind&amp;lt;U&amp;gt;`       | 型`U`を確保するように再束縛する              | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
-| `is_always_equal` | 同じ型のアロケータオブジェクトが2つある場合、それらが常に同値であるか。[`true_type`](/reference/type_traits/true_type.md) | C++17 |
+| `is_always_equal` | 同じ型のアロケータオブジェクトが2つある場合、それらが常に同値であるか。[`true_type`](/reference/type_traits/true_type.md) | C++17&amp;lt;br/&amp;gt; C++20で非推奨&amp;lt;br/&amp;gt; C++26で削除 |
 
 
 ## 非メンバ関数
@@ -87,6 +87,9 @@ C++11から：
         - なお、プライマリテンプレートからインスタンス化されるようになっても`allocate`/`deallocate`メンバは内部で`sizeof(void)`を要求するため引き続き使用不可能であり、`std::allocator&amp;lt;void&amp;gt;`の使用用途としては従来と同じく再束縛を目的とすることになる(上述のように[`std::allocator_traits`](allocator_traits.md)の代替機能を用いて`typename` [`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;void&amp;gt;&amp;gt;::template rebind_alloc&amp;lt;R&amp;gt;`のようにする)。
 
 - メンバ型の`size_type`と`difference_type`は、C++17で非推奨となったがC++20で非推奨が取り消された。
+- メンバ型の`is_always_equal`は、このクラスを継承したメモリアロケータが`is_always_equal`の値を引き継いでしまうという点で問題があったため、C++20で非推奨となり、C++26で削除された。
+    - 代わりに[`std::allocator_traits`](allocator_traits.md)クラスの`is_always_equal`メンバ型を使用すること。
+
 
 ## 例
 ```cpp example
@@ -140,3 +143,7 @@ int main(int argc, char** argv) {
 - [P0174R2 Deprecating Vestigial Library Parts in C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html)
 - [P0619R4 Reviewing deprecated facilities of C++17 for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html)
 - [N4258 Cleaning-up noexcept in the Library, Rev 3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf)
+- [LWG Issue 3170. `is_always_equal` added to `std::allocator` makes the standard library treat derived types as always equal](https://cplusplus.github.io/LWG/issue3170)
+    - C++20で`is_always_equal`メンバ型が非推奨化された
+- [P2868R3 Remove Deprecated `std::allocator` Typedef From C++26](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2868r3.pdf)
+    - C++26で`is_always_equal`メンバ型が削除された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>projected -- projected : C++26での不完全型への対策に対応 (close #1185)</title>
      <link href="https://cpprefjp.github.io/reference/iterator/projected.html"/>
      <id>1fe3de6f2d3c0162a5f2b4b89231c01f20f24380:reference/iterator/projected.md</id>
      <updated>2025-05-28T14:49:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/projected.md b/reference/iterator/projected.md
index cf694bbc7..85023e7ad 100644
--- a/reference/iterator/projected.md
+++ b/reference/iterator/projected.md
@@ -6,20 +6,30 @@
 
 ```cpp
 namespace std {
-
-  template&amp;lt;indirectly_readable I, indirectly_regular_unary_invocable&amp;lt;I&amp;gt; Proj&amp;gt;
+  // (1) C++20の定義
+  template &amp;lt;indirectly_readable I, indirectly_regular_unary_invocable&amp;lt;I&amp;gt; Proj&amp;gt;
   struct projected {
     using value_type = remove_cvref_t&amp;lt;indirect_result_t&amp;lt;Proj&amp;amp;, I&amp;gt;&amp;gt;;
 
     indirect_result_t&amp;lt;Proj&amp;amp;, I&amp;gt; operator*() const;	// 宣言のみ
   };
-
-
   // incrementable_traitsにアダプトする
-  template&amp;lt;weakly_incrementable I, class Proj&amp;gt;
+  template &amp;lt;weakly_incrementable I, class Proj&amp;gt;
   struct incrementable_traits&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; {
     using difference_type = iter_difference_t&amp;lt;I&amp;gt;;
   };
+
+  // (1) C++26の定義
+  template &amp;lt;class I, class Proj&amp;gt;
+  struct projected-impl { // 説明用の型
+    struct type { // 説明用の型
+      using value_type = remove_cvref_t&amp;lt;indirect_result_t&amp;lt;Proj&amp;amp;, I&amp;gt;&amp;gt;;
+      using difference_type = iter_difference_t&amp;lt;I&amp;gt;; // weakly_incrementableをモデル化する場合にのみ存在する
+      indirect_result_t&amp;lt;Proj&amp;amp;, I&amp;gt; operator*() const; // 宣言のみで定義なし
+    };
+  };
+  template &amp;lt;indirectly_readable I, indirectly_regular_unary_invocable&amp;lt;I&amp;gt; Proj&amp;gt;
+  using projected = projected-impl&amp;lt;I, Proj&amp;gt;::type;
 }
 ```
 * indirectly_readable[link /reference/iterator/indirectly_readable.md]
@@ -34,6 +44,15 @@ namespace std {
 
 これは射影操作を受け取るコンセプトやアルゴリズムを制約するために使用するものであり、評価される文脈で使用可能ではない。主に、射影操作の結果に対してイテレータ関連のコンセプトを適用する場合に使用する（射影の結果を再び`indirectly_readable`な型に写す事で、一部のイテレータに対するコンセプトを使いまわす事が出来る）。
 
+
+## 備考
+- C++26:
+    - C++20の`projected`の定義では、ADLによって不完全型に完全な定義を要求してしまっており、以下のようなコードがコンパイルエラーになっていたが、C++26での定義変更によって不完全型が許容されるようになった。
+        ```cpp
+        Holder&amp;lt;Incomplete&amp;gt; *a[10] = {};
+        std::ranges::count(a, a + 10, nullptr); // コンパイルエラー
+        ```
+
 ## 例
 ```cpp example
 #include &amp;lt;iterator&amp;gt;
@@ -95,3 +114,4 @@ int main() {
 ## 参照
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P2538R1 ADL-proof `std::projected`](http://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2538r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- execution: bulk (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>876474cda3ade253d72668edd968a4131ed58e14:reference/execution/execution.md</id>
      <updated>2025-05-28T00:49:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index c103bdf8e..ef8fdbfc6 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -121,7 +121,7 @@ namespace std::execution {
 | [`execution::let_value`](execution/let_value.md) | 値完了結果から入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::let_error`](execution/let_error.md.nolink) | エラー完了結果から入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::let_stopped`](execution/let_stopped.md.nolink) | 停止完了を入れ子の非同期操作へ変換 (customization point object) | C++26 |
-| [`execution::bulk`](execution/bulk.md.nolink) | インデクス空間上で指定関数を連続実行 (customization point object) | C++26 |
+| [`execution::bulk`](execution/bulk.md) | インデクス空間上で指定関数を反復実行 (customization point object) | C++26 |
 | [`execution::split`](execution/split.md) | 入力Senderの値を複製回送信可能とする (customization point object) | C++26 |
 | [`execution::when_all`](execution/when_all.md) | 全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::when_all_with_variant`](execution/when_all_with_variant.md) | 複数の値完了シグネチャをもつ全ての入力Sender完了を待機 (customization point object) | C++26 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bulk -- execution: bulk (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/bulk.html"/>
      <id>876474cda3ade253d72668edd968a4131ed58e14:reference/execution/execution/bulk.md</id>
      <updated>2025-05-28T00:49:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/bulk.md b/reference/execution/execution/bulk.md
new file mode 100644
index 000000000..82ad14e32
--- /dev/null
+++ b/reference/execution/execution/bulk.md
@@ -0,0 +1,137 @@
+# bulk
+* execution[meta header]
+* cpo[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  struct bulk_t { unspecified };
+  inline constexpr bulk_t bulk{};
+}
+```
+* unspecified[italic]
+
+## 概要
+`bulk`は、インデクス空間の各インデクスに対してタスクを反復実行するSenderアダプタである。
+
+`bulk`はパイプライン記法をサポートする。
+
+
+## 効果
+説明用の式`sndr`, `shape`, `f`に対して、型`Shape`を`decltype(auto(shape))`とする。下記いずれかの条件をみたすとき、呼び出し式`bulk(sndr, shape, f)`は不適格となる。
+
+- `decltype((sndr))`が[`sender`](sender.md)を満たさない、もしくは
+- `Shape`が[`integral`](/reference/concepts/integral.md)を満たさない、もしくは
+- `decltype((f))`が[`movable-value`](../movable-value.md)を満たさないとき。
+
+そうでなければ、呼び出し式`bulk(sndr, shape, f)`は`sndr`が1回だけ評価されることを除いて、下記と等価。
+
+```cpp
+transform_sender(get-domain-early(sndr), make-sender(bulk, product-type{shape, f}, sndr))
+```
+* transform_sender[link transform_sender.md]
+* get-domain-early[link get-domain-early.md]
+* make-sender[link make-sender.md]
+* product-type[link product-type.md]
+
+
+### Senderアルゴリズムタグ `bulk`
+Senderアルゴリズム動作説明用のクラステンプレート[`impls-for`](impls-for.md)に対して、下記の特殊化が定義される。
+
+```cpp
+namespace std::execution {
+  template&amp;lt;&amp;gt;
+  struct impls-for&amp;lt;bulk_t&amp;gt; : default-impls {
+    static constexpr auto complete = see below;
+  };
+}
+```
+* impls-for[link impls-for.md]
+* default-impls[link impls-for.md]
+* see below[italic]
+
+`impls-for&amp;lt;bulk_t&amp;gt;::complete`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[]&amp;lt;class Index, class State, class Rcvr, class Tag, class... Args&amp;gt;
+  (Index, State&amp;amp; state, Rcvr&amp;amp; rcvr, Tag, Args&amp;amp;&amp;amp;... args) noexcept -&amp;gt; void requires see below {
+    if constexpr (same_as&amp;lt;Tag, set_value_t&amp;gt;) {
+      auto&amp;amp; [shape, f] = state;
+      constexpr bool nothrow = noexcept(f(auto(shape), args...));
+      TRY-EVAL(rcvr, [&amp;amp;]() noexcept(nothrow) {
+        for (decltype(auto(shape)) i = 0; i &amp;lt; shape; ++i) {
+          f(auto(i), args...);
+        }
+        Tag()(std::move(rcvr), std::forward&amp;lt;Args&amp;gt;(args)...);
+      }());
+    } else {
+      Tag()(std::move(rcvr), std::forward&amp;lt;Args&amp;gt;(args)...);
+    }
+  }
+```
+* set_value_t[link set_value.md]
+* TRY-EVAL[link TRY-EVAL.md.nolink]
+* std::move[link /reference/utility/move.md]
+* see below[italic]
+
+型`Tag`が[`set_value_t`](set_value.md)以外の型であるとき、もしくは式`f(auto(shape), args...)`が適格なときに限って、上記ラムダ式のrequires節が満たされる。
+
+
+## カスタマイゼーションポイント
+Senderアルゴリズム構築時および[Receiver](receiver.md)接続時に、関連付けられた実行ドメインに対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](default_domain.md)では無変換。
+
+説明用の式`out_sndr`を`bulk(sndr, shape, f)`の戻り値[Sender](sender.md)とし、式`rcvr`を式[`connect`](connect.md)`(out_sndr, rcvr)`が適格となる[Receiver](receiver.md)とする。式[`connect`](connect.md)`(out_sndr, rcvr)`は[開始(start)](start.md)時に下記を満たす非同期操作を生成しない場合、動作は未定義となる。
+
+- 値完了操作において、パック`args`を入力[Sender](sender.md)の値完了結果データを参照する左辺値式としたとき、型`Shape`の半開区間`[0, Shape)`における全ての`i`に対して`f(i, args...)`を呼び出すこと。
+- `sndr`により送信された全ての完了操作を伝搬すること。
+
+
+## 備考
+非同期実行フレームワークで定義される[デフォルト実行ドメイン](default_domain.md)では、`bulk`に指定したタスク`f`は単一スレッド上で逐次実行される。
+
+
+## 例
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+int main()
+{
+  ex::sender auto sndr =
+    ex::just()
+    | ex::bulk(3, [](int i) {
+        std::println(&amp;#34;{}&amp;#34;, i);
+      });
+  std::this_thread::sync_wait(sndr);
+}
+```
+* ex::bulk[color ff0000]
+* ex::sender[link sender.md]
+* ex::just[link just.md]
+* std::this_thread::sync_wait[link ../this_thread/sync_wait.md]
+
+### 出力例
+```
+0
+1
+2
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>let_value -- execution: bulk (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/let_value.html"/>
      <id>876474cda3ade253d72668edd968a4131ed58e14:reference/execution/execution/let_value.md</id>
      <updated>2025-05-28T00:49:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/let_value.md b/reference/execution/execution/let_value.md
index 0ed009957..5a216c85f 100644
--- a/reference/execution/execution/let_value.md
+++ b/reference/execution/execution/let_value.md
@@ -114,6 +114,7 @@ namespace std::execution {
 ```
 * set_value[link set_value.md]
 * decayed-typeof[link decayed-typeof.md.nolink]
+* TRY-EVAL[link TRY-EVAL.md.nolink]
 * std::move[link /reference/utility/move.md]
 
 説明用の式`sndr`と`env`に対して、型`Sndr`を`decltype((sndr))`とする。[`sender-for`](sender-for.md)`&amp;lt;Sndr, decayed-typeof&amp;lt;let_value&amp;gt;&amp;gt; == false`のとき、式`let_value.transform_env(sndr, env)`は不適格となる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>