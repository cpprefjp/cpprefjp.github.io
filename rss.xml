<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-04-14T05:13:08.309953</updated>
  <id>5cad2c13-a2a3-467b-9cf1-3e9a3d101436</id>

  
    <entry>
      <title>operator+ -- string::operator+ : 表の並び順修正</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>f758e082b24c76af5c67290766b329f830d8b519:reference/string/basic_string/op_plus.md</id>
      <updated>2020-04-14T14:09:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index b69c8b7d7..da8d2c48b 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -180,17 +180,17 @@ C++20からこの演算子による文字列連結時にアロケータがどの
 |オーバーロード|C++17まで|GCC|clang|MSVC|C++20から|
 |----|----|----|----|----|----|
 |(1) : `lhs + rhs`|`lhs`からのSOCCC|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(3) : `lhs + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 |(2) : `std::move(lhs) + rhs`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(3) : `lhs + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 |(4) : `std::move(lhs) + std::move(rhs)`|`lhs`または`rhs`|`lhs`|`lhs`|`lhs`|`lhs`|
-|(9) : `lhs + &amp;#34;rhs&amp;#34;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(11) : `lhs + &amp;#39;r&amp;#39;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(10) : `std::move(lhs) + &amp;#34;rhs&amp;#34;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
-|(12) : `std::move(lhs) + &amp;#39;r&amp;#39;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
 |(5) : `&amp;#34;lhs&amp;#34; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(7) : `&amp;#39;l&amp;#39; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
 |(6) : `&amp;#34;lhs&amp;#34; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(7) : `&amp;#39;l&amp;#39; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
 |(8) : `&amp;#39;l&amp;#39; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(9) : `lhs + &amp;#34;rhs&amp;#34;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(10) : `std::move(lhs) + &amp;#34;rhs&amp;#34;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(11) : `lhs + &amp;#39;r&amp;#39;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(12) : `std::move(lhs) + &amp;#39;r&amp;#39;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
 
 
 表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝播仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>属性構文 -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/attributes.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:lang/cpp11/attributes.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/attributes.md b/lang/cpp11/attributes.md
index e060c678b..a268b81cb 100644
--- a/lang/cpp11/attributes.md
+++ b/lang/cpp11/attributes.md
@@ -52,7 +52,7 @@ int main()
 
 
 ### &amp;lt;a id=&amp;#34;carries_dependency&amp;#34; href=&amp;#34;#carries_dependency&amp;#34;&amp;gt;`[[carries_dependency]]`属性&amp;lt;/a&amp;gt;
-`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order_consume`](/reference/atomic/memory_order.md)を、関数をまたいで伝搬することを明示するための属性である。
+`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order_consume`](/reference/atomic/memory_order.md)を、関数をまたいで伝播することを明示するための属性である。
 
 以下は、[`memory_order_consume`](/reference/atomic/memory_order.md)を使用した順序付けの例である：
 
@@ -70,10 +70,10 @@ if (r1) {
 * x.load[link /reference/atomic/atomic/load.md]
 * memory_order_consume[link /reference/atomic/memory_order.md]
 
-ここでは、`r1`に関連する操作が全て同一関数内で行われているが、一部の操作が別の関数になっていると、別の関数になった操作に値の依存があるかどうか・依存として扱ってよいのかどうかがコンパイラに判断できない可能性がある。そのような状況で、関数のパラメータおよび戻り値のそれぞれが値の依存性を伝搬させることを明示するために`[[carries_dependency]]`属性を使用する。
+ここでは、`r1`に関連する操作が全て同一関数内で行われているが、一部の操作が別の関数になっていると、別の関数になった操作に値の依存があるかどうか・依存として扱ってよいのかどうかがコンパイラに判断できない可能性がある。そのような状況で、関数のパラメータおよび戻り値のそれぞれが値の依存性を伝播させることを明示するために`[[carries_dependency]]`属性を使用する。
 
 
-#### 関数の戻り値で値の依存性を伝搬させる
+#### 関数の戻り値で値の依存性を伝播させる
 関数の戻り値に対して値の依存性を持たせる場合、関数に対して`[[carries_dependency]]`属性を付加する。
 
 ```cpp
@@ -94,7 +94,7 @@ if (r1) {
 * memory_order_consume[link /reference/atomic/memory_order.md]
 
 
-#### 関数のパラメータで値の依存性を伝搬させる
+#### 関数のパラメータで値の依存性を伝播させる
 関数のパラメータに対して値の依存性を持たせる場合、各パラメータ名のうしろに`[[carries_dependency]]`属性を付加する。
 
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/allocator.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator.md b/reference/memory/allocator.md
index da96c6715..12acf9aef 100644
--- a/reference/memory/allocator.md
+++ b/reference/memory/allocator.md
@@ -55,7 +55,7 @@ C++11から：
 | 名前 | 説明 | 対応バージョン |
 |-------------------|----------------------------------------------|-------|
 | `value_type`      | 要素の型 `T`                                 | |
-| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータの状態を伝搬するか。 [`true_type`](/reference/type_traits/true_type.md) | C++14 |
+| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータの状態を伝播するか。 [`true_type`](/reference/type_traits/true_type.md) | C++14 |
 | `size_type`       | 要素数を表す符号なし整数型 `size_t`          | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `difference_type` | ポインタの差を表す符号付き整数型 `ptrdiff_t` | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `pointer`         | 要素のポインタ型 `T*`                        | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator_traits -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator_traits.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/allocator_traits.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator_traits.md b/reference/memory/allocator_traits.md
index 7b3bc0e05..83101640f 100644
--- a/reference/memory/allocator_traits.md
+++ b/reference/memory/allocator_traits.md
@@ -45,9 +45,9 @@ namespace std {
 | `const_void_pointer`    | 読み取り専用の`void`のポインタ型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`const_void_pointer`を持っていればそれを使用し、そうでなければ[`pointer_traits`](pointer_traits.md)`&amp;lt;pointer&amp;gt;::rebind&amp;lt;const void&amp;gt;`を使用する。 | C++11 |
 | `difference_type` | ポインタの差を表す符号付き整数型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`difference_type`を持っていればそれを使用し、そうでなければ[`pointer_traits`](pointer_traits.md)`&amp;lt;pointer&amp;gt;::difference_type`を使用する。 | C++11 |
 | `size_type`       | 要素数を表す符号なし整数型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`size_type`を持っていればそれを使用し、そうでなければ[`make_unsigned`](/reference/type_traits/make_unsigned.md)`&amp;lt;difference_type&amp;gt;::type`を使用する。 | C++11 |
-| `propagate_on_container_copy_assignment` | コンテナのコピー代入時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_copy_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
-| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_move_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
-| `propagate_on_container_swap` | コンテナの交換時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_swap`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_copy_assignment` | コンテナのコピー代入時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_copy_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_move_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_swap` | コンテナの交換時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_swap`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
 | `is_always_equal` | `Alloc::is_always_equal`が存在する場合は`Alloc::is_always_equal`。それ以外の場合は`is_empty&amp;lt;Alloc&amp;gt;::type`。 | C++17 |
 | `rebind_alloc&amp;lt;U&amp;gt;` | 型`U`を確保するようにアロケータ型を再束縛する。&amp;lt;br/&amp;gt; `Alloc::rebind&amp;lt;U&amp;gt;::other`が有効ならそれを使用し、そうでなければ`Alloc&amp;lt;U, Args`&amp;gt;を使用する。`Alloc`がクラステンプレートでない場合、`rebind_alloc`の使用は不適格となる。 | C++11 |
 | `rebind_traits&amp;lt;U&amp;gt;` | 再束縛した型`U`に対する`allocator_traits`。`allocator_traits&amp;lt;rebind_alloc&amp;lt;U&amp;gt;&amp;gt;` | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uses_allocator -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/uses_allocator.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/uses_allocator.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uses_allocator.md b/reference/memory/uses_allocator.md
index 1733788f9..b312c6123 100644
--- a/reference/memory/uses_allocator.md
+++ b/reference/memory/uses_allocator.md
@@ -51,7 +51,7 @@ namespace std {
 - 本型トレイツは、主にスコープアロケータモデルを採用するアロケータで使用されることを意図している。  
 	標準ライブラリでは、[`scoped_allocator_adaptor`](/reference/scoped_allocator/scoped_allocator_adaptor.md)、[`polymorphic_allocator`](../memory_resource/polymorphic_allocator.md) クラステンプレートで使用されている。
 - 標準ライブラリで提供されるいくつかの型は本型トレイツの特殊化を提供している。（[`tuple`](../tuple/tuple.md)、[`promise`](../future/promise.md)、各種コンテナアダプタ等）  
-- [`pair`](../utility/pair.md) は [`tuple`](../tuple/tuple.md) と同列の機能と考えられるが、本型トレイツの特殊化を提供していない。このため、標準ライブラリで提供されるスコープアロケータモデルを採用したアロケータでは C++17 までは独自に [`pair`](../utility/pair.md) の各要素に対して uses-allocator 構築を適用している（ただし、ネストした [`pair`](/reference/utility/pair.md) の要素に対してはアロケータは伝搬されない）。  
+- [`pair`](../utility/pair.md) は [`tuple`](../tuple/tuple.md) と同列の機能と考えられるが、本型トレイツの特殊化を提供していない。このため、標準ライブラリで提供されるスコープアロケータモデルを採用したアロケータでは C++17 までは独自に [`pair`](../utility/pair.md) の各要素に対して uses-allocator 構築を適用している（ただし、ネストした [`pair`](/reference/utility/pair.md) の要素に対してはアロケータは伝播されない）。  
 	スコープアロケータモデルを採用したアロケータを自作する場合には、同様の対応を行う方が良いだろう。  
 	なお、C++20 で [`pair`](../utility/pair.md) に対する特殊対応を含めた uses-allocator 構築サポートのためのユーティリティ関数が追加されたため、以前に比べて容易に uses-allocator 構築への対応が可能となった。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>construct -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/construct.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory_resource/polymorphic_allocator/construct.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/polymorphic_allocator/construct.md b/reference/memory_resource/polymorphic_allocator/construct.md
index bd2dacf0e..7610c3225 100644
--- a/reference/memory_resource/polymorphic_allocator/construct.md
+++ b/reference/memory_resource/polymorphic_allocator/construct.md
@@ -213,7 +213,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -227,7 +227,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -241,7 +241,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -256,7 +256,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -270,7 +270,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scoped_allocator_adaptor -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/scoped_allocator/scoped_allocator_adaptor.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/scoped_allocator/scoped_allocator_adaptor.md b/reference/scoped_allocator/scoped_allocator_adaptor.md
index f152fb0f2..30efb5292 100644
--- a/reference/scoped_allocator/scoped_allocator_adaptor.md
+++ b/reference/scoped_allocator/scoped_allocator_adaptor.md
@@ -24,11 +24,11 @@ namespace std {
 
 ![](https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_02.png)
 
-図2 コンテナとその要素で、アロケータオブジェクトの状態を伝搬させる(例1)
+図2 コンテナとその要素で、アロケータオブジェクトの状態を伝播させる(例1)
 
 ![](https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_03.png)
 
-図3 全ての要素にアロケータオブジェクトの状態を伝搬させる(例2)
+図3 全ての要素にアロケータオブジェクトの状態を伝播させる(例2)
 
 
 
@@ -99,7 +99,7 @@ namespace std {
 | [`(deduction_guide)`](scoped_allocator_adaptor/op_deduction_guide.md) | クラステンプレートの推論補助 | C++17 |
 
 
-## 例1 コンテナとその要素で、アロケータオブジェクトの状態を伝搬させる
+## 例1 コンテナとその要素で、アロケータオブジェクトの状態を伝播させる
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -176,7 +176,7 @@ int main()
 5
 ```
 
-## 例2 全ての要素にアロケータオブジェクトの状態を伝搬させる
+## 例2 全ての要素にアロケータオブジェクトの状態を伝播させる
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -242,7 +242,7 @@ int main()
   std::cout &amp;lt;&amp;lt; &amp;#34;container allocator : &amp;#34; &amp;lt;&amp;lt; v.get_allocator().getState() &amp;lt;&amp;lt; std::endl;
 
   // 要素に使用されるアロケータの状態を確認
-  // 全ての要素に、アロケータの状態が伝搬される
+  // 全ての要素に、アロケータの状態が伝播される
   for (const forward_list&amp;amp; x : v) {
     std::cout &amp;lt;&amp;lt; &amp;#34;element allocator : &amp;#34; &amp;lt;&amp;lt; x.get_allocator().getState() &amp;lt;&amp;lt; std::endl;
   }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>construct -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/construct.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/scoped_allocator/scoped_allocator_adaptor/construct.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/scoped_allocator/scoped_allocator_adaptor/construct.md b/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
index 539f4dd38..837bbee42 100644
--- a/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
+++ b/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
@@ -137,7 +137,7 @@ void construct_propagate_alloc()
   const std::size_t n = 1;
   string* p = alloc.allocate(n);
 
-  // (1) 以下のコンストラクタを呼び出し、アロケータオブジェクトを伝搬させる
+  // (1) 以下のコンストラクタを呼び出し、アロケータオブジェクトを伝播させる
   // basic_string(const char*, Allocator)
   alloc.construct(p, &amp;#34;hello&amp;#34;);
 
@@ -157,7 +157,7 @@ void construct_pair()
 
   // (2)
   // pairの各要素に対して以下のコンストラクタを呼び出し、
-  // アロケータオブジェクトを伝搬させる。
+  // アロケータオブジェクトを伝播させる。
   // basic_string(const char*, Allocator)
   std::pair&amp;lt;string, string&amp;gt;* pair_p = p;
   alloc.construct(p, std::piecewise_construct,
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/string/basic_string/op_plus.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index 9cba8ea23..b69c8b7d7 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -173,9 +173,9 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 ## 備考
 (5)、(6) の形式の `lhs`、および、(9)、(10) の形式の `rhs` の文字列長算出のために `traits::length()` が使用される
 
-## アロケータの伝搬
+## アロケータの伝播
 
-C++20からこの演算子による文字列連結時にアロケータがどのように伝搬するかが変更された。C++17までの仕様及び各実装とC++20からの各オーバーロード利用時の結果オブジェクトへのアロケータ供給元は次のようになる。なお、SOCCCは[`select_on_container_copy_construction`](/reference/memory/allocator_traits/select_on_container_copy_construction.md)の略。
+C++20からこの演算子による文字列連結時にアロケータがどのように伝播するかが変更された。C++17までの仕様及び各実装とC++20からの各オーバーロード利用時の結果オブジェクトへのアロケータ供給元は次のようになる。なお、SOCCCは[`select_on_container_copy_construction`](/reference/memory/allocator_traits/select_on_container_copy_construction.md)の略。
 
 |オーバーロード|C++17まで|GCC|clang|MSVC|C++20から|
 |----|----|----|----|----|----|
@@ -193,7 +193,7 @@ C++20からこの演算子による文字列連結時にアロケータがどの
 |(8) : `&amp;#39;l&amp;#39; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 
 
-表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝搬仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
+表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝播仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
 
 ## 例
 ```cpp example
@@ -226,4 +226,4 @@ Hello, world!
 | [`insert`](insert.md)       | 文字／文字列を挿入する |
 
 ## 参照
-- [P1165R1 Make stateful allocator propagation more consistent for operator+(basic_string)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1165r1.html)
\ No newline at end of file
+- [P1165R1 Make stateful allocator propagation more consistent for operator+(basic_string)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1165r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- Merge pull request #752 from cpprefjp/tshino-patch-1</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/unique.html"/>
      <id>386bc57e28d4f5b88c16a2af7334f2e40faf7803:reference/memory/shared_ptr/unique.md</id>
      <updated>2020-04-14T13:20:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/unique.md b/reference/memory/shared_ptr/unique.md
index 682022606..3cb4ef22c 100644
--- a/reference/memory/shared_ptr/unique.md
+++ b/reference/memory/shared_ptr/unique.md
@@ -14,7 +14,7 @@ bool unique() const noexcept;
 この関数は、C++17から非推奨となり、C++20で削除された。代わりに[`use_count()`](use_count.md)関数を使用すること。
 
 ## 概要
-有効なリソースを所有しているかを判定する。
+同じ所有権を共有する他のユーザーが存在しないかを判定する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equality_comparable -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/reference/concepts/equality_comparable.html"/>
      <id>9d0aaf10ba17673b1dc4f69cd5da961f30fea67c:reference/concepts/equality_comparable.md</id>
      <updated>2020-04-14T12:40:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/equality_comparable.md b/reference/concepts/equality_comparable.md
index f50ac85b2..fa14fd6e3 100644
--- a/reference/concepts/equality_comparable.md
+++ b/reference/concepts/equality_comparable.md
@@ -77,7 +77,7 @@ concept equality_comparable_with =
 
 ## 備考
 
-定義内の`a == b`等の各制約式に[等しさを保持](/reference/concepts.md)する事が要求されていることによって、これらコンセプトを満たす`== !=`演算子は推移的かつ対称的である事を表し、要求している。
+定義内の`t == u`等の各制約式に[等しさを保持](/reference/concepts.md)する事が要求されていることによって、これらコンセプトを満たす`== !=`演算子は推移的かつ対称的である事を表し、要求している。
 
 - 推移律 : `a == b`かつ`b == c`ならば`a == c`
 - 対称律 : `a == b`ならば`b == a`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- string::operator+ : P1165R1対応 #640</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>7f43be4e28ff7282bf9c10c825b6929a6c93f1c2:reference/string/basic_string/op_plus.md</id>
      <updated>2020-04-14T12:40:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index a26f079e3..9cba8ea23 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -46,23 +46,23 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 
 template &amp;lt;class charT, class traits, class Allocator&amp;gt;
 basic_string&amp;lt;charT, traits, Allocator&amp;gt;
-  operator+(const basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; rhs,
-            const charT* lhs);                                  // (9)
+  operator+(const basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; lhs,
+            const charT* rhs);                                  // (9)
 
 template &amp;lt;class charT, class traits, class Allocator&amp;gt;
 basic_string&amp;lt;charT, traits, Allocator&amp;gt;
-  operator+(basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp;&amp;amp; rhs,
-            const charT* lhs);                                  // (10) C++11 から
+  operator+(basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp;&amp;amp; lhs,
+            const charT* rhs);                                  // (10) C++11 から
 
 template &amp;lt;class charT, class traits, class Allocator&amp;gt;
 basic_string&amp;lt;charT, traits, Allocator&amp;gt;
-  operator+(const basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; rhs,
-            charT lhs);                                         // (11)
+  operator+(const basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; lhs,
+            charT rhs);                                         // (11)
 
 template &amp;lt;class charT, class traits, class Allocator&amp;gt;
 basic_string&amp;lt;charT, traits, Allocator&amp;gt;
-  operator+(basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp;&amp;amp; rhs,
-            charT lhs);                                         // (12) C++11 から
+  operator+(basic_string&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp;&amp;amp; lhs,
+            charT rhs);                                         // (12) C++11 から
 ```
 
 ## 概要
@@ -70,6 +70,9 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 
 
 ## 戻り値
+
+### C++17まで
+
 - (1) [`basic_string`](op_constructor.md)`&amp;lt;charT, traits, Allocator&amp;gt;(lhs).`[`append`](append.md)`(rhs)`
 
 - (2) `std::`[`move`](/reference/utility/move.md)`(lhs.`[`append`](append.md)`(rhs))`
@@ -95,10 +98,102 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 
 - (12) `std::`[`move`](/reference/utility/move.md)`(lhs.`[`append`](append.md)`(1, rhs))`
 
+### C++20から
+
+- (1)(9) : 以下と等価
+  ```cpp
+  basic_string&amp;lt;charT, traits, Allocator&amp;gt; r = lhs;
+  r.append(rhs);
+  return r;
+  ```
+  * append[link append.md]
+
+- (2)(10) : 以下と等価
+  ```cpp
+  lhs.append(rhs);
+  return std::move(lhs);
+  ```
+  * append[link append.md]
+
+- (3)(6) : 以下と等価
+  ```cpp
+  rhs.insert(0, lhs);
+  return std::move(rhs);
+  ```
+  * insert[link insert.md]
+
+- (4) : 呼び出しの後でも`lhs`と`rhs`は有効だが未規定な状態のままであることを除いて、以下と等価
+  ```cpp
+  lhs.append(rhs);
+  return std::move(lhs);
+  ```
+  * append[link append.md]
+
+- (5) : 以下と等価
+  ```cpp
+  basic_string&amp;lt;charT, traits, Allocator&amp;gt; r = rhs;
+  r.insert(0, lhs);
+  return r;
+  ```
+  * insert[link insert.md]
+
+- (7) : 以下と等価
+  ```cpp
+  basic_string&amp;lt;charT, traits, Allocator&amp;gt; r = rhs;
+  r.insert(r.begin(), lhs);
+  return r;
+  ```
+  * insert[link insert.md]
+  * begin[link begin.md]
+
+- (8) : 以下と等価
+  ```cpp
+  rhs.insert(rhs.begin(), lhs);
+  return std::move(rhs);
+  ```
+  * insert[link insert.md]
+  * begin[link begin.md]
+
+- (11) : 以下と等価
+  ```cpp
+  basic_string&amp;lt;charT, traits, Allocator&amp;gt; r = lhs;
+  r.push_back(rhs);
+  return r;
+  ```
+  * push_back[link push_back.md]
+
+- (12) : 以下と等価
+  ```cpp
+  lhs.push_back(rhs);
+  return std::move(lhs);
+  ```
+  * push_back[link push_back.md]
+
 
 ## 備考
 (5)、(6) の形式の `lhs`、および、(9)、(10) の形式の `rhs` の文字列長算出のために `traits::length()` が使用される
 
+## アロケータの伝搬
+
+C++20からこの演算子による文字列連結時にアロケータがどのように伝搬するかが変更された。C++17までの仕様及び各実装とC++20からの各オーバーロード利用時の結果オブジェクトへのアロケータ供給元は次のようになる。なお、SOCCCは[`select_on_container_copy_construction`](/reference/memory/allocator_traits/select_on_container_copy_construction.md)の略。
+
+|オーバーロード|C++17まで|GCC|clang|MSVC|C++20から|
+|----|----|----|----|----|----|
+|(1) : `lhs + rhs`|`lhs`からのSOCCC|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(3) : `lhs + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(2) : `std::move(lhs) + rhs`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(4) : `std::move(lhs) + std::move(rhs)`|`lhs`または`rhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(9) : `lhs + &amp;#34;rhs&amp;#34;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(11) : `lhs + &amp;#39;r&amp;#39;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(10) : `std::move(lhs) + &amp;#34;rhs&amp;#34;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(12) : `std::move(lhs) + &amp;#39;r&amp;#39;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(5) : `&amp;#34;lhs&amp;#34; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(7) : `&amp;#39;l&amp;#39; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(6) : `&amp;#34;lhs&amp;#34; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(8) : `&amp;#39;l&amp;#39; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+
+
+表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝搬仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
 
 ## 例
 ```cpp example
@@ -129,3 +224,6 @@ Hello, world!
 | [`append`](append.md)       | 文字／文字列を追加する |
 | [`push_back`](push_back.md) | 文字を追加する         |
 | [`insert`](insert.md)       | 文字／文字列を挿入する |
+
+## 参照
+- [P1165R1 Make stateful allocator propagation more consistent for operator+(basic_string)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1165r1.html)
\ No newline at end of file
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>