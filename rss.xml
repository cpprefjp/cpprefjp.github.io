<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-13T19:38:35.625296</updated>
  <id>6b3cd7a9-54b0-40ad-8fbb-f0e1bdafaf90</id>

  
    <entry>
      <title>ranges -- &lt;ranges&gt; C++23対応(ヘッダーページのみ)</title>
      <link href="https://cpprefjp.github.io/reference/ranges.html"/>
      <id>5b0dfcbb75706d0b4219676187e0851178825d0d:reference/ranges.md</id>
      <updated>2023-01-14T04:32:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges.md b/reference/ranges.md
index 347c3dc20..855273b0f 100644
--- a/reference/ranges.md
+++ b/reference/ranges.md
@@ -209,6 +209,13 @@ range | adaptor(args...)
 | [`views::all`](ranges/all.md)           | Rangeへの参照として振る舞うビューを生成する (customization point object) | C++20          |
 | [`views::all_t`](ranges/all.md)         | `all`の戻り値型 (alias template)                                         | C++20          |
 
+### as rvalue view
+
+| 名前                                           | 説明                                                         | 対応バージョン |
+|------------------------------------------------|--------------------------------------------------------------|----------------|
+| [`as_rvalue_view`](ranges/as_rvalue_view.md.nolink)   | 各要素をrvalueにするビュー (class template)                  | C++23          |
+| [`views::as_rvalue`](ranges/as_rvalue.md.nolink)      | `as_rvalue_view`を生成する (customization point object)      | C++23          |
+
 ### filter view
 
 | 名前                                          | 説明                                                        | 対応バージョン |
@@ -257,15 +264,25 @@ range | adaptor(args...)
 |-----------------------------------------------------|---------------------------------------------------------------------------------------------------|----------------|
 | [`join_view`](ranges/join_view.md)                  | ネストされたRangeを平坦にするビュー (class template)                                              | C++20          |
 | [`views::join`](ranges/join_view.md)                | ネストされたRangeを平坦にするビューを生成する (customization point object)                        | C++20          |
+
+### join with view
+
+| 名前                                                | 説明                                                                                              | 対応バージョン |
+|-----------------------------------------------------|---------------------------------------------------------------------------------------------------|----------------|
 | [`join_with_view`](ranges/join_with_view.md.nolink)        | ネストされたRangeをデリミタで区切りながら平坦にするビュー (class template)                        | C++23          |
 | [`views::join_with`](ranges/join_with_view.md.nolink)      | ネストされたRangeをデリミタで区切りながら平坦にするビューを生成する (customization point object)  | C++23          |
 
-### split view
+### lazy split view
 
 | 名前                                                  | 説明                                                         | 対応バージョン |
 |-------------------------------------------------------|--------------------------------------------------------------|----------------|
 | [`lazy_split_view`](ranges/lazy_split_view.md)        | Rangeを指定したデリミタで分割するビュー (class template)     | C++20          |
 | [`views::lazy_split`](ranges/lazy_split_view.md)      | `lazy_split_view`を生成する (customization point object)     | C++20          |
+
+### split view
+
+| 名前                                                  | 説明                                                         | 対応バージョン |
+|-------------------------------------------------------|--------------------------------------------------------------|----------------|
 | [`split_view`](ranges/split_view.md)                  | 文字列分割に特化した`lazy_split_view` (class template)       | C++20          |
 | [`views::split`](ranges/split_view.md)                | `split_view`を生成する (customization point object)          | C++20          |
 
@@ -289,6 +306,13 @@ range | adaptor(args...)
 | [`reverse_view`](ranges/reverse_view.md)        | 逆順のビュー (class template)                        | C++20          |
 | [`views::reverse`](ranges/reverse_view.md)      | 逆順のビューを生成する (customization point object)  | C++20          |
 
+### as const view
+
+| 名前                                          | 説明                                                         | 対応バージョン |
+|-----------------------------------------------|--------------------------------------------------------------|----------------|
+| [`as_const_view`](ranges/as_const_view.md.nolink)    | 各要素をconstにするビュー (class template)                   | C++23          |
+| [`views::as_const`](ranges/as_const.md.nolink)       | `as_const_view`を生成する (customization point object)       | C++23          |
+
 ### elements view
 
 | 名前                                              | 説明                                                   | 対応バージョン |
@@ -306,6 +330,11 @@ range | adaptor(args...)
 |--------------------------------------------------------|-------------------------------------------------------------------------------------|----------------|
 | [`zip_view`](ranges/zip_view.md.nolink)                       | 2つのシーケンスから値を1つずつ取り出した`tuple`のビュー (class template)            | C++23          |
 | [`views::zip`](ranges/zip_view.md.nolink)                     | `zip_view`を生成する (customization point object)                                   | C++23          |
+
+### zip transform view
+
+| 名前                                                   | 説明                                                                                | 対応バージョン |
+|--------------------------------------------------------|-------------------------------------------------------------------------------------|----------------|
 | [`zip_transform_view`](ranges/zip_transform_view.md.nolink)   | 2つのシーケンスから値を1つずつ取り出し、関数を適用した結果のビュー (class template) | C++23          |
 | [`views::zip_transform`](ranges/zip_transform_view.md.nolink) | `zip_transform_view`を生成する (customization point object)                         | C++23          |
 
@@ -315,6 +344,11 @@ range | adaptor(args...)
 |------------------------------------------------------------------|------------------------------------------------------------------------------------|----------------|
 | [`adjacent_view`](ranges/adjacent_view.md.nolink)                       | 各要素とそれに隣接する要素を指定個数ずつ取り出した`tuple`のビュー (class template) | C++23          |
 | [`views::adjacent`](ranges/adjacent_view.md.nolink)                     | `adjacent_view`を生成する (customization point object)                             | C++23          |
+
+### adjacent transform view
+
+| 名前                                                             | 説明                                                                               | 対応バージョン |
+|------------------------------------------------------------------|------------------------------------------------------------------------------------|----------------|
 | [`adjacent_transform_view`](ranges/adjacent_transform_view.md.nolink)   | `adjacent_view`と同様に取り出し、関数を適用した結果のビュー (class template)       | C++23          |
 | [`views::adjacent_transform`](ranges/adjacent_transform_view.md.nolink) | `adjacent_transform_view`を生成する (customization point object)                   | C++23          |
 
@@ -324,6 +358,11 @@ range | adaptor(args...)
 |---------------------------------------------|--------------------------------------------------------------------|----------------|
 | [`chunk_view`](ranges/chunk_view.md.nolink)         | シーケンスを指定個数で区切った`view`のシーケンス (class template)  | C++23          |
 | [`views::chunk`](ranges/chunk_view.md.nolink)       | `chunk_view`を生成する (customization point object)                | C++23          |
+
+### chunk by view
+
+| 名前                                        | 説明                                                               | 対応バージョン |
+|---------------------------------------------|--------------------------------------------------------------------|----------------|
 | [`chunk_by_view`](ranges/chunk_by_view.md.nolink)   | 2項述語が偽となる部分で区切った`view`のシーケンス (class template) | C++23          |
 | [`views::chunk_by`](ranges/chunk_by_view.md.nolink) | `chunk_by_view`を生成する (customization point object)             | C++23          |
 
@@ -334,6 +373,20 @@ range | adaptor(args...)
 | [`slide_view`](ranges/slide_view.md.nolink)   | 各要素とそれに隣接する要素を指定個数ずつ見る`view`のシーケンス (class template) | C++23          |
 | [`views::slide`](ranges/slide_view.md.nolink) | `slide_view`を生成する (customization point object)                             | C++23          |
 
+### stride view
+
+| 名前                                     | 説明                                                  | 対応バージョン |
+|------------------------------------------|-------------------------------------------------------|----------------|
+| [`stride_view`](ranges/stride_view.md.nolink)   | 要素を指定個数飛ばしに見るビュー (class template)     | C++23          |
+| [`views::stride`](ranges/stride_view.md.nolink) | `stride_view`を生成する (customization point object)  | C++23          |
+
+### cartesian product view
+
+| 名前                                                          | 説明                                                             | 対応バージョン |
+|---------------------------------------------------------------|------------------------------------------------------------------|----------------|
+| [`cartesian_product_view`](ranges/cartesian_product_view.md.nolink)  | シーケンスの直積集合のビュー (class template)                    | C++23          |
+| [`views::cartesian_product`](ranges/cartesian_product.md.nolink)     | `cartesian_product_view`を生成する (customization point object)  | C++23          |
+
 
 ## Range変換
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>INVOKE -- C++20 : P0777R1対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts/Invoke.html"/>
      <id>df3cf1576616ea59ff5b6f2e46c42aad9b88d734:reference/concepts/Invoke.md</id>
      <updated>2023-01-13T18:13:13+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;named requirement&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace &#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;INVOKE&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;C++における関数呼び出しという性質を抽象化しまとめた、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt; を定義する。&lt;/p&gt;
&lt;p&gt;C++17からは、本仮想操作を実体化した&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;invoke&lt;/a&gt;&lt;/code&gt;関数テンプレートが提供される。&lt;/p&gt;
&lt;h2&gt;用語定義&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;call-signature&lt;/em&gt; とは、戻り値型に続けて丸括弧の中に0個以上の引数型を並べたものである。 &lt;em&gt;cf.&lt;/em&gt; &lt;code&gt;int ( std::string, int )&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-type&lt;/em&gt; とは、関数呼び出し演算子を適用できる型 ( 関数、関数への参照、関数へのポインタ、&lt;code&gt;operator ()&lt;/code&gt; をオーバーロードした型もしくはそれを(直接または間接的に) &lt;code&gt;public&lt;/code&gt; 継承した型 ) もしくはメンバへのポインタ型を指す。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-object&lt;/em&gt; は、 &lt;em&gt;callable-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper-type&lt;/em&gt; は、 &lt;em&gt;callable-object&lt;/em&gt; を保持し、自身に対する関数呼び出し操作が行われたとき、保持しているオブジェクトに委譲する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; は、 &lt;em&gt;call-wrapper-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;target-object&lt;/em&gt; とは、 &lt;em&gt;callable-object&lt;/em&gt; に保持されているオブジェクトのことである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;要件（C++14まで）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が T 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN, R)&lt;/code&gt; を、 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること、と定義する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; が &lt;em&gt;weak-result-type&lt;/em&gt; を用意している場合、メンバ型 &lt;code&gt;result_type&lt;/code&gt; は&lt;em&gt;target-object&lt;/em&gt; の型 &lt;code&gt;T&lt;/code&gt; に応じて次のように定義される。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; がメンバ関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;result_type&lt;/code&gt; という名前のメンバ型を持つとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T::result_type&lt;/code&gt; と等しい。&lt;/li&gt;
&lt;li&gt;どの条件にも当てはまらない場合、 &lt;code&gt;result_type&lt;/code&gt; は定義されない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveAssignable&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++17）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveConstructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++20）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;Cpp17MoveConstructible&lt;/em&gt; かつ &lt;em&gt;Cpp17Destructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/Cryolite/status/216814363221303296&#34; target=&#34;_blank&#34;&gt;第1引数がメンバ関数へのポインタの場合でも非静的メンバデータへのポインタの場合でも，第2引数がクラスオブジェクトへの参照の場合でもポインタの場合でもポインタっぽいものの場合でも，なんか知らんけどそれっぽく上手くいく&lt;/a&gt; ように取り計らった操作のことである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;function&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;bind&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/thread.html&#34;&gt;thread&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/async.html&#34;&gt;async&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/packaged_task.html&#34;&gt;packaged_task&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/call_once.html&#34;&gt;call_once&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf&#34; target=&#34;_blank&#34;&gt;P0777R1 Treating Unnecessary &lt;code&gt;decay&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++20から&lt;code&gt;decay_t&lt;/code&gt;を&lt;code&gt;remove_cvref_t&lt;/code&gt;へ変更。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- C++20 : P0777R1対応</title>
      <link href="https://cpprefjp.github.io/reference/optional/optional/op_constructor.html"/>
      <id>df3cf1576616ea59ff5b6f2e46c42aad9b88d734:reference/optional/optional/op_constructor.md</id>
      <updated>2023-01-13T18:13:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/optional/optional/op_constructor.md b/reference/optional/optional/op_constructor.md
index 3046ccd0e..d584fdc65 100644
--- a/reference/optional/optional/op_constructor.md
+++ b/reference/optional/optional/op_constructor.md
@@ -221,6 +221,7 @@ int main()
 - [LWG Issue 2842. `in_place_t` check for `optional::optional(U&amp;amp;&amp;amp;)` should decay `U`](https://wg21.cmeerw.net/lwg/issue2842)
     - 説明の簡略化のため、このオーバーロードで`in_place_t`への言及は現在していない
 - [LWG Issue 2900. The copy and move constructors of `optional` are not `constexpr`](https://wg21.cmeerw.net/lwg/issue2900)
+- [P0777R1 Treating Unnecessary `decay`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf)
 - [P0892R2 `explicit(bool)`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0892r2.html)
     - C++20での`explicit(bool)`構文への対応
-- [P0602R4 `variant` and `optional` should propagate copy/move triviality](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0602r4.html)
\ No newline at end of file
+- [P0602R4 `variant` and `optional` should propagate copy/move triviality](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0602r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>apply -- C++20 : P0777R1対応</title>
      <link href="https://cpprefjp.github.io/reference/tuple/apply.html"/>
      <id>df3cf1576616ea59ff5b6f2e46c42aad9b88d734:reference/tuple/apply.md</id>
      <updated>2023-01-13T18:13:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/apply.md b/reference/tuple/apply.md
index 77d6e1845..ff0343f51 100644
--- a/reference/tuple/apply.md
+++ b/reference/tuple/apply.md
@@ -38,8 +38,17 @@ constexpr decltype(auto) apply-impl(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t, std::index_sequence&amp;lt;I...&amp;gt;)
 * std::invoke[link /reference/functional/invoke.md]
 * std::forward[link /reference/utility/forward.md]
 
-次と等価である。
+C++17 : 次と等価である。
+```cpp
+return apply-impl(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Tuple&amp;gt;(t),
+                  std::make_index_sequence&amp;lt;std::tuple_size_v&amp;lt;std::decay_t&amp;lt;Tuple&amp;gt;&amp;gt;&amp;gt;{});
+```
+* std::tuple_size_v[link tuple_size.md]
+* std::make_index_sequence[link /reference/utility/make_index_sequence.md]
+* std::forward[link /reference/utility/forward.md]
+* std::decay_t[link /reference/type_traits/decay.md]
 
+C++20 : 次と等価である。
 ```cpp
 return apply-impl(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Tuple&amp;gt;(t),
                   std::make_index_sequence&amp;lt;std::tuple_size_v&amp;lt;std::remove_reference_t&amp;lt;Tuple&amp;gt;&amp;gt;&amp;gt;{});
@@ -110,5 +119,7 @@ hello
 - [P0220R0 Adopt Library Fundamentals TS for C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r0.html)
 - [P0220R1 Adopt Library Fundamentals V1 TS Components for C++17 (R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html)
 - [C++1z タプルを展開して関数呼び出しするapply関数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/08/18/184315)
+- [P0777R1 Treating Unnecessary `decay`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf)
+    - C++20から効果説明の`decay_t`を`remove_cvref_t`へ変更。
 - [P2517R1 Add a conditional `noexcept` specification to `std::apply`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2517r1.html)
     - C++23から条件付きで`noexcept`例外指定が行われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- C++20 : P0777R1対応</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant/op_constructor.html"/>
      <id>df3cf1576616ea59ff5b6f2e46c42aad9b88d734:reference/variant/variant/op_constructor.md</id>
      <updated>2023-01-13T18:13:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant/op_constructor.md b/reference/variant/variant/op_constructor.md
index a578926e8..38d1724d0 100644
--- a/reference/variant/variant/op_constructor.md
+++ b/reference/variant/variant/op_constructor.md
@@ -60,9 +60,10 @@ constexpr explicit variant(in_place_index_t&amp;lt;I&amp;gt;,
 - (4) :
     - C++17 : ここで説明用に、`*this`が保持している型`Tj`と、そのインデックス値`j`を定義する。`Types...`の各型`Ti`に対して擬似的な関数`FUN(Ti)`を定義したとして、`FUN(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(t))`呼び出しによって選択されたオーバーロードされた関数のパラメータ型を、構築してその後含まれる値の型を`Tj`とする
     - C++20 : ここで説明用に、`*this`が保持している型`Tj`と、そのインデックス値`j`を定義する。`Types...`の各型`Ti`を、縮小変換を受け付けない型であり (`Ti x[] = {`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(t)};`)、CV修飾付き`bool`の場合にCV修飾を外した`bool`型になるとして、その型に対して擬似的な関数`FUN(Ti)`を定義したとして、`FUN(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(t))`呼び出しによって選択されたオーバーロードされた関数のパラメータ型を、構築してその後含まれる値の型を`Tj`とする
-    - [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;, variant&amp;gt;`が`false`であること
-    - 型[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;`が[`in_place_type_t`](/reference/utility/in_place_type_t.md)および[`in_place_index_t`](/reference/utility/in_place_index_t.md)の特殊化ではないこと
-    - [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;Tj, T&amp;gt;`が`true`であること
+    - C++17 : [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;, variant&amp;gt;`が`false`であること
+    - C++20 : [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;T&amp;gt;, variant&amp;gt;`が`false`であること
+    - C++17 : 型[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;`が[`in_place_type_t`](/reference/utility/in_place_type_t.md)および[`in_place_index_t`](/reference/utility/in_place_index_t.md)の特殊化ではないこと
+    - C++20 : 型[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;T&amp;gt;`が[`in_place_type_t`](/reference/utility/in_place_type_t.md)および[`in_place_index_t`](/reference/utility/in_place_index_t.md)の特殊化ではないこと    - [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;Tj, T&amp;gt;`が`true`であること
     - 式`FUN(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(x))`が適格であること
 - (5) :
     - `Types...`内に`T`が一度だけ現れること
@@ -364,3 +365,5 @@ int main()
 - [LWG Issue 2901 Variants cannot properly support allocators](https://cplusplus.github.io/LWG/issue2901)
 - [P0608R3 A sane variant converting constructor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html)
 - [P0602R4 `variant` and `optional` should propagate copy/move triviality](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0602r4.html)
+- [P0777R1 Treating Unnecessary `decay`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf)
+    - C++20からテンプレートパラメータ制約の`decay_t`を`remove_cvref_t`へ変更。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exchange -- utility/exchange: fix markup</title>
      <link href="https://cpprefjp.github.io/reference/utility/exchange.html"/>
      <id>b40b1a83eab6a27b8ed6b09af38212277074c214:reference/utility/exchange.md</id>
      <updated>2023-01-13T17:22:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/exchange.md b/reference/utility/exchange.md
index 2a4a0f2ba..9c103e5ed 100644
--- a/reference/utility/exchange.md
+++ b/reference/utility/exchange.md
@@ -41,7 +41,7 @@ return old_val;
 
 
 ## 例外
-C++23から : 例外指定の式は次と等価 : [`is_nothrow_move_constructible_v](/reference/type_traits/is_nothrow_move_constructible.md)`&amp;lt;T&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_assignable_v`](/reference/type_traits/is_nothrow_assignable.md)`&amp;lt;T&amp;amp;, U&amp;gt;`
+C++23から : 例外指定の式は次と等価 : [`is_nothrow_move_constructible_v`](/reference/type_traits/is_nothrow_move_constructible.md)`&amp;lt;T&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_assignable_v`](/reference/type_traits/is_nothrow_assignable.md)`&amp;lt;T&amp;amp;, U&amp;gt;`
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exchange -- utility/exchange: P2401R0対応(#1065)</title>
      <link href="https://cpprefjp.github.io/reference/utility/exchange.html"/>
      <id>a01dfab45ae2c0c89c3462ab6ebbccfaa25e2fdd:reference/utility/exchange.md</id>
      <updated>2023-01-13T17:14:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/exchange.md b/reference/utility/exchange.md
index 23e6c4cc9..2a4a0f2ba 100644
--- a/reference/utility/exchange.md
+++ b/reference/utility/exchange.md
@@ -7,10 +7,14 @@
 ```cpp
 namespace std {
   template &amp;lt;class T, class U=T&amp;gt;
-  T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val);           // C++14
+  T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val);           // (1) C++14
 
   template &amp;lt;class T, class U=T&amp;gt;
-  constexpr T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val); // C++20
+  constexpr T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val); // (1) C++20
+
+  template &amp;lt;class T, class U=T&amp;gt;
+  constexpr T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val)
+    noexcept(see below);                     // (1) C++23
 }
 ```
 
@@ -36,6 +40,10 @@ return old_val;
 この関数を呼び出す前の、第1パラメータ`obj`の状態を返す。
 
 
+## 例外
+C++23から : 例外指定の式は次と等価 : [`is_nothrow_move_constructible_v](/reference/type_traits/is_nothrow_move_constructible.md)`&amp;lt;T&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_assignable_v`](/reference/type_traits/is_nothrow_assignable.md)`&amp;lt;T&amp;amp;, U&amp;gt;`
+
+
 ## 備考
 この関数は、[`std::atomic_exchange()`](/reference/atomic/atomic_exchange.md)関数の経験から導入された。
 
@@ -206,3 +214,4 @@ Hello 0x7ffc560ca4cc
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
 - [`std::exchange` Patterns: Fast, Safe, Expressive, and Probably Underused](https://www.fluentcpp.com/2020/09/25/stdexchange-patterns-fast-safe-expressive-and-probably-underused/)
 - [`std::exchange`によるmoveしてリセットするイディオムの御紹介](https://onihusube.hatenablog.com/entry/2020/10/31/163244)
+- [P2401R0 Add a conditional noexcept specification to std::exchange](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2401r0.html)
\ No newline at end of file
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>抽象型のチェック -- コードブロックにC++指定を忘れてた</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/checking_for_abstract_class_types.html"/>
      <id>d7ebdf4d7158da1a8b24fb289bfdf1256a86e654:lang/cpp20/checking_for_abstract_class_types.md</id>
      <updated>2023-01-13T13:53:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/checking_for_abstract_class_types.md b/lang/cpp20/checking_for_abstract_class_types.md
index 8c2193d9e..cf8b4f572 100644
--- a/lang/cpp20/checking_for_abstract_class_types.md
+++ b/lang/cpp20/checking_for_abstract_class_types.md
@@ -8,7 +8,7 @@ C++17までは以下の仕様があったため、抽象クラスに早期の制
 
 しかし、先行宣言したクラスは、あとで定義が追加されるために、パラメータ型、関数の戻り値型、明示的型変換の型として使用できる。
 
-```
+```cpp
 struct S;
 S f(); // OK: 抽象性はここではチェックされない
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>