<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-12-26T03:34:08.900146</updated>
  <id>11f78f46-fdca-4a88-ab9e-ed87304b4707</id>

  
    <entry>
      <title>basic_fstream -- added sample program and explanation for fstream</title>
      <link href="https://cpprefjp.github.io/reference/fstream/basic_fstream.html"/>
      <id>21abedcfe2c88d697684e421604e1e9601e8e15e:reference/fstream/basic_fstream.md</id>
      <updated>2024-12-26T12:31:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/fstream/basic_fstream.md b/reference/fstream/basic_fstream.md
index d0c1c530d..e98b27570 100644
--- a/reference/fstream/basic_fstream.md
+++ b/reference/fstream/basic_fstream.md
@@ -16,7 +16,7 @@ namespace std {
 * basic_iostream[link /reference/istream/basic_iostream.md]
 
 ## 概要
-
+ファイルに対する入出力を提供する高水準な機構
 
 ## メンバ関数
 
@@ -49,3 +49,38 @@ namespace std {
 | `off_type`       | `Traits::off_type`            | |
 | `traits_type`    | テンプレート仮引数`Traits`    | |
 
+## 例
+```cpp example
+#include &amp;lt;fstream&amp;gt;
+#include &amp;lt;ios&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main() {
+  std::fstream fs;
+  fs.exceptions(std::ios::failbit | std::ios::badbit); // 例外を有効化する
+  try {
+    fs.open(&amp;#34;./temp.txt&amp;#34;, std::ios_base::out | std::ios_base::in | std::ios_base::trunc);
+    if (!fs.is_open()) {
+      throw std::runtime_error(&amp;#34;Failed to open file&amp;#34;); // ファイルが開けなかった場合
+    }
+    int a = 1;
+    long double b = 3.141592;
+    std::string c = &amp;#34;hello&amp;#34;;
+    fs &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; std::endl;
+    fs.seekg(0);
+    int d;
+    long double e;
+    std::string f;
+    fs &amp;gt;&amp;gt; d &amp;gt;&amp;gt; e &amp;gt;&amp;gt; f;
+    if (!fs) {
+      throw std::runtime_error(&amp;#34;Failed to read from file&amp;#34;); // ファイルから読み取れなかった場合
+    }
+    std::cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; e &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; std::endl;
+  } catch (const std::exception&amp;amp; e) {
+    std::cerr &amp;lt;&amp;lt; &amp;#34;Error: &amp;#34; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
+    return 1;
+  }
+  return 0;
+}
+```
\ No newline at end of file
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>rotarymars</name>
        <email>s.goto2050@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>機能テストマクロ -- ヘッダのリンクのテキストとアドレスの不一致を修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp14/feature_test_macros.html"/>
      <id>08bb4ea25f7b80e3098f1864174c87d2aa893a39:lang/cpp14/feature_test_macros.md</id>
      <updated>2024-12-25T16:32:04+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;機能テストマクロ&lt;/span&gt;&lt;span class=&#34;cpp cpp14&#34; title=&#34;C++14で追加&#34;&gt;(C++14)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;このページはC++14に採用された言語機能の変更を解説しています。&lt;/p&gt;
&lt;p&gt;のちのC++規格でさらに変更される場合があるため&lt;a href=&#34;#relative-page&#34;&gt;関連項目&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;SD-6 は C++14 の機能について以下のテストマクロを定義することを推奨している：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;マクロ名&lt;/th&gt;
&lt;th&gt;値&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_aggregate_nsdmi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メンバ初期化子と集約&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_binary_literals&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;binary_literals.html&#34;&gt;二進数リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_constexpr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;relaxing_constraints_on_constexpr.html&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;関数内での条件分岐とループの文を許可/&lt;code&gt;constexpr&lt;/code&gt; メンバ関数の暗黙的な &lt;code&gt;const&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_decltype_auto&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;return_type_deduction_for_normal_functions.html&#34;&gt;通常関数の戻り値型推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_generic_lambdas&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;generic_lambdas.html&#34;&gt;ジェネリックラムダ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_init_captures&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;initialize_capture.html&#34;&gt;ラムダ式の初期化キャプチャ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_chrono_udls&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/chrono/duration.html&#34;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; のユーザー定義リテラル (&lt;code&gt;&lt;a href=&#34;../../reference/chrono/duration/op_ns.html&#34;&gt;ns&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/chrono/duration/op_us.html&#34;&gt;us&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/chrono/duration/op_ms.html&#34;&gt;ms&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/chrono/duration/op_s.html&#34;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/chrono/duration/op_min.html&#34;&gt;min&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/chrono/duration/op_h.html&#34;&gt;h&lt;/a&gt;&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_complex_udls&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201309&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ユーザー定義虚数リテラル (&lt;code&gt;&lt;a href=&#34;../../reference/complex/complex/op_i.html&#34;&gt;i&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/complex/complex/op_if.html&#34;&gt;if&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/complex/complex/op_il.html&#34;&gt;il&lt;/a&gt;&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/complex.html&#34;&gt;&amp;lt;complex&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_exchange_function&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/utility/exchange.html&#34;&gt;std::exchange&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_generic_associative_lookup&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;連想配列 (&lt;code&gt;&lt;a href=&#34;../../reference/map/map.html&#34;&gt;std::map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/map/multimap.html&#34;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/set/set.html&#34;&gt;std::set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/set/multiset.html&#34;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;) における異なる型の比較 (&lt;code&gt;count&lt;/code&gt;, &lt;code&gt;equal_range&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;lower_bound&lt;/code&gt;, &lt;code&gt;upper_bound&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/map.html&#34;&gt;&amp;lt;map&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;../../reference/set.html&#34;&gt;&amp;lt;set&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_integer_sequence&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;../../reference/utility/integer_sequence.html&#34;&gt;コンパイル時整数列&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_integral_constant_callable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits/integral_constant.html&#34;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;operator()&lt;/code&gt; を追加&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_is_final&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201402&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits/is_final.html&#34;&gt;std::is_final&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_is_null_pointer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201309&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits/is_null_pointer.html&#34;&gt;std::is_null_pointer&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_make_reverse_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201402&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/iterator/make_reverse_iterator.html&#34;&gt;std::make_reverse_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_make_unique&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/memory/make_unique.html&#34;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/memory/make_unique.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_null_iterators&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ヌル前方向イテレータ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_quoted_string_io&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/iomanip/quoted.html&#34;&gt;std::quoted&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/iomanip.html&#34;&gt;&amp;lt;iomanip&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_result_of_sfinae&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201210&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits/result_of.html&#34;&gt;std::result_of&lt;/a&gt;&lt;/code&gt; と SFINAE&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_robust_nonmodifying_seq_ops&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;シーケンスを変更しない操作をよりロバストに&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_shared_timed_mutex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201402&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;shared_mutex&lt;/code&gt; を &lt;code&gt;&lt;a href=&#34;../../reference/shared_mutex/shared_timed_mutex.html&#34;&gt;shared_timed_mutex&lt;/a&gt;&lt;/code&gt; にリネーム&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/shared_mutex.html&#34;&gt;&amp;lt;shared_mutex&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_string_udls&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ユーザー定義 &lt;code&gt;&lt;a href=&#34;../../reference/string/basic_string/op_s.html&#34;&gt;std::string_literals::basic_string::sリテラル&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/string.html&#34;&gt;&amp;lt;string&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_transformation_trait_aliases&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型トレイトにエイリアステンプレートを追加&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_transparent_operators&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201210&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt; の二項演算のデフォルトテンプレート引数を &lt;code&gt;void&lt;/code&gt; に&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_tuple_element_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201402&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/tuple/tuple_element.html&#34;&gt;std::tuple_element_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_lib_tuples_by_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;../../reference/tuple/tuple/get.html&#34;&gt;型による &lt;code&gt;std::tuple::get&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;../../reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_return_type_deduction&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;return_type_deduction_for_normal_functions.html&#34;&gt;通常関数の戻り値型推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_sized_deallocation&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201309&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;sized_deallocation.html&#34;&gt;サイズ付きデアロケーション&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cpp_variable_templates&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201304&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;variable_templates.html&#34;&gt;変数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__has_cpp_attribute(deprecated)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201309&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;deprecated_attr.html&#34;&gt;&lt;code&gt;[[deprecated]]&lt;/code&gt;属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__has_include(&amp;lt;shared_mutex&amp;gt;)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;../../reference/shared_mutex.html&#34;&gt;共有ロック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;predefined&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations#recs.cpp14&#34; target=&#34;_blank&#34;&gt;SD-6: SG10 Feature Test Recommendations: Standard C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_exchange_strong -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/compare_exchange_strong.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/compare_exchange_strong.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/compare_exchange_strong.md b/reference/atomic/atomic/compare_exchange_strong.md
index efc248a09..f1beed8cb 100644
--- a/reference/atomic/atomic/compare_exchange_strong.md
+++ b/reference/atomic/atomic/compare_exchange_strong.md
@@ -6,25 +6,42 @@
 * cpp11[meta cpp]
 
 ```cpp
-bool compare_exchange_strong(T&amp;amp; expected,
-                             T desired,
-                             memory_order success,
-                             memory_order failure
-                             ) volatile noexcept;  // (1) C++11
-bool compare_exchange_strong(T&amp;amp; expected,
-                             T desired,
-                             memory_order success,
-                             memory_order failure
-                             ) noexcept;           // (2) C++11
-
-bool compare_exchange_strong(T&amp;amp; expected,
-                             T desired,
-                             memory_order order = memory_order_seq_cst
-                             ) volatile noexcept;  // (3) C++11
-bool compare_exchange_strong(T&amp;amp; expected,
-                             T desired,
-                             memory_order order = memory_order_seq_cst
-                             ) noexcept;           // (4) C++11
+bool
+  compare_exchange_strong(T&amp;amp; expected,
+                          T desired,
+                          memory_order success,
+                          memory_order failure
+                          ) volatile noexcept;  // (1) C++11
+
+bool
+  compare_exchange_strong(T&amp;amp; expected,
+                          T desired,
+                          memory_order success,
+                          memory_order failure
+                          ) noexcept;           // (2) C++11
+constexpr bool
+  compare_exchange_strong(T&amp;amp; expected,
+                          T desired,
+                          memory_order success,
+                          memory_order failure
+                          ) noexcept;           // (2) C++26
+
+bool
+  compare_exchange_strong(T&amp;amp; expected,
+                          T desired,
+                          memory_order order = memory_order_seq_cst
+                          ) volatile noexcept;  // (3) C++11
+
+bool
+  compare_exchange_strong(T&amp;amp; expected,
+                          T desired,
+                          memory_order order = memory_order_seq_cst
+                          ) noexcept;           // (4) C++11
+constexpr bool
+  compare_exchange_strong(T&amp;amp; expected,
+                          T desired,
+                          memory_order order = memory_order_seq_cst
+                          ) noexcept;           // (4) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -180,3 +197,5 @@ true
 - [Understand `std::atomic::compare_exchange_weak()` in C++11 - Eric Z&amp;#39;s blog](https://tonywearme.wordpress.com/2014/08/15/understand-stdatomiccompare_exchange_weak-in-c11/)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_exchange_weak -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/compare_exchange_weak.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/compare_exchange_weak.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/compare_exchange_weak.md b/reference/atomic/atomic/compare_exchange_weak.md
index 68c4f23bb..6ae981e4d 100644
--- a/reference/atomic/atomic/compare_exchange_weak.md
+++ b/reference/atomic/atomic/compare_exchange_weak.md
@@ -6,25 +6,42 @@
 * cpp11[meta cpp]
 
 ```cpp
-bool compare_exchange_weak(T&amp;amp; expected,
-                           T desired,
-                           memory_order success,
-                           memory_order failure
-                           ) volatile noexcept;  // (1) C++11
-bool compare_exchange_weak(T&amp;amp; expected,
-                           T desired,
-                           memory_order success,
-                           memory_order failure
-                           ) noexcept;           // (2) C++11
-
-bool compare_exchange_weak(T&amp;amp; expected,
-                           T desired,
-                           memory_order order = memory_order_seq_cst
-                           ) volatile noexcept;  // (3) C++11
-bool compare_exchange_weak(T&amp;amp; expected,
-                           T desired,
-                           memory_order order = memory_order_seq_cst
-                           ) noexcept;           // (4) C++11
+bool
+  compare_exchange_weak(T&amp;amp; expected,
+                        T desired,
+                        memory_order success,
+                        memory_order failure
+                        ) volatile noexcept;  // (1) C++11
+
+bool
+  compare_exchange_weak(T&amp;amp; expected,
+                        T desired,
+                        memory_order success,
+                        memory_order failure
+                        ) noexcept;           // (2) C++11
+constexpr bool
+  compare_exchange_weak(T&amp;amp; expected,
+                        T desired,
+                        memory_order success,
+                        memory_order failure
+                        ) noexcept;           // (2) C++26
+
+bool
+  compare_exchange_weak(T&amp;amp; expected,
+                        T desired,
+                        memory_order order = memory_order_seq_cst
+                        ) volatile noexcept;  // (3) C++11
+
+bool
+  compare_exchange_weak(T&amp;amp; expected,
+                        T desired,
+                        memory_order order = memory_order_seq_cst
+                        ) noexcept;           // (4) C++11
+constexpr bool
+  compare_exchange_weak(T&amp;amp; expected,
+                        T desired,
+                        memory_order order = memory_order_seq_cst
+                        ) noexcept;           // (4) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -205,3 +222,5 @@ int main()
 - [Understand `std::atomic::compare_exchange_weak()` in C++11 - Eric Z&amp;#39;s blog](https://tonywearme.wordpress.com/2014/08/15/understand-stdatomiccompare_exchange_weak-in-c11/)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exchange -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/exchange.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/exchange.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/exchange.md b/reference/atomic/atomic/exchange.md
index ecad452c2..a0eb2da87 100644
--- a/reference/atomic/atomic/exchange.md
+++ b/reference/atomic/atomic/exchange.md
@@ -6,12 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T exchange(T desired,
+T
+  exchange(T desired,
            memory_order order = memory_order_seq_cst
            ) volatile noexcept;                      // (1) C++11
-T exchange(T desired,
+
+T
+  exchange(T desired,
            memory_order order = memory_order_seq_cst
            ) noexcept;                               // (2) C++11
+constexpr T
+  exchange(T desired,
+           memory_order order = memory_order_seq_cst
+           ) noexcept;                               // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -81,3 +88,5 @@ replaced 1 by 2
 ## 参照
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_add -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_add.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/fetch_add.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_add.md b/reference/atomic/atomic/fetch_add.md
index 950f569c9..b62930bbd 100644
--- a/reference/atomic/atomic/fetch_add.md
+++ b/reference/atomic/atomic/fetch_add.md
@@ -6,12 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_add(difference_type operand,
+T
+  fetch_add(difference_type operand,
             memory_order order = memory_order_seq_cst
             ) volatile noexcept;                       // (1) C++11
-T fetch_add(difference_type operand,
+
+T
+  fetch_add(difference_type operand,
             memory_order order = memory_order_seq_cst
             ) noexcept;                                // (2) C++11
+constexpr T
+  fetch_add(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -154,3 +161,5 @@ int main()
     - C++20での、浮動小数点数版の追加
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_and -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_and.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/fetch_and.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_and.md b/reference/atomic/atomic/fetch_and.md
index 673aef1e4..8209763f8 100644
--- a/reference/atomic/atomic/fetch_and.md
+++ b/reference/atomic/atomic/fetch_and.md
@@ -6,12 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_and(T operand,
+T
+  fetch_and(T operand,
             memory_order order = memory_order_seq_cst
             ) volatile noexcept;                       // (1) C++11
-T fetch_and(T operand,
+
+T
+  fetch_and(T operand,
             memory_order order = memory_order_seq_cst
             ) noexcept;                                // (2) C++11
+constexpr T
+  fetch_and(T operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -131,3 +138,5 @@ int main()
     - C++17での、オブジェクト型であることの制約追加
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_max -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_max.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/fetch_max.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_max.md b/reference/atomic/atomic/fetch_max.md
index f4da609a6..117fb1640 100644
--- a/reference/atomic/atomic/fetch_max.md
+++ b/reference/atomic/atomic/fetch_max.md
@@ -6,7 +6,8 @@
 * cpp26[meta cpp]
 
 ```cpp
-T fetch_max(difference_type operand,
+constexpr T
+  fetch_max(difference_type operand,
             memory_order order = memory_order_seq_cst
             ) const noexcept;                         // (1) C++26
 ```
@@ -70,3 +71,4 @@ int main()
 
 ## 参照
 - [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_min -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_min.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/fetch_min.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_min.md b/reference/atomic/atomic/fetch_min.md
index 576ab3fcf..e813120f4 100644
--- a/reference/atomic/atomic/fetch_min.md
+++ b/reference/atomic/atomic/fetch_min.md
@@ -6,7 +6,8 @@
 * cpp26[meta cpp]
 
 ```cpp
-T fetch_min(difference_type operand,
+constexpr T
+  fetch_min(difference_type operand,
             memory_order order = memory_order_seq_cst
             ) const noexcept;                         // (1) C++26
 ```
@@ -70,3 +71,4 @@ int main()
 
 ## 参照
 - [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_or -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_or.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/fetch_or.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_or.md b/reference/atomic/atomic/fetch_or.md
index 988ba029e..9135670e2 100644
--- a/reference/atomic/atomic/fetch_or.md
+++ b/reference/atomic/atomic/fetch_or.md
@@ -6,12 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_or(T operand,
+T
+  fetch_or(T operand,
            memory_order order = memory_order_seq_cst
            ) volatile noexcept;                      // (1) C++11
-T fetch_or(T operand,
+
+T
+  fetch_or(T operand,
            memory_order order = memory_order_seq_cst
            ) noexcept;                               // (2) C++11
+constexpr T
+  fetch_or(T operand,
+           memory_order order = memory_order_seq_cst
+           ) noexcept;                               // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -131,3 +138,5 @@ int main()
     - C++17での、オブジェクト型であることの制約追加
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_sub -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_sub.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/fetch_sub.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_sub.md b/reference/atomic/atomic/fetch_sub.md
index 16f9bfc1a..e81ec5c8d 100644
--- a/reference/atomic/atomic/fetch_sub.md
+++ b/reference/atomic/atomic/fetch_sub.md
@@ -6,12 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_sub(difference_type operand,
+T
+  fetch_sub(difference_type operand,
             memory_order order = memory_order_seq_cst
             ) volatile noexcept;                       // (1) C++11
-T fetch_sub(difference_type operand,
+
+T
+  fetch_sub(difference_type operand,
             memory_order order = memory_order_seq_cst
             ) noexcept;                                // (2) C++11
+constexpr T
+  fetch_sub(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -151,3 +158,5 @@ int main()
     - C++20での、浮動小数点数版の追加
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_xor -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_xor.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/fetch_xor.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_xor.md b/reference/atomic/atomic/fetch_xor.md
index f00b996bf..40e99fff1 100644
--- a/reference/atomic/atomic/fetch_xor.md
+++ b/reference/atomic/atomic/fetch_xor.md
@@ -6,12 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_xor(T operand,
+T
+  fetch_xor(T operand,
             memory_order order = memory_order_seq_cst
             ) volatile noexcept;                      // (1) C++11
-T fetch_xor(T operand,
+
+T
+  fetch_xor(T operand,
             memory_order order = memory_order_seq_cst
             ) noexcept;                               // (2) C++11
+constexpr T
+  fetch_xor(T operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                               // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -133,3 +140,5 @@ int main()
     - C++17での、オブジェクト型であることの制約追加
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>load -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/load.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/load.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/load.md b/reference/atomic/atomic/load.md
index 122d12e8a..6d9c3db9f 100644
--- a/reference/atomic/atomic/load.md
+++ b/reference/atomic/atomic/load.md
@@ -6,10 +6,16 @@
 * cpp11[meta cpp]
 
 ```cpp
-T load(memory_order order = memory_order_seq_cst
+T
+  load(memory_order order = memory_order_seq_cst
       ) const volatile noexcept;                 // (1) C++11
-T load(memory_order order = memory_order_seq_cst
+
+T
+  load(memory_order order = memory_order_seq_cst
       ) const noexcept;                          // (2) C++11
+constexpr T
+  load(memory_order order = memory_order_seq_cst
+      ) const noexcept;                          // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -82,3 +88,5 @@ int main()
 ## 参照
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_all -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/notify_all.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/notify_all.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/notify_all.md b/reference/atomic/atomic/notify_all.md
index d861d0a2d..53841c410 100644
--- a/reference/atomic/atomic/notify_all.md
+++ b/reference/atomic/atomic/notify_all.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_all() volatile noexcept; // (1) C++20
-void notify_all() noexcept;          // (2) C++20
+void notify_all() volatile noexcept;  // (1) C++20
+
+void notify_all() noexcept;           // (2) C++20
+constexpr void notify_all() noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -91,3 +93,5 @@ int main()
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_one -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/notify_one.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/notify_one.md b/reference/atomic/atomic/notify_one.md
index 9cad212ca..70f306111 100644
--- a/reference/atomic/atomic/notify_one.md
+++ b/reference/atomic/atomic/notify_one.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_one() volatile noexcept; // (1) C++20
-void notify_one() noexcept;          // (2) C++20
+void notify_one() volatile noexcept;  // (1) C++20
+
+void notify_one() noexcept;           // (2) C++20
+constexpr void notify_one() noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -117,3 +119,5 @@ int main()
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&amp;= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_and_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_and_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_and_assign.md b/reference/atomic/atomic/op_and_assign.md
index 23312eab7..530fdeb71 100644
--- a/reference/atomic/atomic/op_and_assign.md
+++ b/reference/atomic/atomic/op_and_assign.md
@@ -6,8 +6,10 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator&amp;amp;=(T operand) volatile noexcept; // (1) C++11
-T operator&amp;amp;=(T operand) noexcept;          // (2) C++11
+T operator&amp;amp;=(T operand) volatile noexcept;  // (1) C++11
+
+T operator&amp;amp;=(T operand) noexcept;           // (2) C++11
+constexpr T operator&amp;amp;=(T operand) noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -123,3 +125,5 @@ int main()
 ## 参照
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_assign.md b/reference/atomic/atomic/op_assign.md
index c5e2b19e9..2d0957921 100644
--- a/reference/atomic/atomic/op_assign.md
+++ b/reference/atomic/atomic/op_assign.md
@@ -10,7 +10,9 @@ atomic&amp;amp; operator=(const atomic&amp;amp;) = delete;          // (1) C++11
 atomic&amp;amp; operator=(const atomic&amp;amp;) volatile = delete; // (2) C++11
 
 T operator=(T desired) volatile noexcept;           // (3) C++11
+
 T operator=(T desired) noexcept;                    // (4) C++11
+constexpr T operator=(T desired) noexcept;          // (4) C++26
 ```
 
 ## 概要
@@ -77,3 +79,5 @@ int main()
 ## 参照
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-- -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_decrement.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_decrement.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_decrement.md b/reference/atomic/atomic/op_decrement.md
index 9073ba75f..3db4228cf 100644
--- a/reference/atomic/atomic/op_decrement.md
+++ b/reference/atomic/atomic/op_decrement.md
@@ -6,17 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator--() volatile noexcept;             // (1) C++11
-value_type operator--() volatile noexcept;    // (1) C++20
+T operator--() volatile noexcept;              // (1) C++11
+value_type operator--() volatile noexcept;     // (1) C++20
 
-T operator--() noexcept;                      // (2) C++11
-value_type operator--() noexcept;             // (2) C++20
+T operator--() noexcept;                       // (2) C++11
+value_type operator--() noexcept;              // (2) C++20
+constexpr value_type operator--() noexcept;    // (2) C++26
 
-T operator--(int) volatile noexcept;          // (3) C++11
-value_type operator--(int) volatile noexcept; // (3) C++20
+T operator--(int) volatile noexcept;           // (3) C++11
+value_type operator--(int) volatile noexcept;  // (3) C++20
 
-T operator--(int) noexcept;                   // (4) C++11
-value_type operator--(int) noexcept;          // (4) C++20
+T operator--(int) noexcept;                    // (4) C++11
+value_type operator--(int) noexcept;           // (4) C++20
+constexpr value_type operator--(int) noexcept; // (4) C++26
 ```
 
 ## 概要
@@ -123,3 +125,5 @@ int main()
     - C++20での、`volatile`版への制約追加
 - [P1960R0 NB Comment Changes Reviewed by SG1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1960r0.html)
     - 戻り値の型を`T`から`value_type`に変更
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator++ -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_increment.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_increment.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_increment.md b/reference/atomic/atomic/op_increment.md
index 683ee6e01..cb75999fc 100644
--- a/reference/atomic/atomic/op_increment.md
+++ b/reference/atomic/atomic/op_increment.md
@@ -6,17 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator++() volatile noexcept;             // (1) C++11
-value_type operator++() volatile noexcept;    // (1) C++20
+T operator++() volatile noexcept;              // (1) C++11
+value_type operator++() volatile noexcept;     // (1) C++20
 
-T operator++() noexcept;                      // (2) C++11
-value_type operator++() noexcept;             // (2) C++20
+T operator++() noexcept;                       // (2) C++11
+value_type operator++() noexcept;              // (2) C++20
+constexpr value_type operator++() noexcept;    // (2) C++26
 
-T operator++(int) volatile noexcept;          // (3) C++11
-value_type operator++(int) volatile noexcept; // (3) C++20
+T operator++(int) volatile noexcept;           // (3) C++11
+value_type operator++(int) volatile noexcept;  // (3) C++20
 
-T operator++(int) noexcept;                   // (4) C++11
-value_type operator++(int) noexcept;          // (4) C++20
+T operator++(int) noexcept;                    // (4) C++11
+value_type operator++(int) noexcept;           // (4) C++20
+constexpr value_type operator++(int) noexcept; // (4) C++26
 ```
 
 ## 概要
@@ -126,3 +128,5 @@ int main()
     - C++20での、`volatile`版への制約追加
 - [P1960R0 NB Comment Changes Reviewed by SG1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1960r0.html)
     - 戻り値の型を`T`から`value_type`に変更
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_minus_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_minus_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_minus_assign.md b/reference/atomic/atomic/op_minus_assign.md
index 097d5d2c9..837f70a1e 100644
--- a/reference/atomic/atomic/op_minus_assign.md
+++ b/reference/atomic/atomic/op_minus_assign.md
@@ -6,8 +6,10 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator-=(T operand) volatile noexcept; // (1) C++11
-T operator-=(T operand) noexcept;          // (2) C++11
+T operator-=(T operand) volatile noexcept;  // (1) C++11
+
+T operator-=(T operand) noexcept;           // (2) C++11
+constexpr T operator-=(T operand) noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -144,3 +146,5 @@ int main()
     - C++20での、浮動小数点数版の追加
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator|= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_or_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_or_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_or_assign.md b/reference/atomic/atomic/op_or_assign.md
index 4f63f0972..d06db1922 100644
--- a/reference/atomic/atomic/op_or_assign.md
+++ b/reference/atomic/atomic/op_or_assign.md
@@ -6,8 +6,10 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator|=(T operand) volatile noexcept; // (1) C++11
-T operator|=(T operand) noexcept;          // (2) C++11
+T operator|=(T operand) volatile noexcept;  // (1) C++11
+
+T operator|=(T operand) noexcept;           // (2) C++11
+constexpr T operator|=(T operand) noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -124,3 +126,5 @@ int main()
 ## 参照
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_plus_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_plus_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_plus_assign.md b/reference/atomic/atomic/op_plus_assign.md
index b8f5b235d..e397edc54 100644
--- a/reference/atomic/atomic/op_plus_assign.md
+++ b/reference/atomic/atomic/op_plus_assign.md
@@ -6,8 +6,10 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator+=(T operand) volatile noexcept; // (1) C++11
-T operator+=(T operand) noexcept;          // (2) C++11
+T operator+=(T operand) volatile noexcept;  // (1) C++11
+
+T operator+=(T operand) noexcept;           // (2) C++11
+constexpr T operator+=(T operand) noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -142,3 +144,5 @@ int main()
     - C++20での、浮動小数点数版の追加
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator T -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_t.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_t.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_t.md b/reference/atomic/atomic/op_t.md
index d642b30d4..cf76ea75a 100644
--- a/reference/atomic/atomic/op_t.md
+++ b/reference/atomic/atomic/op_t.md
@@ -6,8 +6,10 @@
 * cpp11[meta cpp]
 
 ```cpp
-operator T() const volatile noexcept; // (1) C++11
-operator T() const noexcept;          // (2) C++11
+operator T() const volatile noexcept;  // (1) C++11
+
+operator T() const noexcept;           // (2) C++11
+constexpr operator T() const noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -66,3 +68,5 @@ int main()
 - [N2514 Implicit Conversion Operators for Atomics](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2514.html)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator^= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_xor_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/op_xor_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_xor_assign.md b/reference/atomic/atomic/op_xor_assign.md
index c27ab068f..bb350f898 100644
--- a/reference/atomic/atomic/op_xor_assign.md
+++ b/reference/atomic/atomic/op_xor_assign.md
@@ -6,8 +6,10 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator^=(T operand) volatile noexcept; // (1) C++11
-T operator^=(T operand) noexcept;          // (2) C++11
+T operator^=(T operand) volatile noexcept;  // (1) C++11
+
+T operator^=(T operand) noexcept;           // (2) C++11
+constexpr T operator^=(T operand) noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -126,3 +128,5 @@ int main()
 ## 参照
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>store -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/store.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/store.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/store.md b/reference/atomic/atomic/store.md
index 43fb105ef..da13dfc8d 100644
--- a/reference/atomic/atomic/store.md
+++ b/reference/atomic/atomic/store.md
@@ -6,12 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-void store(T desired,
-           memory_order order = memory_order_seq_cst
-           ) volatile noexcept;                      // (1) C++11
-void store(T desired,
-           memory_order order = memory_order_seq_cst
-           ) noexcept;                               // (2) C++11
+void
+  store(T desired,
+        memory_order order = memory_order_seq_cst
+        ) volatile noexcept;                      // (1) C++11
+
+void
+  store(T desired,
+        memory_order order = memory_order_seq_cst
+        ) noexcept;                               // (2) C++11
+constexpr void
+  store(T desired,
+        memory_order order = memory_order_seq_cst
+        ) noexcept;                               // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -87,3 +94,5 @@ int main()
 ## 参照
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/wait.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic/wait.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/wait.md b/reference/atomic/atomic/wait.md
index d940060c3..226c45d3b 100644
--- a/reference/atomic/atomic/wait.md
+++ b/reference/atomic/atomic/wait.md
@@ -6,12 +6,19 @@
 * cpp20[meta cpp]
 
 ```cpp
-void wait(T old,
-          memory_order order = memory_order::seq_cst
-          ) const volatile noexcept;                 // (1) C++20
-void wait(T old,
-          memory_order order = memory_order::seq_cst
-          ) const noexcept;                          // (2) C++20
+void
+  wait(T old,
+       memory_order order = memory_order::seq_cst
+       ) const volatile noexcept;                 // (1) C++20
+
+void
+  wait(T old,
+       memory_order order = memory_order::seq_cst
+       ) const noexcept;                          // (2) C++20
+constexpr void
+  wait(T old,
+       memory_order order = memory_order::seq_cst
+       ) const noexcept;                          // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
@@ -132,3 +139,5 @@ int main()
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_compare_exchange_strong -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_compare_exchange_strong.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_compare_exchange_strong.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_compare_exchange_strong.md b/reference/atomic/atomic_compare_exchange_strong.md
index 7cecd9045..bb1a04ab0 100644
--- a/reference/atomic/atomic_compare_exchange_strong.md
+++ b/reference/atomic/atomic_compare_exchange_strong.md
@@ -7,28 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_strong(
+  bool
+    atomic_compare_exchange_strong(
          volatile atomic&amp;lt;T&amp;gt;* object,
          T* expected,
          T desired) noexcept;                              // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_strong(
+  bool
+    atomic_compare_exchange_strong(
          volatile atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type* expected,
          typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_strong(
+  bool
+    atomic_compare_exchange_strong(
          atomic&amp;lt;T&amp;gt;* object,
          T* expected,
          T desired) noexcept;                              // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_strong(
+  bool
+    atomic_compare_exchange_strong(
          atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type* expected,
          typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr bool
+    atomic_compare_exchange_strong(
+         atomic&amp;lt;T&amp;gt;* object,
+         typename atomic&amp;lt;T&amp;gt;::value_type* expected,
+         typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -129,3 +137,5 @@ false 3 3
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_compare_exchange_strong_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_compare_exchange_strong_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_compare_exchange_strong_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_compare_exchange_strong_explicit.md b/reference/atomic/atomic_compare_exchange_strong_explicit.md
index f1f4885f3..cd22b992a 100644
--- a/reference/atomic/atomic_compare_exchange_strong_explicit.md
+++ b/reference/atomic/atomic_compare_exchange_strong_explicit.md
@@ -7,15 +7,16 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_strong_explicit(
+  bool
+    atomic_compare_exchange_strong_explicit(
          volatile atomic&amp;lt;T&amp;gt;* object,
          T* expected,
          T desired,
          memory_order success,
          memory_order failure) noexcept;        // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_strong_explicit(
+  bool
+    atomic_compare_exchange_strong_explicit(
          volatile atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type* expected,
          typename atomic&amp;lt;T&amp;gt;::value_type desired,
@@ -23,15 +24,24 @@ namespace std {
          memory_order failure) noexcept;        // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_strong_explicit(
+  bool
+    atomic_compare_exchange_strong_explicit(
          atomic&amp;lt;T&amp;gt;* object,
          T* expected,
          T desired,
          memory_order success,
          memory_order failure) noexcept;        // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_strong_explicit(
+  bool
+    atomic_compare_exchange_strong_explicit(
+         atomic&amp;lt;T&amp;gt;* object,
+         typename atomic&amp;lt;T&amp;gt;::value_type* expected,
+         typename atomic&amp;lt;T&amp;gt;::value_type desired,
+         memory_order success,
+         memory_order failure) noexcept;        // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr bool
+    atomic_compare_exchange_strong_explicit(
          atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type* expected,
          typename atomic&amp;lt;T&amp;gt;::value_type desired,
@@ -149,3 +159,5 @@ false 3 3
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_compare_exchange_weak -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_compare_exchange_weak.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_compare_exchange_weak.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_compare_exchange_weak.md b/reference/atomic/atomic_compare_exchange_weak.md
index 87e0629a9..2e55ec151 100644
--- a/reference/atomic/atomic_compare_exchange_weak.md
+++ b/reference/atomic/atomic_compare_exchange_weak.md
@@ -7,28 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_weak(
+  bool
+    atomic_compare_exchange_weak(
          volatile atomic&amp;lt;T&amp;gt;* object,
          T* expected,
          T desired) noexcept;                              // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_weak(
+  bool
+    atomic_compare_exchange_weak(
          volatile atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type* expected,
          typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_weak(
+  bool
+    atomic_compare_exchange_weak(
          atomic&amp;lt;T&amp;gt;* object,
          T* expected,
          T desired) noexcept;                              // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_weak(
+  bool
+    atomic_compare_exchange_weak(
          atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type* expected,
          typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr bool
+    atomic_compare_exchange_weak(
+         atomic&amp;lt;T&amp;gt;* object,
+         typename atomic&amp;lt;T&amp;gt;::value_type* expected,
+         typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -133,3 +141,5 @@ false 3 3
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_compare_exchange_weak_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_compare_exchange_weak_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_compare_exchange_weak_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_compare_exchange_weak_explicit.md b/reference/atomic/atomic_compare_exchange_weak_explicit.md
index 397bb6392..6c2274c3b 100644
--- a/reference/atomic/atomic_compare_exchange_weak_explicit.md
+++ b/reference/atomic/atomic_compare_exchange_weak_explicit.md
@@ -7,15 +7,16 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_weak_explicit(
+  bool
+    atomic_compare_exchange_weak_explicit(
          volatile atomic&amp;lt;T&amp;gt;* object,
          T* expected,
          T desired,
          memory_order success,
          memory_order failure) noexcept;       // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_weak_explicit(
+  bool
+    atomic_compare_exchange_weak_explicit(
          volatile atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type* expected,
          typename atomic&amp;lt;T&amp;gt;::value_type desired,
@@ -23,20 +24,29 @@ namespace std {
          memory_order failure) noexcept;       // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_weak_explicit(
+  bool
+    atomic_compare_exchange_weak_explicit(
          atomic&amp;lt;T&amp;gt;* object,
          T* expected,
          T desired,
          memory_order success,
          memory_order failure) noexcept;       // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  bool atomic_compare_exchange_weak_explicit(
+  bool
+    atomic_compare_exchange_weak_explicit(
          atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type* expected,
          typename atomic&amp;lt;T&amp;gt;::value_type desired,
          memory_order success,
          memory_order failure) noexcept;       // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr bool
+    atomic_compare_exchange_weak_explicit(
+         atomic&amp;lt;T&amp;gt;* object,
+         typename atomic&amp;lt;T&amp;gt;::value_type* expected,
+         typename atomic&amp;lt;T&amp;gt;::value_type desired,
+         memory_order success,
+         memory_order failure) noexcept;       // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -151,3 +161,5 @@ false 3 3
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_exchange -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_exchange.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_exchange.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_exchange.md b/reference/atomic/atomic_exchange.md
index 7fa78f8f4..7c303880b 100644
--- a/reference/atomic/atomic_exchange.md
+++ b/reference/atomic/atomic_exchange.md
@@ -7,24 +7,31 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_exchange(
+  T
+    atomic_exchange(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T desired) noexcept;                              // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_exchange(
+  T
+    atomic_exchange(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_exchange(
+  T
+    atomic_exchange(
       atomic&amp;lt;T&amp;gt;* object,
       T desired) noexcept;                              // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_exchange(
+  T
+    atomic_exchange(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_exchange(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -99,3 +106,5 @@ replaced 1 by 2
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_exchange_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_exchange_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_exchange_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_exchange_explicit.md b/reference/atomic/atomic_exchange_explicit.md
index 42ce1048b..eecc35383 100644
--- a/reference/atomic/atomic_exchange_explicit.md
+++ b/reference/atomic/atomic_exchange_explicit.md
@@ -7,28 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_exchange_explicit(
+  T
+    atomic_exchange_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T desired,
       memory_order order) noexcept;           // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_exchange_explicit(
+  T
+    atomic_exchange_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type desired,
       memory_order order) noexcept;           // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_exchange_explicit(
+  T
+    atomic_exchange_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       T desired,
       memory_order order) noexcept;           // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_exchange_explicit(
+  T
+    atomic_exchange_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type desired,
       memory_order order) noexcept;           // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_exchange_explicit(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type desired,
+      memory_order order) noexcept;           // (2) C++26
 ]
 ```
 * atomic[link atomic.md]
@@ -105,3 +113,5 @@ replaced 1 by 2
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_add -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_add.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_add.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_add.md b/reference/atomic/atomic_fetch_add.md
index 54d691e9f..87b5a3547 100644
--- a/reference/atomic/atomic_fetch_add.md
+++ b/reference/atomic/atomic_fetch_add.md
@@ -7,22 +7,29 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_add(
+  T
+    atomic_fetch_add(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                                   // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_add(
+  T
+    atomic_fetch_add(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::difference_type operand) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_add(
+  T
+    atomic_fetch_add(
       atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                                   // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_add(
+  T
+    atomic_fetch_add(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::difference_type operand) noexcept; // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_add(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::difference_type operand) noexcept; // (2) C++17
 }
@@ -102,3 +109,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_add_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_add_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_add_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_add_explicit.md b/reference/atomic/atomic_fetch_add_explicit.md
index 6559e86cc..086b4c99b 100644
--- a/reference/atomic/atomic_fetch_add_explicit.md
+++ b/reference/atomic/atomic_fetch_add_explicit.md
@@ -7,28 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_add_explicit(
+  T
+    atomic_fetch_add_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;                // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_add_explicit(
+  T
+    atomic_fetch_add_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::difference_type operand,
       memory_order order) noexcept;                // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_add_explicit(
+  T
+    atomic_fetch_add_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;                // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_add_explicit(
+  T
+    atomic_fetch_add_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::difference_type operand,
       memory_order order) noexcept;                // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_add_explicit(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::difference_type operand,
+      memory_order order) noexcept;                // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -105,3 +113,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_and -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_and.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_and.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_and.md b/reference/atomic/atomic_fetch_and.md
index a1464a21f..154262e79 100644
--- a/reference/atomic/atomic_fetch_and.md
+++ b/reference/atomic/atomic_fetch_and.md
@@ -7,24 +7,31 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_and(
+  T
+    atomic_fetch_and(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                              // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_and(
+  T
+    atomic_fetch_and(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_and(
+  T
+    atomic_fetch_and(
       atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                              // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_and(
+  T
+    atomic_fetch_and(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_and(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -108,3 +115,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_and_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_and_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_and_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_and_explicit.md b/reference/atomic/atomic_fetch_and_explicit.md
index 1cf4be6d1..f989b07c2 100644
--- a/reference/atomic/atomic_fetch_and_explicit.md
+++ b/reference/atomic/atomic_fetch_and_explicit.md
@@ -7,28 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_and_explicit(
+  T
+    atomic_fetch_and_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;           // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_and_explicit(
+  T
+    atomic_fetch_and_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;           // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_and_explicit(
+  T
+    atomic_fetch_and_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;           // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_and_explicit(
+  T
+    atomic_fetch_and_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;           // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_and_explicit(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand,
+      memory_order order) noexcept;           // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -113,3 +121,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_max -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_max.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_max.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_max.md b/reference/atomic/atomic_fetch_max.md
index 72fcef80d..b8cb69083 100644
--- a/reference/atomic/atomic_fetch_max.md
+++ b/reference/atomic/atomic_fetch_max.md
@@ -7,11 +7,13 @@
 ```cpp
 namespace std {
   template &amp;lt;classT&amp;gt;
-  T atomic_fetch_max(volatile atomic&amp;lt;T&amp;gt;* object,
+  T
+    atomic_fetch_max(volatile atomic&amp;lt;T&amp;gt;* object,
                      typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (1) C++26
 
   template &amp;lt;classT&amp;gt;
-  T atomic_fetch_max(atomic&amp;lt;T&amp;gt;* object,
+  constexpr T
+    atomic_fetch_max(atomic&amp;lt;T&amp;gt;* object,
                      typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++26
 }
 ```
@@ -69,3 +71,4 @@ int main()
 
 ## 参照
 - [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_max_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_max_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_max_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_max_explicit.md b/reference/atomic/atomic_fetch_max_explicit.md
index 17c2259b8..0e088ba8a 100644
--- a/reference/atomic/atomic_fetch_max_explicit.md
+++ b/reference/atomic/atomic_fetch_max_explicit.md
@@ -7,13 +7,15 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_max_explicit(
+  T
+    atomic_fetch_max_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;                // (1) C++26
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_max_explicit(
+  constexpr T
+    atomic_fetch_max_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;                // (2) C++26
@@ -71,3 +73,4 @@ int main()
 
 ## 参照
 - [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_min -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_min.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_min.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_min.md b/reference/atomic/atomic_fetch_min.md
index 69e4a164a..26763e2a6 100644
--- a/reference/atomic/atomic_fetch_min.md
+++ b/reference/atomic/atomic_fetch_min.md
@@ -7,11 +7,13 @@
 ```cpp
 namespace std {
   template &amp;lt;classT&amp;gt;
-  T atomic_fetch_min(volatile atomic&amp;lt;T&amp;gt;* object,
+  T
+    atomic_fetch_min(volatile atomic&amp;lt;T&amp;gt;* object,
                      typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (1) C++26
 
   template &amp;lt;classT&amp;gt;
-  T atomic_fetch_min(atomic&amp;lt;T&amp;gt;* object,
+  constexpr T
+    atomic_fetch_min(atomic&amp;lt;T&amp;gt;* object,
                      typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++26
 }
 ```
@@ -69,3 +71,4 @@ int main()
 
 ## 参照
 - [P0493R5 Atomic maximum/minimum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_min_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_min_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_min_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_min_explicit.md b/reference/atomic/atomic_fetch_min_explicit.md
index cac364da7..dd46f1a0c 100644
--- a/reference/atomic/atomic_fetch_min_explicit.md
+++ b/reference/atomic/atomic_fetch_min_explicit.md
@@ -7,13 +7,15 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_min_explicit(
+  T
+    atomic_fetch_min_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;                // (1) C++26
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_min_explicit(
+  constexpr T
+    atomic_fetch_min_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;                // (2) C++26
@@ -71,3 +73,4 @@ int main()
 
 ## 参照
 - [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_or -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_or.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_or.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_or.md b/reference/atomic/atomic_fetch_or.md
index 90a49db9f..09e06a976 100644
--- a/reference/atomic/atomic_fetch_or.md
+++ b/reference/atomic/atomic_fetch_or.md
@@ -7,24 +7,31 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_or(
+  T
+    atomic_fetch_or(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                              // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_or(
+  T
+    atomic_fetch_or(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_or(
+  T
+    atomic_fetch_or(
       atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                              // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_or(
+  T
+    atomic_fetch_or(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_or(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -108,3 +115,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_or_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_or_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_or_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_or_explicit.md b/reference/atomic/atomic_fetch_or_explicit.md
index 1cb327624..65b5e52a5 100644
--- a/reference/atomic/atomic_fetch_or_explicit.md
+++ b/reference/atomic/atomic_fetch_or_explicit.md
@@ -7,28 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_or_explicit(
+  T
+    atomic_fetch_or_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;           // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_or_explicit(
+  T
+    atomic_fetch_or_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;           // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_or_explicit(
+  T
+    atomic_fetch_or_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;           // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_or_explicit(
+  T
+    atomic_fetch_or_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;           // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_or_explicit(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand,
+      memory_order order) noexcept;           // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -112,3 +120,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_sub -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_sub.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_sub.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_sub.md b/reference/atomic/atomic_fetch_sub.md
index 79b2a6cd3..8e3989fa4 100644
--- a/reference/atomic/atomic_fetch_sub.md
+++ b/reference/atomic/atomic_fetch_sub.md
@@ -7,24 +7,31 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_sub(
+  T
+    atomic_fetch_sub(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                                   // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_sub(
+  T
+    atomic_fetch_sub(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::difference_type operand) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_sub(
+  T
+    atomic_fetch_sub(
       atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                                   // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_sub(
+  T
+    atomic_fetch_sub(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::difference_type operand) noexcept; // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_sub(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::difference_type operand) noexcept; // (2) C++26
 }
 ```
 * atomic[link /reference/atomic/atomic.md]
@@ -101,3 +108,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_sub_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_sub_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_sub_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_sub_explicit.md b/reference/atomic/atomic_fetch_sub_explicit.md
index 12227f39b..5e29e2ebf 100644
--- a/reference/atomic/atomic_fetch_sub_explicit.md
+++ b/reference/atomic/atomic_fetch_sub_explicit.md
@@ -7,28 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_sub_explicit(
+  T
+    atomic_fetch_sub_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;                // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_sub_explicit(
+  T
+    atomic_fetch_sub_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::difference_type operand,
       memory_order order) noexcept;                // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_sub_explicit(
+  T
+    atomic_fetch_sub_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;                // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_sub_explicit(
+  T
+    atomic_fetch_sub_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::difference_type operand,
       memory_order order) noexcept;                // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_sub_explicit(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::difference_type operand,
+      memory_order order) noexcept;                // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -106,3 +114,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_xor -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_xor.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_xor.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_xor.md b/reference/atomic/atomic_fetch_xor.md
index 21e2fdbaa..c4558983a 100644
--- a/reference/atomic/atomic_fetch_xor.md
+++ b/reference/atomic/atomic_fetch_xor.md
@@ -7,24 +7,31 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_xor(
+  T
+    atomic_fetch_xor(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                              // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_xor(
+  T
+    atomic_fetch_xor(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_xor(
+  T
+    atomic_fetch_xor(
       atomic&amp;lt;T&amp;gt;* object,
       T operand) noexcept;                              // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_xor(
+  T
+    atomic_fetch_xor(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_xor(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -108,3 +115,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_xor_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_xor_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_fetch_xor_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_xor_explicit.md b/reference/atomic/atomic_fetch_xor_explicit.md
index a92960f97..a7f98893b 100644
--- a/reference/atomic/atomic_fetch_xor_explicit.md
+++ b/reference/atomic/atomic_fetch_xor_explicit.md
@@ -7,28 +7,36 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_xor_explicit(
+  T
+    atomic_fetch_xor_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;           // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_xor_explicit(
+  T
+    atomic_fetch_xor_explicit(
       volatile atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;           // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_xor_explicit(
+  T
+    atomic_fetch_xor_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       T operand,
       memory_order order) noexcept;           // (2) C++11
-
   template &amp;lt;class T&amp;gt;
-  T atomic_fetch_xor_explicit(
+  T
+    atomic_fetch_xor_explicit(
       atomic&amp;lt;T&amp;gt;* object,
       typename atomic&amp;lt;T&amp;gt;::value_type operand,
       memory_order order) noexcept;           // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_fetch_xor_explicit(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand,
+      memory_order order) noexcept;           // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -114,3 +122,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag/clear.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag/clear.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag/clear.md b/reference/atomic/atomic_flag/clear.md
index cfed6ae7a..e8294272e 100644
--- a/reference/atomic/atomic_flag/clear.md
+++ b/reference/atomic/atomic_flag/clear.md
@@ -6,8 +6,16 @@
 * cpp11[meta cpp]
 
 ```cpp
-void clear(memory_order order = memory_order_seq_cst) volatile noexcept;
-void clear(memory_order order = memory_order_seq_cst) noexcept;
+void
+  clear(memory_order order = memory_order_seq_cst
+        ) volatile noexcept;                      // (1) C++11
+
+void
+  clear(memory_order order = memory_order_seq_cst
+       ) noexcept;                                // (2) C++11
+constexpr void
+  clear(memory_order order = memory_order_seq_cst
+       ) noexcept;                                // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -87,5 +95,5 @@ false
 
 ## 参照
 - [LWG Issue 2138. `atomic_flag::clear` should not accept `memory_order_consume`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2138)
-
-
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_all -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag/notify_all.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag/notify_all.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag/notify_all.md b/reference/atomic/atomic_flag/notify_all.md
index 051d0604a..bdab9021d 100644
--- a/reference/atomic/atomic_flag/notify_all.md
+++ b/reference/atomic/atomic_flag/notify_all.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_all() volatile noexcept;
-void notify_all() noexcept;
+void notify_all() volatile noexcept;  // (1) C++20
+
+void notify_all() noexcept;           // (2) C++20
+constexpr void notify_all() noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -82,3 +84,5 @@ int main()
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_one -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag/notify_one.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag/notify_one.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag/notify_one.md b/reference/atomic/atomic_flag/notify_one.md
index aaa9458e4..cfee53fec 100644
--- a/reference/atomic/atomic_flag/notify_one.md
+++ b/reference/atomic/atomic_flag/notify_one.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_one() volatile noexcept;
-void notify_one() noexcept;
+void notify_one() volatile noexcept;  // (1) C++20
+
+void notify_one() noexcept;           // (2) C++20
+constexpr void notify_one() noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -108,3 +110,5 @@ int main()
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>test -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag/test.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag/test.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag/test.md b/reference/atomic/atomic_flag/test.md
index 0004703d7..aef6fdd59 100644
--- a/reference/atomic/atomic_flag/test.md
+++ b/reference/atomic/atomic_flag/test.md
@@ -6,8 +6,16 @@
 * cpp20[meta cpp]
 
 ```cpp
-bool test(memory_order order = memory_order::seq_cst) const volatile noexcept;
-bool test(memory_order order = memory_order::seq_cst) const noexcept;
+bool
+  test(memory_order order = memory_order::seq_cst
+      ) const volatile noexcept;                  // (1) C++20
+
+bool
+  test(memory_order order = memory_order::seq_cst
+       ) const noexcept;                          // (2) C++20
+constexpr bool
+  test(memory_order order = memory_order::seq_cst
+       ) const noexcept;                          // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
@@ -77,3 +85,5 @@ true
 - [P0995R1 Improving atomic_flag](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0995r1.html)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>test_and_set -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag/test_and_set.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag/test_and_set.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag/test_and_set.md b/reference/atomic/atomic_flag/test_and_set.md
index 7ac2cdd48..681042e67 100644
--- a/reference/atomic/atomic_flag/test_and_set.md
+++ b/reference/atomic/atomic_flag/test_and_set.md
@@ -6,8 +6,16 @@
 * cpp11[meta cpp]
 
 ```cpp
-bool test_and_set(memory_order order = memory_order_seq_cst) volatile noexcept;
-bool test_and_set(memory_order order = memory_order_seq_cst) noexcept;
+bool
+  test_and_set(memory_order order = memory_order_seq_cst
+               ) volatile noexcept;                      // (1) C++11
+
+bool
+  test_and_set(memory_order order = memory_order_seq_cst
+               ) noexcept;                               // (2) C++11
+constexpr bool
+  test_and_set(memory_order order = memory_order_seq_cst
+               ) noexcept;                               // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -73,5 +81,5 @@ true
 
 
 ## 参照
-
-
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag/wait.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag/wait.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag/wait.md b/reference/atomic/atomic_flag/wait.md
index 4f8c1e35a..6a28dc057 100644
--- a/reference/atomic/atomic_flag/wait.md
+++ b/reference/atomic/atomic_flag/wait.md
@@ -6,8 +6,19 @@
 * cpp20[meta cpp]
 
 ```cpp
-void wait(bool old, memory_order order = memory_order::seq_cst) const volatile noexcept;
-void wait(bool old, memory_order order = memory_order::seq_cst) const noexcept;
+void
+  wait(bool old,
+       memory_order order = memory_order::seq_cst
+       ) const volatile noexcept;                 // (1) C++20
+
+void
+  wait(bool old,
+       memory_order order = memory_order::seq_cst
+       ) const noexcept;                          // (2) C++20
+constexpr void
+  wait(bool old,
+       memory_order order = memory_order::seq_cst
+       ) const noexcept;                          // (2) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
@@ -119,3 +130,5 @@ int main()
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_clear -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_clear.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_clear.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_clear.md b/reference/atomic/atomic_flag_clear.md
index 344ca7669..bede0b52a 100644
--- a/reference/atomic/atomic_flag_clear.md
+++ b/reference/atomic/atomic_flag_clear.md
@@ -6,8 +6,13 @@
 
 ```cpp
 namespace std {
-  void atomic_flag_clear(volatile atomic_flag* object) noexcept;
-  void atomic_flag_clear(atomic_flag* object) noexcept;
+  void
+    atomic_flag_clear(volatile atomic_flag* object) noexcept; // (1) C++11
+
+  void
+    atomic_flag_clear(atomic_flag* object) noexcept;          // (2) C++26
+  constexpr void
+    atomic_flag_clear(atomic_flag* object) noexcept;          // (2) C++26
 }
 ```
 * atomic_flag[link atomic_flag.md]
@@ -79,5 +84,5 @@ false
 
 
 ## 参照
-
-
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_clear_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_clear_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_clear_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_clear_explicit.md b/reference/atomic/atomic_flag_clear_explicit.md
index cdc49ca53..380201c65 100644
--- a/reference/atomic/atomic_flag_clear_explicit.md
+++ b/reference/atomic/atomic_flag_clear_explicit.md
@@ -6,8 +6,19 @@
 
 ```cpp
 namespace std {
-  void atomic_flag_clear_explicit(volatile atomic_flag* object, memory_order order) noexcept;
-  void atomic_flag_clear_explicit(atomic_flag* object, memory_order order) noexcept;
+  void
+    atomic_flag_clear_explicit(
+      volatile atomic_flag* object,
+      memory_order order) noexcept; // (1) C++11
+
+  void
+    atomic_flag_clear_explicit(
+      atomic_flag* object,
+      memory_order order) noexcept; // (2) C++11
+  constexpr void
+    atomic_flag_clear_explicit(
+      atomic_flag* object,
+      memory_order order) noexcept; // (2) C++26
 }
 ```
 * atomic_flag[link atomic_flag.md]
@@ -89,4 +100,5 @@ false
 
 ## 参照
 - [LWG Issue 2138. `atomic_flag::clear` should not accept `memory_order_consume`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2138)
-
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_notify_all -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_notify_all.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_notify_all.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_notify_all.md b/reference/atomic/atomic_flag_notify_all.md
index 6b9a2b65b..fd4ef52fa 100644
--- a/reference/atomic/atomic_flag_notify_all.md
+++ b/reference/atomic/atomic_flag_notify_all.md
@@ -6,8 +6,16 @@
 
 ```cpp
 namespace std {
-  void atomic_flag_notify_all(volatile atomic_flag* object) const noexcept; // (1) C++20
-  void atomic_flag_notify_all(atomic_flag* object) const noexcept;          // (2) C++20
+  void
+    atomic_flag_notify_all(
+      volatile atomic_flag* object) const noexcept; // (1) C++20
+
+  void
+    atomic_flag_notify_all(
+      atomic_flag* object) const noexcept;          // (2) C++20
+  constexpr void
+    atomic_flag_notify_all(
+      atomic_flag* object) const noexcept;          // (2) C++26
 }
 ```
 
@@ -83,3 +91,5 @@ int main()
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_notify_one -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_notify_one.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_notify_one.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_notify_one.md b/reference/atomic/atomic_flag_notify_one.md
index cb5fe17f7..ce15d2853 100644
--- a/reference/atomic/atomic_flag_notify_one.md
+++ b/reference/atomic/atomic_flag_notify_one.md
@@ -6,8 +6,16 @@
 
 ```cpp
 namespace std {
-  void atomic_flag_notify_one(volatile atomic_flag* object) noexcept; // (1) C++20
-  void atomic_flag_notify_one(atomic_flag* object) noexcept;          // (2) C++20
+  void
+    atomic_flag_notify_one(
+      volatile atomic_flag* object) noexcept; // (1) C++20
+
+  void
+    atomic_flag_notify_one(
+      atomic_flag* object) noexcept;          // (2) C++20
+  constexpr void
+    atomic_flag_notify_one(
+      atomic_flag* object) noexcept;          // (2) C++26
 }
 ```
 
@@ -109,3 +117,5 @@ int main()
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_test -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_test.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_test.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_test.md b/reference/atomic/atomic_flag_test.md
index 3973f5927..fad333b8f 100644
--- a/reference/atomic/atomic_flag_test.md
+++ b/reference/atomic/atomic_flag_test.md
@@ -6,8 +6,13 @@
 
 ```cpp
 namespace std {
-  bool atomic_flag_test(const volatile atomic_flag* object) noexcept; // (1) C++20
-  bool atomic_flag_test(const atomic_flag* object) noexcept;          // (2) C++20
+  bool
+    atomic_flag_test(const volatile atomic_flag* object) noexcept; // (1) C++20
+
+  bool
+    atomic_flag_test(const atomic_flag* object) noexcept;          // (2) C++20
+  constexpr bool
+    atomic_flag_test(const atomic_flag* object) noexcept;          // (2) C++26
 }
 ```
 
@@ -73,3 +78,5 @@ true
 - [P0995R1 Improving atomic_flag](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0995r1.html)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_test_and_set -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_test_and_set.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_test_and_set.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_test_and_set.md b/reference/atomic/atomic_flag_test_and_set.md
index 20cf95637..fa23298c1 100644
--- a/reference/atomic/atomic_flag_test_and_set.md
+++ b/reference/atomic/atomic_flag_test_and_set.md
@@ -6,8 +6,13 @@
 
 ```cpp
 namespace std {
-  bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
-  bool atomic_flag_test_and_set(atomic_flag* object) noexcept;
+  bool
+    atomic_flag_test_and_set(volatile atomic_flag* object) noexcept; // (1) C++11
+
+  bool
+    atomic_flag_test_and_set(atomic_flag* object) noexcept;          // (2) C++11
+  constexpr bool
+    atomic_flag_test_and_set(atomic_flag* object) noexcept;          // (2) C++26
 }
 ```
 * atomic_flag[link atomic_flag.md]
@@ -75,5 +80,5 @@ true
 
 
 ## 参照
-
-
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_test_and_set_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_test_and_set_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_test_and_set_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_test_and_set_explicit.md b/reference/atomic/atomic_flag_test_and_set_explicit.md
index 2dcc48633..bc919a1f2 100644
--- a/reference/atomic/atomic_flag_test_and_set_explicit.md
+++ b/reference/atomic/atomic_flag_test_and_set_explicit.md
@@ -6,8 +6,19 @@
 
 ```cpp
 namespace std {
-  bool atomic_flag_test_and_set_explicit(volatile atomic_flag* object, memory_order order) noexcept;
-  bool atomic_flag_test_and_set_explicit(atomic_flag* object, memory_order order) noexcept;
+  bool
+    atomic_flag_test_and_set_explicit(
+      volatile atomic_flag* object,
+      memory_order order) noexcept;    // (1) C++11
+
+  bool
+    atomic_flag_test_and_set_explicit(
+      atomic_flag* object,
+      memory_order order) noexcept;    // (2) C++11
+  constexpr bool
+    atomic_flag_test_and_set_explicit(
+      atomic_flag* object,
+      memory_order order) noexcept;    // (2) C++26
 }
 ```
 * atomic_flag[link atomic_flag.md]
@@ -74,5 +85,5 @@ true
 
 
 ## 参照
-
-
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_test_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_test_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_test_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_test_explicit.md b/reference/atomic/atomic_flag_test_explicit.md
index 3b260b077..a03168008 100644
--- a/reference/atomic/atomic_flag_test_explicit.md
+++ b/reference/atomic/atomic_flag_test_explicit.md
@@ -6,10 +6,16 @@
 
 ```cpp
 namespace std {
-  bool atomic_flag_test_explicit(const volatile atomic_flag* object,
-                                 memory_order order) noexcept;  // (1) C++20
-  bool atomic_flag_test_explicit(const atomic_flag* object,
-                                 memory_order order) noexcept;  // (2) C++20
+  bool
+    atomic_flag_test_explicit(const volatile atomic_flag* object,
+                              memory_order order) noexcept;  // (1) C++20
+
+  bool
+    atomic_flag_test_explicit(const atomic_flag* object,
+                              memory_order order) noexcept;  // (2) C++20
+  constexpr bool
+    atomic_flag_test_explicit(const atomic_flag* object,
+                              memory_order order) noexcept;  // (2) C++26
 }
 ```
 * memory_order[link /reference/atomic/memory_order.md]
@@ -81,3 +87,5 @@ true
 - [P0995R1 Improving atomic_flag](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0995r1.html)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_wait -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_wait.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_wait.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_wait.md b/reference/atomic/atomic_flag_wait.md
index 2452edf27..2a360fc00 100644
--- a/reference/atomic/atomic_flag_wait.md
+++ b/reference/atomic/atomic_flag_wait.md
@@ -6,8 +6,19 @@
 
 ```cpp
 namespace std {
-  void atomic_flag_wait(const volatile atomic_flag* object, bool old) noexcept; // (1) C++20
-  void atomic_flag_wait(const atomic_flag* object, bool old) noexcept;          // (2) C++20
+  void
+    atomic_flag_wait(
+      const volatile atomic_flag* object,
+      bool old) noexcept;        // (1) C++20
+
+  void
+    atomic_flag_wait(
+      const atomic_flag* object,
+      bool old) noexcept;        // (2) C++20
+  constexpr void
+    atomic_flag_wait(
+      const atomic_flag* object,
+      bool old) noexcept;        // (2) C++26
 }
 ```
 
@@ -119,3 +130,5 @@ int main()
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_flag_wait_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_flag_wait_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_flag_wait_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_flag_wait_explicit.md b/reference/atomic/atomic_flag_wait_explicit.md
index 5908cb650..4a27b046d 100644
--- a/reference/atomic/atomic_flag_wait_explicit.md
+++ b/reference/atomic/atomic_flag_wait_explicit.md
@@ -6,12 +6,22 @@
 
 ```cpp
 namespace std {
-  void atomic_flag_wait_explicit(const volatile atomic_flag* object,
-                                 bool old,
-                                 memory_order order) noexcept;  // (1) C++20
-  void atomic_flag_wait_explicit(const atomic_flag* object,
-                                 bool old,
-                                 memory_order order) noexcept;  // (2) C++20
+  void
+    atomic_flag_wait_explicit(
+      const volatile atomic_flag* object,
+      bool old,
+      memory_order order) noexcept;  // (1) C++20
+
+  void
+    atomic_flag_wait_explicit(
+      const atomic_flag* object,
+      bool old,
+      memory_order order) noexcept;  // (2) C++20
+  constexpr void
+    atomic_flag_wait_explicit(
+      const atomic_flag* object,
+      bool old,
+      memory_order order) noexcept;  // (2) C++26
 }
 ```
 
@@ -124,3 +134,5 @@ int main()
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_load -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_load.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_load.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_load.md b/reference/atomic/atomic_load.md
index 3bb4becc2..a0390c3a2 100644
--- a/reference/atomic/atomic_load.md
+++ b/reference/atomic/atomic_load.md
@@ -7,10 +7,15 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_load(const volatile atomic&amp;lt;T&amp;gt;* object) noexcept; // (1) C++11
+  T
+    atomic_load(const volatile atomic&amp;lt;T&amp;gt;* object) noexcept; // (1) C++11
 
   template &amp;lt;class T&amp;gt;
-  T atomic_load(const atomic&amp;lt;T&amp;gt;* object) noexcept;          // (2) C++11
+  T
+    atomic_load(const atomic&amp;lt;T&amp;gt;* object) noexcept;          // (2) C++11
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_load(const atomic&amp;lt;T&amp;gt;* object) noexcept;          // (2) C++26
 }
 ```
 * atomic[link /reference/atomic/atomic.md]
@@ -84,3 +89,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_load_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_load_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_load_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_load_explicit.md b/reference/atomic/atomic_load_explicit.md
index 45a0d084c..135852abc 100644
--- a/reference/atomic/atomic_load_explicit.md
+++ b/reference/atomic/atomic_load_explicit.md
@@ -7,14 +7,21 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T atomic_load_explicit(
+  T
+    atomic_load_explicit(
       const volatile atomic&amp;lt;T&amp;gt;* object,
       memory_order order) noexcept;     // (1) C++11
 
   template &amp;lt;class T&amp;gt;
-  T atomic_load_explicit(
+  T
+    atomic_load_explicit(
       const atomic&amp;lt;T&amp;gt;* object,
       memory_order order) noexcept;     // (2) C++11
+  template &amp;lt;class T&amp;gt;
+  constexpr T
+    atomic_load_explicit(
+      const atomic&amp;lt;T&amp;gt;* object,
+      memory_order order) noexcept;     // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -90,3 +97,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_notify_all -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_notify_all.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_notify_all.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_notify_all.md b/reference/atomic/atomic_notify_all.md
index d06922820..0215d5421 100644
--- a/reference/atomic/atomic_notify_all.md
+++ b/reference/atomic/atomic_notify_all.md
@@ -7,10 +7,15 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  void atomic_notify_all(volatile atomic&amp;lt;T&amp;gt;* object); // (1) C++20
+  void
+    atomic_notify_all(volatile atomic&amp;lt;T&amp;gt;* object); // (1) C++20
 
   template &amp;lt;class T&amp;gt;
-  void atomic_notify_all(atomic&amp;lt;T&amp;gt;* object);          // (2) C++20
+  void
+    atomic_notify_all(atomic&amp;lt;T&amp;gt;* object);          // (2) C++20
+  template &amp;lt;class T&amp;gt;
+  constexpr void
+    atomic_notify_all(atomic&amp;lt;T&amp;gt;* object);          // (2) C++26
 }
 ```
 
@@ -95,3 +100,5 @@ int main()
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_notify_one -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_notify_one.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_notify_one.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_notify_one.md b/reference/atomic/atomic_notify_one.md
index 49fee229e..cbfd876d1 100644
--- a/reference/atomic/atomic_notify_one.md
+++ b/reference/atomic/atomic_notify_one.md
@@ -7,10 +7,15 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  void atomic_notify_one(volatile atomic&amp;lt;T&amp;gt;* object); // (1) C++20
+  void
+    atomic_notify_one(volatile atomic&amp;lt;T&amp;gt;* object); // (1) C++20
 
   template &amp;lt;class T&amp;gt;
-  void atomic_notify_one(atomic&amp;lt;T&amp;gt;* object);          // (2) C++20
+  void
+    atomic_notify_one(atomic&amp;lt;T&amp;gt;* object);          // (2) C++20
+  template &amp;lt;class T&amp;gt;
+  constexpr void
+    atomic_notify_one(atomic&amp;lt;T&amp;gt;* object);          // (2) C++26
 }
 ```
 
@@ -121,3 +126,5 @@ int main()
 - [P1135R6 The C++20 Synchronization Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1135r6.html)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_exchange_strong -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/compare_exchange_strong.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/compare_exchange_strong.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/compare_exchange_strong.md b/reference/atomic/atomic_ref/compare_exchange_strong.md
index e128bf2a8..572dbd12b 100644
--- a/reference/atomic/atomic_ref/compare_exchange_strong.md
+++ b/reference/atomic/atomic_ref/compare_exchange_strong.md
@@ -12,7 +12,7 @@ bool
                           memory_order success,
                           memory_order failure
                           ) const noexcept;  // (1) C++20
-bool
+constexpr bool
   compare_exchange_strong(value_type&amp;amp; expected,
                           value_type desired,
                           memory_order success,
@@ -24,7 +24,7 @@ bool
                           T desired,
                           memory_order order = memory_order_seq_cst
                           ) const noexcept;  // (2) C++20
-bool
+constexpr bool
   compare_exchange_strong(value_type&amp;amp; expected,
                           value_type desired,
                           memory_order order = memory_order_seq_cst
@@ -174,3 +174,5 @@ true
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_exchange_weak -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/compare_exchange_weak.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/compare_exchange_weak.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/compare_exchange_weak.md b/reference/atomic/atomic_ref/compare_exchange_weak.md
index 51c6f84ad..3b92958ab 100644
--- a/reference/atomic/atomic_ref/compare_exchange_weak.md
+++ b/reference/atomic/atomic_ref/compare_exchange_weak.md
@@ -12,7 +12,7 @@ bool
                         memory_order success,
                         memory_order failure
                         ) const noexcept;     // (1) C++20
-bool
+constexpr bool
   compare_exchange_weak(value_type&amp;amp; expected,
                         value_type desired,
                         memory_order success,
@@ -24,7 +24,7 @@ bool
                         T desired,
                         memory_order order = memory_order_seq_cst
                         ) const noexcept;     // (2) C++20
-bool
+constexpr bool
   compare_exchange_weak(value_type&amp;amp; expected,
                         value_type desired,
                         memory_order order = memory_order_seq_cst
@@ -204,3 +204,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exchange -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/exchange.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/exchange.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/exchange.md b/reference/atomic/atomic_ref/exchange.md
index c604462cb..4c3bc9a7d 100644
--- a/reference/atomic/atomic_ref/exchange.md
+++ b/reference/atomic/atomic_ref/exchange.md
@@ -9,7 +9,7 @@
 T
   exchange(T desired,
            memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
-value_type
+constexpr value_type
   exchange(value_type desired,
            memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
 ```
@@ -73,3 +73,5 @@ replaced 1 by 2
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_add -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_add.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/fetch_add.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_add.md b/reference/atomic/atomic_ref/fetch_add.md
index 34baa1f68..f1cbbe798 100644
--- a/reference/atomic/atomic_ref/fetch_add.md
+++ b/reference/atomic/atomic_ref/fetch_add.md
@@ -9,7 +9,7 @@
 T
   fetch_add(difference_type operand,
             memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
-value_type
+constexpr value_type
   fetch_add(difference_type operand,
             memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
 ```
@@ -144,3 +144,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_and -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_and.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/fetch_and.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_and.md b/reference/atomic/atomic_ref/fetch_and.md
index 18abb329b..2264df927 100644
--- a/reference/atomic/atomic_ref/fetch_and.md
+++ b/reference/atomic/atomic_ref/fetch_and.md
@@ -9,7 +9,7 @@
 T
   fetch_and(T operand,
             memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
-value_type
+constexpr value_type
   fetch_and(value_type operand,
             memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
 ```
@@ -114,3 +114,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_max -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_max.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/fetch_max.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_max.md b/reference/atomic/atomic_ref/fetch_max.md
index eac81830b..ab4bc9350 100644
--- a/reference/atomic/atomic_ref/fetch_max.md
+++ b/reference/atomic/atomic_ref/fetch_max.md
@@ -6,7 +6,8 @@
 * cpp26[meta cpp]
 
 ```cpp
-T fetch_max(difference_type operand,
+constexpr T
+  fetch_max(difference_type operand,
             memory_order order = memory_order_seq_cst
             ) const noexcept;                         // (1) C++26
 ```
@@ -69,3 +70,4 @@ int main()
 
 ## 参照
 - [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_min -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_min.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/fetch_min.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_min.md b/reference/atomic/atomic_ref/fetch_min.md
index 4beac4381..b4fd996f9 100644
--- a/reference/atomic/atomic_ref/fetch_min.md
+++ b/reference/atomic/atomic_ref/fetch_min.md
@@ -6,7 +6,8 @@
 * cpp26[meta cpp]
 
 ```cpp
-T fetch_min(difference_type operand,
+constexpr T
+  fetch_min(difference_type operand,
             memory_order order = memory_order_seq_cst
             ) const noexcept;                         // (1) C++26
 ```
@@ -69,3 +70,5 @@ int main()
 
 ## 参照
 - [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_or -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_or.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/fetch_or.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_or.md b/reference/atomic/atomic_ref/fetch_or.md
index 95c27b4e8..195aa94ed 100644
--- a/reference/atomic/atomic_ref/fetch_or.md
+++ b/reference/atomic/atomic_ref/fetch_or.md
@@ -9,7 +9,7 @@
 T
   fetch_or(T operand,
            memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
-value_type
+constexpr value_type
   fetch_or(value_type operand,
            memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
 ```
@@ -114,3 +114,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_sub -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_sub.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/fetch_sub.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_sub.md b/reference/atomic/atomic_ref/fetch_sub.md
index 2c26bd65b..35a0c59bc 100644
--- a/reference/atomic/atomic_ref/fetch_sub.md
+++ b/reference/atomic/atomic_ref/fetch_sub.md
@@ -9,7 +9,7 @@
 T
   fetch_sub(difference_type operand,
             memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
-value_type
+constexpr value_type
   fetch_sub(difference_type operand,
             memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
 ```
@@ -139,3 +139,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_xor -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_xor.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/fetch_xor.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_xor.md b/reference/atomic/atomic_ref/fetch_xor.md
index 4b1a3ad01..13e2b1600 100644
--- a/reference/atomic/atomic_ref/fetch_xor.md
+++ b/reference/atomic/atomic_ref/fetch_xor.md
@@ -9,7 +9,7 @@
 T
   fetch_xor(T operand,
             memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
-value_type
+constexpr value_type
   fetch_xor(value_type operand,
             memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
 ```
@@ -116,3 +116,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>load -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/load.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/load.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/load.md b/reference/atomic/atomic_ref/load.md
index 908c73094..f41bf7d6a 100644
--- a/reference/atomic/atomic_ref/load.md
+++ b/reference/atomic/atomic_ref/load.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-T load(memory_order order = memory_order_seq_cst) const noexcept;          // (1) C++20
-value_type load(memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
+T
+  load(memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
+constexpr value_type
+  load(memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -76,3 +78,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_all -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/notify_all.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/notify_all.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/notify_all.md b/reference/atomic/atomic_ref/notify_all.md
index d4d439e44..64feab641 100644
--- a/reference/atomic/atomic_ref/notify_all.md
+++ b/reference/atomic/atomic_ref/notify_all.md
@@ -6,7 +6,8 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_all() const noexcept;
+void notify_all() const noexcept; // (1) C++20
+constexpr void notify_all() const noexcept; // (1) C++20
 ```
 
 ## 概要
@@ -89,3 +90,5 @@ int main()
     - 宣言に`const`を追加
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_one -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/notify_one.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/notify_one.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/notify_one.md b/reference/atomic/atomic_ref/notify_one.md
index 2737886ee..c12935ea1 100644
--- a/reference/atomic/atomic_ref/notify_one.md
+++ b/reference/atomic/atomic_ref/notify_one.md
@@ -6,7 +6,8 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_one() const noexcept;
+void notify_one() const noexcept;           // (1) C++20
+constexpr void notify_one() const noexcept; // (1) C++26
 ```
 
 ## 概要
@@ -116,3 +117,5 @@ int main()
     - 宣言に`const`を追加
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&amp;= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_and_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_and_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_and_assign.md b/reference/atomic/atomic_ref/op_and_assign.md
index 3da312014..8a2537050 100644
--- a/reference/atomic/atomic_ref/op_and_assign.md
+++ b/reference/atomic/atomic_ref/op_and_assign.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-T operator&amp;amp;=(T operand) const noexcept;                   // (1) C++20
-value_type operator&amp;amp;=(value_type operand) const noexcept; // (1) C++26
+T
+  operator&amp;amp;=(T operand) const noexcept;          // (1) C++20
+constexpr value_type
+  operator&amp;amp;=(value_type operand) const noexcept; // (1) C++26
 ```
 
 ## 概要
@@ -106,3 +108,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_assign.md b/reference/atomic/atomic_ref/op_assign.md
index dbe5d5c10..d91ff0ac5 100644
--- a/reference/atomic/atomic_ref/op_assign.md
+++ b/reference/atomic/atomic_ref/op_assign.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-T operator=(T desired) const noexcept;                   // (1) C++20
-value_type operator=(value_type desired) const noexcept; // (1) C++26
+T
+  operator=(T desired) const noexcept;          // (1) C++20
+constexpr value_type
+  operator=(value_type desired) const noexcept; // (1) C++26
 ```
 
 ## 概要
@@ -75,3 +77,5 @@ int main()
     - 宣言に`const`を追加
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_constructor.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_constructor.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_constructor.md b/reference/atomic/atomic_ref/op_constructor.md
index 7f3d70442..3821a7ac2 100644
--- a/reference/atomic/atomic_ref/op_constructor.md
+++ b/reference/atomic/atomic_ref/op_constructor.md
@@ -6,8 +6,11 @@
 * cpp20[meta cpp]
 
 ```cpp
-explicit atomic_ref(T&amp;amp; obj);                  // (1) C++20
-atomic_ref(const atomic_ref&amp;amp; other) noexcept; // (2) C++20
+explicit atomic_ref(T&amp;amp; obj);                            // (1) C++20
+constexpr explicit atomic_ref(T&amp;amp; obj);                  // (1) C++26
+
+atomic_ref(const atomic_ref&amp;amp; other) noexcept;           // (2) C++20
+constexpr atomic_ref(const atomic_ref&amp;amp; other) noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -64,3 +67,5 @@ int main()
 
 ## 参照
 - [LWG issue 3160. `atomic_ref() = delete;` should be deleted](https://wg21.cmeerw.net/lwg/issue3160)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-- -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_decrement.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_decrement.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_decrement.md b/reference/atomic/atomic_ref/op_decrement.md
index 6554c4771..4c1e6a80d 100644
--- a/reference/atomic/atomic_ref/op_decrement.md
+++ b/reference/atomic/atomic_ref/op_decrement.md
@@ -6,8 +6,15 @@
 * cpp20[meta cpp]
 
 ```cpp
-value_type operator--() const noexcept;
-value_type operator--(int) const noexcept;
+value_type
+  operator--() const noexcept;    // (1) C++20
+constexpr value_type
+  operator--() const noexcept;    // (1) C++26
+
+value_type
+  operator--(int) const noexcept; // (2) C++20
+constexpr value_type
+  operator--(int) const noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -106,3 +113,5 @@ int main()
     - 戻り値の型を`T`から`value_type`に変更
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator++ -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_increment.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_increment.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_increment.md b/reference/atomic/atomic_ref/op_increment.md
index d870ebb25..ba657a428 100644
--- a/reference/atomic/atomic_ref/op_increment.md
+++ b/reference/atomic/atomic_ref/op_increment.md
@@ -6,8 +6,15 @@
 * cpp20[meta cpp]
 
 ```cpp
-value_type operator++() const noexcept;    // (1) C++20
-value_type operator++(int) const noexcept; // (2) C++20
+value_type
+  operator++() const noexcept;    // (1) C++20
+constexpr value_type
+  operator++() const noexcept;    // (1) C++26
+
+value_type
+  operator++(int) const noexcept; // (2) C++20
+constexpr value_type
+  operator++(int) const noexcept; // (2) C++26
 ```
 
 ## 概要
@@ -108,3 +115,5 @@ int main()
     - 戻り値の型を`T`から`value_type`に変更
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_minus_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_minus_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_minus_assign.md b/reference/atomic/atomic_ref/op_minus_assign.md
index 3811861b8..eb05e3b4b 100644
--- a/reference/atomic/atomic_ref/op_minus_assign.md
+++ b/reference/atomic/atomic_ref/op_minus_assign.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-T operator-=(T operand) const noexcept;                   // (1) C++20
-value_type operator-=(value_type operand) const noexcept; // (1) C++26
+T
+  operator-=(T operand) const noexcept;                   // (1) C++20
+constexpr value_type
+  operator-=(value_type operand) const noexcept; // (1) C++26
 ```
 
 ## 概要
@@ -133,3 +135,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator|= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_or_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_or_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_or_assign.md b/reference/atomic/atomic_ref/op_or_assign.md
index 20f5be116..18ca0d128 100644
--- a/reference/atomic/atomic_ref/op_or_assign.md
+++ b/reference/atomic/atomic_ref/op_or_assign.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-T operator|=(T operand) const noexcept;                   // (1) C++20
-value_type operator|=(value_type operand) const noexcept; // (1) C++26
+T
+  operator|=(T operand) const noexcept;          // (1) C++20
+constexpr value_type
+  operator|=(value_type operand) const noexcept; // (1) C++26
 ```
 
 ## 概要
@@ -107,3 +109,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_plus_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_plus_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_plus_assign.md b/reference/atomic/atomic_ref/op_plus_assign.md
index 44a48256e..2b4cb59e2 100644
--- a/reference/atomic/atomic_ref/op_plus_assign.md
+++ b/reference/atomic/atomic_ref/op_plus_assign.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-T operator+=(T operand) const noexcept;                   // (1) C++20
-value_type operator+=(value_type operand) const noexcept; // (1) C++26
+T
+  operator+=(T operand) const noexcept;          // (1) C++20
+constexpr value_type
+  operator+=(value_type operand) const noexcept; // (1) C++26
 ```
 
 ## 概要
@@ -132,3 +134,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator value_type -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_value_type.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_value_type.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_value_type.md b/reference/atomic/atomic_ref/op_value_type.md
index f2fa124be..37845899d 100644
--- a/reference/atomic/atomic_ref/op_value_type.md
+++ b/reference/atomic/atomic_ref/op_value_type.md
@@ -6,7 +6,7 @@
 * cpp26[meta cpp]
 
 ```cpp
-operator value_type() const noexcept;
+constexpr operator value_type() const noexcept; // (1) C++26
 ```
 
 ## 概要
@@ -59,3 +59,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator^= -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/op_xor_assign.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/op_xor_assign.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/op_xor_assign.md b/reference/atomic/atomic_ref/op_xor_assign.md
index 4e0e2f47d..b8cf13947 100644
--- a/reference/atomic/atomic_ref/op_xor_assign.md
+++ b/reference/atomic/atomic_ref/op_xor_assign.md
@@ -6,8 +6,10 @@
 * cpp20[meta cpp]
 
 ```cpp
-T operator^=(T operand) const noexcept;                   // (1) C++20
-value_type operator^=(value_type operand) const noexcept; // (1) C++26
+T
+  operator^=(T operand) const noexcept;          // (1) C++20
+constexpr value_type
+  operator^=(value_type operand) const noexcept; // (1) C++26
 ```
 
 ## 概要
@@ -103,3 +105,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>store -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/store.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/store.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/store.md b/reference/atomic/atomic_ref/store.md
index 696c7eaa2..1e73ac4a7 100644
--- a/reference/atomic/atomic_ref/store.md
+++ b/reference/atomic/atomic_ref/store.md
@@ -6,10 +6,12 @@
 * cpp20[meta cpp]
 
 ```cpp
-void store(T desired,
-            memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
-void store(value_type desired,
-           memory_order order = memory_order_seq_cst) const noexcept;  // (1) C++26
+void
+  store(T desired,
+        memory_order order = memory_order_seq_cst) const noexcept; // (1) C++20
+constexpr void
+  store(value_type desired,
+        memory_order order = memory_order_seq_cst) const noexcept; // (1) C++26
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -84,3 +86,5 @@ int main()
 ## 参照
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/wait.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_ref/wait.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/wait.md b/reference/atomic/atomic_ref/wait.md
index 13e7203b6..58f146c89 100644
--- a/reference/atomic/atomic_ref/wait.md
+++ b/reference/atomic/atomic_ref/wait.md
@@ -9,7 +9,7 @@
 void
   wait(T old,
        memory_order order = memory_order::seq_cst) const noexcept; // (1) C++20
-void
+constexpr void
   wait(value_type old,
        memory_order order = memory_order::seq_cst) const noexcept; // (1) C++26
 ```
@@ -134,3 +134,5 @@ int main()
 - [P1643R1 Add wait/notify to `atomic_ref`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1643r1.html)
 - [P3323R1 cv-qualified types in `atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
     - C++26でCV修飾されたテンプレート引数を受け取れるようになった
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_signal_fence -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_signal_fence.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_signal_fence.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_signal_fence.md b/reference/atomic/atomic_signal_fence.md
index 70e79afc8..00974d700 100644
--- a/reference/atomic/atomic_signal_fence.md
+++ b/reference/atomic/atomic_signal_fence.md
@@ -6,7 +6,12 @@
 
 ```cpp
 namespace std {
-  extern &amp;#34;C&amp;#34; void atomic_signal_fence(memory_order order) noexcept;
+  extern &amp;#34;C&amp;#34;
+  void
+    atomic_signal_fence(memory_order order) noexcept; // (1) C++11
+  extern &amp;#34;C&amp;#34;
+  constexpr void
+    atomic_signal_fence(memory_order order) noexcept; // (1) C++26
 }
 ```
 * memory_order[link memory_order.md]
@@ -50,5 +55,6 @@ namespace std {
 
 
 ## 参照
-[How to correctly use std::atomic_signal_fence()?](http://stackoverflow.com/questions/14581090/how-to-correctly-use-stdatomic-signal-fence)
-
+- [How to correctly use std::atomic_signal_fence()?](http://stackoverflow.com/questions/14581090/how-to-correctly-use-stdatomic-signal-fence)
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_store -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_store.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_store.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_store.md b/reference/atomic/atomic_store.md
index ce97d33c7..7793a8b4f 100644
--- a/reference/atomic/atomic_store.md
+++ b/reference/atomic/atomic_store.md
@@ -7,20 +7,26 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  void atomic_store(volatile atomic&amp;lt;T&amp;gt;* object,
-                    T desired) noexcept;                              // (1) C++11
-
+  void
+    atomic_store(volatile atomic&amp;lt;T&amp;gt;* object,
+                 T desired) noexcept;                              // (1) C++11
   template &amp;lt;class T&amp;gt;
-  void atomic_store(volatile atomic&amp;lt;T&amp;gt;* object,
-                    typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (1) C++17
+  void
+    atomic_store(volatile atomic&amp;lt;T&amp;gt;* object,
+                 typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  void atomic_store(atomic&amp;lt;T&amp;gt;* object,
-                    T desired) noexcept;                              // (2) C++11
-
+  void
+    atomic_store(atomic&amp;lt;T&amp;gt;* object,
+                 T desired) noexcept;                              // (2) C++11
+  template &amp;lt;class T&amp;gt;
+  void
+    atomic_store(atomic&amp;lt;T&amp;gt;* object,
+                 typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++17
   template &amp;lt;class T&amp;gt;
-  void atomic_store(atomic&amp;lt;T&amp;gt;* object,
-                    typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++17
+  constexpr void
+    atomic_store(atomic&amp;lt;T&amp;gt;* object,
+                 typename atomic&amp;lt;T&amp;gt;::value_type desired) noexcept; // (2) C++26
 }
 ```
 * atomic[link /reference/atomic/atomic.md]
@@ -96,3 +102,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_store_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_store_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_store_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_store_explicit.md b/reference/atomic/atomic_store_explicit.md
index 742052570..c97de61c1 100644
--- a/reference/atomic/atomic_store_explicit.md
+++ b/reference/atomic/atomic_store_explicit.md
@@ -7,28 +7,37 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  void atomic_store_explicit(
+  void
+    atomic_store_explicit(
          volatile atomic&amp;lt;T&amp;gt;* object,
          T desired,
          memory_order order) noexcept;           // (1) C++11
-
   template &amp;lt;class T&amp;gt;
-  void atomic_store_explicit(
+  void
+    atomic_store_explicit(
          volatile atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type desired,
          memory_order order) noexcept;           // (1) C++17
 
   template &amp;lt;class T&amp;gt;
-  void atomic_store_explicit(
+  void
+    atomic_store_explicit(
          atomic&amp;lt;T&amp;gt;* object,
          T desired,
          memory_order order) noexcept;           // (2) C++11
 
   template &amp;lt;class T&amp;gt;
-  void atomic_store_explicit(
+  void
+    atomic_store_explicit(
          atomic&amp;lt;T&amp;gt;* object,
          typename atomic&amp;lt;T&amp;gt;::value_type desired,
          memory_order order) noexcept;           // (2) C++17
+  template &amp;lt;class T&amp;gt;
+  constexpr void
+    atomic_store_explicit(
+         atomic&amp;lt;T&amp;gt;* object,
+         typename atomic&amp;lt;T&amp;gt;::value_type desired,
+         memory_order order) noexcept;           // (2) C++26
 }
 ```
 * atomic[link atomic.md]
@@ -105,3 +114,5 @@ int main()
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_thread_fence -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_thread_fence.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_thread_fence.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_thread_fence.md b/reference/atomic/atomic_thread_fence.md
index a47bf3fab..4ed4a0d77 100644
--- a/reference/atomic/atomic_thread_fence.md
+++ b/reference/atomic/atomic_thread_fence.md
@@ -6,7 +6,12 @@
 
 ```cpp
 namespace std {
-  extern &amp;#34;C&amp;#34; void atomic_thread_fence(memory_order order) noexcept;
+  extern &amp;#34;C&amp;#34;
+  void
+    atomic_thread_fence(memory_order order) noexcept; // (1) C++11
+  extern &amp;#34;C&amp;#34;
+  constexpr void
+    atomic_thread_fence(memory_order order) noexcept; // (1) C++26
 }
 ```
 * memory_order[link memory_order.md]
@@ -142,4 +147,5 @@ int main()
 
 ## 参照
 - [Implementing Dekker&amp;#39;s algorithm with Fences](https://www.justsoftwaresolutions.co.uk/threading/implementing_dekkers_algorithm_with_fences.html)
-
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_wait -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_wait.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_wait.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_wait.md b/reference/atomic/atomic_wait.md
index 75f0080cb..5a8f5996c 100644
--- a/reference/atomic/atomic_wait.md
+++ b/reference/atomic/atomic_wait.md
@@ -7,12 +7,18 @@
 ```cpp
 namespace std {
   template&amp;lt;class T&amp;gt;
-  void atomic_wait(const volatile atomic&amp;lt;T&amp;gt;* object,
-                   typename atomic&amp;lt;T&amp;gt;::value_type old); // (1) C++20
+  void
+    atomic_wait(const volatile atomic&amp;lt;T&amp;gt;* object,
+                typename atomic&amp;lt;T&amp;gt;::value_type old); // (1) C++20
 
   template&amp;lt;class T&amp;gt;
-  void atomic_wait(const atomic&amp;lt;T&amp;gt;* object,
-                   typename atomic&amp;lt;T&amp;gt;::value_type old); // (2) C++20
+  void
+    atomic_wait(const atomic&amp;lt;T&amp;gt;* object,
+                typename atomic&amp;lt;T&amp;gt;::value_type old); // (2) C++20
+  template&amp;lt;class T&amp;gt;
+  constexpr void
+    atomic_wait(const atomic&amp;lt;T&amp;gt;* object,
+                typename atomic&amp;lt;T&amp;gt;::value_type old); // (2) C++26
 }
 ```
 
@@ -132,3 +138,5 @@ int main()
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_wait_explicit -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_wait_explicit.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/atomic_wait_explicit.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_wait_explicit.md b/reference/atomic/atomic_wait_explicit.md
index 07a84ebbf..1f273afa6 100644
--- a/reference/atomic/atomic_wait_explicit.md
+++ b/reference/atomic/atomic_wait_explicit.md
@@ -7,14 +7,21 @@
 ```cpp
 namespace std {
   template&amp;lt;class T&amp;gt;
-  void atomic_wait(const volatile atomic&amp;lt;T&amp;gt;* object,
-                   typename atomic&amp;lt;T&amp;gt;::value_type old,
-                   memory_order order);                 // (1) C++20
+  void
+    atomic_wait(const volatile atomic&amp;lt;T&amp;gt;* object,
+                typename atomic&amp;lt;T&amp;gt;::value_type old,
+                memory_order order);                 // (1) C++20
 
   template&amp;lt;class T&amp;gt;
-  void atomic_wait(const atomic&amp;lt;T&amp;gt;* object,
-                   typename atomic&amp;lt;T&amp;gt;::value_type old,
-                   memory_order order);                 // (2) C++20
+  void
+    atomic_wait(const atomic&amp;lt;T&amp;gt;* object,
+                typename atomic&amp;lt;T&amp;gt;::value_type old,
+                memory_order order);                 // (2) C++20
+  template&amp;lt;class T&amp;gt;
+  constexpr void
+    atomic_wait(const atomic&amp;lt;T&amp;gt;* object,
+                typename atomic&amp;lt;T&amp;gt;::value_type old,
+                memory_order order);                 // (2) C++26
 }
 ```
 
@@ -135,3 +142,5 @@ int main()
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
 - [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
     - C++20での、`volatile`版への制約追加
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>kill_dependency -- atomic : C++26のconstexpr対応 (close #1391)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/kill_dependency.html"/>
      <id>4324757146279c9a5be4816d920449928e2801fe:reference/atomic/kill_dependency.md</id>
      <updated>2024-12-23T16:58:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/kill_dependency.md b/reference/atomic/kill_dependency.md
index 75347c82a..461a6a91d 100644
--- a/reference/atomic/kill_dependency.md
+++ b/reference/atomic/kill_dependency.md
@@ -7,7 +7,9 @@
 ```cpp
 namespace std {
   template &amp;lt;class T&amp;gt;
-  T kill_dependency(T y) noexcept;
+  T kill_dependency(T y) noexcept;           // (1) C++11
+  template &amp;lt;class T&amp;gt;
+  constexpr T kill_dependency(T y) noexcept; // (1) C++26
 }
 ```
 
@@ -122,4 +124,5 @@ T kill_dependency(T y) noexcept
 - [What does `std::kill_dependency` do, and why would I want to use it? - StackOverflow](http://stackoverflow.com/q/7150395/463412)
 - [C++0xのメモリバリアをより深く解説してみる - yamasaのネタ帳](http://d.hatena.ne.jp/bsdhouse/20090929/1254237835)
 - [（抄訳）N4215 `memory_order_consume`の利用と実装に向けて［§5-6のみ］](http://d.hatena.ne.jp/yohhoy/20141115/p1)
-
+- [P3309R3 `constexpr atomic` and `atomic_ref`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
+    - C++26で`constexpr`に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_max_explicit -- コード修飾ミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_max_explicit.html"/>
      <id>d440b084cf68297223b7ebae85f363ee9cb16862:reference/atomic/atomic_fetch_max_explicit.md</id>
      <updated>2024-12-23T15:38:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_max_explicit.md b/reference/atomic/atomic_fetch_max_explicit.md
index 926a49f8e..17c2259b8 100644
--- a/reference/atomic/atomic_fetch_max_explicit.md
+++ b/reference/atomic/atomic_fetch_max_explicit.md
@@ -52,7 +52,7 @@ int main()
   std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
 }
 ```
-* std::atomic_fetch_add_maxlicit[color ff0000]
+* std::atomic_fetch_max_explicit[color ff0000]
 
 
 ### 出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_min_explicit -- コード修飾ミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_min_explicit.html"/>
      <id>d440b084cf68297223b7ebae85f363ee9cb16862:reference/atomic/atomic_fetch_min_explicit.md</id>
      <updated>2024-12-23T15:38:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_min_explicit.md b/reference/atomic/atomic_fetch_min_explicit.md
index 003fcbf40..cac364da7 100644
--- a/reference/atomic/atomic_fetch_min_explicit.md
+++ b/reference/atomic/atomic_fetch_min_explicit.md
@@ -52,7 +52,7 @@ int main()
   std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
 }
 ```
-* std::atomic_fetch_add_maxlicit[color ff0000]
+* std::atomic_fetch_min_explicit[color ff0000]
 
 
 ### 出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++26 -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/lang/cpp26.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:lang/cpp26.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++26&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++26とは、2026年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中のためC++2cと呼ばれることがある。「(2020年代の3つ目のバージョンが) 202c年にリリースされる」という伏せ字として「c」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/static_storage_for_braced_initializers.md.nolink&#34;&gt;&lt;code&gt;std::initializer_list&lt;/code&gt;の配列を静的ストレージに配置する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::vector v = {1, 2, 3};&lt;/code&gt;のような初期化で初期化子リストを静的ストレージに配置することで無駄なコピーをなくす&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/nice_placeholder_with_no_name.html&#34;&gt;宣言のみで使用しない変数の名前として&lt;code&gt;_&lt;/code&gt;をサポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数名&lt;code&gt;_&lt;/code&gt;は暗黙で&lt;code&gt;[[maybe_unused]]&lt;/code&gt;が指定される&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/remove_deprecated_arithmetic_conversion_on_enumerations.html&#34;&gt;非推奨となっていた列挙型の算術変換を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++20から非推奨となっていた列挙値への算術演算で算術型に暗黙変換される仕様を削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/deleting_a_pointer_to_an_incomplete_type_should_be_ill-formed.md.nolink&#34;&gt;不完全型へのポインタに対する&lt;code&gt;delete&lt;/code&gt;を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;未定義動作を引き起こす操作をコンパイルエラーとする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/disallow_binding_a_returned_glvalue_to_a_temporary.md.nolink&#34;&gt;返却された左辺値から暗黙変換された一時オブジェクトが参照に束縛されることを禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;寿命切れの変数によって引き起こされるバグを防止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/clarifying_rules_for_brace_elision_in_aggregate_initialization.md.nolink&#34;&gt;要素数不明の配列を集成体初期化する規則を明確化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;配列要素の集成体初期化で&lt;code&gt;{}&lt;/code&gt;が省略された場合の矛盾していた規定を修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/erroneous_behavior_for_uninitialized_reads.html&#34;&gt;未初期化変数の読み取りをエラー性動作とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化されていない自動変数の読み取りの安全性を規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/structured_bindings_can_introduce_a_pack.md.nolink&#34;&gt;構造化束縛でパックを導入できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;タプルを分解する際に複数の変数をパックとして宣言できるようにする。&lt;code&gt;auto [a, ...xs] = f();&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/making_non-encodable_string_literals_ill-formed.md.nolink&#34;&gt;文字列リテラルの文字エンコーディング失敗を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルのエンコーディング時に文字表現が失われる場合にコンパイルエラーにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/unevaluated_strings.md.nolink&#34;&gt;コンパイル時にのみ使用される文字列の扱いを明確化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static_assert&lt;/code&gt;や&lt;code&gt;[[deprecated]]&lt;/code&gt;などで使用されるコンパイル時の文字列について、文字コードの指定を禁止し、実行時エンコーディングが行われないことを規定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;分岐・ループ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/structured_binding_declaration_as_a_condition.html&#34;&gt;条件式での構造化束縛の使用を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;式全体を&lt;code&gt;bool&lt;/code&gt;値に変換できる場合に条件式で構造化束縛を使用できることとする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/trivial_infinite_loops_are_not_undefined_behavior.md.nolink&#34;&gt;自明な無限ループは未定義動作ではないと規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;並行プログラムの進行保証などを考慮して無限ループを未定義動作ではないものとする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/delete_reason.html&#34;&gt;関数宣言を削除する理由を指定できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;f() = delete(&#34;reason&#34;);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;属性&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/on_the_ignorability_of_standard_attributes.md.nolink&#34;&gt;属性の無視性を見直し&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構文として適格な属性のみを無視できるようにし、そうでない属性の使用を&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;とする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/attributes_for_structured_bindings.html&#34;&gt;構造化束縛への属性を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto [a, b [[maybe_unused]], c] = f();&lt;/code&gt;のように構造化束縛の要素に対して属性を付加できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/pack_indexing.md.nolink&#34;&gt;パラメータパックへのインデックスアクセスを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;可変引数テンプレートのパラメータパックに添字アクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/ordering_of_constraints_involving_fold_expressions.md.nolink&#34;&gt;制約式内での畳み込み式の順序付け&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;畳み込み式では全体ではなく個別の制約を原子制約式として扱う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/variadic_friends.md.nolink&#34;&gt;可変引数テンプレートで&lt;code&gt;friend&lt;/code&gt;宣言をできるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートの可変引数テンプレートでまとめて&lt;code&gt;friend&lt;/code&gt;宣言できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_cast_from_voidptr.md.nolink&#34;&gt;定数式での&lt;code&gt;void*&lt;/code&gt;からポインタ型へのキャストを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型消去のために&lt;code&gt;void*&lt;/code&gt;からポインタ型へのキャストを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/user-generated_static_assert_messages.html&#34;&gt;&lt;code&gt;static_assert&lt;/code&gt;の診断メッセージにユーザーが生成した文字列の指定を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;な&lt;code&gt;S.size()&lt;/code&gt;と&lt;code&gt;S.data()&lt;/code&gt;メンバ関数をもつオブジェクトをコンパイル時文字列として指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_placement_new.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;配置&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式の文脈での配置&lt;code&gt;new&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_structured_bindings_and_references_to_constexpr_variables.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;構造化束縛の許可と、定数式への参照を定数式とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式に対する構造化束縛を許可し、関連する定数式への参照が定数式になるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/allowing_exception_throwing_in_constant-evaluation.md.nolink&#34;&gt;定数評価での例外送出を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式の文脈での例外の送出と捕捉を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ソースコード&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/add_atsign_dollar_graveaccent_to_the_basic_character_set.html&#34;&gt;基本文字集合に@、$、`を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C言語との互換性のためにこれらの文字を基本文字集合に追加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;モジュール&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/module_declarations_shouldnt_be_macros.md.nolink&#34;&gt;モジュール宣言でのモジュール名のマクロ展開を禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;export module MACRO_NAME;&lt;/code&gt;を禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/remove_deprecated_array_comparisons.md.nolink&#34;&gt;非推奨だった配列の比較を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++20で非推奨となっていた配列比較を削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/the_oxford_variadic_comma.md.nolink&#34;&gt;先行するカンマのない省略記号を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void f(int, ...);&lt;/code&gt;はOK。&lt;code&gt;void f(int...);&lt;/code&gt;は非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字列エンコーディングを識別するライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/text_encoding.md.nolink&#34;&gt;&amp;lt;text_encoding&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;並行処理におけるデータの参照・更新を行うRCU (Read Copy Update) のライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/rcu.md.nolink&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;並行処理において参照中のデータが更新されないよう保護するハザードポインタのライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;データ並列ライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/simd.md.nolink&#34;&gt;&amp;lt;simd&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;デバッグサポートのライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/debugging.html&#34;&gt;&amp;lt;debugging&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;線形代数ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/linalg.html&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;コンパイル時に容量を固定する可変長配列クラスのライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/inplace_vector.md.nolink&#34;&gt;&amp;lt;inplace_vector&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;C23の互換ライブラリとして、ビット操作ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/stdbit.h.md.nolink&#34;&gt;&amp;lt;stdbit.h&amp;gt;&lt;/a&gt;&lt;/code&gt;と、検査付き整数演算ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/stdckdint.h.md.nolink&#34;&gt;&amp;lt;stdckdint.h&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。&lt;code&gt;&amp;lt;cstd…&amp;gt;&lt;/code&gt;形式のライブラリは追加されない&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;全体&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;標準ライブラリに付加された、戻り値を無視した際に警告を出力する&lt;a href=&#34;cpp17/nodiscard.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性&lt;/a&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;から部分ビューを取り出す&lt;code&gt;&lt;a href=&#34;../reference/mdspan/submdspan.html&#34;&gt;std::submdspan()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;に対する&lt;code&gt;&lt;a href=&#34;../reference/mdspan/extents.html&#34;&gt;std::dextents&lt;/a&gt;&lt;/code&gt;指定の冗長さを解決する&lt;code&gt;&lt;a href=&#34;../reference/mdspan/extents.html&#34;&gt;std::dims&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;のレイアウトとして、&lt;code&gt;&lt;a href=&#34;../reference/mdspan/layout_left_padded.html&#34;&gt;std::layout_left_padded&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/mdspan/layout_right_padded.html&#34;&gt;std::layout_right_padded&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素アクセスにアライメント保証を与える&lt;code&gt;&lt;a href=&#34;../reference/mdspan/aligned_accessor.html&#34;&gt;std::aligned_accessor&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/span/span.html&#34;&gt;std::span&lt;/a&gt;&lt;/code&gt;に、以下を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;をとるコンストラクタ&lt;/li&gt;
&lt;li&gt;インデックスアクセスのための&lt;code&gt;&lt;a href=&#34;../reference/span/span/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;連想コンテナの以下のメンバ関数に、一時オブジェクトが生成されるコストを抑える拡張を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map.html&#34;&gt;std::map&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/op_at.html&#34;&gt;operator[]&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/try_emplace.html&#34;&gt;try_emplace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/insert_or_assign.html&#34;&gt;insert_or_assign()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/set/set.html&#34;&gt;std::set&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/set/set/insert.html&#34;&gt;insert()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map.html&#34;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/op_at.html&#34;&gt;operator[]&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/try_emplace.html&#34;&gt;try_emplace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/insert_or_assign.html&#34;&gt;insert_or_assign()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_multimap.html&#34;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_multimap/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set.html&#34;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set/insert.html&#34;&gt;insert()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_multiset.html&#34;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_multiset/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/span/span.html&#34;&gt;std::span&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;の推論補助を改善&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/concat_view.html&#34;&gt;std::views::concat&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/cache_latest.md.nolink&#34;&gt;std::views::cache_latest&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のアルゴリズムを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/stable_sort.html&#34;&gt;std::stable_sort()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_stable_sort.html&#34;&gt;std::ranges::stable_sort()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/stable_partition.html&#34;&gt;std::stable_partition()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_stable_partition.html&#34;&gt;std::ranges::stable_partition()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/inplace_merge.html&#34;&gt;std::inplace_merge()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_inplace_merge.html&#34;&gt;std::ranges::inplace_merge()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のアルゴリズムを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_default_construct.html&#34;&gt;std::uninitialized_default_construct()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_default_construct.html&#34;&gt;std::ranges::uninitialized_default_construct()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_default_construct_n.html&#34;&gt;std::uninitialized_default_construct_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_default_construct_n.html&#34;&gt;std::ranges::uninitialized_default_construct_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_value_construct.html&#34;&gt;std::uninitialized_value_construct()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_value_construct.html&#34;&gt;std::ranges::uninitialized_value_construct()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_value_construct_n.html&#34;&gt;std::uninitialized_value_construct_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_value_construct_n.html&#34;&gt;std::ranges::uninitialized_value_construct_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_copy.html&#34;&gt;std::uninitialized_copy()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_copy.html&#34;&gt;std::ranges::uninitialized_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_copy_n.html&#34;&gt;std::uninitialized_copy_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_copy_n.html&#34;&gt;std::ranges::uninitialized_copy_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_move.html&#34;&gt;std::uninitialized_move()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_move.html&#34;&gt;std::ranges::uninitialized_move()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_move_n.html&#34;&gt;std::uninitialized_move_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_move_n.html&#34;&gt;std::ranges::uninitialized_move_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_fill.html&#34;&gt;std::uninitialized_fill()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_fill.html&#34;&gt;std::ranges::uninitialized_fill()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_fill_n.html&#34;&gt;std::uninitialized_fill_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_fill_n.html&#34;&gt;std::ranges::uninitialized_fill_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rangeアルゴリズムが完全型を要求しないようにするため、&lt;code&gt;&lt;a href=&#34;../reference/iterator/projected.html&#34;&gt;std::projected&lt;/a&gt;&lt;/code&gt;の制約を緩和&lt;/li&gt;
&lt;li&gt;以下のアルゴリズムに、値を波カッコ初期化で渡せるよう制約を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::erase()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/deque/deque.html&#34;&gt;std::deque&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/deque/deque/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/forward_list/forward_list/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/list/list/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/vector/vector.html&#34;&gt;std::vector&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/vector/vector/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/find.html&#34;&gt;std::find()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_find.html&#34;&gt;std::ranges::find()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_find_last.html&#34;&gt;std::ranges::find_last()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/count.html&#34;&gt;std::count()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_count.html&#34;&gt;std::ranges::count()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/search_n.html&#34;&gt;std::search_n()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_search_n.html&#34;&gt;std::ranges::search_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace.html&#34;&gt;std::replace()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace.html&#34;&gt;std::ranges::replace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_if.html&#34;&gt;std::replace_if()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_if.html&#34;&gt;std::ranges::replace_if()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy.html&#34;&gt;std::ranges::replace_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy_if.html&#34;&gt;std::replace_copy_if()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy_if.html&#34;&gt;std::ranges::replace_copy_if()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/fill.html&#34;&gt;std::fill()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fill.html&#34;&gt;std::ranges::fill()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/fill_n.html&#34;&gt;std::fill_n()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fill_n.html&#34;&gt;std::ranges::fill_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/remove.html&#34;&gt;std::remove()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_remove.html&#34;&gt;std::ranges::remove()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/remove_copy.html&#34;&gt;std::remove_copy()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_remove_copy.html&#34;&gt;std::ranges::remove_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/lower_bound.html&#34;&gt;std::lower_bound()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_lower_bound.html&#34;&gt;std::ranges::lower_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/upper_bound.html&#34;&gt;std::upper_bound()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_upper_bound.html&#34;&gt;std::ranges::upper_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/equal_range.html&#34;&gt;std::equal_range()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_equal_range.html&#34;&gt;std::ranges::equal_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/binary_search.html&#34;&gt;std::binary_search()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_binary_search.html&#34;&gt;std::ranges::binary_search()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fold_left.html&#34;&gt;std::ranges::fold_left()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fold_right.html&#34;&gt;std::ranges::fold_right()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_contains.html&#34;&gt;std::ranges::contains()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有権を保持しない&lt;code&gt;&lt;a href=&#34;../reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;として、&lt;code&gt;&lt;a href=&#34;../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/functional/function_ref.html&#34;&gt;std::function_ref&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/move_only_function.html&#34;&gt;std::move_only_function&lt;/a&gt;&lt;/code&gt;のコピー可能版として、&lt;code&gt;&lt;a href=&#34;../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/functional/copyable_function.html&#34;&gt;std::copyable_function&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/functional/bind_back.html&#34;&gt;std::bind_back()&lt;/a&gt;&lt;/code&gt;に、非型テンプレート引数として関数を指定するオーバーロードを追加&lt;ul&gt;
&lt;li&gt;関連して、非型テンプレート引数の関数オブジェクトを反転させられるよう、&lt;code&gt;&lt;a href=&#34;../reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;に非型テンプレート引数版のオーバーロードを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;に、比較演算子&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper/op_equal.html&#34;&gt;==&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper/op_compare_3way.html&#34;&gt;&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/charconv.html&#34;&gt;&amp;lt;charconv&amp;gt;&lt;/a&gt;&lt;/code&gt;の変換結果&lt;code&gt;&lt;a href=&#34;../reference/charconv/to_chars_result.html&#34;&gt;std::to_chars_result&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/charconv/from_chars_result.html&#34;&gt;std::from_chars_result&lt;/a&gt;&lt;/code&gt;に、変換が正しく完了したかを判定する&lt;code&gt;operator bool&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/to_string.html&#34;&gt;std::to_string()&lt;/a&gt;&lt;/code&gt;の仕様が&lt;code&gt;std::sprintf()&lt;/code&gt;で説明されていたが、&lt;code&gt;&lt;a href=&#34;../reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;で定義するよう仕様を変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_istringstream.html&#34;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;および&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_ostringstream.html&#34;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;のコンストラクタおよび&lt;code&gt;str()&lt;/code&gt;メンバ関数に、&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を受け取るオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;に、以下の改善を導入&lt;ul&gt;
&lt;li&gt;ポインタ出力のサポートを追加&lt;/li&gt;
&lt;li&gt;幅と精度を動的に指定した場合でも型の検証がコンパイル時に行われるよう仕様を見直し&lt;/li&gt;
&lt;li&gt;コンパイル時の書式文字列だけでなく、実行時の書式文字列を渡せるよう仕様修正&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;として連結させる&lt;code&gt;operator+&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイル&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ファイルのネイティブハンドルを取得できるよう、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_filebuf.html&#34;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_ifstream.html&#34;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_ofstream.html&#34;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_fstream.html&#34;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;クラスに、以下のメンバを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;native_handle_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native_handle()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path.html&#34;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt;に、文字列フォーマットのサポートを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/print.html&#34;&gt;std::print()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;に、ロックを取得せず高速に書き出す最適化を許可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;に、改行のみを出力するオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/print.html&#34;&gt;std::print()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;をより高速にできる最適化が可能か判定する&lt;code&gt;&lt;a href=&#34;../reference/format/enable_nonlocking_formatter_optimization.html&#34;&gt;std::enable_nonlocking_formatter_optimization&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列・非同期処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;に汎用的な非同期実行を管理するフレームワークを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;オブジェクトに対する2つの値の最大値・最小値を取得する関数として、メンバ関数&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_max.html&#34;&gt;fetch_max()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_min.html&#34;&gt;fetch_min()&lt;/a&gt;&lt;/code&gt;、非メンバ関数として&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_max.html&#34;&gt;std::atomic_fetch_max&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_max_explicit.html&#34;&gt;std::atomic_fetch_max_explicit&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_min.html&#34;&gt;std::atomic_fetch_min&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_min_explicit.html&#34;&gt;std::atomic_fetch_min_explicit&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;クラスに、参照するオブジェクトのアドレスを取得する&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref/address.md.nolink&#34;&gt;address()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスのテンプレートパラメータとしてCV修飾された型を禁止&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;クラスのテンプレートパラメータとして、CV修飾された型を受け取れるようにした (内部でCV修飾が外される)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic.html&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/a&gt;&lt;/code&gt;ライブラリのアトミック操作を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;を非順序連想コンテナのキーとして使用できるよう、&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に所有権ベースのハッシュ値を取得する関数オブジェクト&lt;code&gt;&lt;a href=&#34;../reference/memory/owner_hash.md.nolink&#34;&gt;std::owner_hash&lt;/a&gt;&lt;/code&gt;、および所有権ベースの等値比較を行う関数オブジェクト&lt;code&gt;&lt;a href=&#34;../reference/memory/owner_equal.md.nolink&#34;&gt;std::owner_equal&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;関連して、&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;クラスのメンバ関数として、&lt;code&gt;owner_hash()&lt;/code&gt;と&lt;code&gt;owner_equal()&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;日付・時間&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のクラスに、ハッシュ値サポートとして&lt;code&gt;&lt;a href=&#34;../reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;の特殊化を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/duration.html&#34;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/time_point.html&#34;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/day.html&#34;&gt;std::chrono::day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month.html&#34;&gt;std::chrono::month&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year.html&#34;&gt;std::chrono::year&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday.html&#34;&gt;std::chrono::weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday_indexed.html&#34;&gt;std::chrono::weekday_indexed&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday_last.html&#34;&gt;std::chrono::weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_day.html&#34;&gt;std::chrono::month_day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_day_last.html&#34;&gt;std::chrono::month_day_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_weekday.html&#34;&gt;std::chrono::month_weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_weekday_last.html&#34;&gt;std::chrono::month_weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month.html&#34;&gt;std::chrono::year_month&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_day.html&#34;&gt;std::chrono::year_month_day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_day_last.html&#34;&gt;std::chrono::year_month_day_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_weekday.html&#34;&gt;std::chrono::year_month_weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_weekday_last.html&#34;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/zoned_time.html&#34;&gt;std::chrono::zoned_time&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/leap_second.html&#34;&gt;std::chrono::leap_second&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数値&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に、飽和演算 (Saturation Arithmetic) として、型の表現可能な範囲で演算を行う以下の関数を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/add_sat.html&#34;&gt;std::add_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/sub_sat.html&#34;&gt;std::sub_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/mul_sat.html&#34;&gt;std::mul_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/div_sat.html&#34;&gt;std::div_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/saturate_cast.html&#34;&gt;std::saturate_cast()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の関数を、&lt;code&gt;constexpr&lt;/code&gt;に対応 (特殊関数と、グローバルの丸めモードに依存する丸め関数以外の全て)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cos.html&#34;&gt;std::cos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sin.html&#34;&gt;std::sin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tan.html&#34;&gt;std::tan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cosh.html&#34;&gt;std::cosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sinh.html&#34;&gt;std::sinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tanh.html&#34;&gt;std::tanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/acos.html&#34;&gt;std::acos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/asin.html&#34;&gt;std::asin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atan.html&#34;&gt;std::atan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atan2.html&#34;&gt;std::atan2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/acosh.html&#34;&gt;std::acosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/asinh.html&#34;&gt;std::asinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atanh.html&#34;&gt;std::atanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/exp.html&#34;&gt;std::exp()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/exp2.html&#34;&gt;std::exp2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/expm1.html&#34;&gt;std::expm1()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log.html&#34;&gt;std::log()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log10.html&#34;&gt;std::log10()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log1p.html&#34;&gt;std::log1p()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log2.html&#34;&gt;std::log2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/pow.html&#34;&gt;std::pow()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sqrt.html&#34;&gt;std::sqrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cbrt.html&#34;&gt;std::cbrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/hypot.html&#34;&gt;std::hypot()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/erf.html&#34;&gt;std::erf()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/erfc.html&#34;&gt;std::erfc()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/lgamma.html&#34;&gt;std::lgamma()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tgamma.html&#34;&gt;std::tgamma()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex.html&#34;&gt;&amp;lt;complex&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の関数を、&lt;code&gt;constexpr&lt;/code&gt;に対応 (すべて)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/abs.html&#34;&gt;std::abs()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/arg.html&#34;&gt;std::arg()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/proj.html&#34;&gt;std::proj()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/polar.html&#34;&gt;std::polar()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/cos.html&#34;&gt;std::cos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sin.html&#34;&gt;std::sin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/tan.html&#34;&gt;std::tan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/cosh.html&#34;&gt;std::cosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sinh.html&#34;&gt;std::sinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/tanh.html&#34;&gt;std::tanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/acos.html&#34;&gt;std::acos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/asin.html&#34;&gt;std::asin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/atan.html&#34;&gt;std::atan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/acosh.html&#34;&gt;std::acosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/asinh.html&#34;&gt;std::asinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/atanh.html&#34;&gt;std::atanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/exp.html&#34;&gt;std::exp()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/log.html&#34;&gt;std::log()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/log10.html&#34;&gt;std::log10()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/pow.html&#34;&gt;std::pow()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sqrt.html&#34;&gt;std::sqrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/norm.html&#34;&gt;std::norm()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/conj.html&#34;&gt;std::conj()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/imag_free.html&#34;&gt;std::imag()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/real_free.html&#34;&gt;std::real()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;を構造化束縛や、将来のパターンマッチで使用できるようタプルインタフェースの特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;の範囲&lt;code&gt;[0, 1)&lt;/code&gt;の乱数を生成する&lt;code&gt;&lt;a href=&#34;../reference/random/generate_canonical.html&#34;&gt;std::generate_canonical()&lt;/a&gt;&lt;/code&gt;を、望ましい統計的性質を保証するようアルゴリズムと制約を変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に、乱数列を生成する&lt;code&gt;&lt;a href=&#34;../reference/random/generate_random.html&#34;&gt;std::ranges::generate_random()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に、乱数生成器は並列シミュレーションに効果的なカウンターベースのPhilox乱数生成器として、&lt;code&gt;&lt;a href=&#34;../reference/random/philox_engine.html&#34;&gt;std::philox_engine&lt;/a&gt;&lt;/code&gt;クラス、およびその別名である&lt;code&gt;&lt;a href=&#34;../reference/random/philox4x32.html&#34;&gt;std::philox4x32&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/random/philox4x64.html&#34;&gt;std::philox4x64&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/variant/variant.html&#34;&gt;std::variant&lt;/a&gt;&lt;/code&gt;クラスに、メンバ関数版の&lt;code&gt;&lt;a href=&#34;../reference/variant/variant/visit.md.nolink&#34;&gt;visit()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional.html&#34;&gt;std::optional&lt;/a&gt;&lt;/code&gt;クラスに、0もしくは1要素のRangeとして扱えるようにするための拡張として、イテレータインタフェースを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iterator&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_iterator&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional/begin.md.nolink&#34;&gt;begin()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional/end.md.nolink&#34;&gt;end()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/tuple/ignore.html&#34;&gt;std::ignore&lt;/a&gt;&lt;/code&gt;をファーストクラス・オブジェクトとして型を詳細に定義&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/bitset/bitset.html&#34;&gt;std::bitset&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を受け取るコンストラクタを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio.html&#34;&gt;&amp;lt;ratio&amp;gt;&lt;/a&gt;&lt;/code&gt;に、新たなSI接頭辞として、以下を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;ronna&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;27&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;ronto&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;−27&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;quetta&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;30&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;quecto&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;−30&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定数式での例外送出が許可されることにともない、以下を&lt;code&gt;constexpr&lt;/code&gt;化&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception.html&#34;&gt;&amp;lt;exception&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/exception.html&#34;&gt;std::exception&lt;/a&gt;&lt;/code&gt;クラスの全メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/nested_exception.html&#34;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;クラスの全面場関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/bad_exception.html&#34;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/uncaught_exceptions.html&#34;&gt;std::uncaught_exceptions()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/current_exception.html&#34;&gt;std::current_exception()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/rethrow_exception.html&#34;&gt;std::rethrow_exception()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/make_exception_ptr.html&#34;&gt;std::make_exception_ptr()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/throw_with_nested.html&#34;&gt;std::throw_with_nested()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/rethrow_if_nested.html&#34;&gt;std::rethrow_if_nested()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new.html&#34;&gt;&amp;lt;new&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new/bad_alloc.html&#34;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new/bad_array_new_length.html&#34;&gt;std::bad_array_new_length&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo.html&#34;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo/bad_cast.html&#34;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo/bad_typeid.html&#34;&gt;std::bad_typeid&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、ポインタのアライメントを判定する&lt;code&gt;&lt;a href=&#34;../reference/memory/is_sufficiently_aligned.html&#34;&gt;std::is_sufficiently_aligned()&lt;/a&gt;&lt;/code&gt;関数を追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;デバッグ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cassert/assert.html&#34;&gt;assert&lt;/a&gt;&lt;/code&gt;マクロの引数としてカンマを含む式を指定できるよう、可変引数化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、共用体のどのメンバがアクティブかを判定するための関数として&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_within_lifetime.md.nolink&#34;&gt;std::is_within_lifetime()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、仮想継承の関係を判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_virtual_base_of.md.nolink&#34;&gt;std::is_virtual_base_of&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;制約&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;間接実行に関連する制約から、共通参照の要件を削除&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirectly_unary_invocable.html&#34;&gt;std::indirectly_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirectly_unary_invocable.html&#34;&gt;std::indirectly_regular_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_unary_predicate.html&#34;&gt;std::indirect_unary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_binary_predicate.html&#34;&gt;std::indirect_binary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_equivalence_relation.html&#34;&gt;std::indirect_equivalence_relation&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_strict_weak_order.html&#34;&gt;std::indirect_strict_weak_order&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;の&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivial.html&#34;&gt;std::is_trivial&lt;/a&gt;&lt;/code&gt;を非推奨化&lt;ul&gt;
&lt;li&gt;これは&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivially_copyable.html&#34;&gt;std::is_trivially_copyable&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivially_default_constructible.html&#34;&gt;std::is_trivially_default_constructible&lt;/a&gt;&lt;/code&gt;の2つが合わさったものであるが、それらは異なる状況で必要になるものであった&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;非推奨の取り消し&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator.html&#34;&gt;std::polymorphic_allocator&lt;/a&gt;::&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/destroy.html&#34;&gt;destroy()&lt;/a&gt;&lt;/code&gt;の非推奨を取り消し&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++98から非推奨となっていた&lt;code&gt;&amp;lt;strstream&amp;gt;&lt;/code&gt;ライブラリを削除&lt;/li&gt;
&lt;li&gt;C++17から非推奨となっていたUnicode変換ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/codecvt.html&#34;&gt;&amp;lt;codecvt&amp;gt;&lt;/a&gt;&lt;/code&gt;と、&lt;code&gt;&lt;a href=&#34;../reference/locale/wstring_convert.html&#34;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/locale/wbuffer_convert.html&#34;&gt;std::wbuffer_convert&lt;/a&gt;&lt;/code&gt;クラスを削除&lt;/li&gt;
&lt;li&gt;C++20から非推奨となっていた、&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;../reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;のパラメータなしのオーバーロードを削除&lt;/li&gt;
&lt;li&gt;C++20から非推奨となっていた&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;に対する、以下の古いアトミック操作関数のオーバーロードを削除&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_is_lock_free.html&#34;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_load.html&#34;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_load_explicit.html&#34;&gt;std::atomic_load_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_store.html&#34;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_store_explicit.html&#34;&gt;std::atomic_store_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_exchange.html&#34;&gt;std::atomic_exchange&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_exchange_explicit.html&#34;&gt;std::atomic_exchange_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_weak.html&#34;&gt;std::atomic_compare_exchange_weak&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_strong.html&#34;&gt;std::atomic_compare_exchange_strong&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.html&#34;&gt;std::atomic_compare_exchange_weak_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.html&#34;&gt;std::atomic_compare_exchange_strong_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++23から非推奨となっていた、&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;のメンバ型&lt;code&gt;is_always_equal&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;atomic&amp;gt;&lt;/code&gt;ヘッダでは、アトミック操作(atomic operation ： 不可分操作とも呼ばれる)のライブラリを提供する。&lt;/p&gt;
&lt;p&gt;アトミック操作は、スレッド間でデータをやり取りするための最も基本的な同期プリミティブであり、
変数への不可分(atomic)な読み込みや書き込み、および読み書きを同時に行う操作(Read-Modify-Write operation)を提供する。&lt;/p&gt;
&lt;p&gt;本ヘッダはフリースタンディング環境でも提供される。
フリースタンディング環境の場合、常にロックフリーな整数アトミック型のサポート、&lt;code&gt;atomic_signed_lock_free&lt;/code&gt;や&lt;code&gt;atomic_unsigned_lock_free&lt;/code&gt;の提供可否は処理系定義となる。&lt;/p&gt;
&lt;h2&gt;順序と一貫性&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/memory_order.html&#34;&gt;memory_order&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーの種類(enum)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/kill_dependency.html&#34;&gt;kill_dependency&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;データ依存性を切る(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ロックフリープロパティ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_BOOL_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;bool&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_CHAR_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;char&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_CHAR8_T_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;char8_t&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_CHAR16_T_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;char16_t&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_CHAR32_T_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;char32_t&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_WCHAR_T_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;wchar_t&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_SHORT_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;short&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_INT_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;int&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_LONG_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;long&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_LLONG_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;long long&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/lock_free_property.html&#34;&gt;ATOMIC_POINTER_LOCK_FREE&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;atomic&amp;lt;T*&amp;gt;&lt;/code&gt;に対する操作がロックフリーかを調べる(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;汎用型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_ref.html&#34;&gt;atomic_ref&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;参照したオブジェクトに対してアトミック操作を適用する型(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic.html&#34;&gt;atomic&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アトミック型(class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;アトミック型に対する一般的な操作&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_is_lock_free.html&#34;&gt;atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定されたオブジェクトがロックフリーに振る舞うことができるかを調べる(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_init.html&#34;&gt;atomic_init&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初期化(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;br /&gt;C++20から非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_store.html&#34;&gt;atomic_store&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値を書き込む(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_store_explicit.html&#34;&gt;atomic_store_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して値を書き込む(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_load.html&#34;&gt;atomic_load&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値を読み込む(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_load_explicit.html&#34;&gt;atomic_load_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して値を読み込む(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_exchange.html&#34;&gt;atomic_exchange&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値を入れ替える(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_exchange_explicit.html&#34;&gt;atomic_exchange_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して値を入れ替える(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_compare_exchange_weak.html&#34;&gt;atomic_compare_exchange_weak&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;弱い比較で値の入れ替えを行う(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_compare_exchange_strong.html&#34;&gt;atomic_compare_exchange_strong&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;強い比較で値の入れ替えを行う(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_compare_exchange_weak_explicit.html&#34;&gt;atomic_compare_exchange_weak_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;弱い比較でメモリオーダーを指定して値の入れ替えを行う(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_compare_exchange_strong_explicit.html&#34;&gt;atomic_compare_exchange_strong_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;強い比較でメモリオーダーを指定して値の入れ替えを行う(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;アトミック型に対する算術操作&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_add.html&#34;&gt;atomic_fetch_add&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;加算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_add_explicit.html&#34;&gt;atomic_fetch_add_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して加算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_sub.html&#34;&gt;atomic_fetch_sub&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;減算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_sub_explicit.html&#34;&gt;atomic_fetch_sub_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して減算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_and.html&#34;&gt;atomic_fetch_and&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;AND演算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_and_explicit.html&#34;&gt;atomic_fetch_and_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定してAND演算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_or.html&#34;&gt;atomic_fetch_or&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OR演算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_or_explicit.html&#34;&gt;atomic_fetch_or_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定してOR演算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_xor.html&#34;&gt;atomic_fetch_xor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;XOR演算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_xor_explicit.html&#34;&gt;atomic_fetch_xor_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定してXOR演算(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_max.html&#34;&gt;atomic_fetch_max&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大値取得(function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_max_explicit.html&#34;&gt;atomic_fetch_max_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して最大値取得(function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_min.html&#34;&gt;atomic_fetch_min&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最小値取得(function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_fetch_min_explicit.html&#34;&gt;atomic_fetch_min_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して最小値取得(function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;アトミック型に対するブロッキング同期操作&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_wait.html&#34;&gt;atomic_wait&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;起床されるまで待機する (function template )&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_wait_explicit.html&#34;&gt;atomic_wait_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して起床されるまで待機する (function template )&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_notify_one.html&#34;&gt;atomic_notify_one&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;待機しているスレッドをひとつ起床させる (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_notify_all.html&#34;&gt;atomic_notify_all&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;待機している全てのスレッドを起床させる (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;初期化&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_var_init.html&#34;&gt;ATOMIC_VAR_INIT&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アトミック変数の初期化(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;br /&gt;C++20から非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;フラグ型とその操作&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag.html&#34;&gt;atomic_flag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;フラグ用アトミック型(class)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_test.html&#34;&gt;atomic_flag_test&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;現在の値を&lt;code&gt;bool&lt;/code&gt;値として取得する (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_test_explicit.html&#34;&gt;atomic_flag_test_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して現在の値を&lt;code&gt;bool&lt;/code&gt;値として取得する (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_test_and_set.html&#34;&gt;atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;フラグを立てる(function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_test_and_set_explicit.html&#34;&gt;atomic_flag_test_and_set_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定してフラグを立てる(function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_clear.html&#34;&gt;atomic_flag_clear&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;フラグをクリアする(function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_clear_explicit.html&#34;&gt;atomic_flag_clear_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定してフラグをクリアする(function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_wait.html&#34;&gt;atomic_flag_wait&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;起床されるまで待機する (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_wait_explicit.html&#34;&gt;atomic_flag_wait_explicit&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリオーダーを指定して起床されるまで待機する (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_notify_one.html&#34;&gt;atomic_flag_notify_one&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;待機しているスレッドをひとつ起床させる (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_notify_all.html&#34;&gt;atomic_flag_notify_all&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;待機している全てのスレッドを起床させる (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_flag_init.html&#34;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;フラグ変数の初期化(define)&lt;/td&gt;
&lt;td&gt;C++11&lt;br /&gt;C++20から非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;フェンス&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_thread_fence.html&#34;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スレッド間で有効なフェンスを設定する(function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;atomic/atomic_signal_fence.html&#34;&gt;atomic_signal_fence&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スレッドと、そのスレッド上で処理されるシグナルハンドラとの間でのみ有効なフェンスを設定する(function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;stdatomic.h.html&#34;&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2006/n2047.html&#34; target=&#34;_blank&#34;&gt;N2047 An Atomic Operations Library for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html&#34; target=&#34;_blank&#34;&gt;N2427 C++ Atomic Types and Operations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/atomic/&#34; target=&#34;_blank&#34;&gt;Boost Atomic Library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic.md b/reference/atomic/atomic.md
index d9c2b8b10..3b03104d2 100644
--- a/reference/atomic/atomic.md
+++ b/reference/atomic/atomic.md
@@ -162,6 +162,8 @@ namespace std {
 | [`fetch_and`](atomic/fetch_and.md)        | AND演算        | C++11 |
 | [`fetch_or`](atomic/fetch_or.md)          | OR演算         | C++11 |
 | [`fetch_xor`](atomic/fetch_xor.md)        | XOR演算        | C++11 |
+| [`fetch_max`](atomic/fetch_max.md)        | 最大値取得     | C++26 |
+| [`fetch_min`](atomic/fetch_min.md)        | 最小値取得     | C++26 |
 | [`operator++`](atomic/op_increment.md)    | インクリメント | C++11 |
 | [`operator--`](atomic/op_decrement.md)    | デクリメント   | C++11 |
 | [`operator+=`](atomic/op_plus_assign.md)  | 加算           | C++11 |
@@ -201,6 +203,8 @@ namespace std {
 |------|------|----------------|
 | [`fetch_add`](atomic/fetch_add.md)        | 加算 | C++11 |
 | [`fetch_sub`](atomic/fetch_sub.md)        | 減算 | C++11 |
+| [`fetch_max`](atomic/fetch_max.md)        | 最大値取得     | C++26 |
+| [`fetch_min`](atomic/fetch_min.md)        | 最小値取得     | C++26 |
 | [`operator++`](atomic/op_increment.md)    | インクリメント | C++11 |
 | [`operator--`](atomic/op_decrement.md)    | デクリメント | C++11 |
 | [`operator+=`](atomic/op_plus_assign.md)  | 加算 | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_max -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_max.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic/fetch_max.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_max.md b/reference/atomic/atomic/fetch_max.md
new file mode 100644
index 000000000..f4da609a6
--- /dev/null
+++ b/reference/atomic/atomic/fetch_max.md
@@ -0,0 +1,72 @@
+# fetch_max
+* atomic[meta header]
+* std[meta namespace]
+* atomic[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+T fetch_max(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) const noexcept;                         // (1) C++26
+```
+* memory_order[link /reference/atomic/memory_order.md]
+* memory_order_seq_cst[link /reference/atomic/memory_order.md]
+
+## 概要
+最大値を取得する。
+
+この関数は、`*this`が保持する値と`operand`の大きい方を返す。
+
+
+## テンプレートパラメータ制約
+- (1) : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+
+
+## 効果
+`order`で指定されたメモリオーダーにしたがって、[`std::max()`](/reference/algorithm/max.md)アルゴリズムのように`*this`が保持する値と`operand`の最大値を求めて返す
+
+
+## 例外
+投げない
+
+
+## 備考
+- この関数は、`atomic`クラスの整数型、ポインタに対する特殊化で定義される (浮動小数点数型に対しては定義されない)
+- ポインタ型
+    - ポインタが異なる完全型オブジェクトを指している場合、`&amp;lt;`演算子による比較は狭義の弱順序を確立しない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main()
+{
+  std::atomic&amp;lt;int&amp;gt; x(3);
+
+  int ret = x.fetch_max(2);
+
+  std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
+}
+```
+* fetch_max[color ff0000]
+
+
+### 出力
+```
+3
+```
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): 19 [mark noimpl]
+- [GCC](/implementation.md#gcc): 14 [mark noimpl]
+
+
+## 参照
+- [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_min -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_min.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic/fetch_min.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_min.md b/reference/atomic/atomic/fetch_min.md
new file mode 100644
index 000000000..576ab3fcf
--- /dev/null
+++ b/reference/atomic/atomic/fetch_min.md
@@ -0,0 +1,72 @@
+# fetch_min
+* atomic[meta header]
+* std[meta namespace]
+* atomic[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+T fetch_min(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) const noexcept;                         // (1) C++26
+```
+* memory_order[link /reference/atomic/memory_order.md]
+* memory_order_seq_cst[link /reference/atomic/memory_order.md]
+
+## 概要
+最小値を取得する。
+
+この関数は、`*this`が保持する値と`operand`の大きい方を返す。
+
+
+## テンプレートパラメータ制約
+- (1) : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+
+
+## 効果
+`order`で指定されたメモリオーダーにしたがって、[`std::min()`](/reference/algorithm/min.md)アルゴリズムのように`*this`が保持する値と`operand`の最小値を求めて返す
+
+
+## 例外
+投げない
+
+
+## 備考
+- この関数は、`atomic`クラスの整数型、ポインタに対する特殊化で定義される (浮動小数点数型に対しては定義されない)
+- ポインタ型
+    - ポインタが異なる完全型オブジェクトを指している場合、`&amp;lt;`演算子による比較は狭義の弱順序を確立しない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main()
+{
+  std::atomic&amp;lt;int&amp;gt; x(3);
+
+  int ret = x.fetch_min(2);
+
+  std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
+}
+```
+* fetch_min[color ff0000]
+
+
+### 出力
+```
+2
+```
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): 19 [mark noimpl]
+- [GCC](/implementation.md#gcc): 14 [mark noimpl]
+
+
+## 参照
+- [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_max -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_max.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic_fetch_max.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_max.md b/reference/atomic/atomic_fetch_max.md
new file mode 100644
index 000000000..72fcef80d
--- /dev/null
+++ b/reference/atomic/atomic_fetch_max.md
@@ -0,0 +1,71 @@
+# atomic_fetch_max
+* atomic[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;classT&amp;gt;
+  T atomic_fetch_max(volatile atomic&amp;lt;T&amp;gt;* object,
+                     typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (1) C++26
+
+  template &amp;lt;classT&amp;gt;
+  T atomic_fetch_max(atomic&amp;lt;T&amp;gt;* object,
+                     typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++26
+}
+```
+* atomic[link /reference/atomic/atomic.md]
+
+
+## 概要
+アトミックに最大値を取得する
+
+
+## テンプレートパラメータ制約
+- (1), (2) : 型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 効果
+[`memory_order_seq_cst`](memory_order.md)のメモリオーダーにしたがって、[`std::max()`](/reference/algorithm/max.md)アルゴリズムのように`*object`が保持する値と`operand`の最大値を求めて返す
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main()
+{
+  std::atomic&amp;lt;int&amp;gt; x(3);
+
+  int ret = std::atomic_fetch_max(&amp;amp;x, 2);
+
+  std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::atomic_fetch_max[color ff0000]
+
+### 出力
+```
+3
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+
+### 処理系
+- [Clang](/implementation.md#clang): 19 [mark noimpl]
+- [GCC](/implementation.md#gcc): 14 [mark noimpl]
+
+
+## 参照
+- [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_max_explicit -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_max_explicit.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic_fetch_max_explicit.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_max_explicit.md b/reference/atomic/atomic_fetch_max_explicit.md
new file mode 100644
index 000000000..926a49f8e
--- /dev/null
+++ b/reference/atomic/atomic_fetch_max_explicit.md
@@ -0,0 +1,73 @@
+# atomic_fetch_max_explicit
+* atomic[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T&amp;gt;
+  T atomic_fetch_max_explicit(
+      volatile atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand,
+      memory_order order) noexcept;                // (1) C++26
+
+  template &amp;lt;class T&amp;gt;
+  T atomic_fetch_max_explicit(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand,
+      memory_order order) noexcept;                // (2) C++26
+}
+```
+* atomic[link atomic.md]
+* memory_order[link memory_order.md]
+
+## 概要
+アトミックに最大値を取得する
+
+
+## テンプレートパラメータ制約
+- (1), (2) : 型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 効果
+`order`で指定されたメモリオーダーにしたがって、[`std::max()`](/reference/algorithm/max.md)アルゴリズムのように`*object`が保持する値と`operand`の最大値を求めて返す
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main()
+{
+  std::atomic&amp;lt;int&amp;gt; x(3);
+
+  int ret = std::atomic_fetch_max_explicit(&amp;amp;x, 2, std::memory_order_seq_cst);
+  std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::atomic_fetch_add_maxlicit[color ff0000]
+
+
+### 出力
+```
+3
+```
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): 19 [mark noimpl]
+- [GCC](/implementation.md#gcc): 14 [mark noimpl]
+
+
+## 参照
+- [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_min -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_min.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic_fetch_min.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_min.md b/reference/atomic/atomic_fetch_min.md
new file mode 100644
index 000000000..69e4a164a
--- /dev/null
+++ b/reference/atomic/atomic_fetch_min.md
@@ -0,0 +1,71 @@
+# atomic_fetch_min
+* atomic[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;classT&amp;gt;
+  T atomic_fetch_min(volatile atomic&amp;lt;T&amp;gt;* object,
+                     typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (1) C++26
+
+  template &amp;lt;classT&amp;gt;
+  T atomic_fetch_min(atomic&amp;lt;T&amp;gt;* object,
+                     typename atomic&amp;lt;T&amp;gt;::value_type operand) noexcept; // (2) C++26
+}
+```
+* atomic[link /reference/atomic/atomic.md]
+
+
+## 概要
+アトミックに最小値を取得する
+
+
+## テンプレートパラメータ制約
+- (1), (2) : 型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 効果
+[`memory_order_seq_cst`](memory_order.md)のメモリオーダーにしたがって、[`std::min()`](/reference/algorithm/min.md)アルゴリズムのように`*object`が保持する値と`operand`の最小値を求めて返す
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main()
+{
+  std::atomic&amp;lt;int&amp;gt; x(3);
+
+  int ret = std::atomic_fetch_min(&amp;amp;x, 2);
+
+  std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::atomic_fetch_min[color ff0000]
+
+### 出力
+```
+2
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+
+### 処理系
+- [Clang](/implementation.md#clang): 19 [mark noimpl]
+- [GCC](/implementation.md#gcc): 14 [mark noimpl]
+
+
+## 参照
+- [P0493R5 Atomic maximum/minimum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_fetch_min_explicit -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_fetch_min_explicit.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic_fetch_min_explicit.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_fetch_min_explicit.md b/reference/atomic/atomic_fetch_min_explicit.md
new file mode 100644
index 000000000..003fcbf40
--- /dev/null
+++ b/reference/atomic/atomic_fetch_min_explicit.md
@@ -0,0 +1,73 @@
+# atomic_fetch_min_explicit
+* atomic[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T&amp;gt;
+  T atomic_fetch_min_explicit(
+      volatile atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand,
+      memory_order order) noexcept;                // (1) C++26
+
+  template &amp;lt;class T&amp;gt;
+  T atomic_fetch_min_explicit(
+      atomic&amp;lt;T&amp;gt;* object,
+      typename atomic&amp;lt;T&amp;gt;::value_type operand,
+      memory_order order) noexcept;                // (2) C++26
+}
+```
+* atomic[link atomic.md]
+* memory_order[link memory_order.md]
+
+## 概要
+アトミックに最小値を取得する
+
+
+## テンプレートパラメータ制約
+- (1), (2) : 型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 効果
+`order`で指定されたメモリオーダーにしたがって、[`std::min()`](/reference/algorithm/min.md)アルゴリズムのように`*object`が保持する値と`operand`の最小値を求めて返す
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main()
+{
+  std::atomic&amp;lt;int&amp;gt; x(3);
+
+  int ret = std::atomic_fetch_min_explicit(&amp;amp;x, 2, std::memory_order_seq_cst);
+  std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::atomic_fetch_add_maxlicit[color ff0000]
+
+
+### 出力
+```
+2
+```
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): 19 [mark noimpl]
+- [GCC](/implementation.md#gcc): 14 [mark noimpl]
+
+
+## 参照
+- [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atomic_ref -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic_ref.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref.md b/reference/atomic/atomic_ref.md
index 156f23ca7..d9f77af79 100644
--- a/reference/atomic/atomic_ref.md
+++ b/reference/atomic/atomic_ref.md
@@ -89,6 +89,8 @@ C++26から、これらの特殊化はCV修飾された型に対しても行わ
 | [`fetch_and`](atomic_ref/fetch_and.md)        | AND演算        | C++20 |
 | [`fetch_or`](atomic_ref/fetch_or.md)          | OR演算         | C++20 |
 | [`fetch_xor`](atomic_ref/fetch_xor.md)        | XOR演算        | C++20 |
+| [`fetch_max`](atomic_ref/fetch_max.md)        | 最大値取得     | C++26 |
+| [`fetch_min`](atomic_ref/fetch_min.md)        | 最小値取得     | C++26 |
 | [`operator++`](atomic_ref/op_increment.md)    | インクリメント | C++20 |
 | [`operator--`](atomic_ref/op_decrement.md)    | デクリメント   | C++20 |
 | [`operator+=`](atomic_ref/op_plus_assign.md)  | 加算           | C++20 |
@@ -128,6 +130,8 @@ C++26から、これらの特殊化はCV修飾された型に対しても行わ
 |------|------|----------------|
 | [`fetch_add`](atomic_ref/fetch_add.md)        | 加算 | C++20 |
 | [`fetch_sub`](atomic_ref/fetch_sub.md)        | 減算 | C++20 |
+| [`fetch_max`](atomic_ref/fetch_max.md)        | 最大値取得     | C++26 |
+| [`fetch_min`](atomic_ref/fetch_min.md)        | 最小値取得     | C++26 |
 | [`operator++`](atomic_ref/op_increment.md)    | インクリメント | C++20 |
 | [`operator--`](atomic_ref/op_decrement.md)    | デクリメント | C++20 |
 | [`operator+=`](atomic_ref/op_plus_assign.md)  | 加算 | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_max -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_max.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic_ref/fetch_max.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_max.md b/reference/atomic/atomic_ref/fetch_max.md
new file mode 100644
index 000000000..eac81830b
--- /dev/null
+++ b/reference/atomic/atomic_ref/fetch_max.md
@@ -0,0 +1,71 @@
+# fetch_max
+* atomic[meta header]
+* std[meta namespace]
+* atomic_ref[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+T fetch_max(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) const noexcept;                         // (1) C++26
+```
+* memory_order[link /reference/atomic/memory_order.md]
+* memory_order_seq_cst[link /reference/atomic/memory_order.md]
+
+## 概要
+最大値を取得する。
+
+この関数は、`*this`が保持する値と`operand`の大きい方を返す。
+
+
+## テンプレートパラメータ制約
+- (1) : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+
+
+## 効果
+`order`で指定されたメモリオーダーにしたがって、[`std::max()`](/reference/algorithm/max.md)アルゴリズムのように`*this`が保持する値と`operand`の最大値を求めて返す
+
+
+## 例外
+投げない
+
+
+## 備考
+- この関数は、`atomic`クラスの整数型、ポインタに対する特殊化で定義される (浮動小数点数型に対しては定義されない)
+- ポインタ型
+    - ポインタが異なる完全型オブジェクトを指している場合、`&amp;lt;`演算子による比較は狭義の弱順序を確立しない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main()
+{
+  int x = 3;
+  int ret = std::atomic_ref{x}.fetch_max(2);
+
+  std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
+}
+```
+* fetch_max[color ff0000]
+
+
+### 出力
+```
+3
+```
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): 19 [mark noimpl]
+- [GCC](/implementation.md#gcc): 14 [mark noimpl]
+
+
+## 参照
+- [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_min -- C++26対応としてatomic(_ref)にfetch_max/minを追加 (close #1188)</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic_ref/fetch_min.html"/>
      <id>eef0639011e770371d6c76f9bb686bfcd1358b25:reference/atomic/atomic_ref/fetch_min.md</id>
      <updated>2024-12-23T15:19:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic_ref/fetch_min.md b/reference/atomic/atomic_ref/fetch_min.md
new file mode 100644
index 000000000..4beac4381
--- /dev/null
+++ b/reference/atomic/atomic_ref/fetch_min.md
@@ -0,0 +1,71 @@
+# fetch_min
+* atomic[meta header]
+* std[meta namespace]
+* atomic_ref[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+T fetch_min(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) const noexcept;                         // (1) C++26
+```
+* memory_order[link /reference/atomic/memory_order.md]
+* memory_order_seq_cst[link /reference/atomic/memory_order.md]
+
+## 概要
+最小値を取得する。
+
+この関数は、`*this`が保持する値と`operand`の大きい方を返す。
+
+
+## テンプレートパラメータ制約
+- (1) : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+
+
+## 効果
+`order`で指定されたメモリオーダーにしたがって、[`std::min()`](/reference/algorithm/min.md)アルゴリズムのように`*this`が保持する値と`operand`の最小値を求めて返す
+
+
+## 例外
+投げない
+
+
+## 備考
+- この関数は、`atomic`クラスの整数型、ポインタに対する特殊化で定義される (浮動小数点数型に対しては定義されない)
+- ポインタ型
+    - ポインタが異なる完全型オブジェクトを指している場合、`&amp;lt;`演算子による比較は狭義の弱順序を確立しない
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;atomic&amp;gt;
+
+int main()
+{
+  int x = 3;
+  int ret = std::atomic_ref{x}.fetch_min(2);
+
+  std::cout &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl;
+}
+```
+* fetch_min[color ff0000]
+
+
+### 出力
+```
+2
+```
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): 19 [mark noimpl]
+- [GCC](/implementation.md#gcc): 14 [mark noimpl]
+
+
+## 参照
+- [P0493R5 Atomic minimum/maximum](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0493r5.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>