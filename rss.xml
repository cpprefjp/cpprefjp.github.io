<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-17T09:09:01.961514</updated>
  <id>de6e8dc8-535d-4139-ba79-558eb1b08336</id>

  
    <entry>
      <title>ディレクトリ構造 -- Merge pull request #1128 from cpprefjp/dict-struct</title>
      <link href="https://cpprefjp.github.io/start_editing/directory_structure.html"/>
      <id>c6827281ccfc04ced709ccdf398f9058f43c5469:start_editing/directory_structure.md</id>
      <updated>2023-02-17T18:04:42+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;ディレクトリ構造&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;lang&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cpp{version}.mdの形式で、各C++バージョンの言語機能ページを作る&lt;/li&gt;
&lt;li&gt;future.mdは、将来のC++で検討されている言語機能を記載するところである。導入予定だった機能が再検討になった場合などに使用する&lt;/li&gt;
&lt;li&gt;archive.mdは、廃案になったC++機能だが解説として残す価値のあるものがある場合に、記載するところである&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;reference / module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;reference階層は、ヘッダベースのライブラリリファレンスで、その階層直下にはヘッダページを置く&lt;/li&gt;
&lt;li&gt;module階層は、モジュールベースのライブラリリファレンスで、その階層直下にはモジュールページを置く&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reference階層とmodule階層は上記以外は同じであるため、以下、共通のルールを書きます。&lt;/p&gt;
&lt;h3&gt;ヘッダ・モジュール階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ヘッダ・モジュール階層以下に、それに所属している機能のページを置く&lt;/li&gt;
&lt;li&gt;どのヘッダ・モジュールにも属さない機能の場合は、以下のように対応する&lt;ul&gt;
&lt;li&gt;全体で使用する説明専用の機能は、仮のヘッダ&lt;code&gt;&amp;lt;exposition-only&amp;gt;&lt;/code&gt;に属するものとして記載する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;クラス階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;クラスに属するメンバ関数と型は、クラス階層の下に置く&lt;/li&gt;
&lt;li&gt;オーバーロードを意図している関数、そのクラス向けに特殊化した機能も、クラス階層の下に置き、機能の列挙としてもクラスページで行う&lt;ul&gt;
&lt;li&gt;オーバーロードを意図している関数の例は以下：&lt;ul&gt;
&lt;li&gt;非メンバ関数の演算子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::get()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::begin()&lt;/code&gt;/&lt;code&gt;std::end()&lt;/code&gt;/&lt;code&gt;std::data()&lt;/code&gt;/&lt;code&gt;std::size()&lt;/code&gt;およびそれに類するもの&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::swap()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::erase()&lt;/code&gt;/&lt;code&gt;std::erase_if()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor()&lt;/code&gt;/&lt;code&gt;ceil()&lt;/code&gt;/&lt;code&gt;round()&lt;/code&gt; (chrono)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/expected/expected.html&#34;&gt;std::expected&lt;/a&gt;&lt;/code&gt;では&lt;a href=&#34;https://cpprefjp.github.io/reference/expected/expected.void.html&#34;&gt;`部分特殊化&lt;/a&gt;のためにクラス階層を分離している。これは各メンバ説明の差分が大きいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;演算子オーバーロードは、&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; (出力ストリームへの出力) と &lt;code&gt;std::operator&amp;gt;&amp;gt;&lt;/code&gt; (入力ストリームからの入力) を除き、左辺のクラスに属するものとする&lt;ul&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error/error_code.html&#34;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error/error_condition.html&#34;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;の比較演算子は、クラス階層ではなくヘッダ階層としている。これは所属関係がむずかしいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンセプト階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;コンセプトによってオーバーロード・特殊化されている場合は、コンセプトの階層を作って、その下に置く。機能の列挙としてはヘッダページで行う&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;名前空間階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;名前空間の階層は基本的に導入しない。例外は以下：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/this_thread.html&#34;&gt;std::this_thread&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;名前空間に特殊な意味をもたせている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ディレクトリ構造 -- ディレクトリ構造: クラス階層expected/expected.void特例を明記(#1066)</title>
      <link href="https://cpprefjp.github.io/start_editing/directory_structure.html"/>
      <id>910ec8ffb3fc83359cb2515e37f3230fd992090b:start_editing/directory_structure.md</id>
      <updated>2023-02-17T16:54:31+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;ディレクトリ構造&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;lang&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cpp{version}.mdの形式で、各C++バージョンの言語機能ページを作る&lt;/li&gt;
&lt;li&gt;future.mdは、将来のC++で検討されている言語機能を記載するところである。導入予定だった機能が再検討になった場合などに使用する&lt;/li&gt;
&lt;li&gt;archive.mdは、廃案になったC++機能だが解説として残す価値のあるものがある場合に、記載するところである&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;reference / module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;reference階層は、ヘッダベースのライブラリリファレンスで、その階層直下にはヘッダページを置く&lt;/li&gt;
&lt;li&gt;module階層は、モジュールベースのライブラリリファレンスで、その階層直下にはモジュールページを置く&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reference階層とmodule階層は上記以外は同じであるため、以下、共通のルールを書きます。&lt;/p&gt;
&lt;h3&gt;ヘッダ・モジュール階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ヘッダ・モジュール階層以下に、それに所属している機能のページを置く&lt;/li&gt;
&lt;li&gt;どのヘッダ・モジュールにも属さない機能の場合は、以下のように対応する&lt;ul&gt;
&lt;li&gt;全体で使用する説明専用の機能は、仮のヘッダ&lt;code&gt;&amp;lt;exposition-only&amp;gt;&lt;/code&gt;に属するものとして記載する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;クラス階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;クラスに属するメンバ関数と型は、クラス階層の下に置く&lt;/li&gt;
&lt;li&gt;オーバーロードを意図している関数、そのクラス向けに特殊化した機能も、クラス階層の下に置き、機能の列挙としてもクラスページで行う&lt;ul&gt;
&lt;li&gt;オーバーロードを意図している関数の例は以下：&lt;ul&gt;
&lt;li&gt;非メンバ関数の演算子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::get()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::begin()&lt;/code&gt;/&lt;code&gt;std::end()&lt;/code&gt;/&lt;code&gt;std::data()&lt;/code&gt;/&lt;code&gt;std::size()&lt;/code&gt;およびそれに類するもの&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::swap()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::erase()&lt;/code&gt;/&lt;code&gt;std::erase_if()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor()&lt;/code&gt;/&lt;code&gt;ceil()&lt;/code&gt;/&lt;code&gt;round()&lt;/code&gt; (chrono)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/expected/expected.html&#34;&gt;std::expected&lt;/a&gt;&lt;/code&gt;では&lt;a href=&#34;https://cpprefjp.github.io/reference/expected/expected.void.html&#34;&gt;`部分特殊化&lt;/a&gt;のためにクラス階層を分離している。これは各メンバ説明の差分が大きいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;演算子オーバーロードは、&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; (出力ストリームへの出力) と &lt;code&gt;std::operator&amp;gt;&amp;gt;&lt;/code&gt; (入力ストリームからの入力) を除き、左辺のクラスに属するものとする&lt;ul&gt;
&lt;li&gt;特殊な例として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error/error_code.html&#34;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error/error_condition.html&#34;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;の比較演算子は、クラス階層ではなくヘッダ階層としている。これは所属関係がむずかしいためである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンセプト階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;コンセプトによってオーバーロード・特殊化されている場合は、コンセプトの階層を作って、その下に置く。機能の列挙としてはヘッダページで行う&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;名前空間階層&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;名前空間の階層は基本的に導入しない。例外は以下：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/this_thread.html&#34;&gt;std::this_thread&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;名前空間に特殊な意味をもたせている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functinoal/hash: 関連項目に特殊化版へのリンク列挙</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>bc842eccb3ea7ec2195a7d339994b4d9af21d4ea:reference/functional/hash.md</id>
      <updated>2023-02-17T16:25:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index f2bcb7730..f1b626178 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -38,7 +38,7 @@ namespace std {
 
 このクラスはそのものにデフォルトの定義は存在せず、ユーザーが任意の型で特殊化する際の要件を定義する。`hash`クラステンプレートを特殊化する場合、以下に記述するメンバ関数を持たせる必要がある。
 
-なお、`&amp;lt;functional&amp;gt;`ヘッダでは、以下の特殊化を提供する：
+`&amp;lt;functional&amp;gt;`ヘッダでは、以下の特殊化を提供する。これ以外の特殊化は、対象型を定義する各種ヘッダファイルにて提供される：
 
 | 型                   | 対応バージョン |
 |----------------------|----------------|
@@ -167,6 +167,26 @@ found : 3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+
+## 関連項目
+
+| ヘッダ | 特殊化対象 |
+|--------|------------|
+| [`&amp;lt;coroutine&amp;gt;`](/reference/coroutine.md) | [`std::coroutine_handle`](/reference/coroutine/coroutine_handle.md) |
+| [`&amp;lt;bitset&amp;gt;`](/reference/bitset.md) | [`std::bitset`](/reference/bitset/bitset.md) |
+| [`&amp;lt;filesystem&amp;gt;`](/reference/filesystem.md) | [`std::filesystem::path`](/reference/filesystem/path.md) |
+| [`&amp;lt;optional&amp;gt;`](/reference/optional.md) | [`std::optional`](/reference/optional/optional.md) |
+| [`&amp;lt;memory&amp;gt;`](/reference/memory.md) | [`std::shared_ptr`](/reference/memory/shared_ptr.md), [`std::unique_ptr`](/reference/memory/unique_ptr.md) |
+| [`&amp;lt;stacktrace&amp;gt;`](/reference/stacktrace.md) | [`std::basic_backtrace`](/reference/stacktrace/basic_stacktrace.md), [`std::stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md) |
+| [`&amp;lt;string&amp;gt;`](/reference/string.md) | `std::string`など |
+| [`&amp;lt;string_view&amp;gt;`](/reference/string_view.md) | `std::string_view`など |
+| [`&amp;lt;system_error&amp;gt;`](/reference/system_error.md) | [`std::error_code`](/reference/system_error/error_code.md), [`std::error_condition`](/reference/system_error/error_condition.md) |
+| [`&amp;lt;thread&amp;gt;`](/reference/thread.md) | [`std::thread:id`](/reference/thread/thread.md) |
+| [`&amp;lt;typeindex&amp;gt;`](/reference/typeindex.md) | [`std::type_index`](/reference/typeindex/type_index.md) |
+| [`&amp;lt;variant&amp;gt;`](/reference/variant.md) | [`std::variant`](/reference/variant/variant.md), [`std::monostate`](/reference/variant/monostate.md) |
+| [`&amp;lt;vector&amp;gt;`](/reference/vector.md) | [`std::vector&amp;lt;bool&amp;gt;`](/reference/vector/vector.md) |
+
+
 ## 参照
 - [ハッシュ関数 - Wikipedia](https://ja.wikipedia.org/wiki/ハッシュ関数)
 - [LWG 2148 - Hashing enums should be supported directly by std::hash](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functional/hash: メンバ型is_transparent 説明文を見直し</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>16cab03355668b5b677440ac2a954a3d72817aa2:reference/functional/hash.md</id>
      <updated>2023-02-17T14:51:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index a2df8a8dd..f2bcb7730 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -80,7 +80,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt; 標準ライブラリの`hash`クラスの特殊化がこの型を持つかは未規定。&amp;lt;br/&amp;gt; この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
+| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt;この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functional/hash: 透過的ハッシュ/等値比較の例示コードを改善</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>5415e29dfd912b953b8249e2d1b51dd18f57c4b5:reference/functional/hash.md</id>
      <updated>2023-02-17T14:13:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index 09717118b..a2df8a8dd 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -123,16 +123,25 @@ int main()
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;unordered_map&amp;gt;
 #include &amp;lt;string&amp;gt;
+#include &amp;lt;string_view&amp;gt;
+
+struct string_hash {
+  using is_transparent = void;
+  // string/string_view/const char*共用ハッシュ計算
+  size_t operator()(std::string_view sv) const {
+    return std::hash&amp;lt;std::string_view&amp;gt;{}(sv);
+  }
+};
 
 int main()
 {
-  std::unordered_map&amp;lt;std::string, int&amp;gt; um = {
+  std::unordered_map&amp;lt;std::string, int, string_hash, std::equal_to&amp;lt;&amp;gt;&amp;gt; um = {
     {&amp;#34;Alice&amp;#34;, 3},
     {&amp;#34;Bob&amp;#34;, 1},
     {&amp;#34;Carol&amp;#34;, 4}
   };
 
-  // std::equal_to&amp;lt;std::string&amp;gt;とstd::hash&amp;lt;std::string&amp;gt;がis_transparent型を持つ場合、
+  // string_hashおよびstd::equal_to&amp;lt;&amp;gt;はいずれもメンバ型にis_transparentを持つため、
   // find()などの検索関数に引数を渡す場合に、std::string一時オブジェクトが作られない
   auto it = um.find(&amp;#34;Alice&amp;#34;);
   if (it != um.end()) {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>