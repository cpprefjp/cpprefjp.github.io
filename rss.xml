<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-12-23T11:52:32.388236</updated>
  <id>07b9e073-cdc0-4c68-bc14-dad2d15cf197</id>

  
    <entry>
      <title>契約プログラミング [P2900R14] -- contracts: Adding contents(#1419)</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/contracts.html"/>
      <id>5b4545770cf94c6ef9c3bc732b896065d763cfaa:lang/cpp26/contracts.md</id>
      <updated>2025-12-23T20:47:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/contracts.md b/lang/cpp26/contracts.md
index 05c1613ff..ab3863f62 100644
--- a/lang/cpp26/contracts.md
+++ b/lang/cpp26/contracts.md
@@ -18,9 +18,9 @@ C++26では、関数の正確な動作を明示的に指定でき、プログラ
 
 ## 仕様
 ### キーワード
-`pre`、`post`、`assert`は文脈依存キーワードである。これらは`override`や`final`と同様に、特定の文脈でのみ特別な意味を持つ。
+`pre`、`post`は文脈依存キーワードである。これらは`override`や`final`と同様に、特定の文脈でのみ特別な意味を持つ。`contract_assert`は完全なキーワードである。
 
-- 変数名や関数名として使用可能
+- `pre`と`post`は変数名や関数名として使用可能
   ```cpp
   int pre = 42;  // OK: 変数名として使用
   void post() {} // OK: 関数名として使用
@@ -30,6 +30,12 @@ C++26では、関数の正確な動作を明示的に指定でき、プログラ
   void f()
     pre(true);   // ここでは契約指定として機能
   ```
+- `contract_assert`は既存の`assert`マクロとの衝突を避けるための完全なキーワード
+  ```cpp
+  void g() {
+    contract_assert(true);  // アサーション文
+  }
+  ```
 
 ### 契約の種類
 契約には以下の3種類が定められている。
@@ -102,60 +108,637 @@ public:
 #### アサーション(assert)
 関数の実行中に満たされているべき条件を指定する。
 ```cpp
-void return_negative(int value)
+int return_negative(int value)
 {
     contract_assert(value &amp;gt;= 0);
     return -value;
 }
 ```
-ここでは、`return_negative`関数のが引数として受け取っている`value`が0以上であることをアサーションとして指定している。
+ここでは、`return_negative`関数が引数として受け取っている`value`が0以上であることをアサーションとして指定している。
 
 `contract_assert`は、関数の本体内で使用される。
 
 また、これらの全ては、`[[ likely ]]`や`[[ unlikely ]]`、 `[[ maybe_unused ]]`属性を使用することができる。
 ```cpp
-void return_negative(int value)
+int return_negative(int value)
   pre [[likely]] (value &amp;gt;= 0)
   post (r [[maybe_unused]] : r &amp;lt;= 0)
   {
     return -value;
   }
 ```
+### 構文上の制約
+契約プログラミングには、いくつかの構文上の制約がある。
+
+#### 複数の宣言
+関数に複数の宣言がある場合、それらすべてに同じ契約指定子の並びを指定することも、一部の宣言にのみ指定することもできる。契約指定子の並びが指定されていない宣言は、他の宣言から契約アサーションを継承する。
+
+```cpp
+int f(int x) pre(x &amp;gt; 0);  // 宣言
+int f(int x);             // OK: 契約アサーションを継承
+int f(int x) pre(x &amp;gt; 0) { // OK: 定義でも同じ契約を指定
+    return x * 2;
+}
+```
+
+#### 仮想関数
+仮想関数に事前条件または事後条件の指定子を付けることは不適格（ill-formed）である。仮想関数への`pre`と`post`のサポートは、将来の拡張として提案される予定である。
+
+```cpp
+struct Base {
+    // エラー：仮想関数に契約指定子を適用できない
+    virtual int compute(int x) pre(x &amp;gt; 0) = 0;
+};
+```
+
+#### デフォルト化・削除された関数
+最初の宣言でデフォルト化（`= default`）された関数に事前条件または事後条件指定子を付けることは不適格（ill-formed）である。
+
+```cpp
+struct X {
+    X() pre(true) = default;           // エラー: 最初の宣言でdefault化
+    X(const X&amp;amp;) pre(true) = default;   // エラー: 最初の宣言でdefault化
+};
+```
+
+ただし、最初の宣言ではない宣言でデフォルト化する場合は契約指定子を付けることができる。
+
+```cpp
+struct Y {
+    Y() pre(true);                      // 最初の宣言に契約指定子
+};
+Y::Y() pre(true) = default;             // OK: 最初の宣言ではない（pre(true)は省略可能）
+```
+
+また、明示的に削除（`= delete`）された関数に事前条件または事後条件指定子を付けることは不適格である。
+
+```cpp
+struct Z {
+    Z() pre(true) = delete;             // エラー: 削除された関数
+    Z&amp;amp; operator=(const Z&amp;amp;) pre(true) = delete; // エラー: 削除された関数
+};
+```
+
+#### コンストラクタとデストラクタの制約
+コンストラクタの事前条件アサーションまたはデストラクタの事後条件アサーションの述語内で、クラスの非静的データメンバを`this-&amp;gt;`なしで直接参照すると、プログラムは不適格となる。これは、オブジェクトの生存期間の開始前または終了後にメンバにアクセスする未定義動作のリスクを最小限に抑えるためである。
+
+```cpp
+struct X {
+    int i = 0;
+    bool f();
+
+    X()
+        pre(i == 0)              // エラー: thisなしでメンバ参照
+        pre(f())                 // エラー: thisなしでメンバ関数呼び出し
+        pre(this-&amp;gt;i == 0)        // OK: thisを明示的に使用
+        pre(this-&amp;gt;f())           // OK
+    {}
+
+    ~X()
+        pre(i == 0)              // OK: デストラクタの事前条件
+        post(i == 0)             // エラー: デストラクタの事後条件でメンバ参照
+        post(this-&amp;gt;i == 0)       // OK
+    {}
+};
+```
+
+#### await式とyield式
+コルーチン内の契約アサーションの述語に、そのコルーチンの中断コンテキスト内にある`await`式または`yield`式が含まれている場合、プログラムは不適格となる。
+
+```cpp
+std::generator&amp;lt;int&amp;gt; f() {
+    contract_assert(((co_yield 1), true));  // エラー
+}
+
+stdex::task&amp;lt;void&amp;gt; g() {
+    contract_assert((co_await query_database()) &amp;gt; 0);  // エラー
+}
+```
+
+#### 関数へのポインタとメンバ関数へのポインタ
+関数へのポインタやメンバ関数へのポインタに契約指定子を適用することはできない。
+
+```cpp
+typedef int (*fpt)(int) post(r: r != 0);  // エラー
+
+int f(int x) post(r: r != 0);
+int (*fp)(int) post(r: r != 0) = f;       // エラー
+```
+
+ただし、契約アサーションは関数の型の一部ではないため、契約付きの関数のアドレスを通常の関数ポインタに代入できる。
+
+```cpp
+int f(int x) post(r: r != 0);
+int (*fp)(int) = f;  // OK
+```
+
+関数ポインタを通して関数を呼び出す場合でも、その関数の契約アサーションは通常通り評価される必要がある。
+
+#### 関数型エイリアス
+関数型エイリアスに契約指定子を適用することはできない。
+
+```cpp
+using ft = int(int) post(r: r != 0);  // エラー
+```
+
+ただし、関数型エイリアスを使用する関数宣言には契約指定子を適用できる。
+
+```cpp
+using ft = int(int);
+ft f post(r: r != 0);  // OK
+```
+
+#### C言語の可変長引数パラメータの使用
+契約述語内で`va_start`マクロを使用すると、プログラムは不適格となる（診断不要）。
+
+### 意味論
+
+#### 名前探索とアクセス制御
+関数契約アサーションの述語に対する名前探索とアクセス制御のルールは、その関数の宣言の他の部分と同様に適用される。
+
+- 非静的メンバ関数の宣言の一部として、`this`式が使用可能であり、関数の暗黙のオブジェクトパラメータを参照する。
+- メンバ関数の場合、述語はprivateメンバにアクセスできる。
+- 事後条件アサーションは結果バインディング（result binding）という新しい宣言をそのスコープに導入し、この名前は外側のスコープの他の名前を隠す。
+
+```cpp
+struct Y {
+    int i;
+public:
+    void f() pre(i == 0);                    // OK
+    friend void g(Y* y) pre(y-&amp;gt;i == 0);      // OK
+};
+
+int r = 10;
+int h() post(r : r != ::r);  // OK: 結果バインディングのrは外側のrを隠す
+```
+
+#### 暗黙のconst性
+契約チェックは、プログラムの状態を変更するのではなく観察するものである。これを促進するために、契約述語内で参照される変数には暗黙的に`const`修飾が適用される。
+
+```cpp
+void f(int x) {
+    contract_assert(++x &amp;gt; 0);  // エラー: xは暗黙的にconstとして扱われる
+}
+```
+
+ただし、述語内で呼び出される関数は`constexpr`である必要はない。ロギングなどのデバッグ目的で副作用を持つ関数を呼び出すことは許可されるが、プログラムの正当性に影響を与える破壊的な副作用は避けるべきである。
+
+#### 結果バインディング
+事後条件の結果バインディングは、関数の戻り値オブジェクトを参照する。結果バインディングによって導入される変数は、定数（`const`）な左辺値参照である。
+
+```cpp
+int f(int i)
+    post(result: result &amp;gt;= i);  // resultは戻り値への定数参照
+```
+
+結果バインディングには、`[[maybe_unused]]`などの属性を適用できる。
+
+```cpp
+int g()
+    post(r [[maybe_unused]]: true);  // OK
+```
+
+#### 事後条件における関数パラメータ
+事後条件アサーションの述語内で関数パラメータを使用できる。ただし、配列パラメータをODR使用（One Definition Rule use）することは不適格である。
+
+```cpp
+int sum(int arr[], int n)
+    post(r: r &amp;gt;= 0);  // OK: 配列パラメータを使用していない
+
+int process(int arr[], int n)
+    post(r: arr[0] &amp;gt; 0);  // エラー: 配列パラメータをODR使用
+```
+
 ### 評価の順番
-契約式の評価順序に注意が必要である。
+契約アサーションの評価順序は以下の通りである。
+
+#### 評価のタイミング
+- **事前条件アサーション**: 関数パラメータの初期化後、関数本体の評価開始前に評価される。
+- **事後条件アサーション**: 戻り値の初期化後、return文によって抜けるスコープのローカル変数の破棄後、ただし**関数パラメータの破棄前**に評価される。
+- **アサーション文**: 制御フローがその文に到達した時点で実行される。
+
+コンストラクタとデストラクタでの評価タイミングの詳細については、「コンストラクタとデストラクタの制約」および「レジスタで渡される・返されるオブジェクト」を参照のこと。
 
-事前条件は関数の引数が初期化された後に評価され、事後条件は関数の戻り値が初期化された後、ローカル変数の破棄前に評価される。この順序により、契約式は必要な変数や状態にアクセスできるようになっている。
+#### 複数の契約指定子の評価順序
+関数契約アサーションのシーケンス内に複数の事前条件または事後条件アサーションがある場合、それらは宣言された順序で評価される。
+
+```cpp
+void f()
+    pre(a())
+    pre(b())
+    post(c())
+    post(d())
+{
+    // 事前条件の評価順: a(), b()
+    // 事後条件の評価順: c(), d()
+}
+```
+
+#### 戻り値のコピーとシーケンス
+関数の戻り値の型がレジスタで渡される資格がある場合、コンパイラは戻り値オブジェクトの追加のトリビアルなコピーを作成することが許可されており、事後条件アサーションはそれらのコピーを参照する可能性がある。ただし、これらのコピーは事後条件アサーションの評価と順序付けられて行われなければならない。
+
+したがって、すべての契約アサーションがチェックセマンティクスで正確に1回評価されるようにプログラムがビルドされている場合、以下の例では、`r`が同じオブジェクトを参照するかどうかに関わらず、両方の事後条件アサーションはtrueと評価されなければならない。
+
+```cpp
+int f()
+    post(r: ++const_cast&amp;lt;int&amp;amp;&amp;gt;(r) == 1)
+    post(r: ++const_cast&amp;lt;int&amp;amp;&amp;gt;(r) == 2)
+{
+    return 0;
+}
+```
+
+#### 述語の評価
+契約アサーションの述語式が評価されるとき、それは`bool`に文脈的に変換される。述語式は完全式（full expression）であるため、述語の評価中に作成された一時オブジェクトは、その評価が完了したときに破棄される。
 
 ### 契約の評価モード
-契約の評価には、次の4つのモードが存在する。
+各契約アサーションの個別の評価は、特定の評価セマンティクスで実行される。提案されている4つの評価セマンティクスは以下の通りである。
 
-- ignore: 契約のチェックを無視(ignore)する。
+#### ignore（無視）
+`ignore`セマンティクスは何も行わない。契約述語は評価されず、副作用も発生しない。これは非チェックセマンティクスである。
 
-- observe: 契約違反時にハンドラを呼び出し、プログラムの実行を続行する。
+#### observe（観察）
+`observe`セマンティクスは述語を評価して契約違反を識別する。契約違反が発生した場合、契約違反ハンドラを呼び出す。ハンドラが正常に戻ると、プログラムの実行は続行される。これはチェックセマンティクスである。
 
-- enforce: 契約違反時にハンドラを呼び出し、プログラムを終了する。
+#### enforce（強制）
+`enforce`セマンティクスは述語を評価して契約違反を識別する。契約違反が発生した場合、契約違反ハンドラを呼び出す。ハンドラが正常に戻ると、プログラムは実装定義の方法で終了する（通常は`std::terminate()`を呼び出すか、類似の方法）。これはチェックセマンティクスであり、終了セマンティクスでもある。
 
-- quick_enforce: 契約違反時にハンドラを呼び出さず、即座にプログラムを終了する。
+#### quick-enforce（高速強制）
+`quick-enforce`セマンティクスは述語を評価して契約違反を識別する。契約違反が発生した場合、契約違反ハンドラを呼び出さずに、即座にプログラムを実装定義の方法で終了する。これはチェックセマンティクスであり、終了セマンティクスでもある。`quick-enforce`は、契約違反ハンドラのオーバーヘッドを避けるため、パフォーマンスが重要な状況で有用である。
 
-評価モードは、コンパイル時、もしくは実行時に指定できる。
+#### 評価セマンティクスの選択
+契約アサーションの個別の評価に対してどの評価セマンティクスが使用されるかを選択するメカニズムは実装定義である。コンパイル時オプション、実行時設定、またはその組み合わせで指定できる。
 
-GCCでは、
+GCCでの例：
 ```bash
 g++ -std=c++26 -fcontracts -fcontract-semantic=observe main.cpp
 ```
-のように指定できる。
+
+#### 契約述語のチェック
+チェックセマンティクス（`observe`、`enforce`、`quick-enforce`）では、述語が評価され、`bool`に文脈変換される。述語が`true`に評価されると、契約違反は識別されない。述語が`false`に評価されるか、述語の評価が例外で終了すると、契約違反が識別される。
+
+述語の評価がスタックを通じて制御を返さない他の結果（終了、無限ループ、`longjmp`の呼び出しなど）が発生した場合、他のC++式の評価時と同様に処理される。
+
+#### 省略、重複、順次評価
+実装は、契約アサーションの評価を省略、重複、または特定の順序で実行できる。ただし、副作用が正常に戻る場合にのみ省略できる。この柔軟性により、実装は最適化の機会を持つ。
+
+#### 述語の副作用
+契約述語に副作用があることは推奨されないが、完全に禁止されているわけではない。述語に破壊的な副作用（プログラムの正当性に影響を与える副作用）がある場合、その動作は設計原則に違反する。ただし、ロギングやデバッグ目的の非破壊的な副作用は許可される。
+
+#### 観察可能なチェックポイント
+契約アサーションの評価は、観察可能なチェックポイントである。これは、コンパイラが契約アサーションの評価の前後でメモリアクセスの並べ替えを行わないことを意味する。
+
+#### コルーチンのサポート
+コルーチンには契約指定子を適用できる。事前条件アサーションはコルーチンの引数が初期化された後に評価され、事後条件アサーションはコルーチンが`co_return`で終了したときに評価される。
+
+#### 定数評価
+契約アサーションは定数評価中にも評価できる。定数評価中、契約違反ハンドラは呼び出されない。代わりに、チェックセマンティクスで契約違反が識別されると、定数評価は失敗する。
 
 ### 契約違反ハンドラ
-契約違反が発生した場合、`std::contracts::contract_violation`型の情報（&amp;amp;lt;contracts&amp;amp;gt;ヘッダー）がハンドラに渡される。この情報には、違反の種類、発生場所、違反した条件式などが含まれる。
+
+#### ハンドラの定義
+契約違反ハンドラは、ユーザーがリンク時にカスタム定義できる関数である。ハンドラの署名は以下の通り：
+
+```cpp
+void handle_contract_violation(const std::contracts::contract_violation&amp;amp; violation);
+```
+
+この関数を定義することで、デフォルトの契約違反ハンドラをオーバーライドできる。
+
+#### contract_violation情報
+`std::contracts::contract_violation`オブジェクトは、契約違反に関する以下の情報を提供する：
+
+- **違反の種類** (`assertion_kind`): 事前条件、事後条件、またはアサーション文のいずれか
+- **評価セマンティクス** (`evaluation_semantic`): 違反を識別した評価セマンティクス
+- **検出モード** (`detection_mode`): 契約違反がどのように検出されたか（述語が`false`に評価されたか、例外が発生したか）
+- **ソースロケーション** (`location`): 違反した契約アサーションのソースファイル名、行番号、関数名
+- **終了判定** (`is_terminating`): この違反後にプログラムが終了するかどうか
+- **評価例外** (`evaluation_exception`): 述語の評価中に例外が発生した場合、その例外オブジェクトへのアクセス
+
+#### ハンドラの動作
+契約違反が識別されると、`observe`または`enforce`セマンティクスの場合、契約違反ハンドラが呼び出される：
+
+1. **observeセマンティクス**: ハンドラが正常に戻ると、プログラムの実行は続行される。
+2. **enforceセマンティクス**: ハンドラが正常に戻ると、プログラムは実装定義の方法で終了する。
+3. **quick-enforceセマンティクス**: ハンドラは呼び出されず、即座にプログラムが終了する。
+
+#### デフォルトハンドラ
+ユーザーがカスタムハンドラを定義しない場合、実装が提供するデフォルトハンドラが使用される。デフォルトハンドラは、標準エラー出力に診断メッセージを出力することが期待される。
+
+#### ハンドラ内での契約違反
+契約違反ハンドラの実行中に別の契約違反が発生した場合（再帰的契約違反）、動作は実装定義である。通常は、無限再帰を避けるために即座にプログラムを終了する。
+
+#### 例外を投げるハンドラ
+契約違反ハンドラから例外を投げることは許可されているが、推奨されない。ハンドラが例外で終了した場合、`std::terminate()`が呼び出される。
+
+### 標準ライブラリAPI
+
+#### &amp;amp;lt;contracts&amp;amp;gt;ヘッダー
+C++26では、契約プログラミングをサポートするために`&amp;lt;contracts&amp;gt;`ヘッダーが導入される。このヘッダーには以下の型と関数が含まれる。
+
+#### 列挙型
+
+##### assertion_kind
+契約アサーションの種類を表す列挙型：
+
+```cpp
+namespace std::contracts {
+    enum class assertion_kind {
+        precondition,   // 事前条件アサーション
+        postcondition,  // 事後条件アサーション
+        assertion       // アサーション文
+    };
+}
+```
+
+##### evaluation_semantic
+契約アサーションの評価セマンティクスを表す列挙型：
+
+```cpp
+namespace std::contracts {
+    enum class evaluation_semantic {
+        ignore,         // 無視
+        observe,        // 観察
+        enforce,        // 強制
+        quick_enforce   // 高速強制
+    };
+}
+```
+
+##### detection_mode
+契約違反がどのように検出されたかを表す列挙型：
+
+```cpp
+namespace std::contracts {
+    enum class detection_mode {
+        predicate_false,     // 述語がfalseに評価された
+        evaluation_exception // 述語の評価中に例外が発生
+    };
+}
+```
+
+#### contract_violationクラス
+契約違反に関する情報を提供するクラス：
+
+```cpp
+namespace std::contracts {
+    class contract_violation {
+    public:
+        assertion_kind kind() const noexcept;
+        evaluation_semantic semantic() const noexcept;
+        detection_mode detection() const noexcept;
+        source_location location() const noexcept;
+        string_view comment() const noexcept;
+        bool is_terminating() const noexcept;
+        exception_ptr evaluation_exception() const noexcept;
+    };
+}
+```
+
+主なメンバ関数：
+- `kind()`: 違反した契約アサーションの種類を返す
+- `semantic()`: 使用された評価セマンティクスを返す
+- `detection()`: 違反の検出方法を返す
+- `location()`: 契約アサーションのソースロケーションを返す
+- `comment()`: ベンダー固有のコメント文字列を返す
+- `is_terminating()`: 違反後にプログラムが終了するかどうかを返す
+- `evaluation_exception()`: 述語の評価中に例外が発生した場合、その例外への`exception_ptr`を返す
+
+#### invoke_default_contract_violation_handler関数
+デフォルトの契約違反ハンドラを明示的に呼び出すための関数：
+
+```cpp
+namespace std::contracts {
+    void invoke_default_contract_violation_handler(
+        const contract_violation&amp;amp; violation);
+}
+```
+
+この関数は、カスタムハンドラ内でデフォルトの動作を呼び出したい場合に有用である。
 
 ### 使用上の注意
-以下の操作は、気をつけなければならない。
-- 契約式内において副作用を要する式を記述した場合(グローバル変数の変更、`volatile`変数への参照、`constexpr`でない関数の呼び出しなど)
-- 契約式内で例外を送出すると、std::terminate()が呼び出され、プログラムが終了する。
-- 通常の関数やメンバ関数には契約を適用できるが、特殊な関数(例えば`default`によって定義されたコピーコンストラクタやデストラクタ)には適用できない。適用すると、プログラムは不適格(ill-formed)となる。
+以下の操作には注意が必要である。
+
+#### 副作用
+契約述語内で副作用を持つ式を記述することは可能だが、推奨されない。破壊的な副作用（グローバル変数の変更、`volatile`変数への参照など）は避けるべきである。ただし、ロギングなどの非破壊的な副作用は許可される。
+
+```cpp
+// 推奨されない例
+int global_counter = 0;
+void f(int x) pre(++global_counter &amp;gt; 0);  // 副作用あり
+
+// 許容される例（デバッグ目的）
+void g(int x) pre(log_value(x), x &amp;gt; 0);  // ロギングは許容
+```
+
+#### 例外
+契約述語内で例外が送出されると、契約違反として扱われる。`observe`または`enforce`セマンティクスの場合、契約違反ハンドラが呼び出され、その後の動作はセマンティクスに依存する。
+
+```cpp
+bool might_throw(int x);
+
+void f(int x) pre(might_throw(x));  // 例外発生時は契約違反
+```
+
+#### 特殊メンバ関数
+`= default`または`= delete`で定義された特殊メンバ関数に契約指定子を適用すると、プログラムは不適格となる。通常のコンストラクタ、デストラクタ、およびメンバ関数には契約を適用できる。
+
+#### assert マクロとの違い
+契約プログラミング機能と従来の`assert`マクロには以下の違いがある：
+
+- **キーワード vs マクロ**: `contract_assert`はキーワードであり、`assert`はマクロである
+- **評価制御**: 契約の評価セマンティクスは実装定義の方法で選択されるが、`assert`は`NDEBUG`マクロの有無で制御される
+- **事後条件**: 契約プログラミングは事後条件を簡潔に記述できるが、`assert`マクロでは困難
+- **標準化**: 契約プログラミングはC++標準の一部であり、`assert`はCから継承されたマクロである
+
+## 例
+
+### 基本的な使用例
+
+```cpp example
+#include &amp;lt;contracts&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+// 事前条件と事後条件を持つ関数
+int safe_division(int numerator, int denominator)
+    pre(denominator != 0)
+    post(result: result * denominator == numerator)
+{
+    return numerator / denominator;
+}
+
+// 複数の契約条件
+class BankAccount {
+    double balance = 0.0;
+
+public:
+    void deposit(double amount)
+        pre(amount &amp;gt; 0)
+        post(balance &amp;gt;= old_balance)  // 注: old値の参照はC++26では未サポート
+    {
+        balance += amount;
+    }
+
+    void withdraw(double amount)
+        pre(amount &amp;gt; 0)
+        pre(amount &amp;lt;= balance)  // 複数の事前条件
+        post(balance &amp;gt;= 0)
+    {
+        contract_assert(balance &amp;gt;= amount);  // アサーション文
+        balance -= amount;
+    }
+
+    double get_balance() const
+        post(result: result &amp;gt;= 0)
+    {
+        return balance;
+    }
+};
+
+// ラムダ式での使用
+auto lambda_with_contract = [](int x)
+    pre(x &amp;gt; 0)
+    post(r: r &amp;gt; x)
+{
+    return x + 1;
+};
+
+int main() {
+    // 正常な使用
+    int result = safe_division(10, 2);  // OK: result = 5
+    std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+
+    BankAccount account;
+    account.deposit(100.0);   // OK
+    account.withdraw(50.0);   // OK
+
+    // 契約違反の例（実行時に検出される）
+    // safe_division(10, 0);  // 事前条件違反
+    // account.withdraw(200.0);  // 事前条件違反
+
+    auto value = lambda_with_contract(5);  // OK: value = 6
+
+    return 0;
+}
+```
+
+### カスタム契約違反ハンドラの例
+
+```cpp example
+#include &amp;lt;contracts&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;cstdlib&amp;gt;
+
+// カスタム契約違反ハンドラの定義
+void handle_contract_violation(const std::contracts::contract_violation&amp;amp; v) {
+    std::cerr &amp;lt;&amp;lt; &amp;#34;契約違反が発生しました:\n&amp;#34;;
+    std::cerr &amp;lt;&amp;lt; &amp;#34;  種類: &amp;#34;;
+    switch (v.kind()) {
+        case std::contracts::assertion_kind::precondition:
+            std::cerr &amp;lt;&amp;lt; &amp;#34;事前条件\n&amp;#34;;
+            break;
+        case std::contracts::assertion_kind::postcondition:
+            std::cerr &amp;lt;&amp;lt; &amp;#34;事後条件\n&amp;#34;;
+            break;
+        case std::contracts::assertion_kind::assertion:
+            std::cerr &amp;lt;&amp;lt; &amp;#34;アサーション\n&amp;#34;;
+            break;
+    }
+
+    std::cerr &amp;lt;&amp;lt; &amp;#34;  場所: &amp;#34; &amp;lt;&amp;lt; v.location().file_name()
+              &amp;lt;&amp;lt; &amp;#34;:&amp;#34; &amp;lt;&amp;lt; v.location().line() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+    std::cerr &amp;lt;&amp;lt; &amp;#34;  関数: &amp;#34; &amp;lt;&amp;lt; v.location().function_name() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+
+    if (v.is_terminating()) {
+        std::cerr &amp;lt;&amp;lt; &amp;#34;プログラムを終了します。\n&amp;#34;;
+    }
+
+    // デフォルトハンドラも呼び出す
+    std::contracts::invoke_default_contract_violation_handler(v);
+}
+
+int process(int x)
+    pre(x &amp;gt; 0)
+    post(r: r &amp;gt; x)
+{
+    return x + 1;
+}
+
+int main() {
+    // 契約違反が発生すると、カスタムハンドラが呼び出される
+    // process(-1);  // 事前条件違反
+
+    return 0;
+}
+```
+
+### テンプレート関数での使用例
+
+```cpp example
+#include &amp;lt;contracts&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+template&amp;lt;std::integral T&amp;gt;
+T increment(T value)
+    pre(value &amp;lt; std::numeric_limits&amp;lt;T&amp;gt;::max())
+    post(result: result == value + 1)
+{
+    return value + 1;
+}
+
+template&amp;lt;typename T&amp;gt;
+class Stack {
+    std::vector&amp;lt;T&amp;gt; data;
+
+public:
+    void push(const T&amp;amp; item)
+        post(size() == old_size + 1)  // 注: old値の参照はC++26では未サポート
+    {
+        data.push_back(item);
+    }
+
+    T pop()
+        pre(!empty())
+        post(size() == old_size - 1)  // 注: old値の参照はC++26では未サポート
+    {
+        T value = data.back();
+        data.pop_back();
+        return value;
+    }
+
+    bool empty() const
+        post(result: result == (size() == 0))
+    {
+        return data.empty();
+    }
+
+    std::size_t size() const
+        post(result: result &amp;lt;= data.capacity())
+    {
+        return data.size();
+    }
+};
+
+int main() {
+    auto value = increment(42);  // OK
+
+    Stack&amp;lt;int&amp;gt; stack;
+    stack.push(10);
+    stack.push(20);
+    int top = stack.pop();  // OK: top = 20
+
+    return 0;
+}
+```
 
 ## &amp;lt;a id=&amp;#34;relative-page&amp;#34; href=&amp;#34;#relative-page&amp;#34;&amp;gt;関連項目&amp;lt;/a&amp;gt;
 - [C++ 将来 契約に基づくプログラミング](/lang/future/contract-based_programming.md)
+- [`&amp;lt;contracts&amp;gt;`ヘッダー](/reference/contracts.md)
+- [`std::contracts::contract_violation`](/reference/contracts/contract_violation.md)
+- [`std::contracts::assertion_kind`](/reference/contracts/assertion_kind.md)
+- [`std::contracts::evaluation_semantic`](/reference/contracts/evaluation_semantic.md)
+- [`std::contracts::detection_mode`](/reference/contracts/detection_mode.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>rotarymars</name>
        <email>s.goto2050@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>invocable -- regular_invocable: 意味論要件について追加と調整</title>
      <link href="https://cpprefjp.github.io/reference/concepts/invocable.html"/>
      <id>baadf1ba8cbbf82fc7ece96596d119e0949b6b96:reference/concepts/invocable.md</id>
      <updated>2025-12-21T19:10:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/invocable.md b/reference/concepts/invocable.md
index a19bbae04..7fa1ed181 100644
--- a/reference/concepts/invocable.md
+++ b/reference/concepts/invocable.md
@@ -21,11 +21,13 @@ namespace std {
 
 `invocable`及び`regular_invocable`は、任意の関数呼び出し可能な型`F`が引数`Args...`によって関数呼び出し可能であることを表すコンセプトである。
 
+加えて、`regular_invocable`はその呼び出しが等しさを保持し、なおかつ関数オブジェクト（`F`のオブジェクト）も引数（`Args`オブジェクト）も変更しないものである必要がある。
+
 ## 等しさの保持
 
 `invocable`コンセプトでは`F`の`Args...`による関数呼び出しが[等しさを保持](/reference/concepts.md)することを要求しない。従って、`invocable`コンセプトのモデルとなる型`F, Args...`は関数呼び出しに際して副作用があっても良く、その出力が内部状態や外部状態に依存していても構わない。
 
-対して、`regular_invocable`コンセプトのモデルとなる`F`の`Args...`による関数呼び出しには[等しさを保持](/reference/concepts.md)することが要求される。従って、`regular_invocable`コンセプトのモデルとなる型`F, Args...`は関数呼び出しに際して副作用を持ってはならず、出力は何かしらの状態に依存してはならない。ただし、このことは構文的に（コンパイル時に）チェックされるものではなく、純粋に意味論的な制約として要求・表明される。
+対して、`regular_invocable`コンセプトのモデルとなる`F`の`Args...`による関数呼び出しには[等しさを保持](/reference/concepts.md)することと引数を変更しないことが要求される。従って、`regular_invocable`コンセプトのモデルとなる型`F, Args...`は関数呼び出しに際して副作用を持ってはならず、出力は何かしらの状態に依存してはならない。ただし、このことは構文的に（コンパイル時に）チェックされるものではなく、純粋に意味論的な制約として要求・表明される。
 
 例えば、[乱数・分布生成器](/reference/random.md)はその呼び出しに際して等しさを保持しない（内部に状態を保ち、出力はそれに依存する）ため、`regular_invocable`コンセプトのモデルにはならないが`invocable`コンセプトのモデルとなる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>契約プログラミング [P2900R14] -- reference / lang : ですます調を、である調に修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/contracts.html"/>
      <id>7a709f016fb9836e7641d73efa2d651fe5b84c1b:lang/cpp26/contracts.md</id>
      <updated>2025-12-12T12:39:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/contracts.md b/lang/cpp26/contracts.md
index e2e57725f..05c1613ff 100644
--- a/lang/cpp26/contracts.md
+++ b/lang/cpp26/contracts.md
@@ -131,11 +131,11 @@ void return_negative(int value)
 
 - ignore: 契約のチェックを無視(ignore)する。
 
-- observe: 契約違反時にハンドラを呼び出し、プログラムの実行を続行します。
+- observe: 契約違反時にハンドラを呼び出し、プログラムの実行を続行する。
 
-- enforce: 契約違反時にハンドラを呼び出し、プログラムを終了します。
+- enforce: 契約違反時にハンドラを呼び出し、プログラムを終了する。
 
-- quick_enforce: 契約違反時にハンドラを呼び出さず、即座にプログラムを終了します。
+- quick_enforce: 契約違反時にハンドラを呼び出さず、即座にプログラムを終了する。
 
 評価モードは、コンパイル時、もしくは実行時に指定できる。
 
@@ -146,7 +146,7 @@ g++ -std=c++26 -fcontracts -fcontract-semantic=observe main.cpp
 のように指定できる。
 
 ### 契約違反ハンドラ
-契約違反が発生した場合、`std::contracts::contract_violation`型の情報（&amp;amp;lt;contracts&amp;amp;gt;ヘッダー）がハンドラに渡されます。この情報には、違反の種類、発生場所、違反した条件式などが含まれます。
+契約違反が発生した場合、`std::contracts::contract_violation`型の情報（&amp;amp;lt;contracts&amp;amp;gt;ヘッダー）がハンドラに渡される。この情報には、違反の種類、発生場所、違反した条件式などが含まれる。
 
 ### 使用上の注意
 以下の操作は、気をつけなければならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>int_fast16_t -- reference / lang : ですます調を、である調に修正</title>
      <link href="https://cpprefjp.github.io/reference/cstdint/int_fast16_t.html"/>
      <id>7a709f016fb9836e7641d73efa2d651fe5b84c1b:reference/cstdint/int_fast16_t.md</id>
      <updated>2025-12-12T12:39:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdint/int_fast16_t.md b/reference/cstdint/int_fast16_t.md
index ca7bcb465..9b45bff47 100644
--- a/reference/cstdint/int_fast16_t.md
+++ b/reference/cstdint/int_fast16_t.md
@@ -63,7 +63,7 @@ int_fast16_t is the same as int16_t: 0
 30000 + 10000 = -25536
 ```
 
-この出力例は特定の環境に依存しており、処理系によって異なる可能性があります。特に、`int_fast16_t`のサイズやオーバーフロー動作は処理系によって異なることがある。
+この出力例は特定の環境に依存しており、処理系によって異なる可能性がある。特に、`int_fast16_t`のサイズやオーバーフロー動作は処理系によって異なることがある。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>int_fast32_t -- reference / lang : ですます調を、である調に修正</title>
      <link href="https://cpprefjp.github.io/reference/cstdint/int_fast32_t.html"/>
      <id>7a709f016fb9836e7641d73efa2d651fe5b84c1b:reference/cstdint/int_fast32_t.md</id>
      <updated>2025-12-12T12:39:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdint/int_fast32_t.md b/reference/cstdint/int_fast32_t.md
index d8893f688..bd7dd68df 100644
--- a/reference/cstdint/int_fast32_t.md
+++ b/reference/cstdint/int_fast32_t.md
@@ -63,7 +63,7 @@ int_fast32_t is the same as int32_t: 0
 2000000000 + 1000000000 = -1294967296
 ```
 
-この出力例は特定の環境に依存しており、処理系によって異なる可能性があります。特に、`int_fast32_t`のサイズやオーバーフロー動作は処理系によって異なることがある。
+この出力例は特定の環境に依存しており、処理系によって異なる可能性がある。特に、`int_fast32_t`のサイズやオーバーフロー動作は処理系によって異なることがある。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>int_fast8_t -- reference / lang : ですます調を、である調に修正</title>
      <link href="https://cpprefjp.github.io/reference/cstdint/int_fast8_t.html"/>
      <id>7a709f016fb9836e7641d73efa2d651fe5b84c1b:reference/cstdint/int_fast8_t.md</id>
      <updated>2025-12-12T12:39:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdint/int_fast8_t.md b/reference/cstdint/int_fast8_t.md
index 2ef6ea588..027c08a4b 100644
--- a/reference/cstdint/int_fast8_t.md
+++ b/reference/cstdint/int_fast8_t.md
@@ -63,7 +63,7 @@ int_fast8_t is the same as int8_t: 0
 100 + 50 = -106
 ```
 
-この出力例は特定の環境に依存しており、処理系によって異なる可能性があります。特に、`int_fast8_t`のサイズやオーバーフロー動作は処理系によって異なることがある。
+この出力例は特定の環境に依存しており、処理系によって異なる可能性がある。特に、`int_fast8_t`のサイズやオーバーフロー動作は処理系によって異なることがある。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>expected.void -- reference / lang : ですます調を、である調に修正</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected.void.html"/>
      <id>7a709f016fb9836e7641d73efa2d651fe5b84c1b:reference/expected/expected.void.md</id>
      <updated>2025-12-12T12:39:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected.void.md b/reference/expected/expected.void.md
index 0081c5728..b6c0a7e26 100644
--- a/reference/expected/expected.void.md
+++ b/reference/expected/expected.void.md
@@ -19,6 +19,6 @@ namespace std {
 * expected[link expected.md]
 * is_void_v[link /reference/type_traits/is_void.md]
 
-このページは`expected&amp;lt;cv void, E&amp;gt;`部分特殊化テンプレートに対応するプレースホルダです。
+このページは`expected&amp;lt;cv void, E&amp;gt;`部分特殊化テンプレートに対応するプレースホルダである。
 
-`expected`クラスの説明は[`expected&amp;lt;T, E&amp;gt;`プライマリテンプレート](expected.md)ページを参照してください。
+`expected`クラスの説明は[`expected&amp;lt;T, E&amp;gt;`プライマリテンプレート](expected.md)ページを参照のこと。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>thread -- reference / lang : ですます調を、である調に修正</title>
      <link href="https://cpprefjp.github.io/reference/thread.html"/>
      <id>7a709f016fb9836e7641d73efa2d651fe5b84c1b:reference/thread.md</id>
      <updated>2025-12-12T12:39:35+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;thread&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;thread&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;thread&amp;gt;&lt;/code&gt;ヘッダはマルチスレッド制御に関するクラス・関数を定義する。&lt;/p&gt;
&lt;p&gt;このヘッダでは、以下の標準ヘッダをインクルードする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt; (C++20)&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;thread/thread.html&#34;&gt;thread&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スレッド クラス(class)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;thread/thread/id.html&#34;&gt;thread::id&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スレッド識別子 クラス(class)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;thread/this_thread.html&#34;&gt;this_thread&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;現スレッドの制御機能を提供する名前空間 (namespace)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;thread/jthread.html&#34;&gt;jthread&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;停止要求を扱ったり、自動で&lt;code&gt;&lt;a href=&#34;thread/jthread/join.html&#34;&gt;join&lt;/a&gt;&lt;/code&gt;する機能を持つスレッド クラス (class)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: 4.6.3 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;, 4.7.0 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;
     GCC／pthread環境でスレッドサポートを有効化するには -pthread オプション指定が必要。（GCC 4.7.0で確認）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: 2012 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;, 2013 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;, 2015 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.decadent.org.uk/pipermail/cpp-threads/&#34; target=&#34;_blank&#34;&gt;The cpp-threads Archives&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++11の策定時に、C++標準の言語とライブラリに並行プログラミングの提案を行うため使用されていたメーリングリストのアーカイブである。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2051r0.html&#34; target=&#34;_blank&#34;&gt;P2051R0 C++ Standard Library Issues to be moved in Prague&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>int_fast64_t -- 口調の修正</title>
      <link href="https://cpprefjp.github.io/reference/cstdint/int_fast64_t.html"/>
      <id>57412ffbc6cf3346315154241a95c33606d6a96e:reference/cstdint/int_fast64_t.md</id>
      <updated>2025-12-10T23:07:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdint/int_fast64_t.md b/reference/cstdint/int_fast64_t.md
index de6d1bee6..ad7f943f8 100644
--- a/reference/cstdint/int_fast64_t.md
+++ b/reference/cstdint/int_fast64_t.md
@@ -63,7 +63,7 @@ int_fast64_t is the same as int64_t: 0
 9000000000000000000 + 1000000000000000000 = -8446744073709551616
 ```
 
-この出力例は特定の環境に依存しており、処理系によって異なる可能性があります。特に、`int_fast64_t`のサイズやオーバーフロー動作は処理系によって異なることがある。
+この出力例は特定の環境に依存しており、処理系によって異なる可能性がある。特に、`int_fast64_t`のサイズやオーバーフロー動作は処理系によって異なることがある。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>K10-K10</name>
        <email>keito.tottori@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++20 -- add link in cpp20.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20.html"/>
      <id>a95fb44c81e1311b80e1eeeed9ef110743bbfca8:lang/cpp20.md</id>
      <updated>2025-12-07T12:50:53+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++20&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20とは、2020年中に改訂され、ISO/IEC 14882:2020で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++2aと呼ばれることがあった。「202a年にリリースされる」という伏せ字として「a」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;クラス&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/consistent_comparison.html&#34;&gt;&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;/&lt;code&gt;==&lt;/code&gt;による比較演算子の自動定義&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;三方比較演算子によって比較演算子の自動生成を行うようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/default_member_initializers_for_bit_fields.html&#34;&gt;ビットフィールドのメンバ変数初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ビットフィールドメンバ変数のデフォルト値を設定する構文を追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/explicit_bool.html&#34;&gt;関数を条件付きで&lt;code&gt;explicit&lt;/code&gt;にする構文を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;explicit(true)&lt;/code&gt;のように&lt;code&gt;explicit&lt;/code&gt;に真理値パラメータを指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/fixing_const_qualified_pointers_to_members.html&#34;&gt;&lt;code&gt;const&lt;/code&gt;修飾されたメンバポインタの制限を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.*&lt;/code&gt;演算子での左辺値の&lt;code&gt;const&lt;/code&gt;メンバ関数呼び出しを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/resolving_const_mismatch_with_defaulted_copy_constructor.html&#34;&gt;デフォルトのコピーコンストラクタと非&lt;code&gt;const&lt;/code&gt;なコンストラクタが衝突する問題を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非&lt;code&gt;const&lt;/code&gt;なオブジェクトをとるコンストラクタを定義すると、そのクラスをラップしたクラスのコピーコンストラクタが&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;になってしまう問題を修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/access_checking_on_specializations.html&#34;&gt;特殊化のアクセスチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/language_support_for_empty_objects.html&#34;&gt;空オブジェクトに対する最適化を支援する属性&lt;code&gt;[[no_unique_address]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[no_unique_address]]&lt;/code&gt;属性を導入し、空の型のオブジェクトをほかのオブジェクトと共有する最適化を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/allow_structured_bindings_to_accessible_members.html&#34;&gt;friend指定された関数内から構造化束縛を使用して非公開メンバ変数にアクセスすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛の仕様として公開メンバ変数のみを取り出せるようになっていたが、friend指定された関数からは非公開メンバ変数にもアクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/relaxing_the_structured_bindings_customization_point_finding_rules.html&#34;&gt;構造化束縛がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非テンプレートの&lt;code&gt;get()&lt;/code&gt;メンバ関数が見つかった場合は、非メンバ関数の&lt;code&gt;get()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/checking_for_abstract_class_types.html&#34;&gt;抽象型のチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の宣言段階では、パラメータおよび戻り値型が抽象型かどうかをチェックしないようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/efficient_sized_delete_for_variable_sized_classes.html&#34;&gt;可変長データを扱うクラスの効率的な&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラスの&lt;code&gt;delete&lt;/code&gt;演算子が呼び出される前にデストラクタが呼ばれないようにするオプションを追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/conditionally_trivial_special_member_functions.html&#34;&gt;条件付きで特殊メンバ関数をトリビアルに定義するように&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;制約によってトリビアルな特殊メンバ関数と非トリビアルな特殊メンバ関数をオーバーロードできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html&#34;&gt;未初期化領域への暗黙的なオブジェクト構築&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;未初期化領域の利用時に自動的にトリビアルな型のオブジェクトを構築する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;列挙型&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/using_enum.html&#34;&gt;スコープ付き列挙型のusing宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;using enum EnumType;&lt;/code&gt;もしくは&lt;code&gt;using EnumType::enumerator&lt;/code&gt;とすることで、列挙値のスコープ指定を省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/designated_initialization.html&#34;&gt;指示付き初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波カッコによる集成体初期化でメンバ名を指定して初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/extending_structured_bindings_to_be_more_like_variable_declarations.html&#34;&gt;構造化束縛を拡張して通常の変数宣言のように使用できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;記憶域指定子として&lt;code&gt;static&lt;/code&gt;と&lt;code&gt;thread_local&lt;/code&gt;の指定を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html&#34;&gt;丸カッコの値リストからの集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T x{1, 2, 3};&lt;/code&gt;と同様に&lt;code&gt;T x(1, 2, 3);&lt;/code&gt;でも集成体初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/array_size_deduction_in_new-expressions.html&#34;&gt;&lt;code&gt;new&lt;/code&gt;式での配列要素数の推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double* p = new double[]{1,2,3};&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/permit_conversions_to_arrays_of_unknown_bound.html&#34;&gt;要素数不明の配列への変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;要素数が判明している配列から、要素数が不明の配列への変換を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.html&#34;&gt;ポインタから&lt;code&gt;bool&lt;/code&gt;への変換を縮小変換とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ポインタから&lt;code&gt;bool&lt;/code&gt;値への変換を縮小変換と規定することで、意図しない変換を防止する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;整数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/signed_integers_are_twos_complement.html&#34;&gt;符号付き整数型が2の補数表現であることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;符号付き整数型のビット表現を2の補数に規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/char8_t.html&#34;&gt;UTF-8エンコーディングされた文字の型として&lt;code&gt;char8_t&lt;/code&gt;を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-8エンコードされた文字かどうかでオーバーロード・特殊化をできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/make_char16t_char32t_string_literals_be_utf16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;の文字・文字列リテラルを、文字コードUTF-16/32に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__STDC_UTF_16__&lt;/code&gt;、&lt;code&gt;__STDC_UTF_32__&lt;/code&gt;の定義に関係なく、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のリテラルをUTF-16/32文字コードに規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/nodiscard_should_have_a_reason.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性に理由となる文字列を付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値を無視してはならない理由を関数宣言に持たせ、警告メッセージに役立てる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/nodiscard_for_constructors.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;をコンストラクタのオーバーロードごとに付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リソース確保するコンストラクタにのみ&lt;code&gt;[[nodisacrd]]&lt;/code&gt;を付加できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;制御構文&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/range-based_for_statements_with_initializer.html&#34;&gt;初期化式をともなう範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;範囲for文スコープで使用する変数の初期化のための構文を追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.html&#34;&gt;範囲for文がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;メンバ関数のどちらかが見つからなかった場合に非メンバ関数の&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/likely_and_unlikely_attributes.html&#34;&gt;確率が高い分岐と低い分岐を伝える属性 &lt;code&gt;[[likely]]&lt;/code&gt;, &lt;code&gt;[[unlikely]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;条件分岐の最適化ヒントを与える属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/concepts.html&#34;&gt;コンセプト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータに対する制約を行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/function_templates_with_auto_parameters.html&#34;&gt;autoパラメータによる関数テンプレートの簡易定義&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダと同様、関数パラメータの型を&lt;code&gt;auto&lt;/code&gt;にすることで簡易的に関数テンプレートを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/down_with_typename.html&#34;&gt;型の文脈で&lt;code&gt;typename&lt;/code&gt;の省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型しか現れない文脈では、依存名を解決するための&lt;code&gt;typename&lt;/code&gt;キーワードを省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/class_types_in_non-type_template_parameters.html&#34;&gt;非型テンプレートパラメータとしてクラス型を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式として使用できる型を広く非型テンプレートパラメータとして使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/adl_and_function_templates_that_are_not_visible.html&#34;&gt;関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;名前空間内の関数テンプレートをテンプレート引数指定かつ非修飾・ADLで正しく呼び出せるよう修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/class_template_argument_deduction_for_aggregates.html&#34;&gt;集成体クラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートのテンプレート引数推論はコンストラクタ引数から推論されるが、集成体初期化からも推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/class_template_argument_deduction_for_alias_templates.html&#34;&gt;エイリアステンプレート経由でのクラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エイリアステンプレートからクラステンプレートのテンプレート引数を推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/less_eager_instantiation_of_constexpr_functions.html&#34;&gt;評価されない文脈での定数式評価によって特殊メンバ関数がインスタンス化されることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof&lt;/code&gt;や&lt;code&gt;decltype&lt;/code&gt;などの評価されない文脈において定数式評価を行った場合に、ムーブコンストラクタのような特殊メンバ関数が定義されることを規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/allow_virtual_function_calls_in_constant_expressions.html&#34;&gt;定数式からの仮想関数の呼び出しを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;仮想関数に&lt;code&gt;constexpr&lt;/code&gt;を付けられない制限を解除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/allowing_dynamic_cast_polymorphic_typeid_in_constant_expressions.html&#34;&gt;定数式での&lt;code&gt;dynamic_cast&lt;/code&gt;、多態的な&lt;code&gt;typeid&lt;/code&gt;を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式での動的多態を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/try-catch_blocks_in_constexpr_functions.html&#34;&gt;constexpr関数内でのtry-catchブロックを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内で&lt;code&gt;try-catch&lt;/code&gt;ブロックを書けるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/immediate_functions.html&#34;&gt;常に定数式評価する&lt;code&gt;consteval&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;consteval&lt;/code&gt;キーワードを追加し、常に定数式評価されるよう指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/changing_the_active_member_of_a_union_inside_constexpr.html&#34;&gt;定数式内での共用体のアクティブメンバの変更を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体メンバの書き換えを定数式内で行えるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.html&#34;&gt;constexpr関数内でのトリビアルなデフォルト初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内でのデフォルト初期化を許可し、未初期化値を読むことのみ禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.html&#34;&gt;constexpr関数内で未評価のインラインアセンブリを許可することによる組み込み関数のconstexpr有効化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に評価されない場合にconstexpr関数にasm定義を含めることを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/constinit.html&#34;&gt;コンパイル時初期化を強制する&lt;code&gt;constinit&lt;/code&gt;キーワードを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化のみコンパイル時におわらせたい場合に使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/more_constexpr_containers.html&#34;&gt;可変サイズをもつコンテナの&lt;code&gt;constexpr&lt;/code&gt;化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;記憶域をもつメモリアロケータの存在を考慮することで、可変サイズをもつコンテナをコンパイル時に使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ラムダ式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/familiar_template_syntax_for_generic_lambdas.html&#34;&gt;ジェネリックラムダのテンプレート構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダでテンプレートパラメータを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/allow_lambda_capture_equal_this.html&#34;&gt;ラムダ式のキャプチャとして&lt;code&gt;[=, this]&lt;/code&gt;を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトコピーキャプチャと&lt;code&gt;this&lt;/code&gt;ポインタのコピーキャプチャを両方指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/simplifying_implicit_lambda_capture.html&#34;&gt;暗黙のラムダキャプチャを簡略化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式のキャプチャに関する仕様整理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/default_constructible_and_assignable_stateless_lambdas.html&#34;&gt;状態を持たないラムダ式を、デフォルト構築可能、代入可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャしていないラムダ式をデフォルト構築・代入可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/wording_for_lambdas_in_unevaluated_contexts.html&#34;&gt;評価されない文脈でのラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;評価されない文脈でもラムダ式を書くことができるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/allow_pack_expansion_in_lambda_init_capture.html&#34;&gt;ラムダ式の初期化キャプチャでのパック展開を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[...args = std::move(args)]&lt;/code&gt;のようなキャプチャを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/reference_capture_of_structured_bindings.html&#34;&gt;構造化束縛した変数の参照キャプチャを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛をした変数は特殊な扱いのためラムダ式で参照キャプチャできない規定となっていたがこれを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;名前空間&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/nested_inline_mamespaces.html&#34;&gt;入れ子名前空間定義でのインライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;namespace ns1::inline ns2::ns3 {}&lt;/code&gt;のように、入れ子名前空間を定義する式にインライン名前空間の指定を含められるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;モジュール化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/modules.html&#34;&gt;モジュール&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ヘッダファイル・ソースファイル、インクルードに変わる仕組みとしてモジュールを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/coroutines.html&#34;&gt;コルーチン&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数実行を中断・再開する仕組みとしてコルーチンを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;プリプロセッサ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/va_opt.html&#34;&gt;可変引数が空でない場合のトークン置換&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサの置換で可変引数が空の場合に余計なカンマが付いてしまう問題に対処&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/deprecating_volatile.html&#34;&gt;ほとんどの&lt;code&gt;volatile&lt;/code&gt;を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;volatile&lt;/code&gt;の有用な機能のみを残し、効果が疑わしい、または壊れている機能を非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/deprecate_pod.html&#34;&gt;PODを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PODという用語を非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタのキャプチャを非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/deprecate_uses_of_the_comma_operator_in_subscripting_expressions.html&#34;&gt;添字演算子内でのカンマ演算子の使用を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ar[i, j]&lt;/code&gt;を非推奨化。&lt;code&gt;ar[(i, j)]&lt;/code&gt;はOK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/deprecate_arithmetic_conversion_on_enumerations.html&#34;&gt;列挙値から算術型への暗黙変換を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;列挙値への算術演算で算術型に暗黙変換される仕様を非推奨とする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/deprecate_array_comparisons.html&#34;&gt;組み込み配列の比較を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;組み込み配列同士の比較演算を非推奨とする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/remove_deprecated_nothrow_exception_specification.html&#34;&gt;&lt;code&gt;throw()&lt;/code&gt;による例外送出しない指定を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;代わりに&lt;code&gt;noexcept&lt;/code&gt;を使用すること&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/prohibit_aggregates_with_user-declared_constructors.html&#34;&gt;ユーザー宣言したコンストラクタを持つクラスの集成体初期化を禁止&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタが&lt;code&gt;delete&lt;/code&gt;／&lt;code&gt;default&lt;/code&gt;宣言されているクラスを、集成体初期化によってコンストラクタ呼び出しを回避して構築できてしまっていた技法を禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/update_the_reference_to_the_unicode_standard.html&#34;&gt;Unicode標準への参照を更新&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準C++からISO/IEC 10646への参照を更新する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp20/reserving_attribute_namespaces_for_future_use.html&#34;&gt;属性の名前空間を予約&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将来の使用のために属性の名前空間を予約&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;バージョン情報ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/version.html&#34;&gt;&amp;lt;version&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。ここでは、実装依存の情報 (バージョンやリリース日付など) が標準ライブラリの実装によって定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;ライブラリに、カレンダーとタイムゾーンの機能を拡張&lt;/li&gt;
&lt;li&gt;任意のシーケンスの部分シーケンスを参照するライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/span.html&#34;&gt;&amp;lt;span&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;文字列フォーマットライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/format.html&#34;&gt;&amp;lt;format&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;出力ストリームを同期するライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/syncstream.html&#34;&gt;&amp;lt;syncstream&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;三方比較ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/numbers.html&#34;&gt;&amp;lt;numbers&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。数学定数が定義される&lt;/li&gt;
&lt;li&gt;ビット操作ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/bit.html&#34;&gt;&amp;lt;bit&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;Strict Aliasing規則に抵触しないビットレベルの再解釈キャストである&lt;code&gt;&lt;a href=&#34;../reference/bit/bit_cast.html&#34;&gt;std::bit_cast()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;1ビットだけ立っている値をもっているかを判定する&lt;code&gt;&lt;a href=&#34;../reference/bit/has_single_bit.html&#34;&gt;std::has_single_bit()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;整数値を2の累乗値に切り上げる&lt;code&gt;&lt;a href=&#34;../reference/bit/bit_ceil.html&#34;&gt;std::bit_ceil()&lt;/a&gt;&lt;/code&gt;関数、整数値を2の累乗値に切り下げる&lt;code&gt;&lt;a href=&#34;../reference/bit/bit_floor.html&#34;&gt;std::bit_floor()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;値を表現するために必要なビット幅を求める&lt;code&gt;&lt;a href=&#34;../reference/bit/bit_width.html&#34;&gt;std::bit_width()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;循環ビットシフトを行う&lt;code&gt;&lt;a href=&#34;../reference/bit/rotl.html&#34;&gt;std::rotl()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/bit/rotr.html&#34;&gt;std::rotr()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;連続した0もしくは1のビットを数える&lt;code&gt;&lt;a href=&#34;../reference/bit/countl_zero.html&#34;&gt;std::countl_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/bit/countl_one.html&#34;&gt;std::countl_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/bit/countr_zero.html&#34;&gt;std::countr_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/bit/countr_one.html&#34;&gt;std::countr_one()&lt;/a&gt;&lt;/code&gt;、および立っているビットを数える&lt;code&gt;&lt;a href=&#34;../reference/bit/popcount.html&#34;&gt;std::popcount()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;エンディアンを表す列挙型として&lt;code&gt;&lt;a href=&#34;../reference/bit/endian.html&#34;&gt;std::endian&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;型制約のための要件ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/concepts.html&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;言語機能であるコルーチンを制御するライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/coroutine.html&#34;&gt;&amp;lt;coroutine&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッドの実行を停止させるメカニズムとして&lt;code&gt;&lt;a href=&#34;../reference/stop_token.html&#34;&gt;&amp;lt;stop_token&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加し、停止に対応したスレッドクラスとして&lt;code&gt;&lt;a href=&#34;../reference/thread.html&#34;&gt;&amp;lt;thread&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/thread/jthread.html&#34;&gt;std::jthread&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;軽量な同期プリミティブであるセマフォのライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/semaphore.html&#34;&gt;&amp;lt;semaphore&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッド調整メカニズムとして、ラッチライブラリの&lt;code&gt;&lt;a href=&#34;../reference/latch.html&#34;&gt;&amp;lt;latch&amp;gt;&lt;/a&gt;&lt;/code&gt;、バリアライブラリの&lt;code&gt;&lt;a href=&#34;../reference/barrier.html&#34;&gt;&amp;lt;barrier&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータの組ではなく、コンテナや配列、部分的なコンテナなどを扱う範囲ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;既存のイテレータの組を扱うアルゴリズムは、&lt;code&gt;std::ranges&lt;/code&gt;名前空間に範囲版アルゴリズムが追加される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ソースコードの位置を取得するライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/source_location.html&#34;&gt;&amp;lt;source_location&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;取り決め&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std&lt;/code&gt;名前空間以下の関数テンプレートをユーザーが特殊化することを禁止する (参照 : &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf&#34; target=&#34;_blank&#34;&gt;P0551R3&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;連想コンテナに、要素がコンテナに含まれているかを判定する&lt;code&gt;contains()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;順序付き連想コンテナと同様に、非順序連想コンテナの検索処理で、一時オブジェクトが生成されるコストを抑える拡張を追加。キー等値比較を行う関数オブジェクトとハッシュ計算を行う関数オブジェクトの両方に&lt;code&gt;is_transparent&lt;/code&gt;が定義されていれば、透過的な検索が使用できる。&lt;code&gt;&lt;a href=&#34;../reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;クラスのページを参照&lt;/li&gt;
&lt;li&gt;各コンテナの非メンバ関数として、要素を削除する&lt;code&gt;std::erase()&lt;/code&gt;関数と&lt;code&gt;std::erase_if()&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;のメンバ関数&lt;code&gt;remove()&lt;/code&gt;、&lt;code&gt;remove_if()&lt;/code&gt;、&lt;code&gt;unique()&lt;/code&gt;の戻り値型を、&lt;code&gt;void&lt;/code&gt;から&lt;code&gt;Container::size_type&lt;/code&gt;に変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;クラスの比較演算子、&lt;code&gt;&lt;a href=&#34;../reference/array/array/fill.html&#34;&gt;fill()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;../reference/array/array/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;../reference/array/array/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;組み込み配列を&lt;code&gt;&lt;a href=&#34;../reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;に変換する関数として&lt;code&gt;&lt;a href=&#34;../reference/array/to_array.html&#34;&gt;std::to_array()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数としてコンテナの要素数を取得する&lt;code&gt;&lt;a href=&#34;../reference/iterator/ssize.html&#34;&gt;std::ssize()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;、および&lt;code&gt;&lt;a href=&#34;../reference/vector/vector.html&#34;&gt;std::vector&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;の多くの関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素位置をシフトする&lt;code&gt;&lt;a href=&#34;../reference/algorithm/shift_left.html&#34;&gt;std::shift_left()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/algorithm/shift_right.html&#34;&gt;std::shift_right()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に三方比較による辞書順比較アルゴリズム&lt;code&gt;&lt;a href=&#34;../reference/algorithm/lexicographical_compare_three_way.html&#34;&gt;std::lexicographical_compare_three_way()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値とポインタの中点を求める関数として、&lt;code&gt;&lt;a href=&#34;../reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/numeric/midpoint.html&#34;&gt;std::midpoint()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;浮動小数点数を線形補間する関数として、&lt;code&gt;&lt;a href=&#34;../reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/cmath/lerp.html&#34;&gt;std::lerp()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムをムーブに対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムに&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/back_insert_iterator.html&#34;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/iterator/front_insert_iterator.html&#34;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/iterator/insert_iterator.html&#34;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt;クラスのコンストラクタ、代入演算子、間接参照演算子、インクリメント演算子、および&lt;code&gt;&lt;a href=&#34;../reference/iterator/back_inserter.html&#34;&gt;std::back_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/iterator/front_inserter.html&#34;&gt;std::front_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/iterator/inserter.html&#34;&gt;std::inserter()&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;constexpr&lt;/code&gt;を追加。これらのクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/functional/ref.html&#34;&gt;std::ref()&lt;/a&gt;&lt;/code&gt;関数、&lt;code&gt;&lt;a href=&#34;../reference/functional/cref.html&#34;&gt;std::cref()&lt;/a&gt;&lt;/code&gt;関数のテンプレートパラメータ&lt;code&gt;T&lt;/code&gt;型に不完全型を指定することを許可&lt;/li&gt;
&lt;li&gt;メンバ関数の部分適用を簡単にするために、プレースホルダーの指定なく引数を先頭から順に束縛する&lt;code&gt;&lt;a href=&#34;../reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/invoke.html&#34;&gt;std::invoke()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;の各操作、&lt;code&gt;&lt;a href=&#34;../reference/functional/not_fn.html&#34;&gt;std::not_fn()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/functional/bind.html&#34;&gt;std::bind()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/functional/mem_fn.html&#34;&gt;std::mem_fn()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;li&gt;コンセプトの導入にともない、&lt;code&gt;&lt;a href=&#34;../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った値をそのまま返す関数オブジェクト&lt;code&gt;&lt;a href=&#34;../reference/functional/identity.html&#34;&gt;std::identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;クラスに、先頭の部分文字列を判定する&lt;code&gt;starts_with()&lt;/code&gt;メンバ関数、末尾の部分文字列を判定する&lt;code&gt;ends_with()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;../reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数の、メモリの縮小機能を削除し、伸長のみとする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/char_traits.html&#34;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;../reference/string/char_traits/move.html&#34;&gt;move()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/string/char_traits/copy.html&#34;&gt;copy()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/string/char_traits/assign.html&#34;&gt;assign()&lt;/a&gt;&lt;/code&gt;静的メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが、値初期化するよう動作変更。これまではC言語との互換性のために未初期化となっていた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;../reference/memory/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの浮動小数点数型に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;アトミッククラスに対するブロッキング同期の機能として&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/wait.html&#34;&gt;wait()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/notify_one.html&#34;&gt;notify_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/notify_all.html&#34;&gt;notify_all()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ロックフリーであることが保証されたアトミック整数型の別名として&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;atomic_signed_lock_free&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;atomic_unsigned_lock_free&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/memory_order.html&#34;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;の列挙子にスコープをもたせた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスに、&lt;code&gt;bool&lt;/code&gt;値を読み込むメンバ関数&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_flag/test.html&#34;&gt;test()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;非アトミックなオブジェクトにアトミック操作を適用するためのクラス&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ベクトル化の実行ポリシーとして、&lt;code&gt;&lt;a href=&#34;../reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unsequenced_policy&lt;/a&gt;&lt;/code&gt;型と&lt;code&gt;&lt;a href=&#34;../reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unseq&lt;/a&gt;&lt;/code&gt;タグを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同期ストリームの追加にともなって、&lt;code&gt;&lt;a href=&#34;../reference/ostream.html&#34;&gt;&amp;lt;ostream&amp;gt;&lt;/a&gt;&lt;/code&gt;に、同期ストリーム関係の出力マニピュレータを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/istream/basic_istream/op_istream_free.html&#34;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;(basic_istream&amp;amp;, CharT*)&lt;/code&gt;を&lt;code&gt;operator&amp;gt;&amp;gt;(basic_istream&amp;amp;, CharT (&amp;amp;)[N])&lt;/code&gt;に修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ostream/basic_ostream/op_ostream_free.html&#34;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;wchar_t&lt;/code&gt; (&lt;code&gt;char&lt;/code&gt;版のみ)、&lt;code&gt;char8_t&lt;/code&gt;、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のdelete宣言を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/istream_iterator.html&#34;&gt;std::istream_iterator&lt;/a&gt;&lt;/code&gt;について、要件の書き方を整理し、振る舞いをより明確化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_stringbuf.html&#34;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_istringstream.html&#34;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_ostringstream.html&#34;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;クラスに、アロケータを伝播させるためのインタフェースを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/make_shared.html&#34;&gt;std::make_shared()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/memory/allocate_shared.html&#34;&gt;std::allocate_shared()&lt;/a&gt;&lt;/code&gt;を配列に対応&lt;/li&gt;
&lt;li&gt;スマートポインタをデフォルト初期化で構築するヘルパ関数として、&lt;code&gt;&lt;a href=&#34;../reference/memory/make_unique_for_overwrite.html&#34;&gt;std::make_unique_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/memory/make_shared_for_overwrite.html&#34;&gt;std::make_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/memory/allocate_shared_for_overwrite.html&#34;&gt;std::allocate_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ポインタを生ポインタに変換する&lt;code&gt;&lt;a href=&#34;../reference/memory/to_address.html&#34;&gt;std::to_address()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/pointer_traits.html&#34;&gt;std::pointer_traits&lt;/a&gt;::&lt;a href=&#34;../reference/memory/pointer_traits/pointer_to.html&#34;&gt;pointer_to()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Nバイトアライメントされたポインタであることをコンパイラに伝える&lt;code&gt;&lt;a href=&#34;../reference/memory/assume_aligned.html&#34;&gt;std::assume_aligned()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、uses allocator構築をサポートするユーティリティ関数として、&lt;code&gt;&lt;a href=&#34;../reference/memory/uses_allocator_construction_args.html&#34;&gt;std::uses_allocator_construction_args()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/memory/make_obj_using_allocator.html&#34;&gt;std::make_obj_using_allocator()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_construct_using_allocator.html&#34;&gt;std::uninitialized_construct_using_allocator()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator.html&#34;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;に、以下の変更を追加：&lt;ul&gt;
&lt;li&gt;クラステンプレートのデフォルトテンプレート引数を&lt;code&gt;&lt;a href=&#34;../reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;&lt;/code&gt;型とした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt;のバイト列をメモリ確保する&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/allocate_bytes.html&#34;&gt;allocate_bytes()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/deallocate_bytes.html&#34;&gt;deallocate_bytes()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリを確保する&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/allocate_object.html&#34;&gt;allocate_object()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/deallocate_object.html&#34;&gt;deallocate_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリ確保と構築をする&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/new_object.html&#34;&gt;new_object()&lt;/a&gt;&lt;/code&gt;、破棄と解放をする&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/delete_object.html&#34;&gt;delete_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数と符号なし整数の安全な比較関数として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/cmp_equal.html&#34;&gt;std::cmp_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/cmp_not_equal.html&#34;&gt;std::cmp_not_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/cmp_less.html&#34;&gt;std::cmp_less()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/cmp_less_equal.html&#34;&gt;std::cmp_less_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/cmp_greater.html&#34;&gt;std::cmp_greater()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/cmp_greater_equal.html&#34;&gt;std::cmp_greater_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/in_range.html&#34;&gt;std::in_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/swap.html&#34;&gt;std::swap()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/exchange.html&#34;&gt;std::exchange()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;クラスを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;../reference/utility/pair/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;../reference/utility/pair/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;../reference/utility/pair/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;../reference/utility/pair/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;../reference/tuple/tuple/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;../reference/tuple/tuple/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;../reference/tuple/tuple/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;../reference/tuple/tuple/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイルシステム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/create_directory.html&#34;&gt;std::filesystem::create_directory()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/filesystem/create_directories.html&#34;&gt;std::filesystem::create_directories()&lt;/a&gt;&lt;/code&gt;の仕様が直感的ではなく、すでにディレクトリが存在している場合にエラーとなっていた。C++20ではその状況ではエラーにならないようにする (エラーではなく&lt;code&gt;false&lt;/code&gt;が返る)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、constexpr関数が定数式評価されたかを判定する特殊な関数&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_constant_evaluated.html&#34;&gt;std::is_constant_evaluated()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、型のCV修飾と参照を除去する型特性クラスとして&lt;code&gt;&lt;a href=&#34;../reference/type_traits/remove_cvref.html&#34;&gt;std::remove_cvref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った型をそのまま返す&lt;code&gt;&lt;a href=&#34;../reference/type_traits/type_identity.html&#34;&gt;std::type_identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、例外送出せずに暗黙の型変換が可能かを判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_nothrow_convertible.html&#34;&gt;std::is_nothrow_convertible&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素数が判明している配列型かを判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_bounded_array.html&#34;&gt;std::is_bounded_array&lt;/a&gt;&lt;/code&gt;、要素数が不明な配列型かを判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_unbounded_array.html&#34;&gt;std::is_unbounded_array&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、レイアウト互換性、ポインタ相互交換可能性を判定する以下の型特性を追加：&lt;ul&gt;
&lt;li&gt;2つの型にレイアウト互換があるかを判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_layout_compatible.html&#34;&gt;std::is_layout_compatible&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2つのメンバポインタが互換な共通位置にあるかを判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_corresponding_member.html&#34;&gt;std::is_corresponding_member()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基底クラスと派生クラスの間でポインタ相互交換可能かを判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_pointer_interconvertible_base_of.html&#34;&gt;std::is_pointer_interconvertible_base_of&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メンバポインタとクラスの間でポインタ相互交換可能かを判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_pointer_interconvertible_with_class.html&#34;&gt;is_pointer_interconvertible_with_class()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型を&lt;code&gt;T&amp;amp;&lt;/code&gt;型に展開する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/unwrap_reference.html&#34;&gt;std::unwrap_reference&lt;/a&gt;&lt;/code&gt;型特性、&lt;code&gt;&lt;a href=&#34;../reference/type_traits/decay.html&#34;&gt;std::decay&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型の展開をする&lt;code&gt;&lt;a href=&#34;../reference/type_traits/unwrap_ref_decay.html&#34;&gt;std::unwrap_ref_decay&lt;/a&gt;&lt;/code&gt;型特性を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一貫比較機能によって比較演算子の定義が容易になったため、不要になった演算子の簡潔定義機能である&lt;code&gt;&lt;a href=&#34;../reference/utility/rel_ops.html&#34;&gt;std::rel_ops&lt;/a&gt;&lt;/code&gt;を非推奨化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;../reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数が、メモリの縮小をしなくなったため、デフォルト引数&lt;code&gt;0&lt;/code&gt;を非推奨化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが値初期化するようになったため、不要になった以下のアトミックオブジェクトの初期化機能を非推奨化：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_init.html&#34;&gt;std::atomic_init()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_var_init.html&#34;&gt;ATOMIC_VAR_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;の&lt;a href=&#34;../reference/memory/atomic.html&#34;&gt;&lt;code&gt;std::atomic&lt;/code&gt;特殊化&lt;/a&gt;追加にともない、&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;に対する以下のアトミック操作を非推奨化：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_is_lock_free.html&#34;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_load.html&#34;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_load_explicit.html&#34;&gt;std::atomic_load_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_store.html&#34;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_store_explicit.html&#34;&gt;std::atomic_store_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_exchange.html&#34;&gt;std::atomic_exchange&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_exchange_explicit.html&#34;&gt;std::atomic_exchange_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_weak.html&#34;&gt;std::atomic_compare_exchange_weak&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_strong.html&#34;&gt;std::atomic_compare_exchange_strong&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.html&#34;&gt;std::atomic_compare_exchange_weak_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.html&#34;&gt;std::atomic_compare_exchange_strong_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator.html&#34;&gt;allocator&lt;/a&gt;&lt;/code&gt;の以下のメンバを削除。なお、&lt;code&gt;size_type&lt;/code&gt;型と&lt;code&gt;difference_type&lt;/code&gt;型の非推奨は取り消された。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rebind&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator/address.html&#34;&gt;address()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator/allocate.html&#34;&gt;allocate()&lt;/a&gt;&lt;/code&gt;メンバ関数の&lt;code&gt;hint&lt;/code&gt;パラメータ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator/max_size.html&#34;&gt;max_size()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator/construct.html&#34;&gt;construct()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator/destroy.html&#34;&gt;destroy()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、要素型を再束縛するための&lt;code&gt;allocator&amp;lt;void&amp;gt;&lt;/code&gt;特殊化を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、&lt;code&gt;constexpr&lt;/code&gt;で扱える型の分類である&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_literal_type.html&#34;&gt;is_literal_type&lt;/a&gt;&lt;/code&gt;型特性を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、一時的なメモリ確保のための&lt;code&gt;&lt;a href=&#34;../reference/memory/get_temporary_buffer.html&#34;&gt;std::get_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数と&lt;code&gt;&lt;a href=&#34;../reference/memory/return_temporary_buffer.html&#34;&gt;std::return_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた&lt;code&gt;&lt;a href=&#34;../reference/memory/raw_storage_iterator.html&#34;&gt;raw_storage_iterator&lt;/a&gt;&lt;/code&gt;クラスを削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた以下の機能を削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/negators.html&#34;&gt;not1()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/negators.html&#34;&gt;not2()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/negators.html&#34;&gt;unary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/negators.html&#34;&gt;binary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;標準関数オブジェクトの&lt;code&gt;result_type&lt;/code&gt;、&lt;code&gt;argument_type&lt;/code&gt;、&lt;code&gt;first_argument_type&lt;/code&gt;、&lt;code&gt;second_argument_type&lt;/code&gt;型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;shared_ptr&lt;/a&gt;::&lt;a href=&#34;../reference/memory/shared_ptr/unique.html&#34;&gt;unique()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits/invoke_result.html&#34;&gt;invoke_result&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;../reference/type_traits/result_of.html&#34;&gt;result_of&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17での&lt;code&gt;&lt;a href=&#34;../reference/exception/uncaught_exceptions.html&#34;&gt;uncaught_exceptions()&lt;/a&gt;&lt;/code&gt;の追加にともない、非推奨化していた&lt;code&gt;&lt;a href=&#34;../reference/exception/uncaught_exception.html&#34;&gt;uncaught_exception()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていたC互換ライブラリ&lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt;を削除。また、C++ではなにも定義されないC互換ライブラリ&lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2131r0.html&#34; target=&#34;_blank&#34;&gt;P2131R0 Changes between C++17 and C++20 DIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
</feed>