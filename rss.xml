<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-15T06:55:04.556195</updated>
  <id>85843dd8-b3b7-4929-85f4-2c30788d63a0</id>

  
    <entry>
      <title>try_emplace -- map::try_emplace : C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/map/map/try_emplace.html"/>
      <id>c0573256bbe5a21bdf1c2d073a17b679eb27b092:reference/map/map/try_emplace.md</id>
      <updated>2025-05-15T15:51:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/try_emplace.md b/reference/map/map/try_emplace.md
index f43067b02..7bb94f5dd 100644
--- a/reference/map/map/try_emplace.md
+++ b/reference/map/map/try_emplace.md
@@ -7,16 +7,34 @@
 
 ```cpp
 template &amp;lt;class... Args&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; try_emplace(const key_type&amp;amp; k, Args&amp;amp;&amp;amp;... args);            // (1)
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(const key_type&amp;amp; k, Args&amp;amp;&amp;amp;... args); // (1) C++17
 
 template &amp;lt;class... Args&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; try_emplace(key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);                 // (2)
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);      // (2) C++17
 
 template &amp;lt;class... Args&amp;gt;
-iterator try_emplace(const_iterator hint, const key_type&amp;amp; k, Args&amp;amp;&amp;amp;... args);   // (3)
+iterator
+  try_emplace(const_iterator hint,
+              const key_type&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);        // (3) C++17
 
 template &amp;lt;class... Args&amp;gt;
-iterator try_emplace(const_iterator hint, key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);        // (4)
+iterator
+  try_emplace(const_iterator hint,
+              key_type&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);        // (4) C++17
+
+template &amp;lt;class K, class... Args&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(K&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args); // (5) C++26
+
+template &amp;lt;class K, class... Args&amp;gt;
+iterator
+  try_emplace(const_iterator hint,
+              K&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);        // (6) C++26
 ```
 * pair[link /reference/utility/pair.md]
 
@@ -32,44 +50,43 @@ iterator try_emplace(const_iterator hint, key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);
 - (2) : 指定された一時オブジェクトのキーが存在しない場合に、要素を直接構築で挿入する
 - (3) : キーを検索するヒントを指定し、指定されたキーが存在しない場合に、要素を直接構築で挿入する
 - (4) : キーを検索するヒントを指定し、指定された一時オブジェクトのキーが存在しない場合に、要素を直接構築で挿入する
+- (5) : `key_type`型と比較可能なキーが存在しない場合に、要素を直接構築で挿入する
+- (6) : キーを検索するヒントを指定し、指定された`key_type`型と比較可能なキーが存在しない場合に、要素を直接構築で挿入する
 
 
 ## テンプレートパラメータ制約
-- (1)、(3) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
-- (2)、(4) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
+- (1)、(3)、(5) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
+- (2)、(4)、(6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `map` に直接構築可能であること
+- (5), (6) : `key_compare::is_transparent` が妥当な式であること
 
 なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
 
 
 ## 効果
-- (1)、(3) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1)、(3)、(5) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2)、(4)、(6) : `map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1)、(2)、(5) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 挿入されなかった場合には、`first` に `k` と等価のキーを持つ既存の要素へのイテレータ、`second` に `false` が設定される。
-- (3)、(4) :
+- (3)、(4)、(6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 挿入されなかった場合には、`k` と等価のキーを持つ既存の要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2) : [`emplace`](emplace.md) と同じ。
-- (3)、(4) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1)、(2)、(5) : [`emplace`](emplace.md) と同じ。
+- (3)、(4)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
 - 概要に記載されているように、本メンバ関数は指定されたキーと等価の要素が既に存在する場合には、引数に副作用が発生しない。  
-    一方、[`emplace`](emplace.md)、[`emplace_hint`](emplace_hint.md)、[`insert`](insert.md) にはそのような規定は無く、挿入がされなかった場合でも引数に副作用（引数からのムーブ）が発生してしまう可能性があるため、注意が必要である。
-
-- このメンバ関数の機能テストマクロは以下の通り。  
-
-    | マクロ名                    | 値       |
-    |-----------------------------|----------|
-    | `__cpp_lib_map_try_emplace` | `201411` |
-
+    - 一方、[`emplace`](emplace.md)、[`emplace_hint`](emplace_hint.md)、[`insert`](insert.md) にはそのような規定は無く、挿入がされなかった場合でも引数に副作用（引数からのムーブ）が発生してしまう可能性があるため、注意が必要である。
+- (5), (6) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -129,3 +146,5 @@ false, 114, false
 - [N4006 An improved emplace() for unique-key maps](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html)
 - [N4240 Improved insertion interface for unique-key maps (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html)
 - [N4279 Improved insertion interface for unique-key maps (Revision 2.3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html)
+- [P2363R5: Extending associative containers with the remaining heterogeneous overloads](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>at -- map::operator[ ]とat : C++26対応として異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/map/map/at.html"/>
      <id>c036064051b5a5985af8b5f9777772c65eb8016f:reference/map/map/at.md</id>
      <updated>2025-05-15T15:31:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/at.md b/reference/map/map/at.md
index 16eccbdf4..fc8ffd247 100644
--- a/reference/map/map/at.md
+++ b/reference/map/map/at.md
@@ -6,23 +6,49 @@
 * cpp11[meta cpp]
 
 ```cpp
-T&amp;amp; at(const key_type&amp;amp; x);
-const T&amp;amp; at(const key_type &amp;amp; x) const;
+T&amp;amp; at(const key_type&amp;amp; x);              // (1) C++11
+const T&amp;amp; at(const key_type &amp;amp; x) const; // (2) C++11
+
+template&amp;lt;class K&amp;gt;
+mapped_type&amp;amp; at(const K&amp;amp; x);             // (3) C++26
+template&amp;lt;class K&amp;gt;
+const mapped_type&amp;amp; at(const K&amp;amp; x) const; // (4) C++26
 ```
 
 ## 概要
 指定したキーを持つ要素を取得する。  
-要素を取り出す際にキーの存在チェックをする。
+[`operator[]`](op_at.md)と違って、要素を取り出す際にキーに対応する値がなければ例外が送出される。
+
+- (1), (2) : クラスのテンプレートパラメータ`key_type`型のキーに対応する要素を取得する
+- (3), (4) : `key_type`と比較可能な`K`型のキーに対応する要素を取得する
+
+
+## テンプレートパラメータ制約
+- (3), (4) : `key_compare::is_transparent` が妥当な式であること
+
+
+## 事前条件
+- (3), (4) : [`find`](find.md)`(x)`が妥当な式であり、定義された動作をすること
 
 
 ## 戻り値
-キー`x`に対応する値を返す。対応する要素が存在しないときは、[`out_of_range`](/reference/stdexcept.md)例外を投げる。
+キー`x`に対応する値を返す。
 
 
 ## 計算量
 要素数に対して対数時間
 
 
+## 例外
+- 対応する要素が存在しない場合、[`std::out_of_range`](/reference/stdexcept.md)例外を送出する
+
+
+## 備考
+- (3), (4) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -78,4 +104,6 @@ exception std::out_of_range
 
 ## 参照
 - [LWG Issue 464. Suggestion for new member functions in standard containers](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464)
-
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator[] -- map::operator[ ]とat : C++26対応として異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/map/map/op_at.html"/>
      <id>c036064051b5a5985af8b5f9777772c65eb8016f:reference/map/map/op_at.md</id>
      <updated>2025-05-15T15:31:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/op_at.md b/reference/map/map/op_at.md
index 99d6e53ee..eb7b29d3c 100644
--- a/reference/map/map/op_at.md
+++ b/reference/map/map/op_at.md
@@ -6,12 +6,23 @@
 
 ```cpp
 T&amp;amp; operator[](const key_type&amp;amp; x); // (1) C++03
+
 T&amp;amp; operator[](key_type&amp;amp;&amp;amp; x);      // (2) C++11
+
+template &amp;lt;class K&amp;gt;
+T&amp;amp; operator[](K&amp;amp;&amp;amp; x);             // (3) C++26
 ```
 
 ## 概要
 指定したキーを持つ要素を取得する。対応する要素が存在しない場合は生成して返す。
 
+- (1), (2) : クラスのテンプレートパラメータ`key_type`型のキーに対応する要素を取得する
+- (3) : `key_type`と比較可能な`K`型のキーに対応する要素を取得する
+
+
+## テンプレートパラメータ制約
+- (3) : `key_compare::is_transparent` が妥当な式であること
+
 
 ## 戻り値
 キー`x`に対応する値を返す。対応する要素が存在しない場合は、要素を値初期化して参照を返す。
@@ -21,6 +32,12 @@ T&amp;amp; operator[](key_type&amp;amp;&amp;amp; x);      // (2) C++11
 要素数に対して対数時間
 
 
+## 備考
+- (3) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -56,3 +73,6 @@ a
 | [`insert`](insert.md) | 要素を挿入する |
 
 
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>宣言のみで使用しない変数の名前として_をサポート [P2169R4] -- ignore : C++26対応として詳細な定義を追加し、例を追加 (close #1315)</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/nice_placeholder_with_no_name.html"/>
      <id>676aba0cd327f2f742d2d3f3bb89c29e08247b74:lang/cpp26/nice_placeholder_with_no_name.md</id>
      <updated>2025-05-15T14:13:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/nice_placeholder_with_no_name.md b/lang/cpp26/nice_placeholder_with_no_name.md
index 8e36638dc..e26b12587 100644
--- a/lang/cpp26/nice_placeholder_with_no_name.md
+++ b/lang/cpp26/nice_placeholder_with_no_name.md
@@ -86,6 +86,7 @@ int main() {
 
 ## &amp;lt;a id=&amp;#34;relative-page&amp;#34; href=&amp;#34;#relative-page&amp;#34;&amp;gt;関連項目&amp;lt;/a&amp;gt;
 - [C++17 `[[maybe_unused]]`属性](/lang/cpp17/maybe_unused.md)
+- [`std::ignore`](/reference/tuple/ignore.md)
 
 ## 参照
 - [P2169R4 A nice placeholder with no name](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ignore -- ignore : C++26対応として詳細な定義を追加し、例を追加 (close #1315)</title>
      <link href="https://cpprefjp.github.io/reference/tuple/ignore.html"/>
      <id>676aba0cd327f2f742d2d3f3bb89c29e08247b74:reference/tuple/ignore.md</id>
      <updated>2025-05-15T14:13:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/ignore.md b/reference/tuple/ignore.md
index 46b212ca5..8d3d8a3bc 100644
--- a/reference/tuple/ignore.md
+++ b/reference/tuple/ignore.md
@@ -6,8 +6,15 @@
 
 ```cpp
 namespace std {
-  const unspecified ignore;            // C++11
-  inline constexpr unspecified ignore; // C++17
+  struct ignore-type { // 説明用の定義 (C++26)
+    constexpr const ignore-type&amp;amp;
+    operator=(const auto &amp;amp;) const noexcept
+      { return *this; }
+  };
+
+  const unspecified ignore;            // (1) C++11
+  inline constexpr unspecified ignore; // (1) C++17
+  inline constexpr ignore-type ignore; // (1) C++26
 }
 ```
 * unspecified[italic]
@@ -15,7 +22,61 @@ namespace std {
 ## 概要
 `ignore`は、[`tie()`](tie.md)を使用してタプルから値を抽出する際に、「不要な値」をマーキングするためのプレースホルダーである。
 
-使用例は[`tie()`](tie.md)を参照。
+そのほか、関数の戻り値を明示的に無視する際にも使用できる。
+
+C++26以降は、[`&amp;lt;utility&amp;gt;`](/reference/utility.md)をインクルードして使用することもできる。
+
+
+## 例
+### タプルの要素を取り出す際に一部の要素を無視する
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;tuple&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+std::tuple&amp;lt;int, char, std::string&amp;gt; f()
+{
+  return {1, &amp;#39;a&amp;#39;, &amp;#34;hello&amp;#34;};
+}
+
+int main() {
+  // char要素は無視する
+  int a;
+  std::string c;
+  std::tie(a, std::ignore, c) = f();
+
+  std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ignore[color ff0000]
+
+#### 出力
+```
+1
+hello
+```
+
+### 関数の戻り値を無視する (C++17)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;tuple&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+[[nodiscard]]
+int print_string(std::string s)
+{
+  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
+  return 0;
+}
+
+int main() {
+  // 自分の用途ではこの関数は必ず成功するため、
+  // 戻り値を無視する
+  std::ignore = print_string(&amp;#34;hello&amp;#34;);
+}
+```
+* std::ignore[color ff0000]
 
 
 ## バージョン
@@ -33,4 +94,9 @@ namespace std {
 - [`std::make_tuple`](make_tuple.md)
 - [`std::forward_as_tuple`](forward_as_tuple.md)
 - [`std::tie`](tie.md)
+- [C++17 `[[nodiscard]]`属性](/lang/cpp17/nodiscard.md)
+- [C++26 宣言のみで使用しない変数の名前として`_`をサポート](/lang/cpp26/nice_placeholder_with_no_name.md)
+
 
+## 参照
+- [P2968R2 Make `std::ignore` a first-class object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2968r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tie -- ignore : C++26対応として詳細な定義を追加し、例を追加 (close #1315)</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tie.html"/>
      <id>676aba0cd327f2f742d2d3f3bb89c29e08247b74:reference/tuple/tie.md</id>
      <updated>2025-05-15T14:13:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tie.md b/reference/tuple/tie.md
index 255593bd6..949b3494c 100644
--- a/reference/tuple/tie.md
+++ b/reference/tuple/tie.md
@@ -160,4 +160,5 @@ text, b.txt
 
 ## 参照
 - [LWG2301 Why is std::tie not constexpr?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2301)
+- [P2968R2 Make `std::ignore` a first-class object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2968r2.html)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iterator_concept -- move_iterator::iterator_concept : C++23対応 (close #1099)</title>
      <link href="https://cpprefjp.github.io/reference/iterator/move_iterator/type-iterator_concept.html"/>
      <id>2d8141892da0c3ada9b1835e213d303a89e10c41:reference/iterator/move_iterator/type-iterator_concept.md</id>
      <updated>2025-05-15T12:38:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/move_iterator/type-iterator_concept.md b/reference/iterator/move_iterator/type-iterator_concept.md
index 0df1bcae2..297c74b20 100644
--- a/reference/iterator/move_iterator/type-iterator_concept.md
+++ b/reference/iterator/move_iterator/type-iterator_concept.md
@@ -6,16 +6,26 @@
 * cpp20[meta cpp]
 
 ```cpp
-using iterator_concept = input_iterator_tag; // (1) C++20
+using iterator_concept = 以下参照; // (1) C++20
 ```
-* input_iterator_tag[link /reference/iterator/iterator_tag.md]
 
 ## 概要
 イテレータコンセプトを表す型。
 
+- C++20:
+    - [`input_iterator_tag`](/reference/iterator/iterator_tag.md)
+- C++23:
+    - `Iterator`が[`random_access_iterator`](/reference/iterator/random_access_iterator.md)コンセプトのモデルである場合、[`random_access_iterator_tag`](/reference/iterator/iterator_tag.md)
+    - `Iterator`が[`bidirectional_iterator`](/reference/iterator/bidirectional_iterator.md)コンセプトのモデルである場合、[`bidirectional_iterator_tag`](/reference/iterator/iterator_tag.md)
+    - `Iterator`が[`forward_iterator`](/reference/iterator/forward_iterator.md)コンセプトのモデルである場合、[`forward_iterator_tag`](/reference/iterator/iterator_tag.md)
+    - そうでない場合、[`input_iterator_tag`](/reference/iterator/iterator_tag.md)
+
+
 ## バージョン
 ### 言語
 - C++20
 
 ## 参照
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P2520R0 `move_iterator&amp;lt;T*&amp;gt;` should be a random access iterator](https://wg21.link/p2520r0)
+    - C++23で`iterator_concept`がランダムアクセスイテレータにできるようになった
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>