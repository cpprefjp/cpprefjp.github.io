<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-18T09:01:55.883291</updated>
  <id>0c28d2dd-4c1f-41d4-91a1-26c4f4f30f3e</id>

  
    <entry>
      <title>可変長データを扱うクラスの効率的な`delete` -- 可変長データを扱うクラスの効率的な`delete`、完成 #1102</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.html"/>
      <id>5e7e22e36add8468caa85af0a3c18a7a443a5e1b:lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md</id>
      <updated>2023-01-18T17:57:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md b/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
index dc5424748..913238ea8 100644
--- a/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
+++ b/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md
@@ -126,6 +126,47 @@ struct S {
 
 *destroying operator delete*が`operator delete`として使用される`delete`式の実行において、`delete`式は`delete`対象オブジェクトのデストラクタを呼び出さないで`operator delete`を呼び出す。また、その際の*destroying operator delete*の第二引数（`std::destroying_delete_t`に対応する引数）に渡される値は未規定。
 
+`delete`式に指定されているポインタの指すオブジェクトがクラス型であり、そのデストラクタが仮想デストラクタである場合、その`delete`式の実行に伴う`operator delete`の探索はそのオブジェクトの動的型（実行時の実際のクラス型）のスコープで行われる。この探索は、クラスの仮想関数を基底クラスから呼び出す時と同じものである。
+
+```cpp
+// 基底クラス
+struct B {
+  virtual ~B();
+
+  // 普通のdelete演算子オーバーロード
+  void operator delete(void*, std::size_t);
+};
+
+// 派生クラス1
+struct D : B {
+  // 普通のdelete演算子オーバーロード
+  void operator delete(void*);
+};
+
+// 派生クラス2
+struct E : B {
+  void log_deletion();
+
+  // destroying operator delete
+  void operator delete(E *p, std::destroying_delete_t) {
+    p-&amp;gt;log_deletion();
+    p-&amp;gt;~E();
+    ::operator delete(p);
+  }
+};
+
+void f() {
+  B* bp = new D;
+  delete bp; // #1 D::operator delete(void*)が呼び出される
+
+  bp = new E;
+  delete bp; // #2 E::operator delete(E*, std::destroying_delete_t)が呼び出される
+}
+```
+
+`#1`において、`D`のオブジェクトは`delete`式によって破棄され、そのメモリ領域は`D::operator delete`によって解放される。  
+`#2`において、`E`のオブジェクトの破棄とそのメモリ領域の解放は`E::operator delete`（*destroying operator delete*）によって行われる。
+
 ## 例
 
 ### 可変サイズクラスの`delete`
@@ -292,16 +333,100 @@ destruct derived2
 ```
 
 ## この機能が必要になった背景・経緯
-（執筆中）
+
+1つ目の例に挙げた`inlined_fixed_string`のような可変サイズクラスの定義は、ポインタの間接参照を回避しながら可変長配列を定義することができ、よく書かれるパターンだった（実際には*flexible array member*を使用することが多い）。
+
+しかし、このようなクラスは[サイズ付きデアロケーション](/lang/cpp14/sized_deallocation.md)を活用して効率的に削除することができなかった。
+
+`inlined_fixed_string`のオブジェクトを指すポインタを`s`とすると、`delete s;`という式の実行において、C++14（[CWG Issue 2248](https://cplusplus.github.io/CWG/issues/2248)解決前）のコンパイラは次のようなコードを呼び出す必要があった
+
+```cpp
+::operator delete(s, full_size);
+```
+
+しかし、この場合に自動で`full_size`を取得することはできない。
+
+C++17では代わりに次のようなコードを出力する
+
+```cpp
+::operator delete(s, sizeof(inlined_fixed_string));
+```
+
+が、これは正しく確保したメモリ領域を解放していない。
+
+正しくは、クラスで`operator delete`をオーバーロードする必要がある
+
+```cpp
+static void operator delete(void* ptr) {
+  ::operator delete(ptr); // アロケータが知っているptrのサイズ情報に頼る（アロケータでそのサイズを求めるためのオーバーヘッドが発生しうる）
+}
+```
+
+すなわち、サイズ付きデアロケーションを全く利用しない。これは安全に解放できるようになる一方で、サイズ付きデアロケーションのパフォーマンス上の利点を全て捨てることになる。
+
+理想的には、クラスが保存している実際に確保したメモリのサイズを取得できることが望ましい
+
+```cpp
+static void operator delete(void* ptr) {
+  inlined_fixed_string *s = reinterpret_cast&amp;lt;inlined_fixed_string*&amp;gt;(ptr); // UB
+  std::size_t full_size = sizeof(inlined_fixed_string) + s-&amp;gt;size();       // UB
+  ::operator delete(ptr, full_size);
+}
+```
+
+しかし、前述のように、この`operator delete`実行の前に`ptr`にあるオブジェクトは破棄されているため、これは未定義動作となる。
+
+*destroying operator delete*は、この一番最後の`operator delete`相当のコードを安全にし、このような可変長クラスの`delete`を効率化するために導入された。
 
 ## 検討されたほかの選択肢
-（執筆中）
+
+### `delete p`以外の削除メカニズム
+
+*destroying operator delete*が必要となる場合に、`delete`式ではなく別のメカニズムによってオブジェクトの破棄とメモリ解放を行う方法が検討された。しかし、これに次のような欠点がある
+
+- ユーザー定義型が組み込み型と同様に使用されるという原則に違反している
+    - この方法の場合、`delete`式が使えなくなる
+- 仮想デストラクタを持つ既存のクラス階層は、動的にクラスレイアウトの先頭/末尾に領域を拡張する派生クラスに対して透過的に拡張できない
+- メモリ解放戦略のローカルな選択がコードの利用者にリークする
+    - `std::unique_ptr`などにおいてはカスタムデリータを指定しなければならない
+    - `std::make_unique`などは使用できない
+    - リソース管理に`new/delete`を使用する多くのリソース管理クラスを使用できない
+
+これらの欠点（特に、`delete`式が使用できないこと）によって、この方法は好まれなかった。
+
+### destroying operator deleteの別の構文
+
+*destroying operator delete*を宣言する構文として、いくつかの構文が検討された。
+
+```cpp
+struct S {
+  // 1. void*の代わりにS*をとる
+  void operator delete(S*);
+
+  // 2. 1+~を先頭につける
+  void operator ~delete(S*);
+
+  // 3. デストラクタ風宣言
+  ~S delete();
+};
+```
+
+1. 通常の`operator delete`オーバーロードと区別がつきづらい
+2. まだ通常の`operator delete`オーバーロードと区別がつきづらい
+    - `~delete`は新しい演算子であるため可読性の問題がある
+    - *destroying operator delete*は`delete`式の実行を完全にオーバーライドするものだが、異なる演算子オーバーロードになっていることによってそれを表現していない
+3. デストラクタ風味の宣言によって、サブオブジェクト（メンバや基底クラス）のデストラクタが自動で呼ばれるという勘違いを招く可能性がある。
+    - 加えて、2と同様の問題がある
+
+結局、`std::destroying_delete_t`を第二引数に取る形が一番シンプルかつ可読性が高いとして採用された。
 
 ## 関連項目
 
+- [C++14 サイズ付きデアロケーション](/lang/cpp14/sized_deallocation.md)
 - [`std::destroying_delete_t`](/reference/new/destroying_delete_t.md)
 
 ## 参照
 
 - [P0722R3 Efficient sized delete for variable sized classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0722r3.html)
 - [P0722R1 Efficient sized delete for variable sized classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0722r1.html)
+- [CWG Issue 2248. Problems with sized delete](https://cplusplus.github.io/CWG/issues/2248)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator delete[] -- operator delete[] : 番号の調整</title>
      <link href="https://cpprefjp.github.io/reference/new/op_delete[].html"/>
      <id>3a5b2dc12d79e256423a3b90bb35533e103ec671:reference/new/op_delete[].md</id>
      <updated>2023-01-18T09:33:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/new/op_delete[].md b/reference/new/op_delete[].md
index b734ca7cd..7be6ffe5c 100644
--- a/reference/new/op_delete[].md
+++ b/reference/new/op_delete[].md
@@ -11,11 +11,11 @@ void operator delete[](void* ptr, std::align_val_t alignment) noexcept;
 void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept; // (4) C++17 から
 
 void operator delete[](void* ptr, const std::nothrow_t&amp;amp;) throw();                              // (5) C++03 まで
-void operator delete[](void* ptr, const std::nothrow_t&amp;amp;) noexcept;                             // (6) C++11 から
-void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;amp;) noexcept; // (7) C++17 から
+void operator delete[](void* ptr, const std::nothrow_t&amp;amp;) noexcept;                             // (5) C++11 から
+void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&amp;amp;) noexcept; // (6) C++17 から
 
-void operator delete[](void* ptr, void*) throw();                                       // (8) C++03 まで
-void operator delete[](void* ptr, void*) noexcept;                                      // (8) C++11 から
+void operator delete[](void* ptr, void*) throw();                                       // (7) C++03 まで
+void operator delete[](void* ptr, void*) noexcept;                                      // (7) C++11 から
 ```
 * std::nothrow_t[link nothrow_t.md]
 * std::align_val_t[link align_val_t.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unreachable -- utility/unreachable: 微調整</title>
      <link href="https://cpprefjp.github.io/reference/utility/unreachable.html"/>
      <id>da9f2c769593d5d8b94ad15ed3291ab538c5f83f:reference/utility/unreachable.md</id>
      <updated>2023-01-18T09:25:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/unreachable.md b/reference/utility/unreachable.md
index f4e949d46..9ba4c982d 100644
--- a/reference/utility/unreachable.md
+++ b/reference/utility/unreachable.md
@@ -19,7 +19,7 @@ namespace std {
 
 
 ## 備考
-`std::unreachable`関数の事前条件は決して満たされない（恒偽式）となるため、関数呼び出しは常に未定義の動作を引き起こす。
+`std::unreachable`関数の事前条件は決して満たされない（恒偽式）ため、関数呼び出しは常に未定義の動作を引き起こす。
 C++コンパイラはこの情報を利用し、`std::unreachable`呼び出しを含まないコードパスのみが実行されうると仮定して、より高速に動作するプログラムを生成する可能性がある。
 
 
@@ -28,15 +28,18 @@ C++コンパイラはこの情報を利用し、`std::unreachable`呼び出し
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;utility&amp;gt;
 
-int f(int x)
+int flip(int x)
 {
- switch (x) {
- case 0:
- case 1:
-   return x;
- default:
-   std::unreachable();
- }
+  switch (x) {
+  case 0:
+    return 1;
+  case 1:
+    return 0;
+  default:
+    // C++コンパイラは引数 x が値0,1以外を取らないと
+    // 仮定したコード生成を行う可能性がある。
+    std::unreachable();
+  }
 }
 
 int main()
@@ -50,8 +53,8 @@ int main()
 
 ### 出力
 ```
-0
 1
+0
 ```
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format -- format : Rangeのデバッグ出力を解除する例を記載 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/format.html"/>
      <id>dd2fa16c526d237459f87e1b6b2511545779968d:reference/format/format.md</id>
      <updated>2023-01-17T20:24:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format.md b/reference/format/format.md
index ad5be5954..110f2a53d 100644
--- a/reference/format/format.md
+++ b/reference/format/format.md
@@ -168,6 +168,8 @@ Range・シーケンスコンテナに対して使用できる標準のオプシ
 
 - `?s`書式を指定した場合、`n`オプションと、`range-underlying-spec`は指定できない。
 - コンテナが[`std::vector`](/reference/vector/vector.md)`&amp;lt;bool&amp;gt;`である場合、その要素型は`bool`として処理される
+- Range・シーケンスコンテナでは、要素型がデバッグ出力可能である場合、それがデフォルトで有効となる
+    - 要素型の書式を指定して、デバッグ出力指定をしなければ、デフォルトで有効になっているデバッグ出力を解除できる
 
 
 #### 連想コンテナの場合 (C++23)
@@ -200,7 +202,7 @@ Range・シーケンスコンテナと同じだが、デフォルトで`m`書式
 | (なし) | デフォルト | `tuple{3, 1.23, &amp;#34;hello&amp;#34;}`は`(3, 1.23, &amp;#34;hello&amp;#34;)`となる | C++23 |
 
 - 要素型ごとに個別に書式を指定することはできない
-- 文字列はデバッグ出力が常に有効
+- デバッグ出力可能な要素型の場合、デバッグ出力は常に有効
 
 
 ### 書式例
@@ -388,10 +390,16 @@ int main() {
   std::vector&amp;lt;int&amp;gt; vx = {0xf, 0x1e, 0x3c};
   std::cout &amp;lt;&amp;lt; std::format(&amp;#34;5. {::#x}&amp;#34;, vx) &amp;lt;&amp;lt; std::endl;
 
+  // コンテナの要素型が文字・文字列型の場合はデフォルトでデバッグ出力 (?) が適用されるが、
+  // 要素への書式指定として ? を指定しなければ、デバッグ出力が解除される
+  std::vector&amp;lt;std::string&amp;gt; vt = {&amp;#34;h\tello&amp;#34;, &amp;#34;w\norld&amp;#34;, &amp;#34;C++&amp;#34;};
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;6. {:}&amp;#34;, vt) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;7. {::}&amp;#34;, vt) &amp;lt;&amp;lt; std::endl;
+
   // 文字を要素とするコンテナは文字列として出力させることもできる
   std::vector&amp;lt;char&amp;gt; vc = {&amp;#39;h&amp;#39;, &amp;#39;\n&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;};
-  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;6. {:s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
-  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;7. {:?s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;8. {:s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;9. {:?s}&amp;#34;, vc) &amp;lt;&amp;lt; std::endl;
 }
 ```
 * std::ranges::views::iota[link /reference/ranges/iota_view.md]
@@ -404,9 +412,12 @@ int main() {
 3. {1, 2, 3}
 4. [1, 2, 3, 4]
 5. [0xf, 0x1e, 0x3c]
-6. h
+6. [&amp;#34;h\tello&amp;#34;, &amp;#34;w\norld&amp;#34;, &amp;#34;C++&amp;#34;]
+7. [h    ello, w
+orld, C++]
+8. h
 ello
-7. &amp;#34;h\nello&amp;#34;
+9. &amp;#34;h\nello&amp;#34;
 ```
 
 ### pair、tupleを出力する (C++23)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変引数テンプレート -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/variadic_templates.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:lang/cpp11/variadic_templates.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/variadic_templates.md b/lang/cpp11/variadic_templates.md
index 34e2c5a10..fefba1917 100644
--- a/lang/cpp11/variadic_templates.md
+++ b/lang/cpp11/variadic_templates.md
@@ -40,7 +40,6 @@ void f(Args... args)
 
 f(3, &amp;#39;a&amp;#39;, &amp;#34;hello&amp;#34;);
 ```
-* std::tuple[link /reference/tuple/tuple.md]
 
 パラメータパックを最初の要素から順番に処理していきたい場合には、「任意の型のパラメータをひとつと、任意の個数の任意の型のパラメータを受け取る」というような形式のパラメータリストとし、再帰によって処理をする：
 
@@ -201,7 +200,6 @@ hello
       f(a, b);
     }
     ```
-    * std::tuple[link /reference/tuple/tuple.md]
     * std::make_tuple[link /reference/tuple/make_tuple.md]
 
 - テンプレートパラメータ
@@ -247,7 +245,6 @@ hello
     ```cpp
     std::tuple&amp;lt;Args...&amp;gt; t;
     ```
-    * std::tuple[link /reference/tuple/tuple.md]
 
 - 初期化子
 
@@ -356,7 +353,6 @@ hello
       &amp;gt;::value, &amp;#34;&amp;#34;); // OK
     }
     ```
-    * std::tuple[link /reference/tuple/tuple.md]
     * static_assert[link static_assert.md]
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>構造化束縛 -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/structured_bindings.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:lang/cpp17/structured_bindings.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/structured_bindings.md b/lang/cpp17/structured_bindings.md
index 9d725be6a..6dc9d9971 100644
--- a/lang/cpp17/structured_bindings.md
+++ b/lang/cpp17/structured_bindings.md
@@ -122,7 +122,6 @@ int main()
   }
 }
 ```
-* std::tuple[link /reference/tuple/tuple.md]
 * std::forward_as_tuple[link /reference/tuple/forward_as_tuple.md]
 
 #### 出力
@@ -325,7 +324,6 @@ C++17時点の構造化束縛では、使用しない変数もコピーあるい
 std::tuple&amp;lt;T1, std::pair&amp;lt;T2, T3&amp;gt;, T4&amp;gt; f();
 auto { w, {x, y}, z } = f(); // このような、tuple内にあるpairを同時に分解はできない
 ```
-* std::tuple[link /reference/tuple/tuple.md]
 
 
 ## 関連項目
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>クラステンプレートのテンプレート引数推論 -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/type_deduction_for_class_templates.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:lang/cpp17/type_deduction_for_class_templates.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/type_deduction_for_class_templates.md b/lang/cpp17/type_deduction_for_class_templates.md
index 141b334e8..a6c5bcc05 100644
--- a/lang/cpp17/type_deduction_for_class_templates.md
+++ b/lang/cpp17/type_deduction_for_class_templates.md
@@ -191,7 +191,6 @@ int main()
 * std::function[link /reference/functional/function.md]
 * std::weak_ptr[link /reference/memory/weak_ptr.md]
 * wp.lock()[link /reference/memory/weak_ptr/lock.md]
-* std::tuple[link /reference/tuple/tuple.md]
 * std::make_tuple[link /reference/tuple/make_tuple.md]
 * std::promise[link /reference/future/promise.md]
 * p.get_future()[link /reference/future/promise/get_future.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正 -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/adl_and_function_templates_that_are_not_visible.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:lang/cpp20/adl_and_function_templates_that_are_not_visible.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/adl_and_function_templates_that_are_not_visible.md b/lang/cpp20/adl_and_function_templates_that_are_not_visible.md
index 2843c7bde..0854827db 100644
--- a/lang/cpp20/adl_and_function_templates_that_are_not_visible.md
+++ b/lang/cpp20/adl_and_function_templates_that_are_not_visible.md
@@ -53,7 +53,6 @@ int main() {
   std::cout &amp;lt;&amp;lt; get&amp;lt;0&amp;gt;(t) &amp;lt;&amp;lt; std::endl; // C++17:NG C++20:OK
 }
 ```
-* std::tuple[link /reference/tuple/tuple.md]
 * get[link /reference/tuple/tuple/get.md]
 
 ### 出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>関数を条件付きでexplicitにする構文を追加 -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/explicit_bool.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:lang/cpp20/explicit_bool.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/explicit_bool.md b/lang/cpp20/explicit_bool.md
index d8cc56606..1981098fd 100644
--- a/lang/cpp20/explicit_bool.md
+++ b/lang/cpp20/explicit_bool.md
@@ -94,7 +94,6 @@ std::tuple&amp;lt;int, int&amp;gt; pixel_coordinates()
 struct NonCopyable { NonCopyable(int); NonCopyable(const NonCopyable&amp;amp;) = delete; };
 std::pair&amp;lt;NonCopyable, double&amp;gt; pmd{42, 3.14};  // C++14でコンパイルエラー！
 ```
-* std::tuple[link /reference/tuple/tuple.md]
 
 この問題に対して、C++17では (対応が早い処理系はそれ以前から) これらのクラスのコンストラクタが、条件付きで`explicit`定義されるようにした。その実装方法としてはSFINAEによって、`explicit`コンストラクタと非`explicit`コンストラクタをオーバーロードする方法が使われていた。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uses_allocator_construction_args -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/memory/uses_allocator_construction_args.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/memory/uses_allocator_construction_args.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uses_allocator_construction_args.md b/reference/memory/uses_allocator_construction_args.md
index d3862b4e9..3596122c2 100644
--- a/reference/memory/uses_allocator_construction_args.md
+++ b/reference/memory/uses_allocator_construction_args.md
@@ -215,7 +215,6 @@ int main()
 * std::allocator_arg_t[link allocator_arg_t.md]
 * std::ostream[link ../ostream/basic_ostream.md]
 * std::piecewise_construct_t[link ../utility/piecewise_construct_t.md]
-* std::tuple[link ../tuple/tuple.md]
 * std::apply[link ../tuple/apply.md]
 
 ### 出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>forward_as_tuple -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/tuple/forward_as_tuple.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/tuple/forward_as_tuple.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/forward_as_tuple.md b/reference/tuple/forward_as_tuple.md
index ecd0095c9..82e5c72da 100644
--- a/reference/tuple/forward_as_tuple.md
+++ b/reference/tuple/forward_as_tuple.md
@@ -48,7 +48,6 @@ int main()
 }
 ```
 * std::forward_as_tuple[color ff0000]
-* std::tuple[link tuple.md]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_tuple -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/tuple/make_tuple.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/tuple/make_tuple.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/make_tuple.md b/reference/tuple/make_tuple.md
index 596be8540..237294775 100644
--- a/reference/tuple/make_tuple.md
+++ b/reference/tuple/make_tuple.md
@@ -54,7 +54,6 @@ int main()
 }
 ```
 * std::make_tuple[color ff0000]
-* std::tuple[link tuple.md]
 * std::ref[link /reference/functional/ref.md]
 * std::cref[link /reference/functional/cref.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tie -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tie.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/tuple/tie.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tie.md b/reference/tuple/tie.md
index b94c9d975..f27dd9616 100644
--- a/reference/tuple/tie.md
+++ b/reference/tuple/tie.md
@@ -78,7 +78,6 @@ int main()
 ```
 * std::tie[color ff0000]
 * std::ignore[link ignore.md]
-* std::tuple[link tuple.md]
 
 #### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/tuple/tuple.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple.md b/reference/tuple/tuple.md
index 6b55fb90a..a4a196ca8 100644
--- a/reference/tuple/tuple.md
+++ b/reference/tuple/tuple.md
@@ -93,7 +93,6 @@ int main()
   std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
 }
 ```
-* std::tuple[color ff0000]
 * std::get[link tuple/get.md]
 * std::make_tuple[link make_tuple.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_cat -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_cat.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/tuple/tuple_cat.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_cat.md b/reference/tuple/tuple_cat.md
index 2c278f82d..f1a557365 100644
--- a/reference/tuple/tuple_cat.md
+++ b/reference/tuple/tuple_cat.md
@@ -55,7 +55,6 @@ int main()
 }
 ```
 * std::tuple_cat[color ff0000]
-* std::tuple[link tuple.md]
 * std::get[link tuple/get.md]
 
 ### 出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_element -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_element.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/tuple/tuple_element.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_element.md b/reference/tuple/tuple_element.md
index 8cc6c5558..06543ace0 100644
--- a/reference/tuple/tuple_element.md
+++ b/reference/tuple/tuple_element.md
@@ -80,7 +80,6 @@ int main()
 }
 ```
 * std::tuple_element[color ff0000]
-* std::tuple[link tuple.md]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_size -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_size.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/tuple/tuple_size.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_size.md b/reference/tuple/tuple_size.md
index 7132b6c54..d20516e29 100644
--- a/reference/tuple/tuple_size.md
+++ b/reference/tuple/tuple_size.md
@@ -67,7 +67,6 @@ int main()
 }
 ```
 * std::tuple_size[color ff0000]
-* std::tuple[link tuple.md]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>index_sequence_for -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/index_sequence_for.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/utility/index_sequence_for.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/index_sequence_for.md b/reference/utility/index_sequence_for.md
index 3aceab4d6..8f1a90940 100644
--- a/reference/utility/index_sequence_for.md
+++ b/reference/utility/index_sequence_for.md
@@ -53,7 +53,6 @@ int main()
 ```
 * std::index_sequence_for[color ff0000]
 * std::integer_sequence[link integer_sequence.md]
-* std::tuple[link /reference/tuple/tuple.md]
 * std::make_tuple[link /reference/tuple/make_tuple.md]
 
 ## 出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 「std::tuple」をグローバル修飾リストに追加</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_constructor.html"/>
      <id>1a3edd0c8bebb22b99068fcdd45d4f2efb52c312:reference/utility/pair/op_constructor.md</id>
      <updated>2023-01-17T20:01:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_constructor.md b/reference/utility/pair/op_constructor.md
index f7039ea23..72d83c383 100644
--- a/reference/utility/pair/op_constructor.md
+++ b/reference/utility/pair/op_constructor.md
@@ -113,7 +113,6 @@ constexpr pair(piecewise_construct_t,
     struct NonCopyable { NonCopyable(int); NonCopyable(const NonCopyable&amp;amp;) = delete; };
     std::pair&amp;lt;NonCopyable, double&amp;gt; pmd{42, 3.14};  // C++14でコンパイルエラー！
     ```
-    * std::tuple[link /reference/tuple/tuple.md]
 
     - この変更はC++17に対するものであるが、コンパイラが早期に対応していたため、一部処理系ではC++14の段階から適格となっていた
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>