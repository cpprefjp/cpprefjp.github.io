<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-06-25T04:06:42.717478</updated>
  <id>07a3b370-d3ad-41e4-a0e9-36f2acd20c8f</id>

  
    <entry>
      <title>unique_copy -- リンクを修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/unique_copy.html"/>
      <id>1fb173fc57f5ac8e68fbbbc93af9846664ff3a70:reference/algorithm/unique_copy.md</id>
      <updated>2025-06-25T13:00:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/unique_copy.md b/reference/algorithm/unique_copy.md
index b2b33ae23..875fdfd84 100644
--- a/reference/algorithm/unique_copy.md
+++ b/reference/algorithm/unique_copy.md
@@ -62,7 +62,7 @@ namespace std {
 
 ## テンプレートパラメータ制約
 - `*result = *first` は有効な式でなければならない
-- `InputIterator` と `OutputIterator` のどちらも forward iterator の要求を満たしていない場合、`InputIterator` の値型は [コピー構築可能](/reference/concepts/copy_constructible.md) かつ [コピー代入可能](/reference/type_traits/copy_assignable.md.nolink) でなければならない。そうでない場合は [コピー構築可能](/reference/concepts/copy_constructible.md) であることは要求されない
+- `InputIterator` と `OutputIterator` のどちらも forward iterator の要求を満たしていない場合、`InputIterator` の値型は [コピー構築可能](/reference/concepts/copy_constructible.md) かつ [コピー代入可能](/reference/type_traits/is_copy_assignable.md) でなければならない。そうでない場合は [コピー構築可能](/reference/concepts/copy_constructible.md) であることは要求されない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator[] -- リンクを修正</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/mdspan/op_at.html"/>
      <id>1fb173fc57f5ac8e68fbbbc93af9846664ff3a70:reference/mdspan/mdspan/op_at.md</id>
      <updated>2025-06-25T13:00:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/mdspan/op_at.md b/reference/mdspan/mdspan/op_at.md
index 56c2e0630..3da007b87 100644
--- a/reference/mdspan/mdspan/op_at.md
+++ b/reference/mdspan/mdspan/op_at.md
@@ -89,7 +89,7 @@ int main()
 
 
 ## 関連項目
-- C++23 [添字演算子の多次元サポート](cpp23/multidimensional_subscript_operator.nd.nolink)
+- C++23 [添字演算子の多次元サポート](/lang/cpp23/multidimensional_subscript_operator.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>構造化束縛でパックを導入できるようにする [P1061R10] -- コード例のエラーを修正 #1456</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/structured_bindings_can_introduce_a_pack.html"/>
      <id>22f113ec79b132299ea4ef236affc14c0adc201d:lang/cpp26/structured_bindings_can_introduce_a_pack.md</id>
      <updated>2025-06-24T11:47:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/structured_bindings_can_introduce_a_pack.md b/lang/cpp26/structured_bindings_can_introduce_a_pack.md
index 5b9018db0..f6debe55b 100644
--- a/lang/cpp26/structured_bindings_can_introduce_a_pack.md
+++ b/lang/cpp26/structured_bindings_can_introduce_a_pack.md
@@ -53,14 +53,21 @@ constexpr decltype(auto) apply(F &amp;amp;&amp;amp;f, Tuple &amp;amp;&amp;amp;t)
 C++26での実装：
 
 ```cpp
+namespace detail {
+  template &amp;lt;class A, class B&amp;gt;
+  using override_ref = std::conditional_t&amp;lt;std::is_rvalue_reference_v&amp;lt;A&amp;amp;&amp;amp;&amp;gt;, B&amp;amp;&amp;amp;, B&amp;amp;&amp;gt;;
+}
+
 template &amp;lt;class F, class Tuple&amp;gt;
 constexpr decltype(auto) apply(F &amp;amp;&amp;amp;f, Tuple &amp;amp;&amp;amp;t)
 {
   auto&amp;amp;&amp;amp; [...elems] = t;
   return std::invoke(std::forward&amp;lt;F&amp;gt;(f),
-        std::forward_like&amp;lt;Tuple, decltype(elems)&amp;gt;(elems)...);
+        static_cast&amp;lt;detail::override_ref&amp;lt;Tuple, decltype(elems)&amp;gt;&amp;gt;(elems)...);
 }
 ```
+* std::conditional_t[link /reference/type_traits/conditional.md]
+* std::is_rvalue_reference_v[link /reference/type_traits/is_rvalue_reference.md]
 * std::invoke[link /reference/functional/invoke.md]
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get -- get(const tuple&amp;&amp;) の C++ バージョンを修正</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/get.html"/>
      <id>c601a46e52984303554cad21991d10469a9a9cde:reference/tuple/tuple/get.md</id>
      <updated>2025-06-23T19:51:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/get.md b/reference/tuple/tuple/get.md
index 8c170518b..a5a19b8b2 100644
--- a/reference/tuple/tuple/get.md
+++ b/reference/tuple/tuple/get.md
@@ -44,7 +44,7 @@ namespace std {
   constexpr const T&amp;amp; get(const tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;   // (7) C++14
 
   template &amp;lt;class T, class... Types&amp;gt;
-  constexpr const T&amp;amp;&amp;amp; get(const tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept; // (8) C++14
+  constexpr const T&amp;amp;&amp;amp; get(const tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept; // (8) C++17
 }
 ```
 * tuple_element[link ../tuple_element.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Raclamusi</name>
        <email>61970673+Raclamusi@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get -- get() に const tuple&amp;&amp; 版を追加</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple/get.html"/>
      <id>267a954cdf087832ca47cf490997b7f6240e892c:reference/tuple/tuple/get.md</id>
      <updated>2025-06-23T13:05:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple/get.md b/reference/tuple/tuple/get.md
index 19e33d412..8c170518b 100644
--- a/reference/tuple/tuple/get.md
+++ b/reference/tuple/tuple/get.md
@@ -8,40 +8,43 @@
 namespace std {
   template &amp;lt;size_t I, class... Types&amp;gt;
   typename tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt; &amp;gt;::type&amp;amp;
-    get(tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;                        // (1) C++11
+    get(tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;                          // (1) C++11
 
   template &amp;lt;size_t I, class... Types&amp;gt;
   constexpr tuple_element_t&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt;&amp;amp;
-    get(tuple&amp;lt;Types...&amp;gt;&amp;amp;) noexcept;                          // (1) C++14
+    get(tuple&amp;lt;Types...&amp;gt;&amp;amp;) noexcept;                            // (1) C++14
 
   template &amp;lt;size_t I, class... types&amp;gt;
   typename tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt; &amp;gt;::type&amp;amp;&amp;amp;
-    get(tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept;                       // (2) C++11
+    get(tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept;                         // (2) C++11
 
   template &amp;lt;size_t I, class... Types&amp;gt;
   constexpr tuple_element_t&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt;&amp;amp;&amp;amp;
-    get(tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp;) noexcept;                         // (2) C++14
+    get(tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp;) noexcept;                           // (2) C++14
 
   template &amp;lt;size_t I, class... Types&amp;gt;
   typename tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt; &amp;gt;::type const&amp;amp;
-    get(const tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;                  // (3) C++11
+    get(const tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;                    // (3) C++11
 
   template &amp;lt;size_t I, class... Types&amp;gt;
   constexpr const tuple_element_t&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt;&amp;amp;
-    get(const tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;                  // (3) C++14
+    get(const tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;                    // (3) C++14
 
   template &amp;lt;size_t I, class... Types&amp;gt;
   constexpr const tuple_element_t&amp;lt;I, tuple&amp;lt;Types...&amp;gt; &amp;gt;&amp;amp;&amp;amp;
-    get(const tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept;                 // (4) C++17
+    get(const tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept;                   // (4) C++17
 
   template &amp;lt;class T, class... Types&amp;gt;
-  constexpr T&amp;amp; get(tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;             // (5) C++14
+  constexpr T&amp;amp; get(tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;               // (5) C++14
 
   template &amp;lt;class T, class... Types&amp;gt;
-  constexpr T&amp;amp;&amp;amp; get(tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept;           // (6) C++14
+  constexpr T&amp;amp;&amp;amp; get(tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept;             // (6) C++14
 
   template &amp;lt;class T, class... Types&amp;gt;
-  constexpr const T&amp;amp; get(const tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept; // (7) C++14
+  constexpr const T&amp;amp; get(const tuple&amp;lt;Types...&amp;gt;&amp;amp; t) noexcept;   // (7) C++14
+
+  template &amp;lt;class T, class... Types&amp;gt;
+  constexpr const T&amp;amp;&amp;amp; get(const tuple&amp;lt;Types...&amp;gt;&amp;amp;&amp;amp; t) noexcept; // (8) C++14
 }
 ```
 * tuple_element[link ../tuple_element.md]
@@ -55,12 +58,12 @@ namespace std {
 
 ## 要件
 - (1), (2), (3), (4) : テンプレートパラメータ`I`が`tuple`の要素数よりも小さいこと。この要件を満たさない場合は、コンパイルエラーとなる。
-- (5), (6), (7) : 型`T`が`Types...`の中にひとつだけ含まれること。この要件を満たさない場合は、コンパイルエラーとなる。
+- (5), (6), (7), (8) : 型`T`が`Types...`の中にひとつだけ含まれること。この要件を満たさない場合は、コンパイルエラーとなる。
 
 
 ## 戻り値
 - (1), (2), (3), (4) : `tuple`オブジェクト`t`の`I`番目の要素への参照
-- (5), (6), (7) : `tuple`オブジェクト`t`に含まれる`T`型の要素への参照
+- (5), (6), (7), (8) : `tuple`オブジェクト`t`に含まれる`T`型の要素への参照
 
 
 ## 例外
@@ -94,7 +97,7 @@ int main()
   }
   std::cout &amp;lt;&amp;lt; std::endl;
 
-  // 型を指定して取得する方法。(5)-(7)
+  // 型を指定して取得する方法。(5)-(8)
   {
     int&amp;amp; i = std::get&amp;lt;int&amp;gt;(t);
     char&amp;amp; c = std::get&amp;lt;char&amp;gt;(t);
@@ -119,7 +122,7 @@ a
 hello
 ```
 
-### const右辺値参照版が必要な状況 (4)
+### const右辺値参照版が必要な状況 (4), (8)
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;tuple&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Raclamusi</name>
        <email>raclamusi@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_only_function -- improve std::move_only_function</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function.html"/>
      <id>a9d264c4ed2ba86f5949f89923bf17ff8e4bcccc:reference/functional/move_only_function.md</id>
      <updated>2025-06-21T20:23:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function.md b/reference/functional/move_only_function.md
index 66ccd0b1b..ab24a4fc6 100644
--- a/reference/functional/move_only_function.md
+++ b/reference/functional/move_only_function.md
@@ -222,6 +222,48 @@ int main()
 ```
 ```
 
+### 例5: ムーブオンリーオブジェクト
+```cpp example
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+// ムーブオンリーの関数オブジェクトクラス
+struct UniqueInt {
+  std::unique_ptr&amp;lt;int&amp;gt; ptr;
+
+  void operator()(void) {
+    std::cout &amp;lt;&amp;lt; *ptr &amp;lt;&amp;lt; std::endl;
+  }
+};
+
+int main()
+{
+  UniqueInt ui = {std::make_unique&amp;lt;int&amp;gt;(42)};
+
+  // コンパイルエラー！
+  // std::functionはムーブオンリーオブジェクトを格納できない
+//  std::function&amp;lt;void(void)&amp;gt; f = std::move(ui);
+  
+  // OK
+  // std::move_only_functionなら格納可能
+  std::move_only_function&amp;lt;void(void)&amp;gt; f = std::move(ui);
+
+  f();
+}
+```
+* std::move_only_function&amp;lt;void(void)&amp;gt;[color ff0000]
+* std::function&amp;lt;void(void)&amp;gt;[link /reference/functional/function.md]
+* std::unique_ptr[link /reference/memory/unique_ptr.md]
+* std::make_unique[link /reference/memory/make_unique.md]
+* std::move[link /reference/utility/move.md]
+
+#### 出力
+```
+42
+```
+
 
 ## バージョン
 ### 言語
@@ -237,7 +279,7 @@ int main()
 ## 関連項目
 - C++11 [`function`](function.md)
 - C++26 [`copyable_function`](copyable_function.md)
-- C++26 [`copyable_function`](copyable_function.md)
+- C++26 [`function_ref`](function_ref.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
</feed>