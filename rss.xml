<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-11-25T18:38:19.803509</updated>
  <id>ee3b7689-c473-4c33-8c75-9c8a445d62ad</id>

  
    <entry>
      <title>compare_exchange_strong -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/compare_exchange_strong.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/compare_exchange_strong.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/compare_exchange_strong.md b/reference/atomic/atomic/compare_exchange_strong.md
index 301f4d777..e11d0078f 100644
--- a/reference/atomic/atomic/compare_exchange_strong.md
+++ b/reference/atomic/atomic/compare_exchange_strong.md
@@ -10,21 +10,21 @@ bool compare_exchange_strong(T&amp;amp; expected,
                              T desired,
                              memory_order success,
                              memory_order failure
-                             ) volatile noexcept;  // (1)
+                             ) volatile noexcept;  // (1) C++11
 bool compare_exchange_strong(T&amp;amp; expected,
                              T desired,
                              memory_order success,
                              memory_order failure
-                             ) noexcept;           // (2)
+                             ) noexcept;           // (2) C++11
 
 bool compare_exchange_strong(T&amp;amp; expected,
                              T desired,
                              memory_order order = memory_order_seq_cst
-                             ) volatile noexcept;  // (3)
+                             ) volatile noexcept;  // (3) C++11
 bool compare_exchange_strong(T&amp;amp; expected,
                              T desired,
                              memory_order order = memory_order_seq_cst
-                             ) noexcept;           // (4)
+                             ) noexcept;           // (4) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -36,7 +36,12 @@ bool compare_exchange_strong(T&amp;amp; expected,
 - (3), (4) : 現在の値と`expected`が等値である場合に、現在の値を`desired`で置き換え、そうでなければ`expected`を現在の値で置き換える。どちらの値置き換えの場合でも`order`メモリオーダーが使用される
 
 
-## 要件
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 事前条件
 - `failure`が[`memory_order_release`](/reference/atomic/memory_order.md), [`memory_order_acq_rel`](/reference/atomic/memory_order.md)ではないこと
 
 
@@ -162,6 +167,10 @@ true
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [atomic compare_exchange_weak/strong関数 - yohhoyの日記](http://d.hatena.ne.jp/yohhoy/20120725/p1)
 - [N2748 Strong Compare and Exchange](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2748.html)
@@ -169,3 +178,5 @@ true
 - [What does &amp;#39;spurious failure&amp;#39; on a CAS mean? - StackOverflow](http://stackoverflow.com/q/355365/463412)
 - [“Strong” and “weak” hardware memory models - Sutter’s Mill](https://herbsutter.com/2012/08/02/strong-and-weak-hardware-memory-models/)
 - [Understand `std::atomic::compare_exchange_weak()` in C++11 - Eric Z&amp;#39;s blog](https://tonywearme.wordpress.com/2014/08/15/understand-stdatomiccompare_exchange_weak-in-c11/)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_exchange_weak -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/compare_exchange_weak.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/compare_exchange_weak.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/compare_exchange_weak.md b/reference/atomic/atomic/compare_exchange_weak.md
index ccb6edbba..cbbde0b05 100644
--- a/reference/atomic/atomic/compare_exchange_weak.md
+++ b/reference/atomic/atomic/compare_exchange_weak.md
@@ -10,21 +10,21 @@ bool compare_exchange_weak(T&amp;amp; expected,
                            T desired,
                            memory_order success,
                            memory_order failure
-                           ) volatile noexcept;  // (1)
+                           ) volatile noexcept;  // (1) C++11
 bool compare_exchange_weak(T&amp;amp; expected,
                            T desired,
                            memory_order success,
                            memory_order failure
-                           ) noexcept;           // (2)
+                           ) noexcept;           // (2) C++11
 
 bool compare_exchange_weak(T&amp;amp; expected,
                            T desired,
                            memory_order order = memory_order_seq_cst
-                           ) volatile noexcept;  // (3)
+                           ) volatile noexcept;  // (3) C++11
 bool compare_exchange_weak(T&amp;amp; expected,
                            T desired,
                            memory_order order = memory_order_seq_cst
-                           ) noexcept;           // (4)
+                           ) noexcept;           // (4) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -36,7 +36,12 @@ bool compare_exchange_weak(T&amp;amp; expected,
 - (3), (4) : 現在の値と`expected`が等値である場合に、現在の値を`desired`で置き換え、そうでなければ`expected`を現在の値で置き換える。どちらの値置き換えの場合でも`order`メモリオーダーが使用される
 
 
-## 要件
+## テンプレートパラメータ制約
+- (1), (3) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 事前条件
 - `failure`が[`memory_order_release`](/reference/atomic/memory_order.md), [`memory_order_acq_rel`](/reference/atomic/memory_order.md)ではないこと
 
 
@@ -187,6 +192,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [atomic compare_exchange_weak/strong関数 - yohhoyの日記](http://d.hatena.ne.jp/yohhoy/20120725/p1)
 - [N2748 Strong Compare and Exchange](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2748.html)
@@ -194,3 +203,5 @@ int main()
 - [What does &amp;#39;spurious failure&amp;#39; on a CAS mean? - StackOverflow](http://stackoverflow.com/q/355365/463412)
 - [“Strong” and “weak” hardware memory models - Sutter’s Mill](https://herbsutter.com/2012/08/02/strong-and-weak-hardware-memory-models/)
 - [Understand `std::atomic::compare_exchange_weak()` in C++11 - Eric Z&amp;#39;s blog](https://tonywearme.wordpress.com/2014/08/15/understand-stdatomiccompare_exchange_weak-in-c11/)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exchange -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/exchange.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/exchange.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/exchange.md b/reference/atomic/atomic/exchange.md
index 711816b98..6c70b364b 100644
--- a/reference/atomic/atomic/exchange.md
+++ b/reference/atomic/atomic/exchange.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T exchange(T desired, memory_order order = memory_order_seq_cst) volatile noexcept;
-T exchange(T desired, memory_order order = memory_order_seq_cst) noexcept;
+T exchange(T desired,
+           memory_order order = memory_order_seq_cst
+           ) volatile noexcept;                      // (1) C++11
+T exchange(T desired,
+           memory_order order = memory_order_seq_cst
+           ) noexcept;                               // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,6 +20,11 @@ T exchange(T desired, memory_order order = memory_order_seq_cst) noexcept;
 値を入れ替える
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 `order`で指定されたメモリオーダーにしたがって、現在の値を`desired`でアトミックに置き換える
 
@@ -65,6 +74,10 @@ replaced 1 by 2
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
-## 参照
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
 
 
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_add -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_add.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_add.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_add.md b/reference/atomic/atomic/fetch_add.md
index 0fddfa384..797396e86 100644
--- a/reference/atomic/atomic/fetch_add.md
+++ b/reference/atomic/atomic/fetch_add.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_add(difference_type operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_add(difference_type operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_add(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) volatile noexcept;                       // (1) C++11
+T fetch_add(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,8 +20,10 @@ T fetch_add(difference_type operand, memory_order order = memory_order_seq_cst)
 加算を行う
 
 
-## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+## テンプレートパラメータ制約
+- (1), (2) : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -136,5 +142,15 @@ int main()
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
+- [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
 - [P0020R6 Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)
+    - C++20での、浮動小数点数版の追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_and -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_and.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_and.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_and.md b/reference/atomic/atomic/fetch_and.md
index 8129ac1e5..82ca4710d 100644
--- a/reference/atomic/atomic/fetch_and.md
+++ b/reference/atomic/atomic/fetch_and.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_and(T operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_and(T operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_and(T operand,
+            memory_order order = memory_order_seq_cst
+            ) volatile noexcept;                       // (1) C++11
+T fetch_and(T operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,8 +20,11 @@ T fetch_and(T operand, memory_order order = memory_order_seq_cst) noexcept;
 AND演算を行う
 
 
-## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+## テンプレートパラメータ制約
+- (1), (2) :
+    - C++17 : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -115,5 +122,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_or -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_or.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_or.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_or.md b/reference/atomic/atomic/fetch_or.md
index 27869f7de..804dbcfd2 100644
--- a/reference/atomic/atomic/fetch_or.md
+++ b/reference/atomic/atomic/fetch_or.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_or(T operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_or(T operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_or(T operand,
+           memory_order order = memory_order_seq_cst
+           ) volatile noexcept;                      // (1) C++11
+T fetch_or(T operand,
+           memory_order order = memory_order_seq_cst
+           ) noexcept;                               // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,8 +20,11 @@ T fetch_or(T operand, memory_order order = memory_order_seq_cst) noexcept;
 OR演算を行う
 
 
-## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+## テンプレートパラメータ制約
+- (1), (2) :
+    - C++17 : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -115,5 +122,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_sub -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_sub.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_sub.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_sub.md b/reference/atomic/atomic/fetch_sub.md
index acba5bdb6..5ae73031c 100644
--- a/reference/atomic/atomic/fetch_sub.md
+++ b/reference/atomic/atomic/fetch_sub.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_sub(difference_type operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_sub(difference_type operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_sub(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) volatile noexcept;                       // (1) C++11
+T fetch_sub(difference_type operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                                // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -17,7 +21,10 @@ T fetch_sub(difference_type operand, memory_order order = memory_order_seq_cst)
 
 
 ## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+- (1), (2) :
+    - C++17 : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -133,6 +140,14 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
 - [P0020R6 Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)
+    - C++20での、浮動小数点数版の追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fetch_xor -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/fetch_xor.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/fetch_xor.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/fetch_xor.md b/reference/atomic/atomic/fetch_xor.md
index 41aedb508..55beb9a61 100644
--- a/reference/atomic/atomic/fetch_xor.md
+++ b/reference/atomic/atomic/fetch_xor.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-T fetch_xor(T operand, memory_order order = memory_order_seq_cst) volatile noexcept;
-T fetch_xor(T operand, memory_order order = memory_order_seq_cst) noexcept;
+T fetch_xor(T operand,
+            memory_order order = memory_order_seq_cst
+            ) volatile noexcept;                      // (1) C++11
+T fetch_xor(T operand,
+            memory_order order = memory_order_seq_cst
+            ) noexcept;                               // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -17,7 +21,10 @@ XOR演算を行う
 
 
 ## 要件
-- `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない (C++17)
+- (1), (2) :
+    - C++17 : `std::atomic&amp;lt;T*&amp;gt;`の場合、型`T`がオブジェクト型であること。型`T`が`void*`や関数ポインタであってはならない
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 効果
@@ -117,5 +124,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0558R1 Resolving `atomic&amp;lt;T&amp;gt;` named base class inconsistencies](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0558r1.pdf)
+    - C++17での、オブジェクト型であることの制約追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>load -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/load.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/load.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/load.md b/reference/atomic/atomic/load.md
index b9ac82574..5696ea0bf 100644
--- a/reference/atomic/atomic/load.md
+++ b/reference/atomic/atomic/load.md
@@ -6,8 +6,10 @@
 * cpp11[meta cpp]
 
 ```cpp
-T load(memory_order order = memory_order_seq_cst) const volatile noexcept;
-T load(memory_order order = memory_order_seq_cst) const noexcept;
+T load(memory_order order = memory_order_seq_cst
+      ) const volatile noexcept;                 // (1) C++11
+T load(memory_order order = memory_order_seq_cst
+      ) const noexcept;                          // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,7 +18,12 @@ T load(memory_order order = memory_order_seq_cst) const noexcept;
 値を読み込む
 
 
-## 要件
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 事前条件
 `order`が以下のメモリオーダーではないこと：
 
 - [`memory_order_release`](/reference/atomic/memory_order.md)
@@ -68,6 +75,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
-## 参照
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
 
 
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_all -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/notify_all.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/notify_all.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/notify_all.md b/reference/atomic/atomic/notify_all.md
index 3dcd23f01..c25cd96ba 100644
--- a/reference/atomic/atomic/notify_all.md
+++ b/reference/atomic/atomic/notify_all.md
@@ -6,8 +6,8 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_all() volatile noexcept;
-void notify_all() noexcept;
+void notify_all() volatile noexcept; // (1) C++20
+void notify_all() noexcept;          // (2) C++20
 ```
 
 ## 概要
@@ -16,6 +16,11 @@ void notify_all() noexcept;
 この関数は、[`wait()`](wait.md)関数によるブロッキング待機を解除する。
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 起床待機している全てのアトミックオブジェクトの待機を解除する
 
@@ -77,6 +82,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): (2019 Update 3時点で実装なし)
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>notify_one -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/notify_one.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/notify_one.md b/reference/atomic/atomic/notify_one.md
index 7fce75cb6..28029f4a5 100644
--- a/reference/atomic/atomic/notify_one.md
+++ b/reference/atomic/atomic/notify_one.md
@@ -6,8 +6,8 @@
 * cpp20[meta cpp]
 
 ```cpp
-void notify_one() volatile noexcept;
-void notify_one() noexcept;
+void notify_one() volatile noexcept; // (1) C++20
+void notify_one() noexcept;          // (2) C++20
 ```
 
 ## 概要
@@ -16,6 +16,11 @@ void notify_one() noexcept;
 この関数は、[`wait()`](wait.md)関数によるブロッキング待機を解除する。
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 起床待機している少なくともひとつのアトミックオブジェクトの待機を解除する
 
@@ -103,6 +108,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): (2019 Update 3時点で実装なし)
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&amp;= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_and_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_and_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_and_assign.md b/reference/atomic/atomic/op_and_assign.md
index d6c6ec0a3..f4df9f3a5 100644
--- a/reference/atomic/atomic/op_and_assign.md
+++ b/reference/atomic/atomic/op_and_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator&amp;amp;=(T operand) volatile noexcept;
-T operator&amp;amp;=(T operand) noexcept;
+T operator&amp;amp;=(T operand) volatile noexcept; // (1) C++11
+T operator&amp;amp;=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 AND演算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -109,3 +114,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_assign.md b/reference/atomic/atomic/op_assign.md
index c06c0716a..e46cf78c8 100644
--- a/reference/atomic/atomic/op_assign.md
+++ b/reference/atomic/atomic/op_assign.md
@@ -6,17 +6,22 @@
 * cpp11[meta cpp]
 
 ```cpp
-atomic&amp;amp; operator=(const atomic&amp;amp;) = delete;
-atomic&amp;amp; operator=(const atomic&amp;amp;) volatile = delete;
+atomic&amp;amp; operator=(const atomic&amp;amp;) = delete;          // (1) C++11
+atomic&amp;amp; operator=(const atomic&amp;amp;) volatile = delete; // (2) C++11
 
-T operator=(T desired) volatile noexcept;
-T operator=(T desired) noexcept;
+T operator=(T desired) volatile noexcept;           // (3) C++11
+T operator=(T desired) noexcept;                    // (4) C++11
 ```
 
 ## 概要
 値を書き込む
 
 
+## テンプレートパラメータ制約
+- (3) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 [`store`](/reference/atomic/atomic/store.md)`(desired)`
 
@@ -62,9 +67,13 @@ int main()
 - [GCC](/implementation.md#gcc): 4.7.0
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
-	- 2012はコピー代入演算子のdeleteに対応していないため、代わりにprivateで宣言のみ行う手法で代用されている。
+    - 2012はコピー代入演算子のdeleteに対応していないため、代わりにprivateで宣言のみ行う手法で代用されている。
 
 
-## 参照
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
 
 
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-- -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_decrement.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_decrement.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_decrement.md b/reference/atomic/atomic/op_decrement.md
index d36840698..001c00659 100644
--- a/reference/atomic/atomic/op_decrement.md
+++ b/reference/atomic/atomic/op_decrement.md
@@ -6,21 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator--() volatile noexcept;
-T operator--() noexcept;
-T operator--(int) volatile noexcept;
-T operator--(int) noexcept;
+T operator--() volatile noexcept;    // (1) C++11
+T operator--() noexcept;             // (2) C++11
+
+T operator--(int) volatile noexcept; // (3) C++11
+T operator--(int) noexcept;          // (4) C++11
 ```
 
 ## 概要
-値をデクリメントする
+値をデクリメントする。
+
+- (1) : `volatile`オブジェクトに対する前置デクリメント
+- (2) : 非`volatile`オブジェクトに対する前置デクリメント
+- (3) : `volatile`オブジェクトに対する後置デクリメント
+- (4) : 非`volatile`オブジェクトに対する後置デクリメント
+
+
+## テンプレートパラメータ制約
+- (1), (3) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 戻り値
 以下と等価：
 
-- 前置`operator--`： [`fetch_sub`](fetch_sub.md)`(1) - 1`
-- 後置`operator--`： [`fetch_sub`](fetch_sub.md)`(1)`
+- (1), (2) : [`fetch_sub`](fetch_sub.md)`(1) - 1`
+- (3), (4) : [`fetch_sub`](fetch_sub.md)`(1)`
 
 
 ## 例外
@@ -95,3 +106,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator++ -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_increment.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_increment.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_increment.md b/reference/atomic/atomic/op_increment.md
index d5e162d30..8494218c2 100644
--- a/reference/atomic/atomic/op_increment.md
+++ b/reference/atomic/atomic/op_increment.md
@@ -6,22 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator++() volatile noexcept;
-T operator++() noexcept;
+T operator++() volatile noexcept;    // (1) C++11
+T operator++() noexcept;             // (2) C++11
 
-T operator++(int) volatile noexcept;
-T operator++(int) noexcept;
+T operator++(int) volatile noexcept; // (3) C++11
+T operator++(int) noexcept;          // (4) C++11
 ```
 
 ## 概要
-値をインクリメントする
+値をインクリメントする。
+
+- (1) : `volatile`オブジェクトに対する前置インクリメント
+- (2) : 非`volatile`オブジェクトに対する前置インクリメント
+- (3) : `volatile`オブジェクトに対する後置インクリメント
+- (4) : 非`volatile`オブジェクトに対する後置インクリメント
+
+
+## テンプレートパラメータ制約
+- (1), (3) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
 
 
 ## 戻り値
 以下と等価：
 
-- 前置`operator++`：[`fetch_add`](fetch_add.md)`(1) + 1`
-- 後置`operator++`：[`fetch_add`](fetch_add.md)`(1)`
+- (1), (2) : [`fetch_add`](fetch_add.md)`(1) + 1`
+- (3), (4) : [`fetch_add`](fetch_add.md)`(1)`
 
 
 ## 例外
@@ -99,3 +109,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_minus_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_minus_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_minus_assign.md b/reference/atomic/atomic/op_minus_assign.md
index 32d9b296a..13cd1d67c 100644
--- a/reference/atomic/atomic/op_minus_assign.md
+++ b/reference/atomic/atomic/op_minus_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator-=(T operand) volatile noexcept;
-T operator-=(T operand) noexcept;
+T operator-=(T operand) volatile noexcept; // (1) C++11
+T operator-=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 加算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -130,5 +135,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0020R6 Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)
+    - C++20での、浮動小数点数版の追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator|= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_or_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_or_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_or_assign.md b/reference/atomic/atomic/op_or_assign.md
index 6a23da19d..ccc8c3da6 100644
--- a/reference/atomic/atomic/op_or_assign.md
+++ b/reference/atomic/atomic/op_or_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator|=(T operand) volatile noexcept;
-T operator|=(T operand) noexcept;
+T operator|=(T operand) volatile noexcept; // (1) C++11
+T operator|=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 OR演算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -110,3 +115,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_plus_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_plus_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_plus_assign.md b/reference/atomic/atomic/op_plus_assign.md
index a42590f08..8ff774824 100644
--- a/reference/atomic/atomic/op_plus_assign.md
+++ b/reference/atomic/atomic/op_plus_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator+=(T operand) volatile noexcept;
-T operator+=(T operand) noexcept;
+T operator+=(T operand) volatile noexcept; // (1) C++11
+T operator+=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 加算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -128,5 +133,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0020R6 Floating Point Atomic](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0020r6.html)
+    - C++20での、浮動小数点数版の追加
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator T -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_t.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_t.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_t.md b/reference/atomic/atomic/op_t.md
index 4afe6a3ba..80d7f87b0 100644
--- a/reference/atomic/atomic/op_t.md
+++ b/reference/atomic/atomic/op_t.md
@@ -6,17 +6,23 @@
 * cpp11[meta cpp]
 
 ```cpp
-operator T() const volatile noexcept;
-operator T() const noexcept;
+operator T() const volatile noexcept; // (1) C++11
+operator T() const noexcept;          // (2) C++11
 ```
 
 ## 概要
 型`T`への暗黙の型変換
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 [`load()`](load.md)
 
+
 ## 例外
 投げない
 
@@ -51,6 +57,12 @@ int main()
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [N2514 Implicit Conversion Operators for Atomics](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2514.html)
-
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator^= -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/op_xor_assign.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/op_xor_assign.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/op_xor_assign.md b/reference/atomic/atomic/op_xor_assign.md
index 40dcad417..fc3e8630d 100644
--- a/reference/atomic/atomic/op_xor_assign.md
+++ b/reference/atomic/atomic/op_xor_assign.md
@@ -6,14 +6,19 @@
 * cpp11[meta cpp]
 
 ```cpp
-T operator^=(T operand) volatile noexcept;
-T operator^=(T operand) noexcept;
+T operator^=(T operand) volatile noexcept; // (1) C++11
+T operator^=(T operand) noexcept;          // (2) C++11
 ```
 
 ## 概要
 XOR演算を行う
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 戻り値
 以下と等価の式により、演算結果の値が返る：
 
@@ -112,3 +117,12 @@ int main()
 - [Clang](/implementation.md#clang): 3.2
 - [GCC](/implementation.md#gcc): 4.7.0
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>store -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/store.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/store.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/store.md b/reference/atomic/atomic/store.md
index c1f464255..89da0aed0 100644
--- a/reference/atomic/atomic/store.md
+++ b/reference/atomic/atomic/store.md
@@ -6,8 +6,12 @@
 * cpp11[meta cpp]
 
 ```cpp
-void store(T desired, memory_order order = memory_order_seq_cst) volatile noexcept;
-void store(T desired, memory_order order = memory_order_seq_cst) noexcept;
+void store(T desired,
+           memory_order order = memory_order_seq_cst
+           ) volatile noexcept;                      // (1) C++11
+void store(T desired,
+           memory_order order = memory_order_seq_cst
+           ) noexcept;                               // (2) C++11
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 * memory_order_seq_cst[link /reference/atomic/memory_order.md]
@@ -16,13 +20,19 @@ void store(T desired, memory_order order = memory_order_seq_cst) noexcept;
 値を書き込む
 
 
-## 要件
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
+## 事前条件
 `order`が以下のメモリオーダーではないこと：
 
 - [`memory_order_consume`](/reference/atomic/memory_order.md)
 - [`memory_order_acquire`](/reference/atomic/memory_order.md)
 - [`memory_order_acq_rel`](/reference/atomic/memory_order.md)
 
+
 ## 効果
 `order`で指定されたメモリオーダーにしたがって、現在の値を`desired`でアトミックに置き換える。
 この関数は、戻り値のない[`exchange()`](exchange.md)と見なせる。
@@ -70,6 +80,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013
 
 
-## 参照
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
 
 
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- atomic : volatileの制約に対応</title>
      <link href="https://cpprefjp.github.io/reference/atomic/atomic/wait.html"/>
      <id>e1886ee8c9f9533dc0f255df1e707e020938de80:reference/atomic/atomic/wait.md</id>
      <updated>2020-11-26T03:33:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/atomic/atomic/wait.md b/reference/atomic/atomic/wait.md
index 06bfe2b91..77dbc1205 100644
--- a/reference/atomic/atomic/wait.md
+++ b/reference/atomic/atomic/wait.md
@@ -6,8 +6,12 @@
 * cpp20[meta cpp]
 
 ```cpp
-void wait(T old, memory_order order = memory_order::seq_cst) const volatile noexcept;
-void wait(T old, memory_order order = memory_order::seq_cst) const noexcept;
+void wait(T old,
+          memory_order order = memory_order::seq_cst
+          ) const volatile noexcept;                 // (1) C++20
+void wait(T old,
+          memory_order order = memory_order::seq_cst
+          ) const noexcept;                          // (2) C++20
 ```
 * memory_order[link /reference/atomic/memory_order.md]
 
@@ -19,6 +23,11 @@ void wait(T old, memory_order order = memory_order::seq_cst) const noexcept;
 この関数によってブロッキング待機をしたら、対応する起床関数である[`notify_one()`](notify_one.md)、[`notify_all()`](notify_all.md)によってブロッキング待機を解除できる。
 
 
+## テンプレートパラメータ制約
+- (1) :
+    - C++20 : `atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`であること
+
+
 ## 効果
 - 以下のステップを順に繰り返し実行する：
     - [`load`](load.md)`(order)`によって現在の値を読み込み、`old`と値を比較する
@@ -114,6 +123,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): (2019 Update 3時点で実装なし)
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [P0514R4 Efficient concurrent waiting for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0514r4.pdf)
 - [ogiroux/atomic_wait - Sample implementation of C++20 atomic_wait/notify](https://github.com/ogiroux/atomic_wait)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
+    - C++20での、`volatile`版への制約追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dynamic_pointer_cast -- fix(dynamic_pointer_cast): virtual destructor will be required</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html"/>
      <id>841eb4872eeff75942f55dc7b524968a768c624c:reference/memory/shared_ptr/dynamic_pointer_cast.md</id>
      <updated>2020-11-26T00:30:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/dynamic_pointer_cast.md b/reference/memory/shared_ptr/dynamic_pointer_cast.md
index 8f442b9e1..aa1c77dff 100644
--- a/reference/memory/shared_ptr/dynamic_pointer_cast.md
+++ b/reference/memory/shared_ptr/dynamic_pointer_cast.md
@@ -51,10 +51,11 @@ struct A {
   virtual void call() const {
     std::cout &amp;lt;&amp;lt; &amp;#34;A::call&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
+  virtual ~A() = default;
 };
 
 struct B : A {
-  void call() const {
+  void call() const override {
     std::cout &amp;lt;&amp;lt; &amp;#34;B::call()&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>variant_alternative -- variant_size, variant_alternative : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant_alternative.html"/>
      <id>fb2a6a91cfbb622788c45e2c8d02c89022045145:reference/variant/variant_alternative.md</id>
      <updated>2020-11-25T18:14:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant_alternative.md b/reference/variant/variant_alternative.md
index 7c38bb42a..5d3e11d5d 100644
--- a/reference/variant/variant_alternative.md
+++ b/reference/variant/variant_alternative.md
@@ -7,23 +7,25 @@
 ```cpp
 namespace std {
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative;                       // (1) 先行宣言
+  struct variant_alternative;                       // (1) C++17 先行宣言
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, const T&amp;gt;;           // (2)
+  struct variant_alternative&amp;lt;I, const T&amp;gt;;           // (2) C++17
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, volatile T&amp;gt;;        // (3)
+  struct variant_alternative&amp;lt;I, volatile T&amp;gt;;        // (3) C++17
+                                                    // C++20で非推奨
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, const volatile T&amp;gt;;  // (4)
+  struct variant_alternative&amp;lt;I, const volatile T&amp;gt;;  // (4) C++17
+                                                    // C++20で非推奨
 
   template &amp;lt;std::size_t I, class T&amp;gt;
   using variant_alternative_t =
-    typename variant_alternative&amp;lt;I, T&amp;gt;::type;       // (5)
+    typename variant_alternative&amp;lt;I, T&amp;gt;::type;       // (5) C++17
 
   template &amp;lt;std::size_t I, class... Types&amp;gt;
-  struct variant_alternative&amp;lt;I, variant&amp;lt;Types...&amp;gt;&amp;gt;; // (6)
+  struct variant_alternative&amp;lt;I, variant&amp;lt;Types...&amp;gt;&amp;gt;; // (6) C++17
 }
 ```
 * variant[link variant.md]
@@ -50,6 +52,10 @@ namespace std {
 - (6) : `std::variant&amp;lt;Types...&amp;gt;`の`Types...`のうち、`I`番目の型`T`を取得し、その型をメンバ型`type`とする
 
 
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
+
+
 ## 例
 ```cpp example
 #include &amp;lt;variant&amp;gt;
@@ -120,3 +126,11 @@ int main()
 - [Clang](/implementation.md#clang): 4.0
 - [GCC](/implementation.md#gcc): 7.3
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>variant_size -- variant_size, variant_alternative : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant_size.html"/>
      <id>fb2a6a91cfbb622788c45e2c8d02c89022045145:reference/variant/variant_size.md</id>
      <updated>2020-11-25T18:14:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant_size.md b/reference/variant/variant_size.md
index d21b0cb71..47ffda0ab 100644
--- a/reference/variant/variant_size.md
+++ b/reference/variant/variant_size.md
@@ -6,19 +6,27 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class T&amp;gt; struct variant_size;                   // (1) 先行宣言
+  template &amp;lt;class T&amp;gt;
+  struct variant_size;                   // (1) C++17 先行宣言
 
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;const T&amp;gt;;          // (2)
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;volatile T&amp;gt;;       // (3)
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;const volatile T&amp;gt;; // (4)
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;const T&amp;gt;;          // (2) C++17
+
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;volatile T&amp;gt;;       // (3) C++17
+                                         // C++20で非推奨
+
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;const volatile T&amp;gt;; // (4) C++17
+                                         // C++20で非推奨
 
   template &amp;lt;class T&amp;gt;
   inline constexpr size_t variant_size_v
-    = variant_size&amp;lt;T&amp;gt;::value;                               // (5)
+    = variant_size&amp;lt;T&amp;gt;::value;            // (5) C++17
 
   template&amp;lt;class... Types&amp;gt;
   struct variant_size&amp;lt;variant&amp;lt;Types...&amp;gt;&amp;gt;
-    : integral_constant&amp;lt;std::size_t, sizeof...(Types)&amp;gt; {};  // (6)
+    : integral_constant&amp;lt;std::size_t, sizeof...(Types)&amp;gt; {}; // (6) C++17
 }
 ```
 * variant[link variant.md]
@@ -38,6 +46,10 @@ namespace std {
 - (6) : 修飾なしの[`std::variant`](variant.md)型の、候補型の数を取得する
 
 
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
+
+
 ## 例
 ```cpp example
 #include &amp;lt;variant&amp;gt;
@@ -55,16 +67,6 @@ int main()
     const std::variant&amp;lt;int, std::string, double&amp;gt;
   &amp;gt;::value == 3);
 
-  // (3) volatile修飾付きのstd::variant型の、候補型の数を取得する
-  static_assert(std::variant_size&amp;lt;
-    volatile std::variant&amp;lt;int, std::string, double&amp;gt;
-  &amp;gt;::value == 3);
-
-  // (4) const volatile修飾付きのstd::variant型の、候補型の数を取得する
-  static_assert(std::variant_size&amp;lt;
-    const volatile std::variant&amp;lt;int, std::string, double&amp;gt;
-  &amp;gt;::value == 3);
-
   // (5) 変数テンプレート版
   static_assert(std::variant_size_v&amp;lt;
     std::variant&amp;lt;int, std::string, double&amp;gt;
@@ -87,3 +89,11 @@ int main()
 - [Clang](/implementation.md#clang): 4.0
 - [GCC](/implementation.md#gcc): 7.3
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_element -- tuple_element, tuple_size : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_element.html"/>
      <id>01bd2a73ba54793a4e96fef216dfa05a7e255b56:reference/tuple/tuple_element.md</id>
      <updated>2020-11-25T18:07:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_element.md b/reference/tuple/tuple_element.md
index 65f5e96e1..030778847 100644
--- a/reference/tuple/tuple_element.md
+++ b/reference/tuple/tuple_element.md
@@ -6,20 +6,29 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element; // 宣言のみで定義なし
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element;                        // (1) C++11 宣言のみで定義なし
 
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const T&amp;gt;;
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, volatile T&amp;gt;;
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const volatile T&amp;gt;;
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, const T&amp;gt;;            // (2) C++11
+
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, volatile T&amp;gt;;         // (3) C++11
+                                              // C++20で非推奨
+
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, const volatile T&amp;gt;;   // (4) C++11
+                                              // C++20で非推奨
 
   template &amp;lt;std::size_t I, class... Types&amp;gt;
-  class tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt; {
+  class tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt; {   // (5) C++11
   public:
     using type = TI;
   };
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  using tuple_element_t = typename tuple_element&amp;lt;I, T&amp;gt;::type; // C++14
+  using tuple_element_t =
+    typename tuple_element&amp;lt;I, T&amp;gt;::type;       // (6) C++14
 }
 ```
 * tuple[link tuple.md]
@@ -29,19 +38,16 @@ namespace std {
 
 `tuple_element`の第1テンプレート引数に要素番号、第2引数のタプルの型を指定し、ネスト型である`type`型を取り出すことで要素型を得ることができる。
 
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element;`
-
-    特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素型を取得しようとする段階でコンパイルエラーとなる。
-
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const T&amp;gt;;`
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, volatile T&amp;gt;;`
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const volatile T&amp;gt;;`
-
-    CV修飾された型からも要素型を取得できるようにするための部分特殊化。
+- (1) : 特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素型を取得しようとする段階でコンパイルエラーとなる
+- (2) : `const`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (3) : `volatile`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (4) : `const volatile`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (5) : `std::tuple`から要素型を取得できるようにするための部分特殊化
+- (6) : エイリアステンプレート版
 
-- `template &amp;lt;size_t I, class... Types&amp;gt; class tuple_element&amp;lt;I,` [`tuple`](tuple.md)`&amp;lt;Tuples...&amp;gt;&amp;gt;;`
 
-    `std::tuple`から要素型を取得できるようにするための部分特殊化。
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
 
 
 ## 例
@@ -71,18 +77,6 @@ int main()
                   std::tuple_element&amp;lt;0, const std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
                   const int
                 &amp;gt;::value, &amp;#34;&amp;#34;);
-
-  // volatile修飾
-  static_assert(std::is_same&amp;lt;
-                  std::tuple_element&amp;lt;0, volatile std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
-                  volatile int
-                &amp;gt;::value, &amp;#34;&amp;#34;);
-
-  // const, volatile修飾
-  static_assert(std::is_same&amp;lt;
-                  std::tuple_element&amp;lt;0, const volatile std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
-                  const volatile int
-                &amp;gt;::value, &amp;#34;&amp;#34;);
 }
 ```
 * std::tuple_element[color ff0000]
@@ -103,6 +97,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [N3887 Consistent Metafunction Aliases](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3887.pdf)
-
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_size -- tuple_element, tuple_size : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_size.html"/>
      <id>01bd2a73ba54793a4e96fef216dfa05a7e255b56:reference/tuple/tuple_size.md</id>
      <updated>2020-11-25T18:07:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_size.md b/reference/tuple/tuple_size.md
index a5bec3081..a4c220aee 100644
--- a/reference/tuple/tuple_size.md
+++ b/reference/tuple/tuple_size.md
@@ -6,18 +6,27 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class T&amp;gt; class tuple_size; // 宣言のみで定義なし
+  template &amp;lt;class T&amp;gt;
+  class tuple_size;                   // (1) C++11 宣言のみで定義なし
 
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const T&amp;gt;;
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;volatile T&amp;gt;;
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const volatile T&amp;gt;;
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;const T&amp;gt;;          // (2) C++11
+
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;volatile T&amp;gt;;       // (3) C++11
+                                      // C++20で非推奨
+
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;const volatile T&amp;gt;; // (4) C++11
+                                      // C++20で非推奨
 
   template &amp;lt;class... Types&amp;gt;
   class tuple_size&amp;lt;tuple&amp;lt;Types...&amp;gt;&amp;gt;
-    : public integral_constant&amp;lt;size_t, sizeof...(Types)&amp;gt; {};
+    : public integral_constant&amp;lt;size_t, sizeof...(Types)&amp;gt; {}; // (5) C++11
 
   template &amp;lt;class T&amp;gt;
-  inline constexpr size_t tuple_size_v = tuple_size&amp;lt;T&amp;gt;::value; // C++17
+  inline constexpr size_t tuple_size_v =
+    tuple_size&amp;lt;T&amp;gt;::value;                                    // (6) C++17
 }
 ```
 * tuple[link tuple.md]
@@ -28,23 +37,22 @@ namespace std {
 
 要素数は、[`integral_constant`](/reference/type_traits/integral_constant.md)の機能を利用してコンパイル時の定数値として取得できる。
 
-- `template &amp;lt;class T&amp;gt; class tuple_size;`
-
-    特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素数を取得しようとする段階でコンパイルエラーとなる。
+- (1) : 特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素数を取得しようとする段階でコンパイルエラーとなる
+- (2) : `const`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (3) : `volatile`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (4) : `const volatile`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (5) : `std::tuple`の要素数を取得できるようにするための部分特殊化
+- (6) : 変数テンプレート版
 
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const T&amp;gt;;`
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;volatile T&amp;gt;;`
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const volatile T&amp;gt;;`
 
-    CV修飾された型からも要素数を取得できるようにするための部分特殊化。
+型`T`がタプルと見なせない型であった場合、
 
-- `template &amp;lt;class... Types&amp;gt; class tuple_size&amp;lt;tuple&amp;lt;Types...&amp;gt;&amp;gt;;`
+- C++11 : 仕様で明確に規定されてはいないが、直接的にコンパイルエラーとなる
+- C++17 : メンバ`value`が定義されない (SFINAEと組み合わせて扱える)
 
-    `std::tuple`の要素数を取得できるようにするための部分特殊化。
 
-- 型`T`がタプルと見なせない型であった場合、
-    - C++11 : 仕様で明確に規定されてはいないが、直接的にコンパイルエラーとなる
-    - C++17 : メンバ`value`が定義されない (SFINAEと組み合わせて扱える)
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
 
 
 ## 例
@@ -54,10 +62,8 @@ namespace std {
 
 int main()
 {
-  static_assert(std::tuple_size&amp;lt;               std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;const          std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;volatile       std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;const volatile std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
+  static_assert(std::tuple_size&amp;lt;      std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
+  static_assert(std::tuple_size&amp;lt;const std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
 }
 ```
 * std::tuple_size[color ff0000]
@@ -78,7 +84,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [LWG Issue 2770. `tuple_size&amp;lt;const T&amp;gt;` specialization is not SFINAE compatible and breaks decomposition declarations](https://wg21.cmeerw.net/lwg/issue2770)
     - C++17で[構造化束縛](/lang/cpp17/structured_bindings.md)機能が導入されたことに合わせて、`tuple_size`がSFINAEと組み合わせて使用できるようになった
 - [P0006R0 Adopt Type Traits Variable Templates from Library Fundamentals TS for C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0006r0.html)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- リンク再修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/common_iterator/op_equal.html"/>
      <id>6f54156cc0c6fb3bca0d599991ac82eabf84ff92:reference/iterator/common_iterator/op_equal.md</id>
      <updated>2020-11-25T15:41:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/common_iterator/op_equal.md b/reference/iterator/common_iterator/op_equal.md
index 0b35e9b51..3b44f3c51 100644
--- a/reference/iterator/common_iterator/op_equal.md
+++ b/reference/iterator/common_iterator/op_equal.md
@@ -22,7 +22,7 @@ namespace std {
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
-* equality_comparable_with[link /reference/concepts/equality_comparable_with.md]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
 
 ## 概要
 2つの`common_iterator`オブジェクトが同じ要素を指しているかを判定する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>