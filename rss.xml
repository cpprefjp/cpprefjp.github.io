<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-12-21T02:26:18.973075</updated>
  <id>a786e704-e4c3-4576-8e87-41b386044623</id>

  
    <entry>
      <title>lock_guard -- lock_guard: 出力がうまく混ざらなかったのでランダム時間のsleepを入れた</title>
      <link href="https://cpprefjp.github.io/reference/mutex/lock_guard.html"/>
      <id>258038b57db199ef2f5cd5f9998086cb55b59e82:reference/mutex/lock_guard.md</id>
      <updated>2024-12-21T11:23:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mutex/lock_guard.md b/reference/mutex/lock_guard.md
index 799173ab2..dab1029c9 100644
--- a/reference/mutex/lock_guard.md
+++ b/reference/mutex/lock_guard.md
@@ -51,16 +51,29 @@ void safe_print(int x)
   std::cout &amp;lt;&amp;lt; &amp;#34;value:&amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
 }
 
+#include &amp;lt;random&amp;gt;
+void sleep_random()
+{
+  std::random_device seed_gen;
+  std::mt19937 engine{seed_gen()};
+  std::uniform_int_distribution&amp;lt;int&amp;gt; dist{1, 10};
+
+  int sleep_ms = dist(engine);
+  std::this_thread::sleep_for(std::chrono::milliseconds{sleep_ms});
+}
+
 int main()
 {
   std::thread t1([]{
     for (int i = 0; i &amp;lt; 5; i++) {
       safe_print(i);
+      sleep_random();
     }
   });
   std::thread t2([]{
     for (int i = 0; i &amp;lt; 5; i++) {
       safe_print(5 + i);
+      sleep_random();
     }
   });
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lock_guard -- lock_guard : サンプルコードを小さくした</title>
      <link href="https://cpprefjp.github.io/reference/mutex/lock_guard.html"/>
      <id>a0fc868029ef09a5e4011531105a5f4863f69d03:reference/mutex/lock_guard.md</id>
      <updated>2024-12-21T11:13:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mutex/lock_guard.md b/reference/mutex/lock_guard.md
index eda6c1897..799173ab2 100644
--- a/reference/mutex/lock_guard.md
+++ b/reference/mutex/lock_guard.md
@@ -37,60 +37,51 @@ namespace std {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;thread&amp;gt;
 #include &amp;lt;mutex&amp;gt;
-#include &amp;lt;vector&amp;gt;
 
 // std::coutへのアクセスを排他的にする
 std::mutex print_mtx_;
 void safe_print(int x)
 {
-  std::lock_guard&amp;lt;std::mutex&amp;gt; lock(print_mtx_);
-  std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  std::lock_guard&amp;lt;std::mutex&amp;gt; lock{print_mtx_};
+  std::cout &amp;lt;&amp;lt; &amp;#34;value:&amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
 }
 
-class X {
-  std::mutex mtx_;
-  std::vector&amp;lt;int&amp;gt; data_;
-public:
-  // vectorオブジェクトへのアクセスを排他的にする
-  void add_value(int value)
-  {
-    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mtx_); // ロックを取得する(lock_guardのコンストラクタ)
-    data_.push_back(value);
-  } // ロックを手放す(lock_guardのデストラクタ)
-
-  void print()
-  {
-    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mtx_);
-    for (int x : data_) {
-      safe_print(x);
-    }
-  }
-};
-
 int main()
 {
-  X x;
-
-  std::thread t1([&amp;amp;x]{ x.add_value(1); });
-  std::thread t2([&amp;amp;x]{ x.add_value(2); });
+  std::thread t1([]{
+    for (int i = 0; i &amp;lt; 5; i++) {
+      safe_print(i);
+    }
+  });
+  std::thread t2([]{
+    for (int i = 0; i &amp;lt; 5; i++) {
+      safe_print(5 + i);
+    }
+  });
 
   t1.join();
   t2.join();
-
-  x.print();
 }
 ```
 * std::lock_guard[color ff0000]
-* data_.push_back[link /reference/vector/vector/push_back.md]
 
-### 出力
+#### 出力例
 ```
-1
-2
+value:5
+value:6
+value:7
+value:8
+value:9
+value:0
+value:1
+value:2
+value:3
+value:4
 ```
 
 ## バージョン
@@ -98,7 +89,7 @@ int main()
 - C++11
 
 ### 処理系
-- [Clang](/implementation.md#clang): ??
+- [Clang](/implementation.md#clang): 14 [mark verified]
 - [GCC](/implementation.md#gcc): 4.7.0 [mark verified]
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): 2012 [mark verified], 2013 [mark verified], 2015 [mark verified]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>構造化束縛 [P0217R3] -- 構造化束縛とlock_guard系クラスのページから、C++26変数名_のページにリンク</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/structured_bindings.html"/>
      <id>27a5b4133e36413c6b4e952d4f51c066fc3b1bef:lang/cpp17/structured_bindings.md</id>
      <updated>2024-12-21T11:13:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/structured_bindings.md b/lang/cpp17/structured_bindings.md
index 947a83547..87d0a45a9 100644
--- a/lang/cpp17/structured_bindings.md
+++ b/lang/cpp17/structured_bindings.md
@@ -341,6 +341,7 @@ auto { w, {x, y}, z } = f(); // このような、tuple内にあるpairを同時
 - [C++20 構造化束縛した変数の参照キャプチャを許可](/lang/cpp20/reference_capture_of_structured_bindings.md)
 - [C++26 構造化束縛への属性を許可](/lang/cpp26/attributes_for_structured_bindings.md)
 - [C++26 条件式での構造化束縛の使用を許可](/lang/cpp26/structured_binding_declaration_as_a_condition.md)
+- [C++26 宣言のみで使用しない変数の名前として_をサポート](/lang/cpp26/nice_placeholder_with_no_name.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lock_guard -- 構造化束縛とlock_guard系クラスのページから、C++26変数名_のページにリンク</title>
      <link href="https://cpprefjp.github.io/reference/mutex/lock_guard.html"/>
      <id>27a5b4133e36413c6b4e952d4f51c066fc3b1bef:reference/mutex/lock_guard.md</id>
      <updated>2024-12-21T11:13:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mutex/lock_guard.md b/reference/mutex/lock_guard.md
index 6a1d08a74..eda6c1897 100644
--- a/reference/mutex/lock_guard.md
+++ b/reference/mutex/lock_guard.md
@@ -104,5 +104,5 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): 2012 [mark verified], 2013 [mark verified], 2015 [mark verified]
 
 ## 関連項目
-
 - [`scoped_lock`](/reference/mutex/scoped_lock.md)
+- [C++26 宣言のみで使用しない変数の名前として_をサポート](/lang/cpp26/nice_placeholder_with_no_name.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scoped_lock -- 構造化束縛とlock_guard系クラスのページから、C++26変数名_のページにリンク</title>
      <link href="https://cpprefjp.github.io/reference/mutex/scoped_lock.html"/>
      <id>27a5b4133e36413c6b4e952d4f51c066fc3b1bef:reference/mutex/scoped_lock.md</id>
      <updated>2024-12-21T11:13:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mutex/scoped_lock.md b/reference/mutex/scoped_lock.md
index e8a75a55a..6a2d9e0d6 100644
--- a/reference/mutex/scoped_lock.md
+++ b/reference/mutex/scoped_lock.md
@@ -88,9 +88,11 @@ int main()
 - [GCC](/implementation.md#gcc): 7.3 [mark verified]
 - [Visual C++](/implementation.md#visual_cpp): ??
 
-## 関連項目
 
+## 関連項目
 - [`lock_guard`](/reference/mutex/lock_guard.md)
+- [C++26 宣言のみで使用しない変数の名前として_をサポート](/lang/cpp26/nice_placeholder_with_no_name.md)
+
 
 ## 参照
 - [P0156R2 Variadic `lock_guard` (Rev. 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0156r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>宣言のみで使用しない変数の名前として_をサポート [P2169R4] -- fix typo</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/nice_placeholder_with_no_name.html"/>
      <id>8def0da300f3370cce7815ec3476c5980576426d:lang/cpp26/nice_placeholder_with_no_name.md</id>
      <updated>2024-12-21T10:54:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/nice_placeholder_with_no_name.md b/lang/cpp26/nice_placeholder_with_no_name.md
index cb813a6b4..8e36638dc 100644
--- a/lang/cpp26/nice_placeholder_with_no_name.md
+++ b/lang/cpp26/nice_placeholder_with_no_name.md
@@ -20,7 +20,7 @@ std::mutex mux;
 std::tuple&amp;lt;T, U, V&amp;gt; f();
 
 void f() {
-  std::lock_gaurd guard{mux}; // デストラクタでの自動解放だけしたいのでguard変数はとくに使わない
+  std::lock_guard guard{mux}; // デストラクタでの自動解放だけしたいのでguard変数はとくに使わない
   auto [a, b, no_use] = f();  // 構造化束縛した一部の変数は使わない
 }
 ```
@@ -33,7 +33,7 @@ std::mutex mux;
 std::tuple&amp;lt;T, U, V&amp;gt; f();
 
 void f() {
-  std::lock_gaurd _{mux}; // OK
+  std::lock_guard _{mux}; // OK
   auto [a, b, _] = f();   // OK
 }
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>宣言のみで使用しない変数の名前として_をサポート [P2169R4] -- C++26 宣言のみで使用しない変数の名前として_をサポート : ユースケースと仕様を追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/nice_placeholder_with_no_name.html"/>
      <id>d67d018e6b43cbd65b4292f7facb135135e26a67:lang/cpp26/nice_placeholder_with_no_name.md</id>
      <updated>2024-12-21T10:43:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/nice_placeholder_with_no_name.md b/lang/cpp26/nice_placeholder_with_no_name.md
index 58c78f94b..cb813a6b4 100644
--- a/lang/cpp26/nice_placeholder_with_no_name.md
+++ b/lang/cpp26/nice_placeholder_with_no_name.md
@@ -10,22 +10,82 @@
 &amp;lt;!-- last lang caution --&amp;gt;
 
 ## 概要
-C++17で採用された、`[[maybe_unused]]`属性を変数名`_`の場合、自動的につける。
+C++26では、宣言だけして使用しない変数として、変数名`_`を特別扱いする。
+
+宣言だけして使用しない変数が必要な状況としては、以下のようなミューテックスのロック取得や、構造化束縛などがある：
+
+```cpp
+// C++23まで
+std::mutex mux;
+std::tuple&amp;lt;T, U, V&amp;gt; f();
+
+void f() {
+  std::lock_gaurd guard{mux}; // デストラクタでの自動解放だけしたいのでguard変数はとくに使わない
+  auto [a, b, no_use] = f();  // 構造化束縛した一部の変数は使わない
+}
+```
+
+C++26では、変数名として`_`は[`[[maybe_unused]]`属性](/lang/cpp17/maybe_unused.md)が付加される、と規定される。
+
+```cpp
+// C++26
+std::mutex mux;
+std::tuple&amp;lt;T, U, V&amp;gt; f();
+
+void f() {
+  std::lock_gaurd _{mux}; // OK
+  auto [a, b, _] = f();   // OK
+}
+```
+
+
+## 仕様
+- 変数名`_`は、「名前非依存 (name independent) の宣言」という名称で扱われ、実装への推奨としては `[[maybe_unused]]`属性が自動的に付加され、使用されなくても警告は出力されない：
+    ```cpp
+    auto _ = foo(); // [[maybe_unused]] auto _ = f(); と等価
+    ```
+
+- 変数名`_`は、以下の状況では再宣言できる：
+    - 自動変数
+    - 非静的メンバ変数
+    - 構造化束縛
+    - ラムダ式のキャプチャでの導入子
+- 再宣言された変数`_`を使用した場合、プログラムは不適格となる
 
 ```cpp
+namespace a {
+  auto _ = f(); // OK: &amp;#34;_&amp;#34;変数の宣言
+  auto _ = f(); // エラー！ &amp;#34;_&amp;#34;はこの名前空間ですでに定義されている
+}
+
+void f() {
+  auto _ = 42; // OK: &amp;#34;_&amp;#34;変数の宣言
+  auto _ = 0;  // OK: &amp;#34;_&amp;#34;変数の再宣言
+  {
+    auto _ = 1;     // OK: シャドウイング
+    assert(_ == 1); // OK
+  }
+  assert( _ == 42 ); // 不適格: 再宣言されたプレースホルダー変数の使用
+}
+```
+
+
+## 例
+```cpp example
 int main() {
-  [[maybe_unused]]int hardNamingVariable; 
   // gccやclangの場合、-Wallオプションをつけると、
   // 変数が未使用だった場合、警告が出力される。
   // [[maybe_unused]]属性によって、これを抑制することができた。
+  [[maybe_unused]] int hardNamingVariable;
+
   // しかし、今後は、変数名が_であれば、自動的にその属性が適用されるようになる。
+  // 以下のコードを-Wallでコンパイルしても、警告は表示されない。
   int _;
-  // このコードを-Wallでコンパイルしても、警告は表示されない。
 }
 ```
 
 ## &amp;lt;a id=&amp;#34;relative-page&amp;#34; href=&amp;#34;#relative-page&amp;#34;&amp;gt;関連項目&amp;lt;/a&amp;gt;
-- [\[\[maybe_unused\]\]属性 \[P0212R1\]](/lang/cpp17/maybe_unused.md)
+- [C++17 `[[maybe_unused]]`属性](/lang/cpp17/maybe_unused.md)
 
 ## 参照
-- [P2169R4 A nice placeholder with no name](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf)
\ No newline at end of file
+- [P2169R4 A nice placeholder with no name](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>