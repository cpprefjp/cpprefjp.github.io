<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-12-27T15:59:06.022378</updated>
  <id>15784760-0936-42b9-abb5-f35918402422</id>

  
    <entry>
      <title>インライン変数 -- C++17インライン変数 : 名前のないクラスオブジェクトをインライン指定しても同じ実体にはならないことを記載</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/inline_variables.html"/>
      <id>e68299bcaf7535ffe11dcb21247647dd980bd6e7:lang/cpp17/inline_variables.md</id>
      <updated>2022-12-28T00:53:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/inline_variables.md b/lang/cpp17/inline_variables.md
index bb89382a8..10e98f1bb 100644
--- a/lang/cpp17/inline_variables.md
+++ b/lang/cpp17/inline_variables.md
@@ -94,6 +94,10 @@ function-specifier:
   explicit
 ```
 
+## 備考
+- 名前のないクラスのオブジェクトは、インライン指定しても同じ実体にはならない
+
+
 ## 例
 
 ```cpp example
@@ -264,3 +268,4 @@ func
 - [P0386R2 - Inline Variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf), 2016-06-24
 - [P0607R0 - Inline Variables for the Standard Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0607r0.html), 2017-02-27
 - [C++1z インライン変数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/11/11/172954)
+- [インライン変数が翻訳単位毎に別々の実体となってしまう - Stackoverflow](https://ja.stackoverflow.com/questions/93046/)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++11 -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/lang/cpp11.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:lang/cpp11.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++11&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++11とは、2011年8月に改訂され、ISO/IEC 14882:2011で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;前バージョンであるC++03からメジャーバージョンアップされ、多くの有用な機能が追加された。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++0xと呼ばれていた。これは、2009年中までに策定を完了させることを目指して、下一桁を伏せ字にしたものである。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;一般的な機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/auto.html&#34;&gt;auto&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型推論&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/decltype.html&#34;&gt;decltype&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;式の型を取得&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/range_based_for.html&#34;&gt;範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;配列やコンテナといった範囲を表すオブジェクトを、簡潔に走査する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/initializer_lists.html&#34;&gt;初期化子リスト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波括弧による初期化をユーザー定義する。&lt;code&gt;vector&amp;lt;int&amp;gt; v = {1, 2, 3};&lt;/code&gt;など。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/uniform_initialization.html&#34;&gt;一様初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタの呼び出しを、波カッコで行う。&lt;code&gt;T x {a, b, c};&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html&#34;&gt;右辺値参照・ムーブセマンティクス&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;右辺値によるオーバーロード、およびそれによるリソースの所有権移動&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/lambda_expressions.html&#34;&gt;ラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクトをその場に書く&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/noexcept.html&#34;&gt;noexcept&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の例外指定、例外を投げる可能性のある式か&lt;code&gt;bool&lt;/code&gt;値を返す演算子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/constexpr.html&#34;&gt;constexpr&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定数式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/nullptr.html&#34;&gt;nullptr&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ヌルポインタを表すポインタリテラル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/inline_namespaces.html&#34;&gt;インライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ネストした名前空間に、透過的にアクセスする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/user_defined_literals.html&#34;&gt;ユーザー定義リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リテラルのサフィックスをユーザー定義する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/defaulted_and_deleted_functions.html&#34;&gt;関数の&lt;code&gt;default&lt;/code&gt;／&lt;code&gt;delete&lt;/code&gt;宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;自動定義される特殊関数の制御&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/delegating_constructors.html&#34;&gt;委譲コンストラクタ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタから他のコンストラクタに処理を委譲する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/non_static_data_member_initializers.html&#34;&gt;非静的メンバ変数の初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ変数を、宣言と同時に初期値指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/inheriting_constructors.html&#34;&gt;継承コンストラクタ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;基底クラスのコンストラクタを継承する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/override_final.html&#34;&gt;&lt;code&gt;override&lt;/code&gt;と&lt;code&gt;final&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ関数のオーバーライド指定、および派生クラスでのオーバーライドの禁止を指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/explicit_conversion_operator.html&#34;&gt;明示的な型変換演算子のオーバーロード&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;明示的な型変換が行われる場合にのみ呼び出される演算子をオーバーロードできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/extend_friend_targets.html&#34;&gt;&lt;code&gt;friend&lt;/code&gt;宣言できる対象を拡張&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータや型の別名を&lt;code&gt;friend&lt;/code&gt;宣言する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/ref_qualifier_for_this.html&#34;&gt;メンバ関数の左辺値／右辺値修飾&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;オブジェクトが左辺値／右辺値の場合のみ呼び出し可能であることの指定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス以外の型に関する機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/scoped_enum.html&#34;&gt;スコープを持つ列挙型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;強い型付けとスコープを持つ列挙型の導入と、それにともなって従来の列挙型を機能拡張&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/unrestricted_unions.html&#34;&gt;共用体の制限解除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体のメンバ変数として、クラスオブジェクトを持てるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/right_angle_brackets.html&#34;&gt;テンプレートの右山カッコ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector&amp;lt;basic_string&amp;lt;char&amp;gt;&amp;gt;&lt;/code&gt;のように、&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;をスペースを空けずに記述可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/extern_template.html&#34;&gt;extern template&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートのインスタンス化を抑止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alias_templates.html&#34;&gt;エイリアステンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートによって型の別名を定義する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/variadic_templates.html&#34;&gt;可変引数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;任意の数のテンプレートパラメータを受け取れるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/local_and_unnamed_type_as_template_arguments.html&#34;&gt;ローカル型と無名型を、テンプレート引数として使用することを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ローカルおよび無名として定義したクラスや列挙型を、テンプレート引数として渡せるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/sfinae_expressions.html&#34;&gt;任意の式によるSFINAE&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;特定の式が有効かどうかで、その関数をオーバーロード解決に含めるかどうかを決定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/remove_export_templates.html&#34;&gt;テンプレートのエクスポート機能を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレート定義をエクスポートする機能を削除する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;並行関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/thread_local_storage.html&#34;&gt;スレッドローカルストレージ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;スレッドごとに異なる静的記憶域に保持される変数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/static_initialization_thread_safely.html&#34;&gt;ブロックスコープを持つ&lt;code&gt;static&lt;/code&gt;変数初期化のスレッドセーフ化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数ローカルで定義した&lt;code&gt;static&lt;/code&gt;変数の初期化を、スレッドセーフにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;その他様々なユーティリティ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/trailing_return_types.html&#34;&gt;戻り値の型を後置する関数宣言構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;戻り値の型を後ろに書けるようにすることで、パラメータオブジェクトを戻り値型の文脈で使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/static_assert.html&#34;&gt;コンパイル時アサート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に条件式が真であることを表明する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/raw_string_literals.html&#34;&gt;生文字列リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルにRプレフィックスを付けることで、エスケープシーケンスを無視する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/char16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-16とUTF-32の文字型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/utf8_string_literals.html&#34;&gt;UTF-8文字列リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char&lt;/code&gt;の文字列をUTF-8エンコーディングするプレフィックス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/attributes.html&#34;&gt;属性構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[attr]]&lt;/code&gt;構文による、クラス、関数、変数の属性指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alignas.html&#34;&gt;alignas&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメントを指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alignof.html&#34;&gt;alignof&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメントを取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;p&gt;ここでは、コア言語作業グループへ問題報告され、その解決策として導入された言語仕様の変更を解説する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/feature_test_macros.html&#34;&gt;機能テストマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++11 の機能がサポートされているかどうかをテストするためのマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/recursive_template_limit.html&#34;&gt;テンプレート再帰回数の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;17回から1024回に制限緩和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/dependent_name_specifier_outside_of_templates.html&#34;&gt;依存名に対する&lt;code&gt;typename&lt;/code&gt;と&lt;code&gt;template&lt;/code&gt;の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレート外でも&lt;code&gt;typename&lt;/code&gt;と&lt;code&gt;template&lt;/code&gt;を付けられるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/global_scope_syntax_in_nested_name_specifier.html&#34;&gt;入れ子名の指定にグローバルスコープ&lt;code&gt;::&lt;/code&gt;を付加することを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;struct ::A {};&lt;/code&gt;のように入れ子名を指定する際にグローバルスコープから指定できるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/earlier_declarated_array_bounds.html&#34;&gt;宣言時に要素数を指定した配列オブジェクトの、定義時の要素数を規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static&lt;/code&gt;メンバや&lt;code&gt;extern&lt;/code&gt;として宣言した配列を定義した際、宣言時に指定した要素数として定義されることが規定された&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/reserved_namespaces_for_posix.html&#34;&gt;POSIX用の名前空間を予約&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将来の標準化のためにPOSIX用の名前空間を予約し、ユーザーがその名前空間で機能を定義することを禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/extending_sizeof_to_apply_to_non_static_data_members_without_an_object.html&#34;&gt;&lt;code&gt;sizeof&lt;/code&gt;演算子にクラスの非静的メンバを、オブジェクトを作らずに指定できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof(T::data_member)&lt;/code&gt;のように指定して非静的メンバのサイズを取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/deprecation_of_the_register_keyword.html&#34;&gt;&lt;code&gt;register&lt;/code&gt;キーワードを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイラに使われなくなった最適化用の機能を非推奨化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/reference_collapsing.html&#34;&gt;参照への参照を折りたたむ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp;&lt;/code&gt;型に参照を足しても&lt;code&gt;T&amp;amp;&lt;/code&gt;となる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;C99互換機能&lt;/h3&gt;
&lt;p&gt;C99は、1999年に改訂され、ISO/IEC 9899:1999で標準規格化されたC言語バージョンの通称である。&lt;/p&gt;
&lt;p&gt;C++11では、参照するC言語の規格がC89からC99に変更となり、C99の言語機能が一部、C++に導入された。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/variadic_macros.html&#34;&gt;可変引数マクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;マクロで任意の数の引数を受け取る&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/pragma_operator.html&#34;&gt;Pragma演算子&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;処理系定義の機能を使用する単項演算子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/c99_predefined_macros.html&#34;&gt;定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C99互換で導入された定義済みマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/string_literal_concatenation.html&#34;&gt;文字列リテラルとワイド文字列リテラルの結合&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ワイド文字列定数として結合する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/long_long_type.html&#34;&gt;&lt;code&gt;long long&lt;/code&gt;型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;64ビット以上の大きさを持つ整数型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/func.html&#34;&gt;事前定義識別子&lt;code&gt;__func__&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;現在いる関数名が格納されている識別子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/trailing_comma_following_enumerator_list.html&#34;&gt;列挙子の末尾へのカンマ付加を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;末尾の列挙子の後ろにカンマを書くことが許可された&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/result_of_integer_division_and_modulo.html&#34;&gt;整数に対する除算と剰余算の丸め結果を規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;これまで実装定義だった整数の除算と剰余算に対する丸め方法を、標準で規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;固定長配列クラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;単方向リンクリストの実装である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ハッシュ表の連想コンテナである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_map.html&#34;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_set/unordered_set.html&#34;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;クラス、およびその重複を許可するバージョンを追加&lt;/li&gt;
&lt;li&gt;コンテナ全般がムーブセマンティクスに対応&lt;ul&gt;
&lt;li&gt;クラステンプレートのパラメータ&lt;code&gt;T&lt;/code&gt;が、コピー構築可能な型だけでなく、ムーブ構築のみ可能な型も受け付けるようになった&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push_back()&lt;/code&gt;や&lt;code&gt;insert()&lt;/code&gt;等の要素追加のためのメンバ関数が、新たな要素のコピーだけでなく、一時オブジェクトも受け取れて、ムーブで挿入ができるようになった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要素追加のためのメンバ関数として、クラステンプレートのパラメータ&lt;code&gt;T&lt;/code&gt;のコンストラクタ引数を受け取り、一時オブジェクトの生成コストを減らせるものが追加された。これらは、以下のように命名されたメンバ関数である：&lt;code&gt;emplace()&lt;/code&gt;、&lt;code&gt;emplace_back()&lt;/code&gt;、&lt;code&gt;emplace_front()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;コンテナのメモリアロケータが状態を持てるようになった&lt;/li&gt;
&lt;li&gt;初期化子リストでコンテナを初期化できるようになった&lt;/li&gt;
&lt;li&gt;初期化子リストをパラメータで受け取れるようにするためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;型情報型を連想コンテナのキーとして使用するための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/typeindex/type_index.html&#34;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;イテレータを進める関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/next.html&#34;&gt;std::next()&lt;/a&gt;&lt;/code&gt;、イテレータを逆に進める関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/prev.html&#34;&gt;std::prev()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;要素をムーブするイテレータとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/move_iterator.html&#34;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;先頭イテレータと末尾イテレータを取得する非メンバ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/begin.html&#34;&gt;std::begin()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/end.html&#34;&gt;std::end()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;イテレータ範囲が特定の条件を満たしているか調べる、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/all_of.html&#34;&gt;std::all_of()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/any_of.html&#34;&gt;std::any_of()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/none_of.html&#34;&gt;std::none_of&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件を満たしていない最初の要素を検索する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/find_if_not.html&#34;&gt;std::find_if_not()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定された数の要素をコピーする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/copy_n.html&#34;&gt;std::copy_n()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件を満たす要素のみをコピーする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/copy_if.html&#34;&gt;std::copy_if()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータ範囲の要素をムーブする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/move.html&#34;&gt;std::move()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/move_backward.html&#34;&gt;std::move_backward()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;新たな乱数ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に対応したイテレータ範囲のシャッフルアルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shuffle.html&#34;&gt;std::shuffle()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータ範囲がソート済みか調べる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/is_sorted.html&#34;&gt;std::is_sorted()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;2つの値の最小値を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/min.html&#34;&gt;std::min()&lt;/a&gt;&lt;/code&gt;、最大値を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/max.html&#34;&gt;std::max()&lt;/a&gt;&lt;/code&gt;に、初期化子リストによる可変引数版を追加&lt;/li&gt;
&lt;li&gt;最小値と最大値を同時に取得する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/minmax.html&#34;&gt;std::minmax()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/minmax_element.html&#34;&gt;std::minmax_element()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定された値から始まる整数列を生成する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/iota.html&#34;&gt;std::iota()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;メモリアロケータの実装をより容易にするために、コンテナとメモリアロケータの中間インタフェースとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スマートポインタの実装として、所有権共有方式の&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;クラスと、所有権専有方式の&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/unique_ptr.html&#34;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;従来のスマートポインタ&lt;code&gt;auto_ptr&lt;/code&gt;クラスを、非推奨とする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator&amp;amp;()&lt;/code&gt;がオーバーロードされていたとしても正しく変数のアドレスを取得する関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/addressof.html&#34;&gt;std::addressof()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;標準ライブラリ中の入力ストリーム演算子&lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;と出力ストリーム演算子&lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;がムーブセマンティクスに対応。ストリームの一時オブジェクトを受け取れるようになった&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UTF-16の文字列型&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::u16string&lt;/a&gt;&lt;/code&gt;、UTF-32の文字列型&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::u32string&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;UTF-8とUTF-16、UTF-8とUTF-32といった、マルチバイト文字とワイド文字列の相互変換を行うクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/locale/wstring_convert.html&#34;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値から文字列オブジェクトに変換する関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/to_string.html&#34;&gt;std::to_string()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/to_wstring.html&#34;&gt;std::to_wstring()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;文字列オブジェクトから数値に変換する、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/stoi.html&#34;&gt;std::stoi()&lt;/a&gt;&lt;/code&gt;や&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/stof.html&#34;&gt;std::stof()&lt;/a&gt;&lt;/code&gt;といった関数を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;関数ポインタと関数オブジェクトを統一的に扱えるクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;関数の引数を束縛して部分適用する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;std::bind()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;メンバ関数ポインタを関数オブジェクトにアダプトする関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;std::mem_fn()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;テンプレートに、明示的に左辺値参照を渡すための渡すためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;と、そのヘルパ関数である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/ref.html&#34;&gt;std::ref()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/cref.html&#34;&gt;std::cref()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ハッシュ表コンテナの追加にともない、オブジェクトのハッシュ値を計算する関数オブジェクト&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;ビット演算の関数オブジェクトとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bit_and.html&#34;&gt;std::bit_and&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bit_or.html&#34;&gt;std::bit_or&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bit_xor.html&#34;&gt;std::bit_xor&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;従来の関数オブジェクトアダプタ&lt;code&gt;std::unary_function&lt;/code&gt;、&lt;code&gt;std::binary_function&lt;/code&gt;、&lt;code&gt;std::mem_fun()&lt;/code&gt;、&lt;code&gt;std::mem_fun_ref()&lt;/code&gt;等を非推奨とする&lt;/li&gt;
&lt;li&gt;従来の関数バインダ&lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;等を非推奨とする&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;スレッドを管理するクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/thread.html&#34;&gt;std::thread&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッド間での排他制御を行うミューテックスの実装である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/mutex.html&#34;&gt;std::mutex&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/recursive_mutex.html&#34;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt;クラス等を追加&lt;ul&gt;
&lt;li&gt;ミューテックスの所有権放棄を自動的に行うためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/lock_guard.html&#34;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/unique_lock.html&#34;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;スレッドセーフに一度だけ処理を呼び出す関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/call_once.html&#34;&gt;std::call_once()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件変数の実装である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/condition_variable/condition_variable.html&#34;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/condition_variable/condition_variable_any.html&#34;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;Futureデザインパターンをサポートする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/future.html&#34;&gt;std::future&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/promise.html&#34;&gt;std::promise&lt;/a&gt;&lt;/code&gt;クラス、およびその補助機能を追加&lt;/li&gt;
&lt;li&gt;アトミック操作のライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic.html&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;汎用的なユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::swap()&lt;/code&gt;関数を、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;から&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に移動&lt;/li&gt;
&lt;li&gt;ムーブセマンティクスのために、左辺値を右辺値に変換する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/move.html&#34;&gt;std::move()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;引数転送のための関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward.html&#34;&gt;std::forward()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;が、それぞれの要素型のコンストラクタ引数を直接受け取れるようになった&lt;/li&gt;
&lt;li&gt;タプルの実装である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;SFINAEのために、型の値を取得する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/declval.html&#34;&gt;std::declval()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;時間ユーティリティライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;型特性ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;エラー報告&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OSのエラー値を扱うライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/system_error.html&#34;&gt;&amp;lt;system_error&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;正規表現ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正規表現ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/regex.html&#34;&gt;&amp;lt;regex&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ECMAScript、POSIX、AWK、grepなどの構文を切り替えて使用できるのが特徴。デフォルトではECMAScript&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;乱数ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;乱数ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;複数定義されている乱数生成器と分布アルゴリズムを、組み合わせて使用するのが特徴&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C互換ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ビット幅規定の整数型ライブラリである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstdint.html&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/cpp11&#34; target=&#34;_blank&#34;&gt;C++11 Overview - Standard C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>範囲for文 -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/range_based_for.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:lang/cpp11/range_based_for.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/range_based_for.md b/lang/cpp11/range_based_for.md
index 3ae95f0cc..f053c3af2 100644
--- a/lang/cpp11/range_based_for.md
+++ b/lang/cpp11/range_based_for.md
@@ -42,7 +42,7 @@ for (const auto&amp;amp; e : v) {
 
 
 ## 仕様
-範囲for文は配列または、`begin()`および`end()`で表される範囲内の全ての要素に対して、処理を実行する。
+範囲for文は配列または、`begin()`および`end()`で表されるイテレータ範囲に含まれる全ての要素に対して、処理を実行する。
 
 範囲for文は以下の構文を持つ：
 
@@ -54,7 +54,7 @@ for-range-declarationには変数宣言を書く。ここで宣言した変数
 
 for-range-initializerにはfor文が処理すべき範囲を表す値を書く。
 
-値の型が配列の場合、配列のサイズが分かるものでなければエラーとなる。値の型が配列以外（クラスなど）の場合、`begin()`と`end()`で範囲の先頭と終端が表せるものでなければエラーとなる。
+値の型が配列の場合、配列のサイズが分かるものでなければエラーとなる。値の型が配列以外（クラスなど）の場合、`begin()`と`end()`でイテレータ範囲の先頭と終端が表せるものでなければエラーとなる。
 
 語弊を恐れず言えば、メンバ関数に`begin()`および`end()`を持つクラスであれば、何でも範囲for文の範囲として指定できる。
 
@@ -86,7 +86,7 @@ C++11、C++14において、範囲for文は以下のように通常のfor文へ
 
 展開後に現れる変数名は仮のものであり、実際に変数として見えるわけではない。しかし、デバッガーにこれらの変数が現れることがある。
 
-begin-exprとend-exprの具体的な内容は、範囲として何を渡すかによって3通りに分かれる。いずれの場合も、begin-exprとend-exprは同じ型でなければならない。
+begin-exprとend-exprの具体的な内容は、イテレータ範囲として何を渡すかによって3通りに分かれる。いずれの場合も、begin-exprとend-exprは同じ型でなければならない。
 
 配列を範囲として渡したとき、以下のように展開される：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++14 -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/lang/cpp14.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:lang/cpp14.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++14&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++14とは、2014年12月に改訂され、ISO/IEC 14882:2014で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;前バージョンであるC++11からマイナーバージョンアップされ、小さな機能拡張が行われた。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++1yと呼ばれていた。前バージョンであるC++11が策定中、C++0xと呼ばれていたことから、「xの次」という意味で「y」が使われていた。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/binary_literals.html&#34;&gt;2進数リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2進数を表す&lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;プレフィックスを付けた数値リテラルの記述を可能とする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/return_type_deduction_for_normal_functions.html&#34;&gt;通常関数の戻り値型推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値型を&lt;code&gt;auto&lt;/code&gt;にすることで、&lt;code&gt;return&lt;/code&gt;文から戻り値の型を推論させる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/decltype_auto.html&#34;&gt;decltype(auto)&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;decltype&lt;/code&gt;の規則による変数の型推論&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/placeholder_type_in_trailing_return_type.html&#34;&gt;後置戻り値型をプレースホルダーにすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;戻り値の型を後置する関数宣言構文とラムダ式の戻り値型に&lt;code&gt;auto&lt;/code&gt;を使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/initialize_capture.html&#34;&gt;ラムダ式の初期化キャプチャ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャに代入構文を導入し、一つの変数に複数のキャプチャ方法を指定可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/generic_lambdas.html&#34;&gt;ジェネリックラムダ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式のパラメータを&lt;code&gt;auto&lt;/code&gt;にすることで、ジェネリックな関数呼び出し演算子を持つ関数オブジェクトを生成する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/variable_templates.html&#34;&gt;変数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数定義時のテンプレート指定を可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/relaxing_constraints_on_constexpr.html&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if&lt;/code&gt;文、&lt;code&gt;switch&lt;/code&gt;文による条件分岐の許可。&lt;br /&gt;&lt;code&gt;for&lt;/code&gt;文、&lt;code&gt;while&lt;/code&gt;文、&lt;code&gt;do-while&lt;/code&gt;文によるループの許可。&lt;br /&gt;&lt;code&gt;void&lt;/code&gt;戻り値型の許可&lt;br /&gt;初期化を伴う変数宣言の許可。&lt;br /&gt;変数書き換えの許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/member_initializers_and_aggregates.md.nolink&#34;&gt;宣言時のメンバ初期化を持つ型の集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;集成体において、宣言時に初期化されているメンバを持つことを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/brace_elision_in_array_temporary_initialization.html&#34;&gt;ネストする集成体初期化における波カッコ省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;一様初期化と初期化子リストを組み合わせた際、二重に波カッコが必要となっていた仕様を緩和し、波カッコを省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/deprecated_attr.html&#34;&gt;&lt;code&gt;[[deprecated]]&lt;/code&gt;属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非推奨の機能であることを示す属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/digit_separators.html&#34;&gt;数値リテラルの桁区切り文字&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;シングルクォーテーションで数値リテラルを桁区切りする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/sized_deallocation.html&#34;&gt;サイズ付きデアロケーション&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;サイズをとる&lt;code&gt;delete&lt;/code&gt;演算子のオーバーロードを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/clarifying_memory_allocation.html&#34;&gt;動的メモリ確保の省略の許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトの&lt;code&gt;::operator new&lt;/code&gt;による動的メモリ確保を省略したりまとめたりする事を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;p&gt;ここでは、コア言語作業グループへ問題報告され、その解決策として導入された言語仕様の変更を解説する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/feature_test_macros.html&#34;&gt;機能テストマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++14 の機能がサポートされているかどうかをテストするためのマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/no_whitespace_literal_operators.html&#34;&gt;リテラル演算子のスペースを省略可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator&#34;&#34;&lt;/code&gt;とサフィックス名の間にスペースを入力しなくてもよくなった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/nontype_template_parameters_of_type_nullptr_t.html&#34;&gt;&lt;code&gt;nullptr_t&lt;/code&gt;型の定数式を非型テンプレートパラメータとすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;nullptr_t&lt;/code&gt;型の値をテンプレート引数として渡せるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;順序付き連想コンテナのルックアップ処理で、一時オブジェクトが生成されるコストを抑える拡張が行われた&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/find.html&#34;&gt;std::map::find()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/count.html&#34;&gt;std::map::count()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/lower_bound.html&#34;&gt;std::map::lower_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/upper_bound.html&#34;&gt;std::map::upper_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/equal_range.html&#34;&gt;std::map::equal_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::map&lt;/code&gt;クラスのほか、&lt;code&gt;std::set&lt;/code&gt;、&lt;code&gt;std::multiset&lt;/code&gt;、&lt;code&gt;std::multimap&lt;/code&gt;の上記メンバ関数も対象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Forward Iteratorを値初期化した場合に、どこも指さないヌルイテレータになる、という規定が追加された(参照 : &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3644.pdf&#34; target=&#34;_blank&#34;&gt;N3644 Null Forward Iterators&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以下のアルゴリズムに、2つ目のイテレータ範囲の終端イテレータをパラメータにとるバージョンを追加。これにより、2つの範囲が同じ長さかを事前にユーザーがチェックする必要がなくなった&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/mismatch.html&#34;&gt;std::mismatch()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/equal.html&#34;&gt;std::equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/is_permutation.html&#34;&gt;std::is_permutation()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;乱数生成を行うアルゴリズム、&lt;code&gt;std::rand()&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/random_shuffle.html&#34;&gt;std::random_shuffle()&lt;/a&gt;&lt;/code&gt;を非推奨とする。&lt;code&gt;std::rand()&lt;/code&gt;の代わりに&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダで定義される乱数生成器と分布クラスを、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/random_shuffle.html&#34;&gt;std::random_shuffle()&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shuffle.html&#34;&gt;std::shuffle()&lt;/a&gt;&lt;/code&gt;を使用すること&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/unique_ptr.html&#34;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;を生成するヘルパ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_unique.html&#34;&gt;std::make_unique()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字列をクォート修飾する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iomanip/quoted.html&#34;&gt;std::quoted&lt;/a&gt;&lt;/code&gt;マニピュレータを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;汎用的なユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2つの値を入れ替える関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/exchange.html&#34;&gt;std::exchange()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;コンパイル時整数シーケンス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/integer_sequence.html&#34;&gt;std::integer_sequence&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;タプルを型の集合と見なし、型を指定して対応する値を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/get.html&#34;&gt;std::get()&lt;/a&gt;&lt;/code&gt;のオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの、メンバ型&lt;code&gt;type&lt;/code&gt;を定義するクラステンプレートに、エイリアステンプレート版を追加。そのバージョンには、&lt;code&gt;_t&lt;/code&gt;サフィックスが付く&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;リテラル演算子&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;の&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/op_s.html&#34;&gt;リテラル演算子&lt;code&gt;s&lt;/code&gt;&lt;/a&gt;を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#34;hello&#34;s&lt;/code&gt;は、文字コード未規定の&lt;code&gt;std::string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&#34;hello&#34;s&lt;/code&gt;は、文字コード未規定の&lt;code&gt;std::wstring&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u8&#34;hello&#34;s&lt;/code&gt;は、UTF-8文字コードの&lt;code&gt;std::string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&#34;hello&#34;s&lt;/code&gt;は、UTF-16文字コードの&lt;code&gt;std::u16string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U&#34;hello&#34;s&lt;/code&gt;は、UTF-32文字コードの&lt;code&gt;std::u32string&lt;/code&gt;オブジェクトを表すリテラル&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration.html&#34;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;の、各時間単位を表す、以下のリテラルを追加&lt;ul&gt;
&lt;li&gt;ナノ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_ns.html&#34;&gt;&lt;code&gt;ns&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;マイクロ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_us.html&#34;&gt;&lt;code&gt;us&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ミリ秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_ms.html&#34;&gt;&lt;code&gt;ms&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;秒単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_s.html&#34;&gt;&lt;code&gt;s&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_min.html&#34;&gt;&lt;code&gt;min&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;時単位を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration/op_h.html&#34;&gt;&lt;code&gt;h&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;の、各要素型を表す、以下のリテラルを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_i.html&#34;&gt;&lt;code&gt;i&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_if.html&#34;&gt;&lt;code&gt;if&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt;を表す&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/op_il.html&#34;&gt;&lt;code&gt;il&lt;/code&gt;リテラル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Readers-writer lockと呼ばれる、書き込みを行うユーザーが1人、読み込みを行うユーザーが複数いる状況で効率的に振る舞うミューテックスの実装として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/shared_mutex.html&#34;&gt;&amp;lt;shared_mutex&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/cpp14&#34; target=&#34;_blank&#34;&gt;C++14 Overview - Standard C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>畳み込み式 -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/folding_expressions.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:lang/cpp17/folding_expressions.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/folding_expressions.md b/lang/cpp17/folding_expressions.md
index ba37f5a0f..91dfaec80 100644
--- a/lang/cpp17/folding_expressions.md
+++ b/lang/cpp17/folding_expressions.md
@@ -234,7 +234,7 @@ auto res =  (std::string(args) + ...);
 
 ## 関連項目
 - [C++11 可変引数テンプレート](/lang/cpp11/variadic_templates.md)
-- [`std::accumulate`](/reference/numeric/accumulate.md) — イテレータの範囲について累積的に二項演算を行う
+- [`std::accumulate`](/reference/numeric/accumulate.md) — イテレータ範囲について累積的に二項演算を行う
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/all_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/all_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/all_of.md b/reference/algorithm/all_of.md
index 7d4047d14..ec04e3446 100644
--- a/reference/algorithm/all_of.md
+++ b/reference/algorithm/all_of.md
@@ -25,7 +25,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の全ての要素が条件を満たすかを判定する。
+イテレータ範囲`[first, last)`の全ての要素が条件を満たすかを判定する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/any_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/any_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/any_of.md b/reference/algorithm/any_of.md
index 6ac75cb0d..bed217753 100644
--- a/reference/algorithm/any_of.md
+++ b/reference/algorithm/any_of.md
@@ -25,12 +25,12 @@ namespace std {
 ```
 
 ## 概要
-範囲のいずれかの要素が条件を満たすかを判定する。
+イテレータ範囲`[first, last)`のいずれかの要素が条件を満たすかを判定する。
 
 
 ## 戻り値
-`[first,last)` 内のイテレータ `i` について `pred(*i)` が `true` になるような要素があれば`true`を返し、そうでなければ`false`を返す。
-`[first,last)`の範囲が空の場合は`false`を返す。
+イテレータ範囲`[first,last)` 内のイテレータ `i` について `pred(*i)` が `true` になるような要素があれば`true`を返し、そうでなければ`false`を返す。
+イテレータ範囲`[first,last)`が空の場合は`false`を返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/copy.md b/reference/algorithm/copy.md
index 0285d4f09..8ba431a17 100644
--- a/reference/algorithm/copy.md
+++ b/reference/algorithm/copy.md
@@ -27,11 +27,11 @@ namespace std {
 ```
 
 ## 概要
-指定された範囲の要素をコピーする。
+指定されたイテレータ範囲`[first, last)`の要素を出力イテレータにコピーする。
 
 
 ## 要件
-`result` は `[first,last)` の範囲に含まれてはならない。
+`result` はイテレータ範囲 `[first,last)` に含まれてはならない。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_backward -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/copy_backward.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/copy_backward.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/copy_backward.md b/reference/algorithm/copy_backward.md
index fc7c7a2ad..e28d07b41 100644
--- a/reference/algorithm/copy_backward.md
+++ b/reference/algorithm/copy_backward.md
@@ -20,11 +20,11 @@ namespace std {
 ```
 
 ## 概要
-指定された範囲の要素を後ろからコピーする。
+指定されたイテレータ範囲`[first, last)`の要素を、出力イテレータ範囲に後ろからコピーする。
 
 
 ## 要件
-`result` は `(first,last]` の範囲に含まれてはならない。
+`result` はイテレータ範囲 `(first,last]` に含まれてはならない。
 
 
 ## 効果
@@ -42,7 +42,7 @@ namespace std {
 
 
 ## 備考
-`last` が `[result - (last-first), result)` の範囲内にあるときには、`copy()` の代わりに `copy_backward()` を使うべきである。
+`last` がイテレータ範囲 `[result - (last-first), result)` に含まれる場合には、`copy()` の代わりに `copy_backward()` を使うべきである。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/copy_if.md b/reference/algorithm/copy_if.md
index a3d4d5eec..c6584609a 100644
--- a/reference/algorithm/copy_if.md
+++ b/reference/algorithm/copy_if.md
@@ -32,11 +32,11 @@ namespace std {
 ```
 
 ## 概要
-条件を満たす要素のみをコピーする。
+イテレータ範囲`[first, last)`のうち、条件を満たす要素のみを出力イテレータ範囲にコピーする。
 
 
 ## 要件
-`[first,last)` の範囲と、`[result,result + (last - first))` の範囲は重なっていてはならない。
+イテレータ範囲`[first,last)`と、イテレータ範囲`[result,result + (last - first))`は重なっていてはならない。
 
 
 ## 効果
@@ -44,7 +44,7 @@ namespace std {
 
 
 ## 戻り値
-コピー先の範囲の終端を返す。
+コピー先のイテレータ範囲の終端を返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/equal.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/equal.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/equal.md b/reference/algorithm/equal.md
index cfd70a295..1d5fc2195 100644
--- a/reference/algorithm/equal.md
+++ b/reference/algorithm/equal.md
@@ -86,16 +86,16 @@ namespace std {
 ```
 
 ## 概要
-2つの範囲を等値比較する。
+2つのイテレータ範囲を等値比較する。
 
-- (1) : 範囲`[first1, last1)`と範囲`[first2, first2 + (last1 - first1))`が等値かを判定する
+- (1) : イテレータ範囲`[first1, last1)`とイテレータ範囲`[first2, first2 + (last1 - first1))`が等値かを判定する
 - (2) : (1)の等値比較を任意の2引数関数オブジェクトで行う
-- (3) : 範囲`[first1, last1)`と範囲`[first2, last2)`が等値かを判定する
+- (3) : イテレータ範囲`[first1, last1)`とイテレータ範囲`[first2, last2)`が等値かを判定する
 - (4) : (3)の等値比較を任意の2引数関数オブジェクトで行う
 
-2つの範囲が異なる要素数であった場合、`false`を返す。
+2つのイテレータ範囲が異なる要素数であった場合、`false`を返す。
 
-2つの範囲が要素数および各要素が等値であった場合、`true`を返す。
+2つのイテレータ範囲が要素数および各要素が等値であった場合、`true`を返す。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/fill.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/fill.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/fill.md b/reference/algorithm/fill.md
index 8c50f137e..d37db4a8e 100644
--- a/reference/algorithm/fill.md
+++ b/reference/algorithm/fill.md
@@ -25,7 +25,7 @@ namespace std {
 ```
 
 ## 概要
-指定された値で出力の範囲に書き込む。
+イテレータ範囲`[first, last)`のすべての要素に指定された値を書き込む。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/fill_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/fill_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/fill_n.md b/reference/algorithm/fill_n.md
index 6f43b16fd..4cecdfdad 100644
--- a/reference/algorithm/fill_n.md
+++ b/reference/algorithm/fill_n.md
@@ -34,7 +34,7 @@ namespace std {
 ```
 
 ## 概要
-指定された値で出力の範囲に `n` 個を書き込む。
+イテレータ範囲`[first, first + n)`のすべての要素に指定された値を書き込む。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find_end.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/find_end.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find_end.md b/reference/algorithm/find_end.md
index 4c3d607ea..675a49353 100644
--- a/reference/algorithm/find_end.md
+++ b/reference/algorithm/find_end.md
@@ -52,7 +52,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の中から、特定のサブシーケンスを検索する。
+イテレータ範囲`[first1, last1)`の中から、特定のサブシーケンス`[first2, last2)`を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/find_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find_if.md b/reference/algorithm/find_if.md
index 0b73a788a..c3cb3a8ad 100644
--- a/reference/algorithm/find_if.md
+++ b/reference/algorithm/find_if.md
@@ -24,7 +24,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の中から、指定された条件を満たす最初の要素を検索する。
+イテレータ範囲`[first, last)`の中から、指定された条件を満たす最初の要素を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find_if_not.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/find_if_not.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find_if_not.md b/reference/algorithm/find_if_not.md
index 30dbf612c..352e17c24 100644
--- a/reference/algorithm/find_if_not.md
+++ b/reference/algorithm/find_if_not.md
@@ -25,7 +25,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の中から、指定された条件を満たさない最初の要素を検索する。
+イテレータ範囲`[first, last)`の中から、指定された条件を満たさない最初の要素を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/for_each.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/for_each.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/for_each.md b/reference/algorithm/for_each.md
index 9abf51cfe..5f705128b 100644
--- a/reference/algorithm/for_each.md
+++ b/reference/algorithm/for_each.md
@@ -24,7 +24,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の全ての要素に、指定された関数を適用する。
+イテレータ範囲`[first, last)`の全ての要素に、指定された関数を適用する。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/for_each_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/for_each_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/for_each_n.md b/reference/algorithm/for_each_n.md
index 3c2a8da39..b8f688506 100644
--- a/reference/algorithm/for_each_n.md
+++ b/reference/algorithm/for_each_n.md
@@ -28,7 +28,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の先頭N個の要素に、指定された関数を適用する。
+イテレータ範囲`[first, first + n)` (範囲の先頭N要素) のすべての要素に、指定された関数を適用する。
 
 
 ## 要件
@@ -37,7 +37,7 @@ namespace std {
 
 
 ## 効果
-範囲`[first, first + n)` 内の全てのイテレータ `i` に `f(*i)` という操作を行う。
+イテレータ範囲`[first, first + n)` 内の全てのイテレータ `i` に `f(*i)` という操作を行う。
 
 このアルゴリズムはその他のアルゴリズムと違い、関数 `f` の内部で `*i` の値を書き換えても構わない（もちろんイテレータの型が `mutable iterator` の要件を満たしている場合に限る）。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/generate.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/generate.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/generate.md b/reference/algorithm/generate.md
index 2059fc699..17aacb71a 100644
--- a/reference/algorithm/generate.md
+++ b/reference/algorithm/generate.md
@@ -24,15 +24,15 @@ namespace std {
 ```
 
 ## 概要
-出力の範囲へ関数の結果を書き込む。
+イテレータ範囲`[first, last)`に、引数なしの関数`gen`の結果を書き込む。
 
 
-## 要件
-`gen` は引数を取らないこと。
+## テンプレートパラメータ制約
+- `gen` は引数をとらないこと
 
 
 ## 効果
-`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
+イテレータ範囲`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/generate_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/generate_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/generate_n.md b/reference/algorithm/generate_n.md
index dc71f1e24..4d40bb1c4 100644
--- a/reference/algorithm/generate_n.md
+++ b/reference/algorithm/generate_n.md
@@ -33,16 +33,16 @@ namespace std {
 ```
 
 ## 概要
-出力の範囲へ関数の結果を `n` 個書き込む。
+イテレータ範囲`[first, first + n)` (範囲の先頭N要素) に関数`gen`の結果を書き込む。
 
 
-## 要件
+## テンプレートパラメータ制約
 - `gen` は引数をとらないこと。
-- `Size` は integral type に変換可能であること。
+- `Size` は整数型に変換可能であること。
 
 
 ## 効果
-`n` が 1 以上の場合、`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
+`n` が 1 以上の場合、イテレータ範囲`[first,last)` のそれぞれのイテレータについて関数オブジェクト `gen` を呼び出し、その戻り値を代入する。
 
 そうでない場合、何もしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>includes -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/includes.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/includes.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/includes.md b/reference/algorithm/includes.md
index aab15412b..82b393e2c 100644
--- a/reference/algorithm/includes.md
+++ b/reference/algorithm/includes.md
@@ -50,7 +50,9 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
+2つのソート済みイテレータ範囲`[first1, last1)`と`[first2, last2)`において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
+
+この関数は、イテレータ範囲`[first1, last1)`にイテレータ範囲`[first2, last2)`が含まれていれば`true`を返す。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/inplace_merge.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/inplace_merge.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/inplace_merge.md b/reference/algorithm/inplace_merge.md
index 8d75f70c6..72932b0df 100644
--- a/reference/algorithm/inplace_merge.md
+++ b/reference/algorithm/inplace_merge.md
@@ -32,19 +32,24 @@ namespace std {
 ```
 
 ## 概要
-2つの連続したソート済み範囲をマージする。
+2つの連続したソート済みイテレータ範囲`[first, middle)`と`[middle, last)`をマージする。
 
+この関数は、ソート済みイテレータ範囲`[first, middle)`と、ソート済み範囲`[middle, last)`のように大きいイテレータ範囲`[first, last)`内に2つのソート済みイテレータ範囲が含まれている場合に、それらをマージしてソートする。
 
-## 要件
-- `[first,middle)` と `[middle,last)` の範囲はそれぞれ `operator&amp;lt;` か `comp` でソートされていること。
+
+## テンプレートパラメータ制約
 - `BidirectionalIterator` は `ValueSwappable` の要件を満たしていること。
 - `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること。
 
 
+## 事前条件
+- イテレータ範囲`[first,middle)` と イテレータ範囲`[middle,last)` はそれぞれ `operator&amp;lt;` か `comp` でソートされていること。
+
+
 ## 効果
 `[first,middle)`, `[middle,last)` という、連続した２つの範囲をマージし、結果を `[first,last)` へ格納する。
 
-結果の範囲 `[first,last)` は昇順になる。つまり、`first` を除く `[first,last)` 内の全てのイテレータ `i` について、`*i &amp;lt; *(i - 1)` または `comp(*i, *(i - 1))` が `false` になる。
+結果のイテレータ範囲 `[first,last)` は昇順になる。つまり、`first` を除く `[first,last)` 内の全てのイテレータ `i` について、`*i &amp;lt; *(i - 1)` または `comp(*i, *(i - 1))` が `false` になる。
 
 
 ## 戻り値
@@ -68,7 +73,7 @@ int main()
 {
   std::vector&amp;lt;int&amp;gt; v = {1,4,5,  2,3,6};
 
-  // ソートされた2つの範囲をマージ
+  // ソートされた2つのイテレータ範囲をマージ
   std::inplace_merge(v.begin(), v.begin() + 3, v.end());
 
   std::for_each(v.begin(), v.end(), [](int x) {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_heap.md b/reference/algorithm/is_heap.md
index 9bce6b6fa..ac5d29bc5 100644
--- a/reference/algorithm/is_heap.md
+++ b/reference/algorithm/is_heap.md
@@ -38,7 +38,7 @@ namespace std {
 ```
 
 ## 概要
-範囲がヒープ化されているか判定する。
+イテレータ範囲`[first, last)`がヒープ化されているか判定する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap_until -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_heap_until.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_heap_until.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_heap_until.md b/reference/algorithm/is_heap_until.md
index a5c09417e..693f05478 100644
--- a/reference/algorithm/is_heap_until.md
+++ b/reference/algorithm/is_heap_until.md
@@ -44,7 +44,7 @@ namespace std {
 ```
 
 ## 概要
-範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
+イテレータ範囲`[first, last)`がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_partitioned -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_partitioned.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_partitioned.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_partitioned.md b/reference/algorithm/is_partitioned.md
index 5f08741d3..f1e7a758d 100644
--- a/reference/algorithm/is_partitioned.md
+++ b/reference/algorithm/is_partitioned.md
@@ -25,17 +25,16 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
+イテレータ範囲`[first, last)`が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
 
 
-## 要件
-`InputIterator`のvalue typeは `Predicate` の引数型へ変換可能でなければならない。
-
-つまり `pred(*first)` という式が有効でなければならない。
+## テンプレートパラメータ制約
+- `InputIterator`のvalue typeは `Predicate` の引数型へ変換可能でなければならない
+    - つまり `pred(*first)` という式が有効でなければならない
 
 
 ## 戻り値
-`[first,last)` が空、 または `[first,last)` が `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているなら `true` 、そうでなければ `false` を返す。
+イテレータ範囲`[first,last)` が空、 または `[first,last)` が `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているなら `true` 、そうでなければ `false` を返す。
 
 つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現するなら `true` を返す。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_permutation.md b/reference/algorithm/is_permutation.md
index 6eac4d907..bfab19d41 100644
--- a/reference/algorithm/is_permutation.md
+++ b/reference/algorithm/is_permutation.md
@@ -57,17 +57,17 @@ namespace std {
 ```
 
 ## 概要
-`first2` で始まる範囲を並べ替えたものが、`[first1, last1)` の範囲と一致するか判定する。
+`first2` で始まる範囲を並べ替えたものが、イテレータ範囲`[first1, last1)`と一致するか判定する。
 
 
-## 要件
+## テンプレートパラメータ制約
 - `decltype(*first1)` と `decltype(*first2)` の型が同じであること。
 - `BinaryPredicate` は同値関係を持っていること。
 
 
 ## 戻り値
 `last2` が与えられている形式の場合、`last1 - first1 != last2 - first2` であれば `false` を返す。  
-そうでなければ、`[first1, last1)` の範囲と `[first2, first2 + (last1 - first1))` の範囲を並び変えたもので、[`equal`](equal.md)`(first1, last1, first2)`、あるいは [`equal`](equal.md)`(first1, last1, first2, pred)` が `true` を返すようなものがあれば `true` を、そうでなければ `false` を返す。  
+そうでなければ、イテレータ範囲`[first1, last1)`とイテレータ範囲`[first2, first2 + (last1 - first1))`を並び変えたもので、[`equal`](equal.md)`(first1, last1, first2)`、あるいは [`equal`](equal.md)`(first1, last1, first2, pred)` が `true` を返すようなものがあれば `true` を、そうでなければ `false` を返す。  
 なお、実際に並べ替えが行われるわけではない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_sorted.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_sorted.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_sorted.md b/reference/algorithm/is_sorted.md
index 2627aedf8..e318ba717 100644
--- a/reference/algorithm/is_sorted.md
+++ b/reference/algorithm/is_sorted.md
@@ -38,7 +38,7 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲がソート済みか判定する。
+イテレータ範囲`[first, last)`がソート済みか判定する。
 
 ### 戻り値
 - (1) : [`is_sorted_until`](/reference/algorithm/is_sorted_until.md)`(first, last) == last`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/is_sorted_until.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/is_sorted_until.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/is_sorted_until.md b/reference/algorithm/is_sorted_until.md
index ac89b6381..01bda45f7 100644
--- a/reference/algorithm/is_sorted_until.md
+++ b/reference/algorithm/is_sorted_until.md
@@ -44,11 +44,11 @@ namespace std {
 ```
 
 ## 概要
-ソート済みか判定し、ソートされていない位置のイテレータを取得する
+イテレータ範囲`[first, last)`がソート済みか判定し、ソートされていない位置のイテレータを取得する
 
 
 ## 戻り値
-[`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、`[first,last]` の中でソートされている範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
+[`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、イテレータ範囲`[first,last]` の中でソートされているイテレータ範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/lexicographical_compare.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/lexicographical_compare.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/lexicographical_compare.md b/reference/algorithm/lexicographical_compare.md
index 9ded8eb18..b486aed5d 100644
--- a/reference/algorithm/lexicographical_compare.md
+++ b/reference/algorithm/lexicographical_compare.md
@@ -56,7 +56,8 @@ namespace std {
 ```
 
 ## 概要
-`[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
+2つのイテレータ範囲`[first1, last1)`と`[first2, last2)`を辞書式順序で比較する。
+
 このアルゴリズムは、コンテナの`operator&amp;lt;()`の実装で使用される。
 
 
@@ -71,7 +72,7 @@ return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
 
 
 ## 戻り値
-範囲`[first1, last1)`が、辞書式比較で範囲`[first2, last2)`より小さい場合`true`を返し、そうでなければ`false`を返す。
+イテレータ範囲`[first1, last1)`が、辞書式比較でイテレータ範囲`[first2, last2)`より小さい場合`true`を返し、そうでなければ`false`を返す。
 
 
 ## 計算量
@@ -81,7 +82,7 @@ return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
 ## 備考
 空のシーケンスは、空でないシーケンスより小さいと判断されるが、空のシーケンスに対しては小さくないと判断される。
 
-どちらかのシーケンスの横断が先に終わる場合(つまり、範囲の長さが合わない場合)、先に終わった方が小さいと判断される。
+どちらかのシーケンスの横断が先に終わる場合(つまり、イテレータ範囲の長さが合わない場合)、先に終わった方が小さいと判断される。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare_three_way -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/lexicographical_compare_three_way.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/lexicographical_compare_three_way.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/lexicographical_compare_three_way.md b/reference/algorithm/lexicographical_compare_three_way.md
index f0349739a..6897cc909 100644
--- a/reference/algorithm/lexicographical_compare_three_way.md
+++ b/reference/algorithm/lexicographical_compare_three_way.md
@@ -29,7 +29,8 @@ namespace std {
 
 ## 概要
 
-`[first1, last1)`および`[first2, last2)`の2つの範囲を[辞書式順序](lexicographical_compare.md)による三方比較によって比較する。
+2つのイテレータ範囲`[first1, last1)`と`[first2, last2)`を[辞書式順序](lexicographical_compare.md)による三方比較によって比較する。
+
 このアルゴリズムは、コンテナの`operator&amp;lt;=&amp;gt;()`の実装で使用される。
 
 
@@ -39,10 +40,10 @@ namespace std {
 
 ## 引数
 
-- `first1` -- 比較する1つ目の範囲の先頭のイテレータ。
-- `last1` -- 比較する1つ目の範囲の終端のイテレータ。
-- `first2` -- 比較する2つ目の範囲の先頭のイテレータ。
-- `last2` -- 比較する2つ目の範囲の終端のイテレータ。
+- `first1` -- 比較する1つ目のイテレータ範囲の先頭イテレータ。
+- `last1` -- 比較する1つ目のイテレータ範囲の終端イテレータ。
+- `first2` -- 比較する2つ目のイテレータ範囲の先頭イテレータ。
+- `last2` -- 比較する2つ目のイテレータ範囲の終端イテレータ。
 - `comp` -- 使用する三方比較をカスタマイズする関数オブジェクト。
 
 ## 効果
@@ -65,7 +66,7 @@ namespace std {
 ## 戻り値
 
 戻り値型となる比較カテゴリ型を`Cat`とすると、  
-範囲`[first1, last1)`が、辞書式比較で範囲`[first2, last2)`より大きい場合は`Cat::greator`を返し、小さい場合`Cat::less`を返し、等しいのならば`Cat::equivalent`を返す。
+イテレータ範囲`[first1, last1)`が、辞書式比較でイテレータ範囲`[first2, last2)`より大きい場合は`Cat::greator`を返し、小さい場合`Cat::less`を返し、等しいのならば`Cat::equivalent`を返す。
 
 ## 計算量
 
@@ -100,13 +101,13 @@ int main() {
 
   std::cout &amp;lt;&amp;lt; std::boolalpha;
 
-  //カスタマイズした比較による同じ長さの範囲の比較
+  //カスタマイズした比較による同じ長さのイテレータ範囲の比較
   {
     auto comp = std::lexicographical_compare_three_way(str1.begin(), str1.end(), str2.begin(), str2.end(), weak_comp);
     std::cout &amp;lt;&amp;lt; (comp == 0) &amp;lt;&amp;lt; std::endl;
   }
 
-  //デフォルトの比較による異なる長さの範囲の比較
+  //デフォルトの比較による異なる長さのイテレータ範囲の比較
   {
     auto comp = std::lexicographical_compare_three_way(str1.begin(), str1.end(), str3.begin(), str3.end());
     std::cout &amp;lt;&amp;lt; (comp &amp;gt; 0) &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/lower_bound.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/lower_bound.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/lower_bound.md b/reference/algorithm/lower_bound.md
index 5f458df8e..24bc996d4 100644
--- a/reference/algorithm/lower_bound.md
+++ b/reference/algorithm/lower_bound.md
@@ -34,9 +34,9 @@ namespace std {
 ```
 
 ## 概要
-指定された要素以上の値が現れる最初の位置のイテレータを取得する。
+イテレータ範囲`[first, last)`のうち、指定された要素以上の値が現れる最初の位置のイテレータを取得する。
 
-この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::equal_range()`](equal_range.md)関数を使用できる。
+この関数の用途としては、ソート済みイテレータ範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::equal_range()`](equal_range.md)関数を使用できる。
 
 
 ## 要件
@@ -45,11 +45,11 @@ namespace std {
 	- `comp` は 2 引数の関数オブジェクトで、結果の型は `bool` 型に変換可能であること。また、引数に非 `const` の関数を適用しないこと。
 	- `T` は `LessThanComparable` であること。
 	- `operator&amp;lt;` または `comp` は「[狭義の弱順序](../algorithm.md#strict-weak-ordering)」であること。
-	- 範囲 `[first, last)` は `operator&amp;lt;` または `comp` を基準として昇順に並んでいること。
+	- イテレータ範囲 `[first, last)` は `operator&amp;lt;` または `comp` を基準として昇順に並んでいること。
 - C++11 から  
 	- `first`、`last` は前方向イテレータの要件を満たすこと。
 	- `comp` は 2 引数の関数オブジェクトで、結果の型は `bool` 型に変換可能であること。また、引数に非 `const` の関数を適用しないこと。
-	- `[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
+	- イテレータ範囲`[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
 		つまり、`e &amp;lt; value` または `comp(e, value)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
 
 
@@ -103,7 +103,7 @@ int main()
   }
 
   // 基本的な用途
-  // ソート済み範囲から、特定の値を二分探索で見つける
+  // ソート済みイテレータ範囲から、特定の値を二分探索で見つける
   {
     std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
     std::sort(v.begin(), v.end());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/make_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/make_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/make_heap.md b/reference/algorithm/make_heap.md
index 915d67408..a57a55f69 100644
--- a/reference/algorithm/make_heap.md
+++ b/reference/algorithm/make_heap.md
@@ -26,11 +26,11 @@ namespace std {
 ```
 
 ## 概要
-範囲をヒープ化する。
+イテレータ範囲`[first, last)`をヒープ化する。
 
 
-## 要件
-`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+## テンプレートパラメータ制約
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/max_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/max_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/max_element.md b/reference/algorithm/max_element.md
index 6099b0efb..5b042cb16 100644
--- a/reference/algorithm/max_element.md
+++ b/reference/algorithm/max_element.md
@@ -32,12 +32,12 @@ namespace std {
 ```
 
 ## 概要
-`[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
+イテレータ範囲`[first, last)`のうち、最大要素を指す最初のイテレータを取得する。
 
 
 
 ## 戻り値
-`*j &amp;lt; *i`もしくは`comp(*j, *i)`の比較によって最大と判断された最初の要素を指すイテレータ
+`*j &amp;lt; *i`もしくは`comp(*j, *i)`の比較によって最大と判断された最初の要素を指すイテレータを返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/merge.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/merge.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/merge.md b/reference/algorithm/merge.md
index 09087bd18..824b2114a 100644
--- a/reference/algorithm/merge.md
+++ b/reference/algorithm/merge.md
@@ -65,20 +65,22 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲をマージする。
+2つのソート済みイテレータ範囲`[first1, last1)`と`[first2, last2)`をマージする。
 
 
-## 要件
+## 事前条件
 - `[first1,last1)` と `[first2,last2)` は `operator&amp;lt;` または `comp` でソートされていること。
-- 結果の範囲と入力の範囲は重なっていてはならない。
+- 結果のイテレータ範囲と入力のイテレータ範囲は重なっていてはならない。
 
 
 ## 効果
-`[first1,last1)` と `[first2,last2)` の２つの要素を全て `[result,result_last)` へコピーする。その際に、[`is_sorted`](is_sorted.md)`(result, result_last)` または [`is_sorted`](is_sorted.md)`(result, result_last, comp)` の条件を満たすようにコピーする（`result_last` は `result + (last1 - first1) + (last2 - first2)` とする）。
+イテレータ範囲`[first1,last1)`とイテレータ範囲`[first2,last2)` の２つの要素を全て `[result,result_last)` へコピーする。その際に、[`is_sorted`](is_sorted.md)`(result, result_last)` または [`is_sorted`](is_sorted.md)`(result, result_last, comp)` の条件を満たすようにコピーする（`result_last` は `result + (last1 - first1) + (last2 - first2)` とする）。
 
 
 ## 戻り値
-`result + (last1 - first1) + (last2 - first2)`
+```cpp
+return result + (last1 - first1) + (last2 - first2);
+```
 
 
 ## 計算量
@@ -89,7 +91,7 @@ namespace std {
 
 
 ## 備考
-この操作は安定である。つまり、各入力範囲内の要素の前後関係は保たれ、また、1 番目の範囲と 2 番目に等値の要素があった場合には、1 番目の範囲の要素の方が先に来る。
+この操作は安定である。つまり、各入力イテレータ範囲内の要素の前後関係は保たれ、また、1 番目の範囲と 2 番目に等値の要素があった場合には、1 番目の範囲の要素の方が先に来る。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/min_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/min_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/min_element.md b/reference/algorithm/min_element.md
index 59b85f788..53fe86498 100644
--- a/reference/algorithm/min_element.md
+++ b/reference/algorithm/min_element.md
@@ -32,11 +32,11 @@ namespace std {
 ```
 
 ## 概要
-`[first, last)`の範囲において、最小要素を指す最初のイテレータを取得する。
+イテレータ範囲`[first, last)`のうち、最小要素を指す最初のイテレータを取得する。
 
 
 ## 戻り値
-`*i &amp;lt; *j`もしくは`comp(*i, *j)`の比較によって最小と判断された最初の要素を指すイテレータ
+`*i &amp;lt; *j`もしくは`comp(*i, *j)`の比較によって最小と判断された最初の要素を指すイテレータを返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/minmax_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/minmax_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/minmax_element.md b/reference/algorithm/minmax_element.md
index a6527a3ab..793742cea 100644
--- a/reference/algorithm/minmax_element.md
+++ b/reference/algorithm/minmax_element.md
@@ -34,7 +34,9 @@ namespace std {
 * pair[link /reference/utility/pair.md]
 
 ## 概要
-`[first, last)` の範囲において、最小要素を指すイテレータと最大要素を指すイテレータの組を取得する。
+イテレータ範囲`[first, last)`のうち、最小要素を指すイテレータと最大要素を指すイテレータの組を取得する。
+
+この関数の戻り値となるイテレータの[`pair`](/reference/utility/pair.md)では、`first`に最小要素を指すイテレータ、`second`に最大要素を指すイテレータが代入される。
 
 
 ## 戻り値
@@ -92,7 +94,7 @@ minmax_element(ForwardIterator first, ForwardIterator last, Compare comp)
   // 結果用オブジェクト
   std::pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt; result(first, first);
 
-  // 範囲の要素数が 0 か 1 だったら、そのまま result を返す
+  // イテレータ範囲の要素数が 0 か 1 だったら、そのまま result を返す
   if (first != last &amp;amp;&amp;amp; ++first != last) {
     // 最初の 2 個を比較して、小さい方を .first に、大きい方を .second に設定
     if (comp(*first, *result.first))
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/mismatch.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/mismatch.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/mismatch.md b/reference/algorithm/mismatch.md
index 5fa0f9834..836f18368 100644
--- a/reference/algorithm/mismatch.md
+++ b/reference/algorithm/mismatch.md
@@ -90,7 +90,7 @@ namespace std {
 
 
 ## 概要
-2つのシーケンスが一致していない場所を検索する。
+2つのシーケンス`[first1, last1)`と`[first2, last2)`が一致していない位置を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/move.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/move.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/move.md b/reference/algorithm/move.md
index 3f4d632ee..ce9929e35 100644
--- a/reference/algorithm/move.md
+++ b/reference/algorithm/move.md
@@ -29,15 +29,15 @@ namespace std {
 ```
 
 ## 概要
-指定された範囲の要素をムーブする。
+イテレータ範囲`[first, last)`の要素を出力イテレータ範囲にムーブする。
 
 
-## 要件
-`result` は `[first,last)` の範囲に含まれてはならない。
+## 事前条件
+`result` はイテレータ範囲`[first,last)`に含まれてはならない。
 
 
 ## 効果
-`[first,last)` 内の要素を、それぞれ `[result,result + (last - first))` へムーブする。
+イテレータ範囲`[first,last)` 内の要素を、それぞれ出力イテレータ範囲`[result,result + (last - first))` へムーブする。
 
 ムーブは `first` から順番に行い、0 以上 `last - first` 未満であるそれぞれの `n` について、`*(result + n) = std::move(*(first + n))` を行う。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_backward -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/move_backward.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/move_backward.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/move_backward.md b/reference/algorithm/move_backward.md
index 4a912d3b1..693928b9c 100644
--- a/reference/algorithm/move_backward.md
+++ b/reference/algorithm/move_backward.md
@@ -21,15 +21,15 @@ namespace std {
 ```
 
 ## 概要
-指定された範囲の要素を後ろからムーブする。
+イテレータ範囲`[first, last)`の要素を出力イテレータ範囲に後ろからムーブする。
 
 
-## 要件
-`result` は `(first,last]` の範囲に含まれてはならない。
+## 事前条件
+- `result` はイテレータ範囲`(first,last]` に含まれてはならない
 
 
 ## 効果
-`[first,last)` 内にある要素を、それぞれ `[result - (last-first),result)` へムーブする。
+イテレータ範囲`[first,last)` 内にある要素を、それぞれ出力イテレータ範囲`[result - (last-first),result)` へムーブする。
 
 ムーブは `last - 1` から順番に行い、1 以上 `last - first` 以下であるそれぞれの `n` について、`*(result - n) = std::move(*(last - n))` を行う。
 
@@ -68,7 +68,7 @@ int main() {
   std::move_backward(v.begin(), v.begin() + 3, v.end());
 
   // 以下のコードだと期待した結果にならないことを確認しよう。
-  // 移動元の後方と移動先の前方で範囲が重なっている場合は、move_backwardを使わないといけない
+  // 移動元の後方と移動先の前方でイテレータ範囲が重なっている場合は、move_backwardを使わないといけない
   // std::move(v.begin(), v.begin() + 3, v.begin() + 2);
 
   std::for_each(v.begin(), v.end(), &amp;amp;print);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>next_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/next_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/next_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/next_permutation.md b/reference/algorithm/next_permutation.md
index 0f1ebaac2..c1938dfe8 100644
--- a/reference/algorithm/next_permutation.md
+++ b/reference/algorithm/next_permutation.md
@@ -26,21 +26,23 @@ namespace std {
 ```
 
 ## 概要
-与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその次の順列を生成する。
+与えられた時点のイテレータ範囲`[first, last)`を起点の順列として、辞書順によるその次の順列を生成する。
 
 
-## 要件
+## テンプレートパラメータ制約
 `BidriectionalIterator`が`ValueSwappable`の要件を満たしていること。
 
 
 ## 効果
-`[first, last)`の範囲を次の順列に変換する。
+イテレータ範囲`[first, last)`の範囲を次の順列に変換する。
+
 `operator&amp;lt;`または`comp`によって辞書順に並んでいる全ての順列の集合があると仮定すると、次の順列が発見される。
 
 順列の辞書順とは、同じ長さ`N`の順列`a, b`があった時、その最上位の項から見た時に`ai != bi`となる最初の`i`番目の項について、`ai &amp;lt; bi`（もしくは`comp(ai, bi) == true`）となる時に`a &amp;lt; b`とするように定めた順序のことである。例えばこれは、各項（`ai, bi`）が`0 ~ 9`の数であるとすれば、それらをそのまま並べて構成した数の通常の大小関係に等しい。
 
 辞書順による次の順列とは、現在の順列（`[first, last)`）よりも（上記の意味の順序で）大きい順列のうち取り得る最小のもののことである。
 
+
 ## 戻り値
 次の順列が存在する場合は`true`を返し、そうでなければ`false`を返す。
 
@@ -50,8 +52,9 @@ namespace std {
 
 
 ## 備考
-全ての順列を取得したい場合は、この関数に最初に与える範囲が、昇順にソート済みになっていること。  
-順列の長さを`N`（`N = last - first`）とすれば、そのような順列は`N!`個存在する。
+- 全ての順列を取得したい場合は、この関数に最初に与えるイテレータ範囲が、昇順にソート済みになっていること
+    - 順列の長さを`N`（`N = last - first`）とすれば、そのような順列は`N!`個存在する
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/none_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/none_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/none_of.md b/reference/algorithm/none_of.md
index 09a9ab168..4af4718ed 100644
--- a/reference/algorithm/none_of.md
+++ b/reference/algorithm/none_of.md
@@ -25,11 +25,11 @@ namespace std {
 ```
 
 ## 概要
-範囲の全ての要素が条件を満たさないかを判定する。
+イテレータ範囲`[first, last)`の全ての要素が条件を満たさないかを判定する。
 
 
 ## 戻り値
-`[first,last)` が空であったり、`[first,last)` 内の全てのイテレータ `i` について `pred(*i)` が `false` である場合は `true` を返し、そうでない場合は `false` を返す。
+イテレータ範囲`[first,last)` が空であったり、イテレータ範囲`[first,last)` 内の全てのイテレータ `i` について `pred(*i)` が `false` である場合は `true` を返し、そうでない場合は `false` を返す。
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/nth_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/nth_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/nth_element.md b/reference/algorithm/nth_element.md
index 8050f7f4b..6c0ddf375 100644
--- a/reference/algorithm/nth_element.md
+++ b/reference/algorithm/nth_element.md
@@ -45,13 +45,13 @@ namespace std {
 ## 概要
 基準となる要素よりも小さい要素が前に来るよう並べ替える。
 
-この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
+この関数はイテレータ範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半のイテレータ範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、そのイテレータ範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
 
-ある範囲に対して部分的な並び替えを行う場合、[`partial_sort()`](partial_sort.md)を使用する。また範囲全体に対して並び替えを行う場合、[`sort()`](sort.md)を使用する。
+あるイテレータ範囲に対して部分的な並び替えを行う場合は、[`partial_sort()`](partial_sort.md)を使用する。また範囲全体に対して並び替えを行う場合は、[`sort()`](sort.md)を使用する。
 
 
-## 要件
-`RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partial_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partial_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partial_sort.md b/reference/algorithm/partial_sort.md
index e09f81350..4c0d67336 100644
--- a/reference/algorithm/partial_sort.md
+++ b/reference/algorithm/partial_sort.md
@@ -43,18 +43,19 @@ namespace std {
 ```
 
 ## 概要
-範囲を部分的にソートし、先頭 `N` 個を順に並んだ状態にする。`N` は `middle - first` で決まる。
+イテレータ範囲`[first, last)`を部分的にソートし、先頭 `N` 個を順に並んだ状態にする。`N` は `middle - first` で決まる。
 
 この関数は、「売り上げランキング トップ1位から10位まで」のように、全体ではなく最高順位から途中までの順位がわかればよい状況で、全体を並び替える[`sort()`](sort.md)関数の代わりに使用できる。
 
 なお、トップ10がどれかわかれば十分である（1位から10位までは順不同でよい）ような場合、[`nth_element()`](nth_element.md)が使用できる。
 
-## 要件
-`RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
-`[first,last)` にある要素の中から、`middle - first` 個の要素をソート済みの状態で `[first,middle)` に配置する。残りの `[middle,last)` にある要素は unspecified order に配置される。
+イテレータ範囲`[first,last)`にある要素の中から、`middle - first` 個の要素をソート済みの状態で `[first,middle)` に配置する。残りの `[middle,last)` にある要素は未規定の順序に配置される。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partial_sort_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partial_sort_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partial_sort_copy.md b/reference/algorithm/partial_sort_copy.md
index 7695e6f5e..f70f56d01 100644
--- a/reference/algorithm/partial_sort_copy.md
+++ b/reference/algorithm/partial_sort_copy.md
@@ -56,15 +56,15 @@ namespace std {
 ```
 
 ## 概要
-範囲を部分的にソートした結果を他の範囲にコピーする
+イテレータ範囲`[first, last)`を部分的にソートした結果を他の範囲`[result_first, result_last)`にコピーする。
 
 
-## 要件
-`RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*result_first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*result_first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
-`[first,last)` にある要素の中から、[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` 個の要素をソート済みの状態で `[result_first,result_first +` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first))` に配置する。
+イテレータ範囲`[first,last)` にある要素の中から、[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` 個の要素をソート済みの状態で `[result_first,result_first +` [`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first))` に配置する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partition.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partition.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partition.md b/reference/algorithm/partition.md
index 0d4e57d0c..f58de2d53 100644
--- a/reference/algorithm/partition.md
+++ b/reference/algorithm/partition.md
@@ -33,7 +33,7 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
+イテレータ範囲`[first, last)`を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partition_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partition_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partition_copy.md b/reference/algorithm/partition_copy.md
index 8373da620..adf6fc812 100644
--- a/reference/algorithm/partition_copy.md
+++ b/reference/algorithm/partition_copy.md
@@ -45,16 +45,21 @@ namespace std {
 * pair[link /reference/utility/pair.md]
 
 ## 概要
-与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする。
+イテレータ範囲`[first, last)`を条件を満たすか満たさないかで、2つの出力範囲へ分けてコピーする。
 
+この関数は、入力のイテレータ範囲のうち、条件を満たす要素を出力イテレータ範囲`out_true`、条件を満たさない要素を出力イテレータ範囲`out_false`にコピーする。
 
-## 要件
-- `InputIterator` の value type は `Assignable` で、`out_true` と `out_false` の `OutputIterator` へ書き込み可能で、`Predicate` の argument type へ変換可能でなければならない。
-- 入力範囲は出力範囲のどちらとも重なっていてはならない。
+
+## テンプレートパラメータ制約
+- `InputIterator` の value type は `Assignable` で、`out_true` と `out_false` の `OutputIterator` へ書き込み可能で、`Predicate` の引数型へ変換可能であること
+
+
+## 事前条件
+- 入力範囲は出力範囲のどちらとも重なっていてはならない
 
 
 ## 効果
-`[first,last)` 内にあるそれぞれのイテレータ `i` について、`pred(*i)` が `true` なら `*i` を `out_true` へコピーし、そうでない場合は `out_false` へコピーする。
+イテレータ範囲`[first,last)` 内にあるそれぞれのイテレータ `i` について、`pred(*i)` が `true` なら `*i` を `out_true` へコピーし、そうでない場合は `out_false` へコピーする。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_point -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/partition_point.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/partition_point.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/partition_point.md b/reference/algorithm/partition_point.md
index 31c83e155..433353398 100644
--- a/reference/algorithm/partition_point.md
+++ b/reference/algorithm/partition_point.md
@@ -21,12 +21,15 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る。
+イテレータ範囲`[first, last)`から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る。
 
 
-## 要件
-- `ForwardIterator` の value type は `Predicate` の argument type へ変換可能でなければならない。
-- `[first,last)` は `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現してなければならない。
+## テンプレートパラメータ制約
+- `ForwardIterator` の value type は `Predicate` の引数型へ変換可能であること
+
+
+## 事前条件
+- イテレータ範囲`[first,last)` は `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現してなければならない
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pop_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/pop_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/pop_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/pop_heap.md b/reference/algorithm/pop_heap.md
index 771c760b5..56cb4179d 100644
--- a/reference/algorithm/pop_heap.md
+++ b/reference/algorithm/pop_heap.md
@@ -26,13 +26,16 @@ namespace std {
 ```
 
 ## 概要
-ヒープ化された範囲の先頭と末尾を入れ替え、ヒープ範囲を作り直す
+ヒープ化されたイテレータ範囲`[first, last)`の先頭と末尾を入れ替え、ヒープ範囲を作り直す
 
 
-## 要件
-- `[first,last)` は空でない heap でなければならない。
-- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+
+
+## 事前条件
+- `[first,last)` は空でないヒープであること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>prev_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/prev_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/prev_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/prev_permutation.md b/reference/algorithm/prev_permutation.md
index e6f0f03d7..dbdea5b98 100644
--- a/reference/algorithm/prev_permutation.md
+++ b/reference/algorithm/prev_permutation.md
@@ -34,7 +34,7 @@ namespace std {
 
 
 ## 効果
-`[first, last)`の範囲を前の順列に変換する。
+イテレータ範囲`[first, last)`を前の順列に変換する。
 
 `operator&amp;lt;`または`comp`によって辞書順に並んでいる全ての順列の集合があると仮定すると、前の順列が発見される。
 
@@ -48,7 +48,7 @@ namespace std {
 
 
 ## 備考
-全ての順列を取得したい場合は、この関数に最初に与える範囲が、降順にソート済みになっていること。
+全ての順列を取得したい場合は、この関数に最初に与えるイテレータ範囲が、降順にソート済みになっていること。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>push_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/push_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/push_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/push_heap.md b/reference/algorithm/push_heap.md
index 9395576cb..3e1cdf5f7 100644
--- a/reference/algorithm/push_heap.md
+++ b/reference/algorithm/push_heap.md
@@ -26,16 +26,21 @@ namespace std {
 ```
 
 ## 概要
-ヒープ化された範囲に要素を追加する
+ヒープ化されたイテレータ範囲`[first, last - 1)`に要素を追加する。
 
+この関数は、イテレータ範囲の末尾要素`*(last - 1)`を、範囲全体がヒープとなるよう配置し直す。
 
-## 要件
-- `[first,last - 1)` は有効な heap である必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+
+## テンプレートパラメータ制約
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+
+
+## 事前条件
+- `[first,last - 1)` は有効なヒープであること
 
 
 ## 効果
-`last - 1` の値を、`[first,last)` が有効な heap となるように配置する
+`last - 1` の値を、`[first,last)` が有効なヒープとなるように配置する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>random_shuffle -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/random_shuffle.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/random_shuffle.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/random_shuffle.md b/reference/algorithm/random_shuffle.md
index df449d0d5..fc8e3c332 100644
--- a/reference/algorithm/random_shuffle.md
+++ b/reference/algorithm/random_shuffle.md
@@ -27,7 +27,7 @@ namespace std {
 
 
 ## 概要
-`[first,last)` のそれぞれの要素を同じ確率で並び替える。
+イテレータ範囲`[first,last)`のそれぞれの要素を同じ確率で並び替える。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_find -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
index 2261d308b..61184e75b 100644
--- a/reference/algorithm/ranges_adjacent_find.md
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -6,11 +6,20 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr I adjacent_find(I first, S last, Pred pred = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;,
+            projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr I
+    adjacent_find(I first, S last, Pred pred = {}, Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});           // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -27,8 +36,8 @@ namespace std::ranges {
 ## 概要
 隣接する要素で条件を満たしている最初の要素を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_all_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_all_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_all_of.md b/reference/algorithm/ranges_all_of.md
index 730b223ea..f7e7fa8d9 100644
--- a/reference/algorithm/ranges_all_of.md
+++ b/reference/algorithm/ranges_all_of.md
@@ -6,11 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool all_of(I first, S last, Pred pred, Proj proj = {}); // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool all_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    all_of(I first, S last, Pred pred, Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    all_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -23,8 +30,8 @@ namespace std::ranges {
 ## 概要
 範囲の全ての要素が条件を満たすかを判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_any_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_any_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_any_of.md b/reference/algorithm/ranges_any_of.md
index ec433feda..ef983c43d 100644
--- a/reference/algorithm/ranges_any_of.md
+++ b/reference/algorithm/ranges_any_of.md
@@ -6,11 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool any_of(I first, S last, Pred pred, Proj proj = {}); // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool any_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    any_of(I first, S last, Pred pred, Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    any_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -23,8 +30,8 @@ namespace std::ranges {
 ## 概要
 範囲のいずれかの要素が条件を満たすかを判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clamp -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_clamp.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_clamp.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_clamp.md b/reference/algorithm/ranges_clamp.md
index 732d1e6da..a4098951c 100644
--- a/reference/algorithm/ranges_clamp.md
+++ b/reference/algorithm/ranges_clamp.md
@@ -6,9 +6,11 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr const T&amp;amp; clamp(const T&amp;amp; v, const T&amp;amp; lo, const T&amp;amp; hi, Comp comp = {}, Proj proj = {});
+  template &amp;lt;class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp;
+    clamp(const T&amp;amp; v, const T&amp;amp; lo, const T&amp;amp; hi, Comp comp = {}, Proj proj = {}); // (1) C++20
 }
 ```
 * identity[link /reference/functional/identity.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy.md b/reference/algorithm/ranges_copy.md
index d59127a00..2e773767f 100644
--- a/reference/algorithm/ranges_copy.md
+++ b/reference/algorithm/ranges_copy.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
-  constexpr copy_result&amp;lt;I, O&amp;gt; copy(I first, S last, O result);            // (1)
+  constexpr copy_result&amp;lt;I, O&amp;gt;
+    copy(I first, S last, O result); // (1) C++20
 
-  template&amp;lt;input_range R, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_range R,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-  constexpr copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt; copy(R&amp;amp;&amp;amp; r, O result); // (2)
+  constexpr copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    copy(R&amp;amp;&amp;amp; r, O result);           // (2) C++20
 }
 ```
 * copy_result[link ranges_in_out_result.md]
@@ -27,8 +32,8 @@ namespace std::ranges {
 ## 概要
 指定された範囲の要素をコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_backward -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_backward.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_copy_backward.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_backward.md b/reference/algorithm/ranges_copy_backward.md
index 653eaa176..23684cd66 100644
--- a/reference/algorithm/ranges_copy_backward.md
+++ b/reference/algorithm/ranges_copy_backward.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, bidirectional_iterator I2&amp;gt;
+  template &amp;lt;bidirectional_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            bidirectional_iterator I2&amp;gt;
     requires indirectly_copyable&amp;lt;I1, I2&amp;gt;
-  constexpr copy_backward_result&amp;lt;I1, I2&amp;gt; copy_backward(I1 first, S1 last, I2 result);       // (1)
+  constexpr copy_backward_result&amp;lt;I1, I2&amp;gt;
+    copy_backward(I1 first, S1 last, I2 result); // (1) C++20
 
-  template&amp;lt;bidirectional_range R, bidirectional_iterator I&amp;gt;
+  template &amp;lt;bidirectional_range R,
+            bidirectional_iterator I&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
-  constexpr copy_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt; copy_backward(R&amp;amp;&amp;amp; r, I result); // (2)
+  constexpr copy_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+    copy_backward(R&amp;amp;&amp;amp; r, I result);              // (2) C++20
 }
 ```
 * copy_backward_result[link ranges_in_out_result.md]
@@ -26,8 +31,8 @@ namespace std::ranges {
 ## 概要
 指定された範囲の要素を後ろからコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_if.md b/reference/algorithm/ranges_copy_if.md
index 68437521d..228372a26 100644
--- a/reference/algorithm/ranges_copy_if.md
+++ b/reference/algorithm/ranges_copy_if.md
@@ -6,13 +6,22 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
-  constexpr copy_if_result&amp;lt;I, O&amp;gt; copy_if(I first, S last, O result, Pred pred, Proj proj = {});            // (1)
+  constexpr copy_if_result&amp;lt;I, O&amp;gt;
+    copy_if(I first, S last, O result, Pred pred, Proj proj = {}); // (1) C++20
 
-  template&amp;lt;input_range R, weakly_incrementable O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-  constexpr copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt; copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {}); // (2)
+  constexpr copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {});           // (2) C++20
 }
 ```
 * copy_if_result[link ranges_in_out_result.md]
@@ -29,8 +38,9 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素のみをコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 `[first,last)` の範囲と、`[result,result + (last - first))` の範囲は重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_count.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 49d338d93..b8977916e 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -6,13 +6,20 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr iter_difference_t&amp;lt;I&amp;gt; count(I first, S last, const T&amp;amp; value, Proj proj = {}); // (1)
+  constexpr iter_difference_t&amp;lt;I&amp;gt;
+    count(I first, S last, const T&amp;amp; value, Proj proj = {}); // (1) C++20
 
-  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr range_difference_t&amp;lt;R&amp;gt; count(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});          // (2)
+  constexpr range_difference_t&amp;lt;R&amp;gt;
+    count(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});           // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -29,8 +36,8 @@ namespace std::ranges {
 ## 概要
 指定された値と等値な要素の数を数える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_count_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 2cf414f54..c7510032d 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -6,11 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr iter_difference_t&amp;lt;I&amp;gt; count_if(I first, S last, Pred pred, Proj proj = {}); // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr range_difference_t&amp;lt;R&amp;gt; count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});          // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt;
+    count_if(I first, S last, Pred pred, Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt;
+    count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -27,8 +34,8 @@ namespace std::ranges {
 ## 概要
 条件を満たしている要素の数を数える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ends_with -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_ends_with.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_ends_with.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_ends_with.md b/reference/algorithm/ranges_ends_with.md
index 99ea4bd30..e5cd294ea 100644
--- a/reference/algorithm/ranges_ends_with.md
+++ b/reference/algorithm/ranges_ends_with.md
@@ -6,17 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires (forward_iterator&amp;lt;I1&amp;gt; || sized_sentinel_for&amp;lt;S1, I1&amp;gt;) &amp;amp;&amp;amp;
              (forward_iterator&amp;lt;I2&amp;gt; || sized_sentinel_for&amp;lt;S2, I2&amp;gt;) &amp;amp;&amp;amp;
              indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr bool
+    ends_with(I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires (forward_range&amp;lt;R1&amp;gt; || sized_range&amp;lt;R1&amp;gt;) &amp;amp;&amp;amp;
              (forward_range&amp;lt;R2&amp;gt; || sized_range&amp;lt;R2&amp;gt;) &amp;amp;&amp;amp;
              indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool ends_with(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+  constexpr bool
+    ends_with(R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              Pred pred = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -34,8 +56,8 @@ namespace std::ranges {
 ## 概要
 シーケンスの末尾が指定されたシーケンスと一致するかを調べる
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_equal.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
index 13b23e4d8..57026ce10 100644
--- a/reference/algorithm/ranges_equal.md
+++ b/reference/algorithm/ranges_equal.md
@@ -6,13 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr bool
+    equal(I1 first1,
+          S1 last1,
+          I2 first2,
+          S2 last2,
+          Pred pred = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool equal(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr bool
+    equal(R1&amp;amp;&amp;amp; r1,
+          R2&amp;amp;&amp;amp; r2,
+          Pred pred = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -30,8 +52,8 @@ namespace std::ranges {
 ## 概要
 2つの範囲を等値比較する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 2つの範囲の要素数および各要素が等値であった場合、`true`を返す。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_equal_range.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index 72e98876f..a3a94c713 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; equal_range(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; equal_range(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    equal_range(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    equal_range(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -30,6 +44,10 @@ namespace std::ranges {
 ## 概要
 指定した値と等しい範囲を取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
+
 ## 事前条件
 `[first,last)` の要素 `e` は `e &amp;lt; value` および `!(value &amp;lt; e)` 、あるいは `comp(e, value)` および `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_fill.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill.md b/reference/algorithm/ranges_fill.md
index 2eddb09d0..cf639f76f 100644
--- a/reference/algorithm/ranges_fill.md
+++ b/reference/algorithm/ranges_fill.md
@@ -6,13 +6,16 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O, sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
-    constexpr O fill(O first, S last, const T&amp;amp; value);
+  template &amp;lt;class T,
+            output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
+            sentinel_for&amp;lt;O&amp;gt; S&amp;gt;
+  constexpr O
+    fill(O first, S last, const T&amp;amp; value); // (1) C++20
 
-  // (2)
-  template&amp;lt;class T, output_range&amp;lt;const T&amp;amp;&amp;gt; R&amp;gt;
-    constexpr borrowed_iterator_t&amp;lt;R&amp;gt; fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);
+  template &amp;lt;class T,
+            output_range&amp;lt;const T&amp;amp;&amp;gt; R&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    fill(R&amp;amp;&amp;amp; r, const T&amp;amp; value);           // (2) C++20
 
 }
 ```
@@ -24,8 +27,8 @@ namespace std::ranges {
 ## 概要
 指定された値で出力の範囲に書き込む。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_fill_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill_n.md b/reference/algorithm/ranges_fill_n.md
index 75b9209e0..4916416db 100644
--- a/reference/algorithm/ranges_fill_n.md
+++ b/reference/algorithm/ranges_fill_n.md
@@ -7,7 +7,8 @@
 ```cpp
 namespace std::ranges {
   template&amp;lt;class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O&amp;gt;
-    constexpr O fill_n(O first, iter_difference_t&amp;lt;O&amp;gt; n, const T&amp;amp; value);
+  constexpr O
+    fill_n(O first, iter_difference_t&amp;lt;O&amp;gt; n, const T&amp;amp; value); // (1) C++20
 }
 ```
 * output_iterator[link /reference/iterator/output_iterator.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 0d20a1b04..d7d1df6a9 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr I find(I first, S last, const T&amp;amp; value, Proj proj = {});
-
-  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+  constexpr I
+    find(I first,
+         S last,
+         const T&amp;amp; value,
+         Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    find(R&amp;amp;&amp;amp; r,
+         const T&amp;amp; value,
+         Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -28,8 +40,8 @@ namespace std::ranges {
 ## 概要
 指定された値を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find_end.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
index fb67c4655..758502647 100644
--- a/reference/algorithm/ranges_find_end.md
+++ b/reference/algorithm/ranges_find_end.md
@@ -6,21 +6,43 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;forward_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            forward_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt;
+    find_end(I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;forward_range R1,
+            forward_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; find_end(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt;
+    find_end(R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (2) C++20
 }
 ```
 
 ## 概要
 範囲の中から、特定のサブシーケンスを検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index c71d9979b..d91734951 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -6,13 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            forward_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr I1
+    find_first_of(I1 first1,
+                  S1 last1,
+                  I2 first2,
+                  S2 last2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            forward_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; find_first_of(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt;
+    find_first_of(R1&amp;amp;&amp;amp; r1,
+                  R2&amp;amp;&amp;amp; r2,
+                  Pred pred = {},
+                  Proj1 proj1 = {},
+                  Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -29,8 +51,8 @@ namespace std::ranges {
 ## 概要
 ある集合の1つとマッチする最初の要素を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+* (1): イテレータ範囲を指定する
+* (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
index 97cc69aee..94d46985f 100644
--- a/reference/algorithm/ranges_find_if.md
+++ b/reference/algorithm/ranges_find_if.md
@@ -6,11 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I
+    find_if(I first,
+            S last,
+            Pred pred,
+            Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if(R&amp;amp;&amp;amp; r,
+            Pred pred,
+            Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -25,8 +37,8 @@ namespace std::ranges {
 ## 概要
 範囲の中から、指定された条件を満たす最初の要素を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+* (1): イテレータ範囲を指定する
+* (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
index 5423c1f33..64d460c45 100644
--- a/reference/algorithm/ranges_find_if_not.md
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -6,11 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find_if_not(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I
+    find_if_not(I first,
+                S last,
+                Pred pred,
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    find_if_not(R&amp;amp;&amp;amp; r,
+                Pred pred,
+                Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -25,8 +37,8 @@ namespace std::ranges {
 ## 概要
 範囲の中から、指定された条件を満たさない最初の要素を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_for_each.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each.md b/reference/algorithm/ranges_for_each.md
index 85795f2be..946d867c6 100644
--- a/reference/algorithm/ranges_for_each.md
+++ b/reference/algorithm/ranges_for_each.md
@@ -6,11 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
-  constexpr for_each_result&amp;lt;I, Fun&amp;gt; for_each(I first, S last, Fun f, Proj proj = {});                     // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
-  constexpr for_each_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, Fun&amp;gt; for_each(R&amp;amp;&amp;amp; r, Fun f, Proj proj = {});          // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  constexpr for_each_result&amp;lt;I, Fun&amp;gt;
+    for_each(I first,
+             S last,
+             Fun f,
+             Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  constexpr for_each_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, Fun&amp;gt;
+    for_each(R&amp;amp;&amp;amp; r,
+             Fun f,
+             Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -27,8 +39,8 @@ namespace std::ranges {
 ## 概要
 範囲の全ての要素に、指定された関数を適用する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+* (1): イテレータ範囲を指定する
+* (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index af7a4db63..dd7b328cc 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -6,8 +6,14 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
-  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; for_each_n(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            class Proj = identity,
+            indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
+  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt;
+    for_each_n(I first,
+               iter_difference_t&amp;lt;I&amp;gt; n,
+               Fun f,
+               Proj proj = {}); // (1) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -31,7 +37,7 @@ namespace std::ranges {
 `n &amp;gt;= 0`
 
 ## 効果
-範囲`[first, first + n)` 内の全てのイテレータ `i` に [`invoke`](/reference/functional/invoke.md)`(f, `[`invoke`](/reference/functional/invoke.md)`(proj, *i))` という操作を行う。
+イテレータ範囲`[first, first + n)` 内の全てのイテレータ `i` に [`invoke`](/reference/functional/invoke.md)`(f, `[`invoke`](/reference/functional/invoke.md)`(proj, *i))` という操作を行う。
 
 このアルゴリズムはその他のアルゴリズムと違い、[`invoke`](/reference/functional/invoke.md)`(proj, *i)` が書き換え可能な参照であれば、関数 `f` の内部でその値を書き換えても構わない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_generate.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate.md b/reference/algorithm/ranges_generate.md
index 323e24417..c07e9c82b 100644
--- a/reference/algorithm/ranges_generate.md
+++ b/reference/algorithm/ranges_generate.md
@@ -6,15 +6,21 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_or_output_iterator O, sentinel_for&amp;lt;O&amp;gt; S, copy_constructible F&amp;gt;
+  template &amp;lt;input_or_output_iterator O,
+            sentinel_for&amp;lt;O&amp;gt; S,
+            copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
-  constexpr O generate(O first, S last, F gen);
+  constexpr O
+    generate(O first,
+             S last,
+             F gen); // (1) C++20
 
-  // (2)
-  template&amp;lt;class R, copy_constructible F&amp;gt;
+  template &amp;lt;class R,
+            copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; output_range&amp;lt;R, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; generate(R&amp;amp;&amp;amp; r, F gen);
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    generate(R&amp;amp;&amp;amp; r,
+             F gen); // (2) C++20
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
@@ -29,8 +35,8 @@ namespace std::ranges {
 ## 概要
 出力の範囲へ関数の結果を書き込む。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generate_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_generate_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_generate_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_generate_n.md b/reference/algorithm/ranges_generate_n.md
index fa2808156..04ff5213f 100644
--- a/reference/algorithm/ranges_generate_n.md
+++ b/reference/algorithm/ranges_generate_n.md
@@ -6,9 +6,13 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_or_output_iterator O, copy_constructible F&amp;gt;
+  template &amp;lt;input_or_output_iterator O,
+            copy_constructible F&amp;gt;
     requires invocable&amp;lt;F&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirectly_writable&amp;lt;O, invoke_result_t&amp;lt;F&amp;amp;&amp;gt;&amp;gt;
-  constexpr O generate_n(O first, iter_difference_t&amp;lt;O&amp;gt; n, F gen);
+  constexpr O
+    generate_n(O first,
+               iter_difference_t&amp;lt;O&amp;gt; n,
+               F gen);                  // (1) C++20
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>includes -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_includes.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_includes.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_includes.md b/reference/algorithm/ranges_includes.md
index 7ca3c4303..9d0571aab 100644
--- a/reference/algorithm/ranges_includes.md
+++ b/reference/algorithm/ranges_includes.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, input_range R2, class Proj1 = identity, class Proj2 = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool ranges::includes(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                 // (2)
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    includes(I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    includes(R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Comp comp = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -27,8 +53,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 `[first2,last2)` が `empty` であるか、`[first2,last2)` の全ての要素が `[first1,last1)` に含まれている場合は `true`、そうでない場合は `false` を返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_inplace_merge.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_inplace_merge.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_inplace_merge.md b/reference/algorithm/ranges_inplace_merge.md
index a6365fb9c..8127d7be7 100644
--- a/reference/algorithm/ranges_inplace_merge.md
+++ b/reference/algorithm/ranges_inplace_merge.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  I
+    inplace_merge(I first,
+                  I middle,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (1) C++20
+
+  template &amp;lt;bidirectional_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  borrowed_iterator_t&amp;lt;R&amp;gt; inplace_merge(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, Comp comp = {}, Proj proj = {});
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    inplace_merge(R&amp;amp;&amp;amp; r,
+                  iterator_t&amp;lt;R&amp;gt; middle,
+                  Comp comp = {},
+                  Proj proj = {}); // (2) C++20
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -27,8 +41,8 @@ namespace std::ranges {
 ## 概要
 2つの連続したソート済み範囲をマージする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` の範囲はそれぞれソートされていること。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap.md b/reference/algorithm/ranges_is_heap.md
index 1cdbba857..3d7cffe21 100644
--- a/reference/algorithm/ranges_is_heap.md
+++ b/reference/algorithm/ranges_is_heap.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool is_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    is_heap(I first,
+            S last,
+            Comp comp = {},
+            Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    is_heap(R&amp;amp;&amp;amp; r,
+            Comp comp = {},
+            Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -26,8 +36,8 @@ namespace std::ranges {
 ## 概要
 範囲がヒープ化されているか判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap_until -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap_until.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_heap_until.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap_until.md b/reference/algorithm/ranges_is_heap_until.md
index 786dfc408..76bcc3e58 100644
--- a/reference/algorithm/ranges_is_heap_until.md
+++ b/reference/algorithm/ranges_is_heap_until.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; is_heap_until(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    is_heap_until(I first,
+                  S last,
+                  Comp comp = {},
+                  Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_heap_until(R&amp;amp;&amp;amp; r,
+                  Comp comp = {},
+                  Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -26,8 +36,8 @@ namespace std::ranges {
 ## 概要
 範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_partitioned -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_partitioned.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_partitioned.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_partitioned.md b/reference/algorithm/ranges_is_partitioned.md
index b4cdf7976..7ae74b210 100644
--- a/reference/algorithm/ranges_is_partitioned.md
+++ b/reference/algorithm/ranges_is_partitioned.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool is_partitioned(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    is_partitioned(I first,
+                   S last,
+                   Pred pred,
+                   Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    is_partitioned(R&amp;amp;&amp;amp; r,
+                   Pred pred,
+                   Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -26,6 +36,9 @@ namespace std::ranges {
 ## 概要
 与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 `[first,last)` が空、 または `[first,last)` が `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているなら `true` 、そうでなければ `false` を返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_permutation.md b/reference/algorithm/ranges_is_permutation.md
index 9f7ade40f..c361920db 100644
--- a/reference/algorithm/ranges_is_permutation.md
+++ b/reference/algorithm/ranges_is_permutation.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
-           indirect_equivalence_relation&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;forward_range R1, forward_range R2, class Proj1 = identity, class Proj2 = identity,
-           indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr bool is_permutation(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+  template &amp;lt;forward_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            forward_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_equivalence_relation&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr bool
+    is_permutation(I1 first1,
+                   S1 last1,
+                   I2 first2,
+                   S2 last2,
+                   Pred pred = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;forward_range R1,
+            forward_range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_equivalence_relation&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr bool
+    is_permutation(R1&amp;amp;&amp;amp; r1,
+                   R2&amp;amp;&amp;amp; r2,
+                   Pred pred = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -27,8 +53,8 @@ namespace std::ranges {
 ## 概要
 範囲 `[first2, last2)` を並べ替えたものが、`[first1, last1)` の範囲と一致するか判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 `last2` が与えられている形式の場合、`last1 - first1 != last2 - first2` であれば `false` を返す。  
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_sorted.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted.md b/reference/algorithm/ranges_is_sorted.md
index 0a2b6e8fe..586de7658 100644
--- a/reference/algorithm/ranges_is_sorted.md
+++ b/reference/algorithm/ranges_is_sorted.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    is_sorted(I first,
+              S last,
+              Comp comp = {},
+              Proj proj = {}); // (1) C++20
 
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool is_sorted(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    is_sorted(R&amp;amp;&amp;amp; r,
+              Comp comp = {},
+              Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -27,6 +37,10 @@ namespace std::ranges {
 ## 概要
 与えられた範囲がソート済みか判定する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
+
 ### 戻り値
 - (1) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(first, last, comp, proj) == last`
 - (2) : [`ranges::is_sorted_until`](/reference/algorithm/ranges_is_sorted_until.md)`(r, comp, proj) == last`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted_until.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_is_sorted_until.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted_until.md b/reference/algorithm/ranges_is_sorted_until.md
index 5bc17f503..ff1c746c0 100644
--- a/reference/algorithm/ranges_is_sorted_until.md
+++ b/reference/algorithm/ranges_is_sorted_until.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; is_sorted_until(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    is_sorted_until(I first,
+                    S last,
+                    Comp comp = {},
+                    Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    is_sorted_until(R&amp;amp;&amp;amp; r,
+                    Comp comp = {},
+                    Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,8 +38,8 @@ namespace std::ranges {
 ## 概要
 ソート済みか判定し、ソートされていない位置のイテレータを取得する
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 [`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` なら `last` を返す。そうでない場合、`[first,last]` の中でソートされている範囲を `[first,i)` としたとき、そのイテレータ `i` を返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lexicographical_compare.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_lexicographical_compare.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lexicographical_compare.md b/reference/algorithm/ranges_lexicographical_compare.md
index 16096a9bc..e85bdc772 100644
--- a/reference/algorithm/ranges_lexicographical_compare.md
+++ b/reference/algorithm/ranges_lexicographical_compare.md
@@ -7,13 +7,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, input_range R2, class Proj1 = identity, class Proj2 = identity,
-          indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool lexicographical_compare(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;I1, Proj1&amp;gt;,
+              projected&amp;lt;I2, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    lexicographical_compare(I1 first1,
+                            S1 last1,
+                            I2 first2,
+                            S2 last2,
+                            Comp comp = {},
+                            Proj1 proj1 = {},
+                            Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Proj1 = identity,
+            class Proj2 = identity,
+            indirect_strict_weak_order&amp;lt;
+              projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+              projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    lexicographical_compare(R1&amp;amp;&amp;amp; r1,
+                            R2&amp;amp;&amp;amp; r2,
+                            Comp comp = {},
+                            Proj1 proj1 = {},
+                            Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -28,8 +54,8 @@ namespace std::ranges {
 ## 概要
 `[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
index 78c61d462..096e3675b 100644
--- a/reference/algorithm/ranges_lower_bound.md
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I lower_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; lower_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    lower_bound(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    lower_bound(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,6 +42,9 @@ namespace std::ranges {
 ## 概要
 指定された要素以上の値が現れる最初の位置のイテレータを取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::ranges::equal_range()`](ranges_equal_range.md)関数を使用できる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_make_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_make_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_make_heap.md b/reference/algorithm/ranges_make_heap.md
index 0e2118aa8..4679c8fc0 100644
--- a/reference/algorithm/ranges_make_heap.md
+++ b/reference/algorithm/ranges_make_heap.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I make_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    make_heap(I first,
+              S last,
+              Comp comp = {},
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; make_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    make_heap(R&amp;amp;&amp;amp; r,
+              Comp comp = {},
+              Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 範囲をヒープ化する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_max.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max.md b/reference/algorithm/ranges_max.md
index 3c18d2a68..1fe53446f 100644
--- a/reference/algorithm/ranges_max.md
+++ b/reference/algorithm/ranges_max.md
@@ -6,18 +6,31 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr const T&amp;amp; max(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {}); // (1)
-
-  template&amp;lt;copyable T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr T max(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});         // (2)
-
-  template&amp;lt;input_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  template &amp;lt;class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp;
+    max(const T&amp;amp; a,
+        const T&amp;amp; b,
+        Comp comp = {},
+        Proj proj = {}); // (1) C++20
+
+  template &amp;lt;copyable T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr T
+    max(initializer_list&amp;lt;T&amp;gt; r,
+        Comp comp = {},
+        Proj proj = {}); // (2) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
     requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
-  constexpr range_value_t&amp;lt;R&amp;gt; max(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});          // (3)
+  constexpr range_value_t&amp;lt;R&amp;gt;
+    max(R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (3) C++20
 }
 ```
 * identity[link /reference/functional/identity.md]
@@ -33,6 +46,11 @@ namespace std::ranges {
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最大値を取得する。
 
+- (1): 2つの値を指定する
+- (2): 初期化子リストを指定する
+- (3): Rangeを指定する
+
+
 ## 戻り値
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最大と判断された最初の値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
index fdcacd74e..267aee7f7 100644
--- a/reference/algorithm/ranges_max_element.md
+++ b/reference/algorithm/ranges_max_element.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; max_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    max_element(I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    max_element(R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,6 +38,9 @@ namespace std::ranges {
 ## 概要
 `[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最大と判断された最初の要素を指すイテレータ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_merge.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
index 226e863ab..234e721e6 100644
--- a/reference/algorithm/ranges_merge.md
+++ b/reference/algorithm/ranges_merge.md
@@ -6,15 +6,43 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
-  constexpr merge_result&amp;lt;I1, I2, O&amp;gt; merge(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                    // (1)
-
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr merge_result&amp;lt;I1, I2, O&amp;gt;
+    merge(I1 first1,
+          S1 last1,
+          I2 first2,
+          S2 last2,
+          O result,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
-  constexpr merge_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt; merge(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (2)
+  constexpr merge_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;,
+    O
+  &amp;gt;
+    merge(R1&amp;amp;&amp;amp; r1,
+          R2&amp;amp;&amp;amp; r2,
+          O result,
+          Comp comp = {},
+          Proj1 proj1 = {},
+          Proj2 proj2 = {});  // (2) C++20
 }
 ```
 * merge_result[link ranges_in_in_out_result.md]
@@ -31,8 +59,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲をマージして、出力イテレータへ出力する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_min.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min.md b/reference/algorithm/ranges_min.md
index 254a4e8b3..67f024c65 100644
--- a/reference/algorithm/ranges_min.md
+++ b/reference/algorithm/ranges_min.md
@@ -6,18 +6,31 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr const T&amp;amp; min(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {}); // (1)
-
-  template&amp;lt;copyable T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr T min(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});         // (2)
-
-  template&amp;lt;input_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  template &amp;lt;class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp;
+    min(const T&amp;amp; a,
+        const T&amp;amp; b,
+        Comp comp = {},
+        Proj proj = {}); // (1) C++20
+
+  template &amp;lt;copyable T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr T
+    min(initializer_list&amp;lt;T&amp;gt; r,
+        Comp comp = {},
+        Proj proj = {}); // (2) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
     requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
-  constexpr range_value_t&amp;lt;R&amp;gt; min(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});          // (3)
+  constexpr range_value_t&amp;lt;R&amp;gt;
+    min(R&amp;amp;&amp;amp; r,
+        Comp comp = {},
+        Proj proj = {}); // (3) C++20
 }
 ```
 * identity[link /reference/functional/identity.md]
@@ -33,6 +46,11 @@ namespace std::ranges {
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値を取得する。
 
+- (1): 2つの値を指定する
+- (2): 初期化子リストを指定する
+- (3): Rangeを指定する
+
+
 ## 戻り値
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最小と判断された最初の値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_min_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
index 1ce557869..27966205a 100644
--- a/reference/algorithm/ranges_min_element.md
+++ b/reference/algorithm/ranges_min_element.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; min_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    min_element(I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    min_element(R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -29,6 +39,9 @@ namespace std::ranges {
 ## 概要
 `[first, last)`の範囲において、最小要素を指す最初のイテレータを取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最小と判断された最初の要素を指すイテレータ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_minmax.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax.md b/reference/algorithm/ranges_minmax.md
index da743ed64..2cbda0b5a 100644
--- a/reference/algorithm/ranges_minmax.md
+++ b/reference/algorithm/ranges_minmax.md
@@ -6,18 +6,31 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_result&amp;lt;const T&amp;amp;&amp;gt; minmax(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;copyable T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_result&amp;lt;T&amp;gt; minmax(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;input_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  template &amp;lt;class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;const T&amp;amp;&amp;gt;
+    minmax(const T&amp;amp; a,
+           const T&amp;amp; b,
+           Comp comp = {},
+           Proj proj = {}); // (1) C++20
+
+  template &amp;lt;copyable T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;T&amp;gt;
+    minmax(initializer_list&amp;lt;T&amp;gt; r,
+           Comp comp = {},
+           Proj proj = {}); // (2) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
     requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
-  constexpr minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt; minmax(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax(R&amp;amp;&amp;amp; r,
+           Comp comp = {},
+           Proj proj = {}); // (3) C++20
 }
 ```
 * minmax_result[link ranges_min_max_result.md]
@@ -34,6 +47,11 @@ namespace std::ranges {
 ## 概要
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値と最大値の組を取得する。
 
+- (1): 2つの値を指定する
+- (2): 初期化子リストを指定する
+- (3): Rangeを指定する
+
+
 ## 戻り値
 ```cpp
 minmax_result {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
index 32bbf40e1..cb0d2b76e 100644
--- a/reference/algorithm/ranges_minmax_element.md
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_element_result&amp;lt;I&amp;gt; minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_element_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; minmax_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_element_result&amp;lt;I&amp;gt;
+    minmax_element(I first,
+                   S last,
+                   Comp comp = {},
+                   Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_element_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    minmax_element(R&amp;amp;&amp;amp; r,
+                   Comp comp = {},
+                   Proj proj = {}); // (2) C++20
 }
 ```
 * minmax_element_result[link ranges_min_max_result.md]
@@ -30,6 +40,9 @@ namespace std::ranges {
 ## 概要
 `[first, last)` の範囲において、最小要素を指すイテレータと最大要素を指すイテレータの組を取得する。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_mismatch.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index bf6754050..71f550a11 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -6,13 +6,38 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;I1, I2&amp;gt; mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                      // (1)
-
-  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr mismatch_result&amp;lt;I1, I2&amp;gt;
+    mismatch(I1 first1,
+             S1 last1,
+             I2 first2,
+             S2 last2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; mismatch(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    // (2)
+  constexpr mismatch_result&amp;lt;
+    borrowed_iterator_t&amp;lt;R1&amp;gt;,
+    borrowed_iterator_t&amp;lt;R2&amp;gt;
+  &amp;gt;
+    mismatch(R1&amp;amp;&amp;amp; r1,
+             R2&amp;amp;&amp;amp; r2,
+             Pred pred = {},
+             Proj1 proj1 = {},
+             Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * mismatch_result[link ranges_in_in_result.md]
@@ -34,8 +59,9 @@ namespace std::ranges {
 ## 概要
 2つのシーケンスが一致していない場所を検索する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 戻り値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_move.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move.md b/reference/algorithm/ranges_move.md
index 5e8937914..7b4fe35e0 100644
--- a/reference/algorithm/ranges_move.md
+++ b/reference/algorithm/ranges_move.md
@@ -6,13 +6,21 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O&amp;gt;
     requires indirectly_movable&amp;lt;I, O&amp;gt;
-  constexpr move_result&amp;lt;I, O&amp;gt; move(I first, S last, O result);            // (1)
+  constexpr move_result&amp;lt;I, O&amp;gt;
+    move(I first,
+         S last,
+         O result); // (1) C++20
 
-  template&amp;lt;input_range R, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_range R,
+            weakly_incrementable O&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-  constexpr move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt; move(R&amp;amp;&amp;amp; r, O result); // (2)
+  constexpr move_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    move(R&amp;amp;&amp;amp; r,
+         O result); // (2) C++20
 }
 ```
 * move_result[link ranges_in_out_result.md]
@@ -27,8 +35,9 @@ namespace std::ranges {
 ## 概要
 指定された範囲の要素をムーブする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 `result` は `[first,last)` の範囲に含まれてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_backward -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_move_backward.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_move_backward.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_move_backward.md b/reference/algorithm/ranges_move_backward.md
index 2e6f08a14..a49dc8227 100644
--- a/reference/algorithm/ranges_move_backward.md
+++ b/reference/algorithm/ranges_move_backward.md
@@ -6,13 +6,21 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, bidirectional_iterator I2&amp;gt;
+  template &amp;lt;bidirectional_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            bidirectional_iterator I2&amp;gt;
     requires indirectly_movable&amp;lt;I1, I2&amp;gt;
-  constexpr move_backward_result&amp;lt;I1, I2&amp;gt; move_backward(I1 first, S1 last, I2 result);       // (1)
+  constexpr move_backward_result&amp;lt;I1, I2&amp;gt;
+    move_backward(I1 first,
+                  S1 last,
+                  I2 result); // (1) C++20
 
-  template&amp;lt;bidirectional_range R, bidirectional_iterator I&amp;gt;
+  template &amp;lt;bidirectional_range R,
+            bidirectional_iterator I&amp;gt;
     requires indirectly_movable&amp;lt;iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
-  constexpr move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt; move_backward(R&amp;amp;&amp;amp; r, I result); // (2)
+  constexpr move_backward_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, I&amp;gt;
+    move_backward(R&amp;amp;&amp;amp; r,
+                  I result); // (2) C++20
 }
 ```
 * move_backward_result[link ranges_in_out_result.md]
@@ -26,8 +34,8 @@ namespace std::ranges {
 ## 概要
 指定された範囲の要素を後ろからムーブする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 `result` は `(first,last]` の範囲に含まれてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>next_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_next_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_next_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_next_permutation.md b/reference/algorithm/ranges_next_permutation.md
index 3f3f123a1..1d8b6a8aa 100644
--- a/reference/algorithm/ranges_next_permutation.md
+++ b/reference/algorithm/ranges_next_permutation.md
@@ -7,13 +7,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr next_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
-
-  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr next_permutation_result&amp;lt;I&amp;gt;
+    next_permutation(I first,
+                     S last,
+                     Comp comp = {},
+                     Proj proj = {}); // (1) C++20
+
+  template &amp;lt;bidirectional_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr next_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
+  constexpr next_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    next_permutation(R&amp;amp;&amp;amp; r,
+                     Comp comp = {},
+                     Proj proj = {}); // (2) C++20
 }
 ```
 * next_permutation_result[link ranges_in_found_result.md]
@@ -29,8 +41,8 @@ namespace std::ranges {
 ## 概要
 与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその次の順列を生成する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `[first, last)`の範囲を次の順列に変換する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_none_of.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_none_of.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_none_of.md b/reference/algorithm/ranges_none_of.md
index 28fa19168..e90173df9 100644
--- a/reference/algorithm/ranges_none_of.md
+++ b/reference/algorithm/ranges_none_of.md
@@ -6,11 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool none_of(I first, S last, Pred pred, Proj proj = {}); // (1)
-
-  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool none_of(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    none_of(I first,
+            S last,
+            Pred pred,
+            Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool
+    none_of(R&amp;amp;&amp;amp; r,
+            Pred pred,
+            Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -23,8 +35,8 @@ namespace std::ranges {
 ## 概要
 範囲の全ての要素が条件を満たさないかを判定する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## テンプレートパラメータ制約
 - (1):
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_nth_element.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
index e44cb9b34..a606db096 100644
--- a/reference/algorithm/ranges_nth_element.md
+++ b/reference/algorithm/ranges_nth_element.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    nth_element(I first,
+                I nth,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; nth_element(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; nth, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    nth_element(R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; nth,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -28,6 +42,9 @@ namespace std::ranges {
 ## 概要
 基準となる要素よりも小さい要素が前に来るよう並べ替える。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
 
 ある範囲に対して部分的な並び替えを行う場合、[`partial_sort()`](partial_sort.md)を使用する。また範囲全体に対して並び替えを行う場合、[`sort()`](sort.md)を使用する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index 07cd26fd8..9d5748cf8 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -6,13 +6,27 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    partial_sort(I first,
+                 I middle,
+                 S last,
+                 Comp comp = {},
+                 Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; partial_sort(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    partial_sort(R&amp;amp;&amp;amp; r,
+                 iterator_t&amp;lt;R&amp;gt; middle,
+                 Comp comp = {},
+                 Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -28,6 +42,9 @@ namespace std::ranges {
 ## 概要
 範囲を部分的にソートし、先頭 `N` 個を順に並んだ状態にする。`N` は `middle - first` で決まる。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 この関数は、「売り上げランキング トップ1位から10位まで」のように、全体ではなく最高順位から途中までの順位がわかればよい状況で、全体を並び替える[`sort()`](sort.md)関数の代わりに使用できる。
 
 なお、トップ10がどれかわかれば十分である（1位から10位までは順不同でよい）ような場合、[`nth_element()`](nth_element.md)が使用できる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partial_sort_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort_copy.md b/reference/algorithm/ranges_partial_sort_copy.md
index 5301774bc..1078006a7 100644
--- a/reference/algorithm/ranges_partial_sort_copy.md
+++ b/reference/algorithm/ranges_partial_sort_copy.md
@@ -6,20 +6,42 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, random_access_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp; sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            random_access_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp;
+             sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
              indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
   constexpr partial_sort_copy_result&amp;lt;I1, I2&amp;gt;
-    partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, random_access_range R2,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    partial_sort_copy(I1 first,
+                      S1 last,
+                      I2 result_first,
+                      S2 result_last,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            random_access_range R2,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt; &amp;amp;&amp;amp;
              sortable&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
-             indirect_strict_weak_order&amp;lt;Comp, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;
+             indirect_strict_weak_order&amp;lt;
+               Comp,
+               projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;
+             &amp;gt;
   constexpr partial_sort_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
-    partial_sort_copy(R1&amp;amp;&amp;amp; r, R2&amp;amp;&amp;amp; result_r, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                              // (2)
+    partial_sort_copy(R1&amp;amp;&amp;amp; r,
+                      R2&amp;amp;&amp;amp; result_r,
+                      Comp comp = {},
+                      Proj1 proj1 = {},
+                      Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * partial_sort_copy_result[link ranges_in_out_result.md]
@@ -40,8 +62,8 @@ namespace std::ranges {
 ## 概要
 範囲を部分的にソートした結果を他の範囲にコピーする
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `N = `[`min`](/reference/algorithm/min.md)`(last - first, result_last - result_first)` とする。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partition.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition.md b/reference/algorithm/ranges_partition.md
index 4c18cae09..fdf8f06f6 100644
--- a/reference/algorithm/ranges_partition.md
+++ b/reference/algorithm/ranges_partition.md
@@ -6,14 +6,24 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; partition(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    partition(I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; partition(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    partition(R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
index ebd6fec68..92e2f44e3 100644
--- a/reference/algorithm/ranges_partition_copy.md
+++ b/reference/algorithm/ranges_partition_copy.md
@@ -6,17 +6,33 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O1, weakly_incrementable O2, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O1,
+            weakly_incrementable O2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;I, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;I, O2&amp;gt;
   constexpr partition_copy_result&amp;lt;I, O1, O2&amp;gt;
-    partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O1, weakly_incrementable O2, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O2&amp;gt;
+    partition_copy(I first,
+                   S last, O1 out_true,
+                   O2 out_false,
+                   Pred pred,
+                   Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O1,
+            weakly_incrementable O2,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O1&amp;gt; &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O2&amp;gt;
   constexpr partition_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O1, O2&amp;gt;
-    partition_copy(R&amp;amp;&amp;amp; r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
+    partition_copy(R&amp;amp;&amp;amp; r,
+                   O1 out_true,
+                   O2 out_false,
+                   Pred pred,
+                   Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -35,8 +51,8 @@ namespace std::ranges {
 ## 概要
 与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_point -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_point.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_partition_point.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_point.md b/reference/algorithm/ranges_partition_point.md
index 165001182..a6d4d9077 100644
--- a/reference/algorithm/ranges_partition_point.md
+++ b/reference/algorithm/ranges_partition_point.md
@@ -6,13 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; partition_point(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I
+    partition_point(I first,
+                    S last,
+                    Pred pred,
+                    Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    partition_point(R&amp;amp;&amp;amp; r,
+                    Pred pred,
+                    Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,8 +38,8 @@ namespace std::ranges {
 ## 概要
 与えられた範囲から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` は `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現してなければならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pop_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_pop_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_pop_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_pop_heap.md b/reference/algorithm/ranges_pop_heap.md
index ae6ec364f..de502d680 100644
--- a/reference/algorithm/ranges_pop_heap.md
+++ b/reference/algorithm/ranges_pop_heap.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    pop_heap(I first,
+             S last,
+             Comp comp = {},
+             Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; pop_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    pop_heap(R&amp;amp;&amp;amp; r,
+             Comp comp = {},
+             Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 ヒープ化された範囲の先頭と末尾を入れ替え、ヒープ範囲を作り直す
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>prev_permutation -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_prev_permutation.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_prev_permutation.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_prev_permutation.md b/reference/algorithm/ranges_prev_permutation.md
index 8cac1b54b..ae00858a1 100644
--- a/reference/algorithm/ranges_prev_permutation.md
+++ b/reference/algorithm/ranges_prev_permutation.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr prev_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
-
-  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr prev_permutation_result&amp;lt;I&amp;gt;
+    next_permutation(I first,
+                     S last,
+                     Comp comp = {},
+                     Proj proj = {}); // (1) C++20
+
+  template &amp;lt;bidirectional_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr prev_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
+  constexpr prev_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt;
+    next_permutation(R&amp;amp;&amp;amp; r,
+                     Comp comp = {},
+                     Proj proj = {}); // (2) C++20
 }
 ```
 * prev_permutation_result[link ranges_in_found_result.md]
@@ -28,8 +40,8 @@ namespace std::ranges {
 ## 概要
 与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその前の順列を生成する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `[first, last)`の範囲を前の順列に変換する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>push_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_push_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_push_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_push_heap.md b/reference/algorithm/ranges_push_heap.md
index a3b83cbcb..83356ad17 100644
--- a/reference/algorithm/ranges_push_heap.md
+++ b/reference/algorithm/ranges_push_heap.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I push_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    push_heap(I first,
+              S last,
+              Comp comp = {},
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; push_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    push_heap(R&amp;amp;&amp;amp; r,
+              Comp comp = {},
+              Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 ヒープ化された範囲に要素を追加する
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_remove.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove.md b/reference/algorithm/ranges_remove.md
index 4787437db..77087996f 100644
--- a/reference/algorithm/ranges_remove.md
+++ b/reference/algorithm/ranges_remove.md
@@ -6,15 +6,30 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; remove(I first, S last, const T&amp;amp; value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class T, class Proj = identity&amp;gt;
-    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; remove(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+  constexpr subrange&amp;lt;I&amp;gt;
+    remove(I first,
+           S last,
+           const T&amp;amp; value,
+           Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove(R&amp;amp;&amp;amp; r,
+           const T&amp;amp; value,
+           Proj proj = {}); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -31,8 +46,8 @@ namespace std::ranges {
 ## 概要
 指定された要素を取り除く。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_remove_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy.md b/reference/algorithm/ranges_remove_copy.md
index a047a5abf..7a63b402a 100644
--- a/reference/algorithm/ranges_remove_copy.md
+++ b/reference/algorithm/ranges_remove_copy.md
@@ -6,17 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class T, class Proj = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr remove_copy_result&amp;lt;I, O&amp;gt;
-    remove_copy(I first, S last, O result, const T&amp;amp; value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, class T, class Proj = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    remove_copy(I first,
+                S last,
+                O result,
+                const T&amp;amp; value,
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr remove_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    remove_copy(R&amp;amp;&amp;amp; r, O result, const T&amp;amp; value, Proj proj = {});
+    remove_copy(R&amp;amp;&amp;amp; r,
+                O result,
+                const T&amp;amp; value,
+                Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -35,8 +57,8 @@ namespace std::ranges {
 ## 概要
 指定された要素を除け、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first)` は重なってはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_remove_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy_if.md b/reference/algorithm/ranges_remove_copy_if.md
index 65ddfde49..f6a052879 100644
--- a/reference/algorithm/ranges_remove_copy_if.md
+++ b/reference/algorithm/ranges_remove_copy_if.md
@@ -6,17 +6,29 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
   constexpr remove_copy_if_result&amp;lt;I, O&amp;gt;
-    remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    remove_copy_if(I first,
+                   S last,
+                   O result,
+                   Pred pred,
+                   Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr remove_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    remove_copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, Proj proj = {});
+    remove_copy_if(R&amp;amp;&amp;amp; r,
+                   O result,
+                   Pred pred,
+                   Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -34,8 +46,8 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素を除け、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first)` は重なってはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_remove_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_if.md b/reference/algorithm/ranges_remove_if.md
index 855660bd3..32b4e37fe 100644
--- a/reference/algorithm/ranges_remove_if.md
+++ b/reference/algorithm/ranges_remove_if.md
@@ -6,14 +6,24 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-    constexpr subrange&amp;lt;I&amp;gt; remove_if(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    remove_if(I first,
+              S last,
+              Pred pred,
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; remove_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove_if(R&amp;amp;&amp;amp; r,
+              Pred pred,
+              Proj proj = {}); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -30,8 +40,8 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素を除ける。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_replace.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace.md b/reference/algorithm/ranges_replace.md
index c94e3b262..a40e83795 100644
--- a/reference/algorithm/ranges_replace.md
+++ b/reference/algorithm/ranges_replace.md
@@ -6,15 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T1, class T2, class Proj = identity&amp;gt;
-    requires indirectly_writable&amp;lt;I, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T1*&amp;gt;
-  constexpr I replace(I first, S last, const T1&amp;amp; old_value, const T2&amp;amp; new_value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T1, class T2, class Proj = identity&amp;gt;
-    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T1*&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; replace(R&amp;amp;&amp;amp; r, const T1&amp;amp; old_value, const T2&amp;amp; new_value, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;I, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T1*&amp;gt;
+  constexpr I
+    replace(I first,
+            S last,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T1,
+            class T2,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T2&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace(R&amp;amp;&amp;amp; r,
+            const T1&amp;amp; old_value,
+            const T2&amp;amp; new_value,
+            Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -31,8 +51,8 @@ namespace std::ranges {
 ## 概要
 指定された値と一致する要素を指定された値に置き換える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_replace_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy.md b/reference/algorithm/ranges_replace_copy.md
index 406a3c318..642891e7e 100644
--- a/reference/algorithm/ranges_replace_copy.md
+++ b/reference/algorithm/ranges_replace_copy.md
@@ -6,17 +6,43 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T1, class T2, output_iterator&amp;lt;const T2&amp;amp;&amp;gt; O, class Proj = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T1*&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T1,
+            class T2,
+            output_iterator&amp;lt;const T2&amp;amp;&amp;gt; O,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
   constexpr replace_copy_result&amp;lt;I, O&amp;gt;
-    replace_copy(I first, S last, O result, const T1&amp;amp; old_value, const T2&amp;amp; new_value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T1, class T2, output_iterator&amp;lt;const T2&amp;amp;&amp;gt; O, class Proj = identity&amp;gt;
-    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp; indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T1*&amp;gt;
+    replace_copy(I first,
+                 S last,
+                 O result,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T1,
+            class T2,
+            output_iterator&amp;lt;const T2&amp;amp;&amp;gt; O,
+            class Proj = identity&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T1*
+             &amp;gt;
   constexpr replace_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    replace_copy(R&amp;amp;&amp;amp; r, O result, const T1&amp;amp; old_value, const T2&amp;amp; new_value, Proj proj = {});
+    replace_copy(R&amp;amp;&amp;amp; r,
+                 O result,
+                 const T1&amp;amp; old_value,
+                 const T2&amp;amp; new_value,
+                 Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -35,8 +61,8 @@ namespace std::ranges {
 ## 概要
 指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_replace_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy_if.md b/reference/algorithm/ranges_replace_copy_if.md
index 2f3fefdde..6907413b8 100644
--- a/reference/algorithm/ranges_replace_copy_if.md
+++ b/reference/algorithm/ranges_replace_copy_if.md
@@ -6,17 +6,33 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
   constexpr replace_copy_if_result&amp;lt;I, O&amp;gt;
-    replace_copy_if(I first, S last, O result, Pred pred, const T&amp;amp; new_value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    replace_copy_if(I first,
+                    S last,
+                    O result,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T,
+            output_iterator&amp;lt;const T&amp;amp;&amp;gt; O,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr replace_copy_if_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    replace_copy_if(R&amp;amp;&amp;amp; r, O result, Pred pred, const T&amp;amp; new_value, Proj proj = {});
+    replace_copy_if(R&amp;amp;&amp;amp; r,
+                    O result,
+                    Pred pred,
+                    const T&amp;amp; new_value,
+                    Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -34,8 +50,8 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_replace_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_if.md b/reference/algorithm/ranges_replace_if.md
index 44222d628..be92ef555 100644
--- a/reference/algorithm/ranges_replace_if.md
+++ b/reference/algorithm/ranges_replace_if.md
@@ -6,15 +6,29 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_writable&amp;lt;I, const T&amp;amp;&amp;gt;
-  constexpr I replace_if(I first, S last, Pred pred, const T&amp;amp; new_value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I
+    replace_if(I first,
+               S last,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires indirectly_writable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T&amp;amp;&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; replace_if(R&amp;amp;&amp;amp; r, Pred pred, const T&amp;amp; new_value, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    replace_if(R&amp;amp;&amp;amp; r,
+               Pred pred,
+               const T&amp;amp; new_value,
+               Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -30,8 +44,8 @@ namespace std::ranges {
 ## 概要
 条件を満たす要素を指定された値に置き換える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_reverse.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse.md b/reference/algorithm/ranges_reverse.md
index cb3f4c4bf..28caf6aa5 100644
--- a/reference/algorithm/ranges_reverse.md
+++ b/reference/algorithm/ranges_reverse.md
@@ -6,15 +6,17 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
     requires permutable&amp;lt;I&amp;gt;
-  constexpr I reverse(I first, S last);
+  constexpr I
+    reverse(I first,
+            S last); // (1) C++20
 
-  // (2)
-  template&amp;lt;bidirectional_range R&amp;gt;
+  template &amp;lt;bidirectional_range R&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; reverse(R&amp;amp;&amp;amp; r);
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    reverse(R&amp;amp;&amp;amp; r);  // (2) C++20
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -27,8 +29,8 @@ namespace std::ranges {
 ## 概要
 要素の並びを逆にする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_reverse_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse_copy.md b/reference/algorithm/ranges_reverse_copy.md
index 60fa353f1..063c8155d 100644
--- a/reference/algorithm/ranges_reverse_copy.md
+++ b/reference/algorithm/ranges_reverse_copy.md
@@ -6,17 +6,21 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
   constexpr reverse_copy_result&amp;lt;I, O&amp;gt;
-    reverse_copy(I first, S last, O result);
+    reverse_copy(I first,
+                 S last,
+                 O result); // (1) C++20
 
-  // (2)
-  template&amp;lt;bidirectional_range R, weakly_incrementable O&amp;gt;
+  template &amp;lt;bidirectional_range R,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr reverse_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    reverse_copy(R&amp;amp;&amp;amp; r, O result);
+    reverse_copy(R&amp;amp;&amp;amp; r,
+                 O result); // (2) C++20
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -31,8 +35,9 @@ namespace std::ranges {
 ## 概要
 要素の並びを逆にし、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 `[first,last)` と `[result,result+(last-first))` は領域が重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_rotate.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate.md b/reference/algorithm/ranges_rotate.md
index 057d5718b..6fbe6715f 100644
--- a/reference/algorithm/ranges_rotate.md
+++ b/reference/algorithm/ranges_rotate.md
@@ -6,14 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; rotate(I first, I middle, S last);
-
-  // (2)
-  template&amp;lt;forward_range R&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    rotate(I first,
+           I middle,
+           S last);               // (1) C++20
+
+  template &amp;lt;forward_range R&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; rotate(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle);
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    rotate(R&amp;amp;&amp;amp; r,
+           iterator_t&amp;lt;R&amp;gt; middle); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -26,8 +30,8 @@ namespace std::ranges {
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させる。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,middle)` と `[middle,last)` は有効な範囲である必要がある。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_rotate_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate_copy.md b/reference/algorithm/ranges_rotate_copy.md
index 60a8e5a59..87cfa3d3e 100644
--- a/reference/algorithm/ranges_rotate_copy.md
+++ b/reference/algorithm/ranges_rotate_copy.md
@@ -6,17 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
- template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
   constexpr rotate_copy_result&amp;lt;I, O&amp;gt;
-    rotate_copy(I first, I middle, S last, O result);
+    rotate_copy(I first,
+                I middle,
+                S last,
+                O result); // (1) C++20
 
-  // (2)
-  template&amp;lt;forward_range R, weakly_incrementable O&amp;gt;
+  template &amp;lt;forward_range R,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
   constexpr rotate_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    rotate_copy(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, O result);
+    rotate_copy(R&amp;amp;&amp;amp; r,
+                iterator_t&amp;lt;R&amp;gt; middle,
+                O result); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -30,8 +36,8 @@ namespace std::ranges {
 ## 概要
 `middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sample -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sample.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_sample.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sample.md b/reference/algorithm/ranges_sample.md
index 9662516c3..0b65afd20 100644
--- a/reference/algorithm/ranges_sample.md
+++ b/reference/algorithm/ranges_sample.md
@@ -7,15 +7,31 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Gen&amp;gt;
-    requires (forward_iterator&amp;lt;I&amp;gt; || random_access_iterator&amp;lt;O&amp;gt;) &amp;amp;&amp;amp; indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp; uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
-  O sample(I first, S last, O out, iter_difference_t&amp;lt;I&amp;gt; n, Gen&amp;amp;&amp;amp; g);
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, class Gen&amp;gt;
-    requires (forward_range&amp;lt;R&amp;gt; || random_access_iterator&amp;lt;O&amp;gt;) &amp;amp;&amp;amp; indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp; uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
-  O sample(R&amp;amp;&amp;amp; r, O out, range_difference_t&amp;lt;R&amp;gt; n, Gen&amp;amp;&amp;amp; g);
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Gen&amp;gt;
+    requires (forward_iterator&amp;lt;I&amp;gt; || random_access_iterator&amp;lt;O&amp;gt;) &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
+  O
+    sample(I first,
+           S last,
+           O out,
+           iter_difference_t&amp;lt;I&amp;gt; n,
+           Gen&amp;amp;&amp;amp; g); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Gen&amp;gt;
+    requires (forward_range&amp;lt;R&amp;gt; || random_access_iterator&amp;lt;O&amp;gt;) &amp;amp;&amp;amp;
+             indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
+             uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
+  O
+    sample(R&amp;amp;&amp;amp; r,
+           O out,
+           range_difference_t&amp;lt;R&amp;gt; n,
+           Gen&amp;amp;&amp;amp; g); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -32,8 +48,8 @@ namespace std::ranges {
 ## 概要
 範囲から指定された個数の要素をランダムに抽出する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `out`は範囲`[first, last)`に含まれてはならない
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_search.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index 3d474d81c..19bab6beb 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -6,14 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
-  sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;forward_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            forward_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt;
+    search(I1 first1,
+           S1 last1,
+           I2 first2,
+           S2 last2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;forward_range R1,
+            forward_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; search(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});              // (2)
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt;
+    search(R1&amp;amp;&amp;amp; r1,
+           R2&amp;amp;&amp;amp; r2,
+           Pred pred = {},
+           Proj1 proj1 = {},
+           Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -29,8 +50,8 @@ namespace std::ranges {
 ## 概要
 あるシーケンスの中から、特定のサブシーケンスを探す
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 - (1) :
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search_n -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search_n.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_search_n.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search_n.md b/reference/algorithm/ranges_search_n.md
index 6ccb4346b..4cf0eca16 100644
--- a/reference/algorithm/ranges_search_n.md
+++ b/reference/algorithm/ranges_search_n.md
@@ -6,13 +6,31 @@
 
 ```cpp
 namespace std::ranges {]
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Pred = ranges::equal_to,
+            class Proj = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I, const T*, Pred, Proj&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; search_n(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    search_n(I first,
+             S last,
+             iter_difference_t&amp;lt;I&amp;gt; count,
+             const T&amp;amp; value,
+             Pred pred = {},
+             Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Pred = ranges::equal_to,
+            class Proj = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T*, Pred, Proj&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; search_n(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {});
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    search_n(R&amp;amp;&amp;amp; r,
+             range_difference_t&amp;lt;R&amp;gt; count,
+             const T&amp;amp; value,
+             Pred pred = {},
+             Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -30,8 +48,8 @@ namespace std::ranges {]
 ## 概要
 あるシーケンスの中から、指定の要素が連続するサブシーケンスを探す。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 `[first,last-count)` 内のイテレータ `i` があるとき、0 以上 `count` 未満の整数 `n` について、それぞれ [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *(i + n)), value)` であるようなサブシーケンスを探し、見つかった最初のサブシーケンスを返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_difference.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_set_difference.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_difference.md b/reference/algorithm/ranges_set_difference.md
index 5bf939271..d93ad1ab2 100644
--- a/reference/algorithm/ranges_set_difference.md
+++ b/reference/algorithm/ranges_set_difference.md
@@ -6,17 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_difference_result&amp;lt;I1, O&amp;gt;
-    set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
-
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    set_difference(I1 first1,
+                   S1 last1,
+                   I2 first2,
+                   S2 last2,
+                   O result,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, O&amp;gt;
-    set_difference(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+    set_difference(R1&amp;amp;&amp;amp; r1,
+                   R2&amp;amp;&amp;amp; r2,
+                   O result,
+                   Comp comp = {},
+                   Proj1 proj1 = {},
+                   Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * set_difference_result[link ranges_in_out_result.md]
@@ -34,8 +56,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲の差集合を得る
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_intersection.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_set_intersection.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_intersection.md b/reference/algorithm/ranges_set_intersection.md
index bcea585c4..18d993c42 100644
--- a/reference/algorithm/ranges_set_intersection.md
+++ b/reference/algorithm/ranges_set_intersection.md
@@ -6,17 +6,43 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_intersection_result&amp;lt;I1, I2, O&amp;gt;
-    set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (1)
-
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    set_intersection(I1 first1,
+                     S1 last1,
+                     I2 first2,
+                     S2 last2,
+                     O result,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
-  constexpr set_intersection_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
-    set_intersection(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                          // (2)
+  constexpr set_intersection_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              O
+            &amp;gt;
+    set_intersection(R1&amp;amp;&amp;amp; r1,
+                     R2&amp;amp;&amp;amp; r2,
+                     O result,
+                     Comp comp = {},
+                     Proj1 proj1 = {},
+                     Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * set_intersection_result[link ranges_in_in_out_result.md]
@@ -33,8 +59,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲の積集合を得る
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_symmetric_difference.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_set_symmetric_difference.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_symmetric_difference.md b/reference/algorithm/ranges_set_symmetric_difference.md
index 0d80425ab..e823c3f1e 100644
--- a/reference/algorithm/ranges_set_symmetric_difference.md
+++ b/reference/algorithm/ranges_set_symmetric_difference.md
@@ -6,22 +6,46 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_symmetric_difference_result&amp;lt;I1, I2, O&amp;gt;
-    set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  // (2)
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    set_symmetric_difference(I1 first1,
+                             S1 last1,
+                             I2 first2,
+                             S2 last2,
+                             O result,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
-  constexpr set_symmetric_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
-    set_symmetric_difference(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr set_symmetric_difference_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              O
+            &amp;gt;
+    set_symmetric_difference(R1&amp;amp;&amp;amp; r1,
+                             R2&amp;amp;&amp;amp; r2,
+                             O result,
+                             Comp comp = {},
+                             Proj1 proj1 = {},
+                             Proj2 proj2 = {}); // (2) C++20
 }
 ```
-* set_symmetric_difference_result[link ranges_in_in_out_result.md] 
+* set_symmetric_difference_result[link ranges_in_in_out_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -35,8 +59,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_union.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_set_union.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_union.md b/reference/algorithm/ranges_set_union.md
index bce71361e..f35bf4bb3 100644
--- a/reference/algorithm/ranges_set_union.md
+++ b/reference/algorithm/ranges_set_union.md
@@ -6,17 +6,45 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr set_union_result&amp;lt;I1, I2, O&amp;gt;
-    set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});   // (1)
-
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
-           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
-    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
+    set_union(I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            class Comp = ranges::less,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;
+               iterator_t&amp;lt;R1&amp;gt;,
+               iterator_t&amp;lt;R2&amp;gt;,
+               O,
+               Comp,
+               Proj1,
+               Proj2&amp;gt;
   constexpr set_union_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
-    set_union(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                           // (2)
+    set_union(R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              O result,
+              Comp comp = {},
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * set_union_result[link ranges_in_in_out_result.md]
@@ -33,8 +61,8 @@ namespace std::ranges {
 ## 概要
 2つのソート済み範囲の和集合を得る
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 結果の範囲は両方の入力の範囲と重なっていてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_left -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_left.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_shift_left.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_left.md b/reference/algorithm/ranges_shift_left.md
index 2d0e8bf69..019b11dd2 100644
--- a/reference/algorithm/ranges_shift_left.md
+++ b/reference/algorithm/ranges_shift_left.md
@@ -6,14 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
-    constexpr subrange&amp;lt;I&amp;gt; shift_left(I first, S last, iter_difference_t&amp;lt;I&amp;gt; n);
-
-  // (2)
-  template&amp;lt;forward_range R&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    shift_left(I first,
+               S last,
+               iter_difference_t&amp;lt;I&amp;gt; n);  // (1) C++20
+
+  template &amp;lt;forward_range R&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; shift_left(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; n)
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_left(R&amp;amp;&amp;amp; r,
+               range_difference_t&amp;lt;R&amp;gt; n); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -28,8 +32,8 @@ namespace std::ranges {
 ## 概要
 範囲の要素をn個だけ左にシフトさせる。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_right -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_right.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_shift_right.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_right.md b/reference/algorithm/ranges_shift_right.md
index 0e41f9fc6..d536d557a 100644
--- a/reference/algorithm/ranges_shift_right.md
+++ b/reference/algorithm/ranges_shift_right.md
@@ -6,14 +6,18 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
-    constexpr subrange&amp;lt;I&amp;gt; shift_right(I first, S last, iter_difference_t&amp;lt;I&amp;gt; n);
-
-  // (2)
-  template&amp;lt;forward_range R&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    shift_right(I first,
+                S last,
+                iter_difference_t&amp;lt;I&amp;gt; n); // (1) C++20
+
+  template &amp;lt;forward_range R&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; shift_right(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; n);
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    shift_right(R&amp;amp;&amp;amp; r,
+                range_difference_t&amp;lt;R&amp;gt; n); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -29,8 +33,8 @@ namespace std::ranges {
 ## 概要
 範囲の要素をn個だけ右にシフトさせる。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shuffle -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shuffle.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_shuffle.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shuffle.md b/reference/algorithm/ranges_shuffle.md
index 662232a79..28130bad0 100644
--- a/reference/algorithm/ranges_shuffle.md
+++ b/reference/algorithm/ranges_shuffle.md
@@ -6,15 +6,23 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Gen&amp;gt;
-    requires permutable&amp;lt;I&amp;gt; &amp;amp;&amp;amp; uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
-  I shuffle(I first, S last, Gen&amp;amp;&amp;amp; g);
-
-  // (2)
-  template&amp;lt;random_access_range R, class Gen&amp;gt;
-    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp; uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
-  borrowed_iterator_t&amp;lt;R&amp;gt; shuffle(R&amp;amp;&amp;amp; r, Gen&amp;amp;&amp;amp; g);
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Gen&amp;gt;
+    requires permutable&amp;lt;I&amp;gt; &amp;amp;&amp;amp;
+             uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
+  I
+    shuffle(I first,
+            S last,
+            Gen&amp;amp;&amp;amp; g); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Gen&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             uniform_random_bit_generator&amp;lt;remove_reference_t&amp;lt;Gen&amp;gt;&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    shuffle(R&amp;amp;&amp;amp; r,
+            Gen&amp;amp;&amp;amp; g); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -28,10 +36,10 @@ namespace std::ranges {
 
 
 ## 概要
-`[first,last)` のそれぞれの要素を同じ確率で並び替える。
+範囲のそれぞれの要素を同じ確率で並び替える。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort.md b/reference/algorithm/ranges_sort.md
index f4298012f..c5b53212b 100644
--- a/reference/algorithm/ranges_sort.md
+++ b/reference/algorithm/ranges_sort.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I sort(I first, S last, Comp comp = {}, Proj proj = {});            // (1)
-
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    sort(I first,
+         S last,
+         Comp comp = {},
+         Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; sort(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {}); // (2)
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    sort(R&amp;amp;&amp;amp; r,
+         Comp comp = {},
+         Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -27,8 +39,8 @@ namespace std::ranges {
 ## 概要
 範囲を並べ替える
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_sort_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort_heap.md b/reference/algorithm/ranges_sort_heap.md
index 30ba28e9c..99b319819 100644
--- a/reference/algorithm/ranges_sort_heap.md
+++ b/reference/algorithm/ranges_sort_heap.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  constexpr I sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  constexpr I
+    sort_heap(I first,
+              S last,
+              Comp comp = {},
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; sort_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    sort_heap(R&amp;amp;&amp;amp; r,
+              Comp comp = {},
+              Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -29,8 +39,8 @@ namespace std::ranges {
 ## 概要
 ヒープ化された範囲を並べ替える
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 事前条件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_partition -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_partition.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_stable_partition.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_partition.md b/reference/algorithm/ranges_stable_partition.md
index 8e013befc..8cfe53f6f 100644
--- a/reference/algorithm/ranges_stable_partition.md
+++ b/reference/algorithm/ranges_stable_partition.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires permutable&amp;lt;I&amp;gt;
-  subrange&amp;lt;I&amp;gt; stable_partition(I first, S last, Pred pred, Proj proj = {});
-
-  // (2)
-  template&amp;lt;bidirectional_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  subrange&amp;lt;I&amp;gt;
+    stable_partition(I first,
+                     S last,
+                     Pred pred,
+                     Proj proj = {}); // (1) C++20
+
+  template &amp;lt;bidirectional_range R,
+            class Proj = identity,
+            indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  borrowed_subrange_t&amp;lt;R&amp;gt; stable_partition(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+  borrowed_subrange_t&amp;lt;R&amp;gt;
+    stable_partition(R&amp;amp;&amp;amp; r,
+                     Pred pred,
+                     Proj proj = {}); // (2) C++20
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -32,8 +42,8 @@ namespace std::ranges {
 ## 概要
 与えられた範囲を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_stable_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_sort.md b/reference/algorithm/ranges_stable_sort.md
index ba21cfd28..2564b1bc7 100644
--- a/reference/algorithm/ranges_stable_sort.md
+++ b/reference/algorithm/ranges_stable_sort.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+  template &amp;lt;random_access_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
-  I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});            // (1)
-
-  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+  I
+    stable_sort(I first,
+                S last,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;random_access_range R,
+            class Comp = ranges::less,
+            class Proj = identity&amp;gt;
     requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
-  borrowed_iterator_t&amp;lt;R&amp;gt; stable_sort(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {}); // (2)
+  borrowed_iterator_t&amp;lt;R&amp;gt;
+    stable_sort(R&amp;amp;&amp;amp; r,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -27,8 +39,8 @@ namespace std::ranges {
 ## 概要
 範囲を安定ソートで並べ替える
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 効果
 `[first,last)` の範囲をソートする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>starts_with -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_starts_with.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_starts_with.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_starts_with.md b/reference/algorithm/ranges_starts_with.md
index 2db8929a4..8331f84c9 100644
--- a/reference/algorithm/ranges_starts_with.md
+++ b/reference/algorithm/ranges_starts_with.md
@@ -6,13 +6,35 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  constexpr bool
+    starts_with(I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            class Pred = ranges::equal_to,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool starts_with(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr bool
+    starts_with(R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2,
+                Pred pred = {},
+                Proj1 proj1 = {},
+                Proj2 proj2 = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -27,8 +49,8 @@ namespace std::ranges {
 ## 概要
 シーケンスの先頭が指定されたシーケンスと一致するかを調べる
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 戻り値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap_ranges -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_swap_ranges.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_swap_ranges.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_swap_ranges.md b/reference/algorithm/ranges_swap_ranges.md
index d70e346ff..78f4b5343 100644
--- a/reference/algorithm/ranges_swap_ranges.md
+++ b/reference/algorithm/ranges_swap_ranges.md
@@ -6,13 +6,25 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2&amp;gt;
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2&amp;gt;
     requires indirectly_swappable&amp;lt;I1, I2&amp;gt;
-  constexpr swap_ranges_result&amp;lt;I1, I2&amp;gt; swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);                   // (1)
-
-  template&amp;lt;input_range R1, input_range R2&amp;gt;
+  constexpr swap_ranges_result&amp;lt;I1, I2&amp;gt;
+    swap_ranges(I1 first1,
+                S1 last1,
+                I2 first2,
+                S2 last2); // (1) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2&amp;gt;
     requires indirectly_swappable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;&amp;gt;
-  constexpr swap_ranges_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; swap_ranges(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2); // (2)
+  constexpr swap_ranges_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt;
+    swap_ranges(R1&amp;amp;&amp;amp; r1,
+                R2&amp;amp;&amp;amp; r2); // (2) C++20
 }
 ```
 * swap_ranges_result[link ranges_in_in_result.md]
@@ -26,8 +38,8 @@ namespace std::ranges {
 ## 概要
 指定された2つの範囲同士を swap する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_transform.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_transform.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_transform.md b/reference/algorithm/ranges_transform.md
index 5521d8619..9586ce3e7 100644
--- a/reference/algorithm/ranges_transform.md
+++ b/reference/algorithm/ranges_transform.md
@@ -6,29 +6,80 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, copy_constructible F, class Proj = identity&amp;gt;
-    requires indirectly_writable&amp;lt;O, indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I, Proj&amp;gt;&amp;gt;&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I, Proj&amp;gt;&amp;gt;
+             &amp;gt;
   constexpr unary_transform_result&amp;lt;I, O&amp;gt;
-    transform(I first1, S last1, O result, F op, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, copy_constructible F, class Proj = identity&amp;gt;
-    requires indirectly_writable&amp;lt;O, indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;&amp;gt;
+    transform(I first1,
+              S last1,
+              O result,
+              F op,
+              Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            copy_constructible F,
+            class Proj = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+             &amp;gt;
   constexpr unary_transform_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    transform(R&amp;amp;&amp;amp; r, O result, F op, Proj proj = {});
-
-  // (3)
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O, copy_constructible F, class Proj1 = identity, class Proj2 = identity&amp;gt;
-    requires indirectly_writable&amp;lt;O, indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;&amp;gt;
+    transform(R&amp;amp;&amp;amp; r,
+              O result,
+              F op,
+              Proj proj = {}); // (2) C++20
+
+  template &amp;lt;input_iterator I1,
+            sentinel_for&amp;lt;I1&amp;gt; S1,
+            input_iterator I2,
+            sentinel_for&amp;lt;I2&amp;gt; S2,
+            weakly_incrementable O,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
   constexpr binary_transform_result&amp;lt;I1, I2, O&amp;gt;
-    transform(I1 first1, S1 last1, I2 first2, S2 last2, O result, F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
-
-  // (4)
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O, copy_constructible F, class Proj1 = identity, class Proj2 = identity&amp;gt;
-    requires indirectly_writable&amp;lt;O, indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;&amp;gt;
-  constexpr binary_transform_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
-    transform(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
+    transform(I1 first1,
+              S1 last1,
+              I2 first2,
+              S2 last2,
+              O result,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (3) C++20
+
+  template &amp;lt;input_range R1,
+            input_range R2,
+            weakly_incrementable O,
+            copy_constructible F,
+            class Proj1 = identity,
+            class Proj2 = identity&amp;gt;
+    requires indirectly_writable&amp;lt;
+               O,
+               indirect_result_t&amp;lt;F&amp;amp;, projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;,
+               projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt;
+             &amp;gt;
+  constexpr binary_transform_result&amp;lt;
+              borrowed_iterator_t&amp;lt;R1&amp;gt;,
+              borrowed_iterator_t&amp;lt;R2&amp;gt;,
+              O
+            &amp;gt;
+    transform(R1&amp;amp;&amp;amp; r1,
+              R2&amp;amp;&amp;amp; r2,
+              O result,
+              F binary_op,
+              Proj1 proj1 = {},
+              Proj2 proj2 = {}); // (4) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -49,11 +100,12 @@ namespace std::ranges {
 ## 概要
 全ての要素に関数を適用する。
 
-* (1), (2): 1つの範囲の要素に関数を適用し、結果を出力イテレータに出力する
-* (3), (4): 2つの範囲の要素を1つずつ取り出して関数を適用し、結果を出力イテレータに出力する
+- (1), (2): 1つの範囲の要素に関数を適用し、結果を出力イテレータに出力する
+- (3), (4): 2つの範囲の要素を1つずつ取り出して関数を適用し、結果を出力イテレータに出力する
+
+- (1), (3): イテレータ範囲を指定する
+- (2), (4): Rangeを直接指定する
 
-* (1), (3): イテレータペアで範囲を指定する
-* (2), (4): 範囲を直接指定する
 
 ## 事前条件
 - (1), (2) : `op` は、`[first,last]`, `[result,result + (last - first)]` 内のイテレータや subrange を無効にしたり、要素を書き換えてはならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_unique.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique.md b/reference/algorithm/ranges_unique.md
index 94dbae1b9..06b8f9d15 100644
--- a/reference/algorithm/ranges_unique.md
+++ b/reference/algorithm/ranges_unique.md
@@ -6,14 +6,24 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; unique(I first, S last, C comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;forward_range R, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    unique(I first,
+           S last,
+           C comp = {},
+           Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
     requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; unique(R&amp;amp;&amp;amp; r, C comp = {}, Proj proj = {});
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    unique(R&amp;amp;&amp;amp; r,
+           C comp = {},
+           Proj proj = {}); // (2) C++20
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -30,8 +40,8 @@ namespace std::ranges {
 ## 概要
 重複した要素を除ける。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 この関数は、隣り合った重複要素を除いた要素を、範囲の先頭に集める。この関数によってコンテナから直接要素が削除され、コンテナの要素数が減るようなことはない。コンテナから実際に要素を削除する場合は、この関数の戻り値として、先頭に集められた重複なし範囲の末尾の次を指すイテレータが返るため、そのイテレータを介してコンテナの`erase()`メンバ関数などを呼び出し、削除を行うこと。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/ranges_unique_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique_copy.md b/reference/algorithm/ranges_unique_copy.md
index f418c4473..ffea34d91 100644
--- a/reference/algorithm/ranges_unique_copy.md
+++ b/reference/algorithm/ranges_unique_copy.md
@@ -6,19 +6,37 @@
 
 ```cpp
 namespace std::ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
-      (forward_iterator&amp;lt;I&amp;gt; || (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;iter_value_t&amp;lt;I&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) || indirectly_copyable_storable&amp;lt;I, O&amp;gt;)
+             (forward_iterator&amp;lt;I&amp;gt; ||
+               (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;iter_value_t&amp;lt;I&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) ||
+               indirectly_copyable_storable&amp;lt;I, O&amp;gt;
+             )
   constexpr unique_copy_result&amp;lt;I, O&amp;gt;
-    unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, weakly_incrementable O, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    unique_copy(I first,
+                S last,
+                O result,
+                C comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Proj = identity,
+            indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
     requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
-      (forward_iterator&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; || (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;range_value_t&amp;lt;R&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) || indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;)
+             (forward_iterator&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; ||
+               (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;range_value_t&amp;lt;R&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) ||
+               indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+             )
   constexpr unique_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
-    unique_copy(R&amp;amp;&amp;amp; r, O result, C comp = {}, Proj proj = {});
+    unique_copy(R&amp;amp;&amp;amp; r,
+                O result,
+                C comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -41,8 +59,8 @@ namespace std::ranges {
 ## 概要
 隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 ## 事前条件
 - `[first,last)` と `[result,result + (last - first))` は重なっていてはならない
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/remove.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove.md b/reference/algorithm/remove.md
index 5621a18d6..69147c900 100644
--- a/reference/algorithm/remove.md
+++ b/reference/algorithm/remove.md
@@ -27,11 +27,11 @@ namespace std {
 ```
 
 ## 概要
-指定された要素を取り除く。
+イテレータ範囲`[first, last)`から`指定された要素を取り除く。
 
 
-## 要件
-`*first` の型は `MoveAssignable` の要件を満たす必要がある
+## テンプレートパラメータ制約
+- `*first` の型は `MoveAssignable` の要件を満たすこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/remove_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove_copy.md b/reference/algorithm/remove_copy.md
index a6a55fa99..2e9046c39 100644
--- a/reference/algorithm/remove_copy.md
+++ b/reference/algorithm/remove_copy.md
@@ -31,12 +31,16 @@ namespace std {
 ```
 
 ## 概要
-指定された要素を除け、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`から指定された要素を除け、その結果を出力の範囲へコピーする。
 
 
-## 要件
+## テンプレートパラメータ制約
+- `*result = *first` という式が有効であること
+
+
+## 事前条件
 - `[first,last)` と `[result,result + (last - first)` は重なってはならない。
-- `*result = *first` という式が有効でなければならない。
+
 
 ## 効果
 `[first,last)` 内にあるイテレータ `i` について、`*i == value` でない要素を `result` へコピーする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/remove_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove_copy_if.md b/reference/algorithm/remove_copy_if.md
index 392e2355d..aafd67fa6 100644
--- a/reference/algorithm/remove_copy_if.md
+++ b/reference/algorithm/remove_copy_if.md
@@ -31,12 +31,15 @@ namespace std {
 ```
 
 ## 概要
-条件を満たす要素を除け、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`から条件を満たす要素を除け、その結果を出力の範囲へコピーする。
 
 
-## 要件
-- `[first,last)` と `[result,result + (last - first)` は重なってはならない。
-- `*result = *first` という式が有効でなければならない。
+## テンプレートパラメータ制約
+- `*result = *first` という式が有効であること
+
+
+## 事前条件
+- `[first,last)` と `[result,result + (last - first)` は重なってはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/remove_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove_if.md b/reference/algorithm/remove_if.md
index 5491b2e78..3f1ecb2d9 100644
--- a/reference/algorithm/remove_if.md
+++ b/reference/algorithm/remove_if.md
@@ -27,11 +27,11 @@ namespace std {
 ```
 
 ## 概要
-条件を満たす要素を除ける。
+イテレータ範囲`[first, last)`から条件を満たす要素を除ける。
 
 
-## 要件
-`*first` の型は `MoveAssignable` の要件を満たす必要がある
+## テンプレートパラメータ制約
+- `*first` の型は `MoveAssignable` の要件を満たすこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/replace_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/replace_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/replace_copy.md b/reference/algorithm/replace_copy.md
index 80cdf9570..9b8e28518 100644
--- a/reference/algorithm/replace_copy.md
+++ b/reference/algorithm/replace_copy.md
@@ -33,12 +33,15 @@ namespace std {
 ```
 
 ## 概要
-指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`のうち、指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 
-## 要件
-- `*first` と `new_value` は `result` へ書き込み可能でなければならない。
-- また、`[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
+## テンプレートパラメータ制約
+- `*first` と `new_value` は `result` へ書き込み可能であること
+
+
+## 事前条件
+- `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/replace_copy_if.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/replace_copy_if.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/replace_copy_if.md b/reference/algorithm/replace_copy_if.md
index 7bb492d07..82635adc8 100644
--- a/reference/algorithm/replace_copy_if.md
+++ b/reference/algorithm/replace_copy_if.md
@@ -42,12 +42,15 @@ namespace std {
 ```
 
 ## 概要
-条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`のうち、条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする。
 
 
-## 要件
-- `*first` と `new_value` は `result` へ書き込み可能でなければならない。
-- また、`[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない。
+## テンプレートパラメータ制約
+- `*first` と `new_value` は `result` へ書き込み可能であること
+
+
+## 事前条件
+- `[first,last)` と `[result,result + (last - first))` の範囲が重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/reverse_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/reverse_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/reverse_copy.md b/reference/algorithm/reverse_copy.md
index 72bfed87f..6c8a9f7c9 100644
--- a/reference/algorithm/reverse_copy.md
+++ b/reference/algorithm/reverse_copy.md
@@ -27,11 +27,11 @@ namespace std {
 ```
 
 ## 概要
-要素の並びを逆にし、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`の要素順を逆にし、その結果を出力の範囲へコピーする。
 
 
-## 要件
-`[first,last)` と `[result,result+(last-first))` は領域が重なっていてはならない。
+## 事前条件
+- `[first,last)` と `[result,result+(last-first))` は領域が重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/rotate.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/rotate.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/rotate.md b/reference/algorithm/rotate.md
index b88dc9e12..9c70fa70e 100644
--- a/reference/algorithm/rotate.md
+++ b/reference/algorithm/rotate.md
@@ -33,13 +33,16 @@ namespace std {
 ```
 
 ## 概要
-`middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させる。
+`middle`の要素が先頭、`middle-1`の要素が末尾となるように、イテレータ範囲`[first,last)`の要素の並びを回転させる。
 
 
 ## 要件
-- `[first,middle)` と `[middle,last)` は有効な範囲である必要がある。
-- `ForwardIterator` は `ValueSwappable` の要件を満たしている必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+- `ForwardIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+
+
+## 事前条件
+- `[first,middle)` と `[middle,last)` は有効な範囲であること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/rotate_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/rotate_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/rotate_copy.md b/reference/algorithm/rotate_copy.md
index b754faaa9..f7c3e7c03 100644
--- a/reference/algorithm/rotate_copy.md
+++ b/reference/algorithm/rotate_copy.md
@@ -30,11 +30,11 @@ namespace std {
 ```
 
 ## 概要
-`middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
+`middle`の要素が先頭、`middle-1`の要素が末尾となるように、イテレータ範囲`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
 
 
-## 要件
-`[first,last)` と `[result,result + (last - first))` の範囲は重なっていてはならない。
+## 事前条件
+- `[first,last)` と `[result,result + (last - first))` の範囲は重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sample -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/sample.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/sample.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/sample.md b/reference/algorithm/sample.md
index 4ce288a1e..3e7e12ed7 100644
--- a/reference/algorithm/sample.md
+++ b/reference/algorithm/sample.md
@@ -7,30 +7,37 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class PopulationIterator, class SampleIterator,
-            class Distance, class UniformRandomBitGenerator&amp;gt;
-  SampleIterator sample(PopulationIterator first, PopulationIterator last,
-                        SampleIterator out, Distance n,
-                        UniformRandomBitGenerator&amp;amp;&amp;amp; g);
+  template &amp;lt;class PopulationIterator,
+            class SampleIterator,
+            class Distance,
+            class UniformRandomBitGenerator&amp;gt;
+  SampleIterator
+    sample(PopulationIterator first,
+           PopulationIterator last,
+           SampleIterator out, Distance n,
+           UniformRandomBitGenerator&amp;amp;&amp;amp; g);
 }
 ```
 
 ## 概要
-範囲から指定された個数の要素をランダムに抽出する。
+イテレータ範囲`[first, last)`から指定された個数の要素をランダムに抽出する。
 
 
-## 要件
+## テンプレートパラメータ制約
 - `PopulationIterator` は `InputIterator` の要件を満たしていること
 - `SampleIterator` は `OutputIterator` の要件を満たしていること
 - `PopulationIterator`が `ForwardIterator` の要件を満たさない限り、`SampleIterator`は`RandomAccessIterator`の要件を満たさなければならない
 - `PopulationIterator`の値型は`out`に対して書き込めなければならない
 - `Distance`は整数型であること
 - `UniformRandomBitGenerator` は uniform random bit generator の要件を満たさなければならず、その戻り値の型は`Distance`型へ変換可能でなければならない
-- `out`は範囲`[first, last)`に含まれてはならない
+
+
+## 事前条件
+- `out`はイテレータ範囲`[first, last)`に含まれてはならない
 
 
 ## 効果
-範囲`[first, last)`を母集団 (population) とし、そこから[`min`](min.md)`(last - first, n)`個の要素を標本 (sample) として `out` にコピーする (`n`が入力範囲の要素数より大きい場合は、最大で入力範囲の要素数がコピーされる)。
+イテレータ範囲`[first, last)`を母集団 (population) とし、そこから[`min`](min.md)`(last - first, n)`個の要素を標本 (sample) として `out` にコピーする (`n`が入力範囲の要素数より大きい場合は、最大で入力範囲の要素数がコピーされる)。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/search.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/search.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/search.md b/reference/algorithm/search.md
index 05fd1d429..ab73e1014 100644
--- a/reference/algorithm/search.md
+++ b/reference/algorithm/search.md
@@ -71,8 +71,8 @@ namespace std {
 ## 概要
 あるシーケンスの中から、特定のサブシーケンスを探す
 
-- (1) : 範囲`[first1, last1)`内からサブシーケンス`[first2, last2)`を検索する。各要素の等値比較として`operator==`を使用する
-- (2) : 範囲`[first1, last1)`内からサブシーケンス`[first2, last2)`を検索する。各要素の等値比較として二項述語関数オブジェクト`pred`を使用する
+- (1) : イテレータ範囲`[first1, last1)`内からサブシーケンス`[first2, last2)`を検索する。各要素の等値比較として`operator==`を使用する
+- (2) : イテレータ範囲`[first1, last1)`内からサブシーケンス`[first2, last2)`を検索する。各要素の等値比較として二項述語関数オブジェクト`pred`を使用する
 - (3) : (1)の並列アルゴリズム版。第1パラメータとして実行ポリシーをとる
 - (4) : (2)の並列アルゴリズム版。第1パラメータとして実行ポリシーをとる
 - (5) : 対象となるサブシーケンスを包含する`sercher`関数オブジェクトを使用して、範囲`[first, last)`から対象のサブシーケンスを検索する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/set_difference.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/set_difference.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/set_difference.md b/reference/algorithm/set_difference.md
index ed5ad3c05..453f1e21a 100644
--- a/reference/algorithm/set_difference.md
+++ b/reference/algorithm/set_difference.md
@@ -65,11 +65,11 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲の差集合を得る
+2つのソート済み範囲`[first1, last1)`と`[first2, last2)`の差集合を得る
 
 
-## 要件
-結果の範囲は両方の入力の範囲と重なっていてはならない。
+## 事前条件
+- 結果の範囲は両方の入力の範囲と重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/set_intersection.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/set_intersection.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/set_intersection.md b/reference/algorithm/set_intersection.md
index efa0e9c61..413e91de6 100644
--- a/reference/algorithm/set_intersection.md
+++ b/reference/algorithm/set_intersection.md
@@ -65,15 +65,15 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲の積集合を得る
+2つのソート済み範囲`[first1, last1)`と`[first2, last2)`の積集合を得る
 
 
-## 要件
-結果の範囲は両方の入力の範囲と重なっていてはならない。
+## 事前条件
+- 結果の範囲は両方の入力の範囲と重なっていてはならない
 
 
 ## 効果
-２つの範囲からソート済みの intersection を構築する。つまり、両方の範囲のみにある要素の集合を構築する。
+２つの範囲からソート済みの積集合を構築する。つまり、両方の範囲のみにある要素の集合を構築する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/set_symmetric_difference.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/set_symmetric_difference.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/set_symmetric_difference.md b/reference/algorithm/set_symmetric_difference.md
index ea0bc5923..3e5cd1a0f 100644
--- a/reference/algorithm/set_symmetric_difference.md
+++ b/reference/algorithm/set_symmetric_difference.md
@@ -67,11 +67,11 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
+2つのソート済み範囲`[first1, last1)`と`[first2, last2)`の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
 
 
-## 要件
-結果の範囲は両方の入力の範囲と重なっていてはならない。
+## 事前条件
+- 結果の範囲は両方の入力の範囲と重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/set_union.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/set_union.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/set_union.md b/reference/algorithm/set_union.md
index 4aeb00708..b33c11063 100644
--- a/reference/algorithm/set_union.md
+++ b/reference/algorithm/set_union.md
@@ -65,11 +65,11 @@ namespace std {
 ```
 
 ## 概要
-2つのソート済み範囲の和集合を得る
+2つのソート済み範囲`[first1, last1)`と`[first2, last2)`の和集合を得る
 
 
-## 要件
-結果の範囲は両方の入力の範囲と重なっていてはならない。
+## 事前条件
+- 結果の範囲は両方の入力の範囲と重なっていてはならない
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_left -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/shift_left.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/shift_left.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/shift_left.md b/reference/algorithm/shift_left.md
index cccec8be0..25010f71a 100644
--- a/reference/algorithm/shift_left.md
+++ b/reference/algorithm/shift_left.md
@@ -23,7 +23,7 @@ namespace std {
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-範囲の要素をn個だけ左にシフトさせる。
+イテレータ範囲`[first, last)`の要素をn個だけ左にシフトさせる。
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_right -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/shift_right.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/shift_right.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/shift_right.md b/reference/algorithm/shift_right.md
index f4b82ff32..06fe7d1ac 100644
--- a/reference/algorithm/shift_right.md
+++ b/reference/algorithm/shift_right.md
@@ -23,7 +23,7 @@ namespace std {
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-範囲の要素をn個だけ右にシフトさせる。
+イテレータ範囲`[first, last)`の要素をn個だけ右にシフトさせる。
 
 この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/sort.md b/reference/algorithm/sort.md
index 40a654951..0336f637b 100644
--- a/reference/algorithm/sort.md
+++ b/reference/algorithm/sort.md
@@ -37,7 +37,7 @@ namespace std {
 ```
 
 ## 概要
-範囲を並べ替える
+イテレータ範囲`[first, last)`を並べ替える
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort_heap -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/sort_heap.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/sort_heap.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/sort_heap.md b/reference/algorithm/sort_heap.md
index 749084801..1d9fdf81a 100644
--- a/reference/algorithm/sort_heap.md
+++ b/reference/algorithm/sort_heap.md
@@ -26,13 +26,16 @@ namespace std {
 ```
 
 ## 概要
-ヒープ化された範囲を並べ替える
+ヒープ化されたイテレータ範囲`[first, last)`を並べ替える
 
 
-## 要件
-- `[first,last)` は有効なヒープである必要がある。
-- `RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
+
+
+## 事前条件
+- `[first,last)` は有効なヒープであること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_partition -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/stable_partition.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/stable_partition.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/stable_partition.md b/reference/algorithm/stable_partition.md
index 523787490..38d2af6d8 100644
--- a/reference/algorithm/stable_partition.md
+++ b/reference/algorithm/stable_partition.md
@@ -21,12 +21,12 @@ namespace std {
 ```
 
 ## 概要
-与えられた範囲を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
+与えられたイテレータ範囲`[first, last)`を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
 
 
-## 要件
-- `BidirectionalIterator` は `ValueSwappable` の要件を満たしている必要がある。
-- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `BidirectionalIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_sort -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/stable_sort.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/stable_sort.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/stable_sort.md b/reference/algorithm/stable_sort.md
index 259e69362..0f77c873b 100644
--- a/reference/algorithm/stable_sort.md
+++ b/reference/algorithm/stable_sort.md
@@ -28,11 +28,12 @@ namespace std {
 ```
 
 ## 概要
-範囲を安定ソートで並べ替える
+イテレータ範囲`[first, last)`を安定ソートで並べ替える
 
 
-## 要件
-`RandomAccessIterator` は `ValueSwappable` の要件を満たしている必要がある。`*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしている必要がある。
+## テンプレートパラメータ制約
+- `RandomAccessIterator` は `ValueSwappable` の要件を満たしていること
+- `*first` の型は `MoveConstructible` と `MoveAssignable` の要件を満たしていること
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap_ranges -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/swap_ranges.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/swap_ranges.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/swap_ranges.md b/reference/algorithm/swap_ranges.md
index b9fa83591..bee7ceb7b 100644
--- a/reference/algorithm/swap_ranges.md
+++ b/reference/algorithm/swap_ranges.md
@@ -27,16 +27,16 @@ namespace std {
 ```
 
 ## 概要
-指定された2つの範囲同士を swap する。
+指定された2つの範囲`[first1, last1)`と`[first2, first2 + (last1 - first1))`を入れ替える。
 
 
-## 効果
-0 以上 `last1 - first1` 以下のそれぞれの `n` について [`swap`](/reference/utility/swap.md)`(*(first1 + n), *(first2 + n))` を行う
+## 事前条件
+- `[first1,last1)` と `[first2,first2 + (last1 - first1))` の範囲が重なってはならない。
+- 0 以上 `last1 - first1` 未満のそれぞれの `n` について、`*(first1 + n) と *(first2 + n)` は `Swappable` でなければならない。
 
 
-## 要件
-`[first1,last1)` と `[first2,first2 + (last1 - first1))` の範囲が重なってはならない。
-0 以上 `last1 - first1` 未満のそれぞれの `n` について、`*(first1 + n) と *(first2 + n)` は `Swappable` でなければならない。
+## 効果
+0 以上 `last1 - first1` 以下のそれぞれの `n` について [`swap`](/reference/utility/swap.md)`(*(first1 + n), *(first2 + n))` を行う
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/unique.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/unique.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/unique.md b/reference/algorithm/unique.md
index 9f03493b0..8bb57b3bf 100644
--- a/reference/algorithm/unique.md
+++ b/reference/algorithm/unique.md
@@ -43,7 +43,7 @@ namespace std {
 ```
 
 ## 概要
-重複した要素を除ける。
+イテレータ範囲`[first, last)`から重複した要素を除ける。
 
 この関数は、隣り合った重複要素を除いた要素を、範囲の先頭に集める。この関数によってコンテナから直接要素が削除され、コンテナの要素数が減るようなことはない。コンテナから実際に要素を削除する場合は、この関数の戻り値として、先頭に集められた重複なし範囲の末尾の次を指すイテレータが返るため、そのイテレータを介してコンテナの`erase()`メンバ関数などを呼び出し、削除を行うこと。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique_copy -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/unique_copy.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/unique_copy.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/unique_copy.md b/reference/algorithm/unique_copy.md
index 2bd79ada8..b2b33ae23 100644
--- a/reference/algorithm/unique_copy.md
+++ b/reference/algorithm/unique_copy.md
@@ -52,7 +52,7 @@ namespace std {
 ```
 
 ## 概要
-隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
+イテレータ範囲`[first, last)`から隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- 言語機能と&lt;algorithm&gt;で、できるだけイテレータ範囲という用語を使用するようにした #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/upper_bound.html"/>
      <id>192dae64b0e9b9d9e42f73fe1036b5990e7c0741:reference/algorithm/upper_bound.md</id>
      <updated>2022-12-28T00:47:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/upper_bound.md b/reference/algorithm/upper_bound.md
index 025155cfe..3ce4be90a 100644
--- a/reference/algorithm/upper_bound.md
+++ b/reference/algorithm/upper_bound.md
@@ -34,7 +34,7 @@ namespace std {
 ```
 
 ## 概要
-指定された要素より大きい値が現れる最初の位置のイテレータを取得する
+イテレータ範囲`[first, last)`のうち、指定された要素より大きい値が現れる最初の位置のイテレータを取得する
 
 
 ## 要件
@@ -43,11 +43,11 @@ namespace std {
 	- `comp` は 2 引数の関数オブジェクトで、結果の型は `bool` 型に変換可能であること。また、引数に非 `const` の関数を適用しないこと。
 	- `T` は `LessThanComparable` であること。
 	- `operator&amp;lt;` または `comp` は「[狭義の弱順序](../algorithm.md#strict-weak-ordering)」であること。
-	- 範囲 `[first, last)` は `operator&amp;lt;` または `comp` を基準として昇順に並んでいること。
+	- イテレータ範囲 `[first, last)` は `operator&amp;lt;` または `comp` を基準として昇順に並んでいること。
 - C++11 から
 	- `first`、`last` は前方向イテレータの要件を満たすこと。
 	- `comp` は 2 引数の関数オブジェクトで、結果の型は `bool` 型に変換可能であること。また、引数に非 `const` の関数を適用しないこと。
-	- `[first,last)` の要素 `e` は `!(value &amp;lt; e)` または `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。  
+	- イテレータ範囲`[first,last)` の要素 `e` は `!(value &amp;lt; e)` または `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。  
 		つまり、`!(value &amp;lt; e)` または `!comp(value, e)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンパイラの実装状況 -- リンク修正 #722</title>
      <link href="https://cpprefjp.github.io/implementation-status.html"/>
      <id>04d615cbcb38f467db47a9956c61715ff9831fab:implementation-status.md</id>
      <updated>2022-12-27T18:32:47+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;コンパイラの実装状況&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このページでは、C++のバージョンごとの言語機能を、どのコンパイラがどのバージョンからサポートしているかをまとめる。&lt;/p&gt;
&lt;p&gt;ライブラリ機能については、本サイトのリファレンスで各機能を参照してもらいたい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp11&#34;&gt;C++11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp14&#34;&gt;C++14&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp17&#34;&gt;C++17&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp20&#34;&gt;C++20&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp23&#34;&gt;C++23&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp11&#34; id=&#34;cpp11&#34;&gt;C++11言語機能の実装状況&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#icc&#34;&gt;ICC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;MSVC&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;N2341: &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alignas.html&#34;&gt;alignas&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメント指定&lt;/td&gt;
&lt;td&gt;4.8&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2015&lt;br /&gt;2003あるいはそれ以前からある&lt;code&gt;__declspec(align(x))&lt;/code&gt;構文で代替可能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2341: &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alignof.html&#34;&gt;alignof&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメント取得&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;td&gt;3.3&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2015&lt;br /&gt;2003あるいはそれ以前よりある&lt;code&gt;__alignof&lt;/code&gt;で代替可能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N1984: &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/auto.html&#34;&gt;auto&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型推論&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;2010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2343: &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/decltype.html&#34;&gt;decltype&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;式の型を取得&lt;/td&gt;
&lt;td&gt;4.3&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;13.0&lt;/td&gt;
&lt;td&gt;2010 (partial)&lt;br /&gt; 2012&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N1653: C99互換のプリプロセッサ&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/variadic_macros.html&#34;&gt;可変引数マクロ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/pragma_operator.html&#34;&gt;Pragma演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/func.html&#34;&gt;__func__&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4.3&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.1&lt;/td&gt;
&lt;td&gt;2005 (partial): 可変引数のみ &lt;code&gt;_Pragma&lt;/code&gt;の代わりに&lt;code&gt;__pragma&lt;/code&gt;が存在する。&lt;br /&gt; 2019 Update 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2235: &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/constexpr.html&#34;&gt;constexpr&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定数式&lt;/td&gt;
&lt;td&gt;4.6&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;13.0 (partial)&lt;br /&gt; 14.0&lt;/td&gt;
&lt;td&gt;2015 (partial)&lt;br /&gt; 2015 Update 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2346: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/defaulted_and_deleted_functions.html&#34;&gt;関数の&lt;code&gt;default/delete&lt;/code&gt;宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;自動定義される特殊関数の制御&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;2013: ムーブコンストラクタ・ムーブ代入演算子の&lt;code&gt;default&lt;/code&gt;は不可&lt;br /&gt; 2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N1986: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/delegating_constructors.html&#34;&gt;委譲コンストラクタ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタから他のコンストラクタに処理を委譲する&lt;/td&gt;
&lt;td&gt;4.7&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2437: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/explicit_conversion_operator.html&#34;&gt;明示的な型変換演算子のオーバーロード&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;明示的な型変換が行われる場合にのみ呼び出される演算子をオーバーロードできるようにする&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N1791: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/extend_friend_targets.html&#34;&gt;&lt;code&gt;friend&lt;/code&gt;宣言できる対象を拡張&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータや型の別名を&lt;code&gt;friend&lt;/code&gt;宣言&lt;/td&gt;
&lt;td&gt;4.7&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.1 (partial) &lt;br /&gt; 12.0&lt;/td&gt;
&lt;td&gt;2010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N1987: &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/extern_template.html&#34;&gt;extern template&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートのインスタンス化抑止&lt;/td&gt;
&lt;td&gt;3.3&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.1&lt;/td&gt;
&lt;td&gt;6.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2540: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/inheriting_constructors.html&#34;&gt;継承コンストラクタ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;基底クラスのコンストラクタを継承する&lt;/td&gt;
&lt;td&gt;4.8&lt;/td&gt;
&lt;td&gt;3.3&lt;/td&gt;
&lt;td&gt;15.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2927: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/lambda_expressions.html&#34;&gt;ラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクトをその場に書く&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;2010 (partial)&lt;br /&gt; 2012&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2657: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/local_and_unnamed_type_as_template_arguments.html&#34;&gt;ローカル型と無名型を、テンプレート引数として使用することを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ローカルおよび無名として定義したクラスや列挙型を、テンプレート引数として渡せるようにする&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;2010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N1811: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/long_long_type.html&#34;&gt;&lt;code&gt;long long&lt;/code&gt;型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;64ビット以上の大きさを持つ整数型&lt;/td&gt;
&lt;td&gt;4.3&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.1&lt;/td&gt;
&lt;td&gt;2003&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2535: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/inline_namespaces.html&#34;&gt;インライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ネストした名前空間に、透過的にアクセスする&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2249: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/char16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-16とUTF-32の文字型&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;12.1 (Windows: partial) &lt;br /&gt; 12.1 (GNU/Linux, macOS)&lt;br /&gt; 14.0&lt;/td&gt;
&lt;td&gt;2015&lt;br /&gt; 2010より組み込み型ではなく型の別名として存在する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2442: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/utf8_string_literals.html&#34;&gt;UTF-8文字列リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char&lt;/code&gt;の文字列をUTF-8エンコーディングするプレフィックス&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;12.1 (Windows: partial) &lt;br /&gt; 12.1 (GNU/Linux, macOS)&lt;br /&gt; 14.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2442: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/raw_string_literals.html&#34;&gt;生文字列リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルにRプレフィックスを付けることで、エスケープシーケンスを無視する&lt;/td&gt;
&lt;td&gt;4.5&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2765: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/user_defined_literals.html&#34;&gt;ユーザー定義リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リテラルのサフィックスをユーザー定義する&lt;/td&gt;
&lt;td&gt;4.7&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;15.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2541: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/trailing_return_types.html&#34;&gt;戻り値の型を後置する関数宣言構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;以下のような形式での関数宣言&lt;br /&gt; &lt;code&gt;auto f(arg_types...) -&amp;gt; return_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;2010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2431: &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/nullptr.html&#34;&gt;nullptr&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ヌルポインタを表すポインタリテラル&lt;/td&gt;
&lt;td&gt;4.6&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;11.1&lt;/td&gt;
&lt;td&gt;2010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N1757: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/right_angle_brackets.html&#34;&gt;テンプレートの右山カッコ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector&amp;lt;basic_string&amp;lt;char&amp;gt;&amp;gt;&lt;/code&gt;のように、&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;をスペースを空けずに記述可能にする&lt;/td&gt;
&lt;td&gt;4.3&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.1&lt;/td&gt;
&lt;td&gt;2005&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2118: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html&#34;&gt;右辺値参照・ムーブセマンティクス&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;右辺値によるオーバーロード、およびそれによるリソースの所有権移動&lt;/td&gt;
&lt;td&gt;4.3 (partial)&lt;br /&gt; 4.6&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;2010 (partial) ムーブコンストラクタと代入演算子の暗黙定義に対応していない。&lt;br /&gt; 2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N1720: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/static_assert.html&#34;&gt;コンパイル時アサート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に条件式が真であることを表明する&lt;/td&gt;
&lt;td&gt;4.3&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.1&lt;/td&gt;
&lt;td&gt;2010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2347: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/scoped_enum.html#extended-unscoped-enum&#34;&gt;&lt;code&gt;enum&lt;/code&gt;の先行宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4.6&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;11.1 (partial)&lt;br /&gt; 14.0&lt;/td&gt;
&lt;td&gt;2012&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2347: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/scoped_enum.html&#34;&gt;スコープを持つ列挙型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;強い型付けとスコープを持つ列挙型&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.1 (partial)&lt;br /&gt; 14.0&lt;/td&gt;
&lt;td&gt;2012&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2258: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/alias_templates.html&#34;&gt;エイリアステンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートによって型の別名を定義する&lt;/td&gt;
&lt;td&gt;4.7&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;12.1&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2544: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/unrestricted_unions.html&#34;&gt;共用体の制限解除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体のメンバ変数として、クラスオブジェクトを持つ&lt;/td&gt;
&lt;td&gt;4.6&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;14.0(Linux系OSおよびMacのみ。Windowsは非対応)&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2242: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/variadic_templates.html&#34;&gt;可変引数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;任意の数のテンプレートパラメータを受け取れるようにする&lt;/td&gt;
&lt;td&gt;4.3 (partial)&lt;br /&gt; 4.4&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;12.1&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2930: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/range_based_for.html&#34;&gt;範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;配列やコンテナといった範囲を表すオブジェクトを、簡潔に走査する&lt;/td&gt;
&lt;td&gt;4.6&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;13.0&lt;/td&gt;
&lt;td&gt;2012&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2928: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/override_final.html&#34;&gt;&lt;code&gt;override&lt;/code&gt;と&lt;code&gt;final&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ関数のオーバーライド指定、および派生クラスでのオーバーロードを禁止する指定&lt;/td&gt;
&lt;td&gt;4.7&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;2005 (partial): &lt;code&gt;override&lt;/code&gt;のみ。&lt;code&gt;final&lt;/code&gt;の代わりにsealedが存在する。ただし両者ともデストラクタには指定できない。&lt;br /&gt; 2012&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2761: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/attributes.html&#34;&gt;属性構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[attr]]&lt;/code&gt;構文による、クラス、関数、変数の属性指定&lt;/td&gt;
&lt;td&gt;4.8&lt;/td&gt;
&lt;td&gt;3.3&lt;/td&gt;
&lt;td&gt;12.1&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2439: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/ref_qualifier_for_this.html&#34;&gt;メンバ関数の左辺値／右辺値修飾&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;オブジェクトが左辺値／右辺値の場合のみ呼び出し可能であることの指定&lt;/td&gt;
&lt;td&gt;4.8.1&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2756: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/non_static_data_member_initializers.html&#34;&gt;非静的メンバ変数の初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ変数を、宣言と同時に初期値指定する&lt;/td&gt;
&lt;td&gt;4.7&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2672: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/initializer_lists.html&#34;&gt;初期化子リスト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波括弧による初期化をユーザー定義する。&lt;code&gt;vector&amp;lt;int&amp;gt; v = {1, 2, 3};&lt;/code&gt;など。&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;14.0&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2672: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/uniform_initialization.html&#34;&gt;一様初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ呼び出しを波カッコで行う。 &lt;code&gt;T x { a, b, c };&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;13.0(partial)&lt;br /&gt; 14.0&lt;/td&gt;
&lt;td&gt;2013&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3050: &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/noexcept.html&#34;&gt;noexcept&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の例外指定、例外を投げる可能性のある式かbool値を返す演算子&lt;/td&gt;
&lt;td&gt;4.6&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;13.0(partial)&lt;br /&gt;14.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2634: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/sfinae_expressions.html&#34;&gt;任意の式によるSFINAE&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;特定の式が有効かどうかで、その関数をオーバーロード解決に含めるかどうかを決定する&lt;/td&gt;
&lt;td&gt;4.4&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;2015 Update 1 (partial)&lt;br /&gt; 2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2659: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/thread_local_storage.html&#34;&gt;スレッドローカルストレージ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;スレッドごとに異なる静的記憶域に保持される変数&lt;/td&gt;
&lt;td&gt;4.8&lt;/td&gt;
&lt;td&gt;3.3&lt;/td&gt;
&lt;td&gt;11.1 (partial)&lt;/td&gt;
&lt;td&gt;2010&lt;br /&gt; &lt;code&gt;__declspec(thread)&lt;/code&gt;属性での部分サポート&lt;br /&gt; 2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N2660: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/static_initialization_thread_safely.html&#34;&gt;ブロックスコープを持つ&lt;code&gt;static&lt;/code&gt;変数初期化のスレッドセーフ化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数ローカルで定義した&lt;code&gt;static&lt;/code&gt;変数の初期化を、スレッドセーフにする&lt;/td&gt;
&lt;td&gt;4.3&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.0 (Lnux/macOS)&lt;br /&gt; 14.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各処理系のC++11実装状況ページ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全体的な対応状況： &lt;a href=&#34;http://web.archive.org/web/20160327011707/https://wiki.apache.org/stdcxx/C++0xCompilerSupport&#34; target=&#34;_blank&#34;&gt;C++0xCompilerSupport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GCC： &lt;a href=&#34;https://gcc.gnu.org/projects/cxx-status.html#cxx11&#34; target=&#34;_blank&#34;&gt;C++11 Support in GCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libstdc++ : &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.2011&#34; target=&#34;_blank&#34;&gt;C++ 2011&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clang： &lt;a href=&#34;http://clang.llvm.org/cxx_status.html&#34; target=&#34;_blank&#34;&gt;C++98 and C++11 Support in Clang&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://clang.llvm.org/cxx_dr_status.html&#34; target=&#34;_blank&#34;&gt;C++ Defect Report Support in Clang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ICC : &lt;a href=&#34;https://software.intel.com/en-us/articles/c0x-features-supported-by-intel-c-compiler&#34; target=&#34;_blank&#34;&gt;C++11 Features Supported by Intel® C++ Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Visual C++ (MSVC):&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/cpp/visual-cpp-language-conformance&#34; target=&#34;_blank&#34;&gt;Visual C++ 言語への準拠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/&#34; target=&#34;_blank&#34;&gt;Announcing: MSVC Conforms to the C++ Standard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp14&#34; id=&#34;cpp14&#34;&gt;C++14言語機能の実装状況&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#icc&#34;&gt;ICC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;MSVC&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;N3472: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/binary_literals.html&#34;&gt;2進数リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2進数を表す&lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;プレフィックスを付けた数値リテラルの記述を可能とする&lt;/td&gt;
&lt;td&gt;4.3(GNU)&lt;br /&gt; 4.9&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3638: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/return_type_deduction_for_normal_functions.html&#34;&gt;通常関数の戻り値型推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値型を&lt;code&gt;auto&lt;/code&gt;にすることで、&lt;code&gt;return&lt;/code&gt;文から戻り値の型を推論させる&lt;/td&gt;
&lt;td&gt;4.8(partial)&lt;br /&gt;4.9&lt;/td&gt;
&lt;td&gt;3.3(partial)&lt;br /&gt; 3.4&lt;/td&gt;
&lt;td&gt;15.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3648: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/initialize_capture.html&#34;&gt;ラムダ式の初期化キャプチャ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャに代入構文を導入し、一つの変数に複数のキャプチャ方法を指定可能にする&lt;/td&gt;
&lt;td&gt;4.9&lt;/td&gt;
&lt;td&gt;3.4&lt;/td&gt;
&lt;td&gt;15.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3649: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/generic_lambdas.html&#34;&gt;ジェネリックラムダ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式のパラメータを&lt;code&gt;auto&lt;/code&gt;にすることで、ジェネリックな関数呼び出し演算子を持つ関数オブジェクトを生成する&lt;/td&gt;
&lt;td&gt;4.9&lt;/td&gt;
&lt;td&gt;3.4&lt;/td&gt;
&lt;td&gt;16.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3651: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/variable_templates.html&#34;&gt;変数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数定義時のテンプレート指定を可能にする。&lt;/td&gt;
&lt;td&gt;5.1&lt;/td&gt;
&lt;td&gt;3.4&lt;/td&gt;
&lt;td&gt;16.0&lt;/td&gt;
&lt;td&gt;2015 Update 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3652: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/relaxing_constraints_on_constexpr.html&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if&lt;/code&gt;文、&lt;code&gt;switch&lt;/code&gt;文による条件分岐の許可。&lt;br /&gt;&lt;code&gt;for&lt;/code&gt;文、&lt;code&gt;while&lt;/code&gt;文、&lt;code&gt;do-while&lt;/code&gt;文によるループの許可。&lt;br /&gt;&lt;code&gt;void&lt;/code&gt;戻り値型の許可&lt;br /&gt;初期化を伴う変数宣言の許可。&lt;br /&gt;変数書き換えの許可。&lt;/td&gt;
&lt;td&gt;5.1&lt;/td&gt;
&lt;td&gt;3.3(partial) &lt;br /&gt; 3.4&lt;/td&gt;
&lt;td&gt;16.0&lt;/td&gt;
&lt;td&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3653: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/brace_elision_in_array_temporary_initialization.html&#34;&gt;宣言時のメンバ初期化を持つ型の集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;一様初期化と初期化子リストを組み合わせた際、二重に波カッコが必要となっていた仕様を緩和し、波カッコを省略できるようにする&lt;/td&gt;
&lt;td&gt;5.1&lt;/td&gt;
&lt;td&gt;3.3&lt;/td&gt;
&lt;td&gt;16.0&lt;/td&gt;
&lt;td&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3760: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/deprecated_attr.html&#34;&gt;&lt;code&gt;[[deprecated]]&lt;/code&gt;属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非推奨の機能であることを示す属性。&lt;/td&gt;
&lt;td&gt;4.9&lt;/td&gt;
&lt;td&gt;3.4&lt;/td&gt;
&lt;td&gt;15.0&lt;br /&gt; (Linux/Mac OS)&lt;/td&gt;
&lt;td&gt;2015&lt;br /&gt;それ以前は&lt;code&gt;__declspec(deprecated)&lt;/code&gt;で代替可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3781: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/digit_separators.html&#34;&gt;数値リテラルの桁区切り文字&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;シングルクォーテーションで数値リテラルを桁区切りする。&lt;/td&gt;
&lt;td&gt;4.9&lt;/td&gt;
&lt;td&gt;3.4&lt;/td&gt;
&lt;td&gt;16.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3778: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp14/sized_deallocation.html&#34;&gt;サイズ付きデアロケーション&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;サイズをとる&lt;code&gt;delete&lt;/code&gt;演算子のオーバーロードを許可する。&lt;/td&gt;
&lt;td&gt;5.1&lt;/td&gt;
&lt;td&gt;3.4&lt;/td&gt;
&lt;td&gt;16.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各処理系のC++14実装状況ページ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: &lt;a href=&#34;https://gcc.gnu.org/projects/cxx-status.html#cxx14&#34; target=&#34;_blank&#34;&gt;C++14 Support in GCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libstdc++: &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.2014&#34; target=&#34;_blank&#34;&gt;C++ 2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clang: &lt;a href=&#34;http://clang.llvm.org/cxx_status.html&#34; target=&#34;_blank&#34;&gt;C++98, C++11, and C++14 Support in Clang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libc++: &lt;a href=&#34;https://libcxx.llvm.org/Status/Cxx14.html&#34; target=&#34;_blank&#34;&gt;libc++ C++14 Status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Visual C++ (MSVC):&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/cpp/visual-cpp-language-conformance&#34; target=&#34;_blank&#34;&gt;Visual C++ 言語への準拠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/&#34; target=&#34;_blank&#34;&gt;Announcing: MSVC Conforms to the C++ Standard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ICC: &lt;a href=&#34;https://software.intel.com/en-us/articles/c14-features-supported-by-intel-c-compiler&#34; target=&#34;_blank&#34;&gt;C++14 Features Supported by Intel C++ Compiler&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://software.intel.com/en-us/forums/topic/549502&#34; target=&#34;_blank&#34;&gt;Intel (R) Parallel Studio XE 2016 Beta program has begun&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp17&#34; id=&#34;cpp17&#34;&gt;C++17言語機能の実装状況&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#icc&#34;&gt;ICC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;MSVC&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;N3928: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/extending_static_assert.html&#34;&gt;メッセージなしの&lt;code&gt;static_assert&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトの表明メッセージを使用する&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N4086: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/removing_trigraphs.html&#34;&gt;トライグラフを削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5.1&lt;/td&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;td&gt;19.1&lt;/td&gt;
&lt;td&gt;2010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N4051: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/allow_typename_in_a_template_template_parameter.html&#34;&gt;テンプレートテンプレートパラメータに&lt;code&gt;typename&lt;/code&gt;を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;class&lt;/code&gt;キーワードしか使用できなかった部分に、&lt;code&gt;typename&lt;/code&gt;を許可&lt;/td&gt;
&lt;td&gt;5.0&lt;/td&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;td&gt;17.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N3922: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/new_rules_for_auto_deduction_from_braced-init-list.html&#34;&gt;単一要素初期化子リストを&lt;code&gt;auto&lt;/code&gt;で受け取った場合の型を変更&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;だったのを&lt;code&gt;T&lt;/code&gt;に変更&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3.8&lt;/td&gt;
&lt;td&gt;17.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N4295: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/folding_expressions.html&#34;&gt;畳み込み式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;パラメータパックに対する2項演算の集積処理&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3.6&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N4267: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/utf8_character_literals.html&#34;&gt;UTF-8文字リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルだけでなく、文字リテラルにもUTF-8指定できるようにする&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3.6&lt;/td&gt;
&lt;td&gt;17.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N4230: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/nested_namespace.html&#34;&gt;入れ子名前空間の定義&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;namespace A::B {}&lt;/code&gt;のように、入れ子の名前空間を簡単に定義できるようにする&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3.6&lt;/td&gt;
&lt;td&gt;17.0&lt;/td&gt;
&lt;td&gt;2015 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N4266: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/attributes_for_namespaces_and_enumerators.html&#34;&gt;名前空間と列挙子に属性の付加を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;名前空間の定義と、列挙型の各要素の定義に、属性を付けられるようにする&lt;/td&gt;
&lt;td&gt;名前空間は4.0&lt;br /&gt;列挙子は6&lt;/td&gt;
&lt;td&gt;3.6&lt;/td&gt;
&lt;td&gt;17.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N4268: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/allow_constant_evaluation_for_all_non-type_template_arguments.html&#34;&gt;全ての非型テンプレート引数の定数式評価を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ポインタの定数式評価として、配列からポインタへの変換や、関数から関数ポインタへの変換などを許可&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3.6&lt;/td&gt;
&lt;td&gt;19.1&lt;/td&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0001R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/remove_deprecated_use_of_the_register_keyword.html&#34;&gt;非推奨だった&lt;code&gt;register&lt;/code&gt;キーワードを削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.8&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0002R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/remove_deprecated_increment_of_bool.html&#34;&gt;非推奨だった&lt;code&gt;bool&lt;/code&gt;型オブジェクトに対するインクリメントの仕様を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.8&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0012R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/exception_spec_be_part_of_the_type_system.html&#34;&gt;例外仕様を型システムの一部にする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0061R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/has_include.html&#34;&gt;プリプロセッサでの条件式&lt;code&gt;__has_include&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;対象のインクルードファイルが存在するかをプリプロセス時に判定する&lt;/td&gt;
&lt;td&gt;5.0&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0136R1: &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0136r1.html&#34; target=&#34;_blank&#34;&gt;継承コンストラクタの新仕様&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルト引数を引き継ぐようにした&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0188R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/fallthrough.html&#34;&gt;&lt;code&gt;[[fallthrough]]&lt;/code&gt;属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;case&lt;/code&gt;節で&lt;code&gt;break&lt;/code&gt;や&lt;code&gt;return&lt;/code&gt;を書かなかった場合に、それが意図したフォールスルーであることをコンパイラに伝える属性&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0189R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/nodiscard.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値を無視してはならないことをユーザーに伝える属性&lt;/td&gt;
&lt;td&gt;4.8からは&lt;code&gt;[[gnu::warn_unused_result]]&lt;/code&gt;を使用すること&lt;br /&gt; 7からサポート&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0212R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/maybe_unused.html&#34;&gt;&lt;code&gt;[[maybe_unused]]&lt;/code&gt;属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;使用しない可能性がある変数であることをコンパイラに伝える属性&lt;/td&gt;
&lt;td&gt;4.8からは&lt;code&gt;[[gnu::unused]]&lt;/code&gt;を使用すること&lt;br /&gt; 7からサポート&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0017R1: &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0017r1.html&#34; target=&#34;_blank&#34;&gt;基底クラスのメンバ変数を集成体初期化するための波カッコを省略できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;基底クラスのメンバを集成体初期化するために、&lt;code&gt;derived d {{42}};&lt;/code&gt;の代わりに&lt;code&gt;derived d {42};&lt;/code&gt;と書けるようにする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;19.1&lt;/td&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0170R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/constexpr_lambda.html&#34;&gt;ラムダ式を&lt;code&gt;constexpr&lt;/code&gt;として使用できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式の関数オブジェクトが定数式の文脈で使用された場合に、それがコンパイル時に評価されるようにする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0184R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/generalizing_the_range-based_for_loop.html&#34;&gt;範囲for文のための&lt;code&gt;begin()&lt;/code&gt;と&lt;code&gt;end()&lt;/code&gt;関数が、異なる型を返すことを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;begin()&lt;/code&gt;と&lt;code&gt;end()&lt;/code&gt;が異なるイテレータ型を返せるようにすることで、終端イテレータを定義しやすくする&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0018R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/lambda_capture_of_this_by_value.html&#34;&gt;ラムダ式での&lt;code&gt;*this&lt;/code&gt;のコピーキャプチャ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャリストに&lt;code&gt;*this&lt;/code&gt;を指定することで、&lt;code&gt;*this&lt;/code&gt;をコピーキャプチャする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0138R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/construction_enum_class_values.html&#34;&gt;&lt;code&gt;enum class&lt;/code&gt;変数の初期値として整数を指定する際の規則を調整&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャストを使用することなく整数を初期値として使用し、&lt;code&gt;E e{0};&lt;/code&gt;のような初期化を許可&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0245R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/hexadecimal_floating_literals.html&#34;&gt;浮動小数点数の16進数リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hexfloat&lt;/code&gt;マニピュレータや&lt;code&gt;printf()&lt;/code&gt;の16進数出力に合わせて、浮動小数点数のリテラルも16進数表記できるようにする&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0028R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/using_attribute_namespaces.html&#34;&gt;属性の名前空間指定に繰り返しをなくす&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[using CC: opt(1), debug]]&lt;/code&gt;のように属性の名前空間宣言をまとめて行う&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0035R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/dynamic_memory_allocation_for_over-aligned_data.html&#34;&gt;アライメント指定されたデータの動的メモリ確保&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator new&lt;/code&gt;と&lt;code&gt;operator delete&lt;/code&gt;でアライメント値を取得できるようにする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0091R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/type_deduction_for_class_templates.html&#34;&gt;クラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタの引数からクラスのテンプレート引数を推論できるようにする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;19.1&lt;/td&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0127R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/declaring_non-type_template_arguments_with_auto.html&#34;&gt;非型テンプレート引数の&lt;code&gt;auto&lt;/code&gt;宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;typename T, T x&amp;gt;&lt;/code&gt;という冗長なコードを&lt;code&gt;template &amp;lt;auto x&amp;gt;&lt;/code&gt;のようにして受けられるようにし、&lt;br /&gt; &lt;code&gt;X&amp;lt;3&amp;gt;; X&amp;lt;true&amp;gt;; X&amp;lt;&#39;a&#39;&amp;gt;&lt;/code&gt;のように定数を簡潔に渡せるようにする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;19.1&lt;/td&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0135R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/guaranteed_copy_elision.html&#34;&gt;値のコピー省略を保証&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;一時オブジェクトをコピーする際に、単純な値を持つクラスであればコピーが省略されることを保証する&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;19.1&lt;/td&gt;
&lt;td&gt;2017 Update 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0145R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/expression_evaluation_order.html&#34;&gt;厳密な式の評価順&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;式の項が評価される順序を厳密に規定する。&lt;br /&gt; &lt;code&gt;b = a;&lt;/code&gt;の式が右から順番(a, bの順)に評価される&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;19.1&lt;/td&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0283R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/non_standard_attributes.html&#34;&gt;不明な属性を無視する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;実装が知らない名前空間の属性は無視する&lt;/td&gt;
&lt;td&gt;4.8&lt;/td&gt;
&lt;td&gt;3.0&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0292R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/if_constexpr.html&#34;&gt;constexpr if文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if constexpr(cond)&lt;/code&gt;とすることで、そのif文はコンパイル時に処理される&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0296R2: &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0296r2.html&#34; target=&#34;_blank&#34;&gt;処理の進行保証&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;並行処理に関して「処理の進行」を明確に定義&lt;br /&gt; (TODO:言葉の定義だけなので実装状況ページからは取り除く)&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0386R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/inline_variables.html&#34;&gt;インライン変数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;インライン指定を関数だけでなく変数にも指定できるようにする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0391R0: &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0391r0.html&#34; target=&#34;_blank&#34;&gt;templated entityという用語を導入&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;(TODO:言葉の定義だけなので実装状況ページからは取り除く)&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0217R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/structured_bindings.html&#34;&gt;構造化束縛&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;タプルやユーザー定義型を分解して受け取れるようにする&lt;br /&gt; &lt;code&gt;tuple&amp;lt;int, string&amp;gt; f();&lt;/code&gt; &lt;br /&gt; &lt;code&gt;const auto [a, b] = f(); // aはintの値、bはstringの値&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0305R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/selection_statements_with_initializer.html&#34;&gt;if文とswitch文の条件式と初期化を分離&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if (init; condition)&lt;/code&gt;のように初期化と条件式を分けて記述できるようにする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.9&lt;/td&gt;
&lt;td&gt;18.0&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0137R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/replacement_of_class_objects_containing_reference_members.html&#34;&gt;参照メンバをもつクラスの置き換え&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;参照型メンバや&lt;code&gt;const&lt;/code&gt;メンバ変数を含むクラスについてこれまで結果は未定義とされていた配置&lt;code&gt;new&lt;/code&gt;によるオブジェクトの置き換えを条件付きで可能とする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0003R5: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/remove_deprecated_exception_specifications.html&#34;&gt;非推奨だった例外仕様を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;noexcept&lt;/code&gt;が入ったことによって非推奨になった&lt;code&gt;throw&lt;/code&gt;キーワードによる例外仕様を削除&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0195R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp17/pack_expansions_in_using.html&#34;&gt;using宣言でのパック展開&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;パラメータパックの型を基底クラスとして指定した場合に、&lt;code&gt;using&lt;/code&gt;宣言に基底クラスのパラメータパックを指定できるようにする&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0512R0: &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0512r0.pdf&#34; target=&#34;_blank&#34;&gt;クラステンプレート引数の推論仕様を調整&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5.0&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2017 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0490R0: &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0490r0.html&#34; target=&#34;_blank&#34;&gt;Committee Draftに対するNational Body Commentへの対応&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0522R0: &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0522r0.html&#34; target=&#34;_blank&#34;&gt;テンプレートテンプレート引数のマッチングにおいて、互換性のあるテンプレートを除外&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4 (partial)&lt;/td&gt;
&lt;td&gt;19.1&lt;/td&gt;
&lt;td&gt;2017 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各処理系のC++17実装状況ページ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: &lt;a href=&#34;https://gcc.gnu.org/projects/cxx-status.html#cxx17&#34; target=&#34;_blank&#34;&gt;C++17 Support in GCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clang: &lt;a href=&#34;http://clang.llvm.org/cxx_status.html&#34; target=&#34;_blank&#34;&gt;C++ Support in Clang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libc++ : &lt;a href=&#34;https://libcxx.llvm.org/Status/Cxx17.html&#34; target=&#34;_blank&#34;&gt;libc++ C++17 Status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Visual C++ (MSVC):&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/cpp/visual-cpp-language-conformance&#34; target=&#34;_blank&#34;&gt;Visual C++ 言語への準拠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/&#34; target=&#34;_blank&#34;&gt;Announcing: MSVC Conforms to the C++ Standard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ICC: &lt;a href=&#34;https://software.intel.com/en-us/articles/c17-features-supported-by-intel-c-compiler&#34; target=&#34;_blank&#34;&gt;C++17 Features Supported by Intel C++ Compiler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp20&#34; id=&#34;cpp20&#34;&gt;C++20言語機能の実装状況&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#icc&#34;&gt;ICC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;MSVC&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;P0683R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_member_initializers_for_bit_fields.html&#34;&gt;ビットフィールドのメンバ変数初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ビットフィールドメンバ変数のデフォルト値を設定する構文を追加する&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0409R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_lambda_capture_equal_this.html&#34;&gt;ラムダ式のキャプチャとして&lt;code&gt;[=, this]&lt;/code&gt;を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトコピーキャプチャと&lt;code&gt;this&lt;/code&gt;ポインタのコピーキャプチャを両方指定できるようにする&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0806R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタをキャプチャされなくする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0428R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/familiar_template_syntax_for_generic_lambdas.html&#34;&gt;ジェネリックラムダのテンプレート構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダでテンプレートパラメータを定義できるようにする&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0704R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/fixing_const_qualified_pointers_to_members.html&#34;&gt;&lt;code&gt;const&lt;/code&gt;修飾されたメンバポインタの制限を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.*&lt;/code&gt;演算子での左辺値の&lt;code&gt;const&lt;/code&gt;メンバ関数呼び出しを許可する&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0306R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/va_opt.html&#34;&gt;可変引数が空でない場合のトークン置換&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサの置換で可変引数が空の場合に余計なカンマが付いてしまう問題に対処&lt;/td&gt;
&lt;td&gt;8 (partial, &lt;code&gt;#__VA_OPT__&lt;/code&gt;による文字列化が未サポート)&lt;/td&gt;
&lt;td&gt;6.0&lt;br /&gt; 9.0 (&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1042r1.html&#34; target=&#34;_blank&#34;&gt;p1042&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0329R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/designated_initialization.html&#34;&gt;指示付き初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;6.0 (partial)&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0734R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/concepts.html&#34;&gt;コンセプト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータに対する制約を行う&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10.0 (partial)&lt;/td&gt;
&lt;td&gt;2021.6&lt;/td&gt;
&lt;td&gt;2019 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0614R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/range-based_for_statements_with_initializer.html&#34;&gt;初期化式をともなう範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;範囲for文スコープで使用する変数の初期化のための構文を追加&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0588R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/simplifying_implicit_lambda_capture.md.nolink&#34;&gt;暗黙のラムダキャプチャを簡略化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0846R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/adl_and_function_templates_that_are_not_visible.html&#34;&gt;関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;名前空間内の関数テンプレートをテンプレート引数指定かつ非修飾・ADLで正しく呼び出せるよう修正&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0641R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/resolving_const_mismatch_with_defaulted_copy_constructor.md.nolink&#34;&gt;デフォルトのコピーコンストラクタと非&lt;code&gt;const&lt;/code&gt;なコンストラクタが衝突する問題を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0859R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/less_eager_instantiation_of_constexpr_functions.html&#34;&gt;評価されない文脈での定数式評価によって特殊メンバ関数がインスタンス化されることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof&lt;/code&gt;や&lt;code&gt;decltype&lt;/code&gt;などの評価されない文脈において定数式評価を行った場合に、ムーブコンストラクタのような特殊メンバ関数が定義されることを規定&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Partial in 2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0515R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html&#34;&gt;一貫比較&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;三方比較演算子によって比較演算子の自動生成を行うようにする&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;8.0 (partial)&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0692R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/access_checking_on_specializations.html&#34;&gt;特殊化のアクセスチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;partial&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0624R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_constructible_and_assignable_stateless_lambdas.html&#34;&gt;状態を持たないラムダ式を、デフォルト構築可能、代入可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャしていないラムダ式をデフォルト構築・代入可能にする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0767R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_pod.html&#34;&gt;PODを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PODという用語を非推奨化する&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0315R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html&#34;&gt;評価されない文脈でのラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;評価されない文脈でもラムダ式を書くことができるようにする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;Partial&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0840R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/language_support_for_empty_objects.html&#34;&gt;空オブジェクトを言語サポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[no_unique_address]]&lt;/code&gt;属性を導入し、空の型のオブジェクトをほかのオブジェクトと共有する最適化を許可する&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 9 &lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#note-t1-1&#34; id=&#34;note_ref-t1-1&#34;&gt;†1&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0962R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.html&#34;&gt;範囲for文がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;メンバ関数のどちらかが見つからなかった場合に非メンバ関数の&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0969R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_structured_bindings_to_accessible_members.html&#34;&gt;friend指定された関数内から構造化束縛を使用して非公開メンバ変数にアクセスすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛の仕様として公開メンバ変数のみを取り出せるようになっていたが、friend指定された関数からは非公開メンバ変数にもアクセスできるようにする&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0961R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_structured_bindings_customization_point_finding_rules.html&#34;&gt;構造化束縛がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非テンプレートの&lt;code&gt;get()&lt;/code&gt;メンバ関数が見つかった場合は、非メンバ関数の&lt;code&gt;get()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0634R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/down_with_typename.html&#34;&gt;型の文脈で&lt;code&gt;typename&lt;/code&gt;の省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型しか現れない文脈では、依存名を解決するための&lt;code&gt;typename&lt;/code&gt;キーワードを省略できるようにする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2021.4 (2021.6 は未対応)&lt;/td&gt;
&lt;td&gt;2019 Update 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0780R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_pack_expansion_in_lambda_init_capture.html&#34;&gt;ラムダ式の初期化キャプチャでのパック展開を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[...args = std::move(args)]&lt;/code&gt;のようなキャプチャを許可&lt;/td&gt;
&lt;td&gt;9&lt;br /&gt;10&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0479R5: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/likely_and_unlikely_attributes.html&#34;&gt;確率が高い分岐と低い分岐を伝える属性 &lt;code&gt;[[likely]]&lt;/code&gt;, &lt;code&gt;[[unlikely]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;条件分岐の最適化ヒントを与える属性&lt;/td&gt;
&lt;td&gt;9 (partial, &lt;code&gt;switch&lt;/code&gt; 文のみ可能)&lt;br /&gt; 10&lt;/td&gt;
&lt;td&gt;12.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0929R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/checking_for_abstract_class_types.md.nolink&#34;&gt;抽象型のチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の宣言段階では、パラメータおよび戻り値型が抽象型かどうかをチェックしないようにする&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0732R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_types_in_non-type_template_parameters.html&#34;&gt;非型テンプレートパラメータとしてクラス型を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式として使用できる型を広く非型テンプレートパラメータとして使用できるようにする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;partial&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0722R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md.nolink&#34;&gt;可変長データを扱うクラスの効率的な&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラスの&lt;code&gt;delete&lt;/code&gt;演算子が呼び出される前にデストラクタが呼ばれないようにするオプションを追加&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1064R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_virtual_function_calls_in_constant_expressions.html&#34;&gt;定数式からの仮想関数の呼び出しを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;仮想関数に&lt;code&gt;constexpr&lt;/code&gt;を付けられない制限を解除&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1327R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allowing_dynamic_cast_polymorphic_typeid_in_constant_expressions.html&#34;&gt;定数式での&lt;code&gt;dynamic_cast&lt;/code&gt;、多態的な&lt;code&gt;typeid&lt;/code&gt;を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式での動的多態を許可&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1002R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/try-catch_blocks_in_constexpr_functions.html&#34;&gt;constexpr関数内でのtry-catchブロックを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内でtry-catchブロックを書けるようにする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;2021.4 (2021.6 は未対応)&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1073R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/immediate_functions.html&#34;&gt;即時関数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;consteval&lt;/code&gt;キーワードを追加し、常に定数式評価されるよう指定できるようにする&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1330R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/changing_the_active_member_of_a_union_inside_constexpr.html&#34;&gt;定数式内での共用体のアクティブメンバの変更を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体メンバの書き換えを定数式内で行えるようにする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2017&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1008R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/prohibit_aggregates_with_user-declared_constructors.html&#34;&gt;ユーザー宣言したコンストラクタを持つクラスの集成体初期化を禁止&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタが&lt;code&gt;delete&lt;/code&gt;／&lt;code&gt;default&lt;/code&gt;宣言されているクラスを、集成体初期化によってコンストラクタ呼び出しを回避して構築できてしまっていた技法を禁止&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0892R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/explicit_bool.html&#34;&gt;関数を条件付きで&lt;code&gt;explicit&lt;/code&gt;にする構文を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;explicit(true)&lt;/code&gt;のように&lt;code&gt;explicit&lt;/code&gt;に真理値パラメータを指定できるようにする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1236R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html&#34;&gt;符号付き整数型が2の補数表現であることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;符号付き整数型のビット表現を2の補数に規定する&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0482R6: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/char8_t.html&#34;&gt;UTF-8エンコーディングされた文字の型として&lt;code&gt;char8_t&lt;/code&gt;を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-8エンコードされた文字かどうかでオーバーロード・特殊化をできるようにする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;7 (&lt;code&gt;-fchar8_t&lt;/code&gt;オプションが必要)&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1094R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nested_inline_mamespaces.html&#34;&gt;入れ子名前空間定義でのインライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;namespace ns1::inline ns2::ns3 {}&lt;/code&gt;のように、入れ子名前空間を定義する式にインライン名前空間の指定を含められるようにする&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1091R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/extending_structured_bindings_to_be_more_like_variable_declarations.html&#34;&gt;構造化束縛を拡張して通常の変数宣言のように使用できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;記憶域指定子として&lt;code&gt;static&lt;/code&gt;と&lt;code&gt;thread_local&lt;/code&gt;の指定を許可&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;8.0 (partial)&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1381R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reference_capture_of_structured_bindings.html&#34;&gt;構造化束縛した変数の参照キャプチャを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛をした変数は特殊な扱いのためラムダ式で参照キャプチャできない規定となっていたがこれを許可する&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8.0 (partial)&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2017 Update 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0960R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html&#34;&gt;丸カッコの値リストからの集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T x{1, 2, 3};&lt;/code&gt;と同様に&lt;code&gt;T x(1, 2, 3);&lt;/code&gt;でも集成体初期化できるようにする&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1009R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/array_size_deduction_in_new-expressions.html&#34;&gt;&lt;code&gt;new&lt;/code&gt;式での配列要素数の推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double* p = new double[]{1,2,3};&lt;/code&gt;を許可&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1041R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/make_char16t_char32t_string_literals_be_utf16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;の文字・文字列リテラルを、文字コードUTF-16/32に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__STDC_UTF_16__&lt;/code&gt;、&lt;code&gt;__STDC_UTF_32__&lt;/code&gt;の定義に関係なく、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のリテラルをUTF-16/32文字コードに規定する&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1103R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/modules.html&#34;&gt;モジュール&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ヘッダファイル・ソースファイル、インクルードに変わる仕組みとしてモジュールを導入する&lt;/td&gt;
&lt;td&gt;11 (&lt;code&gt;-fmodules-ts&lt;/code&gt;が必要)&lt;/td&gt;
&lt;td&gt;15&lt;br /&gt;8.0 partial (&lt;code&gt;-fmodules&lt;/code&gt;, &lt;code&gt;-fmodules-ts&lt;/code&gt;が必要)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0912R5: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/coroutines.html&#34;&gt;コルーチン&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数実行を中断・再開する仕組みとしてコルーチンを導入する&lt;/td&gt;
&lt;td&gt;10 (&lt;code&gt;-fcoroutines&lt;/code&gt;が必要)&lt;/td&gt;
&lt;td&gt;8.0 (partial)&lt;/td&gt;
&lt;td&gt;2021.4&lt;/td&gt;
&lt;td&gt;2019 Update 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1161R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_uses_of_the_comma_operator_in_subscripting_expressions.html&#34;&gt;添字演算子内でのカンマ演算子の使用を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ar[i, j]&lt;/code&gt;を非推奨化。&lt;code&gt;ar[(i, j)]&lt;/code&gt;はOK&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.6&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1331R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.html&#34;&gt;constexpr関数内でのトリビアルなデフォルト初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内でのデフォルト初期化を許可し、未初期化値を読むことのみ禁止する&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0848R3: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/conditionally_trivial_special_member_functions.md.nolink&#34;&gt;条件付きで特殊メンバ関数をトリビアルに定義するように&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;制約によってトリビアルな特殊メンバ関数と非トリビアルな特殊メンバ関数をオーバーロードできるようにする&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;16 Partial (consepts 未実装部あり)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1301R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nodiscard_should_have_a_reason.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性に理由となる文字列を付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値を無視してはならない理由を関数宣言に持たせ、警告メッセージに役立てる&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;9.0&lt;/td&gt;
&lt;td&gt;2021.6&lt;/td&gt;
&lt;td&gt;2019 Update 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1099R5: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/using_enum.html&#34;&gt;スコープ付き列挙型のusing宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;using enum EnumType;&lt;/code&gt;もしくは&lt;code&gt;using EnumType::enumerator&lt;/code&gt;とすることで、列挙値のスコープ指定を省略できるようにする&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1816R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_aggregates.html&#34;&gt;集成体クラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートのテンプレート引数推論はコンストラクタ引数から推論されるが、集成体初期化からも推論できるようにする&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1668R1: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.html&#34;&gt;constexpr関数内で未評価のインラインアセンブリを許可することによる組み込み関数のconstexpr有効化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に評価されない場合にconstexpr関数にasm定義を含めることを許可&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0388R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.html&#34;&gt;要素数不明の配列への変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;要素数が判明している配列から、要素数が不明の配列への変換を許可&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;2021.6&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1143R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/constinit.html&#34;&gt;コンパイル時初期化を強制する&lt;code&gt;constinit&lt;/code&gt;キーワードを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化のみコンパイル時におわらせたい場合に使用する&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1152R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html&#34;&gt;ほとんどの&lt;code&gt;volatile&lt;/code&gt;を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;volatile&lt;/code&gt;の有用な機能のみを残し、効果が疑わしい、または壊れている機能を非推奨化する&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;td&gt;2021.6&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1814R0: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_alias_templates.html&#34;&gt;エイリアステンプレート経由でのクラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エイリアステンプレートからクラステンプレートのテンプレート引数を推論できるようにする&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P0784R7: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html&#34;&gt;可変サイズをもつコンテナの&lt;code&gt;constexpr&lt;/code&gt;化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;記憶域をもつメモリアロケータの存在を考慮することで、可変サイズをもつコンテナをコンパイル時に使用できるようにする&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10.0&lt;/td&gt;
&lt;td&gt;2021.6&lt;/td&gt;
&lt;td&gt;2019 Update 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1957R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.html&#34;&gt;ポインタから&lt;code&gt;bool&lt;/code&gt;への変換を縮小変換とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ポインタから&lt;code&gt;bool&lt;/code&gt;値への変換を縮小変換と規定することで、意図しない変換を防止する&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;11.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2019 Update 7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#note_ref-t1-1&#34; id=&#34;note-t1-1&#34;&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/a&gt; 不明な属性として無視されなくなっただけで期待する効果は得られない。完全に実装されるまでは、代わりに&lt;code&gt;&lt;a href=&#34;https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/#msvc-extensions-and-abi&#34; target=&#34;_blank&#34;&gt;[[msvc::no_unique_address]]&lt;/a&gt;&lt;/code&gt;を使用できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各処理系のC++20実装状況ページ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: &lt;a href=&#34;https://gcc.gnu.org/projects/cxx-status.html#cxx20&#34; target=&#34;_blank&#34;&gt;C++20 Support in GCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clang: &lt;a href=&#34;http://clang.llvm.org/cxx_status.html&#34; target=&#34;_blank&#34;&gt;C++ Support in Clang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libstdc++: &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.2020&#34; target=&#34;_blank&#34;&gt;C++ 2020 Implementation Status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libc++: &lt;a href=&#34;https://libcxx.llvm.org/Status/Cxx20.html&#34; target=&#34;_blank&#34;&gt;libc++ C++20 Status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Visual C++ (MSVC):&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/cpp/visual-cpp-language-conformance&#34; target=&#34;_blank&#34;&gt;Visual C++ 言語への準拠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/STL/wiki/Changelog&#34; target=&#34;_blank&#34;&gt;次リリース情報(VS2019,2022) - Change log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ICC: &lt;a href=&#34;https://www.intel.com/content/www/us/en/developer/articles/technical/c20-features-supported-by-intel-cpp-compiler.html&#34; target=&#34;_blank&#34;&gt;C++20 Features Supported by Intel® C++ Compiler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-status.html#cpp23&#34; id=&#34;cpp23&#34;&gt;C++23言語機能の実装状況&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#icc&#34;&gt;ICC&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;MSVC&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;P0330R8: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/literal_suffix_for_signed_size_t.html&#34;&gt;(符号付き)&lt;code&gt;size_t&lt;/code&gt;リテラルのためのサフィックス&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;42z&lt;/code&gt;/&lt;code&gt;42Z&lt;/code&gt;とすることで&lt;code&gt;size_t&lt;/code&gt;に対応する符号付き整数型のリテラルとする&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2096R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/generalized_wording_for_partial_specializations.md.nolink&#34;&gt;部分特殊化の汎用化仕様&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数テンプレートの部分特殊化を許可するために部分特殊化の仕様を汎用化&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2029R4: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/numeric_and_universal_character_escapes_in_character_and_string_literals.md.nolink&#34;&gt;文字・文字列リテラル中の数値・ユニバーサルキャラクタのエスケープに関する問題解決&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1787R6: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/declarations_and_where_to_find_them.md.nolink&#34;&gt;スコープと名前ルックアップの仕様整理&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;複雑で不完全になっているスコープと名前ルックアップの仕様を整理し、一部の問題を解決する&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1102R2: &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/down_with_lambda_parens.md.nolink&#34;&gt;ラムダ式で&lt;code&gt;()&lt;/code&gt;を省略できる条件を緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャや修飾をともなってもパラメータリストが空であれば&lt;code&gt;()&lt;/code&gt;を省略できる&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1938R3 : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/if_consteval.md.nolink&#34;&gt;if consteval&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時の文脈かどうかで分岐させる&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1401R5 : &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/narrowing_contextual_conversions_to_bool.md.nolink&#34;&gt;定数式の文脈での&lt;code&gt;bool&lt;/code&gt;への縮小変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if constexpr(flags &amp;amp; Flags::Exec)&lt;/code&gt;や&lt;code&gt;static_assert(N);&lt;/code&gt;を許可&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2223R2 : &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/trimming_whitespaces_before_line_splicing.md.nolink&#34;&gt;行末スペースを無視するよう規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;行末が&lt;code&gt;\&lt;/code&gt;でおわっていた場合にMSVCは行の継続をしない実装になっていたため動作を共通化するため仕様を規定&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P1847R4 : &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/make_declaration_order_layout_mandated.md.nolink&#34;&gt;アクセス制御の異なるメンバ変数のレイアウトを宣言順に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;アクセス制御の異なるメンバ変数のレイアウトが実装によって異なっていたため仕様を規定&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2201R1 : &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/mixed_string_literal_concatenation.md.nolink&#34;&gt;異なる文字エンコーディングをもつ文字列リテラルの連結を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto a = u8&#34;&#34; L&#34;&#34;;&lt;/code&gt;のような異なる文字エンコーディング同士での文字列リテラルを連結を禁止する&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各処理系のC++23実装状況ページ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: &lt;a href=&#34;https://gcc.gnu.org/projects/cxx-status.html#cxx23&#34; target=&#34;_blank&#34;&gt;C++23 Support in GCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clang: &lt;a href=&#34;https://clang.llvm.org/cxx_status.html#cxx23&#34; target=&#34;_blank&#34;&gt;C++2b implementation status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Visual C++ (MSVC):&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.cppreference.com/w/cpp/23&#34; target=&#34;_blank&#34;&gt;C++23 - cppreference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/STL/wiki/Changelog&#34; target=&#34;_blank&#34;&gt;次リリース情報(VS2019,2022) - Change log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++20 -- C++20 特殊化のアクセスチェック、背景まで #722</title>
      <link href="https://cpprefjp.github.io/lang/cpp20.html"/>
      <id>886f17be7a416fdc2c48b8faa6bb15207b07459b:lang/cpp20.md</id>
      <updated>2022-12-27T18:24:47+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++20&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20とは、2020年中に改訂され、ISO/IEC 14882:2020で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++2aと呼ばれることがあった。「202a年にリリースされる」という伏せ字として「a」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;クラス&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html&#34;&gt;一貫比較&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;三方比較演算子によって比較演算子の自動生成を行うようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_member_initializers_for_bit_fields.html&#34;&gt;ビットフィールドのメンバ変数初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ビットフィールドメンバ変数のデフォルト値を設定する構文を追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/explicit_bool.html&#34;&gt;関数を条件付きで&lt;code&gt;explicit&lt;/code&gt;にする構文を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;explicit(true)&lt;/code&gt;のように&lt;code&gt;explicit&lt;/code&gt;に真理値パラメータを指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/fixing_const_qualified_pointers_to_members.html&#34;&gt;&lt;code&gt;const&lt;/code&gt;修飾されたメンバポインタの制限を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.*&lt;/code&gt;演算子での左辺値の&lt;code&gt;const&lt;/code&gt;メンバ関数呼び出しを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/resolving_const_mismatch_with_defaulted_copy_constructor.md.nolink&#34;&gt;デフォルトのコピーコンストラクタと非&lt;code&gt;const&lt;/code&gt;なコンストラクタが衝突する問題を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/access_checking_on_specializations.html&#34;&gt;特殊化のアクセスチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/language_support_for_empty_objects.html&#34;&gt;空オブジェクトに対する最適化を支援する属性&lt;code&gt;[[no_unique_address]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[no_unique_address]]&lt;/code&gt;属性を導入し、空の型のオブジェクトをほかのオブジェクトと共有する最適化を許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_structured_bindings_to_accessible_members.html&#34;&gt;friend指定された関数内から構造化束縛を使用して非公開メンバ変数にアクセスすることを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛の仕様として公開メンバ変数のみを取り出せるようになっていたが、friend指定された関数からは非公開メンバ変数にもアクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_structured_bindings_customization_point_finding_rules.html&#34;&gt;構造化束縛がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非テンプレートの&lt;code&gt;get()&lt;/code&gt;メンバ関数が見つかった場合は、非メンバ関数の&lt;code&gt;get()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/checking_for_abstract_class_types.md.nolink&#34;&gt;抽象型のチェック&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の宣言段階では、パラメータおよび戻り値型が抽象型かどうかをチェックしないようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/efficient_sized_delete_for_variable_sized_classes.md.nolink&#34;&gt;可変長データを扱うクラスの効率的な&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラスの&lt;code&gt;delete&lt;/code&gt;演算子が呼び出される前にデストラクタが呼ばれないようにするオプションを追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/conditionally_trivial_special_member_functions.md.nolink&#34;&gt;条件付きで特殊メンバ関数をトリビアルに定義するように&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;制約によってトリビアルな特殊メンバ関数と非トリビアルな特殊メンバ関数をオーバーロードできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;列挙型&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/using_enum.html&#34;&gt;スコープ付き列挙型のusing宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;using enum EnumType;&lt;/code&gt;もしくは&lt;code&gt;using EnumType::enumerator&lt;/code&gt;とすることで、列挙値のスコープ指定を省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/designated_initialization.html&#34;&gt;指示付き初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波カッコによる集成体初期化でメンバ名を指定して初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/extending_structured_bindings_to_be_more_like_variable_declarations.html&#34;&gt;構造化束縛を拡張して通常の変数宣言のように使用できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;記憶域指定子として&lt;code&gt;static&lt;/code&gt;と&lt;code&gt;thread_local&lt;/code&gt;の指定を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html&#34;&gt;丸カッコの値リストからの集成体初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T x{1, 2, 3};&lt;/code&gt;と同様に&lt;code&gt;T x(1, 2, 3);&lt;/code&gt;でも集成体初期化できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/array_size_deduction_in_new-expressions.html&#34;&gt;&lt;code&gt;new&lt;/code&gt;式での配列要素数の推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double* p = new double[]{1,2,3};&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.html&#34;&gt;要素数不明の配列への変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;要素数が判明している配列から、要素数が不明の配列への変換を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html&#34;&gt;ほとんどの&lt;code&gt;volatile&lt;/code&gt;を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;volatile&lt;/code&gt;の有用な機能のみを残し、効果が疑わしい、または壊れている機能を非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/converting_from_pointer_to_bool_should_be_considered_narrowing.html&#34;&gt;ポインタから&lt;code&gt;bool&lt;/code&gt;への変換を縮小変換とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ポインタから&lt;code&gt;bool&lt;/code&gt;値への変換を縮小変換と規定することで、意図しない変換を防止する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;整数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html&#34;&gt;符号付き整数型が2の補数表現であることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;符号付き整数型のビット表現を2の補数に規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/char8_t.html&#34;&gt;UTF-8エンコーディングされた文字の型として&lt;code&gt;char8_t&lt;/code&gt;を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-8エンコードされた文字かどうかでオーバーロード・特殊化をできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/make_char16t_char32t_string_literals_be_utf16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;の文字・文字列リテラルを、文字コードUTF-16/32に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__STDC_UTF_16__&lt;/code&gt;、&lt;code&gt;__STDC_UTF_32__&lt;/code&gt;の定義に関係なく、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のリテラルをUTF-16/32文字コードに規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nodiscard_should_have_a_reason.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性に理由となる文字列を付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値を無視してはならない理由を関数宣言に持たせ、警告メッセージに役立てる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nodiscard_for_constructors.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;をコンストラクタのオーバーロードごとに付加できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リソース確保するコンストラクタにのみ&lt;code&gt;[[nodisacrd]]&lt;/code&gt;を付加できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;制御構文&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/range-based_for_statements_with_initializer.html&#34;&gt;初期化式をともなう範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;範囲for文スコープで使用する変数の初期化のための構文を追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.html&#34;&gt;範囲for文がカスタマイゼーションポイントを見つけるルールを緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;メンバ関数のどちらかが見つからなかった場合に非メンバ関数の&lt;code&gt;begin()&lt;/code&gt;/&lt;code&gt;end()&lt;/code&gt;を探しにいく&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/likely_and_unlikely_attributes.html&#34;&gt;確率が高い分岐と低い分岐を伝える属性 &lt;code&gt;[[likely]]&lt;/code&gt;, &lt;code&gt;[[unlikely]]&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;条件分岐の最適化ヒントを与える属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/concepts.html&#34;&gt;コンセプト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータに対する制約を行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/function_templates_with_auto_parameters.html&#34;&gt;autoパラメータによる関数テンプレートの簡易定義&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダと同様、関数パラメータをの型を&lt;code&gt;auto&lt;/code&gt;にすることで簡易的に関数テンプレートを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/down_with_typename.html&#34;&gt;型の文脈で&lt;code&gt;typename&lt;/code&gt;の省略を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型しか現れない文脈では、依存名を解決するための&lt;code&gt;typename&lt;/code&gt;キーワードを省略できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_types_in_non-type_template_parameters.html&#34;&gt;非型テンプレートパラメータとしてクラス型を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式として使用できる型を広く非型テンプレートパラメータとして使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/adl_and_function_templates_that_are_not_visible.html&#34;&gt;関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;名前空間内の関数テンプレートをテンプレート引数指定かつ非修飾・ADLで正しく呼び出せるよう修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_aggregates.html&#34;&gt;集成体クラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートのテンプレート引数推論はコンストラクタ引数から推論されるが、集成体初期化からも推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/class_template_argument_deduction_for_alias_templates.html&#34;&gt;エイリアステンプレート経由でのクラステンプレートのテンプレート引数推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エイリアステンプレートからクラステンプレートのテンプレート引数を推論できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/less_eager_instantiation_of_constexpr_functions.html&#34;&gt;評価されない文脈での定数式評価によって特殊メンバ関数がインスタンス化されることを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof&lt;/code&gt;や&lt;code&gt;decltype&lt;/code&gt;などの評価されない文脈において定数式評価を行った場合に、ムーブコンストラクタのような特殊メンバ関数が定義されることを規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_virtual_function_calls_in_constant_expressions.html&#34;&gt;定数式からの仮想関数の呼び出しを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;仮想関数に&lt;code&gt;constexpr&lt;/code&gt;を付けられない制限を解除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allowing_dynamic_cast_polymorphic_typeid_in_constant_expressions.html&#34;&gt;定数式での&lt;code&gt;dynamic_cast&lt;/code&gt;、多態的な&lt;code&gt;typeid&lt;/code&gt;を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式での動的多態を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/try-catch_blocks_in_constexpr_functions.html&#34;&gt;constexpr関数内でのtry-catchブロックを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内で&lt;code&gt;try-catch&lt;/code&gt;ブロックを書けるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/immediate_functions.html&#34;&gt;即時関数&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;consteval&lt;/code&gt;キーワードを追加し、常に定数式評価されるよう指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/changing_the_active_member_of_a_union_inside_constexpr.html&#34;&gt;定数式内での共用体のアクティブメンバの変更を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体メンバの書き換えを定数式内で行えるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.html&#34;&gt;constexpr関数内でのトリビアルなデフォルト初期化を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;constexpr関数内でのデフォルト初期化を許可し、未初期化値を読むことのみ禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.html&#34;&gt;constexpr関数内で未評価のインラインアセンブリを許可することによる組み込み関数のconstexpr有効化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に評価されない場合にconstexpr関数にasm定義を含めることを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/constinit.html&#34;&gt;コンパイル時初期化を強制する&lt;code&gt;constinit&lt;/code&gt;キーワードを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化のみコンパイル時におわらせたい場合に使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html&#34;&gt;可変サイズをもつコンテナの&lt;code&gt;constexpr&lt;/code&gt;化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;記憶域をもつメモリアロケータの存在を考慮することで、可変サイズをもつコンテナをコンパイル時に使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ラムダ式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/familiar_template_syntax_for_generic_lambdas.html&#34;&gt;ジェネリックラムダのテンプレート構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックラムダでテンプレートパラメータを定義できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_lambda_capture_equal_this.html&#34;&gt;ラムダ式のキャプチャとして&lt;code&gt;[=, this]&lt;/code&gt;を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;デフォルトコピーキャプチャと&lt;code&gt;this&lt;/code&gt;ポインタのコピーキャプチャを両方指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタをキャプチャされなくする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/simplifying_implicit_lambda_capture.md.nolink&#34;&gt;暗黙のラムダキャプチャを簡略化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/default_constructible_and_assignable_stateless_lambdas.html&#34;&gt;状態を持たないラムダ式を、デフォルト構築可能、代入可能とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キャプチャしていないラムダ式をデフォルト構築・代入可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html&#34;&gt;評価されない文脈でのラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;評価されない文脈でもラムダ式を書くことができるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/allow_pack_expansion_in_lambda_init_capture.html&#34;&gt;ラムダ式の初期化キャプチャでのパック展開を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[...args = std::move(args)]&lt;/code&gt;のようなキャプチャを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reference_capture_of_structured_bindings.html&#34;&gt;構造化束縛した変数の参照キャプチャを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構造化束縛をした変数は特殊な扱いのためラムダ式で参照キャプチャできない規定となっていたがこれを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;名前空間&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/nested_inline_mamespaces.html&#34;&gt;入れ子名前空間定義でのインライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;namespace ns1::inline ns2::ns3 {}&lt;/code&gt;のように、入れ子名前空間を定義する式にインライン名前空間の指定を含められるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;モジュール化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/modules.html&#34;&gt;モジュール&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ヘッダファイル・ソースファイル、インクルードに変わる仕組みとしてモジュールを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/coroutines.html&#34;&gt;コルーチン&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数実行を中断・再開する仕組みとしてコルーチンを導入する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;プリプロセッサ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/va_opt.html&#34;&gt;可変引数が空でない場合のトークン置換&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサの置換で可変引数が空の場合に余計なカンマが付いてしまう問題に対処&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_pod.html&#34;&gt;PODを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PODという用語を非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_implicit_capture_of_this_via_defcopy.html&#34;&gt;&lt;code&gt;[=]&lt;/code&gt;による&lt;code&gt;this&lt;/code&gt;の暗黙のキャプチャを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コピーのデフォルトキャプチャでは、&lt;code&gt;this&lt;/code&gt;ポインタのキャプチャを非推奨化する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/deprecate_uses_of_the_comma_operator_in_subscripting_expressions.html&#34;&gt;添字演算子内でのカンマ演算子の使用を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ar[i, j]&lt;/code&gt;を非推奨化。&lt;code&gt;ar[(i, j)]&lt;/code&gt;はOK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/remove_deprecated_nothrow_exception_specification.html&#34;&gt;&lt;code&gt;throw()&lt;/code&gt;による例外送出しない指定を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;代わりに&lt;code&gt;noexcept&lt;/code&gt;を使用すること&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/prohibit_aggregates_with_user-declared_constructors.html&#34;&gt;ユーザー宣言したコンストラクタを持つクラスの集成体初期化を禁止&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタが&lt;code&gt;delete&lt;/code&gt;／&lt;code&gt;default&lt;/code&gt;宣言されているクラスを、集成体初期化によってコンストラクタ呼び出しを回避して構築できてしまっていた技法を禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/update_the_reference_to_the_unicode_standard.html&#34;&gt;Unicode標準への参照を更新&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準C++からISO/IEC 10646への参照を更新する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp20/reserving_attribute_namespaces_for_future_use.html&#34;&gt;属性の名前空間を予約&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将来の使用のために属性の名前空間を予約&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;バージョン情報ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/version.html&#34;&gt;&amp;lt;version&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。ここでは、実装依存の情報 (バージョンやリリース日付など) が標準ライブラリの実装によって定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;ライブラリに、カレンダーとタイムゾーンの機能を拡張&lt;/li&gt;
&lt;li&gt;任意のシーケンスの部分シーケンスを参照するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/span.html&#34;&gt;&amp;lt;span&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;文字列フォーマットライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format.html&#34;&gt;&amp;lt;format&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;出力ストリームを同期するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/syncstream.html&#34;&gt;&amp;lt;syncstream&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;三方比較ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numbers.html&#34;&gt;&amp;lt;numbers&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。数学定数が定義される&lt;/li&gt;
&lt;li&gt;ビット操作ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit.html&#34;&gt;&amp;lt;bit&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;Strict Aliasing規則に抵触しないビットレベルの再解釈キャストである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_cast.html&#34;&gt;std::bit_cast()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;1ビットだけ立っている値をもっているかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/has_single_bit.html&#34;&gt;std::has_single_bit()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;整数値を2の累乗値に切り上げる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_ceil.html&#34;&gt;std::bit_ceil()&lt;/a&gt;&lt;/code&gt;関数、整数値を2の累乗値に切り下げる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_floor.html&#34;&gt;std::bit_floor()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;値を表現するために必要なビット幅を求める&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/bit_width.html&#34;&gt;std::bit_width()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;循環ビットシフトを行う&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/rotl.html&#34;&gt;std::rotl()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/rotr.html&#34;&gt;std::rotr()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;連続した0もしくは1のビットを数える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countl_zero.html&#34;&gt;std::countl_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countl_one.html&#34;&gt;std::countl_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countr_zero.html&#34;&gt;std::countr_zero()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/countr_one.html&#34;&gt;std::countr_one()&lt;/a&gt;&lt;/code&gt;、および立っているビットを数える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/popcount.html&#34;&gt;std::popcount()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;エンディアンを表す列挙型として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/endian.html&#34;&gt;std::endian&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;型制約のための要件ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts.html&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;言語機能であるコルーチンを制御するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/coroutine.html&#34;&gt;&amp;lt;coroutine&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッドの実行を停止させるメカニズムとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stop_token.html&#34;&gt;&amp;lt;stop_token&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加し、停止に対応したスレッドクラスとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread.html&#34;&gt;&amp;lt;thread&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/jthread.html&#34;&gt;std::jthread&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;軽量な同期プリミティブであるセマフォのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/semaphore.html&#34;&gt;&amp;lt;semaphore&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッド調整メカニズムとして、ラッチライブラリの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/latch.html&#34;&gt;&amp;lt;latch&amp;gt;&lt;/a&gt;&lt;/code&gt;、バリアライブラリの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/barrier.html&#34;&gt;&amp;lt;barrier&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータの組ではなく、コンテナや配列、部分的なコンテナなどを扱う範囲ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;既存のイテレータの組を扱うアルゴリズムは、&lt;code&gt;std::ranges&lt;/code&gt;名前空間に範囲版アルゴリズムが追加される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ソースコードの位置を取得するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/source_location.html&#34;&gt;&amp;lt;source_location&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;取り決め&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std&lt;/code&gt;名前空間以下の関数テンプレートをユーザーが特殊化することを禁止する (参照 : &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r3.pdf&#34; target=&#34;_blank&#34;&gt;P0551R3&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;連想コンテナに、要素がコンテナに含まれているかを判定する&lt;code&gt;contains()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;順序付き連想コンテナと同様に、非順序連想コンテナの検索処理で、一時オブジェクトが生成されるコストを抑える拡張を追加。キー等値比較を行う関数オブジェクトとハッシュ計算を行う関数オブジェクトの両方に&lt;code&gt;is_transparent&lt;/code&gt;が定義されていれば、透過的な検索が使用できる。&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;クラスのページを参照&lt;/li&gt;
&lt;li&gt;各コンテナの非メンバ関数として、要素を削除する&lt;code&gt;std::erase()&lt;/code&gt;関数と&lt;code&gt;std::erase_if()&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;のメンバ関数&lt;code&gt;remove()&lt;/code&gt;、&lt;code&gt;remove_if()&lt;/code&gt;、&lt;code&gt;unique()&lt;/code&gt;の戻り値型を、&lt;code&gt;void&lt;/code&gt;から&lt;code&gt;Container::size_type&lt;/code&gt;に変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;クラスの比較演算子、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/fill.html&#34;&gt;fill()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;組み込み配列を&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;に変換する関数として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/to_array.html&#34;&gt;std::to_array()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数としてコンテナの要素数を取得する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ssize.html&#34;&gt;std::ssize()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;、および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/vector/vector.html&#34;&gt;std::vector&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;の多くの関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素位置をシフトする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shift_left.html&#34;&gt;std::shift_left()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/shift_right.html&#34;&gt;std::shift_right()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に三方比較による辞書順比較アルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/lexicographical_compare_three_way.html&#34;&gt;std::lexicographical_compare_three_way()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値とポインタの中点を求める関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/midpoint.html&#34;&gt;std::midpoint()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;浮動小数点数を線形補間する関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/lerp.html&#34;&gt;std::lerp()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムをムーブに対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;の数値計算アルゴリズムに&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_insert_iterator.html&#34;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_insert_iterator.html&#34;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/insert_iterator.html&#34;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt;クラスのコンストラクタ、代入演算子、間接参照演算子、インクリメント演算子、および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_inserter.html&#34;&gt;std::back_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_inserter.html&#34;&gt;std::front_inserter()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/inserter.html&#34;&gt;std::inserter()&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;constexpr&lt;/code&gt;を追加。これらのクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/ref.html&#34;&gt;std::ref()&lt;/a&gt;&lt;/code&gt;関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/cref.html&#34;&gt;std::cref()&lt;/a&gt;&lt;/code&gt;関数のテンプレートパラメータ&lt;code&gt;T&lt;/code&gt;型に不完全型を指定することを許可&lt;/li&gt;
&lt;li&gt;メンバ関数の部分適用を簡単にするために、プレースホルダーの指定なく引数を先頭から順に束縛する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;の各操作、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;std::not_fn()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;std::bind()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;std::mem_fn()&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;li&gt;コンセプトの導入にともない、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った値をそのまま返す関数オブジェクト&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/identity.html&#34;&gt;std::identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;クラスに、先頭の部分文字列を判定する&lt;code&gt;starts_with()&lt;/code&gt;メンバ関数、末尾の部分文字列を判定する&lt;code&gt;ends_with()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数の、メモリの縮小機能を削除し、伸長のみとする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits.html&#34;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/move.html&#34;&gt;move()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/copy.html&#34;&gt;copy()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/char_traits/assign.html&#34;&gt;assign()&lt;/a&gt;&lt;/code&gt;静的メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが、値初期化するよう動作変更。これまではC言語との互換性のために未初期化となっていた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスの浮動小数点数型に対する特殊化を追加&lt;/li&gt;
&lt;li&gt;アトミッククラスに対するブロッキング同期の機能として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/wait.html&#34;&gt;wait()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html&#34;&gt;notify_one()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/notify_all.html&#34;&gt;notify_all()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ロックフリーであることが保証されたアトミック整数型の別名として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;atomic_signed_lock_free&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;atomic_unsigned_lock_free&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/memory_order.html&#34;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;の列挙子にスコープをもたせた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスに、&lt;code&gt;bool&lt;/code&gt;値を読み込むメンバ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag/test.html&#34;&gt;test()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;非アトミックなオブジェクトにアトミック操作を適用するためのクラス&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ベクトル化の実行ポリシーとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unsequenced_policy&lt;/a&gt;&lt;/code&gt;型と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/execution/execution/execution_policy.html&#34;&gt;std::execution::unseq&lt;/a&gt;&lt;/code&gt;タグを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同期ストリームの追加にともなって、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream.html&#34;&gt;&amp;lt;ostream&amp;gt;&lt;/a&gt;&lt;/code&gt;に、同期ストリーム関係の出力マニピュレータを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/istream/basic_istream/op_istream_free.html&#34;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;(basic_istream&amp;amp;, CharT*)&lt;/code&gt;を&lt;code&gt;operator&amp;gt;&amp;gt;(basic_istream&amp;amp;, CharT (&amp;amp;)[N])&lt;/code&gt;に修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream/basic_ostream/op_ostream_free.html&#34;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;wchar_t&lt;/code&gt; (&lt;code&gt;char&lt;/code&gt;版のみ)、&lt;code&gt;char8_t&lt;/code&gt;、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;のdelete宣言を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/istream_iterator.html&#34;&gt;std::istream_iterator&lt;/a&gt;&lt;/code&gt;について、要件の書き方を整理し、振る舞いをより明確化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::basic_stringbuf&lt;/code&gt;、&lt;code&gt;std::basic_istringstream&lt;/code&gt;、&lt;code&gt;std::basic_ostringstream&lt;/code&gt;クラスに、アロケータを伝播させるためのインタフェースを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_shared.html&#34;&gt;std::make_shared()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocate_shared.html&#34;&gt;std::allocate_shared()&lt;/a&gt;&lt;/code&gt;を配列に対応&lt;/li&gt;
&lt;li&gt;スマートポインタをデフォルト初期化で構築するヘルパ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_unique_for_overwrite.html&#34;&gt;std::make_unique_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_shared_for_overwrite.html&#34;&gt;std::make_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocate_shared_for_overwrite.html&#34;&gt;std::allocate_shared_for_overwrite()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ポインタを生ポインタに変換する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/to_address.html&#34;&gt;std::to_address()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_traits.html&#34;&gt;std::pointer_traits&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_traits/pointer_to.html&#34;&gt;pointer_to()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Nバイトアライメントされたポインタであることをコンパイラに伝える&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/assume_aligned.html&#34;&gt;std::assume_aligned()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、uses allocator構築をサポートするユーティリティ関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/uses_allocator_construction_args.html&#34;&gt;std::uses_allocator_construction_args()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/make_obj_using_allocator.html&#34;&gt;std::make_obj_using_allocator()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/uninitialized_construct_using_allocator.html&#34;&gt;std::uninitialized_construct_using_allocator()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator.html&#34;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;に、以下の変更を追加：&lt;ul&gt;
&lt;li&gt;クラステンプレートのデフォルトテンプレート引数を&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;&lt;/code&gt;型とした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt;のバイト列をメモリ確保する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/allocate_bytes.html&#34;&gt;allocate_bytes()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/deallocate_bytes.html&#34;&gt;deallocate_bytes()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリを確保する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/allocate_object.html&#34;&gt;allocate_object()&lt;/a&gt;&lt;/code&gt;、解放する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/deallocate_object.html&#34;&gt;deallocate_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定した型のメモリ確保と構築をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/new_object.html&#34;&gt;new_object()&lt;/a&gt;&lt;/code&gt;、破棄と解放をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/delete_object.html&#34;&gt;delete_object()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、符号付き整数と符号なし整数の安全な比較関数として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_equal.html&#34;&gt;std::cmp_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_not_equal.html&#34;&gt;std::cmp_not_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less.html&#34;&gt;std::cmp_less()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_less_equal.html&#34;&gt;std::cmp_less_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater.html&#34;&gt;std::cmp_greater()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/cmp_greater_equal.html&#34;&gt;std::cmp_greater_equal()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/in_range.html&#34;&gt;std::in_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/swap.html&#34;&gt;std::swap()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/exchange.html&#34;&gt;std::exchange()&lt;/a&gt;&lt;/code&gt;関数に&lt;code&gt;constexpr&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;クラスを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;、&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/op_assign.html&#34;&gt;代入演算子&lt;/a&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/swap.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;メンバ関数、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple/swap_free.html&#34;&gt;swap()&lt;/a&gt;&lt;/code&gt;非メンバ関数に&lt;code&gt;constexpr&lt;/code&gt;を追加。このクラスのメンバ関数はすべて&lt;code&gt;constexpr&lt;/code&gt;に対応した&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイルシステム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/filesystem/create_directory.html&#34;&gt;std::filesystem::create_directory()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/filesystem/create_directories.html&#34;&gt;std::filesystem::create_directories()&lt;/a&gt;&lt;/code&gt;の仕様が直感的ではなく、すでにディレクトリが存在している場合にエラーとなっていた。C++20ではその状況ではエラーにならないようにする (エラーではなく&lt;code&gt;false&lt;/code&gt;が返る)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、constexpr関数が定数式評価されたかを判定する特殊な関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_constant_evaluated.html&#34;&gt;std::is_constant_evaluated()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、型のCV修飾と参照を除去する型特性クラスとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;std::remove_cvref&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、受け取った型をそのまま返す&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/type_identity.html&#34;&gt;std::type_identity&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、例外送出せずに暗黙の型変換が可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_nothrow_convertible.html&#34;&gt;std::is_nothrow_convertible&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素数が判明している配列型かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_bounded_array.html&#34;&gt;std::is_bounded_array&lt;/a&gt;&lt;/code&gt;、要素数が不明な配列型かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_unbounded_array.html&#34;&gt;std::is_unbounded_array&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、レイアウト互換性、ポインタ相互交換可能性を判定する以下の型特性を追加：&lt;ul&gt;
&lt;li&gt;2つの型にレイアウト互換があるかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_layout_compatible.html&#34;&gt;std::is_layout_compatible&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2つのメンバポインタが互換な共通位置にあるかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_corresponding_member.html&#34;&gt;std::is_corresponding_member()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基底クラスと派生クラスの間でポインタ相互交換可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_base_of.html&#34;&gt;std::is_pointer_interconvertible_base_of&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;メンバポインタとクラスの間でポインタ相互交換可能かを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_pointer_interconvertible_with_class.html&#34;&gt;is_pointer_interconvertible_with_class()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型を&lt;code&gt;T&amp;amp;&lt;/code&gt;型に展開する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_reference.html&#34;&gt;std::unwrap_reference&lt;/a&gt;&lt;/code&gt;型特性、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;std::decay&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;型の展開をする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/unwrap_ref_decay.html&#34;&gt;std::unwrap_ref_decay&lt;/a&gt;&lt;/code&gt;型特性を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一貫比較機能によって比較演算子の定義が容易になったため、不要になった演算子の簡潔定義機能である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/rel_ops.html&#34;&gt;std::rel_ops&lt;/a&gt;&lt;/code&gt;を非推奨化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;メンバ関数が、メモリの縮小をしなくなったため、デフォルト引数&lt;code&gt;0&lt;/code&gt;を非推奨化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag.html&#34;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;クラスのデフォルトコンストラクタが値初期化するようになったため、不要になった以下のアトミックオブジェクトの初期化機能を非推奨化：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_init.html&#34;&gt;std::atomic_init()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_var_init.html&#34;&gt;ATOMIC_VAR_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_flag_init.html&#34;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;マクロ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;allocator&lt;/a&gt;&lt;/code&gt;の以下のメンバを削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;difference_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_pointer&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_reference&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rebind&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/address.html&#34;&gt;address()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/allocate.html&#34;&gt;allocate()&lt;/a&gt;&lt;/code&gt;メンバ関数の&lt;code&gt;hint&lt;/code&gt;パラメータ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/max_size.html&#34;&gt;max_size()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/construct.html&#34;&gt;construct()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/destroy.html&#34;&gt;destroy()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++11で&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator_traits.html&#34;&gt;allocator_traits&lt;/a&gt;&lt;/code&gt;クラスが導入されたことでC++17から非推奨化されていた、要素型を再束縛するための&lt;code&gt;allocator&amp;lt;void&amp;gt;&lt;/code&gt;特殊化を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、&lt;code&gt;constexpr&lt;/code&gt;で扱える型の分類である&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_literal_type.html&#34;&gt;is_literal_type&lt;/a&gt;&lt;/code&gt;型特性を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた、一時的なメモリ確保のための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/get_temporary_buffer.html&#34;&gt;std::get_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/return_temporary_buffer.html&#34;&gt;std::return_temporary_buffer()&lt;/a&gt;&lt;/code&gt;関数を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/raw_storage_iterator.html&#34;&gt;raw_storage_iterator&lt;/a&gt;&lt;/code&gt;クラスを削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた以下の機能を削除：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;not1()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;not2()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;unary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/negators.html&#34;&gt;binary_negate&lt;/a&gt;&lt;/code&gt;クラス&lt;/li&gt;
&lt;li&gt;標準関数オブジェクトの&lt;code&gt;result_type&lt;/code&gt;、&lt;code&gt;argument_type&lt;/code&gt;、&lt;code&gt;first_argument_type&lt;/code&gt;、&lt;code&gt;second_argument_type&lt;/code&gt;型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;shared_ptr&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr/unique.html&#34;&gt;unique()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/invoke_result.html&#34;&gt;invoke_result&lt;/a&gt;&lt;/code&gt;の追加にともない、C++17から非推奨化されていた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/result_of.html&#34;&gt;result_of&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17での&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exception/uncaught_exceptions.html&#34;&gt;uncaught_exceptions()&lt;/a&gt;&lt;/code&gt;の追加にともない、非推奨化していた&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/exception/uncaught_exception.html&#34;&gt;uncaught_exception()&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17で非推奨化されていたC互換ライブラリ&lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt;を削除。また、C++ではなにも定義されないC互換ライブラリ&lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2131r0.html&#34; target=&#34;_blank&#34;&gt;P2131R0 Changes between C++17 and C++20 DIS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>特殊化のアクセスチェック -- C++20 特殊化のアクセスチェック、背景まで #722</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/access_checking_on_specializations.html"/>
      <id>886f17be7a416fdc2c48b8faa6bb15207b07459b:lang/cpp20/access_checking_on_specializations.md</id>
      <updated>2022-12-27T18:24:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/access_checking_on_specializations.md b/lang/cpp20/access_checking_on_specializations.md
new file mode 100644
index 000000000..ac3ea1d84
--- /dev/null
+++ b/lang/cpp20/access_checking_on_specializations.md
@@ -0,0 +1,97 @@
+# 特殊化のアクセスチェック
+* cpp20[meta cpp]
+
+## 概要
+
+クラス`C1`の内側で宣言されたクラス（ローカルクラス`impl`）が`private/protected`で宣言されている場合、テンプレートの文脈で`C1`の外側から`impl`を参照することは禁止されていた。しかし、実際にはほぼ全てのコンパイラでこれは許可されており、実際に使用されていた。
+
+```cpp
+template&amp;lt;class T&amp;gt;
+struct trait;
+
+class C1 {
+  class impl; // クラス内ローカルクラス
+};
+
+// C++17まではill-formed、しかし実際にはほぼ全てのコンパイラでエラーにならなかった
+// C++20からはok
+template&amp;lt;&amp;gt;
+struct trait&amp;lt;C1::impl&amp;gt;;
+```
+
+ただし、この`impl`がクラステンプレートになるとコンパイラによってはエラーとなっていた。
+
+```cpp
+class C1 {
+  template&amp;lt;typename U&amp;gt;
+  class impl{}; // クラス内ローカルクラステンプレート
+};
+
+// C++17まではill-formed、しかし一部のコンパイラではエラーにならなかった
+// C++20からはok
+template&amp;lt;&amp;gt;
+struct trait&amp;lt;C1::impl&amp;gt;;
+```
+
+C++20からはこれらの場合の挙動が標準化され、アクセス指定に関わらずローカルクラスをその親クラスの外側からテンプレートの文脈で参照することが許可されるようになる。
+
+## 仕様
+
+1. 通常のアクセスチェックルールは、テンプレートの部分特殊化のテンプレート引数を指定する名前（非依存名）に対しては適用されない。
+2. 通常のアクセスチェックルールは、明示的特殊化の宣言及び[明示的インスタンス化](/lang/cpp11/extern_template.md)内の名前に対しては適用されない。
+    - 関数本体、デフォルト引数、基底クラスのリスト、メンバ宣言、列挙子宣言、静的メンバ変数、変数テンプレートの初期化子内の名前を除く
+
+部分特殊化のテンプレート引数の依存名については、部分特殊化宣言時にはアクセスチェックされないが、部分特殊化の置換時にはチェックされる。
+
+```cpp
+class C {
+  template&amp;lt;typename U&amp;gt;
+  class impl{};
+};
+
+// プライマリテンプレート
+template&amp;lt;typename T, typename U&amp;gt;
+struct traits;
+
+// 部分特殊化
+template&amp;lt;typename T, typename U&amp;gt;
+struct traits&amp;lt;C::impl&amp;lt;T&amp;gt;, U&amp;gt; {}; // ok、部分特殊化の宣言、インスタンス化時には依存名でなくなる
+
+// 他のテンプレート
+template&amp;lt;typename T&amp;gt;
+struct S {
+  traits&amp;lt;C::impl&amp;lt;T&amp;gt;, int&amp;gt; t;     // ng、Sのインスタンス化に伴って部分特殊化の置換が発生し、C::impl&amp;lt;T&amp;gt;は依存名なのでアクセスチェックが行われる
+};
+
+
+int main() {
+  S&amp;lt;int&amp;gt; s;
+}
+```
+
+## この機能が必要になった背景・経緯
+
+冒頭で示した例は抽象的で出会うことは少なそうに思われるが、実際にはこのようなコードは範囲を表すクラスのイテレータ型の実装においてよく行われていた。
+
+```cpp
+template&amp;lt;typename V&amp;gt;
+class my_view {
+  template&amp;lt;typename T&amp;gt;
+  class my_view_iterator;
+};
+
+template&amp;lt;typename T&amp;gt;
+struct std::iterator_traits&amp;lt;my_view&amp;lt;int&amp;gt;::my_view_iterator&amp;lt;T&amp;gt;&amp;gt;;
+```
+
+このようなイテレータの実装方法はC++17以前にもよく行われており、C++20の`&amp;lt;ranges&amp;gt;`の一部の`view`型の実装においても行われる。これを放置すると、そのような`view`型ではポータブルかつ合法的に`std::iterator_traits`を使用することができなくなる。
+
+そのため、C++20においてこの振る舞いを実装間で統一するために、テンプレートの文脈でプライベートローカルクラス（テンプレート）を参照することが許可された。
+
+## 検討されたほかの選択肢
+(執筆中)
+
+## 参照
+
+- [P0692R1 Access Checking on Specializations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0692r1.html)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>