<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-27T09:03:12.492214</updated>
  <id>f4d807f5-8a4f-4286-b166-6c53f2adab8f</id>

  
    <entry>
      <title>fold_left -- fold_left, fold_right : 箇条書きの表示崩れを修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.html"/>
      <id>9094beb997b31879c2fe78a6249d4cddc5163ba6:reference/algorithm/ranges_fold_left.md</id>
      <updated>2025-05-27T17:59:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left.md b/reference/algorithm/ranges_fold_left.md
index 8c7651f38..cd35caa38 100644
--- a/reference/algorithm/ranges_fold_left.md
+++ b/reference/algorithm/ranges_fold_left.md
@@ -152,6 +152,7 @@ concept indirectly-binary-left-foldable =
 
     - すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
     - また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+
 - (1), (2) :
     - C++26 : 引数として波カッコ初期化`{}`を受け付ける
         ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_right -- fold_left, fold_right : 箇条書きの表示崩れを修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.html"/>
      <id>9094beb997b31879c2fe78a6249d4cddc5163ba6:reference/algorithm/ranges_fold_right.md</id>
      <updated>2025-05-27T17:59:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_right.md b/reference/algorithm/ranges_fold_right.md
index 2c418690b..89531d1fd 100644
--- a/reference/algorithm/ranges_fold_right.md
+++ b/reference/algorithm/ranges_fold_right.md
@@ -149,6 +149,7 @@ return accum;
 
     - すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
     - また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+
 - (1), (2) :
     - C++26 : 引数として波カッコ初期化`{}`を受け付ける
         ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- ranges::count, equal_range, lower_bound : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>1f87d6a9e341dd8e5fe7a0f74d7545a804e9895a:reference/algorithm/ranges_count.md</id>
      <updated>2025-05-27T17:23:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 0c3504815..294f0855b 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -142,6 +142,43 @@ int main() {
 count of {1,2}: 2
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct Item {
+  int id;
+  std::string label;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, &amp;#34;foo&amp;#34;},
+    {3, &amp;#34;bar&amp;#34;},
+    {5, &amp;#34;foo&amp;#34;},
+    {2, &amp;#34;baz&amp;#34;},
+  };
+
+  // メンバ変数ポインタを使って label==&amp;#34;foo&amp;#34; の要素数を数える
+  int n1 = std::ranges::count(v, std::string(&amp;#34;foo&amp;#34;), &amp;amp;Item::label);
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of label==\&amp;#34;foo\&amp;#34;: &amp;#34; &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; std::endl;
+
+  // ラムダ式を使って id==1 の要素数を数える
+  int n2 = std::ranges::count(v, 1, [](const Item&amp;amp; p) { return p.id; });
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of id==1: &amp;#34; &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count[color ff0000]
+
+#### 出力
+```
+count of label==&amp;#34;foo&amp;#34;: 2
+count of id==1: 2
+```
+
 
 ## 実装例
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- ranges::count, equal_range, lower_bound : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>1f87d6a9e341dd8e5fe7a0f74d7545a804e9895a:reference/algorithm/ranges_equal_range.md</id>
      <updated>2025-05-27T17:23:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index 225f563da..fa5266fb4 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -182,6 +182,62 @@ int main() {
 3,4
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct X {
+  int id;
+  std::string name;
+};
+
+int main() {
+  std::vector&amp;lt;X&amp;gt; v = {
+    {1, &amp;#34;Carol&amp;#34;},
+    {3, &amp;#34;Alice&amp;#34;},
+    {4, &amp;#34;Bob&amp;#34;},
+    {4, &amp;#34;Bob&amp;#34;},
+    {5, &amp;#34;Eve&amp;#34;},
+    {6, &amp;#34;Dave&amp;#34;}
+  };
+  const std::string key = &amp;#34;Bob&amp;#34;;
+
+  // メンバ変数nameをキーとして検索
+  // 1. メンバ変数ポインタを使う方法
+  auto result1 = std::ranges::equal_range(v, key, {}, &amp;amp;X::name);
+  std::cout &amp;lt;&amp;lt; &amp;#34;[メンバ変数ポインタ]&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const X&amp;amp; x : result1) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; x.id &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; x.name &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 2. ラムダ式を使う方法
+  auto result2 = std::ranges::equal_range(
+    v,
+    key,
+    {},
+    [](const X&amp;amp; x) { return x.name; }
+);
+  std::cout &amp;lt;&amp;lt; &amp;#34;[ラムダ式]&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const X&amp;amp; x : result2) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; x.id &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; x.name &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::equal_range[color ff0000]
+
+#### 出力
+```
+[メンバ変数ポインタ]
+id=4 name=Bob
+id=4 name=Bob
+[ラムダ式]
+id=4 name=Bob
+id=4 name=Bob
+```
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- ranges::count, equal_range, lower_bound : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>1f87d6a9e341dd8e5fe7a0f74d7545a804e9895a:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2025-05-27T17:23:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
index 9fb2c5659..9b4d1be4f 100644
--- a/reference/algorithm/ranges_lower_bound.md
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -230,6 +230,62 @@ int main() {
 pos=2
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct X {
+  int id;
+  std::string name;
+};
+
+int main() {
+  std::vector&amp;lt;X&amp;gt; v = {
+    {1, &amp;#34;Carol&amp;#34;},
+    {3, &amp;#34;Alice&amp;#34;},
+    {4, &amp;#34;Bob&amp;#34;},
+    {5, &amp;#34;Eve&amp;#34;},
+    {6, &amp;#34;Dave&amp;#34;}
+  };
+  const std::string key = &amp;#34;Bob&amp;#34;;
+
+  // nameメンバ変数をキーとして検索
+  // 1. メンバ変数ポインタを使う方法
+  auto it1 = std::ranges::lower_bound(v, key, {}, &amp;amp;X::name);
+  if (it1 != v.end() &amp;amp;&amp;amp; it1-&amp;gt;name == key) {
+    std::size_t pos = std::ranges::distance(v.begin(), it1);
+    std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it1-&amp;gt;id
+              &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it1-&amp;gt;name
+              &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 2. ラムダ式を使う方法
+  auto it2 = std::ranges::lower_bound(
+    v,
+    key,
+    {},
+    [](const X&amp;amp; x) { return x.name; }
+  );
+  if (it2 != v.end() &amp;amp;&amp;amp; it2-&amp;gt;name == key) {
+    std::size_t pos = std::ranges::distance(v.begin(), it2);
+    std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it2-&amp;gt;id
+              &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it2-&amp;gt;name
+              &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::lower_bound[color ff0000]
+* std::ranges::distance[link /reference/iterator/ranges_distance.md]
+
+#### 出力
+```
+id=4 name=Bob pos=2
+id=4 name=Bob pos=2
+```
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- ranges::find : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>0dfcb84d27bb4a6a4eed9c75a13522415335c80a:reference/algorithm/ranges_find.md</id>
      <updated>2025-05-27T17:08:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 7f76d5976..41dfe9d96 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -102,6 +102,62 @@ int main() {
 found: 1
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct Item {
+  int id;
+  std::string name;
+};
+
+int main() {
+  std::vector&amp;lt;Item&amp;gt; v = {
+    {1, &amp;#34;aaa&amp;#34;},
+	{3, &amp;#34;bbb&amp;#34;},
+	{5, &amp;#34;ccc&amp;#34;}
+  };
+
+  // メンバ変数ポインタを使って特定のメンバ変数で検索
+  {
+    auto it = std::ranges::find(
+      v,
+      std::string(&amp;#34;bbb&amp;#34;),
+      &amp;amp;Item::name
+    );
+    if (it == v.end()) {
+      std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+    } else {
+      std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; it-&amp;gt;name &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // ラムダ式で特定のメンバ変数を検索
+  {
+    auto it = std::ranges::find(
+      v,
+      std::string(&amp;#34;bbb&amp;#34;),
+      [](const Item&amp;amp; x) { return x.name; }
+    );
+    if (it == v.end()) {
+      std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+    } else {
+      std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; it-&amp;gt;name &amp;lt;&amp;lt; std::endl;
+    }
+  } 
+}
+```
+* std::ranges::find[color ff0000]
+
+#### 出力
+```
+found: 3,bbb
+found: 3,bbb
+```
+
 ### 波カッコ初期化を入力として使用する (C++26)
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- find_last, contains : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains.html"/>
      <id>1350ce71a23944efb2f73e7eabded20f52930d17:reference/algorithm/ranges_contains.md</id>
      <updated>2025-05-27T16:52:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains.md b/reference/algorithm/ranges_contains.md
index be782ad08..2f3e2ded3 100644
--- a/reference/algorithm/ranges_contains.md
+++ b/reference/algorithm/ranges_contains.md
@@ -6,16 +6,59 @@
 
 ```cpp
 namespace ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-    constexpr bool contains(I first, S last, const T&amp;amp; value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires
-      indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-    constexpr bool contains(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (2) C++23
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (2) C++26
 }
 ```
 
@@ -25,25 +68,72 @@ namespace ranges {
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
 
+
 ## 戻り値
 ```cpp
 ranges::find(std::move(first), last, value, proj) != last
 ```
 * ranges::find[link ranges_find.md]
 
+
 ## 計算量
 最大で `last - first` 回比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::ranges::contains(r, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;print&amp;gt;
 #include &amp;lt;array&amp;gt;
 
 int main() {
-  constexpr std::array v = { 3, 1, 4 };
-  if (std::ranges::contains(v, 1)) {
+  constexpr std::array ar = { 3, 1, 4 };
+  if (std::ranges::contains(ar, 1)) {
+    std::println(&amp;#34;found&amp;#34;);
+  } else {
+    std::println(&amp;#34;not found&amp;#34;);
+  }
+}
+```
+* std::ranges::contains[color ff0000]
+
+#### 出力
+```
+found
+```
+
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+	{1, 2},
+	{3, 4},
+	{5, 6}
+  };
+
+  bool found = std::ranges::contains(v, {3, 4});
+  if (found) {
     std::println(&amp;#34;found&amp;#34;);
   } else {
     std::println(&amp;#34;not found&amp;#34;);
@@ -52,7 +142,7 @@ int main() {
 ```
 * std::ranges::contains[color ff0000]
 
-### 出力
+#### 出力
 ```
 found
 ```
@@ -90,3 +180,5 @@ inline constexpr contains_impl contains;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last -- find_last, contains : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last.html"/>
      <id>1350ce71a23944efb2f73e7eabded20f52930d17:reference/algorithm/ranges_find_last.md</id>
      <updated>2025-05-27T16:52:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last.md b/reference/algorithm/ranges_find_last.md
index 47afea8da..a2c7878bc 100644
--- a/reference/algorithm/ranges_find_last.md
+++ b/reference/algorithm/ranges_find_last.md
@@ -10,21 +10,55 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr ranges::subrange&amp;lt;I&amp;gt;
     find_last(I first,
               S last,
               const T&amp;amp; value,
               Proj proj = {}); // (1) C++23
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr ranges::subrange&amp;lt;I&amp;gt;
+    find_last(I first,
+              S last,
+              const T&amp;amp; value,
+              Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
             class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
     find_last(R&amp;amp;&amp;amp; r,
               const T&amp;amp; value,
               Proj proj = {}); // (2) C++23
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last(R&amp;amp;&amp;amp; r,
+              const T&amp;amp; value,
+              Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -50,31 +84,82 @@ namespace std::ranges {
 最大で `last - first` 回比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::ranges::find_last(r, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;iostream&amp;gt;
 
 int main() {
-  constexpr std::array v = { 3, 1, 4, 1, 5 };
-  const auto result = std::ranges::find_last(v, 1);
-  if (result.begin() == v.end()) {
+  constexpr std::array ar = { 3, 1, 4, 1, 5 };
+  const std::ranges::subrange result = std::ranges::find_last(ar, 1);
+  if (result.begin() == ar.end()) {
     std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
   } else {
     std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
-    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(ar.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
   }
 }
 ```
 * std::ranges::find_last[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Point&amp;amp; p) {
+  return os &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; p.y;
+}
+
+int main() {
+  constexpr std::array&amp;lt;Point, 3&amp;gt; ar = {{
+    {1, 2},
+	{3, 4},
+	{5, 6}
+  }};
+
+  const std::ranges::subrange result = std::ranges::find_last(ar, {3, 4});
+  if (result.begin() == ar.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(ar.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last[color ff0000]
+
+#### 出力
+```
+found: 3,4
+  pos: 1
+```
+
 
 ## バージョン
 ### 言語
@@ -87,4 +172,8 @@ found: 1
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 ## 参照
-- [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P1223R5 `find_last`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3217R0 Adjoints to &amp;#34;Enabling list-initialization for algorithms&amp;#34;: `find_last`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3217r0.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
+    - 関連文書：
+        - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_left.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left.md b/reference/algorithm/ranges_fold_left.md
index 3477c8c6d..8c7651f38 100644
--- a/reference/algorithm/ranges_fold_left.md
+++ b/reference/algorithm/ranges_fold_left.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_left(I first, S last, T init, F f);       // (1)
-
-  template&amp;lt;input_range R, class T, 
-           indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_left(R&amp;amp;&amp;amp; r, T init, F f);                 // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(I first,
+              S last,
+              T init,
+              F f);   // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(I first,
+              S last,
+              T init,
+              F f);   // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T, 
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(R&amp;amp;&amp;amp; r,
+              T init,
+              F f);   // (2) C++23
+  template &amp;lt;input_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;, 
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(R&amp;amp;&amp;amp; r,
+              T init,
+              F f);   // (2) C++26
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -116,19 +142,22 @@ concept indirectly-binary-left-foldable =
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
-
-この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
-
-```cpp
-using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, T, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
-```
-* decay_t[link /reference/type_traits/decay.md]
-* invoke_result_t[link /reference/type_traits/invoke_result.md]
-* iter_reference_t[link /reference/iterator/iter_reference_t.md]
-
-すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
-
-また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
+    ```cpp
+    using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, T, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
+    ```
+    * decay_t[link /reference/type_traits/decay.md]
+    * invoke_result_t[link /reference/type_traits/invoke_result.md]
+    * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+
+    - すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
+    - また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        T sum = std::ranges::fold_left(v, {a, b}, op);
+        ```
 
 ## 例
 
@@ -172,7 +201,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 55
 1.125
@@ -217,12 +246,36 @@ int main() {
 * println[link /reference/print/println.md]
 * fold_right[link ranges_fold_right.md]
 
-### 出力
+#### 出力
 ```
 init -&amp;gt; a -&amp;gt; b -&amp;gt; c -&amp;gt; d -&amp;gt; e -&amp;gt; f
 init -&amp;gt; f -&amp;gt; e -&amp;gt; d -&amp;gt; c -&amp;gt; b -&amp;gt; a
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  int sum = std::ranges::fold_left(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{}&amp;#34;, sum);
+}
+```
+* std::ranges::fold_left[color ff0000]
+
+#### 出力
+```
+6
+```
+
 ## 実装例
 
 ```cpp
@@ -273,3 +326,5 @@ constexpr auto fold_left(I first, S last, T init, F f) {
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
 - [プログラミングHaskellのfoldr, foldlの説明が秀逸だった件 - あと味](https://taiju.hatenablog.com/entry/20130202/1359773888)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left_with_iter -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_with_iter.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_left_with_iter.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left_with_iter.md b/reference/algorithm/ranges_fold_left_with_iter.md
index a1e264bbc..1646732ec 100644
--- a/reference/algorithm/ranges_fold_left_with_iter.md
+++ b/reference/algorithm/ranges_fold_left_with_iter.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_left_with_iter(I first, S last, T init, F f); // (1)
-
-  template&amp;lt;input_range R, class T,
-           indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_left_with_iter(R&amp;amp;&amp;amp; r, T init, F f);           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(I first,
+                        S last,
+                        T init,
+                        F f); // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(I first,
+                        S last,
+                        T init,
+                        F f); // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(R&amp;amp;&amp;amp; r,
+                        T init,
+                        F f); // (2) C++23
+  template &amp;lt;input_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(R&amp;amp;&amp;amp; r,
+                        T init,
+                        F f); // (2) C++26
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -96,10 +122,15 @@ constexpr fold_left_with_iter_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, U&amp;gt;
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
+- 戻り値の項で使用している`U`は、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型であり、`fold_left_with_iter()`の処理内部で積算値の型として使用されるものでもある。
+- `fold_left`同様に、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto [end, sum] = std::ranges::fold_left_with_iter(v, {a, b}, op);
+        ```
 
-戻り値の項で使用している`U`は、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型であり、`fold_left_with_iter()`の処理内部で積算値の型として使用されるものでもある。
-
-`fold_left`同様に、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
 
 ## 例
 
@@ -141,7 +172,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 { true, 55 }
 { true, 1.125 }
@@ -178,7 +209,7 @@ int main() {
 * println[link /reference/print/println.md]
 * value_or[link /reference/optional/optional/value_or.md]
 
-### 出力
+#### 出力
 ```
 -1
 -1
@@ -222,13 +253,37 @@ int main() {
 * subrange[link /reference/ranges/subrange.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 
 ```
 sum = 36
 mul = 36288, 36288
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  auto [end, sum] = std::ranges::fold_left_with_iter(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{} {}&amp;#34;, end == v.end(), sum);
+}
+```
+* std::ranges::fold_left_with_iter[color ff0000]
+
+#### 出力
+```
+true 6
+```
+
 ## 実装例
 
 ```cpp
@@ -282,3 +337,5 @@ constexpr auto fold_left_with_iter(I first, S last, T init, F f) -&amp;gt; fold_left_wi
 ## 参照
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_right -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_right.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_right.md b/reference/algorithm/ranges_fold_right.md
index 96a13edc2..2c418690b 100644
--- a/reference/algorithm/ranges_fold_right.md
+++ b/reference/algorithm/ranges_fold_right.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_right(I first, S last, T init, F f);       // (1)
-
-  template&amp;lt;bidirectional_range R, class T,
-           indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_right(R&amp;amp;&amp;amp; r, T init, F f);                 // (2)
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(I first,
+               S last,
+               T init,
+               F f);    // (1) C++23
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(I first,
+               S last,
+               T init,
+               F f);    // (1) C++23
+
+  template &amp;lt;bidirectional_range R,
+            class T,
+            indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(R&amp;amp;&amp;amp; r,
+               T init,
+               F f);    // (2) C++23
+  template &amp;lt;bidirectional_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;,
+            indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(R&amp;amp;&amp;amp; r,
+               T init,
+               F f);    // (2) C++26
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -113,19 +139,23 @@ return accum;
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
+- この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
+    ```cpp
+    using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, iter_reference_t&amp;lt;I&amp;gt;, T&amp;gt;&amp;gt;;
+    ```
+    * decay_t[link /reference/type_traits/decay.md]
+    * invoke_result_t[link /reference/type_traits/invoke_result.md]
+    * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+
+    - すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
+    - また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        T sum = std::ranges::fold_right(v, {a, b}, op);
+        ```
 
-この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
-
-```cpp
-using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, iter_reference_t&amp;lt;I&amp;gt;, T&amp;gt;&amp;gt;;
-```
-* decay_t[link /reference/type_traits/decay.md]
-* invoke_result_t[link /reference/type_traits/invoke_result.md]
-* iter_reference_t[link /reference/iterator/iter_reference_t.md]
-
-すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
-
-また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
 
 ## 例
 
@@ -170,7 +200,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 55
 1.125
@@ -217,7 +247,7 @@ int main() {
 * println[link /reference/print/println.md]
 * fold_left[link /reference/algorithm/ranges_fold_left.md]
 
-### 出力
+#### 出力
 ```
 init -&amp;gt; a -&amp;gt; b -&amp;gt; c -&amp;gt; d -&amp;gt; e -&amp;gt; f
 init -&amp;gt; f -&amp;gt; e -&amp;gt; d -&amp;gt; c -&amp;gt; b -&amp;gt; a
@@ -255,11 +285,35 @@ int main() {
 * iota[link /reference/ranges/iota_view.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  int sum = std::ranges::fold_right(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{}&amp;#34;, sum);
+}
+```
+* std::ranges::fold_right[color ff0000]
+
+#### 出力
+```
+6
+```
+
 ## 実装例
 
 ```cpp
@@ -309,3 +363,5 @@ constexpr auto fold_right(I first, S last, T init, F f) {
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
 - [プログラミングHaskellのfoldr, foldlの説明が秀逸だった件 - あと味](https://taiju.hatenablog.com/entry/20130202/1359773888)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>