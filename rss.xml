<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-02-26T14:39:06.328462</updated>
  <id>6e9cd3b4-9368-4a28-a2bc-07d2375f60be</id>

  
    <entry>
      <title>indirectly_readable_traits -- LWG Issue 3446対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirectly_readable_traits.html"/>
      <id>1d7fae9e06d1a3a3533c88ccf92441455fa5dbac:reference/iterator/indirectly_readable_traits.md</id>
      <updated>2021-02-26T16:07:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirectly_readable_traits.md b/reference/iterator/indirectly_readable_traits.md
index 7be6932c0..d4b10579c 100644
--- a/reference/iterator/indirectly_readable_traits.md
+++ b/reference/iterator/indirectly_readable_traits.md
@@ -7,7 +7,7 @@
 ```cpp
 namespace std {
 
-  // 素の型を取得する、説明専用type-traits
+  // 素の型を取得しvalue_typeという名前に変換する、説明専用type-traits
   template&amp;lt;class&amp;gt;
   struct cond-value-type { };
 
@@ -39,17 +39,29 @@ namespace std {
   struct indirectly_readable_traits&amp;lt;const I&amp;gt;
     : indirectly_readable_traits&amp;lt;I&amp;gt; { };
 
-  // value_typeを定義している型についての特殊化
   template&amp;lt;class T&amp;gt;
-    requires requires { typename T::value_type; }
+  concept has-member-value-type = requires { typename T::value_type; };     // 説明専用
+
+  template&amp;lt;class T&amp;gt;
+  concept has-member-element-type = requires { typename T::element_type; }; // 説明専用
+
+  // value_typeを定義している型についての特殊化
+  template&amp;lt;has-member-value-type T&amp;gt;
   struct indirectly_readable_traits&amp;lt;T&amp;gt;
     : cond-value-type&amp;lt;typename T::value_type&amp;gt; { };
 
   // element_typeを定義している型についての特殊化
-  template&amp;lt;class T&amp;gt;
-    requires requires { typename T::element_type; }
+  template&amp;lt;has-member-element-type T&amp;gt;
   struct indirectly_readable_traits&amp;lt;T&amp;gt;
     : cond-value-type&amp;lt;typename T::element_type&amp;gt; { };
+  
+  // value_typeとelement_typeを両方定義している型についての特殊化
+  template&amp;lt;has-member-value-type T&amp;gt;
+    requires has-member-element-type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
+             same_as&amp;lt;remove_cv_t&amp;lt;typename T::element_type&amp;gt;, 
+                     remove_cv_t&amp;lt;typename T::value_type&amp;gt;&amp;gt;; }
+  struct indirectly_readable_traits&amp;lt;T&amp;gt;
+    : cond-value-type&amp;lt;typename T::value_type&amp;gt; { };
 }
 ```
 * is_object_v[link /reference/type_traits/is_object.md]
@@ -139,3 +151,4 @@ int main() {
 ## 参照
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [LWG Issue 3446. `indirectly_readable_traits` ambiguity for types with both `value_type` and `element_type`](https://cplusplus.github.io/LWG/issue3446)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_partial_order_fallback -- LWG Issue 3465対応</title>
      <link href="https://cpprefjp.github.io/reference/compare/compare_partial_order_fallback.html"/>
      <id>4b80799943658ee46ebb52e570f350c3bbaff345:reference/compare/compare_partial_order_fallback.md</id>
      <updated>2021-02-26T15:56:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/compare/compare_partial_order_fallback.md b/reference/compare/compare_partial_order_fallback.md
index 59d2dd0bf..4ffd72d8f 100644
--- a/reference/compare/compare_partial_order_fallback.md
+++ b/reference/compare/compare_partial_order_fallback.md
@@ -28,7 +28,7 @@ namespace std {
 
 2. [`partial_order`](partial_order.md)`(a, b)`が呼び出し可能ならば`partial_order(a, b)`
 
-3. `a == b`、`a &amp;lt; b`の両方の演算子が使用可能でありその戻り値型が`bool`へ変換可能ならば、以下の式
+3. `a == b`、`a &amp;lt; b`、`b &amp;lt; a`の3つの演算子が使用可能でありその戻り値型が`bool`へ変換可能ならば、以下の式
    ```cpp
    a == b ? partial_ordering::equivalent :
    a &amp;lt;  b ? partial_ordering::less :
@@ -151,3 +151,4 @@ false
 
 - [P0768R1 Library support for the spaceship (comparison) operator](http://wg21.link/p0768)
 - [P1614R2 The Mothership has Landed (Adding &amp;lt;=&amp;gt; to the Library)](http://wg21.link/p1614)
+- [LWG Issue 3465. `compare_partial_order_fallback` requires `F &amp;lt; E`](https://cplusplus.github.io/LWG/issue3465)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>convertible_to -- LWG Issue 3461対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts/convertible_to.html"/>
      <id>f26d50433239e535d7b29cbbb588cf13205dcc7c:reference/concepts/convertible_to.md</id>
      <updated>2021-02-26T15:51:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/convertible_to.md b/reference/concepts/convertible_to.md
index b3c040a08..1b4a82011 100644
--- a/reference/concepts/convertible_to.md
+++ b/reference/concepts/convertible_to.md
@@ -21,7 +21,7 @@ namespace std {
 
 `convertible_to`は、`From`に指定された型および値カテゴリから型`To`へ変換可能であることを表すコンセプトである。
 
-このコンセプトを満たすためには`From`から`To`へ暗黙的にも明示的にも変換可能であり、それら暗黙的および明示的な変換は同じ結果とならなければならない。
+このコンセプトを満たすためには[`declval`](/reference/utility/declval.md)`&amp;lt;From&amp;gt;()`と同じ型と値カテゴリを持つオブジェクトが型`To`へ暗黙的にも明示的にも変換可能であり、それら暗黙的および明示的な変換は同じ結果とならなければならない。
 
 ## モデル
 
@@ -141,3 +141,4 @@ true
 - [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
 - [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
 - [LWG Issue 3194. `ConvertibleTo` prose does not match code](https://wg21.cmeerw.net/lwg/issue3194)
+- [LWG Issue 3461. `convertible_to`&amp;#39;s description mishandles cv-qualified void](https://cplusplus.github.io/LWG/issue3461)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iter_move (非メンバ関数) -- LWG Issue 3472対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/iter_move.html"/>
      <id>b3ea6b2fb6a067ddf7177a4be7e40e5a63b5864a:reference/iterator/counted_iterator/iter_move.md</id>
      <updated>2021-02-26T15:42:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/iter_move.md b/reference/iterator/counted_iterator/iter_move.md
index 7f294f24f..9b949231c 100644
--- a/reference/iterator/counted_iterator/iter_move.md
+++ b/reference/iterator/counted_iterator/iter_move.md
@@ -19,6 +19,12 @@ namespace std {
 
 `counted_iterator`の指す要素をムーブする。
 
+## 事前条件
+
+カウントの値を`length`メンバ変数に保持するとして
+
+`length &amp;gt;= 0`
+
 ## 効果
 
 以下と等価
@@ -80,3 +86,4 @@ int main() {
 
 ## 参照
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [LWG Issue 3472. `counted_iterator` is missing preconditions](https://cplusplus.github.io/LWG/issue3472)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iter_swap (非メンバ関数) -- LWG Issue 3472対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/iter_swap.html"/>
      <id>b3ea6b2fb6a067ddf7177a4be7e40e5a63b5864a:reference/iterator/counted_iterator/iter_swap.md</id>
      <updated>2021-02-26T15:42:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/iter_swap.md b/reference/iterator/counted_iterator/iter_swap.md
index f4c46dabb..30c4a7deb 100644
--- a/reference/iterator/counted_iterator/iter_swap.md
+++ b/reference/iterator/counted_iterator/iter_swap.md
@@ -19,6 +19,12 @@ namespace std {
 
 2つの`counted_iterator`の指す要素を交換する。
 
+## 事前条件
+
+カウントの値を`length`メンバ変数に保持するとして
+
+`length &amp;gt;= 0`
+
 ## 効果
 
 以下と等価
@@ -84,3 +90,4 @@ int main() {
 
 ## 参照
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [LWG Issue 3472. `counted_iterator` is missing preconditions](https://cplusplus.github.io/LWG/issue3472)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator* -- LWG Issue 3472対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/op_deref.html"/>
      <id>b3ea6b2fb6a067ddf7177a4be7e40e5a63b5864a:reference/iterator/counted_iterator/op_deref.md</id>
      <updated>2021-02-26T15:42:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/op_deref.md b/reference/iterator/counted_iterator/op_deref.md
index 3135ee4d8..74c0b7930 100644
--- a/reference/iterator/counted_iterator/op_deref.md
+++ b/reference/iterator/counted_iterator/op_deref.md
@@ -14,6 +14,12 @@ constexpr decltype(auto) operator*() const requires dereferenceable&amp;lt;const I&amp;gt;;
 ## 概要
 イテレータを間接参照する。
 
+## 事前条件
+
+カウントの値を`length`メンバ変数に保持するとして
+
+`length &amp;gt;= 0`
+
 ## 効果
 
 `I`の値を`current`メンバ変数に保持するとして、以下と等価
@@ -59,3 +65,4 @@ int main() {
 
 ## 参照
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [LWG Issue 3472. `counted_iterator` is missing preconditions](https://cplusplus.github.io/LWG/issue3472)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-integer-like -- is-integer-like : LWG Issue 3467対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/is_integer_like.html"/>
      <id>de0c9736b7f9437a97e28ff42a14f4ffd2ef970a:reference/iterator/is_integer_like.md</id>
      <updated>2021-02-26T15:34:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/is_integer_like.md b/reference/iterator/is_integer_like.md
index 7099dcf45..b4774a8d8 100644
--- a/reference/iterator/is_integer_like.md
+++ b/reference/iterator/is_integer_like.md
@@ -22,8 +22,8 @@ namespace std {
 
 ## 効果
 
-`is-integer-like&amp;lt;T&amp;gt;`は`T`が[`integral`](/reference/concepts/integral.md)のモデルとなるか*integer-class*である時に`true`を示す。  
-`is-signed-integer-like&amp;lt;T&amp;gt;`は`T`が[`signed_integral`](/reference/concepts/signed_integral.md)のモデルとなるか*signed-integer-class*である時に`true`を示す。
+`is-integer-like&amp;lt;T&amp;gt;`は`T`が[`integral`](/reference/concepts/integral.md)のモデルとなるか*integer-class*である時に`true`を示す。ただし、`T`が`bool`かそのCV修飾された型である場合は常に`false`となる。  
+`is-signed-integer-like&amp;lt;T&amp;gt;`は`T`が`integer-like`（`is-integer-like&amp;lt;T&amp;gt; == true`）であり、[`signed_integral`](/reference/concepts/signed_integral.md)のモデルとなるか*signed-integer-class*である時に`true`を示す。
 
 ## (signed-)integer-class型
 
@@ -66,3 +66,4 @@ namespace std {
 ## 参照
 
 - [P1522R1 Iterator Difference Type and Integer Overflow](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1522r1.pdf)
+- [LWG Issue 3467. bool can&amp;#39;t be an integer-like type](https://cplusplus.github.io/LWG/issue3467)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>