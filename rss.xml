<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-22T14:48:08.793329</updated>
  <id>ca44d363-9119-44e6-ae21-7b354a05f362</id>

  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/deque/deque/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/erase_free.md b/reference/deque/deque/erase_free.md
index 5ed9fec9a..6c95c90d4 100644
--- a/reference/deque/deque/erase_free.md
+++ b/reference/deque/deque/erase_free.md
@@ -7,7 +7,11 @@
 ```cpp
 namespace std {
   template &amp;lt;class T, class Allocator, class U&amp;gt;
-  typename deque&amp;lt;T, Allocator&amp;gt;::size_type erase(deque&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+  typename deque&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(deque&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++20
+  template &amp;lt;class T, class Allocator, class U = T&amp;gt;
+  typename deque&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(deque&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++26
 }
 ```
 
@@ -35,7 +39,18 @@ return r;
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::deque&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; d;
+        erase(d, {}); // 空の要素を削除
+        erase(d, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;deque&amp;gt;
@@ -54,13 +69,39 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 5
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;deque&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::deque&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; d = {
+    {1, 2, 3},
+    {4, 5, 6},
+    {},
+    {7, 8}
+  };
+
+  std::erase(d, {}); // 空の要素を削除
+  std::erase(d, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+
+  std::println(&amp;#34;{}&amp;#34;, d);
+}
+```
+
+#### 出力
+```
+[[4, 5, 6], [7, 8]]
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -74,3 +115,5 @@ int main()
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/forward_list/forward_list/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/erase_free.md b/reference/forward_list/forward_list/erase_free.md
index 9e8ca2134..b6b6ffc18 100644
--- a/reference/forward_list/forward_list/erase_free.md
+++ b/reference/forward_list/forward_list/erase_free.md
@@ -7,7 +7,11 @@
 ```cpp
 namespace std {
   template &amp;lt;class T, class Allocator, class U&amp;gt;
-  typename forward_list&amp;lt;T, Allocator&amp;gt;::size_type erase(forward_list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+  typename forward_list&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(forward_list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++20
+  template &amp;lt;class T, class Allocator, class U = T&amp;gt;
+  typename forward_list&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(forward_list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++26
 }
 ```
 
@@ -28,7 +32,18 @@ erase_if(c, [&amp;amp;](auto&amp;amp; elem) { return elem == value; });
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::forward_list&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; ls;
+        erase(ls, {}); // 空の要素を削除
+        erase(ls, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;forward_list&amp;gt;
@@ -47,13 +62,39 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 5
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;forward_list&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::forward_list&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; ls = {
+    {1, 2, 3},
+    {4, 5, 6},
+    {},
+    {7, 8}
+  };
+
+  std::erase(ls, {}); // 空の要素を削除
+  std::erase(ls, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+
+  std::println(&amp;#34;{}&amp;#34;, ls);
+}
+```
+
+#### 出力
+```
+[[4, 5, 6], [7, 8]]
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -67,3 +108,5 @@ int main()
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/list/list/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/list/list/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/erase_free.md b/reference/list/list/erase_free.md
index 8f1c859cf..004e672b9 100644
--- a/reference/list/list/erase_free.md
+++ b/reference/list/list/erase_free.md
@@ -7,7 +7,11 @@
 ```cpp
 namespace std {
   template &amp;lt;class T, class Allocator, class U&amp;gt;
-  typename list&amp;lt;T, Allocator&amp;gt;::size_type erase(list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+  typename list&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++20
+  template &amp;lt;class T, class Allocator, class U = T&amp;gt;
+  typename list&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(list&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value); // (1) C++26
 }
 ```
 
@@ -28,7 +32,18 @@ erase_if(c, [&amp;amp;](auto&amp;amp; elem) { return elem == value; });
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::list&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; ls;
+        erase(ls, {}); // 空の要素を削除
+        erase(ls, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;list&amp;gt;
@@ -47,13 +62,39 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 5
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;list&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::list&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; ls = {
+    {1, 2, 3},
+    {4, 5, 6},
+    {},
+    {7, 8}
+  };
+
+  std::erase(ls, {}); // 空の要素を削除
+  std::erase(ls, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+
+  std::println(&amp;#34;{}&amp;#34;, ls);
+}
+```
+
+#### 出力
+```
+[[4, 5, 6], [7, 8]]
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -67,3 +108,5 @@ int main()
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/string/basic_string/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/erase_free.md b/reference/string/basic_string/erase_free.md
index 35d7ec1a3..dfc18ebac 100644
--- a/reference/string/basic_string/erase_free.md
+++ b/reference/string/basic_string/erase_free.md
@@ -8,7 +8,10 @@
 namespace std {
   template &amp;lt;class CharT, class Traits, class Allocator, class U&amp;gt;
   constexpr typename basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;::size_type
-    erase(basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+    erase(basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);   // (1) C++20
+  template &amp;lt;class CharT, class Traits, class Allocator, class U = CharT&amp;gt;
+  constexpr typename basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;::size_type
+    erase(basic_string&amp;lt;CharT, Traits, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);   // (1) C++26
 }
 ```
 
@@ -36,7 +39,17 @@ return r;
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        erase(s, {});    // ヌル文字&amp;#39;\0&amp;#39;を削除
+        erase(s, {&amp;#39;a&amp;#39;}); // 文字&amp;#39;a&amp;#39;を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;string&amp;gt;
@@ -53,11 +66,33 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 HelloWorld
 ```
 
+### 波カッコ初期化を入力文字として使用する (C++26)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main() {
+  const char ar[] = &amp;#34;hel\0lo&amp;#34;;
+  std::string s(ar, ar + sizeof(ar));
+
+  std::erase(s, {});
+  std::erase(s, {&amp;#39;l&amp;#39;});
+
+  std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
+}
+```
+
+#### 出力
+```
+heo
+```
+
+
 ## バージョン
 ### 言語
 - C++20
@@ -71,3 +106,5 @@ HelloWorld
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase (非メンバ関数) -- コンテナのstd::erase : C++26の波カッコ初期化対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector/erase_free.html"/>
      <id>e36b137e8a237c71b7a03306148cc7b44ed405e8:reference/vector/vector/erase_free.md</id>
      <updated>2025-05-22T23:44:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector/erase_free.md b/reference/vector/vector/erase_free.md
index 81a12080a..82a5411ff 100644
--- a/reference/vector/vector/erase_free.md
+++ b/reference/vector/vector/erase_free.md
@@ -8,7 +8,10 @@
 namespace std {
   template &amp;lt;class T, class Allocator, class U&amp;gt;
   constexpr typename vector&amp;lt;T, Allocator&amp;gt;::size_type
-    erase(vector&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);
+    erase(vector&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);  // (1) C++20
+  template &amp;lt;class T, class Allocator, class U = T&amp;gt;
+  constexpr typename vector&amp;lt;T, Allocator&amp;gt;::size_type
+    erase(vector&amp;lt;T, Allocator&amp;gt;&amp;amp; c, const U&amp;amp; value);  // (1) C++26
 }
 ```
 
@@ -36,7 +39,18 @@ return r;
 削除した要素数を返す。
 
 
+## 備考
+- (1) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; v;
+        erase(v, {}); // 空の要素を削除
+        erase(v, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -55,13 +69,38 @@ int main()
 ```
 * std::erase[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 5
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; v = {
+    {1, 2, 3},
+    {4, 5, 6},
+    {},
+    {7, 8}
+  };
+
+  std::erase(v, {}); // 空の要素を削除
+  std::erase(v, {1, 2, 3}); // 値{1, 2, 3}をもつ要素を削除
+
+  std::println(&amp;#34;{}&amp;#34;, v);
+}
+```
+
+#### 出力
+```
+[[4, 5, 6], [7, 8]]
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -75,3 +114,5 @@ int main()
 ## 参照
 - [P1209R0 Adopt consistent container erasure from Library Fundamentals 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1209r0.html)
 - [R1115R3 Improving the Return Value of Erase-Like Algorithms II: Free `erase`/`erase_if`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1115r3.pdf)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/cmath/abs.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/cmath/abs.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/abs.md b/reference/cmath/abs.md
index 8ae5febb3..52d2b8bda 100644
--- a/reference/cmath/abs.md
+++ b/reference/cmath/abs.md
@@ -45,12 +45,12 @@ namespace std {
 ## 戻り値
 引数 `x` の絶対値を返す。
 
-- (1),(2),(3),(4) : `x` が `±∞` だった場合 `+∞` を返す。
+- (1), (2), (3), (4) : `x` が `±∞` だった場合 `+∞` を返す。
 
 
 ## 備考
 - $$ f(x) = | x | $$
-- 任意の整数型に対するオーバーロード(5)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(6),(7),(8)が追加された
+- 任意の整数型に対するオーバーロード(5)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(6), (7), (8)が追加された
 - C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/condition_variable/condition_variable_any/wait.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait.md b/reference/condition_variable/condition_variable_any/wait.md
index 3694af8c1..32a396579 100644
--- a/reference/condition_variable/condition_variable_any/wait.md
+++ b/reference/condition_variable/condition_variable_any/wait.md
@@ -65,7 +65,7 @@ return pred();
 
 
 ## 戻り値
-- (1),(2) : なし
+- (1), (2) : なし
 - (3) : 停止要求の有無によらず、`pred()`の結果が返る。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/cstdlib/abs.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/cstdlib/abs.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdlib/abs.md b/reference/cstdlib/abs.md
index ad61f0b6a..a9bbede8c 100644
--- a/reference/cstdlib/abs.md
+++ b/reference/cstdlib/abs.md
@@ -59,7 +59,7 @@ namespace std {
 ## 戻り値
 引数 `j` の絶対値を返す。
 
-- (4),(5),(6),(7) : `j` が `±∞` だった場合 `+∞` を返す。
+- (4), (5), (6), (7) : `j` が `±∞` だった場合 `+∞` を返す。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected.void/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/expected/expected.void/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected.void/op_constructor.md b/reference/expected/expected.void/op_constructor.md
index 84266a193..494caea13 100644
--- a/reference/expected/expected.void/op_constructor.md
+++ b/reference/expected/expected.void/op_constructor.md
@@ -198,7 +198,7 @@ int main()
     // ムーブ後のstd::unique_ptr型はnullptrが保証される
   }
 
-  // (6),(7) エラー値の変換コピー／ムーブ構築
+  // (6), (7) エラー値の変換コピー／ムーブ構築
   {
     std::unexpected&amp;lt;IntPair&amp;gt; src1{std::in_place, 1, 2};
     std::expected&amp;lt;void, IntTuple&amp;gt; dst1 = src1;
@@ -217,7 +217,7 @@ int main()
     assert(x1.has_value());
   }
 
-  // (9),(10) 引数リストからエラー値を直接構築
+  // (9), (10) 引数リストからエラー値を直接構築
   {
     std::expected&amp;lt;void, ComplexType&amp;gt; x1{std::unexpect, &amp;#34;C++&amp;#34;, 1};
     assert(not x1.has_value());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/expected/expected/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected/op_constructor.md b/reference/expected/expected/op_constructor.md
index 43c739071..96418b457 100644
--- a/reference/expected/expected/op_constructor.md
+++ b/reference/expected/expected/op_constructor.md
@@ -255,7 +255,7 @@ int main()
     assert(*dst2.value() == 42);
   }
 
-  // (7),(8) エラー値の変換コピー／ムーブ構築
+  // (7), (8) エラー値の変換コピー／ムーブ構築
   {
     std::unexpected&amp;lt;IntPair&amp;gt; src1{std::in_place, 1, 2};
     std::expected&amp;lt;int, IntTuple&amp;gt; dst1 = src1;
@@ -268,7 +268,7 @@ int main()
     assert(*dst2.error() == 42);
   }
 
-  // (9),(10) 引数リストから正常値を直接構築
+  // (9), (10) 引数リストから正常値を直接構築
   {
     std::expected&amp;lt;ComplexType, int&amp;gt; x1{std::in_place, &amp;#34;C++&amp;#34;, 1};
     assert(x1.has_value());
@@ -281,7 +281,7 @@ int main()
     assert((x2.value().seq == std::vector&amp;lt;int&amp;gt;{5, 6, 7, 8}));
   }
 
-  // (11),(12) 引数リストからエラー値を直接構築
+  // (11), (12) 引数リストからエラー値を直接構築
   {
     std::expected&amp;lt;int, ComplexType&amp;gt; x1{std::unexpect, &amp;#34;Hello!&amp;#34;, 4};
     assert(not x1.has_value());
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/expected/unexpected/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/expected/unexpected/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/unexpected/op_constructor.md b/reference/expected/unexpected/op_constructor.md
index 02406bb5d..1b8373301 100644
--- a/reference/expected/unexpected/op_constructor.md
+++ b/reference/expected/unexpected/op_constructor.md
@@ -109,7 +109,7 @@ int main()
     // ムーブ後のstd::unique_ptr型はnullptrが保証される
   }
 
-  // (4),(5) 引数リストから直接構築
+  // (4), (5) 引数リストから直接構築
   {
     std::unexpected&amp;lt;ComplexType&amp;gt; x1{std::in_place, &amp;#34;C++&amp;#34;, 1};
     assert(x1.error().data == &amp;#34;C&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format_to -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/format/format_to.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/format/format_to.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format_to.md b/reference/format/format_to.md
index 03cc3bc5c..2cd9f2489 100644
--- a/reference/format/format_to.md
+++ b/reference/format/format_to.md
@@ -51,15 +51,15 @@ format_to(back_inserter(buffer), &amp;#34;The answer is {}.&amp;#34;, 42);
 
 `Out`は以下の制約を満たす。
 
-* (1),(3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
-* (2),(4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
+* (1), (3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
+* (2), (4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
 
 ## 事前条件
 
 `Out`は以下のコンセプトのモデルである。
 
-* (1),(3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
-* (2),(4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
+* (1), (3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
+* (2), (4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
 
 ## 効果
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>vformat_to -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/format/vformat_to.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/format/vformat_to.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/vformat_to.md b/reference/format/vformat_to.md
index dd565dd0d..e14207425 100644
--- a/reference/format/vformat_to.md
+++ b/reference/format/vformat_to.md
@@ -42,15 +42,15 @@ namespace std {
 
 `Out`は以下の制約を満たす。
 
-* (1),(3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
-* (2),(4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
+* (1), (3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
+* (2), (4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
 
 ## 事前条件
 
 `out`は以下の制約を満たす型の有効なオブジェクトである。
 
-* (1),(3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
-* (2),(4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
+* (1), (3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
+* (2), (4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
 
 ## 効果
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>splice_after -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/splice_after.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/forward_list/forward_list/splice_after.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/splice_after.md b/reference/forward_list/forward_list/splice_after.md
index ecb33dfab..20677d81e 100644
--- a/reference/forward_list/forward_list/splice_after.md
+++ b/reference/forward_list/forward_list/splice_after.md
@@ -35,9 +35,9 @@ void splice_after(const_iterator position, forward_list&amp;amp;&amp;amp; x,
 
 
 ## 効果
-- (1),(2) : `position`の指す要素の後ろに、`x`の全ての要素を移動する
-- (3),(4) : `position`の指す要素の後ろに、`x`の要素のうち`i`の次の要素を移動する
-- (5),(6) : `position`の指す要素の後ろに、`x`の要素のうち`(first, last)`の範囲を移動する
+- (1), (2) : `position`の指す要素の後ろに、`x`の全ての要素を移動する
+- (3), (4) : `position`の指す要素の後ろに、`x`の要素のうち`i`の次の要素を移動する
+- (5), (6) : `position`の指す要素の後ろに、`x`の要素のうち`(first, last)`の範囲を移動する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>yield_value -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/generator/generator/promise_type/yield_value.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/generator/generator/promise_type/yield_value.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/generator/generator/promise_type/yield_value.md b/reference/generator/generator/promise_type/yield_value.md
index 51bcb800f..ca95b2820 100644
--- a/reference/generator/generator/promise_type/yield_value.md
+++ b/reference/generator/generator/promise_type/yield_value.md
@@ -90,7 +90,7 @@ return yield_value(ranges::elements_of(nested(
 
 
 ## 例外
-- (1),(3),(4) : 投げない。
+- (1), (3), (4) : 投げない。
 - (2) : 格納されるオブジェクトの初期化によって送出された例外。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/queue/queue/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/queue/queue/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/queue/queue/op_constructor.md b/reference/queue/queue/op_constructor.md
index 0dfe840c6..4596320db 100644
--- a/reference/queue/queue/op_constructor.md
+++ b/reference/queue/queue/op_constructor.md
@@ -6,11 +6,11 @@
 
 ```cpp
 // C++03まで
-explicit queue(const Container&amp;amp; other = Container());  // (1),(2)
+explicit queue(const Container&amp;amp; other = Container());  // (1), (2)
 
 // C++11以降 C++17まで
 explicit queue(const Container&amp;amp; other);           // (2)
-explicit queue(Container&amp;amp;&amp;amp; other = Container());  // (1),(3)
+explicit queue(Container&amp;amp;&amp;amp; other = Container());  // (1), (3)
 
 // C++20以降
 queue() : queue(Container()) {}          // (1)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/stack/stack/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/stack/stack/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stack/stack/op_constructor.md b/reference/stack/stack/op_constructor.md
index 14b0c8d2f..f173b91ca 100644
--- a/reference/stack/stack/op_constructor.md
+++ b/reference/stack/stack/op_constructor.md
@@ -6,11 +6,11 @@
 
 ```cpp
 // C++03まで
-explicit stack(const Container&amp;amp; cont = Container());  // (1),(2)
+explicit stack(const Container&amp;amp; cont = Container());  // (1), (2)
 
 // C++11以降 C++17まで
 explicit stack(const Container&amp;amp; cont);           // (2)
-explicit stack(Container&amp;amp;&amp;amp; cont = Container());  // (1),(3)
+explicit stack(Container&amp;amp;&amp;amp; cont = Container());  // (1), (3)
 
 // C++20以降
 stack() : stack(Container()) {}    // (1)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 全体: オーバーロード番号の列挙を「(1),(2)」になっているものから「(1), (2)」の形式に変更 #1451</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_constructor.html"/>
      <id>003bb897a82f0e7946d76abc1da6eb2f3f3e0e03:reference/string/basic_string/op_constructor.md</id>
      <updated>2025-05-22T17:27:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_constructor.md b/reference/string/basic_string/op_constructor.md
index 5bf500824..b0a95566d 100644
--- a/reference/string/basic_string/op_constructor.md
+++ b/reference/string/basic_string/op_constructor.md
@@ -268,4 +268,4 @@ s14 : Hello
 - [P2166R1 A Proposal to Prohibit std::basic_string and std::basic_string_view construction from nullptr.](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2166r1.html)
     - C++23での(16)`nullptr_t`をとるコンストラクタのdelete宣言追加
 - [P2438R2 `std::string::substr() &amp;amp;&amp;amp;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2438r2.html)
-    - C++23での(17),(18)`basic_string&amp;amp;&amp;amp;`と範囲指定をとるコンストラクタ追加
+    - C++23での(17), (18)`basic_string&amp;amp;&amp;amp;`と範囲指定をとるコンストラクタ追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bucket -- unordered_(multi)set::bucket : C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/bucket.html"/>
      <id>9bcd535b0cb4a69bb29748b0a10fa83c8b58ac20:reference/unordered_set/unordered_multiset/bucket.md</id>
      <updated>2025-05-22T16:22:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/bucket.md b/reference/unordered_set/unordered_multiset/bucket.md
index d970e5566..165c9ec60 100644
--- a/reference/unordered_set/unordered_multiset/bucket.md
+++ b/reference/unordered_set/unordered_multiset/bucket.md
@@ -6,20 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-size_type bucket(const key_type&amp;amp; k) const;
+size_type bucket(const key_type&amp;amp; k) const; // (1) C++11
+
+template &amp;lt;class K&amp;gt;
+size_type bucket(const K&amp;amp; k) const;        // (2) C++26
 ```
 
 ## 概要
 指定したキーと等価な要素が格納されている場合、そのバケットのインデックス（添え字）を取得する。
 
+- (1) : `key_type`型のキーを受け取って、バケットのインデックスを取得する
+- (2) : `key_type`と比較可能なキーを受け取って、バケットのインデックスを取得する
+
+
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent` が妥当な式であること
 
-## 要件
+
+## 事前条件
 当該コンテナは [`bucket_count`](bucket_count.md)`() &amp;gt; 0` であること
 
 
 ## 戻り値
 パラメータ `k` と等価なキーの要素が格納されているバケットのインデックス（添え字）
 
+
+## 事後条件
 戻り値は `[0,` [`bucket_count`](bucket_count.md)`())` の範囲である。
 
 
@@ -28,7 +40,10 @@ size_type bucket(const key_type&amp;amp; k) const;
 
 
 ## 備考
-指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- 指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -94,3 +109,6 @@ key = H, bucket = 3, bucket_size = 0
 |----------------------------------------------|----------------------|
 | [`max_bucket_count`](max_bucket_count.md)  | 最大バケット数の取得 |
 
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bucket -- unordered_(multi)set::bucket : C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/bucket.html"/>
      <id>9bcd535b0cb4a69bb29748b0a10fa83c8b58ac20:reference/unordered_set/unordered_set/bucket.md</id>
      <updated>2025-05-22T16:22:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/bucket.md b/reference/unordered_set/unordered_set/bucket.md
index c8c990ed4..a7d2700cb 100644
--- a/reference/unordered_set/unordered_set/bucket.md
+++ b/reference/unordered_set/unordered_set/bucket.md
@@ -6,20 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-size_type bucket(const key_type&amp;amp; k) const;
+size_type bucket(const key_type&amp;amp; k) const; // (1) C++11
+
+template &amp;lt;class K&amp;gt;
+size_type bucket(const K&amp;amp; k) const;        // (2) C++26
 ```
 
 ## 概要
 指定したキーと等価な要素が格納されている場合、そのバケットのインデックス（添え字）を取得する。
 
+- (1) : `key_type`型のキーを受け取って、バケットのインデックスを取得する
+- (2) : `key_type`と比較可能なキーを受け取って、バケットのインデックスを取得する
+
+
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent` が妥当な式であること
 
-## 要件
+
+## 事前条件
 当該コンテナは [`bucket_count`](bucket_count.md)`() &amp;gt; 0` であること
 
 
 ## 戻り値
 パラメータ `k` と等価なキーの要素が格納されているバケットのインデックス（添え字）
 
+
+## 事後条件
 戻り値は `[0,` [`bucket_count`](bucket_count.md)`())` の範囲である。
 
 
@@ -28,7 +40,10 @@ size_type bucket(const key_type&amp;amp; k) const;
 
 
 ## 備考
-指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- 指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -85,8 +100,10 @@ key = H, bucket = 2, bucket_size = 0
 
 ## 関連項目
 
-
 | 名前 | 説明 |
 |-------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------|
 | [`max_bucket_count`](max_bucket_count.md) | 最大バケット数の取得 |
 
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- unordered_set::insert : C++26異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/set/set/insert.html"/>
      <id>6216138ce74cd31f4d2b8567733a769fc9f5f320:reference/set/set/insert.md</id>
      <updated>2025-05-22T16:18:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/insert.md b/reference/set/set/insert.md
index 5310bb901..180fb3d7a 100644
--- a/reference/set/set/insert.md
+++ b/reference/set/set/insert.md
@@ -37,10 +37,10 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (10) C++17
 
 - (1) : 新たな要素`x`をコピー挿入する
 - (2) : 新たな要素`y`をムーブ挿入する
-- (3) : `value_type`に変換可能な`Key`型の新たな要素`x`を転送して挿入する
+- (3) : `value_type`に変換可能な`K`型の新たな要素`x`を転送して挿入する
 - (4) : 新たな要素`x`をコピー挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
 - (5) : 新たな要素`y`をムーブ挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
-- (6) : `value_type`に変換可能な`Key`型の新たな要素`x`を転送して挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (6) : `value_type`に変換可能な`K`型の新たな要素`x`を転送して挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
 - (7) : イテレータ範囲`[first, last)`の要素を挿入する
 - (8) : 初期化子リスト`init`の要素を挿入する
 - (9) : `nh`が空の場合、効果はない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- unordered_set::insert : C++26異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html"/>
      <id>6216138ce74cd31f4d2b8567733a769fc9f5f320:reference/unordered_set/unordered_set/insert.md</id>
      <updated>2025-05-22T16:18:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/insert.md b/reference/unordered_set/unordered_set/insert.md
index 0db8c87cf..6aaa0be13 100644
--- a/reference/unordered_set/unordered_set/insert.md
+++ b/reference/unordered_set/unordered_set/insert.md
@@ -6,19 +6,40 @@
 * cpp11[meta cpp]
 
 ```cpp
-pair&amp;lt;iterator, bool&amp;gt; insert(const value_type&amp;amp; v);              // (1) C++11
-pair&amp;lt;iterator, bool&amp;gt; insert(value_type&amp;amp;&amp;amp; rv);                  // (2) C++11
-
-iterator insert(const_iterator position, const value_type&amp;amp; v); // (3) C++11
-iterator insert(const_iterator position, value_type&amp;amp;&amp;amp; rv);     // (4) C++11
+pair&amp;lt;iterator, bool&amp;gt;
+  insert(const value_type&amp;amp; v);             // (1) C++11
+pair&amp;lt;iterator, bool&amp;gt;
+  insert(value_type&amp;amp;&amp;amp; rv);                 // (2) C++11
+
+template &amp;lt;class K&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  insert(K&amp;amp;&amp;amp; x);                           // (3) C++26
+
+iterator
+  insert(const_iterator position,
+         const value_type&amp;amp; v);             // (4) C++11
+iterator
+  insert(const_iterator position,
+         value_type&amp;amp;&amp;amp; rv);                 // (5) C++11
+
+template &amp;lt;class K&amp;gt;
+iterator
+  insert(const_iterator hint,
+         K&amp;amp;&amp;amp; x);                           // (6) C++11
 
 template &amp;lt;class InputIterator&amp;gt;
-void insert(InputIterator first, InputIterator last);          // (5) C++11
-
-void insert(initializer_list&amp;lt;value_type&amp;gt; il);                  // (6) C++11
-
-insert_return_type insert(node_type&amp;amp;&amp;amp; nh);                     // (7) C++17
-iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
+void
+  insert(InputIterator first,
+         InputIterator last);              // (7) C++11
+
+void
+  insert(initializer_list&amp;lt;value_type&amp;gt; il); // (8) C++11
+
+insert_return_type
+  insert(node_type&amp;amp;&amp;amp; nh);                  // (9) C++17
+iterator
+  insert(const_iterator hint,
+         node_type&amp;amp;&amp;amp; nh);                  // (10) C++17
 ```
 * pair[link /reference/utility/pair.md]
 * initializer_list[link /reference/initializer_list/initializer_list.md]
@@ -28,57 +49,67 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 - (1) : 新たな要素`v`をコピー挿入する
 - (2) : 新たな要素`rv`をムーブ挿入する
-- (3) : 新たな要素`v`をコピー挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
-- (4) : 新たな要素`rv`をムーブ挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
-- (5) : イテレータ範囲`[first, last)`の要素を挿入する
-- (6) : 初期化子リスト`il`の要素を挿入する
-- (7) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
-- (8) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。 `nh.key()`と同等のキーの要素を指すイテレータを常に返す。要素は、`hint`の直前の位置のできるだけ近くに挿入される。
+- (3) : `value_type`に変換可能な`K`型の新たな要素`x`を転送して挿入する
+- (4) : 新たな要素`v`をコピー挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (5) : 新たな要素`rv`をムーブ挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (6) : `value_type`に変換可能な`K`型の新たな要素`x`を転送して挿入する。`hint`パラメータに適切な挿入位置を指定すれば、高速に挿入できる
+- (7) : イテレータ範囲`[first, last)`の要素を挿入する
+- (8) : 初期化子リスト`il`の要素を挿入する
+- (9) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
+- (10) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。 `nh.key()`と同等のキーの要素を指すイテレータを常に返す。要素は、`hint`の直前の位置のできるだけ近くに挿入される。
+
+
+## テンプレートパラメータ制約
+- (3), (6) :
+    - `key_compare::is_transparent` が妥当な式であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`であること
+    - `value_type`が[`std::forward`](/reference/utility/forward.md)`&amp;lt;K&amp;gt;(x)`によって直接構築可能であること
 
 
 ## 適格要件
-- (1)、(3) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。
+- (1)、(4) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。
     - コンテナに対してコピー挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
         - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
-- (2)、(4) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。
+- (2)、(5) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。
     - コンテナに対してムーブ挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
         - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
-- (3)、(4) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。
+- (4)、(5) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。
     - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
-- (5) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。
+- (7) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。
     - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。
     - ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
         - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, *first);`
     - なお、`first`、および、`last`は、標準では `value_type` を参照しなければならない（つまり、コンテナの `value_type` と `std::`[`iterator_traits`](/reference/iterator/iterator_traits.md)`&amp;lt;decltype(first)&amp;gt;::value_type` が同一の型でなければならない）ことになっているが、実際にはその必要はなく、上記の直接構築可能の要件を満たすだけで良いものと思われる。
-- (6) : `value_type` はコンテナに対してコピー挿入可能でなければならない。
+- (8) : `value_type` はコンテナに対してコピー挿入可能でなければならない。
 
 
 ## 事前条件
-- (5), (6) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`でなければならない。
+- (9), (10) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`でなければならない。
 
 
 ## 効果
-- (1)、(2) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
-- (3)、(4) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
+- (1)、(2)、(3) : 引数で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
+- (4)、(5)、(6) : 第1引数で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
     - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
-- (5) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
-- (6) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
-- (7) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
-- (8) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。`nh.key()`と等価のキーの要素を指すイテレータを常に返す。
+- (7) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
+- (8) : (7)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
+- (9) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
+- (10) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。`nh.key()`と等価のキーの要素を指すイテレータを常に返す。
     - 要素は、`hint`の直前の位置のできるだけ近くに挿入される。
 
 
 ## 戻り値
-- (1)、(2) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。
+- (1)、(2)、(3) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。
     - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
-- (3)、(4) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。
+- (4)、(5)、(6) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。
     - 新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
-- (5) : なし
-- (6) : なし
-- (7) : 戻り値としては、[`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
+- (7) : なし
+- (8) : なし
+- (9) : 戻り値としては、[`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
     - 挿入された場合には、空の[ノードハンドル](/reference/node_handle/node_handle.md)。
     - 挿入されなかった場合には、`nh`の値である。 
-- (8) : `nh`が空の場合、`(*this).end()`を返す。そうではない場合、`nh`と等価のキーの要素を指すイテレータを常に返す。
+- (10) : `nh`が空の場合、`(*this).end()`を返す。そうではない場合、`nh`と等価のキーの要素を指すイテレータを常に返す。
 
 
 ## 例外
@@ -86,11 +117,11 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 
 ## 計算量
-- (1)、(2) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
-- (3)、(4) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
-- (5) : 平均的なケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` に比例（O(N)）するが、最悪のケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` とコンテナの要素数 [`size()`](size.md) に 1 加えたものの積に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last) * (`[`size`](size.md)`() + 1)`)）。
-- (6) : (4)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価。
-- (7), (8) : 平均的なケースでは `O(1)`、最悪のケースでは `O(size())`。
+- (1)、(2)、(3) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
+- (4)、(5)、(6) : 平均的なケースでは定数（O(1)）だが、最悪のケースではコンテナの要素数 [`size`](size.md)`()` に比例（O(N)）。
+- (7) : 平均的なケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` に比例（O(N)）するが、最悪のケースでは引数の範囲の要素数 `std::`[`distance`](/reference/iterator/distance.md)`(first, last)` とコンテナの要素数 [`size()`](size.md) に 1 加えたものの積に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last) * (`[`size`](size.md)`() + 1)`)）。
+- (8) : (7)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価。
+- (9), (10) : 平均的なケースでは `O(1)`、最悪のケースでは `O(size())`。
 
 
 ## 備考
@@ -102,7 +133,10 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
         - 追加しようとした要素と等価なキーの要素が全て既にコンテナに存在したため、要素が追加されなかった。
         - 要素追加後の要素数が、要素追加前のバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）×最大負荷率（[`max_load_factor`](max_load_factor.md)`()` の戻り値）よりも小さかった。
     - なお、後者の条件は「よりも小さい」となっているが、最大負荷率の定義からすると「以下」の方が適切と思われる。[`reserve`](reserve.md) も参照。
-- (7), (8) の場合、要素はコピーもムーブもされない。
+- (9), (10) の場合、要素はコピーもムーブもされない。
+- (3), (6) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -126,7 +160,7 @@ int main()
 {
   std::cout &amp;lt;&amp;lt; std::boolalpha;
 
-  // 一つの要素を挿入（(1)、(2)の形式）
+  // 一つの要素を挿入（(1)、(2)、(3)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -137,7 +171,7 @@ int main()
     print(&amp;#34;insert one element&amp;#34;, us);
   }
 
-  // 一つの要素を挿入（(3)、(4)の形式）
+  // 一つの要素を挿入（(4)、(5)、(6)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -148,7 +182,7 @@ int main()
     print(&amp;#34;insert one element with hint&amp;#34;, us);
   }
 
-  // 複数の要素を挿入（(5)の形式）
+  // 複数の要素を挿入（(7)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -157,7 +191,7 @@ int main()
     print(&amp;#34;insert range&amp;#34;, us);
   }
 
-  // 複数の要素を挿入（(6)の形式）
+  // 複数の要素を挿入（(8)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 0, 1, 2, 3, 4, 5, };
 
@@ -199,7 +233,7 @@ insert initializer_list : 7 8 6 5 4 3 2 1 0
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 ## 実装例
-(3)、(4)、(5)、(6)の形式は、(1)、(2)の形式を使って実装することができる。
+(4)、(5)、(7)、(8)の形式は、(1)、(2)の形式を使って実装することができる。
 
 ```cpp
 template &amp;lt;class Key, class Hash, class Pred, class Allocator&amp;gt;
@@ -253,7 +287,9 @@ inline void unordered_set&amp;lt;Key, Hash, Pred, Allocator&amp;gt;::insert(initializer_list&amp;lt;K
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
 - [N2679 Initializer Lists for Standard Containers(Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2679.pdf)
-    - (6)の経緯となる提案文書
+    - (8)の経緯となる提案文書
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-    - (7), (7)経緯となる提案文書
+    - (9), (10)経緯となる提案文書
 - [How useful is the hint passed to the std::unordered_... collections? - The Old New Thing](https://devblogs.microsoft.com/oldnewthing/20241028-00/?p=110428)
+- [P2363R5: Extending associative containers with the remaining heterogeneous overloads](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- インデントを再修正</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html"/>
      <id>0ff1c70cff068a5069c9a2f51a7727e763055e1e:reference/unordered_set/unordered_set/insert.md</id>
      <updated>2025-05-22T16:04:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/insert.md b/reference/unordered_set/unordered_set/insert.md
index 29a16a84d..0db8c87cf 100644
--- a/reference/unordered_set/unordered_set/insert.md
+++ b/reference/unordered_set/unordered_set/insert.md
@@ -37,19 +37,19 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 
 ## 適格要件
-- (1)、(3) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。  
+- (1)、(3) : `value_type` はコンテナに対してコピー挿入可能（CopyInsertable）でなければならない。
     - コンテナに対してコピー挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
-- (2)、(4) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。  
+        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, v);`
+- (2)、(4) : `value_type` はコンテナに対してムーブ挿入可能（MoveInsertable）でなければならない。
     - コンテナに対してムーブ挿入可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
-- (3)、(4) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。  
-	   - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
-- (5) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
-	   - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。  
-	   - ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
-	       - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, *first);`
-	   - なお、`first`、および、`last`は、標準では `value_type` を参照しなければならない（つまり、コンテナの `value_type` と `std::`[`iterator_traits`](/reference/iterator/iterator_traits.md)`&amp;lt;decltype(first)&amp;gt;::value_type` が同一の型でなければならない）ことになっているが、実際にはその必要はなく、上記の直接構築可能の要件を満たすだけで良いものと思われる。
+        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, std::`[`move`](/reference/utility/move.md)`(rv));`
+- (3)、(4) : 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。
+    - なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
+- (5) : 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。
+    - また、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。
+    - ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
+        - `std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`construct`](/reference/memory/allocator_traits/construct.md)`(m, p, *first);`
+    - なお、`first`、および、`last`は、標準では `value_type` を参照しなければならない（つまり、コンテナの `value_type` と `std::`[`iterator_traits`](/reference/iterator/iterator_traits.md)`&amp;lt;decltype(first)&amp;gt;::value_type` が同一の型でなければならない）ことになっているが、実際にはその必要はなく、上記の直接構築可能の要件を満たすだけで良いものと思われる。
 - (6) : `value_type` はコンテナに対してコピー挿入可能でなければならない。
 
 
@@ -59,8 +59,8 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 ## 効果
 - (1)、(2) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
-- (3)、(4) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。  
-	   - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
+- (3)、(4) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
+    - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
 - (5) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
 - (6) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
 - (7) : `nh`が空の場合、効果はない。それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
@@ -69,10 +69,10 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 
 ## 戻り値
-- (1)、(2) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。  
-	   - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
-- (3)、(4) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。  
-	新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
+- (1)、(2) : [`pair`](/reference/utility/pair.md) の `bool` 部分（`second` 部）は、要素が追加されたら `true`、追加されなかったら（既にあったら）`false`。
+    - [`pair`](/reference/utility/pair.md) の `iterator` 部分（`first` 部）は、追加された要素（`bool` 部分が `true` の場合）、あるいは、既にあった要素（`bool` 部分が `false` の場合）を指すイテレータ。
+- (3)、(4) : 新たな要素が追加された場合、その追加された要素を指すイテレータ。
+    - 新たな要素が追加されなかった場合、既にあった要素を指すイテレータ。
 - (5) : なし
 - (6) : なし
 - (7) : 戻り値としては、[`insert_return_type`](/reference/map/map.md)を返す。`insert_return_type`のイテレータ型メンバ変数`position`、`bool`型メンバ変数`inserted`に格納される値は(1), (2)のものと同じ情報である。`nh`が空の場合は、`position`は終端イテレータである。`node_type`型メンバ変数`node`には、
@@ -95,13 +95,13 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (8) C++17
 
 ## 備考
 - これらの関数が呼ばれた後も、当該コンテナ内の要素を指す参照は無効にはならない。
-	なお、規格書に明確な記載は無いが、当該コンテナ内の要素を指すポインタも無効にはならない。
-- これらの関数が呼ばれた後も、呼び出しの前後でこのコンテナのバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）が変わらなかった場合には当該コンテナを指すイテレータは無効にはならない。  
-	   - それ以外の場合は、当該コンテナを指すイテレータは無効になる可能性がある。  
-	   - コンテナのバケット数が変わらない場合とは、以下のいずれかである：
-	       - 追加しようとした要素と等価なキーの要素が全て既にコンテナに存在したため、要素が追加されなかった。
-	       - 要素追加後の要素数が、要素追加前のバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）×最大負荷率（[`max_load_factor`](max_load_factor.md)`()` の戻り値）よりも小さかった。
-	   - なお、後者の条件は「よりも小さい」となっているが、最大負荷率の定義からすると「以下」の方が適切と思われる。[`reserve`](reserve.md) も参照。
+    - なお、規格書に明確な記載は無いが、当該コンテナ内の要素を指すポインタも無効にはならない。
+- これらの関数が呼ばれた後も、呼び出しの前後でこのコンテナのバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）が変わらなかった場合には当該コンテナを指すイテレータは無効にはならない。
+    - それ以外の場合は、当該コンテナを指すイテレータは無効になる可能性がある。
+    - コンテナのバケット数が変わらない場合とは、以下のいずれかである：
+        - 追加しようとした要素と等価なキーの要素が全て既にコンテナに存在したため、要素が追加されなかった。
+        - 要素追加後の要素数が、要素追加前のバケット数（[`bucket_count`](bucket_count.md)`()` の戻り値）×最大負荷率（[`max_load_factor`](max_load_factor.md)`()` の戻り値）よりも小さかった。
+    - なお、後者の条件は「よりも小さい」となっているが、最大負荷率の定義からすると「以下」の方が適切と思われる。[`reserve`](reserve.md) も参照。
 - (7), (8) の場合、要素はコピーもムーブもされない。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>