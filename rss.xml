<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-04-20T13:05:41.745375</updated>
  <id>b1bcf444-6e70-49a9-a3a7-87b9c9d493b6</id>

  
    <entry>
      <title>contiguous_iterator -- reference/iterator/contiguous_iterator.md: Added information for contiguous_iterator</title>
      <link href="https://cpprefjp.github.io/reference/iterator/contiguous_iterator.html"/>
      <id>28659acd4e63cb13d247b9bb147b7539c043f0a6:reference/iterator/contiguous_iterator.md</id>
      <updated>2025-04-20T22:01:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/contiguous_iterator.md b/reference/iterator/contiguous_iterator.md
index 712c3e7a7..5a16cc318 100644
--- a/reference/iterator/contiguous_iterator.md
+++ b/reference/iterator/contiguous_iterator.md
@@ -33,6 +33,11 @@ namespace std {
 
 `contiguous_iterator`となるイテレータは、[ランダムアクセスイテレータ](random_access_iterator.md)であり、参照する要素列がメモリ上で連続していることが保証される。
 
+C++20で導入された`contiguous_iterator`は、要素がメモリー上で連続していることを保証しているが、C++23の標準ライブラリ実装では
+得られたポインタに対してさらなるポインタ演算を行う演算は許可されていなかった。
+
+しかし、C++26からは、この制限が緩和され、`std::to_address`関数を使用して得られたポインタに対してさらなるポインタ演算を行うことができるようになった。
+
 ## モデル
 
 `a, b`を間接参照可能なイテレータ、`c`を間接参照不可能なイテレータとし、`b`は`a`から、`c`は`b`からそれぞれ到達可能であるとする。そのような型`I`のイテレータ`a, b, c`と[`iter_difference_t&amp;lt;I&amp;gt;`](/reference/iterator/iter_difference_t.md)の示す型`D`について次の条件を満たす場合に限って、型`I`は`contiguous_iterator`のモデルである。
@@ -109,3 +114,4 @@ std::ostream_iterator&amp;lt;double&amp;gt; is not contiguous_iterator
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P1474R1 Helpful pointers for `ContiguousIterator`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1474r1.pdf)
+- [P3349R1 Converting contiguous iterators to pointers](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3349r1.html)
\ No newline at end of file
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>rotarymars</name>
        <email>s.goto2050@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>constexpr ラムダ [P0170R1] -- 「定数とき」→「定数のとき」</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/constexpr_lambda.html"/>
      <id>9bd96532716d3a0abf4b3f8793229ac61a4c082e:lang/cpp17/constexpr_lambda.md</id>
      <updated>2025-04-20T14:50:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/constexpr_lambda.md b/lang/cpp17/constexpr_lambda.md
index 5a118885d..e4d3a09e3 100644
--- a/lang/cpp17/constexpr_lambda.md
+++ b/lang/cpp17/constexpr_lambda.md
@@ -18,7 +18,7 @@ C++17から、ラムダ式をconstexpr関数として使えるようになった
 
 ## 仕様
 
-ラムダ式のキャプチャが全てコンパイル時定数とき、そのラムダ式をconstexprの文脈で使うことができる。
+ラムダ式のキャプチャが全てコンパイル時定数のとき、そのラムダ式をconstexprの文脈で使うことができる。
 
 ```cpp example
 constexpr int add_one(int n){
@@ -68,7 +68,7 @@ int main(){
 
 constexpr修飾されていないラムダ式のoperator()はラムダ式がconstexpr関数としての条件を満たす場合
 
-（つまりラムダ式のキャプチャが全てコンパイル時定数とき）
+（つまりラムダ式のキャプチャが全てコンパイル時定数のとき）
 
 自動的にconstexpr指定される。
 
@@ -201,4 +201,4 @@ C++14まではラムダ式がコンパイル時に呼び出せないため、
 ## 参照
 
 (執筆中)
-- [P0170R1 Wording for Constexpr Lambda](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0170r1.pdf)
\ No newline at end of file
+- [P0170R1 Wording for Constexpr Lambda](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0170r1.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- execution: schedule_result_t (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>a4fbd160cb9e78a14ada6491c54dd1d9c55dfed6:reference/execution/execution.md</id>
      <updated>2025-04-19T23:32:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index f4b35abe5..9487a1788 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -104,7 +104,7 @@ namespace std::execution {
 | [`execution::just_stopped`](execution/just_stopped.md.nolink) | 停止を送信するSender (customization point object) | C++26 |
 | [`execution::read_env`](execution/read_env.md.nolink) | Receiver環境から構築されるSender (customization point object) | C++26 |
 | [`execution::schedule`](execution/schedule.md) | Scheduler上で実行されるSender (customization point object) | C++26 |
-| [`execution::schedule_result_t`](execution/schedule_result_t.md.nolink) | `schedule`結果型を取得 (alias template) | C++26 |
+| [`execution::schedule_result_t`](execution/schedule_result_t.md) | [`schedule`](execution/schedule.md)結果型を取得 (alias template) | C++26 |
 
 ### Senderアダプタ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>schedule -- execution: schedule_result_t (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/schedule.html"/>
      <id>a4fbd160cb9e78a14ada6491c54dd1d9c55dfed6:reference/execution/execution/schedule.md</id>
      <updated>2025-04-19T23:32:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/schedule.md b/reference/execution/execution/schedule.md
index f7571c0e2..8bd90c80c 100644
--- a/reference/execution/execution/schedule.md
+++ b/reference/execution/execution/schedule.md
@@ -67,6 +67,8 @@ int main()
 * get_scheduler()[link run_loop/get_scheduler.md.nolink]
 * run()[link run_loop/run.md.nolink]
 * finish()[link run_loop/finish.md.nolink]
+* std::move[link /reference/utility/move.md]
+* std::jthread[link /reference/thread/jthread.md]
 * std::this_thread::get_id()[link /reference/thread/this_thread/get_id.md]
 
 ### 出力例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>schedule_result_t -- execution: schedule_result_t (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/schedule_result_t.html"/>
      <id>a4fbd160cb9e78a14ada6491c54dd1d9c55dfed6:reference/execution/execution/schedule_result_t.md</id>
      <updated>2025-04-19T23:32:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/schedule_result_t.md b/reference/execution/execution/schedule_result_t.md
new file mode 100644
index 000000000..663de9f6e
--- /dev/null
+++ b/reference/execution/execution/schedule_result_t.md
@@ -0,0 +1,36 @@
+# schedule_result_t
+* execution[meta header]
+* std::execution[meta namespace]
+* type-alias[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  template&amp;lt;scheduler Sndr&amp;gt;
+  using schedule_result_t = decltype(schedule(declval&amp;lt;Sndr&amp;gt;()));
+}
+```
+* scheduler[link scheduler.md]
+* schedule[link schedule.md]
+
+## 概要
+[Scheduler型](scheduler.md)`Sndr`の[`schedule`](schedule.md)結果型を取得する。
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution::schedule`](schedule.md)
+
+
+## 参照
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution --  execution: schedule (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>08365debe249bdbd6a7347ad462ea1c22e7cc2a8:reference/execution/execution.md</id>
      <updated>2025-04-19T23:04:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index cb5b97bb8..f4b35abe5 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -103,7 +103,7 @@ namespace std::execution {
 | [`execution::just_error`](execution/just_error.md.nolink) | エラーを送信するSender (customization point object) | C++26 |
 | [`execution::just_stopped`](execution/just_stopped.md.nolink) | 停止を送信するSender (customization point object) | C++26 |
 | [`execution::read_env`](execution/read_env.md.nolink) | Receiver環境から構築されるSender (customization point object) | C++26 |
-| [`execution::schedule`](execution/schedule.md.nolink) | Scheduler上で実行されるSender (customization point object) | C++26 |
+| [`execution::schedule`](execution/schedule.md) | Scheduler上で実行されるSender (customization point object) | C++26 |
 | [`execution::schedule_result_t`](execution/schedule_result_t.md.nolink) | `schedule`結果型を取得 (alias template) | C++26 |
 
 ### Senderアダプタ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>schedule --  execution: schedule (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/schedule.html"/>
      <id>08365debe249bdbd6a7347ad462ea1c22e7cc2a8:reference/execution/execution/schedule.md</id>
      <updated>2025-04-19T23:04:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/schedule.md b/reference/execution/execution/schedule.md
new file mode 100644
index 000000000..f7571c0e2
--- /dev/null
+++ b/reference/execution/execution/schedule.md
@@ -0,0 +1,97 @@
+# schedule
+* execution[meta header]
+* cpo[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  struct schedule_t { unspecified };
+  inline constexpr schedule_t schedule{};
+}
+```
+* unspecified[italic]
+
+## 概要
+`schedule`は、[Scheduler](scheduler.md)から[スケジュールSender](sender.md)を取得するSenderファクトリである。
+
+スケジュールSenderより生成される[非同期操作](operation_state.md)を開始すると、Schedulerに関連付けられた実行リソース上で空の[値完了関数](set_value.md)を呼び出す。
+
+
+## 効果
+呼び出し式`schedule(sch)`は式`sch.schedule()`と等価であり、式の型は[`sender`](sender.md)を満たすこと。
+
+式[`get_completion_scheduler`](get_completion_scheduler.md.nolink)`&amp;lt;`[`set_value_t`](set_value.md)`&amp;gt;(`[`get_env`](get_env.md)`(sch.schedule())) == sch`が不適格もしくは`false`となる場合、呼び出し式`schedule(sch)`の動作は未定義となる。
+
+
+## カスタマイゼーションポイント
+[Scheduler](scheduler.md)`sch`に対して、式`sch.schedule()`が呼び出される。
+
+
+## 例
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+int main()
+{
+  ex::run_loop loop;
+  std::jthread worker{[&amp;amp;]{
+    std::println(&amp;#34;start worker#{}&amp;#34;, std::this_thread::get_id());
+    loop.run();
+  }};
+
+  ex::scheduler auto sch = loop.get_scheduler();
+  ex::sender auto sndr =
+    ex::schedule(sch)
+    | ex::then([]{
+      std::println(&amp;#34;on worker#{}&amp;#34;, std::this_thread::get_id());
+      return 42;
+    });
+
+  std::println(&amp;#34;main#{}&amp;#34;, std::this_thread::get_id());
+
+  auto [val] = std::this_thread::sync_wait(std::move(sndr)).value();
+  std::println(&amp;#34;val={}&amp;#34;, val);
+
+  loop.finish();
+}
+```
+* ex::schedule[color ff0000]
+* ex::scheduler[link scheduler.md]
+* ex::sender[link sender.md]
+* ex::then[link then.md.nolink]
+* ex::run_loop[link run_loop.md.nolink]
+* get_scheduler()[link run_loop/get_scheduler.md.nolink]
+* run()[link run_loop/run.md.nolink]
+* finish()[link run_loop/finish.md.nolink]
+* std::this_thread::get_id()[link /reference/thread/this_thread/get_id.md]
+
+### 出力例
+```
+main#134276695947072
+start worker#134276691527232
+on worker#134276691527232
+val=42
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution::scheduler`](scheduler.md)
+
+
+## 参照
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scheduler --  execution: schedule (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/scheduler.html"/>
      <id>08365debe249bdbd6a7347ad462ea1c22e7cc2a8:reference/execution/execution/scheduler.md</id>
      <updated>2025-04-19T23:04:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/scheduler.md b/reference/execution/execution/scheduler.md
index 27ef5307c..427727a05 100644
--- a/reference/execution/execution/scheduler.md
+++ b/reference/execution/execution/scheduler.md
@@ -25,7 +25,7 @@ namespace std::execution {
 * derived_from[link /reference/concepts/derived_from.md]
 * sender[link sender.md]
 * queryable[link ../queryable.md]
-* schedule[link schedule.md.nolink]
+* schedule[link schedule.md]
 * get_completion_scheduler[link get_completion_scheduler.md.nolink]
 * set_value_t[link set_value.md]
 * get_env[link get_env.md]
@@ -40,7 +40,7 @@ namespace std::execution {
 - `scheduler_t`をメンバ型`Sch::scheduler_concept`として定義する
 - [クエリ可能オブジェクト](../queryable.md)である
 - `Sch`型の値`sch`に対して下記を満たすこと
-    - [`execution::schedule`](schedule.md.nolink)`(sch)`が[Sender](sender.md)を返す
+    - [`execution::schedule`](schedule.md)`(sch)`が[Sender](sender.md)を返す
     - 上記Senderの[値完了関数](set_value.md)の[完了Scheduler](get_completion_scheduler.md.nolink)が`Sch`に等しいこと
 - コピー可能かつ同値比較可能
 
@@ -69,15 +69,15 @@ namespace std::execution {
 型`Sch`を`scheduler`の型、型`Env`を[`sender_in`](sender_in.md)`&amp;lt;schedule_result_t&amp;lt;Sch&amp;gt;, Env&amp;gt;`を満たす実行環境の型としたとき、`sender-in-of&amp;lt;schedule_result_t&amp;lt;Sch&amp;gt;, Env&amp;gt;`のモデルとなること。
 
 [`copyable`](/reference/concepts/copyable.md)`&amp;lt;remove_cvref_t&amp;lt;Sch&amp;gt;&amp;gt;`および[`equality_comparable`](/reference/concepts/equality_comparable.md)`&amp;lt;remove_cvref_t&amp;lt;Sch&amp;gt;&amp;gt;`により要求される操作は、例外で終了してはならない。
-これらの操作やScheduler型の[`schedule`](schedule.md.nolink)関数は、異なるスレッドから同時に操作を呼び出す可能性がある場合でも、データ競合を引き起こしてはならない。
+これらの操作やScheduler型の[`schedule`](schedule.md)関数は、異なるスレッドから同時に操作を呼び出す可能性がある場合でも、データ競合を引き起こしてはならない。
 
 あるScheduler型`Sch`の2つの値`sch1`と`sch2`に対して、`sch1`と`sch2`が同じ実行リソースを共有する場合に限って、`sch1 == sch2`は`true`となる。
 
-あるScheduler`sch`に対して、式[`get_completion_scheduler`](get_completion_scheduler.md.nolink)`&amp;lt;`[`set_value_t`](set_value.md)`&amp;gt;(`[`get_env`](get_env.md)`(`[`schedule`](schedule.md.nolink)`(sch)))`が`sch`と等しいこと。
+あるScheduler`sch`に対して、式[`get_completion_scheduler`](get_completion_scheduler.md.nolink)`&amp;lt;`[`set_value_t`](set_value.md)`&amp;gt;(`[`get_env`](get_env.md)`(`[`schedule`](schedule.md)`(sch)))`が`sch`と等しいこと。
 
-あるScheduler`sch`に対して式[`get_domain`](get_domain.md.nolink)`(sch)`が適格であるとき、式`get_domain(`[`get_env`](get_env.md)`(schedule(sch)))`も適格であり、かつ同じ型を持つ。
+あるScheduler`sch`に対して式[`get_domain`](get_domain.md.nolink)`(sch)`が適格であるとき、式`get_domain(`[`get_env`](get_env.md)`(`[`schedule`](schedule.md)`(sch)))`も適格であり、かつ同じ型を持つ。
 
-Scheduler型のデストラクタは、`schedule`が返すSenderオブジェクトに接続されたReceiverの完了を待機してブロックしてはならない。
+Scheduler型のデストラクタは、[`schedule`](schedule.md)が返すSenderオブジェクトに接続されたReceiverの完了を待機してブロックしてはならない。
 
 
 ## 例
@@ -112,7 +112,7 @@ int main()
 
 
 ## 関連項目
-- [`execution::schedule`](schedule.md.nolink)
+- [`execution::schedule`](schedule.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scheduler -- execution/scheduler: fix inner link</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/scheduler.html"/>
      <id>7a43329c3d646a98daf79ab7f29c9df6d7488bc1:reference/execution/execution/scheduler.md</id>
      <updated>2025-04-19T21:44:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/scheduler.md b/reference/execution/execution/scheduler.md
index 0e2fd7e19..27ef5307c 100644
--- a/reference/execution/execution/scheduler.md
+++ b/reference/execution/execution/scheduler.md
@@ -75,7 +75,7 @@ namespace std::execution {
 
 あるScheduler`sch`に対して、式[`get_completion_scheduler`](get_completion_scheduler.md.nolink)`&amp;lt;`[`set_value_t`](set_value.md)`&amp;gt;(`[`get_env`](get_env.md)`(`[`schedule`](schedule.md.nolink)`(sch)))`が`sch`と等しいこと。
 
-あるScheduler`sch`に対して式[`get_domain`](get_domain.md)`(sch)`が適格であるとき、式`get_domain(`[`get_env`](get_env.md)`(schedule(sch)))`も適格であり、かつ同じ型を持つ。
+あるScheduler`sch`に対して式[`get_domain`](get_domain.md.nolink)`(sch)`が適格であるとき、式`get_domain(`[`get_env`](get_env.md)`(schedule(sch)))`も適格であり、かつ同じ型を持つ。
 
 Scheduler型のデストラクタは、`schedule`が返すSenderオブジェクトに接続されたReceiverの完了を待機してブロックしてはならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>