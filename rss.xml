<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-11-14T14:46:51.287998</updated>
  <id>360aae54-6306-4b07-865d-e3e9e733047f</id>

  
    <entry>
      <title>コンストラクタ -- jthreadのコンストラクタ : サンプルコードの小さな改善</title>
      <link href="https://cpprefjp.github.io/reference/thread/jthread/op_constructor.html"/>
      <id>d640460031efd9c87ec0aed8426756ae492a2fc1:reference/thread/jthread/op_constructor.md</id>
      <updated>2022-11-14T22:57:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/thread/jthread/op_constructor.md b/reference/thread/jthread/op_constructor.md
index 169eab85c..172e1c92d 100644
--- a/reference/thread/jthread/op_constructor.md
+++ b/reference/thread/jthread/op_constructor.md
@@ -105,11 +105,11 @@ jthread(jthread&amp;amp;&amp;amp;) noexcept;             // (4) C++20
 std::uint64_t sum1 = 0;
 std::uint64_t sum2 = 0;
 
-void f1(std::stop_token token, std::uint64_t n)
+void f1(std::stop_token stoken, std::uint64_t n)
 {
   sum1 = 0;
   for (std::uint64_t i = 1; i &amp;lt; n; ++i) {
-    if (token.stop_requested()) {
+    if (stoken.stop_requested()) {
       // 中断リクエストがきたのでスレッドを終了する
       break;
     }
@@ -134,6 +134,9 @@ int main()
     std::this_thread::sleep_for(std::chrono::milliseconds{3});
     t1.request_stop(); // スレッドの中断要求を発行
 
+    // スレッド実行する関数がstd::stop_tokenを受け取らない場合、
+    // 中断リクエストを使用せず、
+    // デストラクタで自動的にjoinするスレッドオブジェクトとして使用する
     std::jthread t2 {
       [] { f2(1&amp;#39;000&amp;#39;000); }
     };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>subrange -- fix for site_generator</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange.html"/>
      <id>abd229030a4ada8cc21ffb7dfa06dae05ba45296:reference/ranges/subrange.md</id>
      <updated>2022-11-14T20:55:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange.md b/reference/ranges/subrange.md
index 5867810c1..6d5d3a8ce 100644
--- a/reference/ranges/subrange.md
+++ b/reference/ranges/subrange.md
@@ -26,7 +26,7 @@ namespace std::ranges {
 また、元のRangeが[`sized_range`](sized_range.md)でなくても、長さを別に指定することで[`sized_range`](sized_range.md)になれる。
 
 ## テンプレートパラメータ制約
-[`subrange_kind`](subrange_kind.md)` K`が`sized`である。または、イテレータ`I`と番兵`S`が[`sized_sentinel_for`](/reference/iterator/sized_sentinel_for.md)を満たさない。
+[`subrange_kind`](subrange_kind.md) `K`が`sized`である。または、イテレータ`I`と番兵`S`が[`sized_sentinel_for`](/reference/iterator/sized_sentinel_for.md)を満たさない。
 
 ## メンバ関数
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cpprefjp特有の拡張構文 -- cpprefjp特有の拡張構文 : バッククォート内の両端にスペースは使用できない制限を記載</title>
      <link href="https://cpprefjp.github.io/editors_doc/specialized.html"/>
      <id>63b7da16d88fd0f03c47bc66fb0e69690aae36c9:editors_doc/specialized.md</id>
      <updated>2022-11-14T19:52:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/editors_doc/specialized.md b/editors_doc/specialized.md
index e9a426118..2ba83f231 100644
--- a/editors_doc/specialized.md
+++ b/editors_doc/specialized.md
@@ -4,6 +4,19 @@
 
 Markdownだけだと表現力が足りないため、cpprefjpでは構文を拡張しています。
 
+## 文章中のコード
+
+バッククォートによる文章中のコード指定では、バッククォート内の両端にスペースは使用できません。以下のようにスペースはバッククォートの外で使用すれば、コードとして連結されます。
+
+```markdown
+式`f(a,` [`std::make_shared`](/reference/memory/make_shared.md)`&amp;lt;X&amp;gt;(x));`が有効である場合、それを呼び出す。
+```
+
+結果：
+
+式`f(a,` [`std::make_shared`](/reference/memory/make_shared.md)`&amp;lt;X&amp;gt;(x));`が有効である場合、それを呼び出す。
+
+
 ## コードブロック
 
 \`\`\` と \`\`\` で挟むことで、複数行に渡るコードを書けます。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>jthread -- jthread : コンストラクタを追加 #689</title>
      <link href="https://cpprefjp.github.io/reference/thread/jthread.html"/>
      <id>654109c63e6930e8d7cb03c570751cddab977a48:reference/thread/jthread.md</id>
      <updated>2022-11-14T19:05:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/thread/jthread.md b/reference/thread/jthread.md
index 92d54a113..a13784b49 100644
--- a/reference/thread/jthread.md
+++ b/reference/thread/jthread.md
@@ -22,7 +22,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |----------------------------------------------|--------------------------------------------------------------------|-------|
-| [`(constructor)`](jthread/op_constructor.md.nolink)        | コンストラクタ | C++20 |
+| [`(constructor)`](jthread/op_constructor.md)        | コンストラクタ | C++20 |
 | [`(destructor)`](jthread/op_destructor.md.nolink)        | デストラクタ | C++20 |
 | [`operator=`](jthread/op_assign.md.nolink)         | 代入演算子 | C++20 |
 | [`swap`](jthread/swap.md.nolink)                   | 別の`jthread`と交換する | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- jthread : コンストラクタを追加 #689</title>
      <link href="https://cpprefjp.github.io/reference/thread/jthread/op_constructor.html"/>
      <id>654109c63e6930e8d7cb03c570751cddab977a48:reference/thread/jthread/op_constructor.md</id>
      <updated>2022-11-14T19:05:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/thread/jthread/op_constructor.md b/reference/thread/jthread/op_constructor.md
new file mode 100644
index 000000000..169eab85c
--- /dev/null
+++ b/reference/thread/jthread/op_constructor.md
@@ -0,0 +1,166 @@
+# コンストラクタ
+* thread[meta header]
+* std[meta namespace]
+* jthread[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+jthread() noexcept;                      // (1) C++20
+
+template &amp;lt;class F, class... Args&amp;gt;
+explicit jthread(F&amp;amp;&amp;amp; f, Args&amp;amp;&amp;amp;... args); // (2) C++20
+
+jthread(const jthread&amp;amp;) = delete;        // (3) C++20
+
+jthread(jthread&amp;amp;&amp;amp;) noexcept;             // (4) C++20
+```
+
+
+## 概要
+- (1) : デフォルトコンストラクタ。新しいスレッドを生成せず、空の状態にする。
+- (2) : 新しいスレッドを生成し、そのスレッド上で引数`args...`を渡して、関数オブジェクト`f`を呼び出す。
+- (3) : コピーコンストラクタ。コピー不可。
+- (4) : ムーブコンストラクタ。スレッドの所有権を移動する。
+
+
+## テンプレートパラメータ制約
+- (2) :
+    - [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;F&amp;gt;`が`jthread`ではないこと
+    - [`decay_t`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;`および[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;Args&amp;gt;`の各型がCpp17MoveConstructible要件を満たすこと
+
+
+## 適格要件
+- (2) : 以下の条件がすべて`true`であること
+    - [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;, F&amp;gt;`
+    - `(`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;Args&amp;gt;, Args&amp;gt; &amp;amp;&amp;amp; ...)`
+    - [`is_move_constructible_v`](/reference/type_traits/is_move_constructible.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;&amp;gt;`
+    - `(`[`is_move_constructible_v`](/reference/type_traits/is_move_constructible.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;Args&amp;gt;&amp;gt; &amp;amp;&amp;amp; ...)`
+    - [`is_invocable_v`](/reference/type_traits/is_invocable.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;,` [`decay_t`](/reference/type_traits/decay.md)`&amp;lt;Args&amp;gt;...&amp;gt; ||` [`is_invocable_v`](/reference/type_traits/is_invocable.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;,` [`stop_token`](/reference/stop_token/stop_token.md)`,` [`decay_t`](/reference/type_traits/decay.md)`&amp;lt;Args&amp;gt;...&amp;gt;`
+
+
+## 効果
+- (2) :
+    - メンバ変数として保持している[`std::stop_source`](/reference/stop_token/stop_source.md)型オブジェクトを初期化する
+    - 以下の式が有効であればそれで新たなスレッドを生成して実行し、
+        ```cpp
+        invoke(decay-copy(std::forward&amp;lt;F&amp;gt;(f)), get_stop_token(), decay-copy(std::forward&amp;lt;Args&amp;gt;(args))...)
+        ```
+        * invoke[link /reference/functional/invoke.md]
+        * decay-copy[link /reference/exposition-only/decay-copy.md]
+        * std::forward[link /reference/utility/forward.md]
+        * get_stop_token()[link get_stop_token.md.nolink]
+
+    - そうでなければ以下の式でスレッドを生成して実行する
+        ```cpp
+        invoke(decay-copy(std::forward&amp;lt;F&amp;gt;(f)), decay-copy(std::forward&amp;lt;Args&amp;gt;(args))...)
+        ```
+        * invoke[link /reference/functional/invoke.md]
+        * decay-copy[link /reference/exposition-only/decay-copy.md]
+        * std::forward[link /reference/utility/forward.md]
+
+    - この呼び出しでの戻り値は無視される。この関数呼び出しが例外を送出する場合、呼び出し元スレッドで[`std::terminate`](/reference/exception/terminate.md)が呼び出される
+- (3) :
+
+
+## 同期
+- (2) : コンストラクタ呼び出しの完了は、`f`のコピーの呼び出し開始と同期する
+
+
+新しいスレッドを生成し、[`INVOKE`](/reference/concepts/Invoke.md)`(DECAY_COPY(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;F&amp;gt;(f)), DECAY_COPY(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args))...)`を実行する。ただし`DECAY_COPY`は同コンストラクタを呼び出したスレッド上にて評価される。また`f`のコピーの戻り値は無視される。
+    - `DECAY_COPY(x)`は `template &amp;lt;class T&amp;gt; typename std::decay&amp;lt;T&amp;gt;::type decay_copy(T&amp;amp;&amp;amp; v) { return` [`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(v); }` と定義される。おおよそ、`x`が配列型なら先頭要素へのポインタ、`x`が関数型ならその関数ポインタ、`x`がコピーコンストラクト可能な型なら`x`からコピーされたオブジェクト、`x`がムーブコンストラクト可能な型なら`x`からムーブされたオブジェクトとなる。
+
+
+## 同期
+- (2) : 同コンストラクタの呼び出し完了は、fのコピーの呼び出し開始と**同期する**。つまり、「コンストラクタ呼び出し側スレッドT0でのコンストラクタ呼び出し完了」は、「新しいスレッド`T1`上での`f`のコピーの呼び出し開始」よりも**前に発生する**。
+
+
+## 事後条件
+- (1) :
+    - [`get_id()`](get_id.md.nolink) `==` [`id()`](/reference/thread/thread/id.md)が`true`となること
+    - [`get_stop_source()`](get_stop_source.md.nolink)で取得される[`std::stop_source`](/reference/stop_token/stop_source.md)オブジェクトの[`stop_possible()`](/reference/stop_token/stop_source/stop_possible.md)が`false`であること
+- (2) :
+    - [`get_id()`](get_id.md.nolink) `!=` [`id()`](/reference/thread/thread/id.md)が`true`となること
+    - [`get_stop_source()`](get_stop_source.md.nolink)で取得される[`std::stop_source`](/reference/stop_token/stop_source.md)オブジェクトの[`stop_possible()`](/reference/stop_token/stop_source/stop_possible.md)が`true`であること
+    - `*this`は新しいスレッドと関連付けられること
+- (4) :
+    - `x.`[`get_id()`](get_id.md.nolink) `==` [`get_id()`](get_id.md.nolink)が`true`であること
+    - [`get_id()`](get_id.md.nolink)がムーブ前の`x.`[`get_id()`](get_id.md.nolink)の値であること
+    - `x.`[`get_stop_source()`](get_stop_source.md.nolink)`.`[`stop_possible()`](/reference/stop_token/stop_source/stop_possible.md)が`false`であること
+
+
+## 例外
+- (2) : 新しいスレッドの作成に失敗した場合、[`system_error`](/reference/system_error/system_error.md)例外を投げる。その例外オブジェクトには、以下のエラー状態が設定されうる：
+
+    - `resource_unavailable_try_again` : 新たなスレッドを作るためのリソースが不足している。もしくはシステムやプロセスが規定するスレッド数の上限を超過した。
+
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;cstdint&amp;gt;
+#include &amp;lt;thread&amp;gt;
+
+std::uint64_t sum1 = 0;
+std::uint64_t sum2 = 0;
+
+void f1(std::stop_token token, std::uint64_t n)
+{
+  sum1 = 0;
+  for (std::uint64_t i = 1; i &amp;lt; n; ++i) {
+    if (token.stop_requested()) {
+      // 中断リクエストがきたのでスレッドを終了する
+      break;
+    }
+    sum1 += i;
+  }
+}
+
+void f2(std::uint64_t n)
+{
+  sum2 = 0;
+  for (std::uint64_t i = 1; i &amp;lt; n; ++i) {
+    sum2 += i;
+  }
+}
+
+int main()
+{
+  {
+    // 関数の第1引数がstd::stop_token型である場合、
+    // スレッドに中断リクエストを送れるようになる
+    std::jthread t1 {f1, 1&amp;#39;000&amp;#39;000};
+    std::this_thread::sleep_for(std::chrono::milliseconds{3});
+    t1.request_stop(); // スレッドの中断要求を発行
+
+    std::jthread t2 {
+      [] { f2(1&amp;#39;000&amp;#39;000); }
+    };
+  } // スレッドの終了をデストラクタで待機する
+
+  std::cout &amp;lt;&amp;lt; sum1 &amp;lt;&amp;lt; std::endl; // 計算できたところまで表示
+  std::cout &amp;lt;&amp;lt; sum2 &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::uint64_t[link /reference/cstdint/uint64_t.md]
+* std::stop_token[link /reference/stop_token/stop_token.md]
+* token.stop_requested()[link /reference/stop_token/stop_token/stop_requested.md]
+* std::this_thread::sleep_for[link /reference/thread/this_thread/sleep_for.md]
+* t1.request_stop()[link request_stop.md.nolink]
+
+
+### 出力例
+```
+48458670270
+499999500000
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang):
+- [GCC](/implementation.md#gcc): 10.2.0
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>subrange -- Revert &#34;add zwsp to suppress trim_start by markdown module&#34;</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange.html"/>
      <id>6978db1b0d94c639e73ee0e95b8efa882189d662:reference/ranges/subrange.md</id>
      <updated>2022-11-14T18:23:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange.md b/reference/ranges/subrange.md
index 575be3b54..5867810c1 100644
--- a/reference/ranges/subrange.md
+++ b/reference/ranges/subrange.md
@@ -26,7 +26,7 @@ namespace std::ranges {
 また、元のRangeが[`sized_range`](sized_range.md)でなくても、長さを別に指定することで[`sized_range`](sized_range.md)になれる。
 
 ## テンプレートパラメータ制約
-[`subrange_kind`](subrange_kind.md)`​ K`が`sized`である。または、イテレータ`I`と番兵`S`が[`sized_sentinel_for`](/reference/iterator/sized_sentinel_for.md)を満たさない。
+[`subrange_kind`](subrange_kind.md)` K`が`sized`である。または、イテレータ`I`と番兵`S`が[`sized_sentinel_for`](/reference/iterator/sized_sentinel_for.md)を満たさない。
 
 ## メンバ関数
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>