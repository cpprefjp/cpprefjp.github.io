<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-22T09:17:10.157482</updated>
  <id>83b5b561-39f0-4e5f-8997-b8fc6e241d3f</id>

  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 未初期化領域への暗黙的なオブジェクト構築 : 複数のオブジェクトが構築されうるように修正 #1117</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>4818ff7a040a83267ebc5ee506299e44ea6195a3:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-22T18:12:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index 9e5eab7c4..032c88222 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -216,13 +216,13 @@ C++においては、ポインタに対する演算（`+ -`など）はそのポ
 
 ### 暗黙的なオブジェクト構築
 
-オブジェクトを暗黙的に構築する操作では、そうすることでプログラムが定義された振る舞いをするようになる（すなわち、未定義動作が回避できる）場合に、*implicit-lifetime types*の０個以上のオブジェクトを暗黙的に構築しその生存期間を開始させる。そのような、暗黙的なオブジェクト構築によってプログラムに定義された振る舞いをもたらすオブジェクトが１つも存在しない場合は未定義動作となる（これは今まで通り）。逆に、そのようなオブジェクトが複数存在している場合は、どのオブジェクトが暗黙的に構築されるかは未規定（これは、都度適切なオブジェクトが選択され構築されることを意図している）。
+オブジェクトを暗黙的に構築する操作では、そうすることでプログラムが定義された振る舞いをするようになる（すなわち、未定義動作が回避できる）場合に、*implicit-lifetime types*の0個以上のオブジェクトを暗黙的に構築しその生存期間を開始させる。そのような、暗黙的なオブジェクト構築によってプログラムに定義された振る舞いをもたらすオブジェクトの集合が1つも存在しない場合は未定義動作となる（これは今まで通り）。逆に、そのようなオブジェクトの集合が複数存在している場合は、どのオブジェクトが暗黙的に構築されるかは未規定（これは、都度適切なオブジェクトが選択され構築されることを意図している）。
 
 暗黙的なオブジェクト構築が行われる場合、そのサブオブジェクトの*implicit-lifetime types*のオブジェクトも暗黙的に構築され生存期間が開始されるが、*implicit-lifetime types*ではないオブジェクトは暗黙的に構築されないため明示的な初期化が必要となる。
 
 暗黙的なオブジェクト構築を行わなくてもプログラムが定義された振る舞いをする（未定義動作とならない）場合、対象の操作は暗黙的にオブジェクトを構築せず、通常の効果のみをもたらす。
 
-さらに、オブジェクトを暗黙的に構築する操作の内メモリを確保する関数等一部の操作では、暗黙的なオブジェクト構築によって作成されたオブジェクトを指す適切なポインタを返すことが規定される。これらの操作においては、そのポインタ値を返すことでプログラムが定義された振る舞いをするようになる場合に、指定された領域の先頭アドレスをアドレスとする暗黙的に構築されたオブジェクトの１つを選択し、そのオブジェクトを指すポインタ値を生成しそれを返す。そのような、プログラムに定義された振る舞いをもたらすようなポインタ値が存在しない場合は未定義動作となる。逆に、そのようなポインタ値が複数存在している場合は、どのポインタ値が生成されるかは未規定。
+さらに、オブジェクトを暗黙的に構築する操作の内メモリを確保する関数等一部の操作では、暗黙的なオブジェクト構築によって作成されたオブジェクトを指す適切なポインタを返すことが規定される。これらの操作においては、そのポインタ値を返すことでプログラムが定義された振る舞いをするようになる場合に、指定された領域の先頭アドレスをアドレスとする暗黙的に構築されたオブジェクトの1つを選択し、そのオブジェクトを指すポインタ値を生成しそれを返す。そのような、プログラムに定義された振る舞いをもたらすようなポインタ値が存在しない場合は未定義動作となる。逆に、そのようなポインタ値が複数存在している場合は、どのポインタ値が生成されるかは未規定。
 
 そのようなポインタ生成を行わなくてもプログラムが定義された振る舞いをする場合、そのようなポインタ値は生成されず、対象の操作は通常のポインタ値を返す。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 未初期化領域への暗黙的なオブジェクト構築 : 共用体の例と問題解決例を追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>04deaac7dfd476246698e5046dffb52e63625c51:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-22T17:52:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index fa76066ac..9e5eab7c4 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -15,7 +15,7 @@ X *make_x() {
   // malloc()はメモリの確保だけを行う
   X *p = (X*)malloc(sizeof(struct X));
   
-  // pの領域にはオブジェクトが構築されていない
+  // pの領域にはXのオブジェクトが構築されていない
   p-&amp;gt;a = 1; // 💀 UB
   p-&amp;gt;b = 2; // 💀 UB
 
@@ -31,7 +31,7 @@ X *make_x() {
   // new式はメモリの確保とオブジェクト構築を行う
   X *p = new X;
   
-  // pの領域にはオブジェクトが構築済
+  // pの領域にはXのオブジェクトが構築済
   p-&amp;gt;a = 1; // ✅ ok
   p-&amp;gt;b = 2; // ✅ ok
 
@@ -50,12 +50,12 @@ X *make_x() {
 `new`式ではなく`operator new()`を直接使用する場合は同様の問題がある。
 
 ```cpp
-// new式を使用する場合
+// new演算子を使用する場合
 X *make_x() {
   // operator new()はメモリの確保だけを行う
   X *p = (X*)::operator new(sizeof(struct X));
   
-  // pの領域にはオブジェクトが構築されていない
+  // pの領域にはXのオブジェクトが構築されていない
   p-&amp;gt;a = 1; // 💀 UB
   p-&amp;gt;b = 2; // 💀 UB
 
@@ -195,6 +195,25 @@ C++においては、ポインタに対する演算（`+ -`など）はそのポ
 
 また、これらの操作に限らず、`char, unsigned char, std::byte`の配列オブジェクトを構築しその生存期間を開始する操作は、その配列オブジェクトが占有する領域内にその要素のオブジェクトを暗黙的に構築する。
 
+#### 共用体のコピー操作
+
+共用体のデフォルトのコピー/ムーブコンストラクタと代入演算子では、次のようにオブジェクトを暗黙的に構築する
+
+- コンストラクタ
+    - コピー元オブジェクトにネストした各オブジェクトに対して、コピー先内で対応するオブジェクト`o`を
+        - サブオブジェクトの場合 : 特定する
+        - それ以外の場合 : 暗黙的に構築する
+            - 別のオブジェクトにストレージを提供している場合やサブオブジェクトのサブオブジェクトなど
+    - `o`の生存期間はコピーの前に開始される
+- 代入演算子
+  - 代入元と代入先が同じオブジェクトではない場合
+  - コピー元オブジェクトにネストした各オブジェクトに対して、コピー先内で対応するオブジェクト`o`が暗黙的に構築され
+  - `o`の生存期間はコピーの前に開始される
+
+どちらの場合も、コピー元で生存期間内にあるオブジェクトがコピー先で（可能なら）暗黙的に構築される。
+
+クラス型をメンバとして保持する場合など、デフォルトのコンストラクタ/代入演算子が`delete`されている場合はこれは行われない。
+
 ### 暗黙的なオブジェクト構築
 
 オブジェクトを暗黙的に構築する操作では、そうすることでプログラムが定義された振る舞いをするようになる（すなわち、未定義動作が回避できる）場合に、*implicit-lifetime types*の０個以上のオブジェクトを暗黙的に構築しその生存期間を開始させる。そのような、暗黙的なオブジェクト構築によってプログラムに定義された振る舞いをもたらすオブジェクトが１つも存在しない場合は未定義動作となる（これは今まで通り）。逆に、そのようなオブジェクトが複数存在している場合は、どのオブジェクトが暗黙的に構築されるかは未規定（これは、都度適切なオブジェクトが選択され構築されることを意図している）。
@@ -237,32 +256,182 @@ static_assert(f() == 123);  // C++20からはUBが起こるため不適格、C++
 
 したがって、これらの変更によって実行時に何かすべきことが増えるわけではなく、暗黙的なオブジェクト構築は実際にコンストラクタを呼んだり何か初期化を行うものではないし、擬似デストラクタ呼び出しが実行時に何かをするようになるわけでもない。
 
-## 例
-(執筆中)
-```cpp example
-// (ここには、言語機能の使い方を解説するための、サンプルコードを記述します。)
-// (インクルードとmain()関数を含む、実行可能なサンプルコードを記述してください。そのようなコードブロックにはexampleタグを付けます。)
+## 以前の問題の修正例
+
+### `malloc()`/ `operator new`
+
+```cpp
+// Xはimplicit-lifetime class types
+struct X {
+  int a;
+  int b;
+};
+
+X *make_x() {
+  // 後続のXのメンバアクセスを定義された振る舞いとするために
+  // malloc()はメモリの確保とともにXのオブジェクト（とメンバオブジェクト）を暗黙的に構築する
+  // そして、構築されたXのオブジェクトへの適切なポインタを返す
+  X *p = (X*)malloc(sizeof(struct X));
+  
+  // pの領域にはXのオブジェクトが暗黙的に構築されている
+  p-&amp;gt;a = 1; // ✅ ok
+  p-&amp;gt;b = 2; // ✅ ok
+
+  return p;
+}
+```
+
+```cpp
+// new演算子を使用する場合
+X *make_x() {
+  // 後続のXのメンバアクセスを定義された振る舞いとするために
+  // operator new()はメモリの確保とともにXのオブジェクト（とメンバオブジェクト）を暗黙的に構築する
+  // そして、構築されたXのオブジェクトへの適切なポインタを返す
+  X *p = (X*)::operator new(sizeof(struct X));
+  
+  // pの領域にはXのオブジェクトが暗黙的に構築されている
+  p-&amp;gt;a = 1; // ✅ ok
+  p-&amp;gt;b = 2; // ✅ ok
+
+  return p;
+}
+```
+
+### 共用体のコピー
+
+```cpp
+union U {
+  int n;
+  float f;
+};
+
+float pun(int n) {
+  // U::nの生存期間が開始
+  U u = {.n = n};
+  
+  // このコピーではuのオブジェクト表現がコピーされるとともに
+  // uのアクティブメンバに対応するメンバがコピー先でアクティブとなる
+  U u2 = u;
+  
+  // u2.fは非アクティブ
+  return u2.f; // 💀 UB
+}
+```
+
+共用体のコピーにおいてはあくまでコピー元で生存期間内にあったオブジェクトに対応するオブジェクトがコピー先でも生存期間内にあることが保証されるだけで、*type-punning*のようなことを可能にするわけではない。
+
+```cpp
+int f(int n) {
+  U u = {.n = n};
+
+  U u2 = u;
+  
+  // これならok
+  return u2.n; // ✅ ok
+}
+```
+
+### バイト配列の読み込み
 
-#include &amp;lt;iostream&amp;gt;
+```cpp
+// 何かバイト列ストリームを受け取って処理する関数とする
+void process(Stream *stream) {
+  // バイト配列の読み出し
+  std::unique_ptr&amp;lt;char[]&amp;gt; buffer = stream-&amp;gt;read();
 
-int main()
-{
-  int variable = 0;
-  std::cout &amp;lt;&amp;lt; variable &amp;lt;&amp;lt; std::endl;
+  // 先頭バイトの状態によって分岐
+  if (buffer[0] == FOO) {
+    process_foo(reinterpret_cast&amp;lt;Foo*&amp;gt;(buffer.get())); // #1
+  } else {
+    process_bar(reinterpret_cast&amp;lt;Bar*&amp;gt;(buffer.get())); // #2
+  }
 }
 ```
-* variable[color ff0000]
 
-(コードブロック中の識別子に、文字色を付ける例です。)
+`Foo`も`Bar`も*implicit-lifetime types*だとして、以前のこのコードに対して`Stream::read()`が次のように実装されている場合
 
-### 出力
+```cpp
+unique_ptr&amp;lt;char[]&amp;gt; Stream::read() {
+  // ... determine data size ...
+  unique_ptr&amp;lt;char[]&amp;gt; buffer(new char[N]);
+  // ... copy data into buffer ...
+  return buffer;
+}
 ```
-0
+
+この`read()`内の`new char[N]`によって呼ばれる`operator new[]`によって`Foo`/`Bar`のオブジェクトが暗黙的に構築される。この場合、`buffer[0] == FOO`による分岐によってプログラムに定義された振る舞いをもたらすオブジェクトは、`Foo`と`Bar`のオブジェクトとして2つ存在する。したがって、ここでは先頭バイトの状態に応じて適切なオブジェクトが構築される（そうすることでプログラムに定義された振る舞いをもたらす）ため、`process()`内では未定義動作は回避される。
+
+```cpp
+void process(Stream *stream) {
+  // バイト配列の読み出し
+  std::unique_ptr&amp;lt;char[]&amp;gt; buffer = stream-&amp;gt;read();
+
+  // 先頭バイトの状態によって適切なオブジェクトがStream::read()内で構築されている
+  if (buffer[0] == FOO) {
+    process_foo(reinterpret_cast&amp;lt;Foo*&amp;gt;(buffer.get())); // ✅ ok
+  } else {
+    process_bar(reinterpret_cast&amp;lt;Bar*&amp;gt;(buffer.get())); // ✅ ok
+  }
+}
 ```
 
-(ここには、サンプルコードの実行結果を記述します。何も出力がない場合は、項目を削除せず、空の出力にしてください。)  
-(実行結果が処理系・実行環境によって異なる場合は、項目名を「出力例」に変更し、可能であればその理由も併記してください。)
+### 動的配列の実装
+
+```cpp
+// std::vectorの様な動的配列型を実装したい
+template&amp;lt;typename T&amp;gt;
+struct Vec {
+  char *buf = nullptr;
+  char *buf_end_size = nullptr;
+  char *buf_end_capacity = nullptr;
+
+  void reserve(std::size_t n) {
+    // 後続の操作を適格にするためのオブジェクトを暗黙的に構築する
+    // ここでは、Tの配列型T[]のオブジェクトが暗黙的に構築される（要素のオブジェクトは構築されない）
+    // 同時に、char[]のオブジェクトも暗黙的に構築される
+    char *newbuf = (char*)::operator new(n * sizeof(T), std::align_val_t(alignof(T)));
+
+    // newbufにはT[]のオブジェクトが生存期間内にあるため、ポインタT*をイテレータとして使用可能となる
+    // ここで、T[]の要素のTのオブジェクトが構築される（明示的）
+    std::uninitialized_copy(begin(), end(), (T*)newbuf); // #a ✅ ok
+
+    ::operator delete(buf, std::align_val_t(alignof(T)));
+    
+    // newbufにはchar[]のオブジェクトが生存期間内にあるため、newbuf(char*)をイテレータとして使用可能となる
+    buf_end_size = newbuf + sizeof(T) * size(); // #b ✅ ok
+    buf_end_capacity = newbuf + sizeof(T) * n;  // #c ✅ ok
+    buf = newbuf;
+  }
+
+  void push_back(T t) {
+    if (buf_end_size == buf_end_capacity)
+      reserve(std::max&amp;lt;std::size_t&amp;gt;(size() * 2, 1));
+    new (buf_end_size) T(t);
+
+    // buf_end_sizeの指す領域にはchar[]のオブジェクトが生存期間内にあるため、ポインタをイテレータとして使用可能
+    buf_end_size += sizeof(T); // #d ✅ ok
+  }
+
+  T *begin() { return (T*)buf; }
+
+  T *end() { return (T*)buf_end_size; }
+
+  // buf及びbuf_end_sizeの指す領域にはT[]のオブジェクトが生存期間内にあるため、ポインタをイテレータとして使用可能
+  std::size_t size() { return end() - begin(); } // #e ✅ ok
+};
+
+int main() {
+  Vec&amp;lt;int&amp;gt; v;
+  v.push_back(1);
+  v.push_back(2);
+  v.push_back(3);
+
+  // 実装内部で暗黙的に配列オブジェクトが構築されることでUBが回避される
+  for (int n : v) { /*...*/ } // #f ✅ ok
+}
+```
 
+この例では、`reserve()`内`newbuf`及びそれを保存している`Vec::buf`の領域に`T[]`（`T`の配列型）と`char[]`のオブジェクトが暗黙的に構築され、同時に生存期間内にあることで、問題（配列オブジェクトを指さないポインタのイテレータとしての使用）が解消され、すべての箇所で定義された振る舞いをもたらしている。
 
 ## この機能が必要になった背景・経緯
 (執筆中)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functional/hash: 説明増補</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>496bf9cbdced56bf08284bc1b984977a18136cee:reference/functional/hash.md</id>
      <updated>2023-02-21T18:40:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index f1b626178..764b4ff5c 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -36,9 +36,11 @@ namespace std {
 ## 概要
 クラステンプレート`hash`は、非順序連想コンテナ（[`unordered_map`](/reference/unordered_map/unordered_map.md)/[`unordered_multimap`](/reference/unordered_map/unordered_multimap.md)/[`unordered_set`](/reference/unordered_set/unordered_set.md)/[`unordered_multiset`](/reference/unordered_set/unordered_multiset.md)）のキーとなる型のためのハッシュ値を計算する関数オブジェクトである。
 
-このクラスはそのものにデフォルトの定義は存在せず、ユーザーが任意の型で特殊化する際の要件を定義する。`hash`クラステンプレートを特殊化する場合、以下に記述するメンバ関数を持たせる必要がある。
+このクラスはそのものにデフォルトの定義は存在せず、ユーザーが任意の型で特殊化する際の要件を定義する。`hash`クラステンプレートを特殊化する場合、後述するメンバ関数を持たせる必要がある。
 
-`&amp;lt;functional&amp;gt;`ヘッダでは、以下の特殊化を提供する。これ以外の特殊化は、対象型を定義する各種ヘッダファイルにて提供される：
+### 基本型のハッシュサポート
+`&amp;lt;functional&amp;gt;`ヘッダでは、基本型に対する特殊化を提供する。
+`std::string`などC++標準ライブラリ定義の型に対する特殊化は、対象型を定義する各種ヘッダファイルにて提供される。
 
 | 型                   | 対応バージョン |
 |----------------------|----------------|
@@ -69,18 +71,25 @@ namespace std {
 ## メンバ関数
 
 | 名前 | 説明 |
-|-----------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|
-| `hash()`&amp;lt;br/&amp;gt;`hash(const hash&amp;amp;)`&amp;lt;br/&amp;gt;`hash(hash&amp;amp;&amp;amp;)` | デフォルトコンストラクタ、コピーコンストラクタ、ムーブコンストラクタを持つ |
-| `~hash()` | デストラクタを持つ |
-| `hash&amp;amp; operator=(const hash&amp;amp;)`&amp;lt;br/&amp;gt;`hash&amp;amp; operator=(hash&amp;amp;&amp;amp;)` | コピー代入演算子とムーブ代入演算子を持つ |
-| `size_t operator()(T key) const` | 関数呼び出し演算子によって、キーに対応するハッシュ値を返す |
+|------|------|
+| `(constructor)` | デフォルトコンストラクタ、コピーコンストラクタ、ムーブコンストラクタを持つ |
+| `(destructor)` | デストラクタを持つ |
+| `operator=` | コピー代入演算子とムーブ代入演算子を持つ |
+| `operator()` | 関数呼び出し演算子によって、キー値`k`に対応する`size_t`型のハッシュ値を返す。`const`修飾メンバ関数。 |
+
+関数呼び出し演算子に関する制約は次の通り :
+
+- 引数に指定するキー値`k`を変更してはならない。
+- ハッシュ計算は引数で指定したキー値以外に依存してはいけない（状態をもってはいけない）。
+- 式`k1 == k2`を満たす2個のキー値に対しては、同一ハッシュ値を返すこと。
+    - 異なる2個のキーに対して同一ハッシュ値を返すこと（collision; 衝突）は許容されるが、入力に対する出力ハッシュ値は`size_t`型の値域において均等分布することが好ましい。
 
 
 ## メンバ型
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt;この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
+| `is_transparent` | 省略可。ハッシュ計算を行う関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt;この型は、例えば関数オブジェクトが`string`型／`string_view`型／ヌル終端文字列(`const char*`)に対して等価なハッシュ値を生成できる場合に定義される。 | C++20 |
 
 
 ## 例
@@ -89,6 +98,8 @@ namespace std {
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;functional&amp;gt;
 
+enum class E { A = 1, B = 42, C = 100 };
+
 int main()
 {
   int x;
@@ -104,6 +115,10 @@ int main()
 
   // int*型のアドレス値(&amp;amp;x)に対するハッシュ値を求める
   std::cout &amp;lt;&amp;lt; std::hash&amp;lt;int*&amp;gt;()(&amp;amp;x) &amp;lt;&amp;lt; std::endl;
+
+  // 列挙型の値E::Bに対するハッシュ値を求める（C++14から）
+  E e = E::B;
+  std::cout &amp;lt;&amp;lt; std::hash&amp;lt;E&amp;gt;()(e) &amp;lt;&amp;lt; std::endl;
 }
 ```
 * std::hash[color ff0000]
@@ -114,10 +129,11 @@ int main()
 100
 1427109137
 3219530756
+42
 ```
 
 ### 透過的にハッシュ値を計算できる場合 (C++20)
-`is_transparent`が定義される場合、以下のようなコードにおいて、`find()`メンバ関数に文字列リテラルを指定しても、一時的な[`string`](/reference/string/basic_string.md)オブジェクトが作成されず、パフォーマンス向上が期待できる。
+メンバ型`is_transparent`が定義される場合、以下のようなコードにおいて、[`find`](/reference/unordered_map/unordered_map/find.md)メンバ関数に文字列リテラルを指定しても、一時的な[`string`](/reference/string/basic_string.md)オブジェクトが作成されず、パフォーマンス向上が期待できる。
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -135,6 +151,7 @@ struct string_hash {
 
 int main()
 {
+  // キー型=std::string, 値型=int
   std::unordered_map&amp;lt;std::string, int, string_hash, std::equal_to&amp;lt;&amp;gt;&amp;gt; um = {
     {&amp;#34;Alice&amp;#34;, 3},
     {&amp;#34;Bob&amp;#34;, 1},
@@ -142,7 +159,7 @@ int main()
   };
 
   // string_hashおよびstd::equal_to&amp;lt;&amp;gt;はいずれもメンバ型にis_transparentを持つため、
-  // find()などの検索関数に引数を渡す場合に、std::string一時オブジェクトが作られない
+  // find()などの検索関数に値を渡す場合に、キー型(std::string)一時オブジェクトが作られない
   auto it = um.find(&amp;#34;Alice&amp;#34;);
   if (it != um.end()) {
     std::cout &amp;lt;&amp;lt; &amp;#34;found : &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
@@ -189,7 +206,9 @@ found : 3
 
 ## 参照
 - [ハッシュ関数 - Wikipedia](https://ja.wikipedia.org/wiki/ハッシュ関数)
-- [LWG 2148 - Hashing enums should be supported directly by std::hash](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148)
+- [LWG 2148 - Hashing enums should be supported directly by `std::hash`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148)
 - [LWG 2291 - std::hash is vulnerable to collision DoS attack](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2291)
+- [LWG 2543 - LWG 2148 (hash support for enum types) seems under-specified](https://cplusplus.github.io/LWG/issue2543)
+- [LWG 2817 - `std::hash` for `nullptr_t`](https://cplusplus.github.io/LWG/issue2817)
 - [P0919R3 Heterogeneous lookup for unordered containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0919r3.html)
 - [P1690R1 Refinement Proposal for P0919 Heterogeneous lookup for unordered containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1690r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 未初期化領域への暗黙的なオブジェクト構築 : 表現修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>9755c4c685f21f8cfb47980a23f619306afdcbff:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-21T14:43:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index ed4a4415f..fa76066ac 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -209,9 +209,9 @@ C++においては、ポインタに対する演算（`+ -`など）はそのポ
 
 ### 擬似デストラクタ呼び出しによる生存期間の終了
 
-一部の文脈では、スカラー型のオブジェクトに対してデストラクタ呼び出しを行うことができ、その場合のデストラクタ呼び出しのことを擬似デストラクタ呼び出し（*pseudo-destructor call*）と呼ぶ。
+一部の文脈では、スカラ型のオブジェクトに対してデストラクタ呼び出しを行うことができ、その場合のデストラクタ呼び出しのことを擬似デストラクタ呼び出し（*pseudo-destructor call*）と呼ぶ。
 
-C++17まで、擬似デストラクタ呼び出しには何の効果もなかった（テンプレートの文脈でクラス型との構文上の互換性を取るためのものでしかなかった）が、C++20からは擬似デストラクタ呼び出しはそのスカラー型オブジェクトの生存期間を終了させることが規定される。
+C++17まで、擬似デストラクタ呼び出しには何の効果もなかった（テンプレートの文脈でクラス型との構文上の互換性を取るためのものでしかなかった）が、C++20からは擬似デストラクタ呼び出しはそのスカラ型オブジェクトの生存期間を終了させることが規定される。
 
 ```cpp
 constexpr int f() {
@@ -235,7 +235,7 @@ static_assert(f() == 123);  // C++20からはUBが起こるため不適格、C++
 
 これらの変更はあくまでオブジェクト生存期間に関する規則を変更しただけに過ぎず、その影響はコンパイラ等の実装のオブジェクト生存期間の認識が変わるだけである。それによって、今まで未定義動作となっていたコードが未定義動作ではなくなり、未定義動作をトリガーとする最適化を受ける可能性が将来にわたって取り除かれることになる（ただし、擬似デストラクタ呼び出し周りの変更だけは、未定義動作ではなかったコードを未定義動作にしうる）。
 
-したがって、擬似デストラクタ呼び出しを除いて、これらの変更によって最適化によるもの以外の実行時の振る舞いが変化することはなく、暗黙的なオブジェクト構築は実際にコンストラクタを呼んだり何か初期化を行うものではない。
+したがって、これらの変更によって実行時に何かすべきことが増えるわけではなく、暗黙的なオブジェクト構築は実際にコンストラクタを呼んだり何か初期化を行うものではないし、擬似デストラクタ呼び出しが実行時に何かをするようになるわけでもない。
 
 ## 例
 (執筆中)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 擬似デストラクタ呼び出しの例を追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>cf2f9aca8e91c46b6f5c05b6152d5533279b356a:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-21T14:29:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index 7186111c5..ed4a4415f 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -213,13 +213,29 @@ C++においては、ポインタに対する演算（`+ -`など）はそのポ
 
 C++17まで、擬似デストラクタ呼び出しには何の効果もなかった（テンプレートの文脈でクラス型との構文上の互換性を取るためのものでしかなかった）が、C++20からは擬似デストラクタ呼び出しはそのスカラー型オブジェクトの生存期間を終了させることが規定される。
 
+```cpp
+constexpr int f() {
+  int a = 123;
+  using T = int;
+
+  // 擬似デストラクタ呼び出し
+  // C++20からはaの生存期間を終了させる
+  // C++17までは何も効果がない
+  a.~T();
+
+  return a;  // C++20からはUB、C++17までは123を返す
+}
+
+static_assert(f() == 123);  // C++20からはUBが起こるため不適格、C++17以前は適格
+```
+
 これに伴い、[`destroy_at()`](/reference/memory/destroy_at.md)などの擬似デストラクタ呼び出しと等価のことを行うライブラリ機能においても、スカラ型のオブジェクトの生存期間を終了させるようになる。
 
 ### これらの変更の影響
 
-これらの変更はあくまでオブジェクト生存期間に関する規則を変更しただけに過ぎず、その影響はコンパイラ等の実装のオブジェクト生存期間の認識が変わるだけである。それによって、今まで未定義動作となっていたコードが未定義動作ではなくなり、未定義動作をトリガーとする最適化を受ける可能性が将来にわたって取り除かれることになる。
+これらの変更はあくまでオブジェクト生存期間に関する規則を変更しただけに過ぎず、その影響はコンパイラ等の実装のオブジェクト生存期間の認識が変わるだけである。それによって、今まで未定義動作となっていたコードが未定義動作ではなくなり、未定義動作をトリガーとする最適化を受ける可能性が将来にわたって取り除かれることになる（ただし、擬似デストラクタ呼び出し周りの変更だけは、未定義動作ではなかったコードを未定義動作にしうる）。
 
-したがって、これらの変更によって最適化によるもの以外の実行時の振る舞いが変化することはなく、暗黙的なオブジェクト構築は実際にコンストラクタを呼んだり何か初期化を行うものではない。
+したがって、擬似デストラクタ呼び出しを除いて、これらの変更によって最適化によるもの以外の実行時の振る舞いが変化することはなく、暗黙的なオブジェクト構築は実際にコンストラクタを呼んだり何か初期化を行うものではない。
 
 ## 例
 (執筆中)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>