<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-11-25T09:12:44.946573</updated>
  <id>c4a1c88f-f00e-4e4c-b8ef-209f344f5271</id>

  
    <entry>
      <title>tuple_element -- tuple_element, tuple_size : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_element.html"/>
      <id>01bd2a73ba54793a4e96fef216dfa05a7e255b56:reference/tuple/tuple_element.md</id>
      <updated>2020-11-25T18:07:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_element.md b/reference/tuple/tuple_element.md
index 65f5e96e1..030778847 100644
--- a/reference/tuple/tuple_element.md
+++ b/reference/tuple/tuple_element.md
@@ -6,20 +6,29 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element; // 宣言のみで定義なし
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element;                        // (1) C++11 宣言のみで定義なし
 
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const T&amp;gt;;
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, volatile T&amp;gt;;
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const volatile T&amp;gt;;
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, const T&amp;gt;;            // (2) C++11
+
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, volatile T&amp;gt;;         // (3) C++11
+                                              // C++20で非推奨
+
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, const volatile T&amp;gt;;   // (4) C++11
+                                              // C++20で非推奨
 
   template &amp;lt;std::size_t I, class... Types&amp;gt;
-  class tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt; {
+  class tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt; {   // (5) C++11
   public:
     using type = TI;
   };
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  using tuple_element_t = typename tuple_element&amp;lt;I, T&amp;gt;::type; // C++14
+  using tuple_element_t =
+    typename tuple_element&amp;lt;I, T&amp;gt;::type;       // (6) C++14
 }
 ```
 * tuple[link tuple.md]
@@ -29,19 +38,16 @@ namespace std {
 
 `tuple_element`の第1テンプレート引数に要素番号、第2引数のタプルの型を指定し、ネスト型である`type`型を取り出すことで要素型を得ることができる。
 
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element;`
-
-    特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素型を取得しようとする段階でコンパイルエラーとなる。
-
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const T&amp;gt;;`
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, volatile T&amp;gt;;`
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const volatile T&amp;gt;;`
-
-    CV修飾された型からも要素型を取得できるようにするための部分特殊化。
+- (1) : 特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素型を取得しようとする段階でコンパイルエラーとなる
+- (2) : `const`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (3) : `volatile`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (4) : `const volatile`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (5) : `std::tuple`から要素型を取得できるようにするための部分特殊化
+- (6) : エイリアステンプレート版
 
-- `template &amp;lt;size_t I, class... Types&amp;gt; class tuple_element&amp;lt;I,` [`tuple`](tuple.md)`&amp;lt;Tuples...&amp;gt;&amp;gt;;`
 
-    `std::tuple`から要素型を取得できるようにするための部分特殊化。
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
 
 
 ## 例
@@ -71,18 +77,6 @@ int main()
                   std::tuple_element&amp;lt;0, const std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
                   const int
                 &amp;gt;::value, &amp;#34;&amp;#34;);
-
-  // volatile修飾
-  static_assert(std::is_same&amp;lt;
-                  std::tuple_element&amp;lt;0, volatile std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
-                  volatile int
-                &amp;gt;::value, &amp;#34;&amp;#34;);
-
-  // const, volatile修飾
-  static_assert(std::is_same&amp;lt;
-                  std::tuple_element&amp;lt;0, const volatile std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
-                  const volatile int
-                &amp;gt;::value, &amp;#34;&amp;#34;);
 }
 ```
 * std::tuple_element[color ff0000]
@@ -103,6 +97,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [N3887 Consistent Metafunction Aliases](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3887.pdf)
-
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_size -- tuple_element, tuple_size : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_size.html"/>
      <id>01bd2a73ba54793a4e96fef216dfa05a7e255b56:reference/tuple/tuple_size.md</id>
      <updated>2020-11-25T18:07:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_size.md b/reference/tuple/tuple_size.md
index a5bec3081..a4c220aee 100644
--- a/reference/tuple/tuple_size.md
+++ b/reference/tuple/tuple_size.md
@@ -6,18 +6,27 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class T&amp;gt; class tuple_size; // 宣言のみで定義なし
+  template &amp;lt;class T&amp;gt;
+  class tuple_size;                   // (1) C++11 宣言のみで定義なし
 
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const T&amp;gt;;
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;volatile T&amp;gt;;
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const volatile T&amp;gt;;
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;const T&amp;gt;;          // (2) C++11
+
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;volatile T&amp;gt;;       // (3) C++11
+                                      // C++20で非推奨
+
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;const volatile T&amp;gt;; // (4) C++11
+                                      // C++20で非推奨
 
   template &amp;lt;class... Types&amp;gt;
   class tuple_size&amp;lt;tuple&amp;lt;Types...&amp;gt;&amp;gt;
-    : public integral_constant&amp;lt;size_t, sizeof...(Types)&amp;gt; {};
+    : public integral_constant&amp;lt;size_t, sizeof...(Types)&amp;gt; {}; // (5) C++11
 
   template &amp;lt;class T&amp;gt;
-  inline constexpr size_t tuple_size_v = tuple_size&amp;lt;T&amp;gt;::value; // C++17
+  inline constexpr size_t tuple_size_v =
+    tuple_size&amp;lt;T&amp;gt;::value;                                    // (6) C++17
 }
 ```
 * tuple[link tuple.md]
@@ -28,23 +37,22 @@ namespace std {
 
 要素数は、[`integral_constant`](/reference/type_traits/integral_constant.md)の機能を利用してコンパイル時の定数値として取得できる。
 
-- `template &amp;lt;class T&amp;gt; class tuple_size;`
-
-    特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素数を取得しようとする段階でコンパイルエラーとなる。
+- (1) : 特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素数を取得しようとする段階でコンパイルエラーとなる
+- (2) : `const`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (3) : `volatile`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (4) : `const volatile`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (5) : `std::tuple`の要素数を取得できるようにするための部分特殊化
+- (6) : 変数テンプレート版
 
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const T&amp;gt;;`
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;volatile T&amp;gt;;`
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const volatile T&amp;gt;;`
 
-    CV修飾された型からも要素数を取得できるようにするための部分特殊化。
+型`T`がタプルと見なせない型であった場合、
 
-- `template &amp;lt;class... Types&amp;gt; class tuple_size&amp;lt;tuple&amp;lt;Types...&amp;gt;&amp;gt;;`
+- C++11 : 仕様で明確に規定されてはいないが、直接的にコンパイルエラーとなる
+- C++17 : メンバ`value`が定義されない (SFINAEと組み合わせて扱える)
 
-    `std::tuple`の要素数を取得できるようにするための部分特殊化。
 
-- 型`T`がタプルと見なせない型であった場合、
-    - C++11 : 仕様で明確に規定されてはいないが、直接的にコンパイルエラーとなる
-    - C++17 : メンバ`value`が定義されない (SFINAEと組み合わせて扱える)
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
 
 
 ## 例
@@ -54,10 +62,8 @@ namespace std {
 
 int main()
 {
-  static_assert(std::tuple_size&amp;lt;               std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;const          std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;volatile       std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;const volatile std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
+  static_assert(std::tuple_size&amp;lt;      std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
+  static_assert(std::tuple_size&amp;lt;const std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
 }
 ```
 * std::tuple_size[color ff0000]
@@ -78,7 +84,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [LWG Issue 2770. `tuple_size&amp;lt;const T&amp;gt;` specialization is not SFINAE compatible and breaks decomposition declarations](https://wg21.cmeerw.net/lwg/issue2770)
     - C++17で[構造化束縛](/lang/cpp17/structured_bindings.md)機能が導入されたことに合わせて、`tuple_size`がSFINAEと組み合わせて使用できるようになった
 - [P0006R0 Adopt Type Traits Variable Templates from Library Fundamentals TS for C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0006r0.html)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- リンク再修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/common_iterator/op_equal.html"/>
      <id>6f54156cc0c6fb3bca0d599991ac82eabf84ff92:reference/iterator/common_iterator/op_equal.md</id>
      <updated>2020-11-25T15:41:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/common_iterator/op_equal.md b/reference/iterator/common_iterator/op_equal.md
index 0b35e9b51..3b44f3c51 100644
--- a/reference/iterator/common_iterator/op_equal.md
+++ b/reference/iterator/common_iterator/op_equal.md
@@ -22,7 +22,7 @@ namespace std {
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
-* equality_comparable_with[link /reference/concepts/equality_comparable_with.md]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
 
 ## 概要
 2つの`common_iterator`オブジェクトが同じ要素を指しているかを判定する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/common_iterator/op_equal.html"/>
      <id>d5c5a53c42f80bbf0db2677142fccbfd0f6cecfe:reference/iterator/common_iterator/op_equal.md</id>
      <updated>2020-11-25T15:38:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/common_iterator/op_equal.md b/reference/iterator/common_iterator/op_equal.md
index 40b39dc1b..0b35e9b51 100644
--- a/reference/iterator/common_iterator/op_equal.md
+++ b/reference/iterator/common_iterator/op_equal.md
@@ -22,7 +22,7 @@ namespace std {
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
-* equality_comparable_with[link /reference/iterator/equality_comparable_with.md]
+* equality_comparable_with[link /reference/concepts/equality_comparable_with.md]
 
 ## 概要
 2つの`common_iterator`オブジェクトが同じ要素を指しているかを判定する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- thread / packaged_task : 不要なdecayを削除</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/op_constructor.html"/>
      <id>a6d5a15cc5bf6f31df45dcccceb70f2fa71d1926:reference/future/packaged_task/op_constructor.md</id>
      <updated>2020-11-25T15:35:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/op_constructor.md b/reference/future/packaged_task/op_constructor.md
index ed3462d73..f70521e25 100644
--- a/reference/future/packaged_task/op_constructor.md
+++ b/reference/future/packaged_task/op_constructor.md
@@ -48,7 +48,7 @@ packaged_task(packaged_task&amp;amp;&amp;amp; rhs) noexcept;       // (5)
 
 ## 備考
 - (2), (3) :
-    - C++14 : [`std::decay`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;::type`が`std::packaged_task&amp;lt;R(ArgTypes...)&amp;gt;`型である場合、この関数はオーバーロード解決に参加しない。
+    - C++14 : [`std::remove_cvref`](/reference/type_traits/remove_cvref.md)`&amp;lt;F&amp;gt;::type`が`std::packaged_task&amp;lt;R(ArgTypes...)&amp;gt;`型である場合、この関数はオーバーロード解決に参加しない。
 
 
 ## 例
@@ -116,3 +116,4 @@ int main()
 - [LWG Issue 2097. `packaged_task` constructors should be constrained](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2097)
 - [LWG Issue 2921. `packaged_task` and type-erased allocators](https://wg21.cmeerw.net/lwg/issue2921)
     - [`std::function`のコンストラクタ](/reference/functional/function/op_constructor.md)と同様の理由により、アロケータを受け取るコンストラクタを削除
+- [LWG Issue 3039. Unnecessary `decay` in `thread` and `packaged_task`](https://wg21.cmeerw.net/lwg/issue3039)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- thread / packaged_task : 不要なdecayを削除</title>
      <link href="https://cpprefjp.github.io/reference/thread/thread/op_constructor.html"/>
      <id>a6d5a15cc5bf6f31df45dcccceb70f2fa71d1926:reference/thread/thread/op_constructor.md</id>
      <updated>2020-11-25T15:35:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/thread/thread/op_constructor.md b/reference/thread/thread/op_constructor.md
index 10cba0c98..b3a740980 100644
--- a/reference/thread/thread/op_constructor.md
+++ b/reference/thread/thread/op_constructor.md
@@ -53,7 +53,7 @@ thread(thread&amp;amp;&amp;amp;) noexcept;              // (4)
 
 ## 備考
 - (2) :
-    - C++14 : [`std::decay`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;::type`が`std::thread`型である場合、この関数はオーバーロード解決に参加しない。
+    - C++14 : [`std::remove_cvref`](/reference/type_traits/remove_cvref.md)`&amp;lt;F&amp;gt;::type`が`std::thread`型である場合、この関数はオーバーロード解決に参加しない。
 
 
 ## 例
@@ -111,4 +111,4 @@ int main()
 
 ## 参照
 - [LWG Issue 2097. `packaged_task` constructors should be constrained](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2097)
-
+- [LWG Issue 3039. Unnecessary `decay` in `thread` and `packaged_task`](https://wg21.cmeerw.net/lwg/issue3039)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_iterator -- common_iterator : ==追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/common_iterator.html"/>
      <id>a266fd7718be32a5972f8070f6fd54fb69115272:reference/iterator/common_iterator.md</id>
      <updated>2020-11-25T15:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/common_iterator.md b/reference/iterator/common_iterator.md
index 4ab53bf6c..b16b6366a 100644
--- a/reference/iterator/common_iterator.md
+++ b/reference/iterator/common_iterator.md
@@ -63,7 +63,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |------------------------------------------------------|-------------|-------|
-| [`operator==`](common_iterator/op_equal.md.nolink)         | 等値比較 | C++20 |
+| [`operator==`](common_iterator/op_equal.md)         | 等値比較 | C++20 |
 | `operator!=`     | 非等値比較 (`==`により使用可能) | C++20 |
 | [`operator-`](common_iterator/op_minus.md.nolink)          | 2つの`common_iterator`の差を求める | C++20 |
 | [`iter_move`](common_iterator/iter_move.md.nolink)     | イテレータの要素の移動 | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- common_iterator : ==追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/common_iterator/op_equal.html"/>
      <id>a266fd7718be32a5972f8070f6fd54fb69115272:reference/iterator/common_iterator/op_equal.md</id>
      <updated>2020-11-25T15:32:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/common_iterator/op_equal.md b/reference/iterator/common_iterator/op_equal.md
new file mode 100644
index 000000000..40b39dc1b
--- /dev/null
+++ b/reference/iterator/common_iterator/op_equal.md
@@ -0,0 +1,111 @@
+# operator==
+* iterator[meta header]
+* std[meta namespace]
+* common_iterator[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;input_or_output_iterator I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  class common_iterator {
+
+    template&amp;lt;class I2, sentinel_for&amp;lt;I&amp;gt; S2&amp;gt;
+      requires sentinel_for&amp;lt;S, I2&amp;gt;
+    friend bool operator==(const common_iterator&amp;amp; x, const common_iterator&amp;lt;I2, S2&amp;gt;&amp;amp; y);   // (1)
+
+    template&amp;lt;class I2, sentinel_for&amp;lt;I&amp;gt; S2&amp;gt;
+      requires sentinel_for&amp;lt;S, I2&amp;gt; &amp;amp;&amp;amp; equality_comparable_with&amp;lt;I, I2&amp;gt;
+    friend bool operator==(const common_iterator&amp;amp; x, const common_iterator&amp;lt;I2, S2&amp;gt;&amp;amp; y);   // (2)
+  };
+}
+```
+* input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* equality_comparable_with[link /reference/iterator/equality_comparable_with.md]
+
+## 概要
+2つの`common_iterator`オブジェクトが同じ要素を指しているかを判定する。
+
+## 事前条件
+
+`x.v_.`[`valueless_by_exception`](/reference/variant/variant/valueless_by_exception)`()`、`y.v_.`[`valueless_by_exception`](/reference/variant/variant/valueless_by_exception)`()`はどちらも`false`であること。
+
+## 戻り値
+
+`I, S`（`I2, S2`）の値のどちらかを[`variant&amp;lt;I, S&amp;gt;`](/reference/variant/variant.md)型のメンバ変数`_v`に保持しており、`i = x.v_.`[`index()`](/reference/variant/variant/index.md)、`j = y.v_.`[`index()`](/reference/variant/variant/index.md)として
+
+- (1)
+    - `i == j`の場合 : `true`
+    - それ以外の場合 : `get&amp;lt;i&amp;gt;(x.v_) == get&amp;lt;j&amp;gt;(y.v_)`
+- (2)
+    - `i, j`がどちらも`1`の場合 : `true`
+    - それ以外の場合 : `get&amp;lt;i&amp;gt;(x.v_) == get&amp;lt;j&amp;gt;(y.v_)`
+
+
+## 備考
+
+C++20以降、これらの演算子により以下の演算子が使用可能になる（制約は使用する`==`に準ずる）。
+
+```cpp
+template&amp;lt;class I2, sentinel_for&amp;lt;I&amp;gt; S2&amp;gt;
+friend bool operator==(const common_iterator&amp;lt;I2, S2&amp;gt;&amp;amp; y, const common_iterator&amp;amp; x);
+
+template&amp;lt;class I2, sentinel_for&amp;lt;I&amp;gt; S2&amp;gt;
+friend bool operator!=(const common_iterator&amp;amp; x, const common_iterator&amp;lt;I2, S2&amp;gt;&amp;amp; y);
+
+template&amp;lt;class I2, sentinel_for&amp;lt;I&amp;gt; S2&amp;gt;
+friend bool operator!=(const common_iterator&amp;lt;I2, S2&amp;gt;&amp;amp; y, const common_iterator&amp;amp; x);
+```
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;ranges&amp;gt;
+
+int main() {
+  auto seq = std::views::iota(1) | std::views::take(5);
+
+  // common_iteratorを通すことでイテレータ型と番兵型を合わせる
+  using CI = std::common_iterator&amp;lt;std::ranges::iterator_t&amp;lt;decltype(seq)&amp;gt;, std::ranges::sentinel_t&amp;lt;decltype(seq)&amp;gt;&amp;gt;;
+
+  CI ci{std::ranges::begin(seq)};
+  CI ce{std::ranges::end(seq)};
+  auto ci2 = ci++;
+  
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  
+  std::cout &amp;lt;&amp;lt; (ci == ci2) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (ci == ce) &amp;lt;&amp;lt; std::endl;
+
+  // ==から導出される!=
+  std::cout &amp;lt;&amp;lt; (ci != ci2) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (ci != ce) &amp;lt;&amp;lt; std::endl;
+}
+```
+* views::iota[link /reference/ranges/iota_view.md.nolink]
+* views::take[link /reference/ranges/take_view.md.nolink]
+* iterator_t[link /reference/ranges/iterator_t.md.nolink]
+* sentinel_t[link /reference/ranges/sentinel_t.md.nolink]
+* ranges::begin[link /reference/ranges/begin.md.nolink]
+
+### 出力
+```
+false
+false
+true
+true
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 9
+
+## 参照
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>