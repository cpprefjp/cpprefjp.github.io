<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-09-01T14:47:15.614713</updated>
  <id>b1aed8f7-ee08-44b4-9f5c-d8f35c5503f9</id>

  
    <entry>
      <title>丸カッコの値リストからの集成体初期化を許可 -- Fix typo</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html"/>
      <id>575f23515bd7eb3e021942cbb3d49c465650c9cf:lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md</id>
      <updated>2020-09-01T23:43:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
index eaac54322..e02fd183d 100644
--- a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
+++ b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
@@ -31,7 +31,7 @@ A aa[]((1, 2), (3, 4), (5, 6));
 * 波カッコによる初期化では縮小変換ができないが、丸カッコによる初期化ではできる。
 * 参照型のメンバへ一時オブジェクトをバインドするとき、波カッコによる初期化では寿命が延長されるが、丸カッコによる初期化では延長されない。
 
-ただし、各要素の評価準は左から右に評価される。この点は波カッコと同じになっている。
+ただし、各要素は左から右に評価される。この点は波カッコと同じになっている。
 
 ```cpp
 // P0960R3より引用
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>契約に基づくプログラミング -- Update contract-based_programming.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/contract-based_programming.html"/>
      <id>ddbc8fae8edeabbd6d35c4be03d7cb6507d8ae80:lang/cpp23/contract-based_programming.md</id>
      <updated>2020-08-31T10:03:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/contract-based_programming.md b/lang/cpp23/contract-based_programming.md
index a976fd458..e9b84b75b 100644
--- a/lang/cpp23/contract-based_programming.md
+++ b/lang/cpp23/contract-based_programming.md
@@ -126,7 +126,7 @@ C++20では、プログラムのコンパイルは次の3つのうちどれか
 * `audit`: 契約レベルが`default`または`audit`の契約がチェックされる。
 
 ビルドレベルを指定する方法は処理系定義である。ただし、ソースコード上で指定する方法は提供されない。
-
+`constexpr`などの定数表現評価では、チェックされた契約のみが評価される。
 チェックされない契約が評価されるかは未規定である。`false`に評価される場合の動作は未定義である。
 
 ### 違反ハンドラーと違反継続モード
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>MITSUNARI Shigeo</name>
        <email>herumi@nifty.com</email>
      </author>
    </entry>
  
    <entry>
      <title>if文とswitch文の条件式と初期化を分離 -- Update selection_statements_with_initializer.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/selection_statements_with_initializer.html"/>
      <id>33b05b121f9bc98db7d90ee4aad1e676dfb8fca9:lang/cpp17/selection_statements_with_initializer.md</id>
      <updated>2020-08-30T01:33:20+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/selection_statements_with_initializer.md b/lang/cpp17/selection_statements_with_initializer.md
index 426d69c28..831b706ce 100644
--- a/lang/cpp17/selection_statements_with_initializer.md
+++ b/lang/cpp17/selection_statements_with_initializer.md
@@ -136,9 +136,16 @@ if (std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mx); shared_flag) { unsafe_ping(); shared_f
 ## この機能が必要になった背景・経緯
 
 変数の宣言あるいは初期化を行い、`if`文や`switch`文のスコープ内だけで変数を使用するケースは多数あるにも関わらず、
-`if`文や`switch`文に初期化を行う記法は存在しなかった。
+`if`文や`switch`文で行える宣言は限定的だった。
+具体的には、単一かつ配列ではない変数しか宣言できず、その変数の初期値が条件になってしまうので、変数を宣言したうえで別の式を条件にすることはできなかった。
 
-C++14まででも同様の意味を持つ記述は不可能ではないが、外側にスコープを追加する必要があり冗長な記述になっていた:
+```cpp
+// ポインターを受け取ってnullチェックをするパターンは、C++14まででもよく見かけた。
+// しかし、この条件を反転(nullptrのとき真)することさえ不可能であった。
+if (auto* p = get_some_object()) { ... } // pがnullptrでなければ真
+```
+
+C++14まででも初期化付きの条件分岐と同様の意味を持つ記述は不可能ではないが、外側にスコープを追加する必要があり冗長な記述になっていた:
 
 ```cpp
 status_code foo() {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait_until -- condition_variable_any/wait_until: 表示崩れ修正</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait_until.html"/>
      <id>b8513fc03a4fa9bdd65d69b3d389901431a92072:reference/condition_variable/condition_variable_any/wait_until.md</id>
      <updated>2020-08-28T15:24:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait_until.md b/reference/condition_variable/condition_variable_any/wait_until.md
index e24515bb0..bfc26b988 100644
--- a/reference/condition_variable/condition_variable_any/wait_until.md
+++ b/reference/condition_variable/condition_variable_any/wait_until.md
@@ -42,7 +42,7 @@ bool wait_until(Lock&amp;amp; lock,
 
 ## 効果
 - (1) :
-    - アトミックに`lock.[unlock()](/reference/mutex/unique_lock/unlock.md)`する
+    - アトミックに`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)する
     - [`notify_one()`](notify_one.md)/[`notify_all()`](notify_all.md)による通知、`abs_time`によって指定された時間に到達したことによる期限切れ、もしくはなんらかの理由によって失敗するまでブロッキングする
     - この関数を抜ける際に`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)する
     - この関数が例外送出によって終了する場合、関数を抜ける前に`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>