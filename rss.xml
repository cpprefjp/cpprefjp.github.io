<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-11-08T10:33:18.619104</updated>
  <id>ea288b35-df53-4f21-8c8b-a5e276daad28</id>

  
    <entry>
      <title>符号付き整数型が2の補数表現であることを規定 -- cpp20/signed_integers_are_twos_complement: シフト演算の説明増補</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html"/>
      <id>4a452247e2cf759ffd06ca8f6050d59afee6d91d:lang/cpp20/signed_integers_are_twos_complement.md</id>
      <updated>2021-11-08T19:27:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/signed_integers_are_twos_complement.md b/lang/cpp20/signed_integers_are_twos_complement.md
index 737b283e6..125151a46 100644
--- a/lang/cpp20/signed_integers_are_twos_complement.md
+++ b/lang/cpp20/signed_integers_are_twos_complement.md
@@ -8,9 +8,11 @@ C++20では、符号付き整数型のビット表現を「2の補数 (Two&amp;#39;s Com
 
 値`-0`は、`0`を意味する。
 
-符号付き整数型に対する右シフトは「符号拡張 (sign extension)」を行い、符号ビットが右に伝播する。
+符号付き整数型に対する左シフト`&amp;lt;&amp;lt;`は[論理シフト(Logical shift)](https://en.wikipedia.org/wiki/Logical_shift)となる。対応する符号無し整数型における左シフト演算とビット表現が等しい結果が得られる。
 
-ただし、符号付き整数型のオーバーフロー時の動作は、これまでと変わらず未定義動作である。[`std::numeric_limits`](/reference/limits/numeric_limits.md)`&amp;lt;符号付き整数型&amp;gt;::`[`is_modulo`](/reference/limits/numeric_limits/is_modulo.md)はデフォルトで`false`のままとなる。
+符号付き整数型に対する右シフト`&amp;gt;&amp;gt;`は[算術シフト(Arithmetic shift)](https://en.wikipedia.org/wiki/Arithmetic_shift)となる。右シフトでは「符号拡張 (sign extension)」が行われ、符号ビットが右に伝播する。
+
+ただし、符号付き整数型に対する算術演算におけるオーバーフロー時の動作は、これまでと変わらず未定義動作である。[`std::numeric_limits`](/reference/limits/numeric_limits.md)`&amp;lt;符号付き整数型&amp;gt;::`[`is_modulo`](/reference/limits/numeric_limits/is_modulo.md)はデフォルトで`false`のままとなる。
 
 
 ## 備考
@@ -43,13 +45,24 @@ int main()
     assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b0000&amp;#39;0000));
     assert(y == static_cast&amp;lt;std::int8_t&amp;gt;(0b0000&amp;#39;0000));
   }
-  // 右シフト時の符号拡張
+  // 論理左シフト演算
+  {
+    std::int8_t x = 64;
+    assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b0100&amp;#39;0000));
+
+    x &amp;lt;&amp;lt;= 1;
+
+    assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(-128));
+    assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b1000&amp;#39;0000));
+  }
+  // 算術右シフト演算
   {
     std::int8_t x = -124;
     assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b1000&amp;#39;0100));
 
     x &amp;gt;&amp;gt;= 2;
 
+    assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(-31));
     assert(x == static_cast&amp;lt;std::int8_t&amp;gt;(0b1110&amp;#39;0001));
   }
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>符号付き整数型が2の補数表現であることを規定 -- cpp20/signed_integers_are_twos_complement: P0907R3 -&gt; R4</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/signed_integers_are_twos_complement.html"/>
      <id>d959de9d5074b09659624dd9f2d7328eea2bf907:lang/cpp20/signed_integers_are_twos_complement.md</id>
      <updated>2021-11-08T13:50:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/signed_integers_are_twos_complement.md b/lang/cpp20/signed_integers_are_twos_complement.md
index 7eda67748..737b283e6 100644
--- a/lang/cpp20/signed_integers_are_twos_complement.md
+++ b/lang/cpp20/signed_integers_are_twos_complement.md
@@ -124,7 +124,7 @@ C11規格は、2の補数のほかに、1の補数表現 (Ones&amp;#39; complement) と
 ## 参照
 - [P1236R1: Alternative Wording for P0907R4 Signed Integers are Two&amp;#39;s Complement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1236r1.html)
     - C++20に採択された提案文書
-- [P0907R3 Signed Integers are Two&amp;#39;s Complement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r3.html)
+- [P0907R4 Signed Integers are Two&amp;#39;s Complement](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r4.html)
     - 元になった提案文書
 - [符号付き整数型の負数表現を 2 の補数と規定 (P1236R1) - cppmap](https://cppmap.github.io/standardization/cpp20/#2-p1236r1)
 - [2の補数表現における演算](http://www.cc.kyoto-su.ac.jp/~kbys/kiso/number/int-op.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_chars -- Merge pull request #914 from sozysozbot/patch-1</title>
      <link href="https://cpprefjp.github.io/reference/charconv/from_chars.html"/>
      <id>0a6b8f376a652c73c66f9c8cdcf7c375e1433af9:reference/charconv/from_chars.md</id>
      <updated>2021-11-05T03:37:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/from_chars.md b/reference/charconv/from_chars.md
index 9e3026d11..54c5e3dea 100644
--- a/reference/charconv/from_chars.md
+++ b/reference/charconv/from_chars.md
@@ -21,13 +21,13 @@ namespace std {
 ```
 
 ## 概要
-与えられた`[fisrt, last)`内の文字列から、オーバーロードと基数・フォーマット指定によって決まるパターンにマッチングする最初の数字文字列を見つけて、数値へ変換する。  
+与えられた`[first, last)`内の文字列から、オーバーロードと基数・フォーマット指定によって決まるパターンにマッチングする最初の数字文字列を見つけて、数値へ変換する。  
 変換に際し、メモリ確保を行わず例外を投げることもない。
 
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
 ## 要件
-- 全て : 出力範囲`[fisrt, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
+- 全て : 出力範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
 - (2)～(4)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
@@ -39,7 +39,7 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 - `fmt` -- 入力文字列の浮動小数点数のフォーマット指定、[`chars_format`](../charconv/chars_format.md)のいずれか。
 
 ## 効果
-- 全て : `[fisrt, last)`からパターンにマッチする文字列を探し、それを変換した数値を`value`に書き込む。  
+- 全て : `[first, last)`からパターンにマッチする文字列を探し、それを変換した数値を`value`に書き込む。  
     数字列の前にあって良いのは`-`符号のみである（`+`やスペース含めてその他の文字から始まる場合は必ず失敗する）。  
     数字列の途中でスペースが現れた場合、そこでマッチングは終了する（数字列中のスペース読み飛ばしをしない）。
     
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Mitama</name>
        <email>yussa.de.dannann@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>to_chars -- Merge pull request #914 from sozysozbot/patch-1</title>
      <link href="https://cpprefjp.github.io/reference/charconv/to_chars.html"/>
      <id>0a6b8f376a652c73c66f9c8cdcf7c375e1433af9:reference/charconv/to_chars.md</id>
      <updated>2021-11-05T03:37:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/to_chars.md b/reference/charconv/to_chars.md
index 2b983f1be..fef05dad3 100644
--- a/reference/charconv/to_chars.md
+++ b/reference/charconv/to_chars.md
@@ -35,13 +35,13 @@ namespace std {
 ```
 
 ## 概要
-与えられた数値（`value`）を文字列へ変換し、`[fisrt, last)`内へ出力する。  
+与えられた数値（`value`）を文字列へ変換し、`[first, last)`内へ出力する。  
 変換に際し、メモリ確保を行わず例外を投げることもない。
 
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
 ## 要件
-- 全て : 出力範囲`[fisrt, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
+- 全て : 出力範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
 - (5)～(10)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
@@ -54,8 +54,8 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 - `precision` -- 浮動小数点数の出力精度（小数点以下の桁数）指定、`printf`において`%.nf, %.ne`などとしたときの`n`にあたる。
 
 ## 効果
-- 全て : `value`の値を文字列へ変換し、結果文字列を`[fisrt, last)`に書き込む。  
-    出力文字列が`[fisrt, last)`に収まらない場合は失敗する。
+- 全て : `value`の値を文字列へ変換し、結果文字列を`[first, last)`に書き込む。  
+    出力文字列が`[first, last)`に収まらない場合は失敗する。
 
 - (1) : `base`の値をnとすると、整数値をn進数の文字列へ変換する（ `value`が負なら`-`が先頭に付く）。  
     10 &amp;lt; nの場合、10～35の値はアルファベットの小文字a～zがあてられる。  
@@ -75,7 +75,7 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 
 なお、[`from_chars`](../charconv/from_chars.md)関数によって値を正確に復元できるのは両関数が同じ処理系で提供されているときにのみ保証される。
 
-全てのオーバーロードにおいて、変換に失敗した場合の`[fisrt, last)`の状態は未規定。
+全てのオーバーロードにおいて、変換に失敗した場合の`[first, last)`の状態は未規定。
 
 ## 戻り値
 [`to_chars_result`](../charconv/to_chars_result.md)の値。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Mitama</name>
        <email>yussa.de.dannann@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_chars -- Even more `fisrt` → `first`</title>
      <link href="https://cpprefjp.github.io/reference/charconv/from_chars.html"/>
      <id>48b554e9b510ee944ace7cf8e4ed6c73b0d1966d:reference/charconv/from_chars.md</id>
      <updated>2021-11-05T02:50:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/from_chars.md b/reference/charconv/from_chars.md
index 9e3026d11..54c5e3dea 100644
--- a/reference/charconv/from_chars.md
+++ b/reference/charconv/from_chars.md
@@ -21,13 +21,13 @@ namespace std {
 ```
 
 ## 概要
-与えられた`[fisrt, last)`内の文字列から、オーバーロードと基数・フォーマット指定によって決まるパターンにマッチングする最初の数字文字列を見つけて、数値へ変換する。  
+与えられた`[first, last)`内の文字列から、オーバーロードと基数・フォーマット指定によって決まるパターンにマッチングする最初の数字文字列を見つけて、数値へ変換する。  
 変換に際し、メモリ確保を行わず例外を投げることもない。
 
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
 ## 要件
-- 全て : 出力範囲`[fisrt, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
+- 全て : 出力範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
 - (2)～(4)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
@@ -39,7 +39,7 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 - `fmt` -- 入力文字列の浮動小数点数のフォーマット指定、[`chars_format`](../charconv/chars_format.md)のいずれか。
 
 ## 効果
-- 全て : `[fisrt, last)`からパターンにマッチする文字列を探し、それを変換した数値を`value`に書き込む。  
+- 全て : `[first, last)`からパターンにマッチする文字列を探し、それを変換した数値を`value`に書き込む。  
     数字列の前にあって良いのは`-`符号のみである（`+`やスペース含めてその他の文字から始まる場合は必ず失敗する）。  
     数字列の途中でスペースが現れた場合、そこでマッチングは終了する（数字列中のスペース読み飛ばしをしない）。
     
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>sozysozbot</name>
        <email>sozysozbot@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>to_chars -- More `fisrt` → `first`</title>
      <link href="https://cpprefjp.github.io/reference/charconv/to_chars.html"/>
      <id>d80b656593d632dbe76abb5063e6ab52a0821b57:reference/charconv/to_chars.md</id>
      <updated>2021-11-05T02:43:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/to_chars.md b/reference/charconv/to_chars.md
index 866b0ddcc..fef05dad3 100644
--- a/reference/charconv/to_chars.md
+++ b/reference/charconv/to_chars.md
@@ -41,7 +41,7 @@ namespace std {
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
 ## 要件
-- 全て : 出力範囲`[fisrt, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
+- 全て : 出力範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
 - (5)～(10)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
@@ -54,8 +54,8 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 - `precision` -- 浮動小数点数の出力精度（小数点以下の桁数）指定、`printf`において`%.nf, %.ne`などとしたときの`n`にあたる。
 
 ## 効果
-- 全て : `value`の値を文字列へ変換し、結果文字列を`[fisrt, last)`に書き込む。  
-    出力文字列が`[fisrt, last)`に収まらない場合は失敗する。
+- 全て : `value`の値を文字列へ変換し、結果文字列を`[first, last)`に書き込む。  
+    出力文字列が`[first, last)`に収まらない場合は失敗する。
 
 - (1) : `base`の値をnとすると、整数値をn進数の文字列へ変換する（ `value`が負なら`-`が先頭に付く）。  
     10 &amp;lt; nの場合、10～35の値はアルファベットの小文字a～zがあてられる。  
@@ -75,7 +75,7 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 
 なお、[`from_chars`](../charconv/from_chars.md)関数によって値を正確に復元できるのは両関数が同じ処理系で提供されているときにのみ保証される。
 
-全てのオーバーロードにおいて、変換に失敗した場合の`[fisrt, last)`の状態は未規定。
+全てのオーバーロードにおいて、変換に失敗した場合の`[first, last)`の状態は未規定。
 
 ## 戻り値
 [`to_chars_result`](../charconv/to_chars_result.md)の値。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>sozysozbot</name>
        <email>sozysozbot@gmail.com</email>
      </author>
    </entry>
  
</feed>