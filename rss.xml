<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-15T07:48:08.062818</updated>
  <id>7a98e671-ada5-4410-b6be-163d3503c22b</id>

  
    <entry>
      <title>epsilon -- fix external link (close #1123)</title>
      <link href="https://cpprefjp.github.io/reference/limits/numeric_limits/epsilon.html"/>
      <id>8203fdd4e47fe92368e78d40c7821cb1d6bae2b9:reference/limits/numeric_limits/epsilon.md</id>
      <updated>2023-02-15T11:56:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/limits/numeric_limits/epsilon.md b/reference/limits/numeric_limits/epsilon.md
index 9f969b62c..3af48f808 100644
--- a/reference/limits/numeric_limits/epsilon.md
+++ b/reference/limits/numeric_limits/epsilon.md
@@ -57,7 +57,7 @@ equal
 ```
 
 ## 参照
-- [C++ FAQ - Why doesn&amp;#39;t my floating-point comparison work?](http://www.cs.technion.ac.il/users/yechiel/c++-faq/floating-point-arith.html)
+- [C++ FAQ - Why doesn&amp;#39;t my floating-point comparison work?](https://isocpp.org/wiki/faq/newbie#floating-point-arith)
 - [Comparing Floating Point Numbers, 2012 Edition](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/)
 - [浮動小数比較の落とし穴 - trinoの走り書き](http://d.hatena.ne.jp/n-trino/20161101#p1)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>expected -- expected/expected: 最低限の説明増補(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/expected.html"/>
      <id>1bcaedc52902daf98f55025838c8ea628714af70:reference/expected/expected.md</id>
      <updated>2023-02-11T20:28:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/expected.md b/reference/expected/expected.md
index 8e3940398..23da5b514 100644
--- a/reference/expected/expected.md
+++ b/reference/expected/expected.md
@@ -21,10 +21,16 @@ namespace std {
 ## 概要
 `expected`クラスは、任意の型`T`の値を正常値とし任意の型`E`の値をエラー値として、正常もしくはエラーいずれかの状態を取ることを値として表現できる型である。
 
+このクラスは、ヒープからの動的メモリ確保を行わない。
+実装は配置newのような機能によって、スタック領域のメモリのみを使用する。
+
 
 ## 適格要件
 
+- 型`T`および型`E`は、参照型、関数型、[`in_place_t`](/reference/utility/in_place_t.md)、[`unexpect_t`](unexpect_t.md)のいずれでもないこと。
+- 型`T`は[`unexpected`](unexpected.md)の特殊化ではないこと。
 - 型`T`が（CV修飾された）`void`型でなければ、型`T`はCpp17Destructible要件を満たすこと。
+- 型`E`は非オブジェクト型、配列型、`unexpected`の特殊化、CV修飾された型のいずれでもないこと。
 - 型`E`はCpp17Destructible要件を満たすこと。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unexpected -- expected/expected: 最低限の説明増補(#1066)</title>
      <link href="https://cpprefjp.github.io/reference/expected/unexpected.html"/>
      <id>1bcaedc52902daf98f55025838c8ea628714af70:reference/expected/unexpected.md</id>
      <updated>2023-02-11T20:28:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/unexpected.md b/reference/expected/unexpected.md
index e0dc8715d..6e8f00f67 100644
--- a/reference/expected/unexpected.md
+++ b/reference/expected/unexpected.md
@@ -16,7 +16,7 @@ namespace std {
 
 
 ## 適格要件
-`E`は非オブジェクト型、配列型、`unexpected&amp;lt;U&amp;gt;`、CV修飾された型のいずれでもないこと。
+型`E`は非オブジェクト型、配列型、`unexpected`の特殊化、CV修飾された型のいずれでもないこと。
 
 
 ## メンバ関数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>take_view -- take_view : 箇条書きのネスト修正</title>
      <link href="https://cpprefjp.github.io/reference/ranges/take_view.html"/>
      <id>d6efda15a80acb4f8c394c4ea3d970d80a4d2192:reference/ranges/take_view.md</id>
      <updated>2023-02-10T18:08:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/take_view.md b/reference/ranges/take_view.md
index 23008c588..cac570185 100644
--- a/reference/ranges/take_view.md
+++ b/reference/ranges/take_view.md
@@ -106,11 +106,11 @@ int main() {
 1. `take_view`イテレータのインクリメント
     1. `take_view`内部カウンタの減算
     2. [`filter_view`](filter_view.md)のイテレータのインクリメント
-      1. 条件を満たす次の要素の探索
-        - 条件を満たす要素が見つかるまで、`iota_view`イテレータをインクリメントする
-          1. `iota_view`イテレータのインクリメント
-            - 増分1で整数値を生成、この場合は終端がない
-          2. `iota_view`生成値の読み取りと条件チェック
+        1. 条件を満たす次の要素の探索
+            - 条件を満たす要素が見つかるまで、`iota_view`イテレータをインクリメントする
+                1. `iota_view`イテレータのインクリメント
+                    - 増分1で整数値を生成、この場合は終端がない
+                2. `iota_view`生成値の読み取りと条件チェック
 
 `views::iota(0)`によるシーケンスは0始まりの整数の無限列であり、`filter_view`のフィルタ条件（`return i &amp;lt; 10`）は10未満の整数値のみを取り出すものである。したがってこの場合、`iota_view`が10を生成して以降は`filter_view`で条件を満たす要素は存在しなくなる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>take_view -- take_view : bidirectional以下の入力に対する注意を追記</title>
      <link href="https://cpprefjp.github.io/reference/ranges/take_view.html"/>
      <id>6a05dbbaea2d5e7472bd2ff832b2d36fcf520780:reference/ranges/take_view.md</id>
      <updated>2023-02-10T17:58:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/take_view.md b/reference/ranges/take_view.md
index 2348faa48..23008c588 100644
--- a/reference/ranges/take_view.md
+++ b/reference/ranges/take_view.md
@@ -78,6 +78,70 @@ namespace std::ranges {
 |-------------------------------------------------------|------------------------------|----------------|
 | [`(deduction_guide)`](take_view/op_deduction_guide.md.nolink) | クラステンプレートの推論補助 | C++20          |
 
+## 使用上の注意
+
+この`view`（及びRangeアダプタ）は、入力が[`random_access_range`](random_access_range.md)ではない場合に意図しない無限ループに陥ることがある
+
+```cpp
+int main() {
+  for (auto i  : std::views::iota(0)
+               | std::views::filter([](auto i) { return i &amp;lt; 10; })
+               | std::views::take(10))
+  {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+  }
+}
+```
+
+このコードは0から9までの数字を出力するだけのループに見えるが、実行すると無限ループに陥るか完了までに多大な時間を要する。
+
+範囲`for`文は内部でイテレータを用いた通常`for`文に展開されており、1つのループの終わりでは次の様な順番でループのための処理が行われている
+
+1. イテレータのインクリメント
+2. イテレータの終端チェック
+3. ループ本体実行
+
+この例における1では、次の様なことが起きている
+
+1. `take_view`イテレータのインクリメント
+    1. `take_view`内部カウンタの減算
+    2. [`filter_view`](filter_view.md)のイテレータのインクリメント
+      1. 条件を満たす次の要素の探索
+        - 条件を満たす要素が見つかるまで、`iota_view`イテレータをインクリメントする
+          1. `iota_view`イテレータのインクリメント
+            - 増分1で整数値を生成、この場合は終端がない
+          2. `iota_view`生成値の読み取りと条件チェック
+
+`views::iota(0)`によるシーケンスは0始まりの整数の無限列であり、`filter_view`のフィルタ条件（`return i &amp;lt; 10`）は10未満の整数値のみを取り出すものである。したがってこの場合、`iota_view`が10を生成して以降は`filter_view`で条件を満たす要素は存在しなくなる。
+
+ループの最終端、本体処理が9を出力した後のループ終了直前には、`take_view`の内部カウンタが0になり`take_view`の終了条件が満たされるものの、その直後に内部イテレータ（`filter_view`のイテレータ）をインクリメントしてしまう。`filter_view`のイテレータはインクリメントによって10未満の次の要素を探索するために`iota_view`のイテレータをインクリメントし、`iota_view`は10以降の整数値をひたすら生成し続ける。
+
+この例の`iota_view`の要素型は符号付き整数型であるため、そのオーバーフローは未定義動作となり、このループが終了するかどうかは保証されない。
+
+入力に対して`filter_view`の条件の与え方が悪いという見方もできるが、これは`take_view`イテレータのインクリメント時に起こることに問題があり、`take_view`のイテレータは入力が[`random_access_range`](random_access_range.md)ではない場合は[`counted_iterator`](/reference/iterator/counted_iterator.md)を使用するため、本質的には`counted_iterator`の問題である。
+
+`counted_iterator`はインクリメント時にカウンタ値を減算してからラップしているイテレータをインクリメントするが、カウンタ値を考慮せず常にインクリメントを行うため`counted_iterator`の内部カウンタが0になりその終了条件が満たされた時でもラップするイテレータをインクリメントしてしまう。そのため、`filter_view`イテレータのようにそのイテレータ取得時点で終端が確定していないイテレータを入力として使用すると、その終端でこのような問題が起こりうる。
+
+特に、`input_iterator`では、イテレータがその範囲の終端に達した後でインクリメントしてしまうと何が起こるかわからないため、この問題はより複雑な形で顕在化する可能性がある。
+
+```cpp
+int main() {
+  // 入力ストリームには整数値1つしかない
+  auto iss = std::istringstream(&amp;#34;0&amp;#34;);
+
+  // 0を読んだ後、takeイテレータが進行するが、istream_viewが次のストリーム入力を待機するために終了しない
+  for (auto i : std::ranges::istream_view&amp;lt;int&amp;gt;(iss)
+              | std::views::take(1))
+  {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+  }
+}
+```
+
+この例では、`istream_view`の基底のストリームに追加の要素が入力されるか、ストリームが閉じられるまで`istream_view`のイテレータはインクリメント時に次の要素の入力を待機し続けてしまう。より一般的な`input_iterator`ではどうなるかわからない。
+
+ただし、`take_view`は入力範囲が`random_access_range`の場合は`counted_iterator`を使用しないため、`random_access_range`に対して使用する場合はこの問題は起こらない。
+
 ## 例
 ```cpp example
 #include &amp;lt;ranges&amp;gt;
@@ -113,3 +177,4 @@ int main() {
 - [N4861 24 Ranges library](https://timsong-cpp.github.io/cppwp/n4861/ranges)
 - [C++20 ranges](https://techbookfest.org/product/5134506308665344)
 - [P2367R0 Remove misuses of list-initialization from Clause 24](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2367r0.html) (本提案文書はC++20に遡って適用されている)
+- [P2406R2 Add `lazy_counted_iterator`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2406r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>