<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-03-20T02:51:08.579640</updated>
  <id>560c9dd9-2e8d-4427-818d-9eff5b3607d6</id>

  
    <entry>
      <title>equal_range -- 名前空間を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>9fae6f9d5a26f6b554a74ce3bc25896b867c4b69:reference/algorithm/ranges_equal_range.md</id>
      <updated>2022-03-20T11:47:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index 7e3f762e6..83e73b1a4 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -5,7 +5,7 @@
 * cpp20[meta cpp]
 
 ```cpp
-namespace std {
+namespace std::ranges {
   template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
   constexpr subrange&amp;lt;I&amp;gt; equal_range(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index eff40d509..d0052caaf 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -371,13 +371,13 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`max_element`](algorithm/max_element.md)       | 範囲内の最大要素へのイテレータを取得する | |
 | [`minmax_element`](algorithm/minmax_element.md) | 範囲内の最小要素と最大要素へのイテレータを取得する | C++11 |
 | [`clamp`](algorithm/clamp.md)                   | 値を範囲内に収める | C++17 |
-| [`ranges::min`](algorithm/ranges_min.md.nolink)                       | 最小値を取得する                                   | C++20 |
-| [`ranges::max`](algorithm/ranges_max.md.nolink)                       | 最大値を取得する                                   | C++20 |
-| [`ranges::minmax`](algorithm/ranges_minmax.md.nolink)                 | 最小値と最大値を取得する                           | C++20 |
-| [`ranges::min_element`](algorithm/ranges_min_element.md.nolink)       | 範囲内の最小要素へのイテレータを取得する           | C++20 |
-| [`ranges::max_element`](algorithm/ranges_max_element.md.nolink)       | 範囲内の最大要素へのイテレータを取得する           | C++20 |
-| [`ranges::minmax_element`](algorithm/ranges_minmax_element.md.nolink) | 範囲内の最小要素と最大要素へのイテレータを取得する | C++20 |
-| [`ranges::clamp`](algorithm/ranges_clamp.md.nolink)                   | 値を範囲内に収める                                 | C++20 |
+| [`ranges::min`](algorithm/ranges_min.md)                       | 最小値を取得する                                   | C++20 |
+| [`ranges::max`](algorithm/ranges_max.md)                       | 最大値を取得する                                   | C++20 |
+| [`ranges::minmax`](algorithm/ranges_minmax.md)                 | 最小値と最大値を取得する                           | C++20 |
+| [`ranges::min_element`](algorithm/ranges_min_element.md)       | 範囲内の最小要素へのイテレータを取得する           | C++20 |
+| [`ranges::max_element`](algorithm/ranges_max_element.md)       | 範囲内の最大要素へのイテレータを取得する           | C++20 |
+| [`ranges::minmax_element`](algorithm/ranges_minmax_element.md) | 範囲内の最小要素と最大要素へのイテレータを取得する | C++20 |
+| [`ranges::clamp`](algorithm/ranges_clamp.md)                   | 値を範囲内に収める                                 | C++20 |
 
 ### 辞書式比較
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clamp -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_clamp.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_clamp.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_clamp.md b/reference/algorithm/ranges_clamp.md
new file mode 100644
index 000000000..732d1e6da
--- /dev/null
+++ b/reference/algorithm/ranges_clamp.md
@@ -0,0 +1,73 @@
+# clamp
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp; clamp(const T&amp;amp; v, const T&amp;amp; lo, const T&amp;amp; hi, Comp comp = {}, Proj proj = {});
+}
+```
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+
+## 概要
+値を範囲内に収める。
+
+この関数は、`v`の値を範囲`[low, high]`に収める。
+
+## 事前条件
+- `low`の値は`high`の値より大きくなってはならない
+
+## 戻り値
+- `v`の値が`low`より小さければ`low`を返す
+- `v`の値が`high`より大きければ`high`を返す
+- そうでなければ`v`を返す
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  for (int i = 0; i &amp;lt; 10; ++i) {
+    // iの値を範囲[2, 7]に収める
+    int result = std::ranges::clamp(i, 2, 7);
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::clamp[color ff0000]
+
+### 出力
+```
+0 : 2
+1 : 2
+2 : 2
+3 : 3
+4 : 4
+5 : 5
+6 : 6
+7 : 7
+8 : 7
+9 : 7
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_max.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max.md b/reference/algorithm/ranges_max.md
new file mode 100644
index 000000000..3c18d2a68
--- /dev/null
+++ b/reference/algorithm/ranges_max.md
@@ -0,0 +1,91 @@
+# max
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp; max(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {}); // (1)
+
+  template&amp;lt;copyable T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr T max(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});         // (2)
+
+  template&amp;lt;input_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  constexpr range_value_t&amp;lt;R&amp;gt; max(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});          // (3)
+}
+```
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* input_range[link /reference/ranges/input_range.md]
+* indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* range_value_t[link /reference/ranges/range_value_t.md]
+
+## 概要
+同じ型の2つの値、もしくは範囲によるN個の値のうち、最大値を取得する。
+
+## 戻り値
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最大と判断された最初の値
+
+## 備考
+- 等価な要素が 2 つ以上あった場合には、最も左の要素を返す。
+
+## 例
+```cpp example
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  constexpr int result1 = std::ranges::max(2, 3);
+  static_assert(result1 == 3);
+
+  constexpr int result2 = std::ranges::max(2, 3, std::ranges::greater());
+  static_assert(result2 == 2);
+
+  constexpr int result3 = std::ranges::max({1, 2, 3});
+  static_assert(result3 == 3);
+
+  constexpr std::array&amp;lt;int, 3&amp;gt; a = {1, 2, 3};
+
+  constexpr int result4 = std::ranges::max(a, std::ranges::greater());
+  static_assert(result4 == 1);
+}
+```
+* std::ranges::max[color ff0000]
+* std::ranges::greater[link /reference/functional/greater.md]
+
+### 出力
+```
+```
+
+### 備考
+Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`max`という名前の関数マクロが定義され、`std::ranges::max()`と衝突してしまうという問題がある。
+
+この解決策として以下の2つの方法がある：
+
+- `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`max`マクロが定義されなくなる。
+- `std::ranges::max()`を呼び出す際に、`(std::ranges::max)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::max()`関数が必ず使用される。
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
new file mode 100644
index 000000000..e95211c11
--- /dev/null
+++ b/reference/algorithm/ranges_max_element.md
@@ -0,0 +1,77 @@
+# max_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; max_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/ranges/forward_iterator.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+`[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
+
+
+## 戻り値
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最大と判断された最初の要素を指すイテレータ
+
+## 計算量
+[`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v1 = {3, 1, 4};
+
+  auto v1_max_element = std::ranges::max_element(v1);
+  assert(*v1_max_element == 4);
+
+
+  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; v2 = {{0, 3}, {1, 1}, {2, 4}};
+
+  auto v2_max_element = std::ranges::max_element(v2, {}, &amp;amp;std::pair&amp;lt;int, int&amp;gt;::second);
+  assert(v2_max_element-&amp;gt;first == 2);
+  assert(v2_max_element-&amp;gt;second == 4);
+}
+```
+* std::ranges::max_element[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_min.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min.md b/reference/algorithm/ranges_min.md
new file mode 100644
index 000000000..254a4e8b3
--- /dev/null
+++ b/reference/algorithm/ranges_min.md
@@ -0,0 +1,92 @@
+# min
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr const T&amp;amp; min(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {}); // (1)
+
+  template&amp;lt;copyable T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr T min(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});         // (2)
+
+  template&amp;lt;input_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  constexpr range_value_t&amp;lt;R&amp;gt; min(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});          // (3)
+}
+```
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* input_range[link /reference/ranges/input_range.md]
+* indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* range_value_t[link /reference/ranges/range_value_t.md]
+
+## 概要
+同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値を取得する。
+
+## 戻り値
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最小と判断された最初の値
+
+## 備考
+- 等価な要素が 2 つ以上あった場合には、最も左の要素を返す。
+
+
+## 例
+```cpp example
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  constexpr int result1 = std::ranges::min(2, 3);
+  static_assert(result1 == 2);
+
+  constexpr int result2 = std::ranges::min(2, 3, std::ranges::greater());
+  static_assert(result2 == 3);
+
+  constexpr int result3 = std::ranges::min({1, 2, 3});
+  static_assert(result3 == 1);
+
+  constexpr std::array&amp;lt;int, 3&amp;gt; a = {1, 2, 3};
+
+  constexpr int result4 = std::ranges::min(a, std::ranges::greater());
+  static_assert(result4 == 3);
+}
+```
+* std::ranges::min[color ff0000]
+* std::ranges::greater[link /reference/functional/ranges_greater.md]
+
+### 出力
+```
+```
+
+### 備考
+Windows環境においては、`&amp;lt;windows.h&amp;gt;`をインクルードすると`min`という名前の関数マクロが定義され、`std::ranges::min()`と衝突してしまうという問題がある。
+
+この解決策として以下の2つの方法がある：
+
+- `&amp;lt;windows.h&amp;gt;`をインクルードするまでに`#define NOMINMAX`を行う。これで`min`マクロが定義されなくなる。
+- `std::ranges::min()`を呼び出す際に、`(std::ranges::min)(a, b);`のように関数名をカッコで囲んで使用する。これで、名前解決において`std::ranges::min()`が必ず使用される。
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_min_element.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
new file mode 100644
index 000000000..d0cc89f93
--- /dev/null
+++ b/reference/algorithm/ranges_min_element.md
@@ -0,0 +1,80 @@
+# min_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; min_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/ranges/forward_iterator.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+
+## 概要
+`[first, last)`の範囲において、最小要素を指す最初のイテレータを取得する。
+
+
+## 戻り値
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって最小と判断された最初の要素を指すイテレータ
+
+
+## 計算量
+[`max`](/reference/algorithm/max.md)`((last - first) - 1, 0)`回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v1 = {3, 1, 4};
+
+  auto v1_min_element = std::ranges::min_element(v1);
+  assert(*v1_min_element == 1);
+
+
+  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; v2 = {{0, 3}, {1, 1}, {2, 4}};
+
+  auto v2_min_element = std::ranges::min_element(v2, {}, &amp;amp;std::pair&amp;lt;int, int&amp;gt;::second);
+  assert(v2_min_element-&amp;gt;first == 1);
+  assert(v2_min_element-&amp;gt;second == 1);
+}
+```
+* std::ranges::min_element[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_minmax.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax.md b/reference/algorithm/ranges_minmax.md
new file mode 100644
index 000000000..ab8178e25
--- /dev/null
+++ b/reference/algorithm/ranges_minmax.md
@@ -0,0 +1,93 @@
+# minmax
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+* cpp11[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T&amp;gt;
+  using minmax_result = min_max_result&amp;lt;T&amp;gt;;
+
+  template&amp;lt;class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;const T&amp;amp;&amp;gt; minmax(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;copyable T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;T&amp;gt; minmax(initializer_list&amp;lt;T&amp;gt; r, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;input_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+    requires indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, range_value_t&amp;lt;R&amp;gt;*&amp;gt;
+  constexpr minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt; minmax(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* min_max_result[link min_max_result.md.nolink]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* input_range[link /reference/ranges/input_range.md]
+* indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* range_value_t[link /reference/ranges/range_value_t.md]
+
+## 概要
+同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値と最大値の組を取得する。
+
+## 戻り値
+第1メンバ`min`が最小値、第2メンバ`max`が最大値となるtuple-likeオブジェクト([`min_max_result`](min_max_result.md.nolink))
+
+それぞれ、比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって判断された最初の値となる。
+
+## 計算量
+- 2値比較バージョンは1操作。
+- 範囲バージョンは高々`(3/2) * t.size()`回の述語適用。
+
+## 例
+```cpp example
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  const auto result1 = std::ranges::minmax(2, 3);
+  assert(result1.min == 2 &amp;amp;&amp;amp; result1.max == 3);
+
+  const auto result2 = std::ranges::minmax(2, 3, std::ranges::greater());
+  assert(result2.min == 3 &amp;amp;&amp;amp; result2.max == 2);
+
+  constexpr auto result3 = std::ranges::minmax({1, 2, 3});
+  static_assert(result3.min == 1 &amp;amp;&amp;amp; result3.max == 3);
+
+  constexpr std::array&amp;lt;int, 3&amp;gt; a = {1, 2, 3};
+
+  constexpr auto result4 = std::ranges::minmax(a, std::ranges::greater());
+  static_assert(result4.min == 3 &amp;amp;&amp;amp; result4.max == 1);
+}
+```
+* std::ranges::minmax[color ff0000]
+* std::ranges::greater[link /reference/functional/ranges_greater.md]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- 最小最大関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>8ae460edd152eb0f2b803c51107271c3eed83ebc:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2022-03-20T11:47:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
new file mode 100644
index 000000000..6c8cf95aa
--- /dev/null
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -0,0 +1,82 @@
+# minmax_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class T&amp;gt;
+  using minmax_result = min_max_result&amp;lt;T&amp;gt;;
+
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;I&amp;gt; minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr minmax_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; minmax_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* min_max_result[link min_max_result.md.nolink]
+* forward_iterator[link /reference/ranges/forward_iterator.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+
+## 概要
+`[first, last)` の範囲において、最小要素を指すイテレータと最大要素を指すイテレータの組を取得する。
+
+
+## 戻り値
+
+第1メンバ`min`が最小の要素、第2メンバ`max`が最大の要素をそれぞれ指すイテレータとなるtuple-likeオブジェクト([`min_max_result`](min_max_result.md.nolink))
+
+それぞれ、比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって判断し、同じ値の要素が複数ある場合は、最小の要素は最初の要素、最大の要素は最後の要素となる。
+
+## 計算量
+`n` を範囲の要素数とする場合、[`max`](max.md)`(floor(3(n - 1) / 2), 0)` 回の述語適用を行う。
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
+
+  auto [min1, max1] = std::ranges::minmax_element(v);
+  assert(*min1 == 1);
+  assert(*max1 == 4);
+
+  auto [min2, max2] = std::ranges::minmax_element(v, std::ranges::greater());
+  assert(*min2 == 4);
+  assert(*max2 == 1);
+}
+```
+* std::ranges::minmax_element[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 1ac82501f..eff40d509 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -301,10 +301,10 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`upper_bound`](algorithm/upper_bound.md) | 指定された要素より大きい値が現れる最初の位置のイテレータを取得する | |
 | [`equal_range`](algorithm/equal_range.md) | `lower_bound`と`upper_bound`の結果を組で取得する | |
 | [`binary_search`](algorithm/binary_search.md) | 二分探索法による検索を行う | |
-| [`ranges::lower_bound`](algorithm/ranges_lower_bound.md.nolink)     | 指定された要素以上の値が現れる最初の位置のイテレータを取得する     | C++20 |
-| [`ranges::upper_bound`](algorithm/ranges_upper_bound.md.nolink)     | 指定された要素より大きい値が現れる最初の位置のイテレータを取得する | C++20 |
-| [`ranges::equal_range`](algorithm/ranges_equal_range.md.nolink)     | `lower_bound`と`upper_bound`の結果を組で取得する                   | C++20 |
-| [`ranges::binary_search`](algorithm/ranges_binary_search.md.nolink) | 二分探索法による検索を行う                                         | C++20 |
+| [`ranges::lower_bound`](algorithm/ranges_lower_bound.md)     | 指定された要素以上の値が現れる最初の位置のイテレータを取得する     | C++20 |
+| [`ranges::upper_bound`](algorithm/ranges_upper_bound.md)     | 指定された要素より大きい値が現れる最初の位置のイテレータを取得する | C++20 |
+| [`ranges::equal_range`](algorithm/ranges_equal_range.md)     | 指定した値と等しい範囲を取得する                                   | C++20 |
+| [`ranges::binary_search`](algorithm/ranges_binary_search.md) | 二分探索法による検索を行う                                         | C++20 |
 
 
 ### マージ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_binary_search.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm/ranges_binary_search.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_binary_search.md b/reference/algorithm/ranges_binary_search.md
new file mode 100644
index 000000000..6185c77ae
--- /dev/null
+++ b/reference/algorithm/ranges_binary_search.md
@@ -0,0 +1,89 @@
+# binary_search
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool binary_search(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool binary_search(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+
+## 概要
+二分探索法による検索を行う。
+
+
+## 要件
+`[first,last)` の要素 `e` は `e &amp;lt; value` および `!(value &amp;lt; e)`、または `comp(e, value)` および `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。
+
+また、`[first, last)` の全ての要素 `e` は、`e &amp;lt; value` であれば `!(value &amp;lt; e)` である、または `comp(e, value)` であれば `!comp(value, e)` である必要がある。
+
+
+## 戻り値
+`[first,last)` 内のイテレータ `i` について、`!(*i &amp;lt; value) &amp;amp;&amp;amp; !(value &amp;lt; *i)` または `comp(*i, value) == false &amp;amp;&amp;amp; comp(value, *i) == false` であるようなイテレータが見つかった場合は `true` を返す。
+
+
+## 計算量
+最大で log2(`last - first`) + O(1) 回の比較を行う
+
+
+## 備考
+- `comp` は 2 引数の関数オブジェクトで、1 番目の引数が 2 番目の引数「より小さい」場合に `true` を、そうでない場合に `false` を返すものとして扱われる。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  // binary_search で 4 を検索する場合、
+  // 4 より小さい物、4 と等しい物、4 より大きい物がその順に並んでいれば、
+  // 必ずしもソートされている必要はない。
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+
+  if (std::ranges::binary_search(v, 4)) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::binary_search[color ff0000]
+
+### 出力
+```
+found
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm/ranges_equal_range.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
new file mode 100644
index 000000000..7e3f762e6
--- /dev/null
+++ b/reference/algorithm/ranges_equal_range.md
@@ -0,0 +1,97 @@
+# equal_range
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; equal_range(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; equal_range(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* subrange[link /reference/ranges/subrange.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+
+## 概要
+指定した値と等しい範囲を取得する。
+
+## 要件
+`[first,last)` の要素 `e` は `e &amp;lt; value` および `!(value &amp;lt; e)` 、あるいは `comp(e, value)` および `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。
+
+また、`[first, last)` の要素 `e` は全て暗黙に、`e &amp;lt; value` が `!(value &amp;lt; e)` または `comp(e, value)` が `!comp(value, e)` を意味している必要がある。
+
+
+## 戻り値
+`{`[`ranges::lower_bound`](ranges_lower_bound.md)`(first, last, value, comp, proj), `[`ranges::upper_bound`](ranges_upper_bound.md)`(first, last, value, comp, proj)}`
+
+## 計算量
+最大で 2 * log2(`last - first`) + O(1) 回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v   = {3, 1, 4, 2, 5, 3};
+  std::vector&amp;lt;int&amp;gt; v2  = {1, 4, 2, 5};
+
+  std::ranges::sort(v);
+
+  auto result  = std::ranges::equal_range(v, 3);
+  auto result2 = std::ranges::equal_range(v2, 3);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; result.size() &amp;lt;&amp;lt; std::endl;
+  for (int i : result) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; result2.size() &amp;lt;&amp;lt; std::endl;
+  for (int i : result2) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::sort[link ranges_sort.md]
+* std::ranges::equal_range[color ff0000]
+
+### 出力
+```
+size: 2
+3
+3
+
+size: 0
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
new file mode 100644
index 000000000..78c61d462
--- /dev/null
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -0,0 +1,143 @@
+# lower_bound
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I lower_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; lower_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+指定された要素以上の値が現れる最初の位置のイテレータを取得する。
+
+この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::ranges::equal_range()`](ranges_equal_range.md)関数を使用できる。
+
+
+## 事前条件
+- `[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
+  つまり、`e &amp;lt; value` または `comp(e, value)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
+
+
+## 戻り値
+`[first, last]` 内のイテレータ `i` のうち、以下の条件を満たす、最も右側（`first` から遠い方）のもの
+
+- `[first, i)` 内の全てのイテレータ `j` が `*j &amp;lt; value` または `comp(*j, value) != false` である
+
+（つまり、`value` 以上の要素のうち最初のものを指すイテレータ。`value` 以上の要素が無ければ `last`）
+
+
+## 計算量
+最大で log2(`last - first`) + O(1) 回の比較を行う
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct X {
+  int id;
+  std::string name;
+};
+
+int main()
+{
+  // この関数単体としての使い方
+  {
+    // lower_bound で 4 以上の要素の位置を検索する場合、
+    // 4 より小さい物と 4 以上の物がその順に並んでいれば、
+    // 必ずしもソートされている必要はない。
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+
+    // 4以上の要素を二分探索で検索
+    auto it = std::ranges::lower_bound(v, 4);
+    if (it != v.end()) {
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // 基本的な用途
+  // ソート済み範囲から、特定の値を二分探索で見つける
+  {
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+    std::ranges::sort(v);
+
+    // 二分探索で値4を検索
+    auto it = std::ranges::lower_bound(v, 4);
+    if (it != v.end() &amp;amp;&amp;amp; *it == 4) { // lower_boundでは4&amp;#34;以上&amp;#34;の値が見つかるので、
+                                     // 値4を見つけたいなら検索結果の値を比較する必要がある
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // 要素の一部の値を比較して見つける
+  {
+    // 要素は複数のメンバ変数をもつ
+    std::vector&amp;lt;X&amp;gt; v = {
+      {1, &amp;#34;Carol&amp;#34;},
+      {3, &amp;#34;Alice&amp;#34;},
+      {4, &amp;#34;Bob&amp;#34;},
+      {5, &amp;#34;Eve&amp;#34;},
+      {6, &amp;#34;Dave&amp;#34;}
+    };
+
+    const std::string key = &amp;#34;Bob&amp;#34;;
+
+    // X::nameメンバ変数をキーにして、
+    // X::name == &amp;#34;Bob&amp;#34;となる要素を二分探索で見つける
+    auto it = std::ranges::lower_bound(v, key, {}, &amp;amp;X::name);
+
+    if (it != v.end() &amp;amp;&amp;amp; it-&amp;gt;name == key) {
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id
+                &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;name
+                &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos
+                &amp;lt;&amp;lt; std::endl;
+    }
+  }
+}
+```
+* std::ranges::sort[link ranges_sort.md]
+* std::ranges::distance[link /reference/iterator/ranges_distance.md]
+* std::ranges::lower_bound[color ff0000]
+
+### 出力
+```
+4 pos=2
+4 pos=2
+id=4 name=Bob pos=2
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_upper_bound.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm/ranges_upper_bound.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_upper_bound.md b/reference/algorithm/ranges_upper_bound.md
new file mode 100644
index 000000000..775b27972
--- /dev/null
+++ b/reference/algorithm/ranges_upper_bound.md
@@ -0,0 +1,130 @@
+# upper_bound
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I upper_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; upper_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+指定された要素より大きい値が現れる最初の位置のイテレータを取得する
+
+
+## 事前条件
+- `[first,last)` の要素 `e` は `!(value &amp;lt; e)` または `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。  
+  つまり、`!(value &amp;lt; e)` または `!comp(value, e)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
+
+
+## 戻り値
+`[first, last]` 内のイテレータ `i` のうち、以下の条件を満たす、最も右側（`first` から遠い方）のもの。
+
+- `[first, i)` 内の全てのイテレータ `j` が `!(value &amp;lt; *j)` または `comp(value, *j) == false` である。
+
+（つまり、`value` より大きい要素のうち最初のものを指すイテレータ。`value` より大きい要素が無ければ `last`）
+
+
+## 計算量
+最大で log2(`last - first`) + O(1) 回の比較を行う
+
+
+## 備考
+- 本関数は、本質的に C++11 で追加された [`partition_point`](partition_point.md) と等価である。  
+	具体的には、[`partition_point`](partition_point.md)`(first, last, [value](const T&amp;amp; e) { return !bool(value &amp;lt; e); })`、あるいは、[`partition_point`](partition_point.md)`(first, last, [value, comp](const T&amp;amp; e) { return !bool(comp(value, e)); })` とすることで等価の結果が得られる。
+- 本関数の要件は、上記の通り C++03 までの方が C++11 よりも厳しい。  
+	しかし、本アルゴリズムの特性上、処理系が C++03 までにしか準拠していない場合でも、昇順に並んでいなくても正常に動作する可能性は高いものと思われる。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+struct X {
+  int key;    // プライマリキー
+  int value;  // 補助的な値
+};
+
+void push_stable(std::vector&amp;lt;X&amp;gt;&amp;amp; queue, X elem)
+{
+  // 挿入対象の値 elem よりも大きい要素の位置、すなわち
+  // elem と同値な要素グループの次の位置を検索する。
+  auto it = std::ranges::upper_bound(queue, elem.key, {}, &amp;amp;X::key);
+  queue.insert(it, elem);
+}
+
+
+int main()
+{
+  // この関数単体としての使い方
+  {
+    // upper_bound で 3 より大きい要素の位置を検索する場合、
+    // 3 以下の物と 3 より大きい物がその順に並んでいれば、
+    // 必ずしもソートされている必要はない。
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+
+    // 3より大きい要素を二分探索で検索
+    auto it = std::ranges::upper_bound(v, 3);
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 応用例：安定順序・優先順位付きキューの実装
+  {
+    std::vector&amp;lt;X&amp;gt; queue;
+    push_stable(queue, {100, 1});
+    push_stable(queue, {200, 1});
+    push_stable(queue, {300, 1});
+    push_stable(queue, {300, 2});
+    push_stable(queue, {200, 2});
+    push_stable(queue, {100, 2});
+
+    // プライマリキー key は同値だが異なる値 value を持つ要素間では
+    // キュー queue への要素挿入順序が維持されている。
+    // （std::priority_queue クラスでは挿入順序は保持されない。）
+    for (const auto&amp;amp; e: queue) {
+      std::cout &amp;lt;&amp;lt; e.key &amp;lt;&amp;lt; &amp;#39;:&amp;#39; &amp;lt;&amp;lt; e.value &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+    }
+    std::cout &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::upper_bound[color ff0000]
+
+
+### 出力
+```
+4
+100:1 100:2 200:1 200:2 300:1 300:2
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges_lower_bound.md -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>7e37e927e5986b12e46fe6885c677c7cf4f80bd5:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2022-03-20T09:34:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
deleted file mode 100644
index 78c61d462..000000000
--- a/reference/algorithm/ranges_lower_bound.md
+++ /dev/null
@@ -1,143 +0,0 @@
-# lower_bound
-* algorithm[meta header]
-* std::ranges[meta namespace]
-* function template[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I lower_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; lower_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-}
-```
-* forward_iterator[link /reference/iterator/forward_iterator.md]
-* sentinel_for[link /reference/iterator/sentinel_for.md]
-* ranges::less[link /reference/functional/ranges_less.md]
-* identity[link /reference/functional/identity.md]
-* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
-* projected[link /reference/iterator/projected.md]
-* forward_range[link /reference/ranges/forward_range.md]
-* iterator_t[link /reference/ranges/iterator_t.md]
-* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
-
-## 概要
-指定された要素以上の値が現れる最初の位置のイテレータを取得する。
-
-この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::ranges::equal_range()`](ranges_equal_range.md)関数を使用できる。
-
-
-## 事前条件
-- `[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
-  つまり、`e &amp;lt; value` または `comp(e, value)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
-
-
-## 戻り値
-`[first, last]` 内のイテレータ `i` のうち、以下の条件を満たす、最も右側（`first` から遠い方）のもの
-
-- `[first, i)` 内の全てのイテレータ `j` が `*j &amp;lt; value` または `comp(*j, value) != false` である
-
-（つまり、`value` 以上の要素のうち最初のものを指すイテレータ。`value` 以上の要素が無ければ `last`）
-
-
-## 計算量
-最大で log2(`last - first`) + O(1) 回の比較を行う
-
-## 例
-```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;algorithm&amp;gt;
-#include &amp;lt;vector&amp;gt;
-#include &amp;lt;string&amp;gt;
-
-struct X {
-  int id;
-  std::string name;
-};
-
-int main()
-{
-  // この関数単体としての使い方
-  {
-    // lower_bound で 4 以上の要素の位置を検索する場合、
-    // 4 より小さい物と 4 以上の物がその順に並んでいれば、
-    // 必ずしもソートされている必要はない。
-    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
-
-    // 4以上の要素を二分探索で検索
-    auto it = std::ranges::lower_bound(v, 4);
-    if (it != v.end()) {
-      std::size_t pos = std::ranges::distance(v.begin(), it);
-      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
-    }
-  }
-
-  // 基本的な用途
-  // ソート済み範囲から、特定の値を二分探索で見つける
-  {
-    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
-    std::ranges::sort(v);
-
-    // 二分探索で値4を検索
-    auto it = std::ranges::lower_bound(v, 4);
-    if (it != v.end() &amp;amp;&amp;amp; *it == 4) { // lower_boundでは4&amp;#34;以上&amp;#34;の値が見つかるので、
-                                     // 値4を見つけたいなら検索結果の値を比較する必要がある
-      std::size_t pos = std::ranges::distance(v.begin(), it);
-      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
-    }
-  }
-
-  // 要素の一部の値を比較して見つける
-  {
-    // 要素は複数のメンバ変数をもつ
-    std::vector&amp;lt;X&amp;gt; v = {
-      {1, &amp;#34;Carol&amp;#34;},
-      {3, &amp;#34;Alice&amp;#34;},
-      {4, &amp;#34;Bob&amp;#34;},
-      {5, &amp;#34;Eve&amp;#34;},
-      {6, &amp;#34;Dave&amp;#34;}
-    };
-
-    const std::string key = &amp;#34;Bob&amp;#34;;
-
-    // X::nameメンバ変数をキーにして、
-    // X::name == &amp;#34;Bob&amp;#34;となる要素を二分探索で見つける
-    auto it = std::ranges::lower_bound(v, key, {}, &amp;amp;X::name);
-
-    if (it != v.end() &amp;amp;&amp;amp; it-&amp;gt;name == key) {
-      std::size_t pos = std::ranges::distance(v.begin(), it);
-      std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id
-                &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;name
-                &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos
-                &amp;lt;&amp;lt; std::endl;
-    }
-  }
-}
-```
-* std::ranges::sort[link ranges_sort.md]
-* std::ranges::distance[link /reference/iterator/ranges_distance.md]
-* std::ranges::lower_bound[color ff0000]
-
-### 出力
-```
-4 pos=2
-4 pos=2
-id=4 name=Bob pos=2
-```
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): 10.1.0
-- [ICC](/implementation.md#icc): ??
-- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
-
-## 参照
-- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges_max_element.md -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>7e37e927e5986b12e46fe6885c677c7cf4f80bd5:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-03-20T09:34:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
deleted file mode 100644
index ed9768a1f..000000000
--- a/reference/algorithm/ranges_max_element.md
+++ /dev/null
@@ -1,126 +0,0 @@
-# max_element
-* algorithm[meta header]
-* std::ranges[meta namespace]
-* function template[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-namespace std {
-  template&amp;lt;class ForwardIterator&amp;gt;
-  ForwardIterator
-    max_element(ForwardIterator first,
-                ForwardIterator last); // (1) C++03
-
-  template&amp;lt;class ForwardIterator, class Compare&amp;gt;
-  ForwardIterator
-    max_element(ForwardIterator first,
-                ForwardIterator last,
-                Compare comp);         // (2) C++03
-
-  template &amp;lt;class ExecutionPolicy, class ForwardIterator&amp;gt;
-  ForwardIterator
-    max_element(ExecutionPolicy&amp;amp;&amp;amp; exec,
-                ForwardIterator first,
-                ForwardIterator last); // (3) C++17
-
-  template &amp;lt;class ExecutionPolicy, class ForwardIterator, class Compare&amp;gt;
-  ForwardIterator
-    max_element(ExecutionPolicy&amp;amp;&amp;amp; exec,
-                ForwardIterator first,
-                ForwardIterator last,
-                Compare comp);         // (4) C++17
-}
-```
-
-## 概要
-`[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
-
-
-
-## 戻り値
-`*j &amp;lt; *i`もしくは`comp(*j, *i)`の比較によって最大と判断された最初の要素を指すイテレータ
-
-
-## 計算量
-[`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
-
-
-## 例
-```cpp example
-#include &amp;lt;algorithm&amp;gt;
-#include &amp;lt;cassert&amp;gt;
-#include &amp;lt;utility&amp;gt;
-#include &amp;lt;vector&amp;gt;
-
-int main()
-{
-  // (1)
-  std::vector&amp;lt;int&amp;gt; v1 = {3, 1, 4};
-
-  decltype(v1)::iterator v1_max_element = std::max_element(v1.begin(), v1.end());
-  assert(*v1_max_element == 4);
-
-
-  // (2)
-  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; v2 = {{0, 3}, {1, 1}, {2, 4}};
-
-  decltype(v2)::iterator v2_max_element = std::max_element(v2.begin(), v2.end(), [](const auto&amp;amp; a, const auto&amp;amp; b) {
-    return a.second &amp;lt; b.second;
-  });
-  assert(v2_max_element-&amp;gt;first == 2);
-  assert(v2_max_element-&amp;gt;second == 4);
-}
-```
-* std::max_element[color ff0000]
-
-### 出力
-```
-```
-
-
-## 実装例
-```cpp
-template &amp;lt;class ForwardIterator&amp;gt;
-ForwardIterator max_element(ForwardIterator first, ForwardIterator last)
-{
-  if (first == last)
-    return first;
-
-  ForwardIterator result = first++;
-  for (; first != last; ++first) {
-    if (*result &amp;lt; *first) {
-      result = first;
-    }
-  }
-  return result;
-}
-
-template &amp;lt;class ForwardIterator, class Compare&amp;gt;
-ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp)
-{
-  if (first == last)
-    return first;
-
-  ForwardIterator result = first++;
-  for (; first != last; ++first) {
-    if (comp(*result, *first)) {
-      result = first;
-    }
-  }
-  return result;
-}
-```
-
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): 10.1.0
-- [ICC](/implementation.md#icc): ??
-- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
-
-## 参照
-- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
new file mode 100644
index 000000000..78c61d462
--- /dev/null
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -0,0 +1,143 @@
+# lower_bound
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I lower_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; lower_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+指定された要素以上の値が現れる最初の位置のイテレータを取得する。
+
+この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::ranges::equal_range()`](ranges_equal_range.md)関数を使用できる。
+
+
+## 事前条件
+- `[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
+  つまり、`e &amp;lt; value` または `comp(e, value)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
+
+
+## 戻り値
+`[first, last]` 内のイテレータ `i` のうち、以下の条件を満たす、最も右側（`first` から遠い方）のもの
+
+- `[first, i)` 内の全てのイテレータ `j` が `*j &amp;lt; value` または `comp(*j, value) != false` である
+
+（つまり、`value` 以上の要素のうち最初のものを指すイテレータ。`value` 以上の要素が無ければ `last`）
+
+
+## 計算量
+最大で log2(`last - first`) + O(1) 回の比較を行う
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct X {
+  int id;
+  std::string name;
+};
+
+int main()
+{
+  // この関数単体としての使い方
+  {
+    // lower_bound で 4 以上の要素の位置を検索する場合、
+    // 4 より小さい物と 4 以上の物がその順に並んでいれば、
+    // 必ずしもソートされている必要はない。
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+
+    // 4以上の要素を二分探索で検索
+    auto it = std::ranges::lower_bound(v, 4);
+    if (it != v.end()) {
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // 基本的な用途
+  // ソート済み範囲から、特定の値を二分探索で見つける
+  {
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+    std::ranges::sort(v);
+
+    // 二分探索で値4を検索
+    auto it = std::ranges::lower_bound(v, 4);
+    if (it != v.end() &amp;amp;&amp;amp; *it == 4) { // lower_boundでは4&amp;#34;以上&amp;#34;の値が見つかるので、
+                                     // 値4を見つけたいなら検索結果の値を比較する必要がある
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // 要素の一部の値を比較して見つける
+  {
+    // 要素は複数のメンバ変数をもつ
+    std::vector&amp;lt;X&amp;gt; v = {
+      {1, &amp;#34;Carol&amp;#34;},
+      {3, &amp;#34;Alice&amp;#34;},
+      {4, &amp;#34;Bob&amp;#34;},
+      {5, &amp;#34;Eve&amp;#34;},
+      {6, &amp;#34;Dave&amp;#34;}
+    };
+
+    const std::string key = &amp;#34;Bob&amp;#34;;
+
+    // X::nameメンバ変数をキーにして、
+    // X::name == &amp;#34;Bob&amp;#34;となる要素を二分探索で見つける
+    auto it = std::ranges::lower_bound(v, key, {}, &amp;amp;X::name);
+
+    if (it != v.end() &amp;amp;&amp;amp; it-&amp;gt;name == key) {
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id
+                &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;name
+                &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos
+                &amp;lt;&amp;lt; std::endl;
+    }
+  }
+}
+```
+* std::ranges::sort[link ranges_sort.md]
+* std::ranges::distance[link /reference/iterator/ranges_distance.md]
+* std::ranges::lower_bound[color ff0000]
+
+### 出力
+```
+4 pos=2
+4 pos=2
+id=4 name=Bob pos=2
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
new file mode 100644
index 000000000..ed9768a1f
--- /dev/null
+++ b/reference/algorithm/ranges_max_element.md
@@ -0,0 +1,126 @@
+# max_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class ForwardIterator&amp;gt;
+  ForwardIterator
+    max_element(ForwardIterator first,
+                ForwardIterator last); // (1) C++03
+
+  template&amp;lt;class ForwardIterator, class Compare&amp;gt;
+  ForwardIterator
+    max_element(ForwardIterator first,
+                ForwardIterator last,
+                Compare comp);         // (2) C++03
+
+  template &amp;lt;class ExecutionPolicy, class ForwardIterator&amp;gt;
+  ForwardIterator
+    max_element(ExecutionPolicy&amp;amp;&amp;amp; exec,
+                ForwardIterator first,
+                ForwardIterator last); // (3) C++17
+
+  template &amp;lt;class ExecutionPolicy, class ForwardIterator, class Compare&amp;gt;
+  ForwardIterator
+    max_element(ExecutionPolicy&amp;amp;&amp;amp; exec,
+                ForwardIterator first,
+                ForwardIterator last,
+                Compare comp);         // (4) C++17
+}
+```
+
+## 概要
+`[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
+
+
+
+## 戻り値
+`*j &amp;lt; *i`もしくは`comp(*j, *i)`の比較によって最大と判断された最初の要素を指すイテレータ
+
+
+## 計算量
+[`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  // (1)
+  std::vector&amp;lt;int&amp;gt; v1 = {3, 1, 4};
+
+  decltype(v1)::iterator v1_max_element = std::max_element(v1.begin(), v1.end());
+  assert(*v1_max_element == 4);
+
+
+  // (2)
+  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; v2 = {{0, 3}, {1, 1}, {2, 4}};
+
+  decltype(v2)::iterator v2_max_element = std::max_element(v2.begin(), v2.end(), [](const auto&amp;amp; a, const auto&amp;amp; b) {
+    return a.second &amp;lt; b.second;
+  });
+  assert(v2_max_element-&amp;gt;first == 2);
+  assert(v2_max_element-&amp;gt;second == 4);
+}
+```
+* std::max_element[color ff0000]
+
+### 出力
+```
+```
+
+
+## 実装例
+```cpp
+template &amp;lt;class ForwardIterator&amp;gt;
+ForwardIterator max_element(ForwardIterator first, ForwardIterator last)
+{
+  if (first == last)
+    return first;
+
+  ForwardIterator result = first++;
+  for (; first != last; ++first) {
+    if (*result &amp;lt; *first) {
+      result = first;
+    }
+  }
+  return result;
+}
+
+template &amp;lt;class ForwardIterator, class Compare&amp;gt;
+ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp)
+{
+  if (first == last)
+    return first;
+
+  ForwardIterator result = first++;
+  for (; first != last; ++first) {
+    if (comp(*result, *first)) {
+      result = first;
+    }
+  }
+  return result;
+}
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_nth_element.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
index df997c8e7..e44cb9b34 100644
--- a/reference/algorithm/ranges_nth_element.md
+++ b/reference/algorithm/ranges_nth_element.md
@@ -21,8 +21,8 @@ namespace std::ranges {
 * identity[link /reference/functional/identity.md]
 * sortable[link /reference/iterator/sortable.md]
 * random_access_range[link /reference/ranges/random_access_range.md]
-* iterator_t[link /reference/iterator/iterator_t.md]
-* borrowed_iterator_t[link /reference/iterator/borrowed_iterator_t.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index 6cec98e4c..07cd26fd8 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -21,8 +21,8 @@ namespace std::ranges {
 * identity[link /reference/functional/identity.md]
 * sortable[link /reference/iterator/sortable.md]
 * random_access_range[link /reference/ranges/random_access_range.md]
-* iterator_t[link /reference/iterator/iterator_t.md]
-* borrowed_iterator_t[link /reference/iterator/borrowed_iterator_t.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges_partition_copy.md -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
deleted file mode 100644
index 2dc175e2c..000000000
--- a/reference/algorithm/ranges_partition_copy.md
+++ /dev/null
@@ -1,125 +0,0 @@
-# partition_copy
-* algorithm[meta header]
-* std::ranges[meta namespace]
-* function template[meta id-type]
-* cpp20[meta cpp]
-* cpp11[meta cpp]
-
-```cpp
-namespace std {
-  template &amp;lt;class InputIterator,
-            class OutputIterator1,
-            class OutputIterator2,
-            class Predicate&amp;gt;
-  pair&amp;lt;OutputIterator1, OutputIterator2&amp;gt;
-    partition_copy(InputIterator first,
-                   InputIterator last,
-                   OutputIterator1 out_true,
-                   OutputIterator2 out_false,
-                   Predicate pred);            // (1) C++11
-
-  template &amp;lt;class InputIterator,
-            class OutputIterator1,
-            class OutputIterator2,
-            class Predicate&amp;gt;
-  constexpr pair&amp;lt;OutputIterator1, OutputIterator2&amp;gt;
-    partition_copy(InputIterator first,
-                   InputIterator last,
-                   OutputIterator1 out_true,
-                   OutputIterator2 out_false,
-                   Predicate pred);            // (1) C++20
-
-  template &amp;lt;class ExecutionPolicy,
-            class ForwardIterator,
-            class ForwardIterator1,
-            class ForwardIterator2,
-            class Predicate&amp;gt;
-  pair&amp;lt;ForwardIterator1, ForwardIterator2&amp;gt;
-    partition_copy(ExecutionPolicy&amp;amp;&amp;amp; exec,
-                   ForwardIterator first,
-                   ForwardIterator last,
-                   ForwardIterator1 out_true,
-                   ForwardIterator2 out_false,
-                   Predicate pred);            // (2) C++17
-}
-```
-* pair[link /reference/utility/pair.md]
-
-## 概要
-与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする。
-
-
-## 要件
-- `InputIterator` の value type は `Assignable` で、`out_true` と `out_false` の `OutputIterator` へ書き込み可能で、`Predicate` の argument type へ変換可能でなければならない。
-- 入力範囲は出力範囲のどちらとも重なっていてはならない。
-
-
-## 効果
-`[first,last)` 内にあるそれぞれのイテレータ `i` について、`pred(*i)` が `true` なら `*i` を `out_true` へコピーし、そうでない場合は `out_false` へコピーする。
-
-
-## 戻り値
-`first` には `out_true` の終端が、`second` には `out_false` の終端が格納された[`pair`](/reference/utility/pair.md)オブジェクトを返す。
-
-
-## 計算量
-正確に `last - first` 回述語が適用される。
-
-
-## 例
-```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;vector&amp;gt;
-#include &amp;lt;algorithm&amp;gt;
-#include &amp;lt;iterator&amp;gt;
-#include &amp;lt;string&amp;gt;
-
-void print(const std::string&amp;amp; name, const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
-{
-  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; : &amp;#34;;
-  std::for_each(v.begin(), v.end(), [](int x) {
-    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;,&amp;#34;;
-  });
-  std::cout &amp;lt;&amp;lt; std::endl;
-}
-
-bool is_even(int x) { return x % 2 == 0; }
-
-int main()
-{
-  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
-
-  // 偶数グループと奇数グループに分ける
-  std::vector&amp;lt;int&amp;gt; evens;
-  std::vector&amp;lt;int&amp;gt; odds;
-  std::partition_copy(v.begin(), v.end(),
-                      std::back_inserter(evens),
-                      std::back_inserter(odds),
-                      is_even);
-
-  print(&amp;#34;v&amp;#34;, v);
-  print(&amp;#34;evens&amp;#34;, evens);
-  print(&amp;#34;odds&amp;#34;, odds);
-}
-```
-* std::partition_copy[color ff0000]
-
-### 出力
-```
-v : 1,2,3,4,5,
-evens : 2,4,
-odds : 1,3,5,
-```
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): 10.1.0
-- [ICC](/implementation.md#icc): ??
-- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
-
-## 参照
-- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>