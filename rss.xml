<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-09-04T14:35:50.092751</updated>
  <id>caab8b26-d4be-4b35-bec6-3c3197690235</id>

  
    <entry>
      <title>集成体初期化の拡張 -- Merge pull request #896 from cpprefjp/fixtypo_extension_to_aggregate_initialization</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/extension_to_aggregate_initialization.html"/>
      <id>0da613912950c473847589fba3f93882c477f321:lang/cpp17/extension_to_aggregate_initialization.md</id>
      <updated>2021-09-04T14:36:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/extension_to_aggregate_initialization.md b/lang/cpp17/extension_to_aggregate_initialization.md
index af3bdeb8a..d3648db38 100644
--- a/lang/cpp17/extension_to_aggregate_initialization.md
+++ b/lang/cpp17/extension_to_aggregate_initialization.md
@@ -18,13 +18,13 @@ C++17 から集成体初期化が拡張され、基底クラスを持つ型の
 
 struct base_a { std::string s; };
 struct base_b { double d; std::vector&amp;lt; int &amp;gt; vi; };
-struct delived: base_a, base_b { char c; };
+struct derived: base_a, base_b { char c; };
 
 int main()
 {
   // このような初期化を C++17 以降は本機能により使用できるようになった
   // この初期化は C++14 以前では基底クラスの初期化として扱えず翻訳に失敗してしまう
-  delived o
+  derived o
   { { // base_a; 本機能により基底クラスの初期化を { } で記述できる
       &amp;#34;abc&amp;#34; // base_a::s
     }
@@ -32,7 +32,7 @@ int main()
       12.345 // base_b::d
     , { 1, 2, 3} // base_b::v
     }
-  , &amp;#39;d&amp;#39; // delived::c
+  , &amp;#39;d&amp;#39; // derived::c
   };
   
   std::cout 
@@ -78,17 +78,17 @@ struct legacy_base
   legacy_base( int a_ ): a( a_ ) { }
   int a;
 };
-struct legacy_delived: legacy_base
+struct legacy_derived: legacy_base
 {
   // いちいち書かなければならないのは面倒くさい
-  legacy_delived( int a_, int b_ ): legacy_base( a_ ), b( b_ ) { }
+  legacy_derived( int a_, int b_ ): legacy_base( a_ ), b( b_ ) { }
   int b;
 };
 
 int main()
 {
-  // 初期化を簡潔に記述するためには legacy_delived, legacy_base の構築子に仕込みが必要だった
-  legacy_delived o{ 123, 456 };
+  // 初期化を簡潔に記述するためには legacy_derived, legacy_base の構築子に仕込みが必要だった
+  legacy_derived o{ 123, 456 };
   std::cout
     &amp;lt;&amp;lt; &amp;#34;o.a = &amp;#34; &amp;lt;&amp;lt; o.a &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
     &amp;lt;&amp;lt; &amp;#34;o.b = &amp;#34; &amp;lt;&amp;lt; o.b &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
@@ -103,11 +103,11 @@ int main()
 #include &amp;lt;iostream&amp;gt;
 
 struct legacy_base { int a; };
-struct legacy_delived: legacy_base { int b; };
+struct legacy_derived: legacy_base { int b; };
 
 int main()
 {
-  legacy_delived o{ { 123 }, 456 };
+  legacy_derived o{ { 123 }, 456 };
   std::cout
     &amp;lt;&amp;lt; &amp;#34;o.a = &amp;#34; &amp;lt;&amp;lt; o.a &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
     &amp;lt;&amp;lt; &amp;#34;o.b = &amp;#34; &amp;lt;&amp;lt; o.b &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>集成体初期化の拡張 -- Typo修正: delive -&gt; derive</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/extension_to_aggregate_initialization.html"/>
      <id>11d572b23e0c91a6eb5f21f9bd3e959248d03377:lang/cpp17/extension_to_aggregate_initialization.md</id>
      <updated>2021-09-04T12:08:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/extension_to_aggregate_initialization.md b/lang/cpp17/extension_to_aggregate_initialization.md
index af3bdeb8a..d3648db38 100644
--- a/lang/cpp17/extension_to_aggregate_initialization.md
+++ b/lang/cpp17/extension_to_aggregate_initialization.md
@@ -18,13 +18,13 @@ C++17 から集成体初期化が拡張され、基底クラスを持つ型の
 
 struct base_a { std::string s; };
 struct base_b { double d; std::vector&amp;lt; int &amp;gt; vi; };
-struct delived: base_a, base_b { char c; };
+struct derived: base_a, base_b { char c; };
 
 int main()
 {
   // このような初期化を C++17 以降は本機能により使用できるようになった
   // この初期化は C++14 以前では基底クラスの初期化として扱えず翻訳に失敗してしまう
-  delived o
+  derived o
   { { // base_a; 本機能により基底クラスの初期化を { } で記述できる
       &amp;#34;abc&amp;#34; // base_a::s
     }
@@ -32,7 +32,7 @@ int main()
       12.345 // base_b::d
     , { 1, 2, 3} // base_b::v
     }
-  , &amp;#39;d&amp;#39; // delived::c
+  , &amp;#39;d&amp;#39; // derived::c
   };
   
   std::cout 
@@ -78,17 +78,17 @@ struct legacy_base
   legacy_base( int a_ ): a( a_ ) { }
   int a;
 };
-struct legacy_delived: legacy_base
+struct legacy_derived: legacy_base
 {
   // いちいち書かなければならないのは面倒くさい
-  legacy_delived( int a_, int b_ ): legacy_base( a_ ), b( b_ ) { }
+  legacy_derived( int a_, int b_ ): legacy_base( a_ ), b( b_ ) { }
   int b;
 };
 
 int main()
 {
-  // 初期化を簡潔に記述するためには legacy_delived, legacy_base の構築子に仕込みが必要だった
-  legacy_delived o{ 123, 456 };
+  // 初期化を簡潔に記述するためには legacy_derived, legacy_base の構築子に仕込みが必要だった
+  legacy_derived o{ 123, 456 };
   std::cout
     &amp;lt;&amp;lt; &amp;#34;o.a = &amp;#34; &amp;lt;&amp;lt; o.a &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
     &amp;lt;&amp;lt; &amp;#34;o.b = &amp;#34; &amp;lt;&amp;lt; o.b &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
@@ -103,11 +103,11 @@ int main()
 #include &amp;lt;iostream&amp;gt;
 
 struct legacy_base { int a; };
-struct legacy_delived: legacy_base { int b; };
+struct legacy_derived: legacy_base { int b; };
 
 int main()
 {
-  legacy_delived o{ { 123 }, 456 };
+  legacy_derived o{ { 123 }, 456 };
   std::cout
     &amp;lt;&amp;lt; &amp;#34;o.a = &amp;#34; &amp;lt;&amp;lt; o.a &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
     &amp;lt;&amp;lt; &amp;#34;o.b = &amp;#34; &amp;lt;&amp;lt; o.b &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Naoya Sakabe</name>
        <email>k.exa.apostrophe@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bidirectional_iterator -- iterator/bidirectional_iterator: リンク調整</title>
      <link href="https://cpprefjp.github.io/reference/iterator/bidirectional_iterator.html"/>
      <id>3581cc83393610e0d5f719b2b33c5f0a76efe6f7:reference/iterator/bidirectional_iterator.md</id>
      <updated>2021-09-03T17:34:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/bidirectional_iterator.md b/reference/iterator/bidirectional_iterator.md
index b280311ff..b20f1ecce 100644
--- a/reference/iterator/bidirectional_iterator.md
+++ b/reference/iterator/bidirectional_iterator.md
@@ -16,10 +16,10 @@ namespace std {
     };
 }
 ```
-* forward_iterator[link /reference/iterator/forward_iterator.md]
+* forward_iterator[link forward_iterator.md]
 * derived_from[link /reference/concepts/derived_from.md]
 * ITER_CONCEPT[link /reference/iterator/input_iterator.md#iter_concept]
-* bidirectional_iterator_tag[link /reference/iterator/iterator_tag.md]
+* bidirectional_iterator_tag[link iterator_tag.md]
 * same_as[link /reference/concepts/same_as.md]
 
 ## 概要
@@ -37,7 +37,7 @@ namespace std {
 型`I`の等しい2つのオブジェクト`a, b`について次の条件を満たす場合に限って、型`I`は`bidirectional_iterator`のモデルである。
 
 - `a, b`がデクリメント可能ならば、次の4つの条件を全て満たす
-    - `addressof(--a) == addressof(a)`
+    - [`addressof`](/reference/memory/addressof.md)`(--a) == `[`addressof`](/reference/memory/addressof.md)`(a)`
     - `bool(a-- == b)`
     - `a--, --b`の評価の後でも、`bool(a == b)`は`true`となる
     - `bool(++(--a) == b)`
@@ -95,6 +95,7 @@ int main() {
 }
 ```
 * std::bidirectional_iterator[color ff0000]
+* std::istream_iterator[link istream_iterator.md]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assignable_from -- concepts/assignable_from: 調整</title>
      <link href="https://cpprefjp.github.io/reference/concepts/assignable_from.html"/>
      <id>ccaeccb41d44782ddc6c524c78c89172f046ee67:reference/concepts/assignable_from.md</id>
      <updated>2021-09-03T17:27:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/assignable_from.md b/reference/concepts/assignable_from.md
index 833dfffac..256e22170 100644
--- a/reference/concepts/assignable_from.md
+++ b/reference/concepts/assignable_from.md
@@ -17,8 +17,8 @@ namespace std {
 ```
 * is_lvalue_reference_v[link /reference/type_traits/is_lvalue_reference.md]
 * remove_reference_t[link /reference/type_traits/remove_reference.md]
-* common_reference_with[link /reference/concepts/common_reference_with.md]
-* same_as[link /reference/concepts/same_as.md]
+* common_reference_with[link common_reference_with.md]
+* same_as[link same_as.md]
 
 ## 概要
 
@@ -30,7 +30,7 @@ namespace std {
 
 これらの`lhs, rhs, lcopy, rcopy`について、以下の条件を満たす場合に限って、型`LHS, RHS`は`assignable_from`のモデルである。
 
-- `addressof(lhs = rhs) == addressof(lcopy)`となる
+- [`addressof`](/reference/memory/addressof.md)`(lhs = rhs) == `[`addressof`](/reference/memory/addressof.md)`(lcopy)`となる
 - `lhs = rhs;`という式の評価の後で以下のいずれかのことが成り立っている
     - `rhs`が`lcopy`を参照する非`const` *xvalue*でないならば
         - `lhs`は`rcopy`と等値である
@@ -38,6 +38,7 @@ namespace std {
         - `rhs`が参照するオブジェクトの状態は有効だが未規定
     - それ以外の場合で、`rhs`が*glvalue*ならば
         - `rhs`が参照するオブジェクトは変更されない
+
 ## 備考
 
 代入操作では、引数型の一部の値が本コンセプトが要求する構文・意味論的制約を必ずしも満たしていなくても構わない。特に、あるオブジェクト`x`への代入操作によって別のオブジェクト`y`が変更される時、`x, y`はその場合の`=`の定義域に含まれない事がある。
@@ -53,7 +54,7 @@ namespace std {
 #include &amp;lt;memory&amp;gt;
 
 template&amp;lt;typename LHS, typename RHS&amp;gt;
-requires std::assignable_from&amp;lt;LHS, RHS&amp;gt;
+  requires std::assignable_from&amp;lt;LHS, RHS&amp;gt;
 void f(const char* name, const char* arg) {
   std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is assignable from &amp;#34; &amp;lt;&amp;lt; arg &amp;lt;&amp;lt; std::endl;
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_istream_view -- Fix typo</title>
      <link href="https://cpprefjp.github.io/reference/ranges/basic_istream_view.html"/>
      <id>3ca70623732fba289191cdf50bab6e3c46c30fb6:reference/ranges/basic_istream_view.md</id>
      <updated>2021-09-03T04:01:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/basic_istream_view.md b/reference/ranges/basic_istream_view.md
index ac1d11b96..aa6344653 100644
--- a/reference/ranges/basic_istream_view.md
+++ b/reference/ranges/basic_istream_view.md
@@ -73,7 +73,7 @@ int main() {
   using namespace std;
   auto iss = istringstream{&amp;#34;1 2 3 4 5&amp;#34;};
 
-  for (int i : ranges::istream_view&amp;lt;int&amp;gt;(iss)) {
+  for (int i : views::istream_view&amp;lt;int&amp;gt;(iss)) {
     cout &amp;lt;&amp;lt; i;
   }
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iota_view -- Fix typo</title>
      <link href="https://cpprefjp.github.io/reference/ranges/iota_view.html"/>
      <id>3ca70623732fba289191cdf50bab6e3c46c30fb6:reference/ranges/iota_view.md</id>
      <updated>2021-09-03T04:01:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/iota_view.md b/reference/ranges/iota_view.md
index d6d944e18..648ec7d82 100644
--- a/reference/ranges/iota_view.md
+++ b/reference/ranges/iota_view.md
@@ -92,11 +92,11 @@ namespace std {
 int main() {
   using namespace std;
 
-  for (int i : ranges::iota(1, 10)) {
+  for (int i : views::iota(1, 10)) {
     cout &amp;lt;&amp;lt; i;
   }
   cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
-  for (int i : ranges::iota(10)) {
+  for (int i : views::iota(10)) {
      cout &amp;lt;&amp;lt; i;
      break;
   }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>