<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-02-12T02:14:10.120731</updated>
  <id>49c5a760-15af-4a1b-ac07-3364b3cf3d39</id>

  
    <entry>
      <title>is_member_pointer -- is_member_pointer: 例示コードを修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_member_pointer.html"/>
      <id>725e24133c61ba90fd461f88f3731d52b9eab1f8:reference/type_traits/is_member_pointer.md</id>
      <updated>2021-02-12T11:08:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_member_pointer.md b/reference/type_traits/is_member_pointer.md
index 156db988e..f35aafe83 100644
--- a/reference/type_traits/is_member_pointer.md
+++ b/reference/type_traits/is_member_pointer.md
@@ -35,27 +35,27 @@ struct s
   static void static_member_function(){} // decltype(&amp;amp;s::static_member_function) は void (*)()
 };
 
-static_assert(std::is_member_object_pointer&amp;lt;int s::*&amp;gt;::value == true, &amp;#34;value == true, int s::* is member pointer&amp;#34;);
-static_assert(std::is_same&amp;lt;std::is_member_object_pointer&amp;lt;int s::*&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_type == bool&amp;#34;);
-static_assert(std::is_same&amp;lt;std::is_member_object_pointer&amp;lt;int s::*&amp;gt;::type, std::true_type&amp;gt;::value, &amp;#34;type == true_type&amp;#34;);
-static_assert(std::is_member_object_pointer&amp;lt;int s::*&amp;gt;() == true, &amp;#34;is_member_object_pointer&amp;lt;int s::*&amp;gt;() == true&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int s::*&amp;gt;::value == true, &amp;#34;value == true, int s::* is member pointer&amp;#34;);
+static_assert(std::is_same&amp;lt;std::is_member_pointer&amp;lt;int s::*&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_type == bool&amp;#34;);
+static_assert(std::is_same&amp;lt;std::is_member_pointer&amp;lt;int s::*&amp;gt;::type, std::true_type&amp;gt;::value, &amp;#34;type == true_type&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int s::*&amp;gt;() == true, &amp;#34;is_member_pointer&amp;lt;int s::*&amp;gt;() == true&amp;#34;);
 
-static_assert(std::is_member_object_pointer&amp;lt;int&amp;gt;::value == false, &amp;#34;value == false, int is not member pointer&amp;#34;);
-static_assert(std::is_same&amp;lt;std::is_member_object_pointer&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_type == bool&amp;#34;);
-static_assert(std::is_same&amp;lt;std::is_member_object_pointer&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
-static_assert(std::is_member_object_pointer&amp;lt;int&amp;gt;() == false, &amp;#34;is_member_object_pointer&amp;lt;int&amp;gt;() == false&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int&amp;gt;::value == false, &amp;#34;value == false, int is not member pointer&amp;#34;);
+static_assert(std::is_same&amp;lt;std::is_member_pointer&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_type == bool&amp;#34;);
+static_assert(std::is_same&amp;lt;std::is_member_pointer&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int&amp;gt;() == false, &amp;#34;is_member_pointer&amp;lt;int&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_member_object_pointer&amp;lt;int s::* const&amp;gt;::value == true, &amp;#34;int s::* const is member pointer&amp;#34;);
-static_assert(std::is_member_object_pointer&amp;lt;const int s::*&amp;gt;::value == true, &amp;#34;const int s::* is member pointer&amp;#34;);
-static_assert(std::is_member_object_pointer&amp;lt;int* s::*&amp;gt;::value == true, &amp;#34;int* s::* is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int s::* const&amp;gt;::value == true, &amp;#34;int s::* const is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;const int s::*&amp;gt;::value == true, &amp;#34;const int s::* is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;int* s::*&amp;gt;::value == true, &amp;#34;int* s::* is member pointer&amp;#34;);
 
-static_assert(std::is_member_function_pointer&amp;lt;void (s::* const)()&amp;gt;::value == true, &amp;#34;void (s::* const)() is member pointer&amp;#34;);
-static_assert(std::is_member_function_pointer&amp;lt;void (s::*)() const&amp;gt;::value == true, &amp;#34;void (s::*)() const is member pointer&amp;#34;);
-static_assert(std::is_member_function_pointer&amp;lt;const int* (s::*)()&amp;gt;::value == true, &amp;#34;const int* (s::*)() is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;void (s::* const)()&amp;gt;::value == true, &amp;#34;void (s::* const)() is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;void (s::*)() const&amp;gt;::value == true, &amp;#34;void (s::*)() const is member pointer&amp;#34;);
+static_assert(std::is_member_pointer&amp;lt;const int* (s::*)()&amp;gt;::value == true, &amp;#34;const int* (s::*)() is member pointer&amp;#34;);
 
 int main(){}
 ```
-* std::is_member_object_pointer[color ff0000]
+* std::is_member_pointer[color ff0000]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>要素数不明の配列への変換を許可 -- 要素数不明の配列への変換を許可 : 例の間違いを修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.html"/>
      <id>f1fbc50a6f8940c23e744d0a0dc784b0f82c212e:lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md</id>
      <updated>2021-02-10T14:14:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md b/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
index 584cf486d..b540cc2b1 100644
--- a/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
+++ b/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
@@ -49,7 +49,7 @@ int main()
 void f(int(&amp;amp;&amp;amp;)[]){ std::cout &amp;lt;&amp;lt; &amp;#34;unknown bound\n&amp;#34;; }
 void f(int(&amp;amp;&amp;amp;)[0]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 0\n&amp;#34;; }
 void f(int(&amp;amp;&amp;amp;)[2]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 2\n&amp;#34;; }
-void f(int(&amp;amp;&amp;amp;)[4]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 3\n&amp;#34;; }
+void f(int(&amp;amp;&amp;amp;)[4]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 4\n&amp;#34;; }
 
 void g(int(&amp;amp;&amp;amp;)[]){ std::cout &amp;lt;&amp;lt; &amp;#34;unknown bound\n&amp;#34;; }
 void g(double(&amp;amp;&amp;amp;)[0]){ std::cout &amp;lt;&amp;lt; &amp;#34;bound 0\n&amp;#34;; }
@@ -69,6 +69,7 @@ int main()
   g({0});
   g({0, 0});
   g({0, 0, 0});
+  g({0.0, 0.0});
 }
 ```
 
@@ -79,7 +80,7 @@ bound 0
 unknown bound
 bound 2
 unknown bound
-bound 3
+bound 4
 unknown bound
 g:
 unknown bound
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>lpha</name>
        <email>sphenocorona@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>要素数不明の配列への変換を許可 -- 要素数不明の配列への変換を許可 : 仕様の例の説明を修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.html"/>
      <id>4bf3c981d3095999018967b2f713c691233d3834:lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md</id>
      <updated>2021-02-10T14:14:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md b/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
index 05389cc4d..584cf486d 100644
--- a/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
+++ b/lang/cpp20/permit_conversions_to_arrays_of_unknown_bound.md
@@ -35,8 +35,8 @@ void f(int    (&amp;amp;&amp;amp;)[2]){ std::cout &amp;lt;&amp;lt; &amp;#34;#3 called\n&amp;#34;; } // #3
 int main()
 {
   f({1});          // #1を呼ぶ: 型が一致していて、要素数が一致する候補がないため#1になる。
-  f({1.0});        // #2を呼ぶ: floatからの変換はdoubleとintならdoubleが選ばれる。
-  f({1.0, 2.0});   // #2を呼ぶ: floatからの変換はdoubleとintならdoubleが選ばれる。
+  f({1.0});        // #2を呼ぶ: 浮動小数点数からの変換はdoubleとintならdoubleが選ばれる。
+  f({1.0, 2.0});   // #2を呼ぶ: 浮動小数点数からの変換はdoubleとintならdoubleが選ばれる。
   f({1, 2});       // #3を呼ぶ: 要素数が明示されている方が優先されるので#1にはならない。
                    // また、型が一致する方が優先されるので#2にはならない。
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>lpha</name>
        <email>sphenocorona@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cpprefjp特有の拡張構文 -- cpprefjp特有の拡張構文 : category, concept, named requirement, cpp23関係を追加 #779</title>
      <link href="https://cpprefjp.github.io/editors_doc/specialized.html"/>
      <id>fc364649c8ab234b92e452e46cd3b18f01783c46:editors_doc/specialized.md</id>
      <updated>2021-02-10T19:35:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/editors_doc/specialized.md b/editors_doc/specialized.md
index da2eeeae5..7a3067e5d 100644
--- a/editors_doc/specialized.md
+++ b/editors_doc/specialized.md
@@ -203,7 +203,8 @@ Warning: [nolinked editors_doc/specialized.md] href &amp;#34;/reference/foobar.md.nolink
 
 * `[meta header]`: 所属ヘッダを表すメタ情報
     * 例: `* chrono[meta header]`
-* `[meta id-type]`: 識別子の種別を表すメタ情報。class, class template, function, function template, enum, variable, type-alias, macro, namespace
+* `[meta category]`: 説明用の機能群を表すメタ情報
+* `[meta id-type]`: 識別子の種別を表すメタ情報。class, class template, function, function template, enum, variable, type-alias, macro, namespace, concept, named requirement
 * `[meta namespace]`: 所属する名前空間を表すメタ情報。マクロを考慮して省略可。名前空間の区切りは`::`
     * 例: `* std[meta namespace]`
     * 例: `* std::chrono[meta namespace]`
@@ -213,6 +214,7 @@ Warning: [nolinked editors_doc/specialized.md] href &amp;#34;/reference/foobar.md.nolink
     * `* cpp14[meta cpp]` : C++14で追加された機能
     * `* cpp17[meta cpp]` : C++17で追加された機能
     * `* cpp20[meta cpp]` : C++20で追加された機能
+    * `* cpp23[meta cpp]` : C++23で追加された機能
     * `* cpp11deprecated[meta cpp]` : C++11で非推奨になった機能
     * `* cpp14deprecated[meta cpp]` : C++14で非推奨になった機能
     * `* cpp14removed[meta cpp]` : C++14で削除された機能
@@ -220,6 +222,8 @@ Warning: [nolinked editors_doc/specialized.md] href &amp;#34;/reference/foobar.md.nolink
     * `* cpp17removed[meta cpp]` : C++17で削除された機能
     * `* cpp20deprecated[meta cpp]` : C++20で非推奨になった機能
     * `* cpp20removed[meta cpp]` : C++20で削除された機能
+    * `* cpp23deprecated[meta cpp]` : C++23で非推奨になった機能
+    * `* cpp23removed[meta cpp]` : C++23で削除された機能
 
 ## 数式
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Callable -- Merge pull request #845 from cpprefjp/cpprefjp/named-requirement</title>
      <link href="https://cpprefjp.github.io/reference/concepts/Callable.html"/>
      <id>b051f54cc843b7579d55f45d932e136b50c1c4f6:reference/concepts/Callable.md</id>
      <updated>2021-02-10T19:08:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/Callable.md b/reference/concepts/Callable.md
index ee2cc6932..efdd42287 100644
--- a/reference/concepts/Callable.md
+++ b/reference/concepts/Callable.md
@@ -1,7 +1,7 @@
 # Callable
 * cpp11[meta cpp]
 * concepts[meta header]
-* concept[meta id-type]
+* named requirement[meta id-type]
 * [meta namespace]
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>INVOKE -- Merge pull request #845 from cpprefjp/cpprefjp/named-requirement</title>
      <link href="https://cpprefjp.github.io/reference/concepts/Invoke.html"/>
      <id>b051f54cc843b7579d55f45d932e136b50c1c4f6:reference/concepts/Invoke.md</id>
      <updated>2021-02-10T19:08:31+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;named requirement&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace &#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;INVOKE&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;用語定義&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;call-signature&lt;/em&gt; とは、戻り値型に続けて丸括弧の中に0個以上の引数型を並べたものである。 &lt;em&gt;cf.&lt;/em&gt; &lt;code&gt;int ( std::string, int )&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-type&lt;/em&gt; とは、関数呼び出し演算子を適用できる型 ( 関数、関数への参照、関数へのポインタ、&lt;code&gt;operator ()&lt;/code&gt; をオーバーロードした型もしくはそれを(直接または間接的に) &lt;code&gt;public&lt;/code&gt; 継承した型 ) もしくはメンバへのポインタ型を指す。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-object&lt;/em&gt; は、 &lt;em&gt;callable-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper-type&lt;/em&gt; は、 &lt;em&gt;callable-object&lt;/em&gt; を保持し、自身に対する関数呼び出し操作が行われたとき、保持しているオブジェクトに委譲する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; は、 &lt;em&gt;call-wrapper-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;target-object&lt;/em&gt; とは、 &lt;em&gt;callable-object&lt;/em&gt; に保持されているオブジェクトのことである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;要件（C++14まで）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が T 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN, R)&lt;/code&gt; を、 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること、と定義する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; が &lt;em&gt;weak-result-type&lt;/em&gt; を用意している場合、メンバ型 &lt;code&gt;result_type&lt;/code&gt; は&lt;em&gt;target-object&lt;/em&gt; の型 &lt;code&gt;T&lt;/code&gt; に応じて次のように定義される。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; がメンバ関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;result_type&lt;/code&gt; という名前のメンバ型を持つとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T::result_type&lt;/code&gt; と等しい。&lt;/li&gt;
&lt;li&gt;どの条件にも当てはまらない場合、 &lt;code&gt;result_type&lt;/code&gt; は定義されない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveAssignable&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++17）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveConstructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/Cryolite/status/216814363221303296&#34; target=&#34;_blank&#34;&gt;第1引数がメンバ関数へのポインタの場合でも非静的メンバデータへのポインタの場合でも，第2引数がクラスオブジェクトへの参照の場合でもポインタの場合でもポインタっぽいものの場合でも，なんか知らんけどそれっぽく上手くいく&lt;/a&gt; ように取り計らった操作のことである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;invoke&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;bind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/thread.html&#34;&gt;thread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/async.html&#34;&gt;async&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/packaged_task.html&#34;&gt;packaged_task&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/call_once.html&#34;&gt;call_once&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>LessThanComparable -- Merge pull request #845 from cpprefjp/cpprefjp/named-requirement</title>
      <link href="https://cpprefjp.github.io/reference/concepts/LessThanComparable.html"/>
      <id>b051f54cc843b7579d55f45d932e136b50c1c4f6:reference/concepts/LessThanComparable.md</id>
      <updated>2021-02-10T19:08:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/LessThanComparable.md b/reference/concepts/LessThanComparable.md
index 60ba9df60..4afa98c7a 100644
--- a/reference/concepts/LessThanComparable.md
+++ b/reference/concepts/LessThanComparable.md
@@ -1,6 +1,6 @@
 # LessThanComparable
 * concepts[meta header]
-* concept[meta id-type]
+* named requirement[meta id-type]
 * [meta namespace]
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ValueSwappable -- Merge pull request #845 from cpprefjp/cpprefjp/named-requirement</title>
      <link href="https://cpprefjp.github.io/reference/concepts/ValueSwappable.html"/>
      <id>b051f54cc843b7579d55f45d932e136b50c1c4f6:reference/concepts/ValueSwappable.md</id>
      <updated>2021-02-10T19:08:31+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;named requirement&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace &#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;ValueSwappable&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ValueSwappableは、イテレータ要件を満たす型のオブジェクトが、間接参照した値で入れ替え可能かを表す要件である&lt;/p&gt;
&lt;h2&gt;要件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;イテレータの要件を満たす型&lt;code&gt;X&lt;/code&gt;のオブジェクト&lt;code&gt;x&lt;/code&gt;において、式&lt;code&gt;*x&lt;/code&gt;によって得られるオブジェクトで&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts/swappable.html&#34;&gt;入れ替え可能&lt;/a&gt;であること&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>