<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-01-07T03:38:06.796052</updated>
  <id>db9fe155-9b22-420f-be0d-5269084814e8</id>

  
    <entry>
      <title>function_ref -- functional/function_ref: some refinement(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref.html"/>
      <id>22a02d493591cb2ca982044feb8a313227f4ec7e:reference/functional/function_ref.md</id>
      <updated>2024-01-07T12:21:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref.md b/reference/functional/function_ref.md
index 63b9db3c9..8d59b4374 100644
--- a/reference/functional/function_ref.md
+++ b/reference/functional/function_ref.md
@@ -16,6 +16,7 @@ namespace std {
 
 ## 概要
 `function_ref`クラステンプレートは、パラメータの型リスト`ArgTypes...`、戻り値の型`R`に合致する、あらゆる関数ポインタ、関数オブジェクト、メンバ関数ポインタ、メンバ変数ポインタを参照できるクラスである。
+メンバ関数やメンバ変数に対してオブジェクトを束縛、関数ポインタや関数オブジェクトに対して第1引数を束縛した状態で参照することもできる。
 
 下記全ての組み合わせ（4種類）に対して、クラステンプレートの部分特殊化が提供される。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- functional/function_ref: some refinement(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref/op_constructor.html"/>
      <id>22a02d493591cb2ca982044feb8a313227f4ec7e:reference/functional/function_ref/op_constructor.md</id>
      <updated>2024-01-07T12:21:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref/op_constructor.md b/reference/functional/function_ref/op_constructor.md
index 5152c1ef4..83be90fc2 100644
--- a/reference/functional/function_ref/op_constructor.md
+++ b/reference/functional/function_ref/op_constructor.md
@@ -34,14 +34,16 @@ constexpr function_ref(const function_ref&amp;amp;) noexcept = default;  // (6)
 
 
 ## テンプレートパラメータ制約
+`function_ref`クラステンプレートパラメータのCV修飾子 *cv* に応じて
+
 - (1) : [`is_function`](/reference/type_traits/is_function.md)`&amp;lt;F&amp;gt;`が`true`、かつ`is-invocable-using&amp;lt;F&amp;gt;`が`true`であること
-- (2) : `T`を`remove_refernce_t&amp;lt;F&amp;gt;`としたとき
-    - `remove_cvref_t&amp;lt;F&amp;gt;`が`function_ref`と同一型ではなく、かつ
-    - [`is_member_pointer_v`](/reference/type_traits/is_member_pointer.md)`T`が`false`であり、かつ
+- (2) : `T`を[`remove_refernce_t`](/reference/type_traits/remove_reference.md)`&amp;lt;F&amp;gt;`としたとき
+    - [`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;F&amp;gt;`が`function_ref`と同一型ではなく、かつ
+    - [`is_member_pointer_v`](/reference/type_traits/is_member_pointer.md)`&amp;lt;T&amp;gt;`が`false`であり、かつ
     - `is-invocable-using&amp;lt;/*cv*/ T&amp;amp;&amp;gt;`が`true`であること
 - (3) : `F`を`decltype(f)`としたとき
     - `is-invocable-using&amp;lt;F&amp;gt;`が`true`であること
-- (4) : `T`を`remove_refernce_t&amp;lt;F&amp;gt;`、`F`を`F`を`decltype(f)`としたとき
+- (4) : `T`を[`remove_refernce_t`](/reference/type_traits/remove_reference.md)`&amp;lt;F&amp;gt;`、`F`を`decltype(f)`としたとき
     - [`is_rvalue_reference_v`](/reference/type_traits/is_rvalue_reference.md)`&amp;lt;U&amp;amp;&amp;amp;&amp;gt;`が`false`であり、かつ
     - `is-invocable-using&amp;lt;F, /*cv*/ T&amp;amp;&amp;gt;`が`true`であること
 - (5) : `F`を`decltype(f)`としたとき
@@ -57,6 +59,8 @@ constexpr function_ref(const function_ref&amp;amp;) noexcept = default;  // (6)
 
 
 ## 効果
+`function_ref`クラステンプレートパラメータのCV修飾子 *cv* に応じて
+
 - (1) : `bound-entity`を`f`で、`thunk-ptr`を説明専用の関数`thunk`へのアドレスで初期化する。
     - [関数呼び出し`thunk(bound-entity, call-args...)`](op_call.md)は[`invoke_r`](/reference/functional/invoke_r.md)`&amp;lt;R&amp;gt;(f, call-args...)`と等価。
 - (2) : `bound-entity`を[`addressof`](/reference/memory/addressof.md)`(f)`で、`thunk-ptr`を説明専用の関数`thunk`へのアドレスで初期化する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- functional/function_ref: some refinement(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref/op_deduction_guide.html"/>
      <id>22a02d493591cb2ca982044feb8a313227f4ec7e:reference/functional/function_ref/op_deduction_guide.md</id>
      <updated>2024-01-07T12:21:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref/op_deduction_guide.md b/reference/functional/function_ref/op_deduction_guide.md
index 507dd12f2..4ad2b4c14 100644
--- a/reference/functional/function_ref/op_deduction_guide.md
+++ b/reference/functional/function_ref/op_deduction_guide.md
@@ -36,8 +36,8 @@ namespace std {
 ## 備考
 - (2) : `F`を[`remove_pointer_t`](/reference/type_traits/remove_pointer.md)`&amp;lt;decltype(f)&amp;gt;`としたとき、型`function_ref&amp;lt;F&amp;gt;`に推論される。
 - (3) : 型`function_ref&amp;lt;R(A...) noexcept(E)&amp;gt;`に推論される。
-  - `F`が`M G::*`の形式のとき、`R`は[`invoke_result_t`](/reference/type_traits/invoke_result.md)`&amp;lt;F, T&amp;amp;&amp;gt;`、`A...`は空のパック、`E`は`false`とする。
-  - それ以外の形式のときは、テンプレートパラメータ制約の説明を参照。
+    - `F`が`M G::*`の形式のとき、`R`は[`invoke_result_t`](/reference/type_traits/invoke_result.md)`&amp;lt;F, T&amp;amp;&amp;gt;`、`A...`は空のパック、`E`は`false`とする。
+    - それ以外の形式のときは、テンプレートパラメータ制約の説明を参照。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- function_ref/op_constructor.md: fix markup(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref/op_constructor.html"/>
      <id>0a6aa59227fd4e1ddb19a164d5351ecfacaa57ff:reference/functional/function_ref/op_constructor.md</id>
      <updated>2024-01-06T22:11:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref/op_constructor.md b/reference/functional/function_ref/op_constructor.md
index e02e2e7ee..5152c1ef4 100644
--- a/reference/functional/function_ref/op_constructor.md
+++ b/reference/functional/function_ref/op_constructor.md
@@ -42,7 +42,7 @@ constexpr function_ref(const function_ref&amp;amp;) noexcept = default;  // (6)
 - (3) : `F`を`decltype(f)`としたとき
     - `is-invocable-using&amp;lt;F&amp;gt;`が`true`であること
 - (4) : `T`を`remove_refernce_t&amp;lt;F&amp;gt;`、`F`を`F`を`decltype(f)`としたとき
-    - [`is_rvalue_reference_v](/reference/type_traits/is_rvalue_reference.md)`&amp;lt;U&amp;amp;&amp;amp;&amp;gt;`が`false`であり、かつ
+    - [`is_rvalue_reference_v`](/reference/type_traits/is_rvalue_reference.md)`&amp;lt;U&amp;amp;&amp;amp;&amp;gt;`が`false`であり、かつ
     - `is-invocable-using&amp;lt;F, /*cv*/ T&amp;amp;&amp;gt;`が`true`であること
 - (5) : `F`を`decltype(f)`としたとき
     - `is-invocable-using&amp;lt;F, /*cv*/ T*&amp;gt;`が`true`であること
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>function_ref -- functional/function_ref: 詳細説明(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref.html"/>
      <id>9b4c3b8d48c0e541c1b1bd48e53d4d3e1139a09b:reference/functional/function_ref.md</id>
      <updated>2024-01-06T22:02:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref.md b/reference/functional/function_ref.md
index e9f9f54ac..63b9db3c9 100644
--- a/reference/functional/function_ref.md
+++ b/reference/functional/function_ref.md
@@ -22,7 +22,7 @@ namespace std {
 - CV修飾子 *cv* : `const`, CV修飾無し
 - noexcept例外指定 *noex* : `true`, `false`
 
-`function_ref`クラステンプレートのあらゆる特殊化は[トリビアルコピー可能](/reference/type_traits/is_trivially_copyable.md)である。
+`function_ref`クラステンプレートの特殊化は、[`copyable`](/reference/concepts/copyable.md)のモデルである[トリビアルコピー可能](/reference/type_traits/is_trivially_copyable.md)な型となる。
 
 
 ### `function`ファミリとの比較
@@ -41,17 +41,17 @@ namespace std {
 
 | 名前            | 説明           | 対応バージョン |
 |-----------------|----------------|----------------|
-| [`(constructor)`](function_ref/op_constructor.md.nolink) | コンストラクタ      | C++26 |
-| (destructor) | デストラクタ | C++26 |
-| [`operator=`](function_ref/op_assign.md.nolink) | 代入演算子 | C++26 |
-| [`operator()`](function_ref/op_call.md.nolink) | 関数呼び出し | C++26 |
+| [`(constructor)`](function_ref/op_constructor.md) | コンストラクタ | C++26 |
+| `(destructor)` | デストラクタ | C++26 |
+| [`operator=`](function_ref/op_assign.md) | 代入演算子 | C++26 |
+| [`operator()`](function_ref/op_call.md) | 関数呼び出し | C++26 |
 
 
 ## 推論補助
 
 | 名前 | 説明 | 対応バージョン |
 |-----------------|----------------|----------------|
-| [`(deduction_guide)`](function_ref/op_deduction_guide.md.nolink) | クラステンプレートの推論補助 | C++26 |
+| [`(deduction_guide)`](function_ref/op_deduction_guide.md) | クラステンプレートの推論補助 | C++26 |
 
 
 ## 例
@@ -59,7 +59,7 @@ namespace std {
 ```cpp example
 #include &amp;lt;functional&amp;gt;
 #include &amp;lt;iostream&amp;gt;
-#include &amp;lt;utility&amp;gt;  // nontype
+#include &amp;lt;utility&amp;gt;
 
 // 呼び出し可能な何かを受け取る高階関数
 int hof(std::function_ref&amp;lt;int(int)&amp;gt; fn)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- functional/function_ref: 詳細説明(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref/op_assign.html"/>
      <id>9b4c3b8d48c0e541c1b1bd48e53d4d3e1139a09b:reference/functional/function_ref/op_assign.md</id>
      <updated>2024-01-06T22:02:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref/op_assign.md b/reference/functional/function_ref/op_assign.md
new file mode 100644
index 000000000..2c9f3166d
--- /dev/null
+++ b/reference/functional/function_ref/op_assign.md
@@ -0,0 +1,74 @@
+# operator=
+* functional[meta header]
+* std[meta namespace]
+* function_ref[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+constexpr function_ref&amp;amp; operator=(const function_ref&amp;amp;) noexcept = default; // (1)
+
+template&amp;lt;class T&amp;gt; function_ref&amp;amp; operator=(T) = delete; // (2)
+```
+
+## 概要
+コピー代入演算子。
+
+
+## テンプレートパラメータ制約
+- (2) : 以下の制約をみたすとき、代入演算子はdelete宣言される
+    - `T`が`function_ref`と同一型ではなく、かつ
+    - [`is_pointer_v`](/reference/type_traits/is_pointer.md)`&amp;lt;T&amp;gt;`が`false`であり、かつ
+    - `T`が[`nontype_t`](/reference/utility/nontype_t.md)の特殊化でないこと
+
+
+## 効果
+- (1) : コピー代入。
+
+
+## 戻り値
+`*this`
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int ident(int x)
+{ return x; }
+
+int twice(int x)
+{ return x * 2; }
+
+int main()
+{
+  std::function_ref&amp;lt;int(int)&amp;gt; f = ident;
+  std::function_ref&amp;lt;int(int)&amp;gt; g = twice;
+
+  // コピー代入
+  f = g;
+
+  std::cout &amp;lt;&amp;lt; f(1) &amp;lt;&amp;lt; std::endl;
+}
+```
+
+### 出力
+```
+2
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0792R14 `function_ref`: a type-erased callable reference](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r14.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- functional/function_ref: 詳細説明(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref/op_call.html"/>
      <id>9b4c3b8d48c0e541c1b1bd48e53d4d3e1139a09b:reference/functional/function_ref/op_call.md</id>
      <updated>2024-01-06T22:02:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref/op_call.md b/reference/functional/function_ref/op_call.md
new file mode 100644
index 000000000..b6efb183f
--- /dev/null
+++ b/reference/functional/function_ref/op_call.md
@@ -0,0 +1,70 @@
+# operator()
+* functional[meta header]
+* std[meta namespace]
+* function_ref[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+R operator()(ArgTypes... args) const noexcept(/*noex*/);
+```
+
+## 概要
+関数を呼び出す。
+
+`operator()`のnoexcept例外指定 *noex* は、[`function_ref`](../function_ref.md)に指定するテンプレートパラメータ`R(ArgTypes...)`部のものと等しい。
+
+
+## 効果
+以下と等価。参照対象に応じた詳細仕様は[コンストラクタ](op_constructor.md)説明を参照のこと。
+
+```cpp
+return thunk-ptr(bound-entity, std::forward&amp;lt;ArgTypes&amp;gt;(args)...);
+```
+* thunk-ptr[italic]
+* bound-entity[italic]
+* std::forward[link /reference/utility/forward.md]
+
+
+## 戻り値
+`R`型が`void`の場合は何も返さない。そうでなければ、関数呼び出しの戻り値を返す。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int ident(int x)
+{ return x; }
+
+int main()
+{
+  std::function_ref&amp;lt;int(int)&amp;gt; f = ident;
+
+  // 関数呼び出し : 参照しているident()関数を呼び出す
+  int result = f(1);
+
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+
+### 出力
+```
+1
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0792R14 `function_ref`: a type-erased callable reference](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r14.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- functional/function_ref: 詳細説明(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref/op_constructor.html"/>
      <id>9b4c3b8d48c0e541c1b1bd48e53d4d3e1139a09b:reference/functional/function_ref/op_constructor.md</id>
      <updated>2024-01-06T22:02:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref/op_constructor.md b/reference/functional/function_ref/op_constructor.md
new file mode 100644
index 000000000..e02e2e7ee
--- /dev/null
+++ b/reference/functional/function_ref/op_constructor.md
@@ -0,0 +1,157 @@
+# コンストラクタ
+* functional[meta header]
+* std[meta namespace]
+* function_ref[meta class]
+* function[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class F&amp;gt; function_ref(F* f) noexcept;  // (1)
+
+template&amp;lt;class F&amp;gt;
+constexpr function_ref(F&amp;amp;&amp;amp; f) noexcept;  // (2)
+
+template&amp;lt;auto f&amp;gt;
+constexpr function_ref(nontype_t&amp;lt;f&amp;gt;) noexcept;  // (3)
+template&amp;lt;auto f, class U&amp;gt;
+constexpr function_ref(nontype_t&amp;lt;f&amp;gt;, U&amp;amp;&amp;amp; obj) noexcept;  // (4)
+template&amp;lt;auto f, class T&amp;gt;
+constexpr function_ref(nontype_t&amp;lt;f&amp;gt;, /*cv*/ T* obj) noexcept;  // (5)
+
+constexpr function_ref(const function_ref&amp;amp;) noexcept = default;  // (6)
+```
+* nontype_t[link /reference/utility/nontype_t.md]
+
+## 概要
+`function_ref`オブジェクトを構築する。
+
+`function_ref`クラステンプレートパラメータのnoexcept例外指定 *noex* に応じて、説明用の`bool`型テンプレート定数`is-invocable-using&amp;lt;T...&amp;gt;`を次のように定義する :
+
+- *noex* が`true`のとき : [`is_nothrow_invocable_r_v`](/reference/type_traits/is_nothrow_invocable_r.md)`&amp;lt;R, T..., ArgTypes...&amp;gt;`
+- *noex* が`false`のとき : [`is_invocable_r_v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, T..., ArgTypes...&amp;gt;`
+
+`function_ref`オブジェクトは、説明専用のメンバ変数`thunk-ptr`と`bound-entity`を保持する。
+
+
+## テンプレートパラメータ制約
+- (1) : [`is_function`](/reference/type_traits/is_function.md)`&amp;lt;F&amp;gt;`が`true`、かつ`is-invocable-using&amp;lt;F&amp;gt;`が`true`であること
+- (2) : `T`を`remove_refernce_t&amp;lt;F&amp;gt;`としたとき
+    - `remove_cvref_t&amp;lt;F&amp;gt;`が`function_ref`と同一型ではなく、かつ
+    - [`is_member_pointer_v`](/reference/type_traits/is_member_pointer.md)`T`が`false`であり、かつ
+    - `is-invocable-using&amp;lt;/*cv*/ T&amp;amp;&amp;gt;`が`true`であること
+- (3) : `F`を`decltype(f)`としたとき
+    - `is-invocable-using&amp;lt;F&amp;gt;`が`true`であること
+- (4) : `T`を`remove_refernce_t&amp;lt;F&amp;gt;`、`F`を`F`を`decltype(f)`としたとき
+    - [`is_rvalue_reference_v](/reference/type_traits/is_rvalue_reference.md)`&amp;lt;U&amp;amp;&amp;amp;&amp;gt;`が`false`であり、かつ
+    - `is-invocable-using&amp;lt;F, /*cv*/ T&amp;amp;&amp;gt;`が`true`であること
+- (5) : `F`を`decltype(f)`としたとき
+    - `is-invocable-using&amp;lt;F, /*cv*/ T*&amp;gt;`が`true`であること
+
+
+## 適格要件
+- (3), (4), (5) : `F`を`decltype(f)`としたとき、[`is_pointer`](/reference/type_traits/is_pointer.md)`&amp;lt;F&amp;gt; ||` [`is_member_pointer`](/reference/type_traits/is_member_pointer.md)`&amp;lt;F&amp;gt;`が`true`ならば、`f`がヌルポインタでないこと。
+
+
+## 事前条件
+- (1) : `f`がヌルポインタでないこと。
+
+
+## 効果
+- (1) : `bound-entity`を`f`で、`thunk-ptr`を説明専用の関数`thunk`へのアドレスで初期化する。
+    - [関数呼び出し`thunk(bound-entity, call-args...)`](op_call.md)は[`invoke_r`](/reference/functional/invoke_r.md)`&amp;lt;R&amp;gt;(f, call-args...)`と等価。
+- (2) : `bound-entity`を[`addressof`](/reference/memory/addressof.md)`(f)`で、`thunk-ptr`を説明専用の関数`thunk`へのアドレスで初期化する。
+    - [関数呼び出し`thunk(bound-entity, call-args...)`](op_call.md)は[`invoke_r`](/reference/functional/invoke_r.md)`&amp;lt;R&amp;gt;(static_cast&amp;lt;/*cv*/ T&amp;amp;&amp;gt;(f), call-args...)`と等価。
+- (3) : `bound-entity`を未規定オブジェクトへのポインタまたはヌルポインタで、`thunk-ptr`を説明専用の関数`thunk`へのアドレスで初期化する。
+    - [関数呼び出し`thunk(bound-entity, call-args...)`](op_call.md)は[`invoke_r`](/reference/functional/invoke_r.md)`&amp;lt;R&amp;gt;(f, call-args...)`と等価。
+- (4) : `bound-entity`を[`addressof`](/reference/memory/addressof.md)`(obj)`で、`thunk-ptr`を説明専用の関数`thunk`へのアドレスで初期化する。
+    - [関数呼び出し`thunk(bound-entity, call-args...)`](op_call.md)は[`invoke_r`](/reference/functional/invoke_r.md)`&amp;lt;R&amp;gt;(f, static_cast&amp;lt;/*cv*/ T&amp;amp;&amp;gt;(obj), call-args...)`と等価。
+- (5) : `bound-entity`を`obj`で、`thunk-ptr`を説明専用の関数`thunk`へのアドレスで初期化する。
+    - [関数呼び出し`thunk(bound-entity, call-args...)`](op_call.md)は[`invoke_r`](/reference/functional/invoke_r.md)`&amp;lt;R&amp;gt;(f, obj, call-args...)`と等価。
+- (6) : コピーコンストラクタ。
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int ident_func(int x)
+{ return x; }
+
+struct ident_functor {
+  int operator()(int x) const
+  { return x; }
+};
+
+struct X {
+  int ident_func(int x) const
+  { return x; }
+};
+
+
+int main()
+{
+  // (1) 関数ポインタ
+  {
+    std::function_ref&amp;lt;int(int)&amp;gt; f1 = &amp;amp;ident_func;
+    std::cout &amp;lt;&amp;lt; &amp;#34;(1) : &amp;#34; &amp;lt;&amp;lt; f1(1) &amp;lt;&amp;lt; std::endl;
+  }
+  // (2) 関数オブジェクト
+  {
+    ident_functor functor;
+    std::function_ref&amp;lt;int(int)&amp;gt; f2 = functor;
+    std::cout &amp;lt;&amp;lt; &amp;#34;(2) : &amp;#34; &amp;lt;&amp;lt; f2(2) &amp;lt;&amp;lt; std::endl;
+  }
+  // (3) メンバ関数
+  {
+    std::function_ref&amp;lt;int(X&amp;amp;, int)&amp;gt; f3 = std::nontype&amp;lt;&amp;amp;X::ident&amp;gt;;
+    X obj;
+    std::cout &amp;lt;&amp;lt; &amp;#34;(3) : &amp;#34; &amp;lt;&amp;lt; f3(obj, 3) &amp;lt;&amp;lt; std::endl;
+  }
+  // (4), (5) メンバ関数＋オブジェクト束縛
+  {
+    X obj;
+    std::function_ref&amp;lt;int(int)&amp;gt; f4{std::nontype&amp;lt;&amp;amp;X::ident&amp;gt;, obj};
+    std::cout &amp;lt;&amp;lt; &amp;#34;(4) : &amp;#34; &amp;lt;&amp;lt; f4(4) &amp;lt;&amp;lt; std::endl;
+    std::function_ref&amp;lt;int(int)&amp;gt; f5{std::nontype&amp;lt;&amp;amp;X::ident&amp;gt;, &amp;amp;obj};
+    std::cout &amp;lt;&amp;lt; &amp;#34;(5) : &amp;#34; &amp;lt;&amp;lt; f5(5) &amp;lt;&amp;lt; std::endl;
+  }
+  // (6) コピーコンストラクタ
+  {
+    std::function_ref&amp;lt;int(int)&amp;gt; f1 = &amp;amp;ident_func;
+    std::function_ref&amp;lt;int(int)&amp;gt; f6 = f1;
+    std::cout &amp;lt;&amp;lt; &amp;#34;(6) : &amp;#34; &amp;lt;&amp;lt; f6(6) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::nontype[link /reference/utility/nontype_t.md]
+
+### 出力
+```
+(1) : 1
+(2) : 2
+(3) : 3
+(4) : 4
+(5) : 5
+(6) : 6
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0792R14 `function_ref`: a type-erased callable reference](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r14.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- functional/function_ref: 詳細説明(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/functional/function_ref/op_deduction_guide.html"/>
      <id>9b4c3b8d48c0e541c1b1bd48e53d4d3e1139a09b:reference/functional/function_ref/op_deduction_guide.md</id>
      <updated>2024-01-06T22:02:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/function_ref/op_deduction_guide.md b/reference/functional/function_ref/op_deduction_guide.md
new file mode 100644
index 000000000..507dd12f2
--- /dev/null
+++ b/reference/functional/function_ref/op_deduction_guide.md
@@ -0,0 +1,93 @@
+# 推論補助
+* functional[meta header]
+* std[meta namespace]
+* function_ref[meta class]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class F&amp;gt;
+  function_ref(F*) -&amp;gt; function_ref&amp;lt;F&amp;gt;; // (1)
+
+  template&amp;lt;auto f&amp;gt;
+  function_ref(nontype_t&amp;lt;f&amp;gt;) -&amp;gt; function_ref&amp;lt;see below&amp;gt;; // (2)
+
+  template&amp;lt;auto f, class T&amp;gt;
+  function_ref(nontype_t&amp;lt;f&amp;gt;, T&amp;amp;&amp;amp;) -&amp;gt; function_ref&amp;lt;see below&amp;gt;; // (3)
+}
+```
+* nontype_t[link /reference/utility/nontype_t.md]
+* see below[italic]
+
+
+## 概要
+`std::function_ref`クラステンプレートの型推論補助。
+
+
+## テンプレートパラメータ制約
+- (1) : [`is_function`](/reference/type_traits/is_function.md)`&amp;lt;F&amp;gt;`が`true`であること。
+- (2) : `F`を[`remove_pointer_t`](/reference/type_traits/remove_pointer.md)`&amp;lt;decltype(f)&amp;gt;`としたとき、[`is_function`](/reference/type_traits/is_function.md)`&amp;lt;F&amp;gt;`が`true`であること。
+- (3) : `F`を`decltype(f)`としたとき
+    - 型`G`に対して`F`が`R(G::*)(A...) /*cv*/ &amp;amp; noexcept(E)`の形式（参照修飾子`&amp;amp;`は省略可、`E`は`bool`値）、または
+    - 型`G`とオブジェクト型`M`に対して`F`が`M G::*`の形式、または
+    - 型`G`に対して`F`が`R(*)(G, A...) noexcept(E)`の形式（`E`は`bool`値）であること
+
+
+## 備考
+- (2) : `F`を[`remove_pointer_t`](/reference/type_traits/remove_pointer.md)`&amp;lt;decltype(f)&amp;gt;`としたとき、型`function_ref&amp;lt;F&amp;gt;`に推論される。
+- (3) : 型`function_ref&amp;lt;R(A...) noexcept(E)&amp;gt;`に推論される。
+  - `F`が`M G::*`の形式のとき、`R`は[`invoke_result_t`](/reference/type_traits/invoke_result.md)`&amp;lt;F, T&amp;amp;&amp;gt;`、`A...`は空のパック、`E`は`false`とする。
+  - それ以外の形式のときは、テンプレートパラメータ制約の説明を参照。
+
+
+## 例
+```cpp example
+#include &amp;lt;functional&amp;gt;
+
+int ident(int x) { return x; }
+
+struct X {
+  int data;
+  int mf(int x) { return x; }
+};
+
+int fun(X&amp;amp; obj) { return obj.data; }
+
+int main()
+{
+  // (1) 関数ポインタ
+  std::function_ref f1{&amp;amp;ident};
+
+  // (2) 関数ポインタ/NTTP
+  std::function_ref f2{std::nontype&amp;lt;&amp;amp;ident&amp;gt;};
+
+  // (3a) メンバ関数＋オブジェクト束縛
+  X obj{42};
+  std::function_ref f3a{std::nontype&amp;lt;&amp;amp;X::mf&amp;gt;, obj};
+  // (3b) メンバ変数＋オブジェクト束縛
+  std::function_ref f3b{std::nontype&amp;lt;&amp;amp;X::data&amp;gt;, obj};
+  // (3c) 関数ポインタ＋第1引数束縛
+  std::function_ref f3c{std::nontype&amp;lt;&amp;amp;fun&amp;gt;, obj};
+}
+```
+* std::function_ref[color ff0000]
+* std::nontype[link /reference/utility/nontype_t.md]
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0792R14 `function_ref`: a type-erased callable reference](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0792r14.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nontype_t -- functional/function_ref: 詳細説明(#1192)</title>
      <link href="https://cpprefjp.github.io/reference/utility/nontype_t.html"/>
      <id>9b4c3b8d48c0e541c1b1bd48e53d4d3e1139a09b:reference/utility/nontype_t.md</id>
      <updated>2024-01-06T22:02:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/nontype_t.md b/reference/utility/nontype_t.md
index 4d16bbf05..09211efc9 100644
--- a/reference/utility/nontype_t.md
+++ b/reference/utility/nontype_t.md
@@ -67,7 +67,7 @@ Bow-wow
 
 
 ## 関連項目
-- [`copyable_function`](/reference/functional/copyable_function.md)
+- [`function_ref`](/reference/functional/function_ref.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>arrive -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/arrive.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/barrier/barrier/arrive.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/arrive.md b/reference/barrier/barrier/arrive.md
index e4288e446..0f79daa98 100644
--- a/reference/barrier/barrier/arrive.md
+++ b/reference/barrier/barrier/arrive.md
@@ -16,7 +16,7 @@
 
 
 ## 事前条件
-`updte &amp;gt; 0` かつ `update` が現行バリアフェーズの予定カウントに等しいかそれより小さいこと。
+`update &amp;gt; 0` かつ `update` が現行バリアフェーズの予定カウントに等しいかそれより小さいこと。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-- -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/chrono/duration/op_decrement.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/chrono/duration/op_decrement.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/duration/op_decrement.md b/reference/chrono/duration/op_decrement.md
index b3f6d015e..6d9617b9e 100644
--- a/reference/chrono/duration/op_decrement.md
+++ b/reference/chrono/duration/op_decrement.md
@@ -18,7 +18,7 @@ constexpr duration operator--(int); // (2) C++17
 
 
 ## 戻り値
-- `duration&amp;amp; opertor--()` : `--rep_; return *this`;
+- `duration&amp;amp; operator--()` : `--rep_; return *this`;
 - `duration operator--(int)` : `return duration(rep_--);`
 
 ※ `rep_`は内部で保持している値。メンバ変数名は説明用のもの。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator++ -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/chrono/duration/op_increment.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/chrono/duration/op_increment.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/duration/op_increment.md b/reference/chrono/duration/op_increment.md
index c0deafcae..2d8c57867 100644
--- a/reference/chrono/duration/op_increment.md
+++ b/reference/chrono/duration/op_increment.md
@@ -17,7 +17,7 @@ constexpr duration operator++(int); // (2) C++17
 `duration`の値をインクリメントする
 
 ## 戻り値
-- `duration&amp;amp; opertor++()` : `++rep_; return *this;`
+- `duration&amp;amp; operator++()` : `++rep_; return *this;`
 - `duration operator++(int)` : `return duration(rep_++);`
 
 ※ `rep_`は内部で保持している値。メンバ変数名は説明用のもの。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_three_way_result -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/compare/compare_three_way_result.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/compare/compare_three_way_result.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/compare/compare_three_way_result.md b/reference/compare/compare_three_way_result.md
index edf34bbac..1706db2fd 100644
--- a/reference/compare/compare_three_way_result.md
+++ b/reference/compare/compare_three_way_result.md
@@ -95,7 +95,7 @@ false
 
 ```cpp
 template&amp;lt;typename T, typename U = T&amp;gt;
-concept simple_3way_compareble = requires(const std::remove_reference_t&amp;lt;T&amp;gt;&amp;amp; t, const std::remove_reference_t&amp;lt;U&amp;gt;&amp;amp; u) {
+concept simple_3way_comparable = requires(const std::remove_reference_t&amp;lt;T&amp;gt;&amp;amp; t, const std::remove_reference_t&amp;lt;U&amp;gt;&amp;amp; u) {
   t &amp;lt;=&amp;gt; u;
 };
 
@@ -103,7 +103,7 @@ template&amp;lt;typename T, typename U = T&amp;gt;
 struct compare_three_way_result {};
 
 template&amp;lt;typename T, typename U&amp;gt;
-requires simple_3way_compareble&amp;lt;T, U&amp;gt;
+requires simple_3way_comparable&amp;lt;T, U&amp;gt;
 struct compare_three_way_result&amp;lt;T, U&amp;gt; {
   using type = decltype(declval&amp;lt;const remove_reference_t&amp;lt;T&amp;gt;&amp;amp;&amp;gt;() &amp;lt;=&amp;gt; declval&amp;lt;const remove_reference_t&amp;lt;U&amp;gt;&amp;amp;&amp;gt;());
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>three_way_comparable -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/compare/three_way_comparable.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/compare/three_way_comparable.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/compare/three_way_comparable.md b/reference/compare/three_way_comparable.md
index 49c44dd75..0626c244d 100644
--- a/reference/compare/three_way_comparable.md
+++ b/reference/compare/three_way_comparable.md
@@ -95,7 +95,7 @@ concept three_way_comparable_with =
     - `(a &amp;lt;=&amp;gt; b &amp;lt;= 0) == bool(a &amp;lt;= b)`が`true`であること
     - `(a &amp;lt;=&amp;gt; b &amp;gt;= 0) == bool(a &amp;gt;= b)`が`true`であること
     - `Cat`が`strong_ordering`に変換可能ならば
-        - `T`は`totally_orderd`のモデルである
+        - `T`は`totally_ordered`のモデルである
   
 - (2) : `const remove_reference_t&amp;lt;T&amp;gt;, const remove_reference_t&amp;lt;U&amp;gt;`の左辺値`t, u`、`C = common_reference_t&amp;lt;const remove_reference_t&amp;lt;T&amp;gt;&amp;amp;, const remove_reference_t&amp;lt;U&amp;gt;&amp;amp;&amp;gt;`について次の条件を満たす場合に限って、型`T, U, Cat`は`three_way_comparable_with`のモデルである
     - `t &amp;lt;=&amp;gt; u`と`u &amp;lt;=&amp;gt; t`が同じ[定義域](/reference/concepts.md)を持つ
@@ -108,7 +108,7 @@ concept three_way_comparable_with =
     - `(t &amp;lt;=&amp;gt; u &amp;lt;= 0) == bool(t &amp;lt;= u)`が`true`であること
     - `(t &amp;lt;=&amp;gt; u &amp;gt;= 0) == bool(t &amp;gt;= u)`が`true`であること
     - `Cat`が`strong_ordering`に変換可能ならば
-        - `T, U`は`totally_orderd_with`のモデルである
+        - `T, U`は`totally_ordered_with`のモデルである
 
 - `partially-ordered-with` : `const remove_reference_t&amp;lt;T&amp;gt;, const remove_reference_t&amp;lt;U&amp;gt;`の左辺値`t, u`について次の条件を満たす場合に限って、型`T, U, Cat`は`partially-ordered-with`のモデルである
     - `t &amp;lt; u, t &amp;lt;= u, t &amp;gt; u, t &amp;gt;= u, u &amp;lt; t, u &amp;lt;= t, u &amp;gt; t, u &amp;gt;= t`が全て同じ[定義域](/reference/concepts.md)を持つ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>div -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/cstdlib/div.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/cstdlib/div.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdlib/div.md b/reference/cstdlib/div.md
index 1940b7e9e..afa02c600 100644
--- a/reference/cstdlib/div.md
+++ b/reference/cstdlib/div.md
@@ -46,7 +46,7 @@ namespace std {
 * lldiv_t[link lldiv_t.md]
 
 ## 概要
-`number / denom`と`number % denom`の計算をひとつの操作で行う。
+`numer / denom`と`numer % denom`の計算をひとつの操作で行う。
 
 - (1) : `int`型のオーバーロード
 - (2) : `long`型のオーバーロード
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hardware_destructive_interference_size -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/new/hardware_destructive_interference_size.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/new/hardware_destructive_interference_size.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/new/hardware_destructive_interference_size.md b/reference/new/hardware_destructive_interference_size.md
index 375be35fe..78ca67e86 100644
--- a/reference/new/hardware_destructive_interference_size.md
+++ b/reference/new/hardware_destructive_interference_size.md
@@ -50,7 +50,7 @@ struct X {
   alignas(std::hardware_destructive_interference_size) int b;
 };
 
-struct IndivisualCacheInt {
+struct IndividualCacheInt {
   alignas(std::hardware_destructive_interference_size) int value;
 };
 
@@ -83,7 +83,7 @@ int main()
 
   // 連続したメモリの各要素を、個別のキャッシュに乗せる
   {
-    std::vector&amp;lt;IndivisualCacheInt&amp;gt; v{10};
+    std::vector&amp;lt;IndividualCacheInt&amp;gt; v{10};
     std::vector&amp;lt;std::thread&amp;gt; threads;
     for (std::size_t i = 0; i &amp;lt; v.size(); ++i) {
       threads.push_back(std::thread{[&amp;amp;v, i]{
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>size -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/ranges/size.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/ranges/size.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/size.md b/reference/ranges/size.md
index f17af9a87..80d30453e 100644
--- a/reference/ranges/size.md
+++ b/reference/ranges/size.md
@@ -19,7 +19,7 @@ Rangeの要素数を取得する関数オブジェクト。
 部分式`E`の型を`T`、`t`を`E`を評価した値とする。このとき、式`ranges::size(E)`の効果は以下の通り。
 
 1. `T`が配列型であれば、[`decay-copy`](/reference/exposition-only/decay-copy.md)`(`[`extent_v`](/reference/type_traits/extent.md)`&amp;lt;T&amp;gt;)`に等しい(expression‑equivalent)。ただし、要素数不明の配列であれば、呼び出しは不適格。
-2. [`disable_sized_range`](disable_sized_range.md)`&amp;lt;`[`remove_cv_t`](/reference/type_traits/remove_cv.md)`&amp;lt;T&amp;gt;&amp;gt;`が`false`、かつ[`decay-copy`](/reference/exposition-only/decay-copy.md)`(t.size())`が整数型(interger-like)の有効な式であれば、[`decay-copy`](/reference/exposition-only/decay-copy.md)`(t.size())`と等しい。
+2. [`disable_sized_range`](disable_sized_range.md)`&amp;lt;`[`remove_cv_t`](/reference/type_traits/remove_cv.md)`&amp;lt;T&amp;gt;&amp;gt;`が`false`、かつ[`decay-copy`](/reference/exposition-only/decay-copy.md)`(t.size())`が整数型(integer-like)の有効な式であれば、[`decay-copy`](/reference/exposition-only/decay-copy.md)`(t.size())`と等しい。
 3. `T`がクラス型または列挙体であって、[`disable_sized_range`](disable_sized_range.md)`&amp;lt;`[`remove_cv_t`](/reference/type_traits/remove_cv.md)`&amp;lt;T&amp;gt;&amp;gt;`が`false`、かつ`size`がADLで見つかり、[`decay-copy`](/reference/exposition-only/decay-copy.md)`(size(t))`が整数型の有効な式であれば、[`decay-copy`](/reference/exposition-only/decay-copy.md)`(size(t))`と等しい。
 4. `to-unsigned-like(`[`ranges::end`](end.md)`(t) - `[`ranges::begin`](begin.md)`(t))`が有効な式で、[`ranges::begin`](begin.md)の型`I`、[`ranges::end`](end.md)の型`S`が[`sized_sentinel_for`](/reference/iterator/disable_sized_sentinel_for.md)`&amp;lt;S, I&amp;gt;`と[`forward_iterator`](/reference/iterator/forward_iterator.md)のモデルであれば、`to-unsigned-like(`[`ranges::end`](end.md)`(t) - `[`ranges::begin`](begin.md)`(t))`と等しい。
 
@@ -33,7 +33,7 @@ Rangeの要素数。
 もしくは、メンバ関数`size`を持たせるなどの方法でカスタマイズできる。
 
 ## 備考
-`ranges::size(E)`が有効な式であるとき、その型は整数型(interger-like)。
+`ranges::size(E)`が有効な式であるとき、その型は整数型(integer-like)。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_trivially_copyable -- Merge pull request #1226 from Joseph0304/fix-typo</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_trivially_copyable.html"/>
      <id>d12c259f0c0ee41070c15526c5e5bec40ee85f87:reference/type_traits/is_trivially_copyable.md</id>
      <updated>2024-01-06T19:22:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_trivially_copyable.md b/reference/type_traits/is_trivially_copyable.md
index 52671bec7..c116b55b1 100644
--- a/reference/type_traits/is_trivially_copyable.md
+++ b/reference/type_traits/is_trivially_copyable.md
@@ -203,7 +203,7 @@ static_assert(std::is_trivially_copyable&amp;lt;DeletedDestructor&amp;gt;::value == false, &amp;#34;De
 #ifdef __cpp_concepts
 // #1も#2も資格のあるコピーコンストラクタではなく、他に資格のあるコピー/ムーブ コンストラクタ/代入演算子がないためトリビアルコピー可能ではない
 static_assert(std::is_trivially_copyable&amp;lt;optional&amp;lt;std::unique_ptr&amp;lt;int&amp;gt;&amp;gt;&amp;gt;::value == false, &amp;#34;std::unique_ptr&amp;lt;int&amp;gt; isn&amp;#39;t trivially copyable&amp;#34;);
-// #2が資格のあるコピーコンストラクタであるが、user-proviedであるためトリビアルコピー可能ではない
+// #2が資格のあるコピーコンストラクタであるが、user-providedであるためトリビアルコピー可能ではない
 static_assert(std::is_trivially_copyable&amp;lt;optional&amp;lt;std::string&amp;gt;&amp;gt;::value == false, &amp;#34;optional&amp;lt;std::string&amp;gt; isn&amp;#39;t trivially copyable&amp;#34;);
 // #1が資格のあるコピーコンストラクタであるのでトリビアルコピー可能
 static_assert(std::is_trivially_copyable&amp;lt;optional&amp;lt;int&amp;gt;&amp;gt;::value == true, &amp;#34;optional&amp;lt;int&amp;gt; is trivially copyable&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>