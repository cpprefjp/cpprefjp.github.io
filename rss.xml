<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-16T14:43:27.476811</updated>
  <id>e14a08cf-b06a-4a41-b7e0-3f7334184264</id>

  
    <entry>
      <title>swap -- ranges::swap : リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/concepts/swap.html"/>
      <id>c12a9d70fa976a36dd29402c6cf4d6385e0537c6:reference/concepts/swap.md</id>
      <updated>2021-05-16T02:30:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/swap.md b/reference/concepts/swap.md
index d39fe9a32..d89cebcc2 100644
--- a/reference/concepts/swap.md
+++ b/reference/concepts/swap.md
@@ -31,7 +31,7 @@ namespace std::ranges {
 2. `a, b`が共に同じ長さの配列型の左辺値であり、`ranges::swap(*a, *b)`が呼び出し可能ならば`ranges::swap_ranges(a, b)`
       - 1か3に委譲して要素毎に`swap`される
 
-3. `a, b`が共に同じ型`T`の左辺値であり、`T`と`T&amp;amp;`は[`move_constructible&amp;lt;T&amp;gt;`](move_constructible.md)及び[`assignable_from&amp;lt;T&amp;amp;, T&amp;gt;`](move_constructible.md)のモデルとなる場合、[`std::swap()`](/reference/utility/swap.md)相当の操作によって`a, b`の値を交換する。
+3. `a, b`が共に同じ型`T`の左辺値であり、`T`と`T&amp;amp;`は[`move_constructible&amp;lt;T&amp;gt;`](move_constructible.md)及び[`assignable_from&amp;lt;T&amp;amp;, T&amp;gt;`](assignable_from.md)のモデルとなる場合、[`std::swap()`](/reference/utility/swap.md)相当の操作によって`a, b`の値を交換する。
 
 4. それ以外の場合、呼び出しは不適格。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- §処理系 内のダブっている箇所を消去</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_assign.html"/>
      <id>1694b472b8415f0d53364ce27823a17ca68a8f25:reference/unordered_map/unordered_map/op_assign.md</id>
      <updated>2021-05-16T00:02:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_assign.md b/reference/unordered_map/unordered_map/op_assign.md
index 01eb369e4..a037e044f 100644
--- a/reference/unordered_map/unordered_map/op_assign.md
+++ b/reference/unordered_map/unordered_map/op_assign.md
@@ -76,7 +76,6 @@ unordered_map&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 - C++11
 
 ### 処理系
-- [Clang](/implementation.md#clang): -
 - [Clang](/implementation.md#clang): 3.0, 3.1
 - [GCC](/implementation.md#gcc): 4.4.7, 4.5.3, 4.6.3, 4.7.0
 - [ICC](/implementation.md#icc): ?
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Kisaragi</name>
        <email>48310258+KisaragiEffective@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- common_type: fix indent</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/common_type.html"/>
      <id>11bd93470d9981dac30568552adc4340b09c9833:reference/type_traits/common_type.md</id>
      <updated>2021-05-14T17:15:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/common_type.md b/reference/type_traits/common_type.md
index 8a76a591e..88220bb65 100644
--- a/reference/type_traits/common_type.md
+++ b/reference/type_traits/common_type.md
@@ -37,8 +37,8 @@ namespace std {
 - `N == 2` : `Types...`の1, 2番目の型を`T1, T2`、`D1 = decay_t&amp;lt;T1&amp;gt;, D2 = decay_t&amp;lt;T2&amp;gt;`として
 	- `T1,T2`に対する`decay`適用が少なくとも片方が恒等写像とならない（`is_same_v&amp;lt;T1, D1&amp;gt; == false || is_same_v&amp;lt;T2, D2&amp;gt; == false`となる）場合、`type = common_type_t&amp;lt;D1, D2&amp;gt;;`
 	- `common_type&amp;lt;T1, T2&amp;gt;`に対するユーザ定義の特殊化が行われていれば、同特殊化を利用する。
-  - `C = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;`が有効な型ならば、`type = C;`
-  - `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
+	- `C = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;`が有効な型ならば、`type = C;`
+	- `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
 	- そうでなければ、メンバ型`type`は定義されない。
 - `N &amp;gt;= 3` : `Types...`の１、2番目の型を`T1, T2`、残りのパラメータパックを`P...`とすると、`type = common_type_t&amp;lt;common_type_t&amp;lt;T1, T2&amp;gt;, P...&amp;gt;;`のように`type`を定義。
 	- 先頭2つの型の共通型を求めて、その型と3番目の型の共通型を求めて、その型と4番目の...というように再帰的に`common_type`を適用していく。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- common_type: 不可視文字を削除</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/common_type.html"/>
      <id>00858756de884b210969ead4aafe7b5f6f2aa893:reference/type_traits/common_type.md</id>
      <updated>2021-05-14T16:46:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/common_type.md b/reference/type_traits/common_type.md
index bc84e9947..8a76a591e 100644
--- a/reference/type_traits/common_type.md
+++ b/reference/type_traits/common_type.md
@@ -38,7 +38,7 @@ namespace std {
 	- `T1,T2`に対する`decay`適用が少なくとも片方が恒等写像とならない（`is_same_v&amp;lt;T1, D1&amp;gt; == false || is_same_v&amp;lt;T2, D2&amp;gt; == false`となる）場合、`type = common_type_t&amp;lt;D1, D2&amp;gt;;`
 	- `common_type&amp;lt;T1, T2&amp;gt;`に対するユーザ定義の特殊化が行われていれば、同特殊化を利用する。
   - `C = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;`が有効な型ならば、`type = C;`
-  - `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_­t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
+  - `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
 	- そうでなければ、メンバ型`type`は定義されない。
 - `N &amp;gt;= 3` : `Types...`の１、2番目の型を`T1, T2`、残りのパラメータパックを`P...`とすると、`type = common_type_t&amp;lt;common_type_t&amp;lt;T1, T2&amp;gt;, P...&amp;gt;;`のように`type`を定義。
 	- 先頭2つの型の共通型を求めて、その型と3番目の型の共通型を求めて、その型と4番目の...というように再帰的に`common_type`を適用していく。
@@ -55,7 +55,7 @@ namespace std {
 `COND-RES`や`CREF`はそれぞれ次のように定義される型を表す説明専用のものである。
 
 - `CREF(X)`
-    - `add_­lvalue_­reference_­t&amp;lt;const remove_­reference_­t&amp;lt;A&amp;gt;&amp;gt;`
+    - `add_lvalue_reference_t&amp;lt;const remove_reference_t&amp;lt;A&amp;gt;&amp;gt;`
 - `COND-REF(X, Y)`
     - `decltype(false ? declval&amp;lt;X(&amp;amp;)()&amp;gt;()() : declval&amp;lt;Y(&amp;amp;)()&amp;gt;()())`
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- common_type: P0898R3反映(C++20)</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/common_type.html"/>
      <id>8a573e3576591d254071659cfa996cb87bfec479:reference/type_traits/common_type.md</id>
      <updated>2021-05-14T16:41:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/common_type.md b/reference/type_traits/common_type.md
index 6397eed10..bc84e9947 100644
--- a/reference/type_traits/common_type.md
+++ b/reference/type_traits/common_type.md
@@ -27,18 +27,19 @@ namespace std {
 ## 効果
 `common_type`は、`Types...`に含まれる全ての型が暗黙変換可能な型を、メンバ型`type`として定義する。
 
-より詳細には、次のように決定される。ただし、C++11では[`decay`](/reference/type_traits/decay.md)を適用するプロセスが、C++14では下記`N == 2`の時のプロセスが、それぞれ行われない。
+より詳細には、次のように決定される。ただし、C++11では[`decay`](/reference/type_traits/decay.md)を適用するプロセスが、C++14では下記`N == 2`の時のプロセスが、C++17では`N == 2`のとき`COND-RES`を適用するプロセスが、それぞれ行われない。
 
 `N = sizeof...(Types)`として
 
 - `N == 0` : メンバ型`type`は定義されない。
 
 - `N == 1` : `Types...`内の唯一の型を`T`とすると、`type = common_type_t&amp;lt;T, T&amp;gt;;`のように`type`を定義。
-- `N == 2` : `Types...`の１、2番目の型を`T1, T2`、`D1 = decay_t&amp;lt;T1&amp;gt;, D2 = decay_t&amp;lt;T2&amp;gt;`として
-	- `T1,T2`に対する`decay`の適用は、少なくとも片方が恒等写像とならない（`is_same_v&amp;lt;T1, D1&amp;gt; &amp;amp;&amp;amp; is_same_v&amp;lt;T2, D2&amp;gt; == false`となる）場合  
-	`type = common_type_t&amp;lt;D1, D2&amp;gt;;`のように`type`を定義。
-	- そうではなく、ユーザ定義の特殊化もない場合、`type = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;;`のように`type`を定義。
-	- 上記の様な型が定義できない場合、メンバ型`type`は定義されない。
+- `N == 2` : `Types...`の1, 2番目の型を`T1, T2`、`D1 = decay_t&amp;lt;T1&amp;gt;, D2 = decay_t&amp;lt;T2&amp;gt;`として
+	- `T1,T2`に対する`decay`適用が少なくとも片方が恒等写像とならない（`is_same_v&amp;lt;T1, D1&amp;gt; == false || is_same_v&amp;lt;T2, D2&amp;gt; == false`となる）場合、`type = common_type_t&amp;lt;D1, D2&amp;gt;;`
+	- `common_type&amp;lt;T1, T2&amp;gt;`に対するユーザ定義の特殊化が行われていれば、同特殊化を利用する。
+  - `C = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;`が有効な型ならば、`type = C;`
+  - `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_­t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
+	- そうでなければ、メンバ型`type`は定義されない。
 - `N &amp;gt;= 3` : `Types...`の１、2番目の型を`T1, T2`、残りのパラメータパックを`P...`とすると、`type = common_type_t&amp;lt;common_type_t&amp;lt;T1, T2&amp;gt;, P...&amp;gt;;`のように`type`を定義。
 	- 先頭2つの型の共通型を求めて、その型と3番目の型の共通型を求めて、その型と4番目の...というように再帰的に`common_type`を適用していく。
 
@@ -50,6 +51,15 @@ namespace std {
 - `T1, T2`はともに参照型でもなく
 - `T1, T2`はともにCV修飾もされていない
 
+
+`COND-RES`や`CREF`はそれぞれ次のように定義される型を表す説明専用のものである。
+
+- `CREF(X)`
+    - `add_­lvalue_­reference_­t&amp;lt;const remove_­reference_­t&amp;lt;A&amp;gt;&amp;gt;`
+- `COND-REF(X, Y)`
+    - `decltype(false ? declval&amp;lt;X(&amp;amp;)()&amp;gt;()() : declval&amp;lt;Y(&amp;amp;)()&amp;gt;()())`
+
+
 ## 特殊化
 `common_type`は以下の条件を満たす場合に、2引数のもの（`common_type&amp;lt;T1, T2&amp;gt;`）に限ってユーザー定義の特殊化が許可されている。
 
@@ -168,3 +178,5 @@ struct common_type&amp;lt;T, U, V...&amp;gt; {
 - [LWG Issue 2141. `common_type` trait produces reference types](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2141)
     - C++11では、`common_type`の結果が参照型になる場合があった。C++14で`decay_t`を通すことにしたことにより、参照型が返されることがなくなった。
 - [P0453R1 Resolving LWG Issues re common_type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0435r1.pdf)
+- [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
+    - C++20で`COND-RES`, `CREF`操作を利用するステップが追加された。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>