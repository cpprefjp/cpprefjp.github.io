<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-05-06T14:39:22.549107</updated>
  <id>2f02002c-72f0-4e5d-b010-0a612745a105</id>

  
    <entry>
      <title>operator= -- packaged_task::resetの実装の動作についても追記 #1270</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/op_assign.html"/>
      <id>2486f062f20953bf9500234b60ca893643f59cc9:reference/future/packaged_task/op_assign.md</id>
      <updated>2024-05-06T15:17:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/op_assign.md b/reference/future/packaged_task/op_assign.md
index 538183840..2dd403be6 100644
--- a/reference/future/packaged_task/op_assign.md
+++ b/reference/future/packaged_task/op_assign.md
@@ -37,7 +37,7 @@ C++11の仕様では、ムーブ代入演算子の効果として古い共有状
 
 「(共有状態を)放棄する(abandon)」とは効果の項(2)の1と2が行われることをいい、「(共有状態を)解放する(release)」とは効果の項(2)の2のみが行われることである。通常、[`promise`](../promise.md)および`packaged_task`は処理結果を提供する側であるため共有状態を所有しなくなるときには前者を行い、[`future`](../future.md)および[`shared_future`](../shared_future.md)は処理結果を受け取る側であるため共有状態を所有しなくなるときには後者を行う。
 
-なお、実際の実装ではClangおよびGCCでは「放棄する(abandon)」の動作になっているが、Visual C++では「解放する(release)」の動作になっている。
+なお、`operator=`の実際の実装では、ClangおよびGCCでは「放棄する(abandon)」の動作になっているが、Visual C++では「解放する(release)」の動作になっている。また、[`reset`](reset.md)では、Clang,GCC,Visual C++のいずれも「放棄する(abandon)」の動作になっている。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino.ssr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- packaged_taskムーブ代入演算子とresetの効果を追記。備考で実装について補足 #1270</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/op_assign.html"/>
      <id>599f09ff3f94f6c3bb943ef59fa76189808313c6:reference/future/packaged_task/op_assign.md</id>
      <updated>2024-05-06T15:09:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/op_assign.md b/reference/future/packaged_task/op_assign.md
index 2d4f859ff..538183840 100644
--- a/reference/future/packaged_task/op_assign.md
+++ b/reference/future/packaged_task/op_assign.md
@@ -18,7 +18,10 @@ packaged_task&amp;amp; operator=(packaged_task&amp;amp;&amp;amp; rhs) noexcept;  // (2)
 
 
 ## 効果
-- (2) : `*this`の共有状態を解放し、`packaged_task(`[`std::move`](/reference/utility/move.md)`(rhs)).swap(*this)`を行う。
+- (2) :
+    1. まず現在の共有状態が準備完了状態([`future_status::ready`](../future_status.md))でなければ、error conditionとして[`broken_promise`](../future_errc.md)を持つ[`future_error`](../future_error.md)例外オブジェクトを格納したのち、準備完了状態にする。ただし、実装によっては、この動作が行われない場合がある(備考を参照)。
+    2. 現在の共有状態を解放する。
+    3. `packaged_task(`[`std::move`](/reference/utility/move.md)`(rhs)).swap(*this)`を行う。
 
 
 ## 戻り値
@@ -29,6 +32,13 @@ packaged_task&amp;amp; operator=(packaged_task&amp;amp;&amp;amp; rhs) noexcept;  // (2)
 - (2) : 投げない
 
 
+## 備考
+C++11の仕様では、ムーブ代入演算子の効果として古い共有状態は「放棄する(abandon)」ではなく「解放する(release)」となっているが、仕様の他の項目(Shared States, Class template promise, および Class template packaged_task内のvoid reset();)の記載との整合性を欠いており、「放棄する(abandon)」とする方が合理性があるため効果の項にはそのように記載した。
+
+「(共有状態を)放棄する(abandon)」とは効果の項(2)の1と2が行われることをいい、「(共有状態を)解放する(release)」とは効果の項(2)の2のみが行われることである。通常、[`promise`](../promise.md)および`packaged_task`は処理結果を提供する側であるため共有状態を所有しなくなるときには前者を行い、[`future`](../future.md)および[`shared_future`](../shared_future.md)は処理結果を受け取る側であるため共有状態を所有しなくなるときには後者を行う。
+
+なお、実際の実装ではClangおよびGCCでは「放棄する(abandon)」の動作になっているが、Visual C++では「解放する(release)」の動作になっている。
+
 ## 例
 ```cpp example
 #include &amp;lt;future&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino.ssr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reset -- packaged_taskムーブ代入演算子とresetの効果を追記。備考で実装について補足 #1270</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/reset.html"/>
      <id>599f09ff3f94f6c3bb943ef59fa76189808313c6:reference/future/packaged_task/reset.md</id>
      <updated>2024-05-06T15:09:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/reset.md b/reference/future/packaged_task/reset.md
index f4333e7ed..59b2d1d70 100644
--- a/reference/future/packaged_task/reset.md
+++ b/reference/future/packaged_task/reset.md
@@ -21,7 +21,7 @@ void reset();
 ```
 * std::move[link /reference/utility/move.md]
 
-によって、新たに共有状態を作成する。古い共有状態は放棄される。
+によって、新たに共有状態を作成する。古い共有状態は放棄される(詳細は[`operator=`](op_assign.md)を参照)。
 
 `f`はメンバ変数として保持している、非同期実行する関数オブジェクト。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino.ssr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>directory_iterator -- (recursive_)directory_iterator : ディレクトリも列挙されることを明記</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/directory_iterator.html"/>
      <id>d12d62181564bfc35f400bed89cf4b787d112c44:reference/filesystem/directory_iterator.md</id>
      <updated>2024-05-05T10:54:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/directory_iterator.md b/reference/filesystem/directory_iterator.md
index 844f2da3b..94b9c2051 100644
--- a/reference/filesystem/directory_iterator.md
+++ b/reference/filesystem/directory_iterator.md
@@ -74,7 +74,7 @@ int main()
   fs::create_directory(&amp;#34;dir_a/dir_b&amp;#34;);
   std::ofstream{&amp;#34;dir_a/dir_b/b.txt&amp;#34;};
 
-  // dir_aディレクトリ直下に含まれる全ファイルを出力
+  // dir_aディレクトリ直下に含まれる全ファイル・ディレクトリを出力
   for (const fs::directory_entry&amp;amp; x : fs::directory_iterator(&amp;#34;dir_a&amp;#34;)) {
     std::cout &amp;lt;&amp;lt; x.path() &amp;lt;&amp;lt; std::endl;
   }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>recursive_directory_iterator -- (recursive_)directory_iterator : ディレクトリも列挙されることを明記</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/recursive_directory_iterator.html"/>
      <id>d12d62181564bfc35f400bed89cf4b787d112c44:reference/filesystem/recursive_directory_iterator.md</id>
      <updated>2024-05-05T10:54:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/recursive_directory_iterator.md b/reference/filesystem/recursive_directory_iterator.md
index 65e497b1a..5aab4c90d 100644
--- a/reference/filesystem/recursive_directory_iterator.md
+++ b/reference/filesystem/recursive_directory_iterator.md
@@ -92,7 +92,7 @@ int main()
   fs::create_directory(&amp;#34;dir_a/dir_b&amp;#34;);
   std::ofstream{&amp;#34;dir_a/dir_b/b.txt&amp;#34;};
 
-  // dir_aディレクトリに含まれる全ファイルを再帰的に出力
+  // dir_aディレクトリに含まれる全ファイル・ディレクトリを再帰的に出力
   for (const fs::directory_entry&amp;amp; x : fs::recursive_directory_iterator(&amp;#34;dir_a&amp;#34;)) {
     std::cout &amp;lt;&amp;lt; x.path() &amp;lt;&amp;lt; std::endl;
   }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>empty -- view_interface::empty : LWG Issue 3715対応</title>
      <link href="https://cpprefjp.github.io/reference/ranges/view_interface/empty.html"/>
      <id>16ab0b8514c8390ce0ee6dd92c0bc2032ad371f2:reference/ranges/view_interface/empty.md</id>
      <updated>2024-05-04T20:46:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/view_interface/empty.md b/reference/ranges/view_interface/empty.md
index f82c4d93f..268537a79 100644
--- a/reference/ranges/view_interface/empty.md
+++ b/reference/ranges/view_interface/empty.md
@@ -7,12 +7,13 @@
 
 ```cpp
 constexpr bool empty()
-  requires forward_range&amp;lt;D&amp;gt;;       // (1)
+  requires sized_range&amp;lt;D&amp;gt; || forward_range&amp;lt;D&amp;gt;;       // (1)
 
 constexpr bool empty() const
-  requires forward_range&amp;lt;const D&amp;gt;; // (2)
+  requires sized_range&amp;lt;const D&amp;gt; || forward_range&amp;lt;const D&amp;gt;; // (2)
 ```
 * forward_range[link ../forward_range.md]
+* forward_range[link ../sized_range.md]
 
 ## 概要
 Rangeが空かどうかを判定する。
@@ -20,8 +21,8 @@ Rangeが空かどうかを判定する。
 ## テンプレートパラメータ制約
 [`view_interface`](../view_interface.md)`&amp;lt;D&amp;gt;`に対して、
 
-- (1): `D`が[`forward_range`](../forward_range.md)であること。
-- (2): `const D`が[`forward_range`](../forward_range.md)であること。
+- (1): `D`が[`sized_range`](../sized_range.md)もしくは[`forward_range`](../forward_range.md)であること。
+- (2): `const D`が[`sized_range`](../sized_range.md)もしくは[`forward_range`](../forward_range.md)であること。
 
 ## 戻り値
 (1)、(2)共に、以下と等価：
@@ -49,3 +50,4 @@ ranges::begin(derived()) == ranges::end(derived())
 ## 参照
 - [N4861 24 Ranges library](https://timsong-cpp.github.io/cppwp/n4861/ranges)
 - [C++20 ranges](https://techbookfest.org/product/5134506308665344)
+- [LWG Issue 3715. `view_interface::empty` is overconstrained](https://cplusplus.github.io/LWG/issue3715)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>デストラクタ -- コード例の一行の長さを短く</title>
      <link href="https://cpprefjp.github.io/reference/future/promise/op_destructor.html"/>
      <id>b9d4a50c1206393ba88cd6366d39fb3aace4d8b9:reference/future/promise/op_destructor.md</id>
      <updated>2024-05-02T01:01:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/promise/op_destructor.md b/reference/future/promise/op_destructor.md
index a922bd7d3..a4b55f036 100644
--- a/reference/future/promise/op_destructor.md
+++ b/reference/future/promise/op_destructor.md
@@ -39,7 +39,8 @@ int main()
   std::thread t(calc, std::move(p));
 
   try {
-    std::cout &amp;lt;&amp;lt; f.get() &amp;lt;&amp;lt; std::endl; // 上で書き込まれた例外が送出される
+    // 上で書き込まれた例外が送出される
+    std::cout &amp;lt;&amp;lt; f.get() &amp;lt;&amp;lt; std::endl;
   }
   catch (std::future_error&amp;amp; e) {
     std::cout &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino.ssr@gmail.com</email>
      </author>
    </entry>
  
</feed>