<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-22T06:15:12.605383</updated>
  <id>97aed5f1-b6ee-4db6-a066-0be587f1e942</id>

  
    <entry>
      <title>bucket -- unordered_multimap::bucket : C++26異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/bucket.html"/>
      <id>4d246b623406cad4bdf1376e1c84471d5117c744:reference/unordered_map/unordered_multimap/bucket.md</id>
      <updated>2025-05-22T15:11:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/bucket.md b/reference/unordered_map/unordered_multimap/bucket.md
index ad908cc31..a4e16b261 100644
--- a/reference/unordered_map/unordered_multimap/bucket.md
+++ b/reference/unordered_map/unordered_multimap/bucket.md
@@ -6,20 +6,32 @@
 * cpp11[meta cpp]
 
 ```cpp
-size_type bucket(const key_type&amp;amp; k) const;
+size_type bucket(const key_type&amp;amp; k) const; // (1) C++26
+
+template &amp;lt;class K&amp;gt;
+size_type bucket(const K&amp;amp; k) const;        // (2) C++26
 ```
 
 ## 概要
 指定したキーと等価な要素が格納されている場合、そのバケットのインデックス（添え字）を取得する。
 
+- (1) : `key_type`型のキーを受け取って、バケットのインデックスを取得する
+- (2) : `key_type`と比較可能なキーを受け取って、バケットのインデックスを取得する
+
+
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent` が妥当な式であること
 
-## 要件
+
+## 事前条件
 当該コンテナは [`bucket_count`](bucket_count.md)`() &amp;gt; 0` であること
 
 
 ## 戻り値
 パラメータ `k` と等価なキーの要素が格納されているバケットのインデックス（添え字）
 
+
+## 事後条件
 戻り値は `[0,` [`bucket_count`](bucket_count.md)`())` の範囲である。
 
 
@@ -28,7 +40,10 @@ size_type bucket(const key_type&amp;amp; k) const;
 
 
 ## 備考
-指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- 指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -95,3 +110,6 @@ key = H, bucket = 6, bucket_size = 0
 |---------------------------------------------|----------------------|
 | [`max_bucket_count`](max_bucket_count.md) | 最大バケット数の取得 |
 
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bucket -- unordered_map::bucket : オーバーロードの概要を記載 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/bucket.html"/>
      <id>8378911c8421931c861ebf61ff4a0974e67b3823:reference/unordered_map/unordered_map/bucket.md</id>
      <updated>2025-05-22T15:08:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/bucket.md b/reference/unordered_map/unordered_map/bucket.md
index 25418c5de..0a02d5c0d 100644
--- a/reference/unordered_map/unordered_map/bucket.md
+++ b/reference/unordered_map/unordered_map/bucket.md
@@ -15,6 +15,9 @@ size_type bucket(const K&amp;amp; k) const;        // (2) C++26
 ## 概要
 指定したキーと等価な要素が格納されている場合、そのバケットのインデックス（添え字）を取得する。
 
+- (1) : `key_type`型のキーを受け取って、バケットのインデックスを取得する
+- (2) : `key_type`と比較可能なキーを受け取って、バケットのインデックスを取得する
+
 
 ## テンプレートパラメータ制約
 - (2) : `key_compare::is_transparent` が妥当な式であること
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bucket -- unordered_map::bucket : C++26異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/bucket.html"/>
      <id>567ae393df32e6e6a8bd4e7275da6ad2ae966712:reference/unordered_map/unordered_map/bucket.md</id>
      <updated>2025-05-22T15:06:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/bucket.md b/reference/unordered_map/unordered_map/bucket.md
index 2f7729450..25418c5de 100644
--- a/reference/unordered_map/unordered_map/bucket.md
+++ b/reference/unordered_map/unordered_map/bucket.md
@@ -6,20 +6,29 @@
 * cpp11[meta cpp]
 
 ```cpp
-size_type bucket(const key_type&amp;amp; k) const;
+size_type bucket(const key_type&amp;amp; k) const; // (1) C++11
+
+template &amp;lt;class K&amp;gt;
+size_type bucket(const K&amp;amp; k) const;        // (2) C++26
 ```
 
 ## 概要
 指定したキーと等価な要素が格納されている場合、そのバケットのインデックス（添え字）を取得する。
 
 
-## 要件
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent` が妥当な式であること
+
+
+## 事前条件
 当該コンテナは [`bucket_count`](bucket_count.md)`() &amp;gt; 0` であること
 
 
 ## 戻り値
 パラメータ `k` と等価なキーの要素が格納されているバケットのインデックス（添え字）
 
+
+## 事後条件
 戻り値は `[0,` [`bucket_count`](bucket_count.md)`())` の範囲である。
 
 
@@ -28,7 +37,10 @@ size_type bucket(const key_type&amp;amp; k) const;
 
 
 ## 備考
-指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- 指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -95,3 +107,7 @@ key = H, bucket = 6, bucket_size = 0
 |---------------------------------------------|----------------------|
 | [`max_bucket_count`](max_bucket_count.md) | 最大バケット数の取得 |
 
+
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>at -- unordered_map : atとoperator[]をC++26異種混合ルックアップに対応</title>
      <link href="https://cpprefjp.github.io/reference/map/map/at.html"/>
      <id>bd07d857fbfcbbd5b70f17025d583d9a88d84945:reference/map/map/at.md</id>
      <updated>2025-05-22T14:54:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/at.md b/reference/map/map/at.md
index a73dc3c21..dd0782d6a 100644
--- a/reference/map/map/at.md
+++ b/reference/map/map/at.md
@@ -10,9 +10,9 @@ T&amp;amp; at(const key_type&amp;amp; x);              // (1) C++11
 const T&amp;amp; at(const key_type &amp;amp; x) const; // (2) C++11
 
 template&amp;lt;class K&amp;gt;
-mapped_type&amp;amp; at(const K&amp;amp; x);             // (3) C++26
+T&amp;amp; at(const K&amp;amp; x);                     // (3) C++26
 template&amp;lt;class K&amp;gt;
-const mapped_type&amp;amp; at(const K&amp;amp; x) const; // (4) C++26
+const T&amp;amp; at(const K&amp;amp; x) const;         // (4) C++26
 ```
 
 ## 概要
@@ -40,7 +40,7 @@ const mapped_type&amp;amp; at(const K&amp;amp; x) const; // (4) C++26
 
 
 ## 例外
-- 対応する要素が存在しない場合、[`std::out_of_range`](/reference/stdexcept.md)例外を送出する
+- 指定されたキーに対応する要素が存在しない場合、[`std::out_of_range`](/reference/stdexcept.md)例外を送出する
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>at -- unordered_map : atとoperator[]をC++26異種混合ルックアップに対応</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/at.html"/>
      <id>bd07d857fbfcbbd5b70f17025d583d9a88d84945:reference/unordered_map/unordered_map/at.md</id>
      <updated>2025-05-22T14:54:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/at.md b/reference/unordered_map/unordered_map/at.md
index a6e81bd1f..aa49034fd 100644
--- a/reference/unordered_map/unordered_map/at.md
+++ b/reference/unordered_map/unordered_map/at.md
@@ -6,24 +6,49 @@
 * cpp11[meta cpp]
 
 ```cpp
-T&amp;amp; at(const key_type&amp;amp; x);
-const T&amp;amp; at(const key_type &amp;amp; x) const;
+T&amp;amp; at(const key_type&amp;amp; x);              // (1) C++11
+const T&amp;amp; at(const key_type &amp;amp; x) const; // (2) C++11
+
+template&amp;lt;class K&amp;gt;
+T&amp;amp; at(const K&amp;amp; x);                     // (3) C++26
+template&amp;lt;class K&amp;gt;
+const T&amp;amp; at(const K&amp;amp; x) const;         // (4) C++26
 ```
 
 ## 概要
 参照のためのメソッドで、取り出す時にキーの存在チェックをする。
 
+- (1), (2) : クラスのテンプレートパラメータ`key_type`型のキーに対応する要素を取得する
+- (3), (4) : `key_type`と比較可能な`K`型のキーに対応する要素を取得する
+
+
+## テンプレートパラメータ制約
+- (3), (4) : `key_compare::is_transparent` が妥当な式であること
+
+
+## 事前条件
+- (3), (4) : [`find`](find.md)`(x)`が妥当な式であり、定義された動作をすること
+
+
 ## 戻り値
-キーxに対応する値を返す。
+キー`x`に対応する値を返す。
+
 
 ## 例外
-オブジェクトが存在しないときは、out_of_range例外を投げる。
+- 指定されたキーに対応する要素が存在しない場合、[`std::out_of_range`](/reference/stdexcept.md)例外を送出する
+
 
 ## 計算量
 - 平均： 定数時間
 - 最悪： [`size`](size.md) について線形時間
 
 
+## 備考
+- (3), (4) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -81,3 +106,5 @@ exception std::out_of_range
 
 ## 参照
 - [LWG Issue 761. `unordered_map` needs an `at()` member function](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761)
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator[] -- unordered_map : atとoperator[]をC++26異種混合ルックアップに対応</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_at.html"/>
      <id>bd07d857fbfcbbd5b70f17025d583d9a88d84945:reference/unordered_map/unordered_map/op_at.md</id>
      <updated>2025-05-22T14:54:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_at.md b/reference/unordered_map/unordered_map/op_at.md
index d4d4e7910..a06ea7946 100644
--- a/reference/unordered_map/unordered_map/op_at.md
+++ b/reference/unordered_map/unordered_map/op_at.md
@@ -6,24 +6,44 @@
 * cpp11[meta cpp]
 
 ```cpp
-T&amp;amp; operator[](const key_type&amp;amp; x);
-T&amp;amp; operator[](key_type&amp;amp;&amp;amp; x);
+T&amp;amp; operator[](const key_type&amp;amp; x); // (1) C++11
+
+T&amp;amp; operator[](key_type&amp;amp;&amp;amp; x);      // (2) C++11
+
+template &amp;lt;class K&amp;gt;
+T&amp;amp; operator[](K&amp;amp;&amp;amp; k);             // (3) C++26
 ```
 
 ## 概要
-要素へのアクセス
+要素へのアクセス。
+
+- (1), (2) : クラスのテンプレートパラメータ`key_type`型のキーに対応する要素を取得する
+- (3) : `key_type`と比較可能な`K`型のキーに対応する要素を取得する
+
+
+## テンプレートパラメータ制約
+- (3) : `key_compare::is_transparent` が妥当な式であること
+
 
 ## 戻り値
 キー`x`に対応する値を返す。対応する要素が存在しない場合は、要素を値初期化して参照を返す。
 
+
 ## 例外
 ハッシュ関数以外から例外が投げられた場合には、対応する要素がない場合の新規要素の挿入処理は実施されない。
 
+
 ## 計算量
 - 平均： 定数時間
 - 最悪： [`size`](size.md) について線形時間
 
 
+## 備考
+- (3) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -78,3 +98,8 @@ size=2
 |-----------------------------|----------------|
 | [`operator=`](op_assign.md) | 代入演算子     |
 | [`insert`](insert.md)       | 要素を挿入する |
+
+
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_or_assign -- unordered_map::insert_or_assign : C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/insert_or_assign.html"/>
      <id>6580bd966e200af44dc548b313e93b0a3f84340e:reference/unordered_map/unordered_map/insert_or_assign.md</id>
      <updated>2025-05-22T14:47:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/insert_or_assign.md b/reference/unordered_map/unordered_map/insert_or_assign.md
index a1fc699bd..259f0ef98 100644
--- a/reference/unordered_map/unordered_map/insert_or_assign.md
+++ b/reference/unordered_map/unordered_map/insert_or_assign.md
@@ -7,16 +7,37 @@
 
 ```cpp
 template &amp;lt;class M&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; insert_or_assign(const key_type&amp;amp; k, M&amp;amp;&amp;amp; obj);              // (1)
+pair&amp;lt;iterator, bool&amp;gt;
+  insert_or_assign(const key_type&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (1) C++17
 
 template &amp;lt;class M&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; insert_or_assign(key_type&amp;amp;&amp;amp; k, M&amp;amp;&amp;amp; obj);                   // (2)
+pair&amp;lt;iterator, bool&amp;gt;
+  insert_or_assign(key_type&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (2) C++17
+
+template &amp;lt;class K, class M&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  insert_or_assign(K&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (3) C++26
 
 template &amp;lt;class M&amp;gt;
-iterator insert_or_assign(const_iterator hint, const key_type&amp;amp; k, M&amp;amp;&amp;amp; obj);     // (3)
+iterator
+  insert_or_assign(const_iterator hint,
+                   const key_type&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (4) C++17
 
 template &amp;lt;class M&amp;gt;
-iterator insert_or_assign(const_iterator hint, key_type&amp;amp;&amp;amp; k, M&amp;amp;&amp;amp; obj);          // (4)
+iterator
+  insert_or_assign(const_iterator hint,
+                   key_type&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (5) C++17
+
+template &amp;lt;class K, class M&amp;gt;
+iterator
+  insert_or_assign(const_iterator hint,
+                   K&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (6) C++26
 ```
 * pair[link /reference/utility/pair.md]
 
@@ -25,41 +46,48 @@ iterator insert_or_assign(const_iterator hint, key_type&amp;amp;&amp;amp; k, M&amp;amp;&amp;amp; obj);
 
 引数 `hint` は、`k` を検索する際のヒントに使用される。（が、実際に使用されることはないものと思われる。[`emplace_hint`](emplace_hint.md) の備考を参照）
 
+- (1) : `key_type`型のキーをとって挿入もしくは代入する
+- (2) : `key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
+- (3) : `key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
+- (4) : 挿入位置のヒントをともない、`key_type`型のキーをとって挿入もしくは代入する
+- (5) : 挿入位置のヒントをともない、`key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
+- (6) : 挿入位置のヒントをともない、`key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
+
 
 ## テンプレートパラメータ制約
-- (1)、(3) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
-- (2)、(4) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (3), (6) : `key_compare::is_transparent` が妥当な式であること
+
+
+## 適格要件
+- (1)、(3)、(4)、(6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (2)、(5) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
 
 
 ## 効果
-- (1)、(3) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1)、(3)、(4)、(6) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2)、(5) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 代入された場合には、`first` に代入された要素へのイテレータ、`second` に `false` が設定される。
-- (3)、(4) :
+- (4)、(5)、(6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 代入された場合には、代入された要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2) : [`emplace`](emplace.md) と同じ。
-- (3)、(4) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1)、(2)、(3) : [`emplace`](emplace.md) と同じ。
+- (4)、(5)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
 - 規格にはこの関数の例外安全性についての記載が無いが、[`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) と等価と考えて問題ないと思われる。
-
 - 規格にはこの関数が呼ばれた後のイテレータや要素へのポインタ・参照の有効性についての記載が無いが、[`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) と等価と考えて問題ないと思われる。
-
-- このメンバ関数の[`機能テストマクロ`](/lang/cpp17/feature_test_macros.md)は以下の通り。
-
-    | マクロ名                              | 値       |
-    |---------------------------------------|----------|
-    | `__cpp_lib_unordered_map_try_emplace` | `201411` |
+- (3), (6) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -107,8 +135,6 @@ key = two, value = 42, is inserted = false, is empty = true
 ```
 
 
-
-
 ## バージョン
 ### 言語
 - C++17
@@ -142,3 +168,5 @@ key = two, value = 42, is inserted = false, is empty = true
 - [N4006 An improved emplace() for unique-key maps](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html)
 - [N4240 Improved insertion interface for unique-key maps (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html)
 - [N4279 Improved insertion interface for unique-key maps (Revision 2.3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html)
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>