<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-04-17T03:24:15.850821</updated>
  <id>1eb31142-8a5c-4b5c-8ba7-56dcb8521d5f</id>

  
    <entry>
      <title>noexcept -- noexcept : 指定可能な位置について追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/noexcept.html"/>
      <id>37440305b5e204f34741e3edb9719a7b852bf4f9:lang/cpp11/noexcept.md</id>
      <updated>2023-04-17T12:19:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/noexcept.md b/lang/cpp11/noexcept.md
index 4257e4bcb..2ac2aff52 100644
--- a/lang/cpp11/noexcept.md
+++ b/lang/cpp11/noexcept.md
@@ -56,13 +56,16 @@ struct X {
   // 例外を送出しない
   int getValue() const noexcept;
 //int getValue() const noexcept(true);
+
+  // noexceptは参照修飾と後置戻り値型の間
+  auto getString() const &amp;amp; noexcept -&amp;gt; std::string;
 };
 ```
 * noexcept[color ff0000]
 
 - `noexcept`もしくは`noexcept(trueに評価される整数定数式)`が指定された関数が例外を送出した場合、[`std::terminate()`](/reference/exception/terminate.md)関数を呼び出してプログラムを異常終了させる。その際、[`std::terminate()`](/reference/exception/terminate.md)関数が呼び出される前に、スタックの巻き戻しは起こらない可能性がある。
 - 従来の`throw`キーワードによる例外仕様(C++03ではexception specification、C++11ではdynamic exception specificationと呼ばれる仕様)は、C++11以降で非推奨である。
-
+- `noexcept`の指定可能な位置は、[参照修飾](/lang/cpp11/ref_qualifier_for_this.md)の後、[戻り値の型を後置する関数宣言構文](/lang/cpp11/trailing_return_types.md)の前である。
 
 ### 式が例外を送出する可能性があるか判定するnoexcept演算子
 - 演算子としての`noexcept`は、引数として指定した定数式が例外を送出する可能性があるかどうかをコンパイル時に判定し、`bool`型の定数値を返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>append -- basic_string::append : コメントアウトが外れていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/append.html"/>
      <id>5eaa8eebe4f6275b47229ed76bfb655ae73896a6:reference/string/basic_string/append.md</id>
      <updated>2023-04-17T12:05:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/append.md b/reference/string/basic_string/append.md
index 8ebc7b88d..aec336438 100644
--- a/reference/string/basic_string/append.md
+++ b/reference/string/basic_string/append.md
@@ -54,12 +54,12 @@ template&amp;lt;class T&amp;gt;
 basic_string&amp;amp;
   append(const T&amp;amp; t,
         size_type pos,
-        size_type n = npos); / (9) C++17
+        size_type n = npos); // (9) C++17
 template&amp;lt;class T&amp;gt;
 constexpr basic_string&amp;amp;
   append(const T&amp;amp; t,
         size_type pos,
-        size_type n = npos); / (9) C++20
+        size_type n = npos); // (9) C++20
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator!= -- type_info::operator!= : =が変だったのを修正</title>
      <link href="https://cpprefjp.github.io/reference/typeinfo/type_info/op_not_equal.html"/>
      <id>b240dfdc804d6675c712e38bad9e666d79964225:reference/typeinfo/type_info/op_not_equal.md</id>
      <updated>2023-04-14T16:22:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/typeinfo/type_info/op_not_equal.md b/reference/typeinfo/type_info/op_not_equal.md
index 77ae97dc9..4f5b6435f 100644
--- a/reference/typeinfo/type_info/op_not_equal.md
+++ b/reference/typeinfo/type_info/op_not_equal.md
@@ -12,7 +12,7 @@ bool operator!=(const type_info&amp;amp; rhs) const noexcept; // (1) C++11
 
 ## 概要
 2つの型が異なるかを判定する
-（C++20からは、`operator＝=`から導出される）
+（C++20からは、`operator==`から導出される）
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- pairコンストラクタ : explicitになる条件の調整</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_constructor.html"/>
      <id>abc25987eceb7bfea7f0dee74dd39a6239e074b3:reference/utility/pair/op_constructor.md</id>
      <updated>2023-04-11T10:37:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_constructor.md b/reference/utility/pair/op_constructor.md
index f4a009000..c0eedfa56 100644
--- a/reference/utility/pair/op_constructor.md
+++ b/reference/utility/pair/op_constructor.md
@@ -128,11 +128,13 @@ constexpr pair(piecewise_construct_t,
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
 - (6)-(10) :
     - `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して
-    - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p))), T1&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p))), T2&amp;gt;`である場合、`explicit`指定される
+    - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p))), first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p))), second_type&amp;gt;`である場合、`explicit`指定される
 - (7) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U1&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U2&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
+    - C++23 : (6)-(10) での定義参照（複雑であるが、条件は同等である）
 - (8) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
+    - C++23 : (6)-(10) での定義参照（複雑であるが、条件は同等である）
 
 ## 備考
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- pairコンストラクタ : explicit/delete条件の整理</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_constructor.html"/>
      <id>bbf0c78e4950b3cec5fba5986840fcd0064a38da:reference/utility/pair/op_constructor.md</id>
      <updated>2023-04-11T10:24:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_constructor.md b/reference/utility/pair/op_constructor.md
index 2556f04c2..f4a009000 100644
--- a/reference/utility/pair/op_constructor.md
+++ b/reference/utility/pair/op_constructor.md
@@ -109,26 +109,34 @@ constexpr pair(piecewise_construct_t,
 - (11) :
     - [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;first_type, Args1&amp;amp;&amp;amp;...&amp;gt;::value &amp;amp;&amp;amp;` [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;second_type, Args2&amp;amp;&amp;amp;...&amp;gt;::value`であること
 
+## delete定義される条件（C++23）
+
+- (5) : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;`である場合、このコンストラクタは削除定義される
+- (6)-(10) :
+    - `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して
+    - [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p)))&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p)))&amp;gt;`である場合、このコンストラクタは削除定義される
+- (11) : 要素型（`T1, T2`のどちらかもしくは両方）が参照型であり、初期化によって一時オブジェクトを束縛することになる場合、このコンストラクタは削除定義される
+    - 上記のコンストラクタと同様に、[`reference_constructs_from_temporary`](/reference/type_traits/reference_constructs_from_temporary.md)を使用して判定される
+
+## explicitになる条件
 
-## 備考
 - (1) :
     - C++17 : `first_type`と`second_type`のどちらかが非暗黙にデフォルト構築できない場合、`explicit`指定される
 - (4) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const first_type&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const second_type&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
 - (5) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
-    - C++23 : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;`である場合、このコンストラクタは削除定義される
 - (6)-(10) :
     - `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して
     - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p))), T1&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p))), T2&amp;gt;`である場合、`explicit`指定される
-    - C++23 : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p)))&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p)))&amp;gt;`である場合、このコンストラクタは削除定義される
 - (7) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U1&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U2&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
-    - C++23 : (6)-(10) での定義参照
 - (8) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
-    - C++23 : (6)-(10) での定義参照
-- (11) : このコンストラクタでは`first`/`second`をそのコンストラクタ引数から直接構築するため、ムーブもコピーもできないような型でも初期化することができる
+
+## 備考
+
+- (11)のコンストラクタでは`first`/`second`をそのコンストラクタ引数から直接構築するため、コピーもムーブもできないような型でも初期化することができる
 
 - C++17では、コンストラクタの各オーバーロードが条件付きで`explicit`となるよう規定された。これは、以下のような初期化子リストを使用したC++17での初期化が不適格になっていたため、適格になるようにするための変更である：
     ```cpp
@@ -143,7 +151,7 @@ constexpr pair(piecewise_construct_t,
 
     - この変更はC++17に対するものであるが、コンパイラが早期に対応していたため、一部処理系ではC++14の段階から適格となっていた
 
-- C++23 では、ダングリング参照の作成が簡単にできていた状態を改善するべく、[`reference_constructs_from_temporary`](/reference/type_traits/reference_constructs_from_temporary.md)が追加され、ダングリング参照が作成される場合には不適格とするようになった :
+- C++23 では、ダングリング参照の作成が簡単にできていた状態を改善するべく、[`reference_constructs_from_temporary`](/reference/type_traits/reference_constructs_from_temporary.md)が追加され、一部のコンストラクタにおいてダングリング参照が作成される場合には不適格とするようになった :
     ```cpp
     // コンストラクタ引数で std::string が構築され
     // その一時オブジェクトが束縛されるため、ダングリング参照となっていた
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>