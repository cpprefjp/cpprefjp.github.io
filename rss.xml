<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-12-10T03:29:33.522122</updated>
  <id>e942204e-fa8a-479e-8aec-c2d5b6e0c0d7</id>

  
    <entry>
      <title>article -- Hidden friendsについての記述を追加</title>
      <link href="https://cpprefjp.github.io/article.html"/>
      <id>4753b7c685d7079488a038a8979fcf1c7e855921:article.md</id>
      <updated>2020-12-10T12:24:37+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;article&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;コア言語&lt;/h2&gt;
&lt;p&gt;現在、このカテゴリに関する記事はない。&lt;/p&gt;
&lt;h2&gt;ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/article/lib/how_to_use_cv.html&#34;&gt;条件変数の利用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/article/lib/dont_use_noexcept.html&#34;&gt;標準ライブラリにおける、関数にnoexceptを付けない条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/article/lib/at_thread_exit.html&#34;&gt;&lt;code&gt;_at_thread_exit&lt;/code&gt;系の関数が存在している理由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/article/lib/disable_adl_function.html&#34;&gt;ADLを無効にする関数定義&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/article/lib/hidden_friends.html&#34;&gt;Hidden friends&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;プラットフォーム&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/article/platform/locales.html&#34;&gt;使用できるロケール文字列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;方針&lt;/h2&gt;
&lt;p&gt;article階層にある記事は、以下の方針のもとに執筆しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;個別のリファレンスページでは解説しにくい俯瞰的な記事を提供する&lt;ul&gt;
&lt;li&gt;基本的にはリファレンスページで完結する解説を書くことが望ましいが、複数機能を組み合わせる解説、複数の選択肢があるなかでの設計選択など、個別のリファレンスページで解説することがむずかしいことを、ここで解説する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;時事的な記事は書かない&lt;ul&gt;
&lt;li&gt;C++の新バージョンで新たな機能が追加されたからその解説を書く、ということはせず、その機能が追加されたバージョン以降でずっと役立つ解説を提供する&lt;/li&gt;
&lt;li&gt;キャッチーな機能がC++に追加されてどこか目立つところで解説したいという動機が起きるかもしれないが、短命でおわってしまう機能もなかにはある。長く必要になるであろう内容をある程度吟味し、ブログでなく静的サイトで記事を書く、ということを念頭に置いて内容を考えてほしい&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プラットフォームカテゴリには、標準外のツールについて記載してもかまわない (Visual C++、GDB、Emscriptenなど)&lt;ul&gt;
&lt;li&gt;コンパイラのインストール方法といった環境構築の方法を解説する記事は歓迎したい。ただし特定のバージョンに限定された時事的なものになると更新がむずかしくなってしまう。これは相談しながら方針を決めたい&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;リファレンスページと二重管理になる記事はなるべく書かない&lt;ul&gt;
&lt;li&gt;たとえば本サイトは正引きリファレンスを提供しているが、逆引きリファレンスをこの階層で提供することは二重管理になる。二重管理になると、ひとつの機能を解説するページを書くために多くの箇所を修正しなければならず、執筆やメンテナンスがむずかしくなってしまう。少なくとも執筆リソースが余るような状況でないうちは、二重管理はできる限り避ける方針とする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;「こういう記事を書きたいけど、cpprefjpに必要かわからない」という場合は、GitHubリポジトリのIssueで相談してほしい&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Hidden Friends -- Hidden friendsについての記述を追加</title>
      <link href="https://cpprefjp.github.io/article/lib/hidden_friends.html"/>
      <id>4753b7c685d7079488a038a8979fcf1c7e855921:article/lib/hidden_friends.md</id>
      <updated>2020-12-10T12:24:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/article/lib/hidden_friends.md b/article/lib/hidden_friends.md
new file mode 100644
index 000000000..32b5d1fd0
--- /dev/null
+++ b/article/lib/hidden_friends.md
@@ -0,0 +1,60 @@
+# Hidden Friends
+
+クラスの定義内で`friend`として定義されている関数のことを*Hidden Friends*と呼ぶ。*Hidden Friends*な関数は通常のメンバ関数やグローバル関数の様に呼ぶことは出来ず、ADLでのみ呼び出すことができる。
+
+```cpp
+namespace NS {
+  struct C {
+
+    // メンバ関数
+    void mem_func();
+
+    // Hidden Friends
+    friend void hidden_friend(C&amp;amp; self);
+  };
+
+  // 普通のfriend関数
+  friend void visible_friend(C&amp;amp; self);
+}
+
+int main() {
+  NS::C c{};
+
+  // メンバ関数
+  c.mem_func();           // ok
+  mem_func(c);            // ng
+  NS::mem_func(c);        // ng
+
+  // Hidden friends
+  c.hidden_friend();      // ng
+  hidden_friend(c);       // ok
+  NS::hidden_friend(c);   // ng
+
+  // 普通のfriend関数
+  c.visible_friend();     // ng
+  visible_friend(c);      // ok
+  NS::visible_friend(c);  // ok
+}
+```
+
+C++20以降の標準ライブラリでは一部のカスタマイゼーションポイントの関数や演算子オーバーロードが*Hidden Friends*として定義される様になる。また、標準ライブラリの実装によっては*Hidden Friends*と規定されていない既存の演算子オーバーロードを*Hidden Friends*として定義していることがある。
+
+## 利点
+
+*Hidden Friends*はADL経由でしか呼べず、クラスのインターフェースにも含まれないという性質から次の様な利点がある。
+
+- 暗黙変換による意図しない関数呼び出しの防止
+- グローバル名前空間汚染の抑止
+- クラスインターフェース増加の抑止
+- （グローバル名前空間に定義する時と比較して）オーバーロード候補の減少によるコンパイル時間の削減
+- 一部の演算子オーバーロードでは宣言を簡素化できる
+
+## Customization Point Object（CPO）とHidden Friends
+
+あるクラスについてカスタマイゼーションポイントにアダプトする時には、そのために定義する関数がそのクラスのインターフェースの一部としてそぐわない場合が多いため、多くのCPOは引数型に対して同名の*Hidden Friends*関数を探しに行くように定義されている。
+
+## 参照
+- [Hidden Friends - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20190531/p1)
+- [The Power of Hidden Friends in C++ - Just Software Solutions](https://www.justsoftwaresolutions.co.uk/cplusplus/hidden-friends.html)
+- [P1965R0 Blanket Wording for Specifying “Hidden Friends”](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1965r0.pdf)
+- [LWG Issue 3065 : LWG 2989 missed that all path&amp;#39;s other operators should be hidden friends as well](https://cplusplus.github.io/LWG/issue3065)
\ No newline at end of file
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- Hidden friendsについての記述を追加</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/op_plus.html"/>
      <id>4753b7c685d7079488a038a8979fcf1c7e855921:reference/iterator/counted_iterator/op_plus.md</id>
      <updated>2020-12-10T12:24:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/op_plus.md b/reference/iterator/counted_iterator/op_plus.md
index a18b02143..d4098ca38 100644
--- a/reference/iterator/counted_iterator/op_plus.md
+++ b/reference/iterator/counted_iterator/op_plus.md
@@ -40,7 +40,7 @@ friend constexpr counted_iterator operator+(iter_difference_t&amp;lt;I&amp;gt; n, const counte
 
 ## 備考
 
-(2)は*Hidden friends*として定義される。
+(2)は[*Hidden friends*](/article/lib/hidden_friends.md)として定義される。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>counted_iterator -- counted_iterator::operator+追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator.html"/>
      <id>dd9591e62a71478a780c3ecca08d6692d1a39a29:reference/iterator/counted_iterator.md</id>
      <updated>2020-12-10T11:28:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator.md b/reference/iterator/counted_iterator.md
index 27e1d02ec..4a99d1fd8 100644
--- a/reference/iterator/counted_iterator.md
+++ b/reference/iterator/counted_iterator.md
@@ -53,9 +53,9 @@ namespace std {
 | [`operator*`](counted_iterator/op_deref.md)           | 間接参照演算子 | C++20 |
 | [`operator++`](counted_iterator/op_increment.md)      | イテレータをインクリメントする | C++20 |
 | [`operator--`](counted_iterator/op_decrement.md)      | イテレータをインクリメントする | C++20 |
-| [`operator+`](counted_iterator/op_unary_plus.md.nolink)      | イテレータを進める | C++20 |
+| [`operator+`](counted_iterator/op_plus.md)      | イテレータを進める | C++20 |
 | [`operator+=`](counted_iterator/op_plus_assign.md.nolink)    | イテレータ自身を進める | C++20 |
-| [`operator-`](counted_iterator/op_unary_minus.md.nolink)     | イテレータを逆に進める | C++20 |
+| [`operator-`](counted_iterator/op_minus.md.nolink)     | イテレータを逆に進める | C++20 |
 | [`operator-=`](counted_iterator/op_minus_assign.md.nolink)   | イテレータ自身を逆に進める | C++20 |
 | [`operator[]`](counted_iterator/op_at.md)             | 任意の位置にランダムアクセスする | C++20 |
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- counted_iterator::operator+追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/op_plus.html"/>
      <id>dd9591e62a71478a780c3ecca08d6692d1a39a29:reference/iterator/counted_iterator/op_plus.md</id>
      <updated>2020-12-10T11:28:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/op_plus.md b/reference/iterator/counted_iterator/op_plus.md
new file mode 100644
index 000000000..a18b02143
--- /dev/null
+++ b/reference/iterator/counted_iterator/op_plus.md
@@ -0,0 +1,86 @@
+# operator+
+* iterator[meta header]
+* std[meta namespace]
+* counted_iterator[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+constexpr counted_iterator operator+(iter_difference_t&amp;lt;I&amp;gt; n) const
+  requires random_access_iterator&amp;lt;I&amp;gt;;                                                           // (1)
+
+friend constexpr counted_iterator operator+(iter_difference_t&amp;lt;I&amp;gt; n, const counted_iterator&amp;amp; x)
+  requires random_access_iterator&amp;lt;I&amp;gt;;                                                           // (2)
+```
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+
+
+## 概要
+
+イテレータを`n`回進める。
+
+## 効果
+
+現在のイテレータとカウントの値をそれぞれ、`current`、`length`メンバ変数に保持するとする。
+
+- (1) : 以下と等価  
+    ```cpp
+    return counted_iterator(current + n, length - n);
+    ```
+
+- (2) : 以下と等価  
+    ```cpp
+    return x + n; // (1)に委譲
+    ```
+
+## 戻り値
+
+`n`進めたイテレータのコピーを返す。
+
+## 備考
+
+(2)は*Hidden friends*として定義される。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  std::counted_iterator ci{std::ranges::begin(vec), 5};
+
+  // (1)
+  auto ci2 = ci + 2;
+
+  std::cout &amp;lt;&amp;lt; *ci2 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+
+  // (2)
+  auto ci3 = 4 + ci;
+
+  std::cout &amp;lt;&amp;lt; *ci3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+}
+```
+* ranges::begin[link /reference/ranges/begin.md.nolink]
+
+### 出力
+```
+3
+5
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 9
+
+## 参照
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-- -- counted_iterator::operator-- : コピペミスの修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/op_decrement.html"/>
      <id>1d73cc58961e264fc4c5e97f935ce0c7b2f0e176:reference/iterator/counted_iterator/op_decrement.md</id>
      <updated>2020-12-10T00:24:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/op_decrement.md b/reference/iterator/counted_iterator/op_decrement.md
index 19c84036a..ee5dea263 100644
--- a/reference/iterator/counted_iterator/op_decrement.md
+++ b/reference/iterator/counted_iterator/op_decrement.md
@@ -78,14 +78,12 @@ int main() {
 
 ## バージョン
 ### 言語
-- C++11
+- C++20
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): 4.6.1
-- [ICC](/implementation.md#icc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
-
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 9
 
 ## 参照
-- [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>underlying_type -- fix(underlying_type): apply p0340r3</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/underlying_type.html"/>
      <id>a93cd3b8a6abb96d760343535eb3a5c05b8f900f:reference/type_traits/underlying_type.md</id>
      <updated>2020-12-10T00:04:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/underlying_type.md b/reference/type_traits/underlying_type.md
index 1dcce9fb5..4fe32683d 100644
--- a/reference/type_traits/underlying_type.md
+++ b/reference/type_traits/underlying_type.md
@@ -41,11 +41,50 @@ enum class IntColor {
 ## 要件
 - C++11 : 型`T`が列挙型であること。(完全型を要求するかどうかは未規定)
 - C++14 : 型`T`が完全な列挙型であること。
-
+- C++20 : 型`T`が不完全な列挙型ではないこと。(満たさない場合不適格)
 
 ## 効果
 `underlying_type`は、列挙型`T`の基底型を、メンバ型`type`として定義する。
 
+C++20からは`T`が列挙型ではない場合、`type`は定義されない。
+これによりSFINAEの文脈で使うときにこれまで不適格となるために列挙型以外の型のときに実体化を防ぐ必要があったところをその必要がなくなった。
+
+```cpp example
+#include &amp;lt;type_traits&amp;gt;
+/**
+Tが列挙型ではないときも、std::underlying_type_t&amp;lt;T&amp;gt;が実体化してしまっているため不適格
+template&amp;lt;class T&amp;gt;
+std::enable_if_t&amp;lt;std::is_enum&amp;lt;T&amp;gt;::value, std::underlying_type_t&amp;lt;T&amp;gt;&amp;gt;
+foo(T t) { return static_cast&amp;lt;underlying_type_wrap_t&amp;lt;T&amp;gt;&amp;gt;(t); }
+*/
+#if 1
+// p0340r3が適用されていない処理系
+template&amp;lt;typename T, bool is_enum&amp;gt;
+struct underlying_type_wrap_impl {};
+template&amp;lt;typename T&amp;gt;
+struct underlying_type_wrap_impl&amp;lt;T, true&amp;gt; : std::underlying_type&amp;lt;T&amp;gt; {};//列挙型に対する特殊化なのでOK
+template&amp;lt;typename T&amp;gt;
+struct underlying_type_wrap : underlying_type_wrap_impl&amp;lt;T, std::is_enum&amp;lt;T&amp;gt;::value&amp;gt; {};
+template&amp;lt;typename T&amp;gt;
+using underlying_type_wrap_t = typename underlying_type_wrap&amp;lt;T&amp;gt;::type;
+
+template&amp;lt;typename T&amp;gt;
+underlying_type_wrap_t&amp;lt;T&amp;gt; foo(T t) { return static_cast&amp;lt;underlying_type_wrap_t&amp;lt;T&amp;gt;&amp;gt;(t); }
+#else
+// C++20またはp0340r3が適用された処理系
+// =&amp;gt; 上のようなラッパーはいらない
+template&amp;lt;typename T&amp;gt;
+std::underlying_type_t&amp;lt;T&amp;gt; foo(T t) { return static_cast&amp;lt;std::underlying_type_t&amp;lt;T&amp;gt;&amp;gt;(t); }
+#endif
+template&amp;lt;typename T, std::enable_if_t&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, std::nullptr_t&amp;gt; = nullptr&amp;gt;
+T foo(T t) { return t; }
+enum class bar {
+    hoge
+};
+int main(){
+    return foo(bar::hoge) + foo(0);
+}
+```
 
 ## 例
 ```cpp example
@@ -76,10 +115,18 @@ int main() {}
 - C++11
 
 ### 処理系
+#### underlying_type
 - [Clang](/implementation.md#clang): 3.0
 - [GCC](/implementation.md#gcc): 4.3.6
 - [Visual C++](/implementation.md#visual_cpp): 2012, 2013, 2015
 
+#### P0340R3: Making `std::underlying_type` SFINAE-friendly
+
+以下の処理系ではコンパイル時の言語バージョンスイッチに関わらずP0340R3の修正が適用されている
+
+- [Clang](/implementation.md#clang): 9.0
+- [GCC](/implementation.md#gcc): 9.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 5
 
 ## 関連項目
 - [C++11 スコープを持つ列挙型](/lang/cpp11/scoped_enum.md)
@@ -93,4 +140,5 @@ int main() {}
 - [N3546 TransformationTraits Redux](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3546.pdf)
 - [N3655 TransformationTraits Redux, v2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf)
 - [LWG Issue 2396. underlying_type doesn&amp;#39;t say what to do for an incomplete enumeration type](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2396)
-
+- [D0340R2: Making std::underlying_type SFINAE-friendly](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0340r2.html)
+- [P0340R3: Making std::underlying_type SFINAE-friendly](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0340r3.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>swap -- stop_source/swap: fix typo</title>
      <link href="https://cpprefjp.github.io/reference/stop_token/stop_source/swap.html"/>
      <id>9a8dcaa8c1dbd0061eec280999e0f207e170df33:reference/stop_token/stop_source/swap.md</id>
      <updated>2020-12-09T19:14:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stop_token/stop_source/swap.md b/reference/stop_token/stop_source/swap.md
index 00a2b2010..93ee3b766 100644
--- a/reference/stop_token/stop_source/swap.md
+++ b/reference/stop_token/stop_source/swap.md
@@ -6,7 +6,7 @@
 * cpp20[meta cpp]
 
 ```cpp
-void swap(stop_token&amp;amp;) noexcept;
+void swap(stop_source&amp;amp;) noexcept;
 ```
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>