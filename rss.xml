<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-12-30T04:59:46.310338</updated>
  <id>49f205f0-5b57-45c8-baab-16a3db51acc8</id>

  
    <entry>
      <title>functional -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional.md b/reference/functional.md
index e3fd97465..8ac753e93 100644
--- a/reference/functional.md
+++ b/reference/functional.md
@@ -84,6 +84,12 @@ struct doubler {
 | [`less_equal`](functional/less_equal.md)       | 左辺が右辺以下かの比較(class template) | |
 | [`greater`](functional/greater.md)             | 左辺が右辺より大きいかの比較(class template) | |
 | [`greater_equal`](functional/greater_equal.md) | 左辺が右辺以上かの比較(class template) | |
+| [`ranges::equal_to`](functional/ranges_equal_to.md)           | 等値比較(class template)                     | C++20 |
+| [`ranges::not_equal_to`](functional/ranges_not_equal_to.md)   | 非等値比較(class template)                   | C++20 |
+| [`ranges::less`](functional/ranges_less.md)                   | 左辺が右辺より小さいかの比較(class template) | C++20 |
+| [`ranges::less_equal`](functional/ranges_less_equal.md)       | 左辺が右辺以下かの比較(class template)       | C++20 |
+| [`ranges::greater`](functional/ranges_greater.md)             | 左辺が右辺より大きいかの比較(class template) | C++20 |
+| [`ranges::greater_equal`](functional/ranges_greater_equal.md) | 左辺が右辺以上かの比較(class template)       | C++20 |
 
 
 ## 論理演算関数オブジェクト
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_to -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_equal_to.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_equal_to.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_equal_to.md b/reference/functional/ranges_equal_to.md
new file mode 100644
index 000000000..fba4e4737
--- /dev/null
+++ b/reference/functional/ranges_equal_to.md
@@ -0,0 +1,65 @@
+# equal_to
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct equal_to {
+    template&amp;lt;class T, class U&amp;gt;
+      requires equality_comparable_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
+
+## 概要
+`equal_to`クラスは、等値比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` が `==` および `!=` で同値比較可能、もしくは `declval&amp;lt;T&amp;gt;() == declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着すること。
+
+## 事前条件
+`declval&amp;lt;T&amp;gt;() == declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する場合、`T`および`U`からポインタへの変換は等しさを保持すること(equality-preserving)。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `x == y` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::equal_to&amp;lt;int&amp;gt;()(3, 3) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::equal_to[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>greater -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_greater.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_greater.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_greater.md b/reference/functional/ranges_greater.md
new file mode 100644
index 000000000..6abf76d46
--- /dev/null
+++ b/reference/functional/ranges_greater.md
@@ -0,0 +1,63 @@
+# greater
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct greater {
+    template&amp;lt;class T, class U&amp;gt;
+      requires totally_ordered_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* totally_ordered_with[link /reference/concepts/totally_ordered.md]
+
+## 概要
+`greater`クラスは、左辺が右辺より大きいかの比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` の間で`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`の演算子による比較が可能であり、その順序付けが全順序の要件を満たしている。
+* もしくは、 `declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | [`ranges::less`](ranges_less.md)`{}(std::forward&amp;lt;U&amp;gt;(u), std::forward&amp;lt;T&amp;gt;(t));` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 | C++20 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::greater&amp;lt;int&amp;gt;()(3, 2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::greater[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>greater_equal -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_greater_equal.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_greater_equal.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_greater_equal.md b/reference/functional/ranges_greater_equal.md
new file mode 100644
index 000000000..0a47d6eb4
--- /dev/null
+++ b/reference/functional/ranges_greater_equal.md
@@ -0,0 +1,63 @@
+# greater_equal
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct greater_equal {
+    template&amp;lt;class T, class U&amp;gt;
+      requires totally_ordered_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* totally_ordered_with[link /reference/concepts/totally_ordered.md]
+
+## 概要
+`greater_equal`クラスは、左辺が右辺以上かの比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` の間で`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`の演算子による比較が可能であり、その順序付けが全順序の要件を満たしている。
+* もしくは、 `declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `!`[`ranges::less`](ranges_less.md)`{}(std::forward&amp;lt;T&amp;gt;(t), std::forward&amp;lt;U&amp;gt;(u));` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 | C++20 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::greater_equal&amp;lt;int&amp;gt;()(3, 2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::greater_equal[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>less -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_less.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_less.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_less.md b/reference/functional/ranges_less.md
new file mode 100644
index 000000000..7e3f6323f
--- /dev/null
+++ b/reference/functional/ranges_less.md
@@ -0,0 +1,66 @@
+# less
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct less {
+    template&amp;lt;class T, class U&amp;gt;
+      requires totally_ordered_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* totally_ordered_with[link /reference/concepts/totally_ordered.md]
+
+## 概要
+`less`クラスは、左辺が右辺より小さいかの比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` の間で`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`の演算子による比較が可能であり、その順序付けが全順序の要件を満たしている。
+* もしくは、 `declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する。
+
+## 事前条件
+`declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する場合、`T`および`U`からポインタへの変換は等しさを保持すること(equality-preserving)。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `&amp;lt;` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::less&amp;lt;int&amp;gt;()(2, 3) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::less[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>less_equal -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_less_equal.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_less_equal.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_less_equal.md b/reference/functional/ranges_less_equal.md
new file mode 100644
index 000000000..580cf3084
--- /dev/null
+++ b/reference/functional/ranges_less_equal.md
@@ -0,0 +1,63 @@
+# less_equal
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct less_equal {
+    template&amp;lt;class T, class U&amp;gt;
+      requires totally_ordered_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* totally_ordered_with[link /reference/concepts/totally_ordered.md]
+
+## 概要
+`less_equal`クラスは、左辺が右辺以下かの比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` の間で`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`の演算子による比較が可能であり、その順序付けが全順序の要件を満たしている。
+* もしくは、 `declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `!`[`ranges::less`](ranges_less.md)`{}(std::forward&amp;lt;U&amp;gt;(u), std::forward&amp;lt;T&amp;gt;(t));` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::less_equal&amp;lt;int&amp;gt;()(2, 3) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::less_equal[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>not_equal_to -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_not_equal_to.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_not_equal_to.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_not_equal_to.md b/reference/functional/ranges_not_equal_to.md
new file mode 100644
index 000000000..b9ce3e099
--- /dev/null
+++ b/reference/functional/ranges_not_equal_to.md
@@ -0,0 +1,62 @@
+# not_equal_to
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct not_equal_to {
+    template&amp;lt;class T, class U&amp;gt;
+      requires equality_comparable_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
+
+## 概要
+`not_equal_to`クラスは、非等値比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` が `==` および `!=` で同値比較可能、もしくは `declval&amp;lt;T&amp;gt;() == declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着すること。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `!`[`ranges::equal_to`](ranges_equal_to.md)`{}(std::forward&amp;lt;T&amp;gt;(t), std::forward&amp;lt;U&amp;gt;(u));` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::not_equal_to&amp;lt;int&amp;gt;()(3, 3) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::not_equal_to[color ff0000]
+
+### 出力
+```
+false
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- 名前空間を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>ade10324ee3bb2c4d4873e0b8d90a60f6e6231e9:reference/algorithm/ranges_count_if.md</id>
      <updated>2021-12-30T09:07:41+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 99310f936..510639aec 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -5,7 +5,7 @@
 * cpp20[meta cpp]
 
 ```cpp
-namespace std {
+namespace std::ranges {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
   constexpr iter_difference_t&amp;lt;I&amp;gt; count_if(I first, S last, Pred pred, Proj proj = {}); // (1)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::find/find_if/find_if_notを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>e830336aa667fd98741a7a92ab7e4bf550172d2c:reference/algorithm.md</id>
      <updated>2021-12-30T08:28:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 2ec416178..0c66010e4 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -124,9 +124,9 @@ ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 | [`ranges::none_of`](algorithm/ranges_none_of.md)             | 全ての要素が条件を満たしていないかを調べる           | C++20 |
 | [`ranges::for_each`](algorithm/ranges_for_each.md)           | 全ての要素に対して処理を行う                         | C++20 |
 | [`ranges::for_each_n`](algorithm/ranges_for_each_n.md)       | 範囲の先頭N個の要素に対して処理を行う                | C++20 |
-| [`ranges::find`](algorithm/ranges_find.md.nolink)                   | 指定された値を検索する                               | C++20 |
-| [`ranges::find_if`](algorithm/ranges_find_if.md.nolink)             | 条件を満たす最初の要素を検索する                     | C++20 |
-| [`ranges::find_if_not`](algorithm/ranges_find_if_not.md.nolink)     | 条件を満たしていない最初の要素を検索する             | C++20 |
+| [`ranges::find`](algorithm/ranges_find.md)                   | 指定された値を検索する                               | C++20 |
+| [`ranges::find_if`](algorithm/ranges_find_if.md)             | 条件を満たす最初の要素を検索する                     | C++20 |
+| [`ranges::find_if_not`](algorithm/ranges_find_if_not.md)     | 条件を満たしていない最初の要素を検索する             | C++20 |
 | [`ranges::find_end`](algorithm/ranges_find_end.md.nolink)           | 指定された最後のサブシーケンスを検索する             | C++20 |
 | [`ranges::find_first_of`](algorithm/ra.nolinknges_find_first_of.md.nolink) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
 | [`ranges::adjacent_find`](algorithm/ra.nolinknges_adjacent_find.md.nolink) | 隣接する要素で条件を満たしている最初の要素を検索する | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- ranges::find/find_if/find_if_notを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>e830336aa667fd98741a7a92ab7e4bf550172d2c:reference/algorithm/ranges_find.md</id>
      <updated>2021-12-30T08:28:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
new file mode 100644
index 000000000..1cf2408c7
--- /dev/null
+++ b/reference/algorithm/ranges_find.md
@@ -0,0 +1,104 @@
+# find
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr I find(I first, S last, const T&amp;amp; value, Proj proj = {});
+
+  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+}
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+- equal_to[link /reference/functional/equal_to.md]
+- input_range[link /reference/ranges/input_range.md]
+- projected[link /reference/iterator/projected.md]
+
+## 概要
+指定された値を検索する。
+
+
+## 戻り値
+`[first,last)` あるいは `r` 内のイテレータ i について、[`invoke`](/reference/functional/invoke.md)`(proj, *i) == value` であるような最初のイテレータを返す。そのようなイテレータが見つからなかった場合は `last` を返す。
+
+## 計算量
+最大で `last - first` 回比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;array&amp;gt;
+
+int main() {
+  constexpr std::array v = { 3, 1, 4 };
+  constexpr auto result = std::ranges::find(v, 1);
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find[color ff0000]
+
+### 出力
+```
+found: 1
+```
+
+
+## 実装例
+```cpp
+struct find_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr I operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
+    for ( ; first != last; ++first)
+      if (*first == value) return first;
+    return last;
+  }
+
+  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
+    return (*this)(begin(r), end(r), value, ref(proj));
+  }
+};
+
+inline constexpr find_impl find;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+* equal_to[link /reference/functional/equal_to.md]
+* projected[link /reference/iterator/projected.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- ranges::find/find_if/find_if_notを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>e830336aa667fd98741a7a92ab7e4bf550172d2c:reference/algorithm/ranges_find_if.md</id>
      <updated>2021-12-30T08:28:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
new file mode 100644
index 000000000..152fce3e4
--- /dev/null
+++ b/reference/algorithm/ranges_find_if.md
@@ -0,0 +1,102 @@
+# find_if
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+}
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+- input_range[link /reference/ranges/input_range.md]
+- projected[link /reference/iterator/projected.md]
+
+## 概要
+範囲の中から、指定された条件を満たす最初の要素を検索する。
+
+
+## 戻り値
+`[first,last)` あるいは `r` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *i)) != false` である最初のイテレータを返す。そのようなイテレータが見つからなかった場合は `last` を返す。
+
+
+## 計算量
+最大で `last - first` 回述語による比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 3, 1, 4 };
+  // 3ではない最初の要素を検索する
+  auto result = std::ranges::find_if(v, [](int x) { return x != 3; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if[color ff0000]
+
+### 出力
+```
+found: 1
+```
+
+
+## 実装例
+```cpp
+struct find_if_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I perator()(I first, S last, Pred pred, Proj proj = {}) {
+    for ( ; first != last; ++first)
+      if (invoke(pred, invoke(proj, *first)))
+        return first;
+  }
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate &amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+    return (*this)(begin(r), end(r), ref(pred), ref(proj));
+  }
+};
+
+inline constexpr find_if_impl find_if;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- ranges::find/find_if/find_if_notを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>e830336aa667fd98741a7a92ab7e4bf550172d2c:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2021-12-30T08:28:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
new file mode 100644
index 000000000..32d9b47ea
--- /dev/null
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -0,0 +1,102 @@
+# find_if_not
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find_if_not(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+}
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+- input_range[link /reference/ranges/input_range.md]
+- projected[link /reference/iterator/projected.md]
+
+## 概要
+範囲の中から、指定された条件を満たさない最初の要素を検索する。
+
+
+## 戻り値
+`[first,last)` あるいは `r` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *i)) == false` である最初のイテレータを返す。そのようなイテレータが見つからなかった場合は `last` を返す。
+
+
+## 計算量
+最大で `last - first` 回述語による比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 3, 1, 4 };
+  // 3ではない最初の要素を検索する
+  auto result = std::ranges::find_if_not(v, [](int x) { return x == 3; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if_not[color ff0000]
+
+### 出力
+```
+found: 1
+```
+
+
+## 実装例
+```cpp
+struct find_if_not_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I perator()(I first, S last, Pred pred, Proj proj = {}) {
+    for ( ; first != last; ++first)
+      if (!invoke(pred, invoke(proj, *first)))
+        return first;
+  }
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate &amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+    return (*this)(begin(r), end(r), ref(pred), ref(proj));
+  }
+};
+
+inline constexpr find_if_not_impl find_if_not;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>6e1108a14d5e51b030b369b047a6d115dfeadd23:reference/algorithm/ranges_count_if.md</id>
      <updated>2021-12-30T08:22:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 91e06e948..99310f936 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -15,7 +15,7 @@ namespace std {
 ```
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
-* indirect_binarindirect_unary_predicatey_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
 * projected[link /reference/iterator/projected.md]
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 * range_difference_t[link /reference/ranges/range_difference_t.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::conut/count_ifを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>19ad00b6639e426c1e71560a3de49e1e5051f908:reference/algorithm.md</id>
      <updated>2021-12-29T23:48:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 75a3d626a..2ec416178 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -130,8 +130,8 @@ ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 | [`ranges::find_end`](algorithm/ranges_find_end.md.nolink)           | 指定された最後のサブシーケンスを検索する             | C++20 |
 | [`ranges::find_first_of`](algorithm/ra.nolinknges_find_first_of.md.nolink) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
 | [`ranges::adjacent_find`](algorithm/ra.nolinknges_adjacent_find.md.nolink) | 隣接する要素で条件を満たしている最初の要素を検索する | C++20 |
-| [`ranges::count`](algorithm/ranges_count.md.nolink)                 | 指定された値である要素の数を数える                   | C++20 |
-| [`ranges::count_if`](algorithm/ranges_count_if.md.nolink)           | 条件を満たしている要素の数を数える                   | C++20 |
+| [`ranges::count`](algorithm/ranges_count.md)                 | 指定された値である要素の数を数える                   | C++20 |
+| [`ranges::count_if`](algorithm/ranges_count_if.md)           | 条件を満たしている要素の数を数える                   | C++20 |
 | [`ranges::mismatch`](algorithm/ranges_mismatch.md.nolink)           | 2つの範囲が一致していない場所を検索する              | C++20 |
 | [`ranges::equal`](algorithm/ranges_equal.md.nolink)                 | 2つの範囲を等値比較する                              | C++20 |
 | [`ranges::search`](algorithm/ranges_search.md.nolink)               | 指定された最初のサブシーケンスを検索する             | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- ranges::conut/count_ifを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>19ad00b6639e426c1e71560a3de49e1e5051f908:reference/algorithm/ranges_count.md</id>
      <updated>2021-12-29T23:48:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
new file mode 100644
index 000000000..b0ff3b076
--- /dev/null
+++ b/reference/algorithm/ranges_count.md
@@ -0,0 +1,110 @@
+# count
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt; count(I first, S last, const T&amp;amp; value, Proj proj = {}); // (1)
+
+  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt; count(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});          // (2)
+}
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+* equal_to[link /reference/functional/equal_to.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+
+## 概要
+指定された値と等値な要素の数を数える。
+
+## テンプレートパラメータ制約
+- (1):
+    - `I`が[`input_iterator`](/reference/iterator/input_iterator.md)である
+    - `S`が[`I`に対する番兵](/reference/iterator/sentinel_for.md)である
+    - `I`を`Proj`で射影した値と指定された値が[`equal_to`](/reference/functional/equal_to.md)によって等値比較できる
+- (2):
+    - `R`が[`input_range`](/reference/ranges/input_range.md)である
+    - `Pred`は`R`のイテレータを`Proj`で射影した値が[`equal_to`](/reference/functional/equal_to.md)によって等値比較できる
+
+## 戻り値
+`[first,last)` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(proj, *i) == value` であるイテレータの数を返す
+
+## 計算量
+正確に `last - first` 回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;array&amp;gt;
+
+int main() {
+  constexpr std::array v = { 1,4,3,3,1,2,2,1 };
+
+  // 値が 1 の要素がいくつあるかを数える
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of 1: &amp;#34; &amp;lt;&amp;lt; std::ranges::count(v, 1) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count[color ff0000]
+
+### 出力
+```
+count of 1: 3
+```
+
+
+## 実装例
+```cpp
+struct count_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
+    iter_difference_t&amp;lt;I&amp;gt; count = 0;
+    for ( ; first != last; ++first)
+      if (value == invoke(proj, *first)) count++;
+    return count;
+  }
+
+  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
+    return (*this)(begin(r), end(r), value, ref(proj));
+  }
+};
+
+inline constexpr count_impl count;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+* equal_to[link /reference/functional/equal_to.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- ranges::conut/count_ifを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>19ad00b6639e426c1e71560a3de49e1e5051f908:reference/algorithm/ranges_count_if.md</id>
      <updated>2021-12-29T23:48:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
new file mode 100644
index 000000000..91e06e948
--- /dev/null
+++ b/reference/algorithm/ranges_count_if.md
@@ -0,0 +1,108 @@
+# count_if
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt; count_if(I first, S last, Pred pred, Proj proj = {}); // (1)
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt; count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});          // (2)
+}
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_binarindirect_unary_predicatey_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+
+
+## 概要
+条件を満たしている要素の数を数える。
+
+## テンプレートパラメータ制約
+- (1):
+    - `I`が[`input_iterator`](/reference/iterator/input_iterator.md)である
+    - `S`が[`I`に対する番兵](/reference/iterator/sentinel_for.md)である
+    - `Pred`は`I`を`Proj`で射影した値を[参照で渡すことができる1引数の述語](/reference/iterator/indirect_unary_predicate.md)である
+- (2):
+    - `R`が[`input_range`](/reference/ranges/input_range.md)である
+    - `Pred`は`R`のイテレータを`Proj`で射影した値を[参照で渡すことができる1引数の述語](/reference/iterator/indirect_unary_predicate.md)である
+
+
+## 戻り値
+`[first,last)` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *i)) != false` であるイテレータの数を返す
+
+
+## 計算量
+正確に `last - first` 回の述語の適用を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;array&amp;gt;
+
+int main() {
+  constexpr std::array v = { 1,4,3,3,1,2,2,1 };
+
+  // 値が 1 または 3 の要素がいくつあるかを数える
+  auto count = std::ranges::count_if(v, [](int x) { return x == 1 || x == 3; });
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of 1 or 3: &amp;#34; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count_if[color ff0000]
+
+### 出力
+```cpp
+count of 1 or 3: 5
+```
+
+
+## 実装例
+```cpp
+struct count_if_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, Pred pred, Proj proj = {}) {
+    iter_difference_t&amp;lt;I&amp;gt; count = 0;
+    for ( ; first != last; ++first)
+      if (invoke(pred, invoke(proj, *first))) count++;
+    return count;
+  }
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+    return (*this)(begin(r), end(r), ref(pred), ref(proj));
+  }
+};
+
+inline constexpr count_if_impl count_if;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>