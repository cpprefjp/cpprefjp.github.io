<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-02-08T14:38:45.711314</updated>
  <id>642636a6-3b2d-4fa9-994b-60056c1ee2b4</id>

  
    <entry>
      <title>is_modulo -- numeric_limits::is_modulo : 2の補数規定のページにリンク</title>
      <link href="https://cpprefjp.github.io/reference/limits/numeric_limits/is_modulo.html"/>
      <id>c34db49be88b6b6ac81de5fd335d053e7fb85482:reference/limits/numeric_limits/is_modulo.md</id>
      <updated>2021-02-08T23:18:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/limits/numeric_limits/is_modulo.md b/reference/limits/numeric_limits/is_modulo.md
index ade0cf909..2a05dd363 100644
--- a/reference/limits/numeric_limits/is_modulo.md
+++ b/reference/limits/numeric_limits/is_modulo.md
@@ -61,6 +61,10 @@ char : false
 ```
 
 
+## 関連項目
+- [C++20 符号付き整数型が2の補数表現であることを規定](/lang/cpp20/signed_integers_are_twos_complement.md)
+
+
 ## 参照
 - [LWG Issue 612. `numeric_limits::is_modulo` insufficiently defined](https://wg21.cmeerw.net/lwg/issue612)
     - C++11で、定義がより明確になった
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bind_front -- bind_front : 戻り値の説明を少し変更</title>
      <link href="https://cpprefjp.github.io/reference/functional/bind_front.html"/>
      <id>88617549384ad5c648bbf81ea7985f99aa82e3a1:reference/functional/bind_front.md</id>
      <updated>2021-02-06T21:42:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/bind_front.md b/reference/functional/bind_front.md
index 44a3590c2..e8cabe737 100644
--- a/reference/functional/bind_front.md
+++ b/reference/functional/bind_front.md
@@ -62,8 +62,10 @@ auto f3 = bind_front(&amp;amp;Strategy::process, Strategy{});
 
 
 ## 戻り値
-[`std::invoke()`](invoke.md)の呼び出しにおける引数の先頭一部`f`と`args...`を完全転送して保持し、残りの引数リストを渡すことで関数オブジェクト`f`を呼び出せる未規定の関数オブジェクトを返す。
 
+呼び出し可能な`f`を[`std::invoke()`](invoke.md)で呼び出した時に必要な引数列に前方一致する`f`と`args...`を完全転送して保持し、後から残りの引数リストを渡すことで`f`を呼び出せる未規定の関数オブジェクトを返す。
+
+返される関数オブジェクトは渡された引数（`f, args...`）を参照として保持せず、適切にコピー/ムーブして保持する。
 
 ## 例外
 - 関数オブジェクト`f`のムーブによって任意の例外が送出される可能性がある
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bind_front -- bind_front: fix typo</title>
      <link href="https://cpprefjp.github.io/reference/functional/bind_front.html"/>
      <id>11c53e6c93735f22a4d577dd36fcf7e6554ff13d:reference/functional/bind_front.md</id>
      <updated>2021-02-06T21:25:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/bind_front.md b/reference/functional/bind_front.md
index a32062933..44a3590c2 100644
--- a/reference/functional/bind_front.md
+++ b/reference/functional/bind_front.md
@@ -62,7 +62,7 @@ auto f3 = bind_front(&amp;amp;Strategy::process, Strategy{});
 
 
 ## 戻り値
-[`std::invoke()`](invoke.md)の呼び出しにおける引数の先頭一部`f`と`args...`を完全転送して保持し、残しの引数リストを渡すことで関数オブジェクト`f`を呼び出せる未規定の関数オブジェクトを返す。
+[`std::invoke()`](invoke.md)の呼び出しにおける引数の先頭一部`f`と`args...`を完全転送して保持し、残りの引数リストを渡すことで関数オブジェクト`f`を呼び出せる未規定の関数オブジェクトを返す。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator_traits -- allocator_traits : rebindの使用例を記載</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator_traits.html"/>
      <id>f3ca4bc4fea99c4e6aa2de17efc4b6f2fca61748:reference/memory/allocator_traits.md</id>
      <updated>2021-02-05T18:29:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator_traits.md b/reference/memory/allocator_traits.md
index fe2bf2893..7f9e661e4 100644
--- a/reference/memory/allocator_traits.md
+++ b/reference/memory/allocator_traits.md
@@ -54,6 +54,7 @@ namespace std {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;memory&amp;gt;
 
@@ -104,10 +105,97 @@ int main()
 * traits::destroy[link allocator_traits/destroy.md]
 * traits::deallocate[link allocator_traits/deallocate.md]
 
-### 出力
+#### 出力
 ```
 ```
 
+
+### rebind_allocの使用例
+```cpp
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;memory&amp;gt;
+
+template &amp;lt;class T&amp;gt;
+struct node {
+  T value;
+  node&amp;lt;T&amp;gt;* next;
+};
+
+// 単方向リンクリストの実装
+template &amp;lt;class T, class Alloc=std::allocator&amp;lt;T&amp;gt;&amp;gt;
+class my_forward_list {
+  // 実際にメモリ確保したいのはT型ではなくnode&amp;lt;T&amp;gt;型なので、
+  // allocator&amp;lt;T&amp;gt;をallocator&amp;lt;node&amp;lt;T&amp;gt;&amp;gt;に置き換える
+  using allocator_type = typename std::allocator_traits&amp;lt;
+    Alloc
+  &amp;gt;::template rebind_alloc&amp;lt;node&amp;lt;T&amp;gt;&amp;gt;;
+
+  using allocator_traits_type =
+    std::allocator_traits&amp;lt;allocator_type&amp;gt;;
+
+  node&amp;lt;T&amp;gt;* head_ = nullptr;
+  allocator_type alloc_;
+
+public:
+  ~my_forward_list() {
+    node&amp;lt;T&amp;gt;* p = head_;
+    while (p) {
+      node&amp;lt;T&amp;gt;* next = p-&amp;gt;next;
+
+      allocator_traits_type::destroy(alloc_, p);
+      allocator_traits_type::deallocate(alloc_, p, 1);
+
+      p = next;
+    }
+  }
+
+  void push_back(const T&amp;amp; x) {
+    node&amp;lt;T&amp;gt;* new_node = allocator_traits_type::allocate(alloc_, 1);
+    allocator_traits_type::construct(alloc_, new_node, node&amp;lt;T&amp;gt;{x, nullptr});
+
+    if (!head_) {
+      head_ = new_node;
+    }
+    else {
+      node&amp;lt;T&amp;gt;* last_node = head_;
+      while (true) {
+        if (!last_node-&amp;gt;next) {
+          last_node-&amp;gt;next = new_node;
+          break;
+        }
+        last_node = last_node-&amp;gt;next;
+      }
+    }
+  }
+
+  void print() {
+    for (auto* p = head_; p; p = p-&amp;gt;next) {
+      std::cout &amp;lt;&amp;lt; p-&amp;gt;value &amp;lt;&amp;lt; std::endl;
+    }
+  }
+};
+
+int main() {
+  my_forward_list&amp;lt;int&amp;gt; ls;
+  ls.push_back(3);
+  ls.push_back(1);
+  ls.push_back(4);
+  ls.print();
+}
+```
+* rebind_alloc[color ff0000]
+* allocator_traits_type::allocate[link allocator_traits/allocate.md]
+* allocator_traits_type::construct[link allocator_traits/construct.md]
+* allocator_traits_type::destroy[link allocator_traits/destroy.md]
+* allocator_traits_type::deallocate[link allocator_traits/deallocate.md]
+
+#### 出力
+```
+3
+1
+4
+```
+
 ## バージョン
 ### 言語
 - C++11
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_compound -- is_compound: 規格書セクション番号を削除</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_compound.html"/>
      <id>253366d8e62cea667ba1dda22b64e54963d1da98:reference/type_traits/is_compound.md</id>
      <updated>2021-02-05T16:48:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_compound.md b/reference/type_traits/is_compound.md
index 067339335..e5004f4ad 100644
--- a/reference/type_traits/is_compound.md
+++ b/reference/type_traits/is_compound.md
@@ -15,7 +15,7 @@ namespace std {
 ```
 
 ## 概要
-型`T`が複合型 (3.9.2 Compound types) か調べる。複合型は、配列型、関数型、ポインタ型、参照型、クラス型、共用型、列挙型、メンバポインタ型、およびそれらのcv修飾を含む。
+型`T`が複合型 (Compound types) か調べる。複合型は、配列型、関数型、ポインタ型、参照型、クラス型、共用型、列挙型、メンバポインタ型、およびそれらのcv修飾を含む。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>