<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-28T08:12:47.331200</updated>
  <id>f937898e-adf5-4853-aff3-775a76ffa979</id>

  
    <entry>
      <title>allocator -- allocator : C++26対応としてis_always_equalを削除 (close #1242)</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator.html"/>
      <id>c3e97ea8a80e4a22e82c6b943a35492f2894d99e:reference/memory/allocator.md</id>
      <updated>2025-05-28T17:09:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator.md b/reference/memory/allocator.md
index f38eef148..7d9970fe2 100644
--- a/reference/memory/allocator.md
+++ b/reference/memory/allocator.md
@@ -64,7 +64,7 @@ C++11から：
 | `reference`       | 要素の参照型 `T&amp;amp;`                            | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `const_reference` | 読み取り専用の要素の参照型 `const T&amp;amp;`        | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `rebind&amp;lt;U&amp;gt;`       | 型`U`を確保するように再束縛する              | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
-| `is_always_equal` | 同じ型のアロケータオブジェクトが2つある場合、それらが常に同値であるか。[`true_type`](/reference/type_traits/true_type.md) | C++17 |
+| `is_always_equal` | 同じ型のアロケータオブジェクトが2つある場合、それらが常に同値であるか。[`true_type`](/reference/type_traits/true_type.md) | C++17&amp;lt;br/&amp;gt; C++20で非推奨&amp;lt;br/&amp;gt; C++26で削除 |
 
 
 ## 非メンバ関数
@@ -87,6 +87,9 @@ C++11から：
         - なお、プライマリテンプレートからインスタンス化されるようになっても`allocate`/`deallocate`メンバは内部で`sizeof(void)`を要求するため引き続き使用不可能であり、`std::allocator&amp;lt;void&amp;gt;`の使用用途としては従来と同じく再束縛を目的とすることになる(上述のように[`std::allocator_traits`](allocator_traits.md)の代替機能を用いて`typename` [`std::allocator_traits`](allocator_traits.md)`&amp;lt;std::allocator&amp;lt;void&amp;gt;&amp;gt;::template rebind_alloc&amp;lt;R&amp;gt;`のようにする)。
 
 - メンバ型の`size_type`と`difference_type`は、C++17で非推奨となったがC++20で非推奨が取り消された。
+- メンバ型の`is_always_equal`は、このクラスを継承したメモリアロケータが`is_always_equal`の値を引き継いでしまうという点で問題があったため、C++20で非推奨となり、C++26で削除された。
+    - 代わりに[`std::allocator_traits`](allocator_traits.md)クラスの`is_always_equal`メンバ型を使用すること。
+
 
 ## 例
 ```cpp example
@@ -140,3 +143,7 @@ int main(int argc, char** argv) {
 - [P0174R2 Deprecating Vestigial Library Parts in C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html)
 - [P0619R4 Reviewing deprecated facilities of C++17 for C++20](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0619r4.html)
 - [N4258 Cleaning-up noexcept in the Library, Rev 3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf)
+- [LWG Issue 3170. `is_always_equal` added to `std::allocator` makes the standard library treat derived types as always equal](https://cplusplus.github.io/LWG/issue3170)
+    - C++20で`is_always_equal`メンバ型が非推奨化された
+- [P2868R3 Remove Deprecated `std::allocator` Typedef From C++26](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2868r3.pdf)
+    - C++26で`is_always_equal`メンバ型が削除された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>projected -- projected : C++26での不完全型への対策に対応 (close #1185)</title>
      <link href="https://cpprefjp.github.io/reference/iterator/projected.html"/>
      <id>1fe3de6f2d3c0162a5f2b4b89231c01f20f24380:reference/iterator/projected.md</id>
      <updated>2025-05-28T14:49:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/projected.md b/reference/iterator/projected.md
index cf694bbc7..85023e7ad 100644
--- a/reference/iterator/projected.md
+++ b/reference/iterator/projected.md
@@ -6,20 +6,30 @@
 
 ```cpp
 namespace std {
-
-  template&amp;lt;indirectly_readable I, indirectly_regular_unary_invocable&amp;lt;I&amp;gt; Proj&amp;gt;
+  // (1) C++20の定義
+  template &amp;lt;indirectly_readable I, indirectly_regular_unary_invocable&amp;lt;I&amp;gt; Proj&amp;gt;
   struct projected {
     using value_type = remove_cvref_t&amp;lt;indirect_result_t&amp;lt;Proj&amp;amp;, I&amp;gt;&amp;gt;;
 
     indirect_result_t&amp;lt;Proj&amp;amp;, I&amp;gt; operator*() const;	// 宣言のみ
   };
-
-
   // incrementable_traitsにアダプトする
-  template&amp;lt;weakly_incrementable I, class Proj&amp;gt;
+  template &amp;lt;weakly_incrementable I, class Proj&amp;gt;
   struct incrementable_traits&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; {
     using difference_type = iter_difference_t&amp;lt;I&amp;gt;;
   };
+
+  // (1) C++26の定義
+  template &amp;lt;class I, class Proj&amp;gt;
+  struct projected-impl { // 説明用の型
+    struct type { // 説明用の型
+      using value_type = remove_cvref_t&amp;lt;indirect_result_t&amp;lt;Proj&amp;amp;, I&amp;gt;&amp;gt;;
+      using difference_type = iter_difference_t&amp;lt;I&amp;gt;; // weakly_incrementableをモデル化する場合にのみ存在する
+      indirect_result_t&amp;lt;Proj&amp;amp;, I&amp;gt; operator*() const; // 宣言のみで定義なし
+    };
+  };
+  template &amp;lt;indirectly_readable I, indirectly_regular_unary_invocable&amp;lt;I&amp;gt; Proj&amp;gt;
+  using projected = projected-impl&amp;lt;I, Proj&amp;gt;::type;
 }
 ```
 * indirectly_readable[link /reference/iterator/indirectly_readable.md]
@@ -34,6 +44,15 @@ namespace std {
 
 これは射影操作を受け取るコンセプトやアルゴリズムを制約するために使用するものであり、評価される文脈で使用可能ではない。主に、射影操作の結果に対してイテレータ関連のコンセプトを適用する場合に使用する（射影の結果を再び`indirectly_readable`な型に写す事で、一部のイテレータに対するコンセプトを使いまわす事が出来る）。
 
+
+## 備考
+- C++26:
+    - C++20の`projected`の定義では、ADLによって不完全型に完全な定義を要求してしまっており、以下のようなコードがコンパイルエラーになっていたが、C++26での定義変更によって不完全型が許容されるようになった。
+        ```cpp
+        Holder&amp;lt;Incomplete&amp;gt; *a[10] = {};
+        std::ranges::count(a, a + 10, nullptr); // コンパイルエラー
+        ```
+
 ## 例
 ```cpp example
 #include &amp;lt;iterator&amp;gt;
@@ -95,3 +114,4 @@ int main() {
 ## 参照
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P2538R1 ADL-proof `std::projected`](http://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2538r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- execution: bulk (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>876474cda3ade253d72668edd968a4131ed58e14:reference/execution/execution.md</id>
      <updated>2025-05-28T00:49:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index c103bdf8e..ef8fdbfc6 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -121,7 +121,7 @@ namespace std::execution {
 | [`execution::let_value`](execution/let_value.md) | 値完了結果から入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::let_error`](execution/let_error.md.nolink) | エラー完了結果から入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::let_stopped`](execution/let_stopped.md.nolink) | 停止完了を入れ子の非同期操作へ変換 (customization point object) | C++26 |
-| [`execution::bulk`](execution/bulk.md.nolink) | インデクス空間上で指定関数を連続実行 (customization point object) | C++26 |
+| [`execution::bulk`](execution/bulk.md) | インデクス空間上で指定関数を反復実行 (customization point object) | C++26 |
 | [`execution::split`](execution/split.md) | 入力Senderの値を複製回送信可能とする (customization point object) | C++26 |
 | [`execution::when_all`](execution/when_all.md) | 全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::when_all_with_variant`](execution/when_all_with_variant.md) | 複数の値完了シグネチャをもつ全ての入力Sender完了を待機 (customization point object) | C++26 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bulk -- execution: bulk (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/bulk.html"/>
      <id>876474cda3ade253d72668edd968a4131ed58e14:reference/execution/execution/bulk.md</id>
      <updated>2025-05-28T00:49:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/bulk.md b/reference/execution/execution/bulk.md
new file mode 100644
index 000000000..82ad14e32
--- /dev/null
+++ b/reference/execution/execution/bulk.md
@@ -0,0 +1,137 @@
+# bulk
+* execution[meta header]
+* cpo[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  struct bulk_t { unspecified };
+  inline constexpr bulk_t bulk{};
+}
+```
+* unspecified[italic]
+
+## 概要
+`bulk`は、インデクス空間の各インデクスに対してタスクを反復実行するSenderアダプタである。
+
+`bulk`はパイプライン記法をサポートする。
+
+
+## 効果
+説明用の式`sndr`, `shape`, `f`に対して、型`Shape`を`decltype(auto(shape))`とする。下記いずれかの条件をみたすとき、呼び出し式`bulk(sndr, shape, f)`は不適格となる。
+
+- `decltype((sndr))`が[`sender`](sender.md)を満たさない、もしくは
+- `Shape`が[`integral`](/reference/concepts/integral.md)を満たさない、もしくは
+- `decltype((f))`が[`movable-value`](../movable-value.md)を満たさないとき。
+
+そうでなければ、呼び出し式`bulk(sndr, shape, f)`は`sndr`が1回だけ評価されることを除いて、下記と等価。
+
+```cpp
+transform_sender(get-domain-early(sndr), make-sender(bulk, product-type{shape, f}, sndr))
+```
+* transform_sender[link transform_sender.md]
+* get-domain-early[link get-domain-early.md]
+* make-sender[link make-sender.md]
+* product-type[link product-type.md]
+
+
+### Senderアルゴリズムタグ `bulk`
+Senderアルゴリズム動作説明用のクラステンプレート[`impls-for`](impls-for.md)に対して、下記の特殊化が定義される。
+
+```cpp
+namespace std::execution {
+  template&amp;lt;&amp;gt;
+  struct impls-for&amp;lt;bulk_t&amp;gt; : default-impls {
+    static constexpr auto complete = see below;
+  };
+}
+```
+* impls-for[link impls-for.md]
+* default-impls[link impls-for.md]
+* see below[italic]
+
+`impls-for&amp;lt;bulk_t&amp;gt;::complete`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[]&amp;lt;class Index, class State, class Rcvr, class Tag, class... Args&amp;gt;
+  (Index, State&amp;amp; state, Rcvr&amp;amp; rcvr, Tag, Args&amp;amp;&amp;amp;... args) noexcept -&amp;gt; void requires see below {
+    if constexpr (same_as&amp;lt;Tag, set_value_t&amp;gt;) {
+      auto&amp;amp; [shape, f] = state;
+      constexpr bool nothrow = noexcept(f(auto(shape), args...));
+      TRY-EVAL(rcvr, [&amp;amp;]() noexcept(nothrow) {
+        for (decltype(auto(shape)) i = 0; i &amp;lt; shape; ++i) {
+          f(auto(i), args...);
+        }
+        Tag()(std::move(rcvr), std::forward&amp;lt;Args&amp;gt;(args)...);
+      }());
+    } else {
+      Tag()(std::move(rcvr), std::forward&amp;lt;Args&amp;gt;(args)...);
+    }
+  }
+```
+* set_value_t[link set_value.md]
+* TRY-EVAL[link TRY-EVAL.md.nolink]
+* std::move[link /reference/utility/move.md]
+* see below[italic]
+
+型`Tag`が[`set_value_t`](set_value.md)以外の型であるとき、もしくは式`f(auto(shape), args...)`が適格なときに限って、上記ラムダ式のrequires節が満たされる。
+
+
+## カスタマイゼーションポイント
+Senderアルゴリズム構築時および[Receiver](receiver.md)接続時に、関連付けられた実行ドメインに対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](default_domain.md)では無変換。
+
+説明用の式`out_sndr`を`bulk(sndr, shape, f)`の戻り値[Sender](sender.md)とし、式`rcvr`を式[`connect`](connect.md)`(out_sndr, rcvr)`が適格となる[Receiver](receiver.md)とする。式[`connect`](connect.md)`(out_sndr, rcvr)`は[開始(start)](start.md)時に下記を満たす非同期操作を生成しない場合、動作は未定義となる。
+
+- 値完了操作において、パック`args`を入力[Sender](sender.md)の値完了結果データを参照する左辺値式としたとき、型`Shape`の半開区間`[0, Shape)`における全ての`i`に対して`f(i, args...)`を呼び出すこと。
+- `sndr`により送信された全ての完了操作を伝搬すること。
+
+
+## 備考
+非同期実行フレームワークで定義される[デフォルト実行ドメイン](default_domain.md)では、`bulk`に指定したタスク`f`は単一スレッド上で逐次実行される。
+
+
+## 例
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+int main()
+{
+  ex::sender auto sndr =
+    ex::just()
+    | ex::bulk(3, [](int i) {
+        std::println(&amp;#34;{}&amp;#34;, i);
+      });
+  std::this_thread::sync_wait(sndr);
+}
+```
+* ex::bulk[color ff0000]
+* ex::sender[link sender.md]
+* ex::just[link just.md]
+* std::this_thread::sync_wait[link ../this_thread/sync_wait.md]
+
+### 出力例
+```
+0
+1
+2
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>let_value -- execution: bulk (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/let_value.html"/>
      <id>876474cda3ade253d72668edd968a4131ed58e14:reference/execution/execution/let_value.md</id>
      <updated>2025-05-28T00:49:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/let_value.md b/reference/execution/execution/let_value.md
index 0ed009957..5a216c85f 100644
--- a/reference/execution/execution/let_value.md
+++ b/reference/execution/execution/let_value.md
@@ -114,6 +114,7 @@ namespace std::execution {
 ```
 * set_value[link set_value.md]
 * decayed-typeof[link decayed-typeof.md.nolink]
+* TRY-EVAL[link TRY-EVAL.md.nolink]
 * std::move[link /reference/utility/move.md]
 
 説明用の式`sndr`と`env`に対して、型`Sndr`を`decltype((sndr))`とする。[`sender-for`](sender-for.md)`&amp;lt;Sndr, decayed-typeof&amp;lt;let_value&amp;gt;&amp;gt; == false`のとき、式`let_value.transform_env(sndr, env)`は不適格となる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>execution -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution.md b/reference/execution/execution.md
index ff06aaaa9..c103bdf8e 100644
--- a/reference/execution/execution.md
+++ b/reference/execution/execution.md
@@ -122,7 +122,7 @@ namespace std::execution {
 | [`execution::let_error`](execution/let_error.md.nolink) | エラー完了結果から入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::let_stopped`](execution/let_stopped.md.nolink) | 停止完了を入れ子の非同期操作へ変換 (customization point object) | C++26 |
 | [`execution::bulk`](execution/bulk.md.nolink) | インデクス空間上で指定関数を連続実行 (customization point object) | C++26 |
-| [`execution::split`](execution/split.md.nolink) | 入力Senderの値を複製送信 (customization point object) | C++26 |
+| [`execution::split`](execution/split.md) | 入力Senderの値を複製回送信可能とする (customization point object) | C++26 |
 | [`execution::when_all`](execution/when_all.md) | 全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::when_all_with_variant`](execution/when_all_with_variant.md) | 複数の値完了シグネチャをもつ全ての入力Sender完了を待機 (customization point object) | C++26 |
 | [`execution::into_variant`](execution/into_variant.md) | 複数の値完了シグネチャを単一[`variant`](/reference/variant/variant.md)型の値完了シグネチャに変換 (customization point object) | C++26 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>into_variant -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/into_variant.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/into_variant.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/into_variant.md b/reference/execution/execution/into_variant.md
index 3e912ee22..afabb4205 100644
--- a/reference/execution/execution/into_variant.md
+++ b/reference/execution/execution/into_variant.md
@@ -203,4 +203,5 @@ int main()
 
 
 ## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>on-stop-request -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/on-stop-request.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/on-stop-request.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/on-stop-request.md b/reference/execution/execution/on-stop-request.md
index 06ad7d68c..447aa6986 100644
--- a/reference/execution/execution/on-stop-request.md
+++ b/reference/execution/execution/on-stop-request.md
@@ -24,6 +24,7 @@ struct on-stop-request {
 
 ## 関連項目
 - [`execution::when_all`](when_all.md)
+- [`execution::split`](split.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>split -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/split.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/split.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/split.md b/reference/execution/execution/split.md
new file mode 100644
index 000000000..0f68960cc
--- /dev/null
+++ b/reference/execution/execution/split.md
@@ -0,0 +1,404 @@
+# split
+* execution[meta header]
+* cpo[meta id-type]
+* std::execution[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::execution {
+  struct split_t { unspecified };
+  inline constexpr split_t split{};
+}
+```
+* unspecified[italic]
+
+## 概要
+`split`は、任意の入力[Sender](sender.md)を複数回[接続(connect)](connect.md)可能とするSenderアダプタである。
+
+`split`はパイプライン記法をサポートする。
+
+
+## 効果
+説明用の型`split-env`を、インスタンス`env`に対して式[`get_stop_token`](../get_stop_token.md)`(env)`が適格かつ型[`inplace_stop_token`](/reference/stop_token/inplace_stop_token.md)をもつ型とする。
+
+説明用の式`sndr`に対して、型`Sndr`を`decltype((sndr))`とする。[`sender_in`](sender_in.md)`&amp;lt;Sndr, split-env&amp;gt; == false`のとき、呼び出し式`split(sndr)`は不適格となる。
+
+そうでなければ、呼び出し式`split(sndr)`は`sndr`が1回だけ評価されることを除いて、下記と等価。
+
+```cpp
+transform_sender(get-domain-early(sndr), make-sender(split, {}, sndr))
+```
+* transform_sender[link transform_sender.md]
+* get-domain-early[link get-domain-early.md]
+* make-sender[link make-sender.md]
+
+
+### Senderアルゴリズムタグ `split`
+説明用のSenderアルゴリズムタグ型`split-impl-tag`を空の型とする。説明用の式`sndr`に対して、式`split.transform_sender(sndr)`は下記と等価。
+
+```cpp
+auto&amp;amp;&amp;amp; [tag, _, child] = sndr;
+auto* sh_state = new shared-state{std::forward_like&amp;lt;decltype((sndr))&amp;gt;(child)};
+return make-sender(split-impl-tag(), shared-wrapper{sh_state, tag});
+```
+* make-sender[link make-sender.md]
+
+説明用の型`shared-wrapper`は、`sh_state`が指す`shared-state`オブジェクトの参照カウントを管理するクラスである。
+
+- `shared-wrapper`は[`copyable`](/reference/concepts/copyable.md)のモデルである。
+- ムーブ操作 : 移動済みオブジェクトをヌルとする。
+- コピー操作 : `sh_state-&amp;gt;inc-ref()`を呼び出して参照カウントをインクリメントする。
+- 代入操作 : Copy-And-Swap操作を行う。
+- デストラクタ : `sh_state`がヌルのときは何もしない。そうでないとき、`sh_state-&amp;gt;dec-ref()`を評価して参照カウントをデクリメントする。
+
+
+### Senderアルゴリズムタグ `split-impl-tag`
+Senderアルゴリズム動作説明用のクラステンプレート[`impls-for`](impls-for.md)に対して、下記の特殊化が定義される。
+
+```cpp
+namespace std::execution {
+  template&amp;lt;&amp;gt;
+  struct impls-for&amp;lt;split-impl-tag&amp;gt; : default-impls {
+    static constexpr auto get-state = see below;
+    static constexpr auto start = see below;
+  };
+}
+```
+* impls-for[link impls-for.md]
+* default-impls[link impls-for.md]
+* see below[italic]
+
+`impls-for&amp;lt;split-impl-tag&amp;gt;::get-state`メンバは、下記ラムダ式と等価な関数呼び出し可能なオブジェクトで初期化される。
+
+```cpp
+[]&amp;lt;class Sndr&amp;gt;(Sndr&amp;amp;&amp;amp; sndr, auto&amp;amp; rcvr) noexcept {
+  return local-state{std::forward&amp;lt;Sndr&amp;gt;(sndr), rcvr};
+}
+```
+
+`impls-for&amp;lt;split-impl-tag&amp;gt;::start`メンバは、下記の関数呼び出し演算子をもつオブジェクトで初期化される。
+
+```cpp
+template&amp;lt;class Sndr, class Rcvr&amp;gt;
+void operator()(local-state&amp;lt;Sndr, Rcvr&amp;gt;&amp;amp; state, Rcvr&amp;amp; rcvr) const noexcept;
+```
+
+効果 : `state.sh_state-&amp;gt;completed == true`のとき、`state.notify()`を評価してリターンする。そうでなければ、下記を順番に行う。
+
+- 以下を評価する。
+
+    ```cpp
+    state.on_stop.emplace(
+      get_stop_token(get_env(rcvr)),
+      on-stop-request{state.sh_state-&amp;gt;stop_src});
+    ```
+    * emplace[link /reference/optional/optional/emplace.md]
+    * get_stop_token[link ../get_stop_token.md]
+    * get_env[link get_env.md]
+    * on-stop-request[link on-stop-request.md]
+
+- 下記をアトミックに行う。
+    - `state.sh_state-&amp;gt;completed`の値`c`を読み取り
+    - `c == false`のとき、`state.sh_state-&amp;gt;waiting_state`に[`addressof`](/reference/memory/addressof.md)`(state)`を挿入する
+- `c == true`ならば、`state.notify()`を呼び出してリターンする。
+- そうではなく、[`addressof`](/reference/memory/addressof.md)`(state)`が`state.sh_state-&amp;gt;waiting_state`に最初に追加されるアイテムならば、`state.sh_state-&amp;gt;start-op()`を評価する。
+
+
+## 説明専用エンティティ
+### `local-state`クラステンプレート
+
+```cpp
+namespace std::execution {
+  struct local-state-base {                // exposition only
+    virtual ~local-state-base() = default;
+    virtual void notify() noexcept = 0;    // exposition only
+  };
+
+  template&amp;lt;class Sndr, class Rcvr&amp;gt;
+  struct local-state : local-state-base {  // exposition only
+    using on-stop-callback =               // exposition only
+      stop_callback_for_t&amp;lt;stop_token_of_t&amp;lt;env_of_t&amp;lt;Rcvr&amp;gt;&amp;gt;, on-stop-request&amp;gt;;
+
+    local-state(Sndr&amp;amp;&amp;amp; sndr, Rcvr&amp;amp; rcvr) noexcept;
+    ~local-state();
+
+    void notify() noexcept override;
+
+  private:
+    optional&amp;lt;on-stop-callback&amp;gt; on_stop;    // exposition only
+    shared-state&amp;lt;Sndr&amp;gt;* sh_state;          // exposition only
+    Rcvr* rcvr;                            // exposition only
+  };
+}
+```
+* stop_callback_for_t[link /reference/stop_token/stop_callback_for_t.md]
+* stop_token_of_t[link ../stop_token_of_t.md]
+* env_of_t[link env_of_t.md]
+* on-stop-request[link on-stop-request.md]
+* optional[link /reference/optional/optional.md]
+
+```cpp
+local-state(Sndr&amp;amp;&amp;amp; sndr, Rcvr&amp;amp; rcvr) noexcept;
+```
+
+- 効果 : 下記と等価。
+
+    ```cpp
+    auto&amp;amp; [_, data, _] = sndr;
+    this-&amp;gt;sh_state = data.sh_state.get();
+    this-&amp;gt;sh_state-&amp;gt;inc-ref();
+    this-&amp;gt;rcvr = addressof(rcvr);
+    ```
+    * addressof[link /reference/memory/addressof.md]
+
+```cpp
+~local-state();
+```
+
+- 効果 : 下記と等価。
+
+    ```cpp
+    sh_state-&amp;gt;dec-ref();
+    ```
+
+```cpp
+void notify() noexcept override;
+```
+
+- 効果 : 下記と等価。
+
+    ```cpp
+    on_stop.reset();
+    visit(
+      [this](const auto&amp;amp; tupl) noexcept -&amp;gt; void {
+        apply(
+          [this](auto tag, const auto&amp;amp;... args) noexcept -&amp;gt; void {
+            tag(std::move(*rcvr), args...);
+          },
+          tupl);
+      },
+      sh_state-&amp;gt;result);
+    ```
+    * reset()[link /reference/optional/optional/reset.md]
+    * visit[link /reference/variant/visit.md]
+    * apply[link /reference/tuple/apply.md]
+    * std::move[link /reference/utility/move.md]
+
+
+### `split-receiver`クラステンプレート
+
+```cpp
+namespace std::execution {
+  template&amp;lt;class Sndr&amp;gt;
+  struct split-receiver {  // exposition only
+    using receiver_concept = receiver_t;
+
+    template&amp;lt;class Tag, class... Args&amp;gt;
+    void complete(Tag, Args&amp;amp;&amp;amp;... args) noexcept {  // exposition only
+      using tuple_t = decayed-tuple&amp;lt;Tag, Args...&amp;gt;;
+      try {
+        sh_state-&amp;gt;result.template emplace&amp;lt;tuple_t&amp;gt;(Tag(), std::forward&amp;lt;Args&amp;gt;(args)...);
+      } catch (...) {
+        using tuple_t = tuple&amp;lt;set_error_t, exception_ptr&amp;gt;;
+        sh_state-&amp;gt;result.template emplace&amp;lt;tuple_t&amp;gt;(set_error, current_exception());
+      }
+      sh_state-&amp;gt;notify();
+    }
+
+    template&amp;lt;class... Args&amp;gt;
+    void set_value(Args&amp;amp;&amp;amp;... args) &amp;amp;&amp;amp; noexcept {
+      complete(execution::set_value, std::forward&amp;lt;Args&amp;gt;(args)...);
+    }
+
+    template&amp;lt;class Error&amp;gt;
+    void set_error(Error&amp;amp;&amp;amp; err) &amp;amp;&amp;amp; noexcept {
+      complete(execution::set_error, std::forward&amp;lt;Error&amp;gt;(err));
+    }
+
+    void set_stopped() &amp;amp;&amp;amp; noexcept {
+      complete(execution::set_stopped);
+    }
+
+    struct env {                     // exposition only
+      shared-state&amp;lt;Sndr&amp;gt;* sh-state;  // exposition only
+
+      inplace_stop_token query(get_stop_token_t) const noexcept {
+        return sh-state-&amp;gt;stop_src.get_token();
+      }
+    };
+
+    env get_env() const noexcept {
+      return env{sh_state};
+    }
+
+    shared-state&amp;lt;Sndr&amp;gt;* sh_state;    // exposition only
+  };
+}
+```
+* receiver_t[link receiver.md]
+* decayed-tuple[link decayed-tuple.md]
+* template emplace[link /reference/variant/variant/emplace.md]
+* set_error_t[link set_error.md]
+* exception_ptr[link /reference/exception/exception_ptr.md]
+* current_exception()[link /reference/exception/current_exception.md]
+* execution::set_value[link set_value.md]
+* execution::set_error[link set_error.md]
+* execution::set_stopped[link set_stopped.md]
+* inplace_stop_token[link /reference/stop_token/inplace_stop_token.md]
+* get_stop_token_t[link ../get_stop_token.md]
+* get_token()[link /reference/stop_token/inplace_stop_source/get_token.md]
+
+
+### `shared-state`クラステンプレート
+
+```cpp
+namespace std::execution {
+  template&amp;lt;class Sndr&amp;gt;
+  struct shared-state {
+    using variant-type = see below;     // exposition only
+    using state-list-type = see below;  // exposition only
+
+    explicit shared-state(Sndr&amp;amp;&amp;amp; sndr);
+
+    void start-op() noexcept;           // exposition only
+    void notify() noexcept;             // exposition only
+    void inc-ref() noexcept;            // exposition only
+    void dec-ref() noexcept;            // exposition only
+
+    inplace_stop_source stop_src{};     // exposition only
+    variant-type result{};              // exposition only
+    state-list-type waiting_states;     // exposition only
+    atomic&amp;lt;bool&amp;gt; completed{false};      // exposition only
+    atomic&amp;lt;size_t&amp;gt; ref_count{1};        // exposition only
+    connect_result_t&amp;lt;Sndr, split-receiver&amp;lt;Sndr&amp;gt;&amp;gt; op_state;  // exposition only
+  };
+}
+```
+* inplace_stop_source[link /reference/stop_token/inplace_stop_source.md]
+* atomic[link /reference/atomic/atomic.md]
+* connect_result_t[link connect_result_t.md]
+* see below[italic]
+
+- 説明用のパック`Sigs`を[`completion_signatures_of_t`](completion_signatures_of_t.md)`&amp;lt;Sndr&amp;gt;`による[`completion_signatures`](completion_signatures.md)特殊化のテンプレートパラメータと定義する。説明用の型`Tag`とパック`Args`に対して、説明用のエイリアステンプレート`as-tuple&amp;lt;Tag(Args...)&amp;gt;`を[`decayed-tuple`](decayed-tuple.md)`&amp;lt;Tag, Args...&amp;gt;`と定義する。型`variant-type`は下記定義において重複削除した型となる。
+
+    ```cpp
+    variant&amp;lt;tuple&amp;lt;set_stopped_t&amp;gt;, tuple&amp;lt;set_error_t, exception_ptr&amp;gt;, as-tuple&amp;lt;Sigs&amp;gt;...&amp;gt;
+    ```
+    * variant[link /reference/variant/variant.md]
+    * tuple[link /reference/tuple/tuple.md]
+    * set_stopped_t[link set_stopped.md]
+    * set_error_t[link set_error.md]
+    * exception_ptr[link /reference/exception/exception_ptr.md]
+
+- 型`state-list-type`を、`local-state-base`オブジェクトへのポインタのリストを格納し、アトミックに要素挿入できる型とする。
+
+```cpp
+explicit shared-state(Sndr&amp;amp;&amp;amp; sndr);
+```
+
+- 効果 : `op_state`を[`connect`](connect.md)`(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;Sndr&amp;gt;(sndr), split-receiver{this})`の結果で初期化する。
+- 事後条件 : `waiting_states`が空、かつ`completed == false`
+
+```cpp
+void start-op() noexcept;
+```
+
+- 効果 : `inc-ref()`を評価する。`stop_src.`[`stop_requested()`](/reference/stop_token/inplace_stop_source/stop_requested.md) `== ture`のとき`notify()`を評価する。そうでなければ、[`start`](start.md)`(op_state)`を評価する。
+
+```cpp
+void notify() noexcept;
+```
+
+- 効果 : 下記をアトミックに行い、ローカル変数`prior_states`の各ポインタ`p`に対して`p-&amp;gt;notify()`を評価し、最後に`dec-ref()`を評価する。
+    - `completed`に`true`を設定し、
+    - `waiting_states`を空のリストと交換し、古い値をローカル変数`prior_states`に格納する。
+
+```cpp
+void inc-ref() noexcept;
+```
+
+- 効果 : `ref_count`をインクリメントする。
+
+```cpp
+void dec-ref() noexcept;
+```
+
+- 効果 : `ref_count`をデクリメントする。`ref_count`の新たな値が`0`のとき、`delete this`を呼び出す。
+- 同期操作 : `dec-ref()`の評価が`ref_count`を値`0`にデクリメントしないとき、`ref_count`を値`0`へデクリメントする`dec-ref()`の評価に対して同期する。
+
+
+## カスタマイゼーションポイント
+Senderアルゴリズム構築時に、[Sender](sender.md)`sndr`に[関連付けられた実行ドメイン](get-domain-early.md)に対して[`execution::transform_sender`](transform_sender.md)経由でSender変換が行われる。
+[デフォルト実行ドメイン](default_domain.md)では`split.transform_sender(sndr)`が呼ばれ、前述仕様通りのSenderへと変換される。
+
+
+## 例
+```cpp example
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;execution&amp;gt;
+namespace ex = std::execution;
+
+int main()
+{
+  { // 関数呼び出し
+    ex::sender auto snd0 = ex::just(21);
+    ex::sender auto snd1 = ex::then(snd0, [](int n) {
+        std::println(&amp;#34;then&amp;#34;);
+        return 2 * n;
+      });
+    ex::sender auto sndr = ex::split(snd1);
+
+    auto [val1] = std::this_thread::sync_wait(sndr).value();
+    std::println(&amp;#34;{}&amp;#34;, val1);
+    auto [val2] = std::this_thread::sync_wait(sndr).value();
+    std::println(&amp;#34;{}&amp;#34;, val2);
+  }
+
+  { // パイプライン記法
+    ex::sender auto sndr =
+      ex::just(21)
+      | ex::then([](int n) {
+          std::println(&amp;#34;then&amp;#34;);
+          return 2 * n;
+        })
+      | ex::split();
+
+    auto [val1] = std::this_thread::sync_wait(sndr).value();
+    std::println(&amp;#34;{}&amp;#34;, val1);
+    auto [val2] = std::this_thread::sync_wait(sndr).value();
+    std::println(&amp;#34;{}&amp;#34;, val2);
+  }
+}
+```
+* ex::split[color ff0000]
+* ex::sender[link sender.md]
+* ex::just[link just.md]
+* ex::then[link then.md]
+* std::this_thread::sync_wait[link ../this_thread/sync_wait.md]
+* value()[link /reference/optional/optional/value.md]
+
+### 出力
+```
+then
+42
+42
+then
+42
+42
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
+- [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>then -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/then.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/then.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/then.md b/reference/execution/execution/then.md
index bdbbdb2a6..257d738ed 100644
--- a/reference/execution/execution/then.md
+++ b/reference/execution/execution/then.md
@@ -127,4 +127,5 @@ C++
 
 
 ## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>when_all -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/when_all.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/when_all.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/when_all.md b/reference/execution/execution/when_all.md
index d22c00b32..44a365383 100644
--- a/reference/execution/execution/when_all.md
+++ b/reference/execution/execution/when_all.md
@@ -16,7 +16,7 @@ namespace std::execution {
 `when_all`は、複数の入力[Sender](sender.md)が全て完了するまで待機するSenderアダプタである。
 
 `when_all`は全ての入力Senderが[値完了シグネチャ](set_value.md)を1個だけ持つことを要求する。
-値完了シグネチャが複数存在する場合は[`when_all_with_variant`](when_all_with_variant.md)アルゴリズムを利用する
+値完了シグネチャが複数存在する場合は[`when_all_with_variant`](when_all_with_variant.md)アルゴリズムを利用する。
 
 - 入力Sender全てが値完了のとき、全ての値完了結果を[`tuple`](/reference/tuple/tuple.md)に結合して値完了操作を行う。
 - いずれかがエラー完了のとき、同エラー値をもってエラー完了操作を行う。このとき停止要求が作成される。
@@ -319,6 +319,7 @@ variant&amp;lt;none-such, copy-fail, Es...&amp;gt;
     ```
     * set_stopped[link set_stopped.md]
     * reset()[link /reference/optional/optional/reset.md]
+    * std::move[link /reference/utility/move.md]
 
 
 ## カスタマイゼーションポイント
@@ -390,8 +391,8 @@ struct MySender {
     void start() noexcept {
       auto stok = ex::get_stop_token(ex::get_env(rcvr_));
       if (stok.stop_requested()) {
-   　　  // 接続先Receiverにおいて停止要求が行われていれば
-        // MySenderも停止完了により早期リターンする
+        // 接続先Receiverにおいて停止要求が行われていれば
+        // 非同期操作も停止完了により早期リターンさせる
         std::println(&amp;#34;{}: set_stopped&amp;#34;, val_);
         ex::set_stopped(std::move(rcvr_));
         return;
@@ -478,4 +479,5 @@ error=-2
 
 
 ## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>when_all_with_variant -- execution: split (#1384)</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/when_all_with_variant.html"/>
      <id>ae2af9069e2ce2af75afc1660f0568839fafbc13:reference/execution/execution/when_all_with_variant.md</id>
      <updated>2025-05-27T19:13:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/when_all_with_variant.md b/reference/execution/execution/when_all_with_variant.md
index 7aef2d143..fb413fec8 100644
--- a/reference/execution/execution/when_all_with_variant.md
+++ b/reference/execution/execution/when_all_with_variant.md
@@ -16,7 +16,7 @@ namespace std::execution {
 `when_all_with_variant`は、複数の入力[Sender](sender.md)が全て完了するまで待機するSenderアダプタである。
 
 `when_all_with_variant`は入力Senderが複数の[値完了シグネチャ](set_value.md)を持つケースに対応する。
-全入力Senderの値完了シグネチャが1個だけの場合は[`when_all`](when_all.md)アルゴリズムを利用する
+全入力Senderの値完了シグネチャが1個だけの場合は[`when_all`](when_all.md)アルゴリズムを利用する。
 
 - 入力Sender全てが値完了のとき、全ての値完了結果を[`variant`](/reference/variant/variant.md)の[`tuple`](/reference/tuple/tuple.md)に結合して値完了操作を行う。
 - いずれかがエラー完了のとき、同エラー値をもってエラー完了操作を行う。このとき停止要求が作成される。
@@ -182,4 +182,5 @@ int main()
 
 
 ## 参照
+- [P2999R3 Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html)
 - [P2300R10 `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2300r10.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left -- fold_left, fold_right : 箇条書きの表示崩れを修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.html"/>
      <id>9094beb997b31879c2fe78a6249d4cddc5163ba6:reference/algorithm/ranges_fold_left.md</id>
      <updated>2025-05-27T17:59:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left.md b/reference/algorithm/ranges_fold_left.md
index 8c7651f38..cd35caa38 100644
--- a/reference/algorithm/ranges_fold_left.md
+++ b/reference/algorithm/ranges_fold_left.md
@@ -152,6 +152,7 @@ concept indirectly-binary-left-foldable =
 
     - すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
     - また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+
 - (1), (2) :
     - C++26 : 引数として波カッコ初期化`{}`を受け付ける
         ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_right -- fold_left, fold_right : 箇条書きの表示崩れを修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.html"/>
      <id>9094beb997b31879c2fe78a6249d4cddc5163ba6:reference/algorithm/ranges_fold_right.md</id>
      <updated>2025-05-27T17:59:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_right.md b/reference/algorithm/ranges_fold_right.md
index 2c418690b..89531d1fd 100644
--- a/reference/algorithm/ranges_fold_right.md
+++ b/reference/algorithm/ranges_fold_right.md
@@ -149,6 +149,7 @@ return accum;
 
     - すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
     - また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+
 - (1), (2) :
     - C++26 : 引数として波カッコ初期化`{}`を受け付ける
         ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>