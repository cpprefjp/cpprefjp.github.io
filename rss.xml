<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-03-19T02:10:10.109163</updated>
  <id>5f3bf6e4-11e5-4ea0-a70a-4876f2a68ded</id>

  
    <entry>
      <title>functional -- identity追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/functional.html"/>
      <id>18218a8b7daa8b6836d93bdd2233968c782d31df:reference/functional.md</id>
      <updated>2020-03-19T11:06:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional.md b/reference/functional.md
index 6caa4516d..e5f63fc6c 100644
--- a/reference/functional.md
+++ b/reference/functional.md
@@ -118,6 +118,13 @@ struct doubler {
 | [`not2`](functional/negators.md)          | 二項の述語を論理反転する (function template) | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 
 
+## 恒等写像関数オブジェクト
+
+| 名前 | 説明 | 対応バージョン |
+|---------------------------------------------|--------------------------|-------|
+| [`identity`](functional/identity.md)          | 入力値を値カテゴリも含めてそのまま返す (function template) | C++20 |
+
+
 ## 検索
 
 | 名前 | 説明 | 対応バージョン |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>identity -- identity追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/functional/identity.html"/>
      <id>18218a8b7daa8b6836d93bdd2233968c782d31df:reference/functional/identity.md</id>
      <updated>2020-03-19T11:06:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/identity.md b/reference/functional/identity.md
new file mode 100644
index 000000000..e649b5452
--- /dev/null
+++ b/reference/functional/identity.md
@@ -0,0 +1,84 @@
+# identity
+* functional[meta header]
+* std[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+
+  struct identity {
+    template&amp;lt;class T&amp;gt;
+    constexpr T&amp;amp;&amp;amp; operator()(T&amp;amp;&amp;amp; t) const noexcept;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+
+## 概要
+
+`identity`クラスは、引数に対して恒等変換を行う関数オブジェクトである。この恒等変換はC++意味論においてのものであり、値そのもの及びCV修飾や値カテゴリも含めて引数をそのまま返す。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+
+## メンバ関数
+
+| 名前         | 説明           | 対応バージョン |
+|--------------|----------------|----------------|
+| `operator()` | `return std​::​forward&amp;lt;T&amp;gt;(t);` | C++20          |
+
+
+## メンバ型
+
+| 名前                   | 説明                                                                                                                                                       | 対応バージョン |
+|------------------------|--------------------------------|----------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。（`T` が `void` の場合のみ） | C++20          |
+
+## 備考
+
+これは主に[`&amp;lt;ranges&amp;gt;`](/reference/ranges.md.nolink)において、カスタマイズ可能な射影操作のデフォルトとして利用される。
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+//intを受け取ってその値と射影した値を足して返す
+//デフォルトはnを2倍にする
+template&amp;lt;typename Projection = std::identity&amp;gt;
+auto f(int n, Projection proj = {}) -&amp;gt; int {
+  return n + proj(n);
+}
+
+int main()
+{
+  //デフォルトの射影で呼び出し
+  std::cout &amp;lt;&amp;lt; f(10) &amp;lt;&amp;lt; std::endl;
+  //何も足さないようにカスタマイズ
+  std::cout &amp;lt;&amp;lt; f(10, [](int){return 0;}) &amp;lt;&amp;lt; std::endl;
+  //3倍にする
+  std::cout &amp;lt;&amp;lt; f(10, [](int m){return m + m;}) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::identity[color ff0000]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 3
+
+## 参照
+
+- [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>relation -- relation : 不可視の文字の削除</title>
      <link href="https://cpprefjp.github.io/reference/concepts/relation.html"/>
      <id>f60d6f03d651433333f47116daa960f296c987dc:reference/concepts/relation.md</id>
      <updated>2020-03-18T15:52:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/relation.md b/reference/concepts/relation.md
index fbc9c13c3..8def5a9a9 100644
--- a/reference/concepts/relation.md
+++ b/reference/concepts/relation.md
@@ -12,7 +12,7 @@ namespace std {
     predicate&amp;lt;R, T, U&amp;gt; &amp;amp;&amp;amp; predicate&amp;lt;R, U, T&amp;gt;;
 }
 ```
-* regular_­invocable[link /reference/concepts/­invocable.md]
+* regular_invocable[link /reference/concepts/invocable.md]
 * boolean-testable[link /reference/concepts/boolean.md]
 * invoke_result_t[link /reference/type_traits/invoke_result.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>predicate -- predicate : 不可視の文字の削除</title>
      <link href="https://cpprefjp.github.io/reference/concepts/predicate.html"/>
      <id>efa49df481f22ddf016fdbeb224631d776fa889c:reference/concepts/predicate.md</id>
      <updated>2020-03-18T15:51:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/predicate.md b/reference/concepts/predicate.md
index eff7a0d74..27c9d8bc3 100644
--- a/reference/concepts/predicate.md
+++ b/reference/concepts/predicate.md
@@ -11,13 +11,13 @@ namespace std {
     regular_invocable&amp;lt;F, Args...&amp;gt; &amp;amp;&amp;amp; boolean-testable&amp;lt;invoke_result_t&amp;lt;F, Args...&amp;gt;&amp;gt;;
 }
 ```
-* regular_­invocable[link /reference/concepts/­invocable.md]
+* regular_invocable[link /reference/concepts/invocable.md]
 * boolean-testable[link /reference/concepts/boolean.md]
 * invoke_result_t[link /reference/type_traits/invoke_result.md]
 
 ## 概要
 
-`predicate`は、任意の関数呼び出し可能な型`F`が引数`Args...`によって関数呼び出し可能（[`regular_­invocable`](/reference/concepts/­invocable.md)）であり、その戻り値型が`bool`に変換可能であることを表すコンセプトである。
+`predicate`は、任意の関数呼び出し可能な型`F`が引数`Args...`によって関数呼び出し可能（[`regular_invocable`](/reference/concepts/invocable.md)）であり、その戻り値型が`bool`に変換可能であることを表すコンセプトである。
 
 `predicate`のモデルとなる`F`はその引数`Args...`に対しての述語（*predicate*）と呼ばれ、（[`&amp;lt;algorithm&amp;gt;`](/reference/algorithm.md)の関数などにおいて）引数がある条件を満たしているかを判定するものとして利用される。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>concepts -- 関数呼び出し関連のコンセプト追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/concepts.html"/>
      <id>9125b98d436fdaefa028e8881658f96191be1304:reference/concepts.md</id>
      <updated>2020-03-18T15:49:53+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts.md b/reference/concepts.md
index 95a94be19..2f7a735d2 100644
--- a/reference/concepts.md
+++ b/reference/concepts.md
@@ -126,11 +126,12 @@ concept C =
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| `invocable` | INVOKEコンセプトに従った関数呼び出しが可能 | C++20 |
-| `regular_invocable` | 正則呼び出し可能 | C++20 |
-| `predicate` | 述語 | C++20 |
-| `relation` | 述語関係 | C++20 |
-| `strict_weak_order` | 狭義の弱順序 | C++20 |
+| [`invocable`](concepts/invocable.md) | INVOKEコンセプトに従った関数呼び出しが可能 | C++20 |
+| [`regular_invocable`](concepts/invocable.md) | 正則呼び出し可能 | C++20 |
+| [`predicate`](concepts/predicate.md) | 述語 | C++20 |
+| [`relation`](concepts/relation.md) | 二項関係 | C++20 |
+| [`equivalence_relation`](concepts/equivalence_relation.md) | 同値関係 | C++20 |
+| [`strict_weak_order`](concepts/strict_weak_order.md) | 狭義の弱順序 | C++20 |
 
 
 ## カスタマイゼーションポイントオブジェクト
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equivalence_relation -- 関数呼び出し関連のコンセプト追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/concepts/equivalence_relation.html"/>
      <id>9125b98d436fdaefa028e8881658f96191be1304:reference/concepts/equivalence_relation.md</id>
      <updated>2020-03-18T15:49:53+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/equivalence_relation.md b/reference/concepts/equivalence_relation.md
new file mode 100644
index 000000000..4385a32e1
--- /dev/null
+++ b/reference/concepts/equivalence_relation.md
@@ -0,0 +1,97 @@
+# equivalence_relation
+* concepts[meta header]
+* std[meta namespace]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class R, class T, class U&amp;gt;
+  concept equivalence_relation = relation&amp;lt;R, T, U&amp;gt;;
+}
+```
+* relation[link /reference/concepts/relation.md]
+
+## 概要
+
+`equivalence_relation`は、型`T, U`の間の[二項関係](/reference/concepts/predicate.md)`R`が同値関係であることを表すコンセプトである。
+
+## モデル
+
+[`relation`](/reference/concepts/relation.md)のモデルである二項関係`R`は、その引数型`T, U`の間の同値関係を示す場合に限って、`equivalence_relation`のモデルである。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+
+template&amp;lt;typename R, typename T, typename U&amp;gt;
+requires std::equivalence_relation&amp;lt;R, T, U&amp;gt;
+void f(const char* name, const char* tname, const char* uname) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is equivalence relation between &amp;#34; &amp;lt;&amp;lt; tname &amp;lt;&amp;lt; &amp;#34; and &amp;#34; &amp;lt;&amp;lt; uname &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename R, typename T, typename U&amp;gt;
+void f(const char* name, const char* tname, const char* uname) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not equivalence relation between &amp;#34; &amp;lt;&amp;lt; tname &amp;lt;&amp;lt; &amp;#34; and &amp;#34; &amp;lt;&amp;lt; uname &amp;lt;&amp;lt; std::endl;
+}
+
+
+struct S1 {
+  int n = 0;
+};
+
+struct S2 {
+  short m = 0;
+};
+
+// S1とS2の間の同値関係
+struct equivalence_relation_s1s2 {
+  
+  bool operator()(S1 lhs, S1 rhs) const {
+    return lhs.n == rhs.n;
+  }
+
+  bool operator()(S2 lhs, S2 rhs ) const {
+    return lhs.m == rhs.m;
+  }
+
+  bool operator()(S1 lhs, S2 rhs) const {
+    return lhs.n == rhs.m;
+  }
+  
+  bool operator()(S2 lhs, S1 rhs) const {
+    return lhs.m == rhs.n;
+  }
+};
+
+int main() {
+  f&amp;lt;equivalence_relation_s1s2, S1, S2&amp;gt;(&amp;#34;equivalence_relation_s1s2&amp;#34;, &amp;#34;S1&amp;#34;, &amp;#34;S2&amp;#34;);
+  f&amp;lt;equivalence_relation_s1s2, S2, S1&amp;gt;(&amp;#34;equivalence_relation_s1s2&amp;#34;, &amp;#34;S2&amp;#34;, &amp;#34;S1&amp;#34;);
+}
+```
+* std::equivalence_relation[color ff0000]
+
+### 出力
+```
+equivalence_relation_s1s2 is equivalence relation between S1 and S2
+equivalence_relation_s1s2 is equivalence relation between S2 and S1
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 3
+
+## 関連項目
+
+- [C++20 コンセプト](/lang/cpp20/concepts.md)
+
+## 参照
+
+- [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
+- [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>invocable -- 関数呼び出し関連のコンセプト追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/concepts/invocable.html"/>
      <id>9125b98d436fdaefa028e8881658f96191be1304:reference/concepts/invocable.md</id>
      <updated>2020-03-18T15:49:53+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/invocable.md b/reference/concepts/invocable.md
new file mode 100644
index 000000000..1d58f1181
--- /dev/null
+++ b/reference/concepts/invocable.md
@@ -0,0 +1,190 @@
+# invocable
+* concepts[meta header]
+* std[meta namespace]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class F, class... Args&amp;gt;
+  concept invocable = requires(F&amp;amp;&amp;amp; f, Args&amp;amp;&amp;amp;... args) {
+    invoke(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Args&amp;gt;(args)...);
+  };
+
+  template&amp;lt;class F, class... Args&amp;gt;
+  concept regular_invocable = invocable&amp;lt;F, Args...&amp;gt;;
+}
+```
+* invoke[link /reference/functional/invoke.md]
+
+## 概要
+
+`invocable`及び`regular_invocable`は、任意の関数呼び出し可能な型`F`が引数`Args...`によって関数呼び出し可能であることを表すコンセプトである。
+
+## 等しさの保持
+
+`invocable`コンセプトでは`F`の`Args...`による関数呼び出しが[等しさを保持](/reference/concepts.md)することを要求しない。従って、`invocable`コンセプトのモデルとなる型`F, Args...`は関数呼び出しに際して副作用があっても良く、その出力が内部状態や外部状態に依存していても構わない。
+
+対して、`regular_invocable`コンセプトのモデルとなる`F`の`Args...`による関数呼び出しには[等しさを保持](/reference/concepts.md)することが要求される。従って、`regular_invocable`コンセプトのモデルとなる型`F, Args...`は関数呼び出しに際して副作用を持ってはならず、出力は何かしらの状態に依存してはならない。ただし、このことは構文的に（コンパイル時に）チェックされるものではなく、純粋に意味論的な制約として要求・表明される。
+
+例えば、[乱数・分布生成器](/reference/random.md)はその呼び出しに際して等しさを保持しない（内部に状態を保ち、出力はそれに依存する）ため、`regular_invocable`コンセプトのモデルにはならないが`invocable`コンセプトのモデルとなる。
+
+## 例
+
+### invocable
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;random&amp;gt;
+
+template&amp;lt;typename F, typename... Args&amp;gt;
+requires std::invocable&amp;lt;F, Args...&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is invocable&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename F, typename... Args&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not invocable&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+
+void func(int);
+auto lambda = [](auto a) { return a; };
+auto mut_lambda = [n = 0](auto a) mutable { ++n; return n + a; };
+
+struct invocable {
+  template&amp;lt;typename T&amp;gt;
+  void operator()(T&amp;amp;&amp;amp; t) const {
+    return t;
+  }
+};
+
+struct not_invocable {};
+
+
+int main() {
+  f&amp;lt;decltype(func), int&amp;gt;(&amp;#34;func(int)&amp;#34;);
+  f&amp;lt;decltype(lambda), int&amp;gt;(&amp;#34;lambda(int)&amp;#34;);
+  f&amp;lt;decltype(lambda), int*&amp;gt;(&amp;#34;lambda(int*)&amp;#34;);
+  f&amp;lt;invocable, int&amp;gt;(&amp;#34;invocable(int)&amp;#34;);
+  f&amp;lt;invocable, int***&amp;gt;(&amp;#34;invocable(int***)&amp;#34;);
+
+  // 内部状態を保ち、等しさを保持しない呼び出し可能な型
+  f&amp;lt;decltype(mut_lambda), int&amp;gt;(&amp;#34;mut_lambda(int)&amp;#34;);
+  f&amp;lt;std::mt19937&amp;gt;(&amp;#34;std::mt19937()&amp;#34;);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+
+  f&amp;lt;decltype(func), int*&amp;gt;(&amp;#34;func(int*)&amp;#34;);
+  f&amp;lt;not_invocable&amp;gt;(&amp;#34;not_invocable()&amp;#34;);
+  f&amp;lt;not_invocable, int&amp;gt;(&amp;#34;not_invocable(int)&amp;#34;);
+}
+```
+* std::invocable[color ff0000]
+
+#### 出力
+```
+func(int) is invocable
+lambda(int) is invocable
+lambda(int*) is invocable
+invocable(int) is invocable
+invocable(int***) is invocable
+
+mut_lambda(int) is invocable
+std::mt19937() is invocable
+
+func(int*) is not invocable
+not_invocable() is not invocable
+not_invocable(int) is not invocable
+```
+
+### regular_invocable
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;random&amp;gt;
+
+template&amp;lt;typename F, typename... Args&amp;gt;
+requires std::regular_invocable&amp;lt;F, Args...&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is regular_invocable&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename F, typename... Args&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not regular_invocable&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+
+void func(int);
+auto lambda = [](auto a) { return a; };
+auto mut_lambda = [n = 0](auto a) mutable { ++n; return n + a; };
+
+struct invocable {
+  template&amp;lt;typename T&amp;gt;
+  void operator()(T&amp;amp;&amp;amp; t) const {
+    return t;
+  }
+};
+
+struct not_invocable {};
+
+
+int main() {
+  f&amp;lt;decltype(func), int&amp;gt;(&amp;#34;func(int)&amp;#34;);
+  f&amp;lt;decltype(lambda), int&amp;gt;(&amp;#34;lambda(int)&amp;#34;);
+  f&amp;lt;decltype(lambda), int*&amp;gt;(&amp;#34;lambda(int*)&amp;#34;);
+  f&amp;lt;invocable, int&amp;gt;(&amp;#34;invocable(int)&amp;#34;);
+  f&amp;lt;invocable, int***&amp;gt;(&amp;#34;invocable(int***)&amp;#34;);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  // 内部状態を保ち、等しさを保持しない呼び出し可能な型
+  f&amp;lt;decltype(mut_lambda), int&amp;gt;(&amp;#34;mut_lambda(int)&amp;#34;);
+  f&amp;lt;std::mt19937&amp;gt;(&amp;#34;std::mt19937()&amp;#34;);
+  
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  f&amp;lt;decltype(func), int*&amp;gt;(&amp;#34;func(int*)&amp;#34;);
+  f&amp;lt;not_invocable&amp;gt;(&amp;#34;not_invocable()&amp;#34;);
+  f&amp;lt;not_invocable, int&amp;gt;(&amp;#34;not_invocable(int)&amp;#34;);
+}
+```
+* std::invocable[color ff0000]
+
+
+#### 出力
+```
+func(int) is regular_invocable
+lambda(int) is regular_invocable
+lambda(int*) is regular_invocable
+invocable(int) is regular_invocable
+invocable(int***) is regular_invocable
+
+mut_lambda(int) is regular_invocable
+std::mt19937() is regular_invocable
+
+func(int*) is not regular_invocable
+not_invocable() is not regular_invocable
+not_invocable(int) is not regular_invocable
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 3
+
+## 関連項目
+
+- [C++20 コンセプト](/lang/cpp20/concepts.md)
+- [invoke](/reference/functional/invoke.md)
+
+## 参照
+
+- [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
+- [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>predicate -- 関数呼び出し関連のコンセプト追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/concepts/predicate.html"/>
      <id>9125b98d436fdaefa028e8881658f96191be1304:reference/concepts/predicate.md</id>
      <updated>2020-03-18T15:49:53+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/predicate.md b/reference/concepts/predicate.md
new file mode 100644
index 000000000..eff7a0d74
--- /dev/null
+++ b/reference/concepts/predicate.md
@@ -0,0 +1,102 @@
+# predicate
+* concepts[meta header]
+* std[meta namespace]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class F, class... Args&amp;gt;
+  concept predicate =
+    regular_invocable&amp;lt;F, Args...&amp;gt; &amp;amp;&amp;amp; boolean-testable&amp;lt;invoke_result_t&amp;lt;F, Args...&amp;gt;&amp;gt;;
+}
+```
+* regular_­invocable[link /reference/concepts/­invocable.md]
+* boolean-testable[link /reference/concepts/boolean.md]
+* invoke_result_t[link /reference/type_traits/invoke_result.md]
+
+## 概要
+
+`predicate`は、任意の関数呼び出し可能な型`F`が引数`Args...`によって関数呼び出し可能（[`regular_­invocable`](/reference/concepts/­invocable.md)）であり、その戻り値型が`bool`に変換可能であることを表すコンセプトである。
+
+`predicate`のモデルとなる`F`はその引数`Args...`に対しての述語（*predicate*）と呼ばれ、（[`&amp;lt;algorithm&amp;gt;`](/reference/algorithm.md)の関数などにおいて）引数がある条件を満たしているかを判定するものとして利用される。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;random&amp;gt;
+
+template&amp;lt;typename F, typename... Args&amp;gt;
+requires std::predicate&amp;lt;F, Args...&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is predicate&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename F, typename... Args&amp;gt;
+void f(const char* name) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not predicate&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+
+bool func1(int);
+int  func2(int);
+int* func3(int);
+auto lambda = [](auto a) { return a &amp;lt; 10; };
+
+struct predicate {
+  bool operator()(int n) const {
+    return n &amp;lt; 10;
+  }
+};
+
+struct not_predicate {
+  void operator()(int) {
+  }
+};
+
+
+int main() {
+  f&amp;lt;decltype(func1), int&amp;gt;(&amp;#34;func1(int)&amp;#34;);
+  f&amp;lt;decltype(func2), int&amp;gt;(&amp;#34;func2(int)&amp;#34;);
+  f&amp;lt;decltype(func3), int&amp;gt;(&amp;#34;func3(int)&amp;#34;);
+  f&amp;lt;decltype(lambda), int&amp;gt;(&amp;#34;lambda(int)&amp;#34;);
+  f&amp;lt;std::mt19937&amp;gt;(&amp;#34;std::mt19937()&amp;#34;);
+  f&amp;lt;predicate, int&amp;gt;(&amp;#34;predicate(int)&amp;#34;);
+
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  f&amp;lt;not_predicate, int&amp;gt;(&amp;#34;not_predicate(int)&amp;#34;);
+}
+```
+* std::predicate[color ff0000]
+
+### 出力
+```
+func1(int) is predicate
+func2(int) is predicate
+func3(int) is predicate
+lambda(int) is predicate
+std::mt19937() is predicate
+predicate(int) is predicate
+
+not_predicate(int) is not predicate
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 3
+
+## 関連項目
+
+- [C++20 コンセプト](/lang/cpp20/concepts.md)
+
+## 参照
+
+- [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
+- [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>regular -- 関数呼び出し関連のコンセプト追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/concepts/regular.html"/>
      <id>9125b98d436fdaefa028e8881658f96191be1304:reference/concepts/regular.md</id>
      <updated>2020-03-18T15:49:53+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/regular.md b/reference/concepts/regular.md
index 0681a1323..496543532 100644
--- a/reference/concepts/regular.md
+++ b/reference/concepts/regular.md
@@ -21,11 +21,11 @@ namespace std {
 
 正則（*regular*）な型とはつまり以下の性質を備えた型である。
 
-- ムーブ構築・代入
-- コピー構築・代入
-- デフォルト構築
-- `swap`
-- `== !=`による等値比較
+- ムーブ構築・代入可能
+- コピー構築・代入可能
+- デフォルト構築可能
+- `swap`可能
+- `== !=`による等値比較可能
 
 このような正則な型とは、`int`型などの[基本型](/reference/type_traits/is_fundamental.md)の様に扱うことのできる型を表している。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>relation -- 関数呼び出し関連のコンセプト追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/concepts/relation.html"/>
      <id>9125b98d436fdaefa028e8881658f96191be1304:reference/concepts/relation.md</id>
      <updated>2020-03-18T15:49:53+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/relation.md b/reference/concepts/relation.md
new file mode 100644
index 000000000..fbc9c13c3
--- /dev/null
+++ b/reference/concepts/relation.md
@@ -0,0 +1,110 @@
+# relation
+* concepts[meta header]
+* std[meta namespace]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class R, class T, class U&amp;gt;
+  concept relation =
+    predicate&amp;lt;R, T, T&amp;gt; &amp;amp;&amp;amp; predicate&amp;lt;R, U, U&amp;gt; &amp;amp;&amp;amp;
+    predicate&amp;lt;R, T, U&amp;gt; &amp;amp;&amp;amp; predicate&amp;lt;R, U, T&amp;gt;;
+}
+```
+* regular_­invocable[link /reference/concepts/­invocable.md]
+* boolean-testable[link /reference/concepts/boolean.md]
+* invoke_result_t[link /reference/type_traits/invoke_result.md]
+
+## 概要
+
+`relation`は、任意の[述語](/reference/concepts/predicate.md)`R`が型`T, U`の間の二項関係にあることを表すコンセプトである。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+
+template&amp;lt;typename R, typename T, typename U&amp;gt;
+requires std::relation&amp;lt;R, T, U&amp;gt;
+void f(const char* name, const char* tname, const char* uname) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is relation between &amp;#34; &amp;lt;&amp;lt; tname &amp;lt;&amp;lt; &amp;#34; and &amp;#34; &amp;lt;&amp;lt; uname &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename R, typename T, typename U&amp;gt;
+void f(const char* name, const char* tname, const char* uname) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not relation between &amp;#34; &amp;lt;&amp;lt; tname &amp;lt;&amp;lt; &amp;#34; and &amp;#34; &amp;lt;&amp;lt; uname &amp;lt;&amp;lt; std::endl;
+}
+
+
+struct S1 {
+  int n = 0;
+};
+
+struct S2 {
+  short m = 0;
+};
+
+// S1とS2の間の同値関係
+struct relation_s1s2 {
+  
+  bool operator()(S1 lhs, S1 rhs) const {
+    return lhs.n == rhs.n;
+  }
+
+  bool operator()(S2 lhs, S2 rhs ) const {
+    return lhs.m == rhs.m;
+  }
+
+  bool operator()(S1 lhs, S2 rhs) const {
+    return lhs.n == rhs.m;
+  }
+  
+  bool operator()(S2 lhs, S1 rhs) const {
+    return lhs.m == rhs.n;
+  }
+};
+
+// 単にS1とS2の間の述語であるだけではrelationではない
+struct not_relation_s1s2 {
+
+  bool operator()(S1 lhs, S2 rhs) const {
+    return lhs.n == rhs.m;
+  }
+  
+  bool operator()(S2 lhs, S1 rhs) const {
+    return lhs.m == rhs.n;
+  }
+};
+
+int main() {
+  f&amp;lt;relation_s1s2, S1, S2&amp;gt;(&amp;#34;relation_s1s2&amp;#34;, &amp;#34;S1&amp;#34;, &amp;#34;S2&amp;#34;);
+  f&amp;lt;not_relation_s1s2, S1, S2&amp;gt;(&amp;#34;not_relation_s1s2&amp;#34;, &amp;#34;S1&amp;#34;, &amp;#34;S2&amp;#34;);
+}
+```
+* std::relation[color ff0000]
+
+### 出力
+```
+relation_s1s2 is relation between S1 and S2
+not_relation_s1s2 is not relation between S1 and S2
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 3
+
+## 関連項目
+
+- [C++20 コンセプト](/lang/cpp20/concepts.md)
+
+## 参照
+
+- [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
+- [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [二項関係 - wikipedia](https://ja.wikipedia.org/wiki/二項関係)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>strict_weak_order -- 関数呼び出し関連のコンセプト追加 #711</title>
      <link href="https://cpprefjp.github.io/reference/concepts/strict_weak_order.html"/>
      <id>9125b98d436fdaefa028e8881658f96191be1304:reference/concepts/strict_weak_order.md</id>
      <updated>2020-03-18T15:49:53+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/strict_weak_order.md b/reference/concepts/strict_weak_order.md
new file mode 100644
index 000000000..7b684ec67
--- /dev/null
+++ b/reference/concepts/strict_weak_order.md
@@ -0,0 +1,99 @@
+# strict_weak_order
+* concepts[meta header]
+* std[meta namespace]
+* concept[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class R, class T, class U&amp;gt;
+  concept strict_weak_order = relation&amp;lt;R, T, U&amp;gt;;
+}
+```
+* relation[link /reference/concepts/relation.md]
+
+## 概要
+
+`strict_weak_order`は、型`T, U`の間の[二項関係](/reference/concepts/predicate.md)`R`が狭義の弱順序であることを表すコンセプトである。
+
+## モデル
+
+[`relation`](/reference/concepts/relation.md)のモデルである二項関係`R`は、その引数型`T, U`の間の狭義の弱順序関係を示す場合に限って、`strict_weak_order`のモデルである。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;concepts&amp;gt;
+
+template&amp;lt;typename R, typename T, typename U&amp;gt;
+requires std::strict_weak_order&amp;lt;R, T, U&amp;gt;
+void f(const char* name, const char* tname, const char* uname) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is strict weak order between &amp;#34; &amp;lt;&amp;lt; tname &amp;lt;&amp;lt; &amp;#34; and &amp;#34; &amp;lt;&amp;lt; uname &amp;lt;&amp;lt; std::endl;
+}
+
+template&amp;lt;typename R, typename T, typename U&amp;gt;
+void f(const char* name, const char* tname, const char* uname) {
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; is not strict weak order between &amp;#34; &amp;lt;&amp;lt; tname &amp;lt;&amp;lt; &amp;#34; and &amp;#34; &amp;lt;&amp;lt; uname &amp;lt;&amp;lt; std::endl;
+}
+
+
+struct S1 {
+  int n = 0;
+};
+
+struct S2 {
+  short m = 0;
+};
+
+// S1とS2の間の順序関係
+struct strict_weak_order_s1s2 {
+  
+  bool operator()(S1 lhs, S1 rhs) const {
+    return lhs.n &amp;lt; rhs.n;
+  }
+
+  bool operator()(S2 lhs, S2 rhs ) const {
+    return lhs.m &amp;lt; rhs.m;
+  }
+
+  bool operator()(S1 lhs, S2 rhs) const {
+    return lhs.n &amp;lt; rhs.m;
+  }
+  
+  bool operator()(S2 lhs, S1 rhs) const {
+    return lhs.m &amp;lt; rhs.n;
+  }
+};
+
+int main() {
+  f&amp;lt;strict_weak_order_s1s2, S1, S2&amp;gt;(&amp;#34;strict_weak_order_s1s2&amp;#34;, &amp;#34;S1&amp;#34;, &amp;#34;S2&amp;#34;);
+  f&amp;lt;strict_weak_order_s1s2, S2, S1&amp;gt;(&amp;#34;strict_weak_order_s1s2&amp;#34;, &amp;#34;S2&amp;#34;, &amp;#34;S1&amp;#34;);
+}
+```
+* std::strict_weak_order[color ff0000]
+
+### 出力
+```
+strict_weak_order_s1s2 is strict weak order between S1 and S2
+strict_weak_order_s1s2 is strict weak order between S2 and S1
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 3
+
+## 関連項目
+
+- [C++20 コンセプト](/lang/cpp20/concepts.md)
+- [狭義の弱順序](https://cpprefjp.github.io/reference/algorithm.html#strict-weak-ordering)
+
+## 参照
+
+- [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
+- [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [二項関係 - wikipedia](https://ja.wikipedia.org/wiki/二項関係)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_constant_evaluated -- is_constant_evaluated : MSVC対応を追記</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_constant_evaluated.html"/>
      <id>ad04326be88e32511c99cc253f05a5dd9741f664:reference/type_traits/is_constant_evaluated.md</id>
      <updated>2020-03-17T23:30:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_constant_evaluated.md b/reference/type_traits/is_constant_evaluated.md
index e6d285ff2..d20ca8178 100644
--- a/reference/type_traits/is_constant_evaluated.md
+++ b/reference/type_traits/is_constant_evaluated.md
@@ -127,7 +127,7 @@ int main()
 - [Clang](/implementation.md#clang): 9
 - [GCC](/implementation.md#gcc): 9.1
 - [ICC](/implementation.md#icc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 update5
 
 ## 関連項目
 - [C++20 コンパイル時初期化を強制する`constinit`キーワードを追加](/lang/cpp20/constinit.md.nolink)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>