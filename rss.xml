<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-03-20T00:58:37.553881</updated>
  <id>63ca18db-f160-4911-b886-6b0441fe931a</id>

  
    <entry>
      <title>algorithm -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 1ac82501f..eff40d509 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -301,10 +301,10 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`upper_bound`](algorithm/upper_bound.md) | 指定された要素より大きい値が現れる最初の位置のイテレータを取得する | |
 | [`equal_range`](algorithm/equal_range.md) | `lower_bound`と`upper_bound`の結果を組で取得する | |
 | [`binary_search`](algorithm/binary_search.md) | 二分探索法による検索を行う | |
-| [`ranges::lower_bound`](algorithm/ranges_lower_bound.md.nolink)     | 指定された要素以上の値が現れる最初の位置のイテレータを取得する     | C++20 |
-| [`ranges::upper_bound`](algorithm/ranges_upper_bound.md.nolink)     | 指定された要素より大きい値が現れる最初の位置のイテレータを取得する | C++20 |
-| [`ranges::equal_range`](algorithm/ranges_equal_range.md.nolink)     | `lower_bound`と`upper_bound`の結果を組で取得する                   | C++20 |
-| [`ranges::binary_search`](algorithm/ranges_binary_search.md.nolink) | 二分探索法による検索を行う                                         | C++20 |
+| [`ranges::lower_bound`](algorithm/ranges_lower_bound.md)     | 指定された要素以上の値が現れる最初の位置のイテレータを取得する     | C++20 |
+| [`ranges::upper_bound`](algorithm/ranges_upper_bound.md)     | 指定された要素より大きい値が現れる最初の位置のイテレータを取得する | C++20 |
+| [`ranges::equal_range`](algorithm/ranges_equal_range.md)     | 指定した値と等しい範囲を取得する                                   | C++20 |
+| [`ranges::binary_search`](algorithm/ranges_binary_search.md) | 二分探索法による検索を行う                                         | C++20 |
 
 
 ### マージ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_binary_search.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm/ranges_binary_search.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_binary_search.md b/reference/algorithm/ranges_binary_search.md
new file mode 100644
index 000000000..6185c77ae
--- /dev/null
+++ b/reference/algorithm/ranges_binary_search.md
@@ -0,0 +1,89 @@
+# binary_search
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool binary_search(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool binary_search(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+
+## 概要
+二分探索法による検索を行う。
+
+
+## 要件
+`[first,last)` の要素 `e` は `e &amp;lt; value` および `!(value &amp;lt; e)`、または `comp(e, value)` および `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。
+
+また、`[first, last)` の全ての要素 `e` は、`e &amp;lt; value` であれば `!(value &amp;lt; e)` である、または `comp(e, value)` であれば `!comp(value, e)` である必要がある。
+
+
+## 戻り値
+`[first,last)` 内のイテレータ `i` について、`!(*i &amp;lt; value) &amp;amp;&amp;amp; !(value &amp;lt; *i)` または `comp(*i, value) == false &amp;amp;&amp;amp; comp(value, *i) == false` であるようなイテレータが見つかった場合は `true` を返す。
+
+
+## 計算量
+最大で log2(`last - first`) + O(1) 回の比較を行う
+
+
+## 備考
+- `comp` は 2 引数の関数オブジェクトで、1 番目の引数が 2 番目の引数「より小さい」場合に `true` を、そうでない場合に `false` を返すものとして扱われる。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  // binary_search で 4 を検索する場合、
+  // 4 より小さい物、4 と等しい物、4 より大きい物がその順に並んでいれば、
+  // 必ずしもソートされている必要はない。
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+
+  if (std::ranges::binary_search(v, 4)) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::binary_search[color ff0000]
+
+### 出力
+```
+found
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm/ranges_equal_range.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
new file mode 100644
index 000000000..7e3f762e6
--- /dev/null
+++ b/reference/algorithm/ranges_equal_range.md
@@ -0,0 +1,97 @@
+# equal_range
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; equal_range(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; equal_range(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* subrange[link /reference/ranges/subrange.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+
+## 概要
+指定した値と等しい範囲を取得する。
+
+## 要件
+`[first,last)` の要素 `e` は `e &amp;lt; value` および `!(value &amp;lt; e)` 、あるいは `comp(e, value)` および `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。
+
+また、`[first, last)` の要素 `e` は全て暗黙に、`e &amp;lt; value` が `!(value &amp;lt; e)` または `comp(e, value)` が `!comp(value, e)` を意味している必要がある。
+
+
+## 戻り値
+`{`[`ranges::lower_bound`](ranges_lower_bound.md)`(first, last, value, comp, proj), `[`ranges::upper_bound`](ranges_upper_bound.md)`(first, last, value, comp, proj)}`
+
+## 計算量
+最大で 2 * log2(`last - first`) + O(1) 回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v   = {3, 1, 4, 2, 5, 3};
+  std::vector&amp;lt;int&amp;gt; v2  = {1, 4, 2, 5};
+
+  std::ranges::sort(v);
+
+  auto result  = std::ranges::equal_range(v, 3);
+  auto result2 = std::ranges::equal_range(v2, 3);
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; result.size() &amp;lt;&amp;lt; std::endl;
+  for (int i : result) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;size: &amp;#34; &amp;lt;&amp;lt; result2.size() &amp;lt;&amp;lt; std::endl;
+  for (int i : result2) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::sort[link ranges_sort.md]
+* std::ranges::equal_range[color ff0000]
+
+### 出力
+```
+size: 2
+3
+3
+
+size: 0
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
new file mode 100644
index 000000000..78c61d462
--- /dev/null
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -0,0 +1,143 @@
+# lower_bound
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I lower_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; lower_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+指定された要素以上の値が現れる最初の位置のイテレータを取得する。
+
+この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::ranges::equal_range()`](ranges_equal_range.md)関数を使用できる。
+
+
+## 事前条件
+- `[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
+  つまり、`e &amp;lt; value` または `comp(e, value)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
+
+
+## 戻り値
+`[first, last]` 内のイテレータ `i` のうち、以下の条件を満たす、最も右側（`first` から遠い方）のもの
+
+- `[first, i)` 内の全てのイテレータ `j` が `*j &amp;lt; value` または `comp(*j, value) != false` である
+
+（つまり、`value` 以上の要素のうち最初のものを指すイテレータ。`value` 以上の要素が無ければ `last`）
+
+
+## 計算量
+最大で log2(`last - first`) + O(1) 回の比較を行う
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct X {
+  int id;
+  std::string name;
+};
+
+int main()
+{
+  // この関数単体としての使い方
+  {
+    // lower_bound で 4 以上の要素の位置を検索する場合、
+    // 4 より小さい物と 4 以上の物がその順に並んでいれば、
+    // 必ずしもソートされている必要はない。
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+
+    // 4以上の要素を二分探索で検索
+    auto it = std::ranges::lower_bound(v, 4);
+    if (it != v.end()) {
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // 基本的な用途
+  // ソート済み範囲から、特定の値を二分探索で見つける
+  {
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+    std::ranges::sort(v);
+
+    // 二分探索で値4を検索
+    auto it = std::ranges::lower_bound(v, 4);
+    if (it != v.end() &amp;amp;&amp;amp; *it == 4) { // lower_boundでは4&amp;#34;以上&amp;#34;の値が見つかるので、
+                                     // 値4を見つけたいなら検索結果の値を比較する必要がある
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // 要素の一部の値を比較して見つける
+  {
+    // 要素は複数のメンバ変数をもつ
+    std::vector&amp;lt;X&amp;gt; v = {
+      {1, &amp;#34;Carol&amp;#34;},
+      {3, &amp;#34;Alice&amp;#34;},
+      {4, &amp;#34;Bob&amp;#34;},
+      {5, &amp;#34;Eve&amp;#34;},
+      {6, &amp;#34;Dave&amp;#34;}
+    };
+
+    const std::string key = &amp;#34;Bob&amp;#34;;
+
+    // X::nameメンバ変数をキーにして、
+    // X::name == &amp;#34;Bob&amp;#34;となる要素を二分探索で見つける
+    auto it = std::ranges::lower_bound(v, key, {}, &amp;amp;X::name);
+
+    if (it != v.end() &amp;amp;&amp;amp; it-&amp;gt;name == key) {
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id
+                &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;name
+                &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos
+                &amp;lt;&amp;lt; std::endl;
+    }
+  }
+}
+```
+* std::ranges::sort[link ranges_sort.md]
+* std::ranges::distance[link /reference/iterator/ranges_distance.md]
+* std::ranges::lower_bound[color ff0000]
+
+### 出力
+```
+4 pos=2
+4 pos=2
+id=4 name=Bob pos=2
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- 二分探索系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_upper_bound.html"/>
      <id>2c4b28ad57e07d8ad89bc2328b3d7d378d032454:reference/algorithm/ranges_upper_bound.md</id>
      <updated>2022-03-20T09:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_upper_bound.md b/reference/algorithm/ranges_upper_bound.md
new file mode 100644
index 000000000..775b27972
--- /dev/null
+++ b/reference/algorithm/ranges_upper_bound.md
@@ -0,0 +1,130 @@
+# upper_bound
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I upper_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; upper_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+指定された要素より大きい値が現れる最初の位置のイテレータを取得する
+
+
+## 事前条件
+- `[first,last)` の要素 `e` は `!(value &amp;lt; e)` または `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。  
+  つまり、`!(value &amp;lt; e)` または `!comp(value, e)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
+
+
+## 戻り値
+`[first, last]` 内のイテレータ `i` のうち、以下の条件を満たす、最も右側（`first` から遠い方）のもの。
+
+- `[first, i)` 内の全てのイテレータ `j` が `!(value &amp;lt; *j)` または `comp(value, *j) == false` である。
+
+（つまり、`value` より大きい要素のうち最初のものを指すイテレータ。`value` より大きい要素が無ければ `last`）
+
+
+## 計算量
+最大で log2(`last - first`) + O(1) 回の比較を行う
+
+
+## 備考
+- 本関数は、本質的に C++11 で追加された [`partition_point`](partition_point.md) と等価である。  
+	具体的には、[`partition_point`](partition_point.md)`(first, last, [value](const T&amp;amp; e) { return !bool(value &amp;lt; e); })`、あるいは、[`partition_point`](partition_point.md)`(first, last, [value, comp](const T&amp;amp; e) { return !bool(comp(value, e)); })` とすることで等価の結果が得られる。
+- 本関数の要件は、上記の通り C++03 までの方が C++11 よりも厳しい。  
+	しかし、本アルゴリズムの特性上、処理系が C++03 までにしか準拠していない場合でも、昇順に並んでいなくても正常に動作する可能性は高いものと思われる。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+struct X {
+  int key;    // プライマリキー
+  int value;  // 補助的な値
+};
+
+void push_stable(std::vector&amp;lt;X&amp;gt;&amp;amp; queue, X elem)
+{
+  // 挿入対象の値 elem よりも大きい要素の位置、すなわち
+  // elem と同値な要素グループの次の位置を検索する。
+  auto it = std::ranges::upper_bound(queue, elem.key, {}, &amp;amp;X::key);
+  queue.insert(it, elem);
+}
+
+
+int main()
+{
+  // この関数単体としての使い方
+  {
+    // upper_bound で 3 より大きい要素の位置を検索する場合、
+    // 3 以下の物と 3 より大きい物がその順に並んでいれば、
+    // 必ずしもソートされている必要はない。
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+
+    // 3より大きい要素を二分探索で検索
+    auto it = std::ranges::upper_bound(v, 3);
+    std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 応用例：安定順序・優先順位付きキューの実装
+  {
+    std::vector&amp;lt;X&amp;gt; queue;
+    push_stable(queue, {100, 1});
+    push_stable(queue, {200, 1});
+    push_stable(queue, {300, 1});
+    push_stable(queue, {300, 2});
+    push_stable(queue, {200, 2});
+    push_stable(queue, {100, 2});
+
+    // プライマリキー key は同値だが異なる値 value を持つ要素間では
+    // キュー queue への要素挿入順序が維持されている。
+    // （std::priority_queue クラスでは挿入順序は保持されない。）
+    for (const auto&amp;amp; e: queue) {
+      std::cout &amp;lt;&amp;lt; e.key &amp;lt;&amp;lt; &amp;#39;:&amp;#39; &amp;lt;&amp;lt; e.value &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+    }
+    std::cout &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::upper_bound[color ff0000]
+
+
+### 出力
+```
+4
+100:1 100:2 200:1 200:2 300:1 300:2
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges_lower_bound.md -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>7e37e927e5986b12e46fe6885c677c7cf4f80bd5:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2022-03-20T09:34:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
deleted file mode 100644
index 78c61d462..000000000
--- a/reference/algorithm/ranges_lower_bound.md
+++ /dev/null
@@ -1,143 +0,0 @@
-# lower_bound
-* algorithm[meta header]
-* std::ranges[meta namespace]
-* function template[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I lower_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; lower_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-}
-```
-* forward_iterator[link /reference/iterator/forward_iterator.md]
-* sentinel_for[link /reference/iterator/sentinel_for.md]
-* ranges::less[link /reference/functional/ranges_less.md]
-* identity[link /reference/functional/identity.md]
-* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
-* projected[link /reference/iterator/projected.md]
-* forward_range[link /reference/ranges/forward_range.md]
-* iterator_t[link /reference/ranges/iterator_t.md]
-* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
-
-## 概要
-指定された要素以上の値が現れる最初の位置のイテレータを取得する。
-
-この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::ranges::equal_range()`](ranges_equal_range.md)関数を使用できる。
-
-
-## 事前条件
-- `[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
-  つまり、`e &amp;lt; value` または `comp(e, value)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
-
-
-## 戻り値
-`[first, last]` 内のイテレータ `i` のうち、以下の条件を満たす、最も右側（`first` から遠い方）のもの
-
-- `[first, i)` 内の全てのイテレータ `j` が `*j &amp;lt; value` または `comp(*j, value) != false` である
-
-（つまり、`value` 以上の要素のうち最初のものを指すイテレータ。`value` 以上の要素が無ければ `last`）
-
-
-## 計算量
-最大で log2(`last - first`) + O(1) 回の比較を行う
-
-## 例
-```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;algorithm&amp;gt;
-#include &amp;lt;vector&amp;gt;
-#include &amp;lt;string&amp;gt;
-
-struct X {
-  int id;
-  std::string name;
-};
-
-int main()
-{
-  // この関数単体としての使い方
-  {
-    // lower_bound で 4 以上の要素の位置を検索する場合、
-    // 4 より小さい物と 4 以上の物がその順に並んでいれば、
-    // 必ずしもソートされている必要はない。
-    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
-
-    // 4以上の要素を二分探索で検索
-    auto it = std::ranges::lower_bound(v, 4);
-    if (it != v.end()) {
-      std::size_t pos = std::ranges::distance(v.begin(), it);
-      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
-    }
-  }
-
-  // 基本的な用途
-  // ソート済み範囲から、特定の値を二分探索で見つける
-  {
-    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
-    std::ranges::sort(v);
-
-    // 二分探索で値4を検索
-    auto it = std::ranges::lower_bound(v, 4);
-    if (it != v.end() &amp;amp;&amp;amp; *it == 4) { // lower_boundでは4&amp;#34;以上&amp;#34;の値が見つかるので、
-                                     // 値4を見つけたいなら検索結果の値を比較する必要がある
-      std::size_t pos = std::ranges::distance(v.begin(), it);
-      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
-    }
-  }
-
-  // 要素の一部の値を比較して見つける
-  {
-    // 要素は複数のメンバ変数をもつ
-    std::vector&amp;lt;X&amp;gt; v = {
-      {1, &amp;#34;Carol&amp;#34;},
-      {3, &amp;#34;Alice&amp;#34;},
-      {4, &amp;#34;Bob&amp;#34;},
-      {5, &amp;#34;Eve&amp;#34;},
-      {6, &amp;#34;Dave&amp;#34;}
-    };
-
-    const std::string key = &amp;#34;Bob&amp;#34;;
-
-    // X::nameメンバ変数をキーにして、
-    // X::name == &amp;#34;Bob&amp;#34;となる要素を二分探索で見つける
-    auto it = std::ranges::lower_bound(v, key, {}, &amp;amp;X::name);
-
-    if (it != v.end() &amp;amp;&amp;amp; it-&amp;gt;name == key) {
-      std::size_t pos = std::ranges::distance(v.begin(), it);
-      std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id
-                &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;name
-                &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos
-                &amp;lt;&amp;lt; std::endl;
-    }
-  }
-}
-```
-* std::ranges::sort[link ranges_sort.md]
-* std::ranges::distance[link /reference/iterator/ranges_distance.md]
-* std::ranges::lower_bound[color ff0000]
-
-### 出力
-```
-4 pos=2
-4 pos=2
-id=4 name=Bob pos=2
-```
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): 10.1.0
-- [ICC](/implementation.md#icc): ??
-- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
-
-## 参照
-- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges_max_element.md -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>7e37e927e5986b12e46fe6885c677c7cf4f80bd5:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-03-20T09:34:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
deleted file mode 100644
index ed9768a1f..000000000
--- a/reference/algorithm/ranges_max_element.md
+++ /dev/null
@@ -1,126 +0,0 @@
-# max_element
-* algorithm[meta header]
-* std::ranges[meta namespace]
-* function template[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-namespace std {
-  template&amp;lt;class ForwardIterator&amp;gt;
-  ForwardIterator
-    max_element(ForwardIterator first,
-                ForwardIterator last); // (1) C++03
-
-  template&amp;lt;class ForwardIterator, class Compare&amp;gt;
-  ForwardIterator
-    max_element(ForwardIterator first,
-                ForwardIterator last,
-                Compare comp);         // (2) C++03
-
-  template &amp;lt;class ExecutionPolicy, class ForwardIterator&amp;gt;
-  ForwardIterator
-    max_element(ExecutionPolicy&amp;amp;&amp;amp; exec,
-                ForwardIterator first,
-                ForwardIterator last); // (3) C++17
-
-  template &amp;lt;class ExecutionPolicy, class ForwardIterator, class Compare&amp;gt;
-  ForwardIterator
-    max_element(ExecutionPolicy&amp;amp;&amp;amp; exec,
-                ForwardIterator first,
-                ForwardIterator last,
-                Compare comp);         // (4) C++17
-}
-```
-
-## 概要
-`[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
-
-
-
-## 戻り値
-`*j &amp;lt; *i`もしくは`comp(*j, *i)`の比較によって最大と判断された最初の要素を指すイテレータ
-
-
-## 計算量
-[`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
-
-
-## 例
-```cpp example
-#include &amp;lt;algorithm&amp;gt;
-#include &amp;lt;cassert&amp;gt;
-#include &amp;lt;utility&amp;gt;
-#include &amp;lt;vector&amp;gt;
-
-int main()
-{
-  // (1)
-  std::vector&amp;lt;int&amp;gt; v1 = {3, 1, 4};
-
-  decltype(v1)::iterator v1_max_element = std::max_element(v1.begin(), v1.end());
-  assert(*v1_max_element == 4);
-
-
-  // (2)
-  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; v2 = {{0, 3}, {1, 1}, {2, 4}};
-
-  decltype(v2)::iterator v2_max_element = std::max_element(v2.begin(), v2.end(), [](const auto&amp;amp; a, const auto&amp;amp; b) {
-    return a.second &amp;lt; b.second;
-  });
-  assert(v2_max_element-&amp;gt;first == 2);
-  assert(v2_max_element-&amp;gt;second == 4);
-}
-```
-* std::max_element[color ff0000]
-
-### 出力
-```
-```
-
-
-## 実装例
-```cpp
-template &amp;lt;class ForwardIterator&amp;gt;
-ForwardIterator max_element(ForwardIterator first, ForwardIterator last)
-{
-  if (first == last)
-    return first;
-
-  ForwardIterator result = first++;
-  for (; first != last; ++first) {
-    if (*result &amp;lt; *first) {
-      result = first;
-    }
-  }
-  return result;
-}
-
-template &amp;lt;class ForwardIterator, class Compare&amp;gt;
-ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp)
-{
-  if (first == last)
-    return first;
-
-  ForwardIterator result = first++;
-  for (; first != last; ++first) {
-    if (comp(*result, *first)) {
-      result = first;
-    }
-  }
-  return result;
-}
-```
-
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): 10.1.0
-- [ICC](/implementation.md#icc): ??
-- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
-
-## 参照
-- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
new file mode 100644
index 000000000..78c61d462
--- /dev/null
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -0,0 +1,143 @@
+# lower_bound
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I lower_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Proj = identity,
+           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; lower_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+指定された要素以上の値が現れる最初の位置のイテレータを取得する。
+
+この関数の用途としては、ソート済み範囲に対して、任意の値を二分探索で見つけるために使用できる。[`std::multiset`](/reference/set/multiset.md)のように同じキーを持つ要素が複数あり、その全てを列挙したい場合にはこの関数の代わりに[`std::ranges::equal_range()`](ranges_equal_range.md)関数を使用できる。
+
+
+## 事前条件
+- `[first,last)` の要素 `e` は `e &amp;lt; value` または `comp(e, value)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。
+  つまり、`e &amp;lt; value` または `comp(e, value)` が `true` となる全ての要素 `e` は、`false` となる全ての要素よりも左側（`first` に近い方）になければならない。
+
+
+## 戻り値
+`[first, last]` 内のイテレータ `i` のうち、以下の条件を満たす、最も右側（`first` から遠い方）のもの
+
+- `[first, i)` 内の全てのイテレータ `j` が `*j &amp;lt; value` または `comp(*j, value) != false` である
+
+（つまり、`value` 以上の要素のうち最初のものを指すイテレータ。`value` 以上の要素が無ければ `last`）
+
+
+## 計算量
+最大で log2(`last - first`) + O(1) 回の比較を行う
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct X {
+  int id;
+  std::string name;
+};
+
+int main()
+{
+  // この関数単体としての使い方
+  {
+    // lower_bound で 4 以上の要素の位置を検索する場合、
+    // 4 より小さい物と 4 以上の物がその順に並んでいれば、
+    // 必ずしもソートされている必要はない。
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+
+    // 4以上の要素を二分探索で検索
+    auto it = std::ranges::lower_bound(v, 4);
+    if (it != v.end()) {
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // 基本的な用途
+  // ソート済み範囲から、特定の値を二分探索で見つける
+  {
+    std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 6, 5};
+    std::ranges::sort(v);
+
+    // 二分探索で値4を検索
+    auto it = std::ranges::lower_bound(v, 4);
+    if (it != v.end() &amp;amp;&amp;amp; *it == 4) { // lower_boundでは4&amp;#34;以上&amp;#34;の値が見つかるので、
+                                     // 値4を見つけたいなら検索結果の値を比較する必要がある
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // 要素の一部の値を比較して見つける
+  {
+    // 要素は複数のメンバ変数をもつ
+    std::vector&amp;lt;X&amp;gt; v = {
+      {1, &amp;#34;Carol&amp;#34;},
+      {3, &amp;#34;Alice&amp;#34;},
+      {4, &amp;#34;Bob&amp;#34;},
+      {5, &amp;#34;Eve&amp;#34;},
+      {6, &amp;#34;Dave&amp;#34;}
+    };
+
+    const std::string key = &amp;#34;Bob&amp;#34;;
+
+    // X::nameメンバ変数をキーにして、
+    // X::name == &amp;#34;Bob&amp;#34;となる要素を二分探索で見つける
+    auto it = std::ranges::lower_bound(v, key, {}, &amp;amp;X::name);
+
+    if (it != v.end() &amp;amp;&amp;amp; it-&amp;gt;name == key) {
+      std::size_t pos = std::ranges::distance(v.begin(), it);
+      std::cout &amp;lt;&amp;lt; &amp;#34;id=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id
+                &amp;lt;&amp;lt; &amp;#34; name=&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;name
+                &amp;lt;&amp;lt; &amp;#34; pos=&amp;#34; &amp;lt;&amp;lt; pos
+                &amp;lt;&amp;lt; std::endl;
+    }
+  }
+}
+```
+* std::ranges::sort[link ranges_sort.md]
+* std::ranges::distance[link /reference/iterator/ranges_distance.md]
+* std::ranges::lower_bound[color ff0000]
+
+### 出力
+```
+4 pos=2
+4 pos=2
+id=4 name=Bob pos=2
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
new file mode 100644
index 000000000..ed9768a1f
--- /dev/null
+++ b/reference/algorithm/ranges_max_element.md
@@ -0,0 +1,126 @@
+# max_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class ForwardIterator&amp;gt;
+  ForwardIterator
+    max_element(ForwardIterator first,
+                ForwardIterator last); // (1) C++03
+
+  template&amp;lt;class ForwardIterator, class Compare&amp;gt;
+  ForwardIterator
+    max_element(ForwardIterator first,
+                ForwardIterator last,
+                Compare comp);         // (2) C++03
+
+  template &amp;lt;class ExecutionPolicy, class ForwardIterator&amp;gt;
+  ForwardIterator
+    max_element(ExecutionPolicy&amp;amp;&amp;amp; exec,
+                ForwardIterator first,
+                ForwardIterator last); // (3) C++17
+
+  template &amp;lt;class ExecutionPolicy, class ForwardIterator, class Compare&amp;gt;
+  ForwardIterator
+    max_element(ExecutionPolicy&amp;amp;&amp;amp; exec,
+                ForwardIterator first,
+                ForwardIterator last,
+                Compare comp);         // (4) C++17
+}
+```
+
+## 概要
+`[first, last)`の範囲において、最大要素を指す最初のイテレータを取得する。
+
+
+
+## 戻り値
+`*j &amp;lt; *i`もしくは`comp(*j, *i)`の比較によって最大と判断された最初の要素を指すイテレータ
+
+
+## 計算量
+[`max`](max.md)`((last - first) - 1, 0)`回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;utility&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  // (1)
+  std::vector&amp;lt;int&amp;gt; v1 = {3, 1, 4};
+
+  decltype(v1)::iterator v1_max_element = std::max_element(v1.begin(), v1.end());
+  assert(*v1_max_element == 4);
+
+
+  // (2)
+  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; v2 = {{0, 3}, {1, 1}, {2, 4}};
+
+  decltype(v2)::iterator v2_max_element = std::max_element(v2.begin(), v2.end(), [](const auto&amp;amp; a, const auto&amp;amp; b) {
+    return a.second &amp;lt; b.second;
+  });
+  assert(v2_max_element-&amp;gt;first == 2);
+  assert(v2_max_element-&amp;gt;second == 4);
+}
+```
+* std::max_element[color ff0000]
+
+### 出力
+```
+```
+
+
+## 実装例
+```cpp
+template &amp;lt;class ForwardIterator&amp;gt;
+ForwardIterator max_element(ForwardIterator first, ForwardIterator last)
+{
+  if (first == last)
+    return first;
+
+  ForwardIterator result = first++;
+  for (; first != last; ++first) {
+    if (*result &amp;lt; *first) {
+      result = first;
+    }
+  }
+  return result;
+}
+
+template &amp;lt;class ForwardIterator, class Compare&amp;gt;
+ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp)
+{
+  if (first == last)
+    return first;
+
+  ForwardIterator result = first++;
+  for (; first != last; ++first) {
+    if (comp(*result, *first)) {
+      result = first;
+    }
+  }
+  return result;
+}
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_nth_element.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
index df997c8e7..e44cb9b34 100644
--- a/reference/algorithm/ranges_nth_element.md
+++ b/reference/algorithm/ranges_nth_element.md
@@ -21,8 +21,8 @@ namespace std::ranges {
 * identity[link /reference/functional/identity.md]
 * sortable[link /reference/iterator/sortable.md]
 * random_access_range[link /reference/ranges/random_access_range.md]
-* iterator_t[link /reference/iterator/iterator_t.md]
-* borrowed_iterator_t[link /reference/iterator/borrowed_iterator_t.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index 6cec98e4c..07cd26fd8 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -21,8 +21,8 @@ namespace std::ranges {
 * identity[link /reference/functional/identity.md]
 * sortable[link /reference/iterator/sortable.md]
 * random_access_range[link /reference/ranges/random_access_range.md]
-* iterator_t[link /reference/iterator/iterator_t.md]
-* borrowed_iterator_t[link /reference/iterator/borrowed_iterator_t.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges_partition_copy.md -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>7f4b38b5a6f53c0f6423faacce3880df0158dc53:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2022-03-20T09:23:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
deleted file mode 100644
index 2dc175e2c..000000000
--- a/reference/algorithm/ranges_partition_copy.md
+++ /dev/null
@@ -1,125 +0,0 @@
-# partition_copy
-* algorithm[meta header]
-* std::ranges[meta namespace]
-* function template[meta id-type]
-* cpp20[meta cpp]
-* cpp11[meta cpp]
-
-```cpp
-namespace std {
-  template &amp;lt;class InputIterator,
-            class OutputIterator1,
-            class OutputIterator2,
-            class Predicate&amp;gt;
-  pair&amp;lt;OutputIterator1, OutputIterator2&amp;gt;
-    partition_copy(InputIterator first,
-                   InputIterator last,
-                   OutputIterator1 out_true,
-                   OutputIterator2 out_false,
-                   Predicate pred);            // (1) C++11
-
-  template &amp;lt;class InputIterator,
-            class OutputIterator1,
-            class OutputIterator2,
-            class Predicate&amp;gt;
-  constexpr pair&amp;lt;OutputIterator1, OutputIterator2&amp;gt;
-    partition_copy(InputIterator first,
-                   InputIterator last,
-                   OutputIterator1 out_true,
-                   OutputIterator2 out_false,
-                   Predicate pred);            // (1) C++20
-
-  template &amp;lt;class ExecutionPolicy,
-            class ForwardIterator,
-            class ForwardIterator1,
-            class ForwardIterator2,
-            class Predicate&amp;gt;
-  pair&amp;lt;ForwardIterator1, ForwardIterator2&amp;gt;
-    partition_copy(ExecutionPolicy&amp;amp;&amp;amp; exec,
-                   ForwardIterator first,
-                   ForwardIterator last,
-                   ForwardIterator1 out_true,
-                   ForwardIterator2 out_false,
-                   Predicate pred);            // (2) C++17
-}
-```
-* pair[link /reference/utility/pair.md]
-
-## 概要
-与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする。
-
-
-## 要件
-- `InputIterator` の value type は `Assignable` で、`out_true` と `out_false` の `OutputIterator` へ書き込み可能で、`Predicate` の argument type へ変換可能でなければならない。
-- 入力範囲は出力範囲のどちらとも重なっていてはならない。
-
-
-## 効果
-`[first,last)` 内にあるそれぞれのイテレータ `i` について、`pred(*i)` が `true` なら `*i` を `out_true` へコピーし、そうでない場合は `out_false` へコピーする。
-
-
-## 戻り値
-`first` には `out_true` の終端が、`second` には `out_false` の終端が格納された[`pair`](/reference/utility/pair.md)オブジェクトを返す。
-
-
-## 計算量
-正確に `last - first` 回述語が適用される。
-
-
-## 例
-```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;vector&amp;gt;
-#include &amp;lt;algorithm&amp;gt;
-#include &amp;lt;iterator&amp;gt;
-#include &amp;lt;string&amp;gt;
-
-void print(const std::string&amp;amp; name, const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
-{
-  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; : &amp;#34;;
-  std::for_each(v.begin(), v.end(), [](int x) {
-    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;,&amp;#34;;
-  });
-  std::cout &amp;lt;&amp;lt; std::endl;
-}
-
-bool is_even(int x) { return x % 2 == 0; }
-
-int main()
-{
-  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
-
-  // 偶数グループと奇数グループに分ける
-  std::vector&amp;lt;int&amp;gt; evens;
-  std::vector&amp;lt;int&amp;gt; odds;
-  std::partition_copy(v.begin(), v.end(),
-                      std::back_inserter(evens),
-                      std::back_inserter(odds),
-                      is_even);
-
-  print(&amp;#34;v&amp;#34;, v);
-  print(&amp;#34;evens&amp;#34;, evens);
-  print(&amp;#34;odds&amp;#34;, odds);
-}
-```
-* std::partition_copy[color ff0000]
-
-### 出力
-```
-v : 1,2,3,4,5,
-evens : 2,4,
-odds : 1,3,5,
-```
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): 10.1.0
-- [ICC](/implementation.md#icc): ??
-- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
-
-## 参照
-- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::nth_elementの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>f5ca01f77ff7ec3dd1d619d0c3309214bbb68421:reference/algorithm.md</id>
      <updated>2022-03-20T08:10:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 8949fa970..1ac82501f 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -286,7 +286,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------|----------------------------------------------------------|-------|
 | [`nth_element`](algorithm/nth_element.md) | 基準となる要素よりも小さい要素が、前に来るよう並べ替える | |
-| [`ranges::nth_element`](algorithm/ranges_nth_element.md.nolink) | 基準となる要素よりも小さい要素が、前に来るよう並べ替える | C++20 |
+| [`ranges::nth_element`](algorithm/ranges_nth_element.md) | 基準となる要素よりも小さい要素が、前に来るよう並べ替える | C++20 |
 
 
 ### &amp;lt;a id=&amp;#34;alg.binary.search&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;二分探索
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nth_element -- ranges::nth_elementの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_nth_element.html"/>
      <id>f5ca01f77ff7ec3dd1d619d0c3309214bbb68421:reference/algorithm/ranges_nth_element.md</id>
      <updated>2022-03-20T08:10:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_nth_element.md b/reference/algorithm/ranges_nth_element.md
new file mode 100644
index 000000000..df997c8e7
--- /dev/null
+++ b/reference/algorithm/ranges_nth_element.md
@@ -0,0 +1,90 @@
+# nth_element
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr I nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; nth_element(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; nth, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/iterator/iterator_t.md]
+* borrowed_iterator_t[link /reference/iterator/borrowed_iterator_t.md]
+
+
+## 概要
+基準となる要素よりも小さい要素が前に来るよう並べ替える。
+
+この関数は範囲 `[first,last)` の並び替えを行うが、基準位置 `nth` のみが正しい要素、つまり仮に範囲 `[first,last)` 全体を並び替えた際に`nth`に位置すべき要素となる。前半の範囲 `[first,nth)` は関数呼び出し後の位置 `nth` にある要素よりも小さいことは保証されるが、その範囲 `[first,nth)` 内での要素並び順はなんら保証されない。
+
+ある範囲に対して部分的な並び替えを行う場合、[`partial_sort()`](partial_sort.md)を使用する。また範囲全体に対して並び替えを行う場合、[`sort()`](sort.md)を使用する。
+
+## 効果
+`nth_element()` を呼び出した後、`nth` が指している位置の要素は、全ての範囲がソートされた場合の位置にある要素になる。そして、`[first,nth)` にあるイテレータ `i` と、`[nth,last)` にあるイテレータ `j` について、`!(*j &amp;lt; *i)` または `comp(*j, *i) == false` になる。
+
+
+## 戻り値
+`last`
+
+
+## 計算量
+平均で線形時間
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {5, 10, 4, 7, 1, 9, 8, 6, 2};
+
+  // 4番目に小さい値より小さい値を前に集める
+  std::ranges::nth_element(v, v.begin() + 3);
+
+  for (int i : v) {
+    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::nth_element[color ff0000]
+
+### 出力例
+```
+2
+1
+4
+5
+7
+6
+8
+9
+10
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort -- Range版を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort.html"/>
      <id>16973ba34d98191e0903aa167c948eb04a6064c4:reference/algorithm/ranges_partial_sort.md</id>
      <updated>2022-03-20T08:06:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort.md b/reference/algorithm/ranges_partial_sort.md
index 6ea70e671..6cec98e4c 100644
--- a/reference/algorithm/ranges_partial_sort.md
+++ b/reference/algorithm/ranges_partial_sort.md
@@ -9,6 +9,10 @@ namespace std::ranges {
   template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
   constexpr I partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; partial_sort(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, Comp comp = {}, Proj proj = {});
 }
 ```
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
@@ -16,6 +20,9 @@ namespace std::ranges {
 * ranges::less[link /reference/functional/ranges_less.md]
 * identity[link /reference/functional/identity.md]
 * sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/iterator/iterator_t.md]
+* borrowed_iterator_t[link /reference/iterator/borrowed_iterator_t.md]
 
 
 ## 概要
@@ -47,7 +54,7 @@ int main()
   std::vector&amp;lt;int&amp;gt; v = {3, 1, 4, 2, 5};
 
   // 先頭2要素を並んだ状態にする
-  std::ranges::partial_sort(v.begin(), v.begin() + 2, v.end());
+  std::ranges::partial_sort(v, v.begin() + 2);
 
   for (int i : v) {
     std::cout &amp;lt;&amp;lt; i;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>