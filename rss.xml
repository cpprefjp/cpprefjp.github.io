<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-12T03:05:09.483416</updated>
  <id>10de0e37-c0b3-414e-837e-6f0913cd2cfd</id>

  
    <entry>
      <title>apply -- apply : オーバーロードに番号をつけた</title>
      <link href="https://cpprefjp.github.io/reference/tuple/apply.html"/>
      <id>a73f34d4e7f371a8d311d7c539471422fbeebc90:reference/tuple/apply.md</id>
      <updated>2023-01-12T12:00:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/apply.md b/reference/tuple/apply.md
index f59d632a3..77d6e1845 100644
--- a/reference/tuple/apply.md
+++ b/reference/tuple/apply.md
@@ -7,10 +7,12 @@
 ```cpp
 namespace std {
   template&amp;lt;class F, class Tuple&amp;gt;
-  constexpr decltype(auto) apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t);  // C++20まで
+  constexpr decltype(auto)
+    apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t);                     // (1) C++20
 
   template&amp;lt;class F, class Tuple&amp;gt;
-  constexpr decltype(auto) apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t) noexcept(see below);  // C++23から
+  constexpr decltype(auto)
+    apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t) noexcept(see below); // (1) C++23
 }
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>apply -- apply : fix typo</title>
      <link href="https://cpprefjp.github.io/reference/tuple/apply.html"/>
      <id>b66903af7aae0c27ac7f4bf5ea730cb11c731609:reference/tuple/apply.md</id>
      <updated>2023-01-12T12:00:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/apply.md b/reference/tuple/apply.md
index fdc9db56f..f59d632a3 100644
--- a/reference/tuple/apply.md
+++ b/reference/tuple/apply.md
@@ -109,4 +109,4 @@ hello
 - [P0220R1 Adopt Library Fundamentals V1 TS Components for C++17 (R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html)
 - [C++1z タプルを展開して関数呼び出しするapply関数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/08/18/184315)
 - [P2517R1 Add a conditional `noexcept` specification to `std::apply`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2517r1.html)
-    - C++23から条件付きで`noexpcet`例外指定が行われる。
+    - C++23から条件付きで`noexcept`例外指定が行われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generator -- generator: 概要説明を修正</title>
      <link href="https://cpprefjp.github.io/reference/generator/generator.html"/>
      <id>58e407c377e144d14665e1825e9b208767c443cc:reference/generator/generator.md</id>
      <updated>2023-01-12T09:44:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/generator/generator.md b/reference/generator/generator.md
index 4335cf0b2..d49ca96d7 100644
--- a/reference/generator/generator.md
+++ b/reference/generator/generator.md
@@ -22,8 +22,10 @@ namespace std {
 戻り値型`generator`のコルーチン（以下、ジェネレータコルーチン）では`co_yield`式を用いて値を生成する。`co_yield` [`std::ranges::elements_of`](/reference/ranges/elements_of.md)`(rng)`式を用いると、ジェネレータコルーチンから入れ子Range(`rng`)の各要素を逐次生成する。
 ジェネレータコルーチンでは`co_await`式を利用できない。
 
-ジェネレータコルーチンは遅延評価される。ジェネレータコルーチンが返す`generator`オブジェクトを利用するコード（以下、ジェネレータ利用側）で先頭要素[`begin`](generator/begin.md)を指す[イテレータ](generator/iterator.md)を間接参照するまで、ジェネレータコルーチンの本体処理は実行されない。
-ジェネレータ利用側がイテレータの間接参照を試みるとジェネレータコルーチンを再開(resume)し、ジェネレータコルーチン本体処理において`co_yield`式に到達すると生成値を保持して再び中断(suspend)する。ジェネレータ利用側ではイテレータの間接参照の結果として生成値を取得する。
+ジェネレータコルーチンは遅延評価される。
+ジェネレータコルーチンが返す`generator`オブジェクトを利用するコード（以下、ジェネレータ利用側）において、先頭要素を指す[イテレータ](generator/iterator.md)を取得する([`begin`](generator/begin.md))、またはイテレータのインクリメント操作を行う(`operator++`)までジェネレータコルーチンは再開(resume)されない。
+ジェネレータコルーチン本体処理において`co_yield`式に到達すると、生成値を保持してから中断(suspend)しジェネレータ利用側へと制御を戻す。
+ジェネレータ利用側ではイテレータの間接参照(単項`operator*`)を行うことで、ジェネレータによる生成値を取得する。
 
 
 ### 説明用メンバ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>apply -- tuple/apply: P2517R1対応(#1098)</title>
      <link href="https://cpprefjp.github.io/reference/tuple/apply.html"/>
      <id>f03abf873882732606460f6f65aaed739389d8d0:reference/tuple/apply.md</id>
      <updated>2023-01-11T18:22:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/apply.md b/reference/tuple/apply.md
index 6332df41c..fdc9db56f 100644
--- a/reference/tuple/apply.md
+++ b/reference/tuple/apply.md
@@ -7,7 +7,10 @@
 ```cpp
 namespace std {
   template&amp;lt;class F, class Tuple&amp;gt;
-  constexpr decltype(auto) apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t);
+  constexpr decltype(auto) apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t);  // C++20まで
+
+  template&amp;lt;class F, class Tuple&amp;gt;
+  constexpr decltype(auto) apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t) noexcept(see below);  // C++23から
 }
 ```
 
@@ -16,7 +19,7 @@ namespace std {
 
 
 ## 要件
-適用先の関数は[`Callable`](/reference/concepts/Callable.md)要件を満たす（[INVOKE](/reference/concepts/Invoke.md)操作が可能）。展開されるものは、[`std::tuple`](../tuple.md)、[`std::array`](/reference/array/array.md)または[`std::pair`](/reference/utility/pair.md)のように、[`std::get`](/reference/array/array/get.md)と[`std::tuple_size`](/reference/array/array/tuple_size.md)をサポートする必要がある。
+適用先の関数は[`Callable`](/reference/concepts/Callable.md)要件を満たす（[INVOKE](/reference/concepts/Invoke.md)操作が可能）。展開される`Tuple`型は[`std::tuple`](../tuple.md)に限定されず、[`std::array`](/reference/array/array.md)または[`std::pair`](/reference/utility/pair.md)のように、[`std::get`](/reference/array/array/get.md)と[`std::tuple_size`](/reference/array/array/tuple_size.md)をサポートする型であればよい。
 
 
 ## 効果
@@ -28,6 +31,7 @@ constexpr decltype(auto) apply-impl(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t, std::index_sequence&amp;lt;I...&amp;gt;)
   return std::invoke(std::forward&amp;lt;F&amp;gt;(f), std::get&amp;lt;I&amp;gt;(std::forward&amp;lt;Tuple&amp;gt;(t))...);
 }
 ```
+* std::get[link tuple/get.md]
 * std::index_sequence[link /reference/utility/index_sequence.md]
 * std::invoke[link /reference/functional/invoke.md]
 * std::forward[link /reference/utility/forward.md]
@@ -38,11 +42,17 @@ constexpr decltype(auto) apply-impl(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t, std::index_sequence&amp;lt;I...&amp;gt;)
 return apply-impl(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Tuple&amp;gt;(t),
                   std::make_index_sequence&amp;lt;std::tuple_size_v&amp;lt;std::remove_reference_t&amp;lt;Tuple&amp;gt;&amp;gt;&amp;gt;{});
 ```
+* std::tuple_size_v[link tuple_size.md]
 * std::make_index_sequence[link /reference/utility/make_index_sequence.md]
+* std::forward[link /reference/utility/forward.md]
 * std::remove_reference_t[link /reference/type_traits/remove_reference.md]
 
 ## 戻り値
-適用した関数の戻り値である。
+適用した関数呼び出しの戻り値
+
+
+## 例外
+C++23から : `I`をパラメータパック`0, 1, ..., (`[`tuple_size_v`](tuple_size.md)`&amp;lt;`[`remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;Tuple&amp;gt;&amp;gt;-1)`としたとき、例外指定の式は次と等価 : `noexcept(`[`invoke`](/reference/functional/invoke.md)`(std::forward&amp;lt;F&amp;gt;(f), get&amp;lt;I&amp;gt;(std::forward&amp;lt;Tuple&amp;gt;(t))...))`
 
 
 ## 例
@@ -86,7 +96,7 @@ hello
 
 
 ## 関連項目
-- [make_from_tuple](../tuple/make_from_tuple.md)
+- [`make_from_tuple`](make_from_tuple.md)
 - [`std::tuple`](../tuple.md)
 - [INVOKE](/reference/concepts/Invoke.md)
 
@@ -98,3 +108,5 @@ hello
 - [P0220R0 Adopt Library Fundamentals TS for C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r0.html)
 - [P0220R1 Adopt Library Fundamentals V1 TS Components for C++17 (R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html)
 - [C++1z タプルを展開して関数呼び出しするapply関数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/08/18/184315)
+- [P2517R1 Add a conditional `noexcept` specification to `std::apply`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2517r1.html)
+    - C++23から条件付きで`noexpcet`例外指定が行われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>coroutine_handle -- coroutine: LWG3460を反映</title>
      <link href="https://cpprefjp.github.io/reference/coroutine/coroutine_handle.html"/>
      <id>1f03563fee051b3135a3dd7ea79f14bd01b37ad3:reference/coroutine/coroutine_handle.md</id>
      <updated>2023-01-11T17:17:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/coroutine/coroutine_handle.md b/reference/coroutine/coroutine_handle.md
index 21c3dd67a..da8306f0c 100644
--- a/reference/coroutine/coroutine_handle.md
+++ b/reference/coroutine/coroutine_handle.md
@@ -15,7 +15,7 @@ namespace std {
   };
 
   template&amp;lt;class Promise&amp;gt;
-  struct coroutine_handle : coroutine_handle&amp;lt;&amp;gt; {
+  struct coroutine_handle {
     // (メンバ宣言は省略)
   };
 }
@@ -30,7 +30,7 @@ namespace std {
 例: 後述サンプルコードでは`task`クラス内に隠蔽されており、コルーチン`f`や関数`main`から間接的に利用される。
 
 `coroutine_handle&amp;lt;void&amp;gt;`または単に`coroutine_handle&amp;lt;&amp;gt;`は、Promise型について型消去(Type-erased)されたコルーチンハンドルとして取り扱える。
-コルーチンのPromise型を明示した`coroutine_handle&amp;lt;Promise&amp;gt;`は型消去された`coroutine_handle&amp;lt;&amp;gt;`から公開派生されており、前者から後者への暗黙変換を行うことが可能となっている。
+コルーチンのPromise型を明示した`coroutine_handle&amp;lt;Promise&amp;gt;`から`coroutine_handle&amp;lt;&amp;gt;`へと暗黙変換が可能となっている。
 
 C++コルーチンとC API（コールバック関数へのポインタと`void*`をとる関数）との組合せ利用を可能とするため、`coroutine_handle`とポインタ型`void*`との相互変換がサポートされる。
 
@@ -51,6 +51,12 @@ C++コルーチンとC API（コールバック関数へのポインタと`void*
 |-----------------|----------------|----------------|
 | [`address`](coroutine_handle/address.md) | コルーチンハンドルに対応するアドレス値 | C++20 |
 
+### 変換
+
+| 名前            | 説明          | 対応バージョン |
+|-----------------|---------------|----------------|
+| `operator coroutine_handle&amp;lt;&amp;gt;` | 型消去されたコルーチンハンドルを返す | C++20 |
+
 ### 観測
 
 | 名前            | 説明           | 対応バージョン |
@@ -188,3 +194,7 @@ result=42
 
 ## 関連項目
 - [C++20 コルーチン](/lang/cpp20/coroutines.md)
+
+
+## 参照
+- [LWG3460 Unimplementable `noop_coroutine_handle` guarantees](https://cplusplus.github.io/LWG/issue3460)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_promise -- coroutine: LWG3460を反映</title>
      <link href="https://cpprefjp.github.io/reference/coroutine/coroutine_handle/from_promise.html"/>
      <id>1f03563fee051b3135a3dd7ea79f14bd01b37ad3:reference/coroutine/coroutine_handle/from_promise.md</id>
      <updated>2023-01-11T17:17:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/coroutine/coroutine_handle/from_promise.md b/reference/coroutine/coroutine_handle/from_promise.md
index 435c016ff..6b8c9293e 100644
--- a/reference/coroutine/coroutine_handle/from_promise.md
+++ b/reference/coroutine/coroutine_handle/from_promise.md
@@ -25,6 +25,10 @@ Promiseオブジェクトから対応するコルーチンハンドルを取得
 [`addressof`](/reference/memory/addressof.md)`(h.`[`promise()`](promise.md)`) ==` [`addressof`](/reference/memory/addressof.md)`(p)`
 
 
+## 備考
+型消去されたコルーチンハンドル`coroutine_handle&amp;lt;&amp;gt;`では、本メンバ関数は提供されない。
+
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>promise -- coroutine: LWG3460を反映</title>
      <link href="https://cpprefjp.github.io/reference/coroutine/coroutine_handle/promise.html"/>
      <id>1f03563fee051b3135a3dd7ea79f14bd01b37ad3:reference/coroutine/coroutine_handle/promise.md</id>
      <updated>2023-01-11T17:17:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/coroutine/coroutine_handle/promise.md b/reference/coroutine/coroutine_handle/promise.md
index 2d36ee9b0..46057acdc 100644
--- a/reference/coroutine/coroutine_handle/promise.md
+++ b/reference/coroutine/coroutine_handle/promise.md
@@ -21,6 +21,10 @@ Promise&amp;amp; promise() const;
 コルーチンのPromiseオブジェクトへの参照。
 
 
+## 備考
+型消去されたコルーチンハンドル`coroutine_handle&amp;lt;&amp;gt;`では、本メンバ関数は提供されない。
+
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>noop_coroutine_handle -- coroutine: LWG3460を反映</title>
      <link href="https://cpprefjp.github.io/reference/coroutine/noop_coroutine_handle.html"/>
      <id>1f03563fee051b3135a3dd7ea79f14bd01b37ad3:reference/coroutine/noop_coroutine_handle.md</id>
      <updated>2023-01-11T17:17:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/coroutine/noop_coroutine_handle.md b/reference/coroutine/noop_coroutine_handle.md
index e9a3cdd3f..074d574d3 100644
--- a/reference/coroutine/noop_coroutine_handle.md
+++ b/reference/coroutine/noop_coroutine_handle.md
@@ -9,8 +9,10 @@ namespace std {
   struct noop_coroutine_promise {};
 
   template&amp;lt;&amp;gt;
-  struct coroutine_handle&amp;lt;noop_coroutine_promise&amp;gt; : coroutine_handle&amp;lt;&amp;gt;
+  struct coroutine_handle&amp;lt;noop_coroutine_promise&amp;gt;
   {
+    constexpr operator coroutine_handle&amp;lt;&amp;gt;() const noexcept;
+
     constexpr explicit operator bool() const noexcept;
     constexpr bool done() const noexcept;
 
@@ -29,8 +31,7 @@ namespace std {
   using noop_coroutine_handle = coroutine_handle&amp;lt;noop_coroutine_promise&amp;gt;;
 }
 ```
-* coroutine_handle&amp;lt;&amp;gt;[link coroutine_handle.md]
-* coroutine_handle&amp;lt;noop_coroutine_promise&amp;gt;[link coroutine_handle.md]
+* coroutine_handle[link coroutine_handle.md]
 * unspecified[italic]
 
 
@@ -41,6 +42,11 @@ namespace std {
 
 
 ## メンバ関数
+### 変換
+| 名前            | 説明          | 対応バージョン |
+|-----------------|---------------|----------------|
+| `operator coroutine_handle&amp;lt;&amp;gt;` | 型消去されたコルーチンハンドルを返す | C++20 |
+
 ### 観測
 
 | 名前            | 説明          | 対応バージョン |
@@ -87,4 +93,4 @@ namespace std {
 
 ## 参照
 - [P0913R1 Add symmetric coroutine control transfer](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0913r1.html)
-- [LWG3460. Unimplementable noop_coroutine_handle guarantees](https://cplusplus.github.io/LWG/issue3460)
+- [LWG3460 Unimplementable `noop_coroutine_handle` guarantees](https://cplusplus.github.io/LWG/issue3460)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>