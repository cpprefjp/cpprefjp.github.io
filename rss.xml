<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-04-14T06:23:27.498747</updated>
  <id>d79ed8db-e3ce-493e-87bb-3f5aedc5e2e2</id>

  
    <entry>
      <title>スタイル -- 訳語表 : 伝播を記載</title>
      <link href="https://cpprefjp.github.io/working_style.html"/>
      <id>1859685731f023df519a5ebef3fdfada3d4757ae:working_style.md</id>
      <updated>2020-04-14T15:19:46+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;スタイル&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本サイトで作業を行う上でのスタイルです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「である」調&lt;/li&gt;
&lt;li&gt;句読点は「、」「。」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型修飾のスタイル：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A) const T &amp;amp;v&lt;/li&gt;
&lt;li&gt;B) const T&amp;amp; v&lt;/li&gt;
&lt;li&gt;C) const T &amp;amp; v&lt;/li&gt;
&lt;li&gt;D) T const &amp;amp;v&lt;/li&gt;
&lt;li&gt;E) T const&amp;amp; v&lt;/li&gt;
&lt;li&gt;F) T const &amp;amp; v&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本サイトでは、Bのスタイルで型修飾を行います。&lt;/p&gt;
&lt;h2&gt;バージョンの表記&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;p&gt;C++11以降対応については対応バージョンを明記します。バージョン表記が省略されている場合、C++03、C++98対応であることを表します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;li&gt;C++14&lt;/li&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;li&gt;C++03&lt;/li&gt;
&lt;li&gt;C++98&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;p&gt;開発環境の表記がない場合は、C++98対応のあらゆる環境で使用できるものとします。 
処理系の記載は、作業者が確認できたものを記載します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Clang: 2.1, 2.8&lt;/li&gt;
&lt;li&gt;GCC: 4.3.4, 4.4.3, 4.4.4, 4.5.2&lt;/li&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1, 12.0&lt;/li&gt;
&lt;li&gt;PathScale: 3.2&lt;/li&gt;
&lt;li&gt;QCC&lt;/li&gt;
&lt;li&gt;Visual C++: 2003, 2008, 2010&lt;/li&gt;
&lt;li&gt;pgCC: 11.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それと、訳語表を随時更新していってください。&lt;/p&gt;
&lt;h3&gt;訳語表&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英語&lt;/th&gt;
&lt;th&gt;日本語&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abstract class&lt;/td&gt;
&lt;td&gt;抽象クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;aggregate&lt;/td&gt;
&lt;td&gt;集成体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alignment&lt;/td&gt;
&lt;td&gt;アライメント (表示位置ではなくメモリの文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;apply, application&lt;/td&gt;
&lt;td&gt;適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arithmetic type&lt;/td&gt;
&lt;td&gt;算術型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;associative container(s)&lt;/td&gt;
&lt;td&gt;連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;base class&lt;/td&gt;
&lt;td&gt;基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bidirectional iterator&lt;/td&gt;
&lt;td&gt;双方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bucket&lt;/td&gt;
&lt;td&gt;バケット&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;complexity&lt;/td&gt;
&lt;td&gt;計算量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compound type&lt;/td&gt;
&lt;td&gt;複合型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const iterator&lt;/td&gt;
&lt;td&gt;読み取り専用イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const reverse iterator&lt;/td&gt;
&lt;td&gt;読み取り専用逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;covariant&lt;/td&gt;
&lt;td&gt;共変的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereference&lt;/td&gt;
&lt;td&gt;間接参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereferenceable&lt;/td&gt;
&lt;td&gt;間接参照可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;derived class&lt;/td&gt;
&lt;td&gt;派生クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;direct base class&lt;/td&gt;
&lt;td&gt;直接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;effects&lt;/td&gt;
&lt;td&gt;効果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emplace&lt;/td&gt;
&lt;td&gt;直接構築&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equal&lt;/td&gt;
&lt;td&gt;等値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence class&lt;/td&gt;
&lt;td&gt;同値分類 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence relation&lt;/td&gt;
&lt;td&gt;同値関係 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalent&lt;/td&gt;
&lt;td&gt;同値 (数学的文脈)、等価 (その他文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forward iterator&lt;/td&gt;
&lt;td&gt;前方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fundamental type&lt;/td&gt;
&lt;td&gt;単純型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ill-formed&lt;/td&gt;
&lt;td&gt;不適格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;implementation-defined&lt;/td&gt;
&lt;td&gt;処理系定義&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indirect base class&lt;/td&gt;
&lt;td&gt;間接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;inherited&lt;/td&gt;
&lt;td&gt;継承&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input iterator&lt;/td&gt;
&lt;td&gt;入力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;literal type&lt;/td&gt;
&lt;td&gt;リテラル型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load factor&lt;/td&gt;
&lt;td&gt;負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lvalue reference&lt;/td&gt;
&lt;td&gt;左辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max load factor&lt;/td&gt;
&lt;td&gt;最大負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;member&lt;/td&gt;
&lt;td&gt;メンバ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move&lt;/td&gt;
&lt;td&gt;(std::move 的な意味で)ムーブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move assignment&lt;/td&gt;
&lt;td&gt;ムーブ代入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move constructor&lt;/td&gt;
&lt;td&gt;ムーブコンストラクタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mutable iterator&lt;/td&gt;
&lt;td&gt;可変イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;non-virtual base class&lt;/td&gt;
&lt;td&gt;非仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;note&lt;/td&gt;
&lt;td&gt;注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output iterator&lt;/td&gt;
&lt;td&gt;出力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overload&lt;/td&gt;
&lt;td&gt;オーバーロード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partial ordering&lt;/td&gt;
&lt;td&gt;半順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partition&lt;/td&gt;
&lt;td&gt;区分化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ポインタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;polymorphic&lt;/td&gt;
&lt;td&gt;多相的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;power of N&lt;/td&gt;
&lt;td&gt;Nの累乗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;predicate&lt;/td&gt;
&lt;td&gt;述語&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;propagation, propagate&lt;/td&gt;
&lt;td&gt;伝播&lt;br /&gt; (伝搬は誤用が広まったものなので使わない)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pure virtual function&lt;/td&gt;
&lt;td&gt;純粋仮想関数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;random access iterator&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;範囲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;remarks&lt;/td&gt;
&lt;td&gt;備考&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;requires&lt;/td&gt;
&lt;td&gt;要件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;returns&lt;/td&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reverse iterator&lt;/td&gt;
&lt;td&gt;逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rvalue reference&lt;/td&gt;
&lt;td&gt;右辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sequence container(s)&lt;/td&gt;
&lt;td&gt;シーケンスコンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;signed&lt;/td&gt;
&lt;td&gt;符号付き&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop request&lt;/td&gt;
&lt;td&gt;停止要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop state&lt;/td&gt;
&lt;td&gt;停止状態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spurious Failure&lt;/td&gt;
&lt;td&gt;見かけ上の失敗&lt;br /&gt; &lt;a href=&#34;https://togetter.com/li/430770&#34; target=&#34;_blank&#34;&gt;https://togetter.com/li/430770&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strict weak ordering&lt;/td&gt;
&lt;td&gt;狭義の弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strong ordering&lt;/td&gt;
&lt;td&gt;全順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;synchronization&lt;/td&gt;
&lt;td&gt;同期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;total ordering relationalship&lt;/td&gt;
&lt;td&gt;全順序関係&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trailing return type&lt;/td&gt;
&lt;td&gt;後置戻り値型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trait&lt;/td&gt;
&lt;td&gt;トレイト&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trivial&lt;/td&gt;
&lt;td&gt;自明 (逆は非自明)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underlying type&lt;/td&gt;
&lt;td&gt;基底型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unordered associative container(s)&lt;/td&gt;
&lt;td&gt;非順序連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unspecified&lt;/td&gt;
&lt;td&gt;未規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;virtual base class&lt;/td&gt;
&lt;td&gt;仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;weak ordering&lt;/td&gt;
&lt;td&gt;弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;well-formed&lt;/td&gt;
&lt;td&gt;適格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- string::operator+ : 表の並び順修正</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>f758e082b24c76af5c67290766b329f830d8b519:reference/string/basic_string/op_plus.md</id>
      <updated>2020-04-14T14:09:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index b69c8b7d7..da8d2c48b 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -180,17 +180,17 @@ C++20からこの演算子による文字列連結時にアロケータがどの
 |オーバーロード|C++17まで|GCC|clang|MSVC|C++20から|
 |----|----|----|----|----|----|
 |(1) : `lhs + rhs`|`lhs`からのSOCCC|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(3) : `lhs + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 |(2) : `std::move(lhs) + rhs`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(3) : `lhs + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 |(4) : `std::move(lhs) + std::move(rhs)`|`lhs`または`rhs`|`lhs`|`lhs`|`lhs`|`lhs`|
-|(9) : `lhs + &amp;#34;rhs&amp;#34;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(11) : `lhs + &amp;#39;r&amp;#39;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(10) : `std::move(lhs) + &amp;#34;rhs&amp;#34;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
-|(12) : `std::move(lhs) + &amp;#39;r&amp;#39;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
 |(5) : `&amp;#34;lhs&amp;#34; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(7) : `&amp;#39;l&amp;#39; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
 |(6) : `&amp;#34;lhs&amp;#34; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(7) : `&amp;#39;l&amp;#39; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
 |(8) : `&amp;#39;l&amp;#39; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(9) : `lhs + &amp;#34;rhs&amp;#34;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(10) : `std::move(lhs) + &amp;#34;rhs&amp;#34;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(11) : `lhs + &amp;#39;r&amp;#39;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(12) : `std::move(lhs) + &amp;#39;r&amp;#39;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
 
 
 表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝播仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>属性構文 -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/attributes.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:lang/cpp11/attributes.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/attributes.md b/lang/cpp11/attributes.md
index e060c678b..a268b81cb 100644
--- a/lang/cpp11/attributes.md
+++ b/lang/cpp11/attributes.md
@@ -52,7 +52,7 @@ int main()
 
 
 ### &amp;lt;a id=&amp;#34;carries_dependency&amp;#34; href=&amp;#34;#carries_dependency&amp;#34;&amp;gt;`[[carries_dependency]]`属性&amp;lt;/a&amp;gt;
-`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order_consume`](/reference/atomic/memory_order.md)を、関数をまたいで伝搬することを明示するための属性である。
+`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order_consume`](/reference/atomic/memory_order.md)を、関数をまたいで伝播することを明示するための属性である。
 
 以下は、[`memory_order_consume`](/reference/atomic/memory_order.md)を使用した順序付けの例である：
 
@@ -70,10 +70,10 @@ if (r1) {
 * x.load[link /reference/atomic/atomic/load.md]
 * memory_order_consume[link /reference/atomic/memory_order.md]
 
-ここでは、`r1`に関連する操作が全て同一関数内で行われているが、一部の操作が別の関数になっていると、別の関数になった操作に値の依存があるかどうか・依存として扱ってよいのかどうかがコンパイラに判断できない可能性がある。そのような状況で、関数のパラメータおよび戻り値のそれぞれが値の依存性を伝搬させることを明示するために`[[carries_dependency]]`属性を使用する。
+ここでは、`r1`に関連する操作が全て同一関数内で行われているが、一部の操作が別の関数になっていると、別の関数になった操作に値の依存があるかどうか・依存として扱ってよいのかどうかがコンパイラに判断できない可能性がある。そのような状況で、関数のパラメータおよび戻り値のそれぞれが値の依存性を伝播させることを明示するために`[[carries_dependency]]`属性を使用する。
 
 
-#### 関数の戻り値で値の依存性を伝搬させる
+#### 関数の戻り値で値の依存性を伝播させる
 関数の戻り値に対して値の依存性を持たせる場合、関数に対して`[[carries_dependency]]`属性を付加する。
 
 ```cpp
@@ -94,7 +94,7 @@ if (r1) {
 * memory_order_consume[link /reference/atomic/memory_order.md]
 
 
-#### 関数のパラメータで値の依存性を伝搬させる
+#### 関数のパラメータで値の依存性を伝播させる
 関数のパラメータに対して値の依存性を持たせる場合、各パラメータ名のうしろに`[[carries_dependency]]`属性を付加する。
 
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/allocator.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator.md b/reference/memory/allocator.md
index da96c6715..12acf9aef 100644
--- a/reference/memory/allocator.md
+++ b/reference/memory/allocator.md
@@ -55,7 +55,7 @@ C++11から：
 | 名前 | 説明 | 対応バージョン |
 |-------------------|----------------------------------------------|-------|
 | `value_type`      | 要素の型 `T`                                 | |
-| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータの状態を伝搬するか。 [`true_type`](/reference/type_traits/true_type.md) | C++14 |
+| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータの状態を伝播するか。 [`true_type`](/reference/type_traits/true_type.md) | C++14 |
 | `size_type`       | 要素数を表す符号なし整数型 `size_t`          | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `difference_type` | ポインタの差を表す符号付き整数型 `ptrdiff_t` | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `pointer`         | 要素のポインタ型 `T*`                        | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator_traits -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator_traits.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/allocator_traits.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator_traits.md b/reference/memory/allocator_traits.md
index 7b3bc0e05..83101640f 100644
--- a/reference/memory/allocator_traits.md
+++ b/reference/memory/allocator_traits.md
@@ -45,9 +45,9 @@ namespace std {
 | `const_void_pointer`    | 読み取り専用の`void`のポインタ型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`const_void_pointer`を持っていればそれを使用し、そうでなければ[`pointer_traits`](pointer_traits.md)`&amp;lt;pointer&amp;gt;::rebind&amp;lt;const void&amp;gt;`を使用する。 | C++11 |
 | `difference_type` | ポインタの差を表す符号付き整数型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`difference_type`を持っていればそれを使用し、そうでなければ[`pointer_traits`](pointer_traits.md)`&amp;lt;pointer&amp;gt;::difference_type`を使用する。 | C++11 |
 | `size_type`       | 要素数を表す符号なし整数型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`size_type`を持っていればそれを使用し、そうでなければ[`make_unsigned`](/reference/type_traits/make_unsigned.md)`&amp;lt;difference_type&amp;gt;::type`を使用する。 | C++11 |
-| `propagate_on_container_copy_assignment` | コンテナのコピー代入時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_copy_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
-| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_move_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
-| `propagate_on_container_swap` | コンテナの交換時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_swap`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_copy_assignment` | コンテナのコピー代入時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_copy_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_move_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_swap` | コンテナの交換時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_swap`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
 | `is_always_equal` | `Alloc::is_always_equal`が存在する場合は`Alloc::is_always_equal`。それ以外の場合は`is_empty&amp;lt;Alloc&amp;gt;::type`。 | C++17 |
 | `rebind_alloc&amp;lt;U&amp;gt;` | 型`U`を確保するようにアロケータ型を再束縛する。&amp;lt;br/&amp;gt; `Alloc::rebind&amp;lt;U&amp;gt;::other`が有効ならそれを使用し、そうでなければ`Alloc&amp;lt;U, Args`&amp;gt;を使用する。`Alloc`がクラステンプレートでない場合、`rebind_alloc`の使用は不適格となる。 | C++11 |
 | `rebind_traits&amp;lt;U&amp;gt;` | 再束縛した型`U`に対する`allocator_traits`。`allocator_traits&amp;lt;rebind_alloc&amp;lt;U&amp;gt;&amp;gt;` | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uses_allocator -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/uses_allocator.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/uses_allocator.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uses_allocator.md b/reference/memory/uses_allocator.md
index 1733788f9..b312c6123 100644
--- a/reference/memory/uses_allocator.md
+++ b/reference/memory/uses_allocator.md
@@ -51,7 +51,7 @@ namespace std {
 - 本型トレイツは、主にスコープアロケータモデルを採用するアロケータで使用されることを意図している。  
 	標準ライブラリでは、[`scoped_allocator_adaptor`](/reference/scoped_allocator/scoped_allocator_adaptor.md)、[`polymorphic_allocator`](../memory_resource/polymorphic_allocator.md) クラステンプレートで使用されている。
 - 標準ライブラリで提供されるいくつかの型は本型トレイツの特殊化を提供している。（[`tuple`](../tuple/tuple.md)、[`promise`](../future/promise.md)、各種コンテナアダプタ等）  
-- [`pair`](../utility/pair.md) は [`tuple`](../tuple/tuple.md) と同列の機能と考えられるが、本型トレイツの特殊化を提供していない。このため、標準ライブラリで提供されるスコープアロケータモデルを採用したアロケータでは C++17 までは独自に [`pair`](../utility/pair.md) の各要素に対して uses-allocator 構築を適用している（ただし、ネストした [`pair`](/reference/utility/pair.md) の要素に対してはアロケータは伝搬されない）。  
+- [`pair`](../utility/pair.md) は [`tuple`](../tuple/tuple.md) と同列の機能と考えられるが、本型トレイツの特殊化を提供していない。このため、標準ライブラリで提供されるスコープアロケータモデルを採用したアロケータでは C++17 までは独自に [`pair`](../utility/pair.md) の各要素に対して uses-allocator 構築を適用している（ただし、ネストした [`pair`](/reference/utility/pair.md) の要素に対してはアロケータは伝播されない）。  
 	スコープアロケータモデルを採用したアロケータを自作する場合には、同様の対応を行う方が良いだろう。  
 	なお、C++20 で [`pair`](../utility/pair.md) に対する特殊対応を含めた uses-allocator 構築サポートのためのユーティリティ関数が追加されたため、以前に比べて容易に uses-allocator 構築への対応が可能となった。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>construct -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/construct.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory_resource/polymorphic_allocator/construct.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/polymorphic_allocator/construct.md b/reference/memory_resource/polymorphic_allocator/construct.md
index bd2dacf0e..7610c3225 100644
--- a/reference/memory_resource/polymorphic_allocator/construct.md
+++ b/reference/memory_resource/polymorphic_allocator/construct.md
@@ -213,7 +213,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -227,7 +227,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -241,7 +241,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -256,7 +256,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -270,7 +270,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scoped_allocator_adaptor -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/scoped_allocator/scoped_allocator_adaptor.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/scoped_allocator/scoped_allocator_adaptor.md b/reference/scoped_allocator/scoped_allocator_adaptor.md
index f152fb0f2..30efb5292 100644
--- a/reference/scoped_allocator/scoped_allocator_adaptor.md
+++ b/reference/scoped_allocator/scoped_allocator_adaptor.md
@@ -24,11 +24,11 @@ namespace std {
 
 ![](https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_02.png)
 
-図2 コンテナとその要素で、アロケータオブジェクトの状態を伝搬させる(例1)
+図2 コンテナとその要素で、アロケータオブジェクトの状態を伝播させる(例1)
 
 ![](https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_03.png)
 
-図3 全ての要素にアロケータオブジェクトの状態を伝搬させる(例2)
+図3 全ての要素にアロケータオブジェクトの状態を伝播させる(例2)
 
 
 
@@ -99,7 +99,7 @@ namespace std {
 | [`(deduction_guide)`](scoped_allocator_adaptor/op_deduction_guide.md) | クラステンプレートの推論補助 | C++17 |
 
 
-## 例1 コンテナとその要素で、アロケータオブジェクトの状態を伝搬させる
+## 例1 コンテナとその要素で、アロケータオブジェクトの状態を伝播させる
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -176,7 +176,7 @@ int main()
 5
 ```
 
-## 例2 全ての要素にアロケータオブジェクトの状態を伝搬させる
+## 例2 全ての要素にアロケータオブジェクトの状態を伝播させる
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -242,7 +242,7 @@ int main()
   std::cout &amp;lt;&amp;lt; &amp;#34;container allocator : &amp;#34; &amp;lt;&amp;lt; v.get_allocator().getState() &amp;lt;&amp;lt; std::endl;
 
   // 要素に使用されるアロケータの状態を確認
-  // 全ての要素に、アロケータの状態が伝搬される
+  // 全ての要素に、アロケータの状態が伝播される
   for (const forward_list&amp;amp; x : v) {
     std::cout &amp;lt;&amp;lt; &amp;#34;element allocator : &amp;#34; &amp;lt;&amp;lt; x.get_allocator().getState() &amp;lt;&amp;lt; std::endl;
   }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>construct -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/construct.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/scoped_allocator/scoped_allocator_adaptor/construct.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/scoped_allocator/scoped_allocator_adaptor/construct.md b/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
index 539f4dd38..837bbee42 100644
--- a/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
+++ b/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
@@ -137,7 +137,7 @@ void construct_propagate_alloc()
   const std::size_t n = 1;
   string* p = alloc.allocate(n);
 
-  // (1) 以下のコンストラクタを呼び出し、アロケータオブジェクトを伝搬させる
+  // (1) 以下のコンストラクタを呼び出し、アロケータオブジェクトを伝播させる
   // basic_string(const char*, Allocator)
   alloc.construct(p, &amp;#34;hello&amp;#34;);
 
@@ -157,7 +157,7 @@ void construct_pair()
 
   // (2)
   // pairの各要素に対して以下のコンストラクタを呼び出し、
-  // アロケータオブジェクトを伝搬させる。
+  // アロケータオブジェクトを伝播させる。
   // basic_string(const char*, Allocator)
   std::pair&amp;lt;string, string&amp;gt;* pair_p = p;
   alloc.construct(p, std::piecewise_construct,
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/string/basic_string/op_plus.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index 9cba8ea23..b69c8b7d7 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -173,9 +173,9 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 ## 備考
 (5)、(6) の形式の `lhs`、および、(9)、(10) の形式の `rhs` の文字列長算出のために `traits::length()` が使用される
 
-## アロケータの伝搬
+## アロケータの伝播
 
-C++20からこの演算子による文字列連結時にアロケータがどのように伝搬するかが変更された。C++17までの仕様及び各実装とC++20からの各オーバーロード利用時の結果オブジェクトへのアロケータ供給元は次のようになる。なお、SOCCCは[`select_on_container_copy_construction`](/reference/memory/allocator_traits/select_on_container_copy_construction.md)の略。
+C++20からこの演算子による文字列連結時にアロケータがどのように伝播するかが変更された。C++17までの仕様及び各実装とC++20からの各オーバーロード利用時の結果オブジェクトへのアロケータ供給元は次のようになる。なお、SOCCCは[`select_on_container_copy_construction`](/reference/memory/allocator_traits/select_on_container_copy_construction.md)の略。
 
 |オーバーロード|C++17まで|GCC|clang|MSVC|C++20から|
 |----|----|----|----|----|----|
@@ -193,7 +193,7 @@ C++20からこの演算子による文字列連結時にアロケータがどの
 |(8) : `&amp;#39;l&amp;#39; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 
 
-表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝搬仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
+表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝播仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
 
 ## 例
 ```cpp example
@@ -226,4 +226,4 @@ Hello, world!
 | [`insert`](insert.md)       | 文字／文字列を挿入する |
 
 ## 参照
-- [P1165R1 Make stateful allocator propagation more consistent for operator+(basic_string)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1165r1.html)
\ No newline at end of file
+- [P1165R1 Make stateful allocator propagation more consistent for operator+(basic_string)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1165r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- Merge pull request #752 from cpprefjp/tshino-patch-1</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/unique.html"/>
      <id>386bc57e28d4f5b88c16a2af7334f2e40faf7803:reference/memory/shared_ptr/unique.md</id>
      <updated>2020-04-14T13:20:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/unique.md b/reference/memory/shared_ptr/unique.md
index 682022606..3cb4ef22c 100644
--- a/reference/memory/shared_ptr/unique.md
+++ b/reference/memory/shared_ptr/unique.md
@@ -14,7 +14,7 @@ bool unique() const noexcept;
 この関数は、C++17から非推奨となり、C++20で削除された。代わりに[`use_count()`](use_count.md)関数を使用すること。
 
 ## 概要
-有効なリソースを所有しているかを判定する。
+同じ所有権を共有する他のユーザーが存在しないかを判定する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equality_comparable -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/reference/concepts/equality_comparable.html"/>
      <id>9d0aaf10ba17673b1dc4f69cd5da961f30fea67c:reference/concepts/equality_comparable.md</id>
      <updated>2020-04-14T12:40:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/equality_comparable.md b/reference/concepts/equality_comparable.md
index f50ac85b2..fa14fd6e3 100644
--- a/reference/concepts/equality_comparable.md
+++ b/reference/concepts/equality_comparable.md
@@ -77,7 +77,7 @@ concept equality_comparable_with =
 
 ## 備考
 
-定義内の`a == b`等の各制約式に[等しさを保持](/reference/concepts.md)する事が要求されていることによって、これらコンセプトを満たす`== !=`演算子は推移的かつ対称的である事を表し、要求している。
+定義内の`t == u`等の各制約式に[等しさを保持](/reference/concepts.md)する事が要求されていることによって、これらコンセプトを満たす`== !=`演算子は推移的かつ対称的である事を表し、要求している。
 
 - 推移律 : `a == b`かつ`b == c`ならば`a == c`
 - 対称律 : `a == b`ならば`b == a`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>