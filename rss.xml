<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-08-31T14:34:39.303181</updated>
  <id>b717f61f-bd55-4f87-bdab-6663cf571fb9</id>

  
    <entry>
      <title>if文とswitch文の条件式と初期化を分離 -- Update selection_statements_with_initializer.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/selection_statements_with_initializer.html"/>
      <id>33b05b121f9bc98db7d90ee4aad1e676dfb8fca9:lang/cpp17/selection_statements_with_initializer.md</id>
      <updated>2020-08-30T01:33:20+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/selection_statements_with_initializer.md b/lang/cpp17/selection_statements_with_initializer.md
index 426d69c28..831b706ce 100644
--- a/lang/cpp17/selection_statements_with_initializer.md
+++ b/lang/cpp17/selection_statements_with_initializer.md
@@ -136,9 +136,16 @@ if (std::lock_guard&amp;lt;std::mutex&amp;gt; lock(mx); shared_flag) { unsafe_ping(); shared_f
 ## この機能が必要になった背景・経緯
 
 変数の宣言あるいは初期化を行い、`if`文や`switch`文のスコープ内だけで変数を使用するケースは多数あるにも関わらず、
-`if`文や`switch`文に初期化を行う記法は存在しなかった。
+`if`文や`switch`文で行える宣言は限定的だった。
+具体的には、単一かつ配列ではない変数しか宣言できず、その変数の初期値が条件になってしまうので、変数を宣言したうえで別の式を条件にすることはできなかった。
 
-C++14まででも同様の意味を持つ記述は不可能ではないが、外側にスコープを追加する必要があり冗長な記述になっていた:
+```cpp
+// ポインターを受け取ってnullチェックをするパターンは、C++14まででもよく見かけた。
+// しかし、この条件を反転(nullptrのとき真)することさえ不可能であった。
+if (auto* p = get_some_object()) { ... } // pがnullptrでなければ真
+```
+
+C++14まででも初期化付きの条件分岐と同様の意味を持つ記述は不可能ではないが、外側にスコープを追加する必要があり冗長な記述になっていた:
 
 ```cpp
 status_code foo() {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait_until -- condition_variable_any/wait_until: 表示崩れ修正</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait_until.html"/>
      <id>b8513fc03a4fa9bdd65d69b3d389901431a92072:reference/condition_variable/condition_variable_any/wait_until.md</id>
      <updated>2020-08-28T15:24:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait_until.md b/reference/condition_variable/condition_variable_any/wait_until.md
index e24515bb0..bfc26b988 100644
--- a/reference/condition_variable/condition_variable_any/wait_until.md
+++ b/reference/condition_variable/condition_variable_any/wait_until.md
@@ -42,7 +42,7 @@ bool wait_until(Lock&amp;amp; lock,
 
 ## 効果
 - (1) :
-    - アトミックに`lock.[unlock()](/reference/mutex/unique_lock/unlock.md)`する
+    - アトミックに`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)する
     - [`notify_one()`](notify_one.md)/[`notify_all()`](notify_all.md)による通知、`abs_time`によって指定された時間に到達したことによる期限切れ、もしくはなんらかの理由によって失敗するまでブロッキングする
     - この関数を抜ける際に`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)する
     - この関数が例外送出によって終了する場合、関数を抜ける前に`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- condition_variable_any: wait系メンバ stop_token対応</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait.html"/>
      <id>3658c726a4ba71dd11ad7170267a1d8e7cd29e7c:reference/condition_variable/condition_variable_any/wait.md</id>
      <updated>2020-08-28T13:18:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait.md b/reference/condition_variable/condition_variable_any/wait.md
index ccb88405b..15cff6ffc 100644
--- a/reference/condition_variable/condition_variable_any/wait.md
+++ b/reference/condition_variable/condition_variable_any/wait.md
@@ -11,7 +11,14 @@ void wait(Lock&amp;amp; lock);                 // (1)
 
 template &amp;lt;class Lock, class Predicate&amp;gt;
 void wait(Lock&amp;amp; lock, Predicate pred); // (2)
+
+template&amp;lt;class Lock, class Predicate&amp;gt;
+bool wait(Lock&amp;amp; lock,
+          stop_token stoken,
+          Predicate pred);             // (3) C++20 から
 ```
+* stop_token[link /reference/stop_token/stop_token.md]
+
 
 ## 概要
 起床されるまで待機する。
@@ -40,13 +47,26 @@ while (!pred()) {
 }
 ```
 
+- (3) : 以下と等価の処理を行う
+
+```cpp
+while (!stoken.stop_requested()) {
+  if (pred())
+    return true;
+  wait(lock);
+}
+return pred();
+```
+* stop_requested()[link /reference/stop_token/stop_source/stop_requested.md]
+
 
 ## 事後条件
 `lock`が参照しているミューテックスオブジェクトが、この関数を呼び出したスレッドでロック取得されていること
 
 
 ## 戻り値
-なし
+- (1),(2) : なし
+- (3) : 停止要求が行われた場合は`true`が返る。そうでない場合は`pred()`の結果が返る。
 
 
 ## 例外
@@ -55,7 +75,9 @@ while (!pred()) {
     - C++14 : 投げない
 - (2) : 
     - C++11まで : この関数は、`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)および`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)によって送出されうる、あらゆる例外が送出される可能性がある。
-    - C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。
+    - C++14 : `pred()`により送出された例外。
+－ (3) :
+    - `pred()`により送出された例外。
 
 
 ## 備考
@@ -158,5 +180,4 @@ process data
 ## 参照
 - [LWG Issue 2093. Throws clause of `condition_variable::wait` with predicate](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2093)
 - [LWG Issue 2135. Unclear requirement for exceptions thrown in `condition_variable::wait()`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2135)
-
-
+- [P0660R10 Stop Token and Joining Thread, Rev 10](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0660r10.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait_for -- condition_variable_any: wait系メンバ stop_token対応</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait_for.html"/>
      <id>3658c726a4ba71dd11ad7170267a1d8e7cd29e7c:reference/condition_variable/condition_variable_any/wait_for.md</id>
      <updated>2020-08-28T13:18:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait_for.md b/reference/condition_variable/condition_variable_any/wait_for.md
index 4a23f4387..03ce231c4 100644
--- a/reference/condition_variable/condition_variable_any/wait_for.md
+++ b/reference/condition_variable/condition_variable_any/wait_for.md
@@ -14,8 +14,16 @@ template &amp;lt;class Lock, class Rep, class Period, class Predicate&amp;gt;
 bool wait_for(Lock&amp;amp; lock,
               const chrono::duration&amp;lt;Rep, Period&amp;gt;&amp;amp; rel_time,
               Predicate pred);                                     // (2)
+
+template&amp;lt;class Lock, class Rep, class Period, class Predicate&amp;gt;
+bool wait_for(Lock&amp;amp; lock,
+              stop_token stoken,
+              const chrono::duration&amp;lt;Rep, Period&amp;gt;&amp;amp; rel_time,
+              Predicate pred);                                     // (3) C++20 から
 ```
 * cv_status[link /reference/condition_variable/cv_status.md]
+* stop_token[link /reference/stop_token/stop_token.md]
+
 
 ## 概要
 相対時間でタイムアウトを指定して、起床されるまで待機する。
@@ -52,14 +60,31 @@ return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred))
 
 `pred()`が最初から`true`の場合、またはすでに期限が過ぎている場合、この関数はブロッキングしない
 
+- (3) :
+
+```cpp
+return wait_until(lock, std::move(stoken), chrono::steady_clock::now() + rel_time,
+                  std::move(pred));
+```
+* wait_until[link wait_until.md]
+* steady_clock[link /reference/chrono/steady_clock.md]
+* now()[link /reference/chrono/steady_clock/now.md]
+* std::move[link /reference/utility/move.md]
+
 
 ## 事後条件
 `lock`が参照しているミューテックスオブジェクトが、この関数を呼び出したスレッドでロック取得されていること
 
 
 ## 例外
-- C++11 : この関数は、`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)および`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)によって送出されうる、あらゆる例外が送出される可能性がある。
-- C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。
+- (1) :
+    - C++11まで : この関数は、`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)および`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)によって送出されうる、あらゆる例外が送出される可能性がある。
+    - C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。
+- (2) :
+    - C++11まで : この関数は、`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)および`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)によって送出されうる、あらゆる例外が送出される可能性がある。
+    - C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。または`pred()`により送出された例外。
+- (3) :
+    - 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。または`pred()`により送出された例外。
 
 
 ## 備考
@@ -176,5 +201,4 @@ process data
 ## 参照
 - [LWG Issue 2093. Throws clause of `condition_variable::wait` with predicate](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2093)
 - [LWG Issue 2135. Unclear requirement for exceptions thrown in `condition_variable::wait()`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2135)
-
-
+- [P0660R10 Stop Token and Joining Thread, Rev 10](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0660r10.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait_until -- condition_variable_any: wait系メンバ stop_token対応</title>
      <link href="https://cpprefjp.github.io/reference/condition_variable/condition_variable_any/wait_until.html"/>
      <id>3658c726a4ba71dd11ad7170267a1d8e7cd29e7c:reference/condition_variable/condition_variable_any/wait_until.md</id>
      <updated>2020-08-28T13:18:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/condition_variable/condition_variable_any/wait_until.md b/reference/condition_variable/condition_variable_any/wait_until.md
index 9f8c00f85..e24515bb0 100644
--- a/reference/condition_variable/condition_variable_any/wait_until.md
+++ b/reference/condition_variable/condition_variable_any/wait_until.md
@@ -14,9 +14,17 @@ template &amp;lt;class Lock, class Clock, class Duration, class Predicate&amp;gt;
 bool wait_until(Lock&amp;amp; lock,
                 const chrono::time_point&amp;lt;Clock, Duration&amp;gt;&amp;amp; abs_time,
                 Predicate pred);                                           // (2)
+
+template&amp;lt;class Lock, class Clock, class Duration, class Predicate&amp;gt;
+bool wait_until(Lock&amp;amp; lock,
+                stop_token stoken,
+                const chrono::time_point&amp;lt;Clock, Duration&amp;gt;&amp;amp; abs_time,
+                Predicate pred);                                           // (3) C++20 から
 ```
 * cv_status[link /reference/condition_variable/cv_status.md]
 * time_point[link /reference/chrono/time_point.md]
+* stop_token[link /reference/stop_token/stop_token.md]
+
 
 ## 概要
 絶対時間でタイムアウトを指定して、起床されるまで待機する。
@@ -51,10 +59,25 @@ return true;
 ```
 * cv_status::timeout[link /reference/condition_variable/cv_status.md]
 
+- (3) : 以下と等価の処理を行う
+
+```cpp
+while (!stoken.stop_requested()) {
+  if (pred())
+    return true;
+  if (cv.wait_until(lock, abs_time) == cv_status::timeout)
+    return pred();
+}
+return pred();
+```
+* stop_requested()[link /reference/stop_token/stop_source/stop_requested.md]
+* cv_status::timeout[link /reference/condition_variable/cv_status.md]
+
 
 ## 戻り値
 - (1) : `abs_time`で指定された絶対時間内に起床されない場合、タイムアウトとなり[`cv_status::timeout`](/reference/condition_variable/cv_status.md)が返る。そうでない場合は[`cv_status::no_timeout`](/reference/condition_variable/cv_status.md)が返る。
-- (2) : 戻り値：`pred()`の結果が返る
+- (2) : `pred()`の結果が返る。
+- (3) : 停止要求が行われた場合は`true`が返る。そうでない場合は`pred()`の結果が返る。
 
 
 ## 事後条件
@@ -62,8 +85,14 @@ return true;
 
 
 ## 例外
-- C++11 : この関数は、`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)および`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)によって送出されうる、あらゆる例外が送出される可能性がある。
-- C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。
+- (1) :
+    - C++11まで : この関数は、`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)および`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)によって送出されうる、あらゆる例外が送出される可能性がある。
+    - C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。
+- (2) :
+    - C++11まで : この関数は、`lock.`[`lock()`](/reference/mutex/unique_lock/lock.md)および`lock.`[`unlock()`](/reference/mutex/unique_lock/unlock.md)によって送出されうる、あらゆる例外が送出される可能性がある。
+    - C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。または`pred()`により送出された例外。
+- (3) :
+    - 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。または`pred()`により送出された例外。
 
 
 ## 備考
@@ -187,4 +216,4 @@ process data
 - [LWG Issue 2135. Unclear requirement for exceptions thrown in `condition_variable::wait()`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2135)
 - [Bug 41861 (DR887) - [DR 887][C++0x] `&amp;lt;condition_variable&amp;gt;` does not use `monotonic_clock`](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=41861)
     - GCC 10から`steady_clock`がサポートされた
-
+- [P0660R10 Stop Token and Joining Thread, Rev 10](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0660r10.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>リテラル演算子のスペースを省略可能とする -- C++14 リテラル演算子のスペースを省略可能とする : defect reportへのリンクがなくなっていたのでURL差し替え</title>
      <link href="https://cpprefjp.github.io/lang/cpp14/no_whitespace_literal_operators.html"/>
      <id>6fb84068191b553a14f327a60c5618c5c76f4fec:lang/cpp14/no_whitespace_literal_operators.md</id>
      <updated>2020-08-25T16:55:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp14/no_whitespace_literal_operators.md b/lang/cpp14/no_whitespace_literal_operators.md
index 96c39943e..10641a093 100644
--- a/lang/cpp14/no_whitespace_literal_operators.md
+++ b/lang/cpp14/no_whitespace_literal_operators.md
@@ -48,5 +48,5 @@ hello
 
 
 ## 参照
-- [CWG Issue 1473. Syntax of literal-operator-id](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1473)
+- [CWG Issue 1473. Syntax of literal-operator-id](https://wg21.cmeerw.net/cwg/issue1473)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>一貫比較 -- 表記の再修正 / consistent_comparison.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html"/>
      <id>439ffe092d1419af9927b08b386db6f6f443bdee:lang/cpp20/consistent_comparison.md</id>
      <updated>2020-08-22T17:53:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/consistent_comparison.md b/lang/cpp20/consistent_comparison.md
index a99b8dfc3..0a15c7367 100644
--- a/lang/cpp20/consistent_comparison.md
+++ b/lang/cpp20/consistent_comparison.md
@@ -229,7 +229,7 @@ bool eq2 = a == category::C;  //ok
 
 この場合でも、`default`の`==`を明示的に宣言することで利用可能となる。
 
-このような仕様になっているのは、`&amp;lt;=&amp;gt;`を用いた同値比較において発生しうるオーバーヘッドを回避するためである（詳細は後述の「検討された他の選択肢」を参照）。
+このような仕様になっているのは、`&amp;lt;=&amp;gt;`を用いた同値比較において発生しうるオーバーヘッドを回避するためである（詳細は後述の「検討されたほかの選択肢」を参照）。
 
 ### 演算子の導出とオーバーロード候補
 `&amp;lt;=&amp;gt;`及び`==`から導出される演算子は暗黙的に宣言され実装されているわけではなく、それらの演算子を呼び出した際のオーバーロード候補に、`&amp;lt;=&amp;gt; ==`を利用して生成した候補を入れることによって導出される。このため、導出された比較演算子のアドレスを取ることは出来ない。
@@ -633,7 +633,7 @@ C++17以前の例に示したように、従来のC++における比較演算子
 そして、`default`指定された`&amp;lt;=&amp;gt;`と`==`は基底クラス及び全メンバの宣言順の辞書式比較を行う。  
 異種型間比較においても、1つの引数順の`&amp;lt;=&amp;gt;`と`==`の2つを定義することで残りの11個の比較演算子を導出することができる。
 
-## 検討された他の選択肢
+## 検討されたほかの選択肢
 
 ### `&amp;lt;=&amp;gt; != ==` : 同値比較の分離
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Ryo Suzuki</name>
        <email>reputeless+github@gmail.com</email>
      </author>
    </entry>
  
</feed>