<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-05-12T14:40:29.709079</updated>
  <id>d6c43fef-5cd4-4e29-bce9-d30045bf1388</id>

  
    <entry>
      <title>nth_element -- fix some typo</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/nth_element.html"/>
      <id>4d8ffbea106f17aca2eaa0e822f836f0262e38be:reference/algorithm/nth_element.md</id>
      <updated>2024-05-12T15:58:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/nth_element.md b/reference/algorithm/nth_element.md
index 6c0ddf375..6c8890ac7 100644
--- a/reference/algorithm/nth_element.md
+++ b/reference/algorithm/nth_element.md
@@ -87,7 +87,7 @@ int main()
 ```
 * std::nth_element[color ff0000]
 
-### 出力
+### 出力例
 ```
 2
 1
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>実行ポリシー -- fix some typo</title>
      <link href="https://cpprefjp.github.io/reference/execution/execution/execution_policy.html"/>
      <id>4d8ffbea106f17aca2eaa0e822f836f0262e38be:reference/execution/execution/execution_policy.md</id>
      <updated>2024-05-12T15:58:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/execution/execution/execution_policy.md b/reference/execution/execution/execution_policy.md
index f1ee35df3..fdc1ea560 100644
--- a/reference/execution/execution/execution_policy.md
+++ b/reference/execution/execution/execution_policy.md
@@ -159,6 +159,8 @@ int main()
   }
 }
 ```
+* std::execution::par[color ff0000]
+* std::execution::par_unseq[color ff0000]
 * count.load[link /reference/atomic/atomic/load.md]
 * is_always_lock_free[link /reference/atomic/atomic/is_always_lock_free.md.nolink]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>const_iterator -- fix some typo</title>
      <link href="https://cpprefjp.github.io/reference/iterator/const_iterator.html"/>
      <id>4d8ffbea106f17aca2eaa0e822f836f0262e38be:reference/iterator/const_iterator.md</id>
      <updated>2024-05-12T15:58:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/const_iterator.md b/reference/iterator/const_iterator.md
index d88d0c17b..91e997fbe 100644
--- a/reference/iterator/const_iterator.md
+++ b/reference/iterator/const_iterator.md
@@ -7,7 +7,7 @@
 ```cpp
 namespace std {
   template&amp;lt;input_iterator I&amp;gt;
-  using const_iterator = /*see below*?;
+  using const_iterator = /*see below*/;
 }
 ```
 * input_iterator[link input_iterator.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>const_sentinel -- fix some typo</title>
      <link href="https://cpprefjp.github.io/reference/iterator/const_sentinel.html"/>
      <id>4d8ffbea106f17aca2eaa0e822f836f0262e38be:reference/iterator/const_sentinel.md</id>
      <updated>2024-05-12T15:58:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/const_sentinel.md b/reference/iterator/const_sentinel.md
index 591caab8e..483495e3d 100644
--- a/reference/iterator/const_sentinel.md
+++ b/reference/iterator/const_sentinel.md
@@ -7,7 +7,7 @@
 ```cpp
 namespace std {
   template&amp;lt;semiregular S&amp;gt;
-  using const_sentinel = /*see below*?;
+  using const_sentinel = /*see below*/;
 }
 ```
 * semiregular[link /reference/concepts/semiregular.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Pragma演算子 -- Merge pull request #1272 from Kiterai/patch-1</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/pragma_operator.html"/>
      <id>a741689cf753c09452e6356bfc74c65a65ffe112:lang/cpp11/pragma_operator.md</id>
      <updated>2024-05-07T17:45:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/pragma_operator.md b/lang/cpp11/pragma_operator.md
index 06294806f..ef1727c73 100644
--- a/lang/cpp11/pragma_operator.md
+++ b/lang/cpp11/pragma_operator.md
@@ -43,7 +43,7 @@ int main()
   int b[N] = {1, 2, 3, 4, 5};
   int c[N] = {};
 
-  // OMP_PARALLEL_FORは、 #pragma omp parallel for に展開される
+  // OMP_PARALLEL_FORは、 _Pragma(&amp;#34;omp parallel for&amp;#34;) に展開される
   OMP_PARALLEL_FOR
   for (int i = 0; i &amp;lt; N; ++i) {
     c[i] = a[i] + b[i];
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- packaged_task::resetの実装の動作についても追記 #1270</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/op_assign.html"/>
      <id>2486f062f20953bf9500234b60ca893643f59cc9:reference/future/packaged_task/op_assign.md</id>
      <updated>2024-05-06T15:17:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/op_assign.md b/reference/future/packaged_task/op_assign.md
index 538183840..2dd403be6 100644
--- a/reference/future/packaged_task/op_assign.md
+++ b/reference/future/packaged_task/op_assign.md
@@ -37,7 +37,7 @@ C++11の仕様では、ムーブ代入演算子の効果として古い共有状
 
 「(共有状態を)放棄する(abandon)」とは効果の項(2)の1と2が行われることをいい、「(共有状態を)解放する(release)」とは効果の項(2)の2のみが行われることである。通常、[`promise`](../promise.md)および`packaged_task`は処理結果を提供する側であるため共有状態を所有しなくなるときには前者を行い、[`future`](../future.md)および[`shared_future`](../shared_future.md)は処理結果を受け取る側であるため共有状態を所有しなくなるときには後者を行う。
 
-なお、実際の実装ではClangおよびGCCでは「放棄する(abandon)」の動作になっているが、Visual C++では「解放する(release)」の動作になっている。
+なお、`operator=`の実際の実装では、ClangおよびGCCでは「放棄する(abandon)」の動作になっているが、Visual C++では「解放する(release)」の動作になっている。また、[`reset`](reset.md)では、Clang,GCC,Visual C++のいずれも「放棄する(abandon)」の動作になっている。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino.ssr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- packaged_taskムーブ代入演算子とresetの効果を追記。備考で実装について補足 #1270</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/op_assign.html"/>
      <id>599f09ff3f94f6c3bb943ef59fa76189808313c6:reference/future/packaged_task/op_assign.md</id>
      <updated>2024-05-06T15:09:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/op_assign.md b/reference/future/packaged_task/op_assign.md
index 2d4f859ff..538183840 100644
--- a/reference/future/packaged_task/op_assign.md
+++ b/reference/future/packaged_task/op_assign.md
@@ -18,7 +18,10 @@ packaged_task&amp;amp; operator=(packaged_task&amp;amp;&amp;amp; rhs) noexcept;  // (2)
 
 
 ## 効果
-- (2) : `*this`の共有状態を解放し、`packaged_task(`[`std::move`](/reference/utility/move.md)`(rhs)).swap(*this)`を行う。
+- (2) :
+    1. まず現在の共有状態が準備完了状態([`future_status::ready`](../future_status.md))でなければ、error conditionとして[`broken_promise`](../future_errc.md)を持つ[`future_error`](../future_error.md)例外オブジェクトを格納したのち、準備完了状態にする。ただし、実装によっては、この動作が行われない場合がある(備考を参照)。
+    2. 現在の共有状態を解放する。
+    3. `packaged_task(`[`std::move`](/reference/utility/move.md)`(rhs)).swap(*this)`を行う。
 
 
 ## 戻り値
@@ -29,6 +32,13 @@ packaged_task&amp;amp; operator=(packaged_task&amp;amp;&amp;amp; rhs) noexcept;  // (2)
 - (2) : 投げない
 
 
+## 備考
+C++11の仕様では、ムーブ代入演算子の効果として古い共有状態は「放棄する(abandon)」ではなく「解放する(release)」となっているが、仕様の他の項目(Shared States, Class template promise, および Class template packaged_task内のvoid reset();)の記載との整合性を欠いており、「放棄する(abandon)」とする方が合理性があるため効果の項にはそのように記載した。
+
+「(共有状態を)放棄する(abandon)」とは効果の項(2)の1と2が行われることをいい、「(共有状態を)解放する(release)」とは効果の項(2)の2のみが行われることである。通常、[`promise`](../promise.md)および`packaged_task`は処理結果を提供する側であるため共有状態を所有しなくなるときには前者を行い、[`future`](../future.md)および[`shared_future`](../shared_future.md)は処理結果を受け取る側であるため共有状態を所有しなくなるときには後者を行う。
+
+なお、実際の実装ではClangおよびGCCでは「放棄する(abandon)」の動作になっているが、Visual C++では「解放する(release)」の動作になっている。
+
 ## 例
 ```cpp example
 #include &amp;lt;future&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino.ssr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reset -- packaged_taskムーブ代入演算子とresetの効果を追記。備考で実装について補足 #1270</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/reset.html"/>
      <id>599f09ff3f94f6c3bb943ef59fa76189808313c6:reference/future/packaged_task/reset.md</id>
      <updated>2024-05-06T15:09:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/reset.md b/reference/future/packaged_task/reset.md
index f4333e7ed..59b2d1d70 100644
--- a/reference/future/packaged_task/reset.md
+++ b/reference/future/packaged_task/reset.md
@@ -21,7 +21,7 @@ void reset();
 ```
 * std::move[link /reference/utility/move.md]
 
-によって、新たに共有状態を作成する。古い共有状態は放棄される。
+によって、新たに共有状態を作成する。古い共有状態は放棄される(詳細は[`operator=`](op_assign.md)を参照)。
 
 `f`はメンバ変数として保持している、非同期実行する関数オブジェクト。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>tshino</name>
        <email>tshino.ssr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Pragma演算子 -- Update pragma_operator.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/pragma_operator.html"/>
      <id>bcfaf97b5b16446e967007fdb452d332352454d7:lang/cpp11/pragma_operator.md</id>
      <updated>2024-05-06T00:05:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/pragma_operator.md b/lang/cpp11/pragma_operator.md
index 06294806f..ef1727c73 100644
--- a/lang/cpp11/pragma_operator.md
+++ b/lang/cpp11/pragma_operator.md
@@ -43,7 +43,7 @@ int main()
   int b[N] = {1, 2, 3, 4, 5};
   int c[N] = {};
 
-  // OMP_PARALLEL_FORは、 #pragma omp parallel for に展開される
+  // OMP_PARALLEL_FORは、 _Pragma(&amp;#34;omp parallel for&amp;#34;) に展開される
   OMP_PARALLEL_FOR
   for (int i = 0; i &amp;lt; N; ++i) {
     c[i] = a[i] + b[i];
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Kiterai</name>
        <email>7496490+Kiterai@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>