<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-14T14:53:24.082996</updated>
  <id>bc739508-94c8-4d86-8bf4-a94c2f5acf04</id>

  
    <entry>
      <title>common_type -- common_type: fix indent</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/common_type.html"/>
      <id>11bd93470d9981dac30568552adc4340b09c9833:reference/type_traits/common_type.md</id>
      <updated>2021-05-14T17:15:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/common_type.md b/reference/type_traits/common_type.md
index 8a76a591e..88220bb65 100644
--- a/reference/type_traits/common_type.md
+++ b/reference/type_traits/common_type.md
@@ -37,8 +37,8 @@ namespace std {
 - `N == 2` : `Types...`の1, 2番目の型を`T1, T2`、`D1 = decay_t&amp;lt;T1&amp;gt;, D2 = decay_t&amp;lt;T2&amp;gt;`として
 	- `T1,T2`に対する`decay`適用が少なくとも片方が恒等写像とならない（`is_same_v&amp;lt;T1, D1&amp;gt; == false || is_same_v&amp;lt;T2, D2&amp;gt; == false`となる）場合、`type = common_type_t&amp;lt;D1, D2&amp;gt;;`
 	- `common_type&amp;lt;T1, T2&amp;gt;`に対するユーザ定義の特殊化が行われていれば、同特殊化を利用する。
-  - `C = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;`が有効な型ならば、`type = C;`
-  - `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
+	- `C = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;`が有効な型ならば、`type = C;`
+	- `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
 	- そうでなければ、メンバ型`type`は定義されない。
 - `N &amp;gt;= 3` : `Types...`の１、2番目の型を`T1, T2`、残りのパラメータパックを`P...`とすると、`type = common_type_t&amp;lt;common_type_t&amp;lt;T1, T2&amp;gt;, P...&amp;gt;;`のように`type`を定義。
 	- 先頭2つの型の共通型を求めて、その型と3番目の型の共通型を求めて、その型と4番目の...というように再帰的に`common_type`を適用していく。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- common_type: 不可視文字を削除</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/common_type.html"/>
      <id>00858756de884b210969ead4aafe7b5f6f2aa893:reference/type_traits/common_type.md</id>
      <updated>2021-05-14T16:46:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/common_type.md b/reference/type_traits/common_type.md
index bc84e9947..8a76a591e 100644
--- a/reference/type_traits/common_type.md
+++ b/reference/type_traits/common_type.md
@@ -38,7 +38,7 @@ namespace std {
 	- `T1,T2`に対する`decay`適用が少なくとも片方が恒等写像とならない（`is_same_v&amp;lt;T1, D1&amp;gt; == false || is_same_v&amp;lt;T2, D2&amp;gt; == false`となる）場合、`type = common_type_t&amp;lt;D1, D2&amp;gt;;`
 	- `common_type&amp;lt;T1, T2&amp;gt;`に対するユーザ定義の特殊化が行われていれば、同特殊化を利用する。
   - `C = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;`が有効な型ならば、`type = C;`
-  - `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_­t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
+  - `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
 	- そうでなければ、メンバ型`type`は定義されない。
 - `N &amp;gt;= 3` : `Types...`の１、2番目の型を`T1, T2`、残りのパラメータパックを`P...`とすると、`type = common_type_t&amp;lt;common_type_t&amp;lt;T1, T2&amp;gt;, P...&amp;gt;;`のように`type`を定義。
 	- 先頭2つの型の共通型を求めて、その型と3番目の型の共通型を求めて、その型と4番目の...というように再帰的に`common_type`を適用していく。
@@ -55,7 +55,7 @@ namespace std {
 `COND-RES`や`CREF`はそれぞれ次のように定義される型を表す説明専用のものである。
 
 - `CREF(X)`
-    - `add_­lvalue_­reference_­t&amp;lt;const remove_­reference_­t&amp;lt;A&amp;gt;&amp;gt;`
+    - `add_lvalue_reference_t&amp;lt;const remove_reference_t&amp;lt;A&amp;gt;&amp;gt;`
 - `COND-REF(X, Y)`
     - `decltype(false ? declval&amp;lt;X(&amp;amp;)()&amp;gt;()() : declval&amp;lt;Y(&amp;amp;)()&amp;gt;()())`
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_type -- common_type: P0898R3反映(C++20)</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/common_type.html"/>
      <id>8a573e3576591d254071659cfa996cb87bfec479:reference/type_traits/common_type.md</id>
      <updated>2021-05-14T16:41:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/common_type.md b/reference/type_traits/common_type.md
index 6397eed10..bc84e9947 100644
--- a/reference/type_traits/common_type.md
+++ b/reference/type_traits/common_type.md
@@ -27,18 +27,19 @@ namespace std {
 ## 効果
 `common_type`は、`Types...`に含まれる全ての型が暗黙変換可能な型を、メンバ型`type`として定義する。
 
-より詳細には、次のように決定される。ただし、C++11では[`decay`](/reference/type_traits/decay.md)を適用するプロセスが、C++14では下記`N == 2`の時のプロセスが、それぞれ行われない。
+より詳細には、次のように決定される。ただし、C++11では[`decay`](/reference/type_traits/decay.md)を適用するプロセスが、C++14では下記`N == 2`の時のプロセスが、C++17では`N == 2`のとき`COND-RES`を適用するプロセスが、それぞれ行われない。
 
 `N = sizeof...(Types)`として
 
 - `N == 0` : メンバ型`type`は定義されない。
 
 - `N == 1` : `Types...`内の唯一の型を`T`とすると、`type = common_type_t&amp;lt;T, T&amp;gt;;`のように`type`を定義。
-- `N == 2` : `Types...`の１、2番目の型を`T1, T2`、`D1 = decay_t&amp;lt;T1&amp;gt;, D2 = decay_t&amp;lt;T2&amp;gt;`として
-	- `T1,T2`に対する`decay`の適用は、少なくとも片方が恒等写像とならない（`is_same_v&amp;lt;T1, D1&amp;gt; &amp;amp;&amp;amp; is_same_v&amp;lt;T2, D2&amp;gt; == false`となる）場合  
-	`type = common_type_t&amp;lt;D1, D2&amp;gt;;`のように`type`を定義。
-	- そうではなく、ユーザ定義の特殊化もない場合、`type = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;;`のように`type`を定義。
-	- 上記の様な型が定義できない場合、メンバ型`type`は定義されない。
+- `N == 2` : `Types...`の1, 2番目の型を`T1, T2`、`D1 = decay_t&amp;lt;T1&amp;gt;, D2 = decay_t&amp;lt;T2&amp;gt;`として
+	- `T1,T2`に対する`decay`適用が少なくとも片方が恒等写像とならない（`is_same_v&amp;lt;T1, D1&amp;gt; == false || is_same_v&amp;lt;T2, D2&amp;gt; == false`となる）場合、`type = common_type_t&amp;lt;D1, D2&amp;gt;;`
+	- `common_type&amp;lt;T1, T2&amp;gt;`に対するユーザ定義の特殊化が行われていれば、同特殊化を利用する。
+  - `C = decay_t&amp;lt;decltype(false ? declval&amp;lt;D1&amp;gt;() : declval&amp;lt;D2&amp;gt;())&amp;gt;`が有効な型ならば、`type = C;`
+  - `COND-RES(CREF(D1), CREF(D2))`が有効な型ならば、`type = decay_­t&amp;lt;COND-RES(CREF(D1), CREF(D2))&amp;gt;;`
+	- そうでなければ、メンバ型`type`は定義されない。
 - `N &amp;gt;= 3` : `Types...`の１、2番目の型を`T1, T2`、残りのパラメータパックを`P...`とすると、`type = common_type_t&amp;lt;common_type_t&amp;lt;T1, T2&amp;gt;, P...&amp;gt;;`のように`type`を定義。
 	- 先頭2つの型の共通型を求めて、その型と3番目の型の共通型を求めて、その型と4番目の...というように再帰的に`common_type`を適用していく。
 
@@ -50,6 +51,15 @@ namespace std {
 - `T1, T2`はともに参照型でもなく
 - `T1, T2`はともにCV修飾もされていない
 
+
+`COND-RES`や`CREF`はそれぞれ次のように定義される型を表す説明専用のものである。
+
+- `CREF(X)`
+    - `add_­lvalue_­reference_­t&amp;lt;const remove_­reference_­t&amp;lt;A&amp;gt;&amp;gt;`
+- `COND-REF(X, Y)`
+    - `decltype(false ? declval&amp;lt;X(&amp;amp;)()&amp;gt;()() : declval&amp;lt;Y(&amp;amp;)()&amp;gt;()())`
+
+
 ## 特殊化
 `common_type`は以下の条件を満たす場合に、2引数のもの（`common_type&amp;lt;T1, T2&amp;gt;`）に限ってユーザー定義の特殊化が許可されている。
 
@@ -168,3 +178,5 @@ struct common_type&amp;lt;T, U, V...&amp;gt; {
 - [LWG Issue 2141. `common_type` trait produces reference types](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2141)
     - C++11では、`common_type`の結果が参照型になる場合があった。C++14で`decay_t`を通すことにしたことにより、参照型が返されることがなくなった。
 - [P0453R1 Resolving LWG Issues re common_type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0435r1.pdf)
+- [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
+    - C++20で`COND-RES`, `CREF`操作を利用するステップが追加された。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>map -- map : pmrエイリアスのコピペミス修正</title>
      <link href="https://cpprefjp.github.io/reference/map/map.html"/>
      <id>aab488fdc01e2159bfca0b6a6dad235ef6b95469:reference/map/map.md</id>
      <updated>2021-05-14T11:12:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map.md b/reference/map/map.md
index ea97bc459..ef886967a 100644
--- a/reference/map/map.md
+++ b/reference/map/map.md
@@ -15,8 +15,8 @@ namespace std {
 
   namespace pmr {
     template &amp;lt;class Key, class T, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
-      using multimap = std::multimap&amp;lt;Key, T, Compare,
-                                     polymorphic_allocator&amp;lt;pair&amp;lt;const Key, T&amp;gt;&amp;gt;&amp;gt;;  // C++17から
+      using map = std::map&amp;lt;Key, T, Compare,
+                           polymorphic_allocator&amp;lt;pair&amp;lt;const Key, T&amp;gt;&amp;gt;&amp;gt;;  // C++17から
   }
 }
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>constexpr関数内で未評価のインラインアセンブリを許可することによる組み込み関数のconstexpr有効化 -- constexpr関数内のasmの許可 : サンプルコードの修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.html"/>
      <id>544cce8d27e65b910d85726bf8bcb2de7c1adb2f:lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.md</id>
      <updated>2021-05-13T16:59:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.md b/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.md
index 027f884a5..69f592443 100644
--- a/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.md
+++ b/lang/cpp20/enabling_constexpr_intrinsics_by_permitting_unevaluated_inline-assembly_in_constexpr_functions.md
@@ -38,16 +38,15 @@ constexpr double inner_product_2d(const double (&amp;amp;v1)[2], const double (&amp;amp;v2)[2])
   if (std::is_constant_evaluated()) {
     dp = v1[0]*v2[0] + v1[1]*v2[1];
   } else {
-    constexpr int imm8 = 0b110001;
     asm volatile (
-      &amp;#34;movlpd %%xmm0, %1;&amp;#34;
-      &amp;#34;movhpd %%xmm0, %2;&amp;#34;
-      &amp;#34;movlpd %%xmm1, %3;&amp;#34;
-      &amp;#34;movhpd %%xmm1, %4;&amp;#34;
-      &amp;#34;dppd %%xmm0, %%xmm1, %5;&amp;#34;
-      &amp;#34;movlpd %0, %%xmm0&amp;#34;
+      &amp;#34;movlpd %1, %%xmm0\n&amp;#34;
+      &amp;#34;movhpd %2, %%xmm0\n&amp;#34;
+      &amp;#34;movlpd %3, %%xmm1\n&amp;#34;
+      &amp;#34;movhpd %4, %%xmm1\n&amp;#34;
+      &amp;#34;dppd $0b110001, %%xmm1, %%xmm0\n&amp;#34;
+      &amp;#34;movlpd %%xmm0, %0\n&amp;#34;
       : &amp;#34;=m&amp;#34;(dp)
-      : &amp;#34;m&amp;#34;(v1[0]), &amp;#34;m&amp;#34;(v1[1]), &amp;#34;m&amp;#34;(v2[0]), &amp;#34;m&amp;#34;(v2[1]), &amp;#34;N&amp;#34;(imm8)
+      : &amp;#34;m&amp;#34;(v1[0]), &amp;#34;m&amp;#34;(v1[1]), &amp;#34;m&amp;#34;(v2[0]), &amp;#34;m&amp;#34;(v2[1])
     );
   }
 
@@ -75,9 +74,7 @@ int main() {
 * is_constant_evaluated[link /reference/type_traits/is_constant_evaluated.md]
 * sqrt2[link /reference/numbers/sqrt2.md]
 
-### 出力例
-
-GCC 11.1 x86-64 `-masm=intel`オプションを設定して実行
+### 出力例（GCC 11.1 x86-64）
 
 ```
 0
@@ -102,4 +99,4 @@ GCC 11.1 x86-64 `-masm=intel`オプションを設定して実行
 
 ## 参照
 
-- [P1668R1 Enabling constexpr Intrinsics By Permitting Unevaluated inline-assembly in constexpr Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1668r1.html)
\ No newline at end of file
+- [P1668R1 Enabling constexpr Intrinsics By Permitting Unevaluated inline-assembly in constexpr Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1668r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>