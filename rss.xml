<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-01-06T14:42:37.615442</updated>
  <id>eb38f679-1d68-45aa-9d05-dd93e1734b34</id>

  
    <entry>
      <title>operator/ -- chrono/month/op_append: リンク付与, 微調整</title>
      <link href="https://cpprefjp.github.io/reference/chrono/month/op_append.html"/>
      <id>a595b0f859327c029153746733b8ff03df088022:reference/chrono/month/op_append.md</id>
      <updated>2022-01-06T10:02:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/month/op_append.md b/reference/chrono/month/op_append.md
index 163d77105..8ef66076c 100644
--- a/reference/chrono/month/op_append.md
+++ b/reference/chrono/month/op_append.md
@@ -33,6 +33,7 @@ namespace std::chrono {
 * month_day[link /reference/chrono/month_day.md]
 * last_spec[link /reference/chrono/last_spec.md]
 * month_day_last[link /reference/chrono/month_day_last.md]
+* month_weekday[link /reference/chrono/month_weekday.md]
 * weekday_indexed[link /reference/chrono/weekday_indexed.md]
 * weekday_last[link /reference/chrono/weekday_last.md]
 * month_weekday_last[link /reference/chrono/month_weekday_last.md]
@@ -55,7 +56,7 @@ namespace std::chrono {
 - (1) : `return {m, d};`
 - (2) : `return m /` [`day`](/reference/chrono/day.md)`{d};`
 - (3) : `return` [`month`](/reference/chrono/month.md)`{m} / d;`
-- (4) : `return `[`month_day_last`](/reference/chrono/month_day_last.md)`{m};`
+- (4) : `return` [`month_day_last`](/reference/chrono/month_day_last.md)`{m};`
 - (5) : `return` [`month`](/reference/chrono/month.md)`{m} /` [`last`](/reference/chrono/last_spec.md)`;`
 - (6) : `return {m, wdi};`
 - (7) : `return` [`month`](/reference/chrono/month.md)`{m} / wdi;`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dangling -- Update dangling.md</title>
      <link href="https://cpprefjp.github.io/reference/ranges/dangling.html"/>
      <id>eda7632ac7db82ab8a061cd15aa0772afad030d9:reference/ranges/dangling.md</id>
      <updated>2021-12-31T16:19:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/dangling.md b/reference/ranges/dangling.md
index 34ef12c01..907a723b1 100644
--- a/reference/ranges/dangling.md
+++ b/reference/ranges/dangling.md
@@ -19,7 +19,9 @@ namespace std::ranges {
 
 `dangling`は、イテレータまたはRangeがダングリングであることを示す型である。
 
-この型のオブジェクトは、イテレータまたはRangeを返す関数において、戻り値のイテレータやRangeがダングリングとなる場合に代わりに返される。
+この型のオブジェクトは、イテレータまたはRangeを返す関数において、戻り値のイテレータやRangeがダングリングとなる場合に代わりに返される(逆は成立しない)。
+
+`dangling`自身はイテレータでもRangeでもないため、呼び出し側でそれらを期待したコードを書いていればコンパイルエラーとなる。その結果、ダングリングイテレータ/Rangeにアクセスするというエラーをコンパイル時に発見することができる。
 
 ## メンバ関数
 ### 構築・破棄
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- サンプルコードの色を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>9235c5656eb04f01581c9b8e12e21dd69ed68c07:reference/algorithm/ranges_search.md</id>
      <updated>2021-12-31T15:54:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index 05d51acd9..11fa1679f 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -60,7 +60,7 @@ int main() {
   }
 }
 ```
-* std::search[color ff0000]
+* std::ranges::search[color ff0000]
 
 #### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search_n -- サンプルコードの色を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search_n.html"/>
      <id>9235c5656eb04f01581c9b8e12e21dd69ed68c07:reference/algorithm/ranges_search_n.md</id>
      <updated>2021-12-31T15:54:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search_n.md b/reference/algorithm/ranges_search_n.md
index 72dd0b3e6..51769626c 100644
--- a/reference/algorithm/ranges_search_n.md
+++ b/reference/algorithm/ranges_search_n.md
@@ -68,7 +68,7 @@ int main() {
   }
 }
 ```
-* std::search_n[color ff0000]
+* std::ranges::search_n[color ff0000]
 * v.begin()[link /reference/vector/vector/begin.md]
 
 ### 出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::adjacent_find/equal/mismatchを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>1e7a4d1a9a47a0b99af0656d2ebb035fb70b40bf:reference/algorithm.md</id>
      <updated>2021-12-31T15:53:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 402c70c67..4dc8bf17e 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -130,11 +130,11 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::find_if_not`](algorithm/ranges_find_if_not.md)     | 条件を満たしていない最初の要素を検索する             | C++20 |
 | [`ranges::find_end`](algorithm/ranges_find_end.md)           | 指定された最後のサブシーケンスを検索する             | C++20 |
 | [`ranges::find_first_of`](algorithm/ranges_find_first_of.md) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
-| [`ranges::adjacent_find`](algorithm/ra.nolinknges_adjacent_find.md.nolink) | 隣接する要素で条件を満たしている最初の要素を検索する | C++20 |
+| [`ranges::adjacent_find`](algorithm/ranges_adjacent_find.md) | 隣接する要素で条件を満たしている最初の要素を検索する | C++20 |
 | [`ranges::count`](algorithm/ranges_count.md)                 | 指定された値である要素の数を数える                   | C++20 |
 | [`ranges::count_if`](algorithm/ranges_count_if.md)           | 条件を満たしている要素の数を数える                   | C++20 |
-| [`ranges::mismatch`](algorithm/ranges_mismatch.md.nolink)           | 2つの範囲が一致していない場所を検索する              | C++20 |
-| [`ranges::equal`](algorithm/ranges_equal.md.nolink)                 | 2つの範囲を等値比較する                              | C++20 |
+| [`ranges::mismatch`](algorithm/ranges_mismatch.md)           | 2つの範囲が一致していない場所を検索する              | C++20 |
+| [`ranges::equal`](algorithm/ranges_equal.md)                 | 2つの範囲を等値比較する                              | C++20 |
 | [`ranges::search`](algorithm/ranges_search.md)               | 指定された最初のサブシーケンスを検索する             | C++20 |
 | [`ranges::search_n`](algorithm/ranges_search_n.md)           | 指定された最初のサブシーケンスを検索する             | C++20 |
 | [`ranges::starts_with`](algorithm/ranges_starts_with.md.nolink)     | 先頭が指定されたシーケンスと一致するかを調べる       | C++23 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_find -- ranges::adjacent_find/equal/mismatchを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>1e7a4d1a9a47a0b99af0656d2ebb035fb70b40bf:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2021-12-31T15:53:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
index 75d6bcd9f..44f88300c 100644
--- a/reference/algorithm/ranges_adjacent_find.md
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -13,20 +13,33 @@ namespace std::ranges {
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});
 }
 ```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- identity[link /reference/functional/identity.md]
+- indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+- projected[link /reference/iterator/projected.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
+
 
 ## 概要
 隣接する要素で条件を満たしている最初の要素を検索する。
 
 
 ## 戻り値
-`[first,last)` 内にあるイテレータ i について、`*i == *(i + 1)` もしくは `pred(*i, *(i + 1)) != false` であるような最初のイテレータを返す。
+`[first,last)` 内にあるイテレータ i について、[`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *(i + 1))) != false` であるような最初のイテレータを返す。
 
 もしそのようなイテレータが見つからなかった場合は `last` を返す。
 
 
 ## 計算量
-- (1), (2) : 与えられたシーケンスが空でない場合、正確に [`min`](/reference/algorithm/min.md)`((i - first) + 1, (last - first) - 1)` 回（`i` は `adjacent_find` の戻り値）の比較または述語が適用される
-- (3), (4) : O`(last - first)`の計算量の回数だけ比較または述語が適用される
+与えられたシーケンスが空でない場合、正確に [`min`](/reference/algorithm/min.md)`((i - first) + 1, (last - first) - 1)` 回（`i` は `adjacent_find` の戻り値）の比較または述語が適用される
 
 
 ## 例
@@ -40,16 +53,17 @@ int main() {
   std::vector&amp;lt;int&amp;gt; v = { 1,4,3,3,1,2,2 };
 
   // 同じ値が連続している最初の要素を検索する
-  auto it = std::adjacent_find(v.begin(), v.end());
+  auto it = std::ranges::adjacent_find(v);
   if (it == v.end()) {
     std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
   } else {
-    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::ranges::distance(v.begin(), it) &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; &amp;#34;*it == *(it+1): &amp;#34; &amp;lt;&amp;lt; (*it == *(it+1)) &amp;lt;&amp;lt; std::endl;
   }
 }
 ```
-* adjacent_find[color ff0000]
+* std::ranges::distance[link /reference/iterator/ranges_distance.md]
+* std::ranges::adjacent_find[color ff0000]
 
 ### 出力
 ```
@@ -59,35 +73,41 @@ found: index==2
 
 ## 実装例
 ```cpp
-template &amp;lt;class ForwardIterator&amp;gt;
-ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last)
-{
-  if (first == last)
-    return last;
-
-  ForwardIterator next = first;
-  ++next;
-  for ( ; next != last; ++next, ++first)
-    if (*first == *next)
-      return first;
-  return last;
-}
-
-template &amp;lt;class ForwardIterator, class BinaryPredicate&amp;gt;
-ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred)
-{
-  if (first == last)
+struct adjacent_find_impl {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr I adjacent_find(I first, S last, Pred pred = {}, Proj proj = {}) {
+    if (first == last)
+      return last;
+
+    I next = first;
+    ++next;
+    for ( ; next != last; ++next, ++first)
+      if (invoke(pred, invoke(proj, *first), invoke(proj, *next)))
+        return first;
     return last;
+  }
 
-  ForwardIterator next = first;
-  ++next;
+  template&amp;lt;forward_range R, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {}) {
+    return (*this)(begin(r), end(r), ref(pred), ref(proj));
+  }
+};
 
-  for ( ; next != last; ++next, ++first)
-    if (pred(*first, *next))
-      return first;
-  return last;
-}
+inline constexpr adjacent_find_impl adjacent_find;
 ```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- identity[link /reference/functional/identity.md]
+- indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+- projected[link /reference/iterator/projected.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- ranges::adjacent_find/equal/mismatchを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>1e7a4d1a9a47a0b99af0656d2ebb035fb70b40bf:reference/algorithm/ranges_equal.md</id>
      <updated>2021-12-31T15:53:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
index b69439f59..bf491598e 100644
--- a/reference/algorithm/ranges_equal.md
+++ b/reference/algorithm/ranges_equal.md
@@ -12,38 +12,35 @@ namespace std::ranges {
 
   template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool equal(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});}
+  constexpr bool equal(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+}
 ```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- input_range[link /reference/ranges/input_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
 
 ## 概要
 2つの範囲を等値比較する。
 
-- (1) : 範囲`[first1, last1)`と範囲`[first2, first2 + (last1 - first1))`が等値かを判定する
-- (2) : (1)の等値比較を任意の2引数関数オブジェクトで行う
-- (3) : 範囲`[first1, last1)`と範囲`[first2, last2)`が等値かを判定する
-- (4) : (3)の等値比較を任意の2引数関数オブジェクトで行う
-
-2つの範囲が異なる要素数であった場合、`false`を返す。
-
-2つの範囲が要素数および各要素が等値であった場合、`true`を返す。
-
+2つの範囲の要素数および各要素が等値であった場合、`true`を返す。
 
 ## 戻り値
-`last2` が与えられている形式の場合、もし `last1 - first1 != last2 - first2` であれば、`false` を返す。  
-そうでない場合、`[first1,last1)` 内のイテレータ `i` について、`*i == *(first2 + (i - first1))` もしくは `pred(*i, *(first2 + (i - first1))) != false` が全てのイテレータ `i` について満たされているのであれば `true` を返す。  
-そうでない場合は `false` を返す。
+2つの範囲の長さを定数時間で求められ、もし `last1 - first1 != last2 - first2` であれば、`false` を返す。
 
+そうでない場合、`[first1,last1)` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj1, *i), `[`invoke`](/reference/functional/invoke.md)`(proj2, *(first2 + (i - first1)))) != false` が全てのイテレータ `i` について満たされているのであれば `true` を返す。  
+そうでない場合は `false` を返す。
 
 ## 計算量
-`last2` が与えられていない形式では、`last2 = first2 + (last1 - first1)`であるとして説明する。
-
-- (1), (2), (3), (4) : `InputIterator1` と `InputIterator2` が共にランダムアクセスイテレータの要件を満たす場合で、かつ、`last1 - first1 != last2 - first2` の場合、1 度も比較または述語は適用されない。そうでない場合、最大で `min(last1 - first1, last2 - first2)` 回の比較または述語が適用される。
-- (5), (6), (7), (8) : `ForwardIterator1` と `ForwardIterator2` が共にランダムアクセスイテレータの要件を満たす場合で、かつ、`last1 - first1 != last2 - first2` の場合、1 度も比較または述語は適用されない。そうでない場合、O(`min(last1 - first1, last2 - first2)`) の計算量で比較または述語が適用される。
-
-
-## 備考
-- ランダムアクセスイテレータの範囲を使用する場合、状況によっては(1) (2)のバージョンよりも、(3) (4)を使用する方が効率がよくなることが期待できる。ランダムアクセスイテレータはイテレータ同士の差を定数時間で求められるため、イテレーションを行うことなく2つの範囲の要素数が異なることを検出できるためである
 
+最大で `min(last1 - first1, last2 - first2)` 回の述語が適用される。ただし、2つの範囲の長さを定数時間で求められ、かつ、長さが異なる場合、1 度も述語は適用されない。
 
 ## 例
 ```cpp example
@@ -58,16 +55,15 @@ int main() {
   std::array&amp;lt;int, 6&amp;gt; v2 = { 1,2,3,4,2,1 };
 
   // コンテナの中身が同じかどうか調べる
-  bool result = std::equal(std::begin(v), std::end(v), std::begin(v2), std::end(v2));
+  bool result = std::ranges::equal(v, v2);
   std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
 
   // x±1 の誤差を許すようにする
-  bool result2 = std::equal(std::begin(v), std::end(v), std::begin(v2), std::end(v2),
-                            [](int x, int y) { return x - 1 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt;= x + 1; });
+  bool result2 = std::ranges::equal(v, v2, [](int x, int y) { return x - 1 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt;= x + 1; });
   std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; result2 &amp;lt;&amp;lt; std::endl;
 }
 ```
-* std::equal[color ff0000]
+* std::ranges::equal[color ff0000]
 
 ### 出力
 ```
@@ -77,66 +73,43 @@ true
 
 
 ## 実装例
-```cpp
-template&amp;lt;class InputIterator1, class InputIterator2&amp;gt;
-bool equal(InputIterator1 first1, InputIterator1 last1,
-           InputIterator2 first2) {
-  for ( ; first1 != last1; ++first1, ++first2)
-    if (!bool(*first1 == *first2))
-      return false;
-  return true;
-}
-
-template&amp;lt;class InputIterator1, class InputIterator2, class BinaryPredicate&amp;gt;
-bool equal(InputIterator1 first1, InputIterator1 last1,
-           InputIterator2 first2, BinaryPredicate pred) {
-  for ( ; first1 != last1; ++first1, ++first2)
-    if (!bool(pred(*first1, *first2)))
-      return false;
-  return true;
-}
 
-# if __cplusplus &amp;gt;= 201402L
-
-template&amp;lt;class RandomAccessIterator1, class RandomAccessIterator2, class BinaryPredicate&amp;gt;
-inline bool equal_impl(RandomAccessIterator1 first1, RandomAccessIterator1 last1,
-                       RandomAccessIterator2 first2, RandomAccessIterator2 last2,
-                       BinaryPredicate pred,
-                       random_access_iterator_tag, random_access_iterator_tag) {
-  if (last1 - first1 != last2 - first2)
-    return false;
-  return std::equal(first1, last1, first2, pred);
-}
-
-template&amp;lt;class InputIterator1, class InputIterator2, class BinaryPredicate&amp;gt;
-bool equal_impl(InputIterator1 first1, InputIterator1 last1,
-                InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred,
-                input_iterator_tag, input_iterator_tag) {
-  for ( ; first1 != last1 &amp;amp;&amp;amp; first2 != last2; ++first1, ++first2)
-    if (!bool(pred(*first1, *first2)))
-      return false;
-  return first1 == last1 &amp;amp;&amp;amp; first2 == last2;
-}
-
-template&amp;lt;class InputIterator1, class InputIterator2, class BinaryPredicate&amp;gt;
-inline bool equal(InputIterator1 first1, InputIterator1 last1,
-                  InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred) {
-  return equal_impl(first1, last1, first2, last2, pred,
-                    typename iterator_traits&amp;lt;InputIterator1&amp;gt;::iterator_category(),
-                    typename iterator_traits&amp;lt;InputIterator2&amp;gt;::iterator_category());
-}
+```cpp
+struct equal_impl {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    if constexpr (sized_sentinel_for&amp;lt;S1, I1&amp;gt; &amp;amp;&amp;amp; sized_sentinel_for&amp;lt;S2, I2&amp;gt;)
+      if (distance(first1, last1) != distance(first2, last2))
+        return false;
+    for ( ; first1 != last1 &amp;amp;&amp;amp; first2 != last2; ++first1, ++first2)
+      if (!bool(invoke(pred, invoke(proj1, *first1), invoke(proj2, *first2))))
+        return false;
+    return true;
+  }
 
-template&amp;lt;class InputIterator1, class InputIterator2&amp;gt;
-inline bool equal(InputIterator1 first1, InputIterator1 last1,
-                  InputIterator2 first2, InputIterator2 last2) {
-  return std::equal(first1, last1, first2, last2, equal_to&amp;lt;&amp;gt;());
-}
+  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
 
-# endif
+inline constexpr equal_impl equal;
 ```
-* ranges::equal_to[link ../functional/ranges_equal_to.md]
-* iterator_traits[link ../iterator/iterator_traits.md]
-
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- input_range[link /reference/ranges/input_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+- distance[link /reference/iterator/ranges_distance.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- ranges::adjacent_find/equal/mismatchを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>1e7a4d1a9a47a0b99af0656d2ebb035fb70b40bf:reference/algorithm/ranges_mismatch.md</id>
      <updated>2021-12-31T15:53:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index a87cd7439..3ff9af144 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -5,37 +5,51 @@
 * cpp20[meta cpp]
 
 ```cpp
-namespace std {
+namespace std::ranges {
+  template&amp;lt;class I1, class I2&amp;gt;
+  using mismatch_result = in_in_result&amp;lt;I1, I2&amp;gt;; // (1)
+
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr ranges::mismatch_result&amp;lt;I1, I2&amp;gt; mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr mismatch_result&amp;lt;I1, I2&amp;gt; mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                      // (2)
 
   template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; mismatch(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; mismatch(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    // (3)
 }
 ```
-* pair[link /reference/utility/pair.md]
+- in_fun_result[link ranges_in_fun_result.md.nolink]
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- subrange[link /reference/ranges/subrange.md]
+- input_range[link /reference/ranges/input_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
 
 
 ## 概要
 2つのシーケンスが一致していない場所を検索する。
 
-
 ## 戻り値
-`last2`が渡されなかった場合は、`last2 = first2 + (last1 - first1)`とする。
+戻り値の型 `mismatch_result` は2つのイテレータからなるtuple-likeな型である。
 
 `[first1,last1)` 内にあるイテレータ `i` と、`j == first2 + (i - first1)` であるイテレータ `j` について、
 
 - `j`が範囲`[first2, last2)`に含まれており、
 - `!(*i == *j)` もしくは
-- `pred(*i, *j) == false` であるような、最初のイテレータのペアを返す。
-
-そのようなイテレータが見つからなかった場合は `last1` と `first2 + (last1 - first1)` のペアを返す。
+- [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj1, *i), `[`invoke`](/reference/functional/invoke.md)`(proj2, *j)) == false` であるような、最初のイテレータのペア `{i, j}` を返す。
 
+そのようなイテレータが見つからなかった場合は `{last1, first2 + (last1 - first1)}` を返す。
 
 ## 計算量
-最大で `last1 - first1` 回の対応する比較もしくは述語が適用される。
+最大で `last1 - first1` 回の対応する述語が適用される。
 
 
 ## 例
@@ -49,11 +63,11 @@ namespace std {
 #include &amp;lt;string&amp;gt;   // for to_string
 
 // mismatch の結果で得られた pair に対する情報を出力する
-template &amp;lt;class Range1, class Range2, class Pair&amp;gt;
-void print_mismatch_value(const Range1&amp;amp; r1, const Range2&amp;amp; r2, const Pair&amp;amp; p) {
-  std::cout &amp;lt;&amp;lt; &amp;#34;mismatch index: &amp;#34; &amp;lt;&amp;lt; std::distance(std::begin(r1), p.first) &amp;lt;&amp;lt; std::endl;
-  std::cout &amp;lt;&amp;lt; &amp;#34;mismatch value: (&amp;#34; &amp;lt;&amp;lt; (std::end(r1) == p.first  ? &amp;#34;end&amp;#34; : std::to_string(*p.first)) &amp;lt;&amp;lt; &amp;#34;,&amp;#34;
-                                   &amp;lt;&amp;lt; (std::end(r2) == p.second ? &amp;#34;end&amp;#34; : std::to_string(*p.second)) &amp;lt;&amp;lt; &amp;#34;)&amp;#34;
+template &amp;lt;class Range1, class Range2, class I1, class I2&amp;gt;
+void print_mismatch_value(const Range1&amp;amp; r1, const Range2&amp;amp; r2, const I1&amp;amp; i1, const I2&amp;amp; i2) {
+  std::cout &amp;lt;&amp;lt; &amp;#34;mismatch index: &amp;#34; &amp;lt;&amp;lt; std::ranges::distance(std::begin(r1), i1) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;mismatch value: (&amp;#34; &amp;lt;&amp;lt; (std::ranges::end(r1) == i1 ? &amp;#34;end&amp;#34; : std::to_string(*i1)) &amp;lt;&amp;lt; &amp;#34;,&amp;#34;
+                                   &amp;lt;&amp;lt; (std::ranges::end(r2) == i2 ? &amp;#34;end&amp;#34; : std::to_string(*i2)) &amp;lt;&amp;lt; &amp;#34;)&amp;#34;
             &amp;lt;&amp;lt; std::endl;
 }
 
@@ -63,15 +77,19 @@ int main() {
   const std::list&amp;lt;int&amp;gt;     v3 = { 1,2,3,4,3, };
 
   // v と v2 で異なる場所を探す
-  auto pair = std::mismatch(v.begin(), v.end(), v2.begin());
-  print_mismatch_value(v, v2, pair);
+  {
+    auto [i1, i2] = std::ranges::mismatch(v, v2);
+    print_mismatch_value(v, v2, i1, i2);
+  }
 
   std::cout &amp;lt;&amp;lt; std::endl;
 
   // v と v3 で異なる場所を探す。
   // v.size() &amp;gt; v3.size() なので mismatch(v.begin(), v.end(), v3.begin()) とやってはいけない。
-  auto pair2 = std::mismatch(v3.begin(), v3.end(), v.begin());
-  print_mismatch_value(v3, v, pair2);
+  {
+    auto [i1, i2] = std::mismatch(v3.begin(), v3.end(), v.begin());
+    print_mismatch_value(v3, v, i1, i2);
+  }
 }
 ```
 * std::mismatch[color ff0000]
@@ -89,24 +107,39 @@ mismatch value: (end,2)
 
 ## 実装例
 ```cpp
-template &amp;lt;class InputIterator1, class InputIterator2&amp;gt;
-std::pair&amp;lt;InputIterator1, InputIterator2&amp;gt; mismatch(
-  InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) {
-  for ( ; first1 != last1; ++first1, ++first2)
-    if (!bool(*first1 == *first2))
-      return std::make_pair(first1, first2);
-  return std::make_pair(first1, first2);
-}
+struct mismatch_impl {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr ranges::mismatch_result&amp;lt;I1, I2&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    for ( ; first1 != last1 &amp;amp;&amp;amp; first != last2; ++first1, ++first2)
+      if (!bool(invoke(pred, invoke(proj1, *first1), invoke(proj2, *first2))))
+        return {first1, first2};
+    return {first1, first2};
+  }
 
-template &amp;lt;class InputIterator1, class InputIterator2, class BinaryPredicate&amp;gt;
-std::pair&amp;lt;InputIterator1, InputIterator2&amp;gt; mismatch(
-  InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred) {
-  for ( ; first1 != last1; ++first1, ++first2)
-    if (!bool(pred(*first1, *first2)))
-      return std::make_pair(first1, first2);
-  return std::make_pair(first1, first2);
-}
+  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
+
+inline constexpr mismatch_impl mismatch;
 ```
+- in_fun_result[link ranges_in_fun_result.md.nolink]
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- subrange[link /reference/ranges/subrange.md]
+- input_range[link /reference/ranges/input_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- 射影のサンプルコードを修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>1e6ca6878c1517e4f82d157330b7c7d6828e10a4:reference/algorithm.md</id>
      <updated>2021-12-31T12:33:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index e587845e4..402c70c67 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -93,10 +93,11 @@ sort(pv.begin(), pv.end(), [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b){ return a.name &amp;lt; b.name; });
 
 ```cpp
 // デフォルトの述語({})で、nameでソート
-ranges::sort(pv.begin(), pv.end(), {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
-// Rangeを渡す
 ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
+// std::invokeで呼び出されるため、メンバ変数ポインタでもよい
+ranges::sort(pv, {}, &amp;amp;Parson::name);
 ```
+* std::invoke[link /reference/functional/invoke.md]
 
 ## シーケンスを変更しない操作
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>