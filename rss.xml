<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-03-01T03:49:58.696319</updated>
  <id>359a0728-6185-401c-9190-d6fa06aa324e</id>

  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 暗黙ムーブ : 経緯を追加 #1021</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>8384e0bb49cce5acc30eca4215df91ecd554eddb:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-03-01T12:46:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index f61ff2f24..dc7b5733b 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -207,6 +207,20 @@ auto g(bool b) -&amp;gt; Weird {
 }
 ```
 
+```cpp
+// ムーブしないことを明示する関数、C++20までは使用可能
+template&amp;lt;typename T&amp;gt;
+auto unmove(T&amp;amp;&amp;amp; v) -&amp;gt; T&amp;amp; {
+  return v; // C++23からng、vはxvalue
+}
+
+// C++23では次のように修正する必要がある
+template&amp;lt;typename T&amp;gt;
+auto unmove(T&amp;amp;&amp;amp; v) -&amp;gt; T&amp;amp; {
+  return static_cast&amp;lt;T&amp;amp;&amp;gt;(v); // ok、キャスト式はムーブする資格のある式ではない
+}
+```
+
 ```cpp
 // 例示用のムーブ可能な型
 struct Widget {
@@ -284,15 +298,48 @@ auto f10(J x) -&amp;gt; Widget&amp;amp; {
 ```
 
 ## この機能が必要になった背景・経緯
-(執筆中)
 
-## 検討されたほかの選択肢
-(執筆中)
+C++20までは戻り値型が参照型である場合に暗黙ムーブが行われていなかった。より正確には、関数戻り値の初期化時に戻り値構築のためのコンストラクタを選択するオーバーロード解決が行われる場合にのみ、暗黙ムーブが考慮されていたが、戻り値型が参照型の場合は参照の初期化だけが起こりコンストラクタ呼び出しは関与しないため暗黙ムーブは考慮されていなかった。
+
+これによって、同じ`return`文でも戻り値型が異なることでそのオペランドの扱いが変化してしまっていた。
+
+```cpp
+// Widget, RRefTakerは上の例を参照
+// どちらも、C++20の場合
+
+auto f(Widget&amp;amp;&amp;amp; w) -&amp;gt; RRefTaker {
+  return w;  // ok、wは右辺値として扱われる
+}
+
+auto g(Widget&amp;amp;&amp;amp; w) -&amp;gt; Widget&amp;amp;&amp;amp; {
+  return w;  // ng、wは左辺値として扱われる
+}
+```
+
+この非一貫性を解消することがまず求められていた。
+
+また、C++20時点の暗黙ムーブの使用は二段階のオーバーロード解決を行う複雑なものであり、暗黙ムーブが行われるかどうかについて実装間で挙動に差異が生じていた。
+
+C++20の仕様は次のようになっていた。
+
+暗黙ムーブ可能なエンティティが次のコピー初期化が行われる場所で指名されている場合、コピーの代わりにムーブが使用される場合がある
+
+- `return/co_return`文のオペランド
+    - （諸条件はC++23仕様と同一なので省略）
+- `throw`式のオペランド
+    - （諸条件はC++23仕様と同一なので省略）
+
+これらのコピー初期化が行われる場所において、呼び出されるコンストラクタまたは[`return_­value()`オーバーロード](/lang/cpp20/coroutines.md)を選択するオーバーロード解決は次の順序で実行される
+
+1. オペランドのid式を右辺値（*rvalue*）としてオーバーロード解決を実行する
+2. 1が失敗した（もしくは行われなかった）場合、オペランドのid式を左辺値（*lvalue*）としてオーバーロード解決を実行する
+
+この最後の手順の1回目のオーバーロード解決時にコピーコンストラクタの代わりにムーブコンストラクタが選択されることによって、C++20の暗黙ムーブは達成されていた。しかし、この手順2における「失敗」という言葉の意味が明確ではなく、それによって実装間で暗黙ムーブが行われるかどうか、あるいは選択されるコンストラクタに差異が生じていた。
 
-## 関連項目
-(執筆中)
+`return`文オペランドの扱いの戻り値型の違いによる非一貫性と、使用の複雑さと曖昧さによる実装間の差異の2つの問題を解決するために、C++23ではムーブする資格がある式という概念を用いて暗黙ムーブの仕様が単純化された。
 
 ## 参照
 
 - [P2266R3 Simpler implicit move](https://wg21.link/p2266r3)
-- [The Complete Guide to `return x;` - Arthur O&amp;#39;Dwyer - [CppNow 2021] - YouTube](https://www.youtube.com/watch?v=OGKAJD7bmr8)
\ No newline at end of file
+- [The Complete Guide to `return x;` - Arthur O&amp;#39;Dwyer - [CppNow 2021] - YouTube](https://www.youtube.com/watch?v=OGKAJD7bmr8)
+- [c++ - Does c++23 break unmove - Stack Overflow](https://stackoverflow.com/questions/76647046/does-c23-break-unmove)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>const_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/const_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/const_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/const_pointer_cast.md b/reference/memory/shared_ptr/const_pointer_cast.md
index 6df15cd64..628c1ad98 100644
--- a/reference/memory/shared_ptr/const_pointer_cast.md
+++ b/reference/memory/shared_ptr/const_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dynamic_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/dynamic_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/dynamic_pointer_cast.md b/reference/memory/shared_ptr/dynamic_pointer_cast.md
index aa1c77dff..ae416865b 100644
--- a/reference/memory/shared_ptr/dynamic_pointer_cast.md
+++ b/reference/memory/shared_ptr/dynamic_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reinterpret_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/reinterpret_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/reinterpret_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/reinterpret_pointer_cast.md b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
index 9054ca33f..81c9ba5c2 100644
--- a/reference/memory/shared_ptr/reinterpret_pointer_cast.md
+++ b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>static_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/static_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/static_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/static_pointer_cast.md b/reference/memory/shared_ptr/static_pointer_cast.md
index 5514da616..9bed817c3 100644
--- a/reference/memory/shared_ptr/static_pointer_cast.md
+++ b/reference/memory/shared_ptr/static_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>const_pointer_cast -- typo: 動作未定義 -&gt; 未定義動作</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/const_pointer_cast.html"/>
      <id>fc76618bd1e1be1d071a19d7c5ee3c462e56e494:reference/memory/shared_ptr/const_pointer_cast.md</id>
      <updated>2024-02-29T23:21:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/const_pointer_cast.md b/reference/memory/shared_ptr/const_pointer_cast.md
index 6df15cd64..628c1ad98 100644
--- a/reference/memory/shared_ptr/const_pointer_cast.md
+++ b/reference/memory/shared_ptr/const_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ToruNiina</name>
        <email>niina.toru.68u@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dynamic_pointer_cast -- typo: 動作未定義 -&gt; 未定義動作</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html"/>
      <id>fc76618bd1e1be1d071a19d7c5ee3c462e56e494:reference/memory/shared_ptr/dynamic_pointer_cast.md</id>
      <updated>2024-02-29T23:21:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/dynamic_pointer_cast.md b/reference/memory/shared_ptr/dynamic_pointer_cast.md
index aa1c77dff..ae416865b 100644
--- a/reference/memory/shared_ptr/dynamic_pointer_cast.md
+++ b/reference/memory/shared_ptr/dynamic_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ToruNiina</name>
        <email>niina.toru.68u@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reinterpret_pointer_cast -- typo: 動作未定義 -&gt; 未定義動作</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/reinterpret_pointer_cast.html"/>
      <id>fc76618bd1e1be1d071a19d7c5ee3c462e56e494:reference/memory/shared_ptr/reinterpret_pointer_cast.md</id>
      <updated>2024-02-29T23:21:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/reinterpret_pointer_cast.md b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
index 9054ca33f..81c9ba5c2 100644
--- a/reference/memory/shared_ptr/reinterpret_pointer_cast.md
+++ b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ToruNiina</name>
        <email>niina.toru.68u@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>static_pointer_cast -- typo: 動作未定義 -&gt; 未定義動作</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/static_pointer_cast.html"/>
      <id>fc76618bd1e1be1d071a19d7c5ee3c462e56e494:reference/memory/shared_ptr/static_pointer_cast.md</id>
      <updated>2024-02-29T23:21:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/static_pointer_cast.md b/reference/memory/shared_ptr/static_pointer_cast.md
index 5514da616..9bed817c3 100644
--- a/reference/memory/shared_ptr/static_pointer_cast.md
+++ b/reference/memory/shared_ptr/static_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>ToruNiina</name>
        <email>niina.toru.68u@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 表周りの修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>6b609be2bb6e9f3c160836055074b5092bee1b8a:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-02-29T12:18:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index ad6937ee1..f61ff2f24 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -168,9 +168,9 @@ auto f() -&amp;gt; int&amp;amp;&amp;amp; {
 
 |関数宣言と`return`文|C++20まで|C++23から|備考|
 |---|:-:|:-:|---|
-|`auto f(T x) -&amp;gt; decltype(x) { return x; }`       |`T` : 〇|`T` : 〇||
+|`auto f(T x) -&amp;gt; decltype(x) { return x; }`       |`T` : 〇| ― ||
 |`auto f(T x) -&amp;gt; decltype((x)) { return (x); }`   |`T&amp;amp;` : 〇|`T&amp;amp;` : **×**|ローカル参照を返していた|
-|`auto f(T x) -&amp;gt; decltype(auto) { return x; }`    |`T` : 〇|`T` : 〇||
+|`auto f(T x) -&amp;gt; decltype(auto) { return x; }`    |`T` : 〇| ― ||
 |`auto f(T x) -&amp;gt; decltype(auto) { return (x); }`  |`T&amp;amp;` : 〇|**`T&amp;amp;&amp;amp;` :** 〇|ローカル参照を返す|
 |`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; decltype(x) { return x; }`     |`T&amp;amp;&amp;amp;` : ×|`T&amp;amp;&amp;amp;` : **〇**||
 |`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; decltype((x)) { return (x); }` |`T&amp;amp;` : 〇|`T&amp;amp;` : **×**||
@@ -181,7 +181,11 @@ auto f() -&amp;gt; int&amp;amp;&amp;amp; {
 |`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; auto&amp;amp;&amp;amp; { return x; }`       |`T&amp;amp;` : 〇|**`T&amp;amp;&amp;amp;` :** 〇|`x`がローカル変数の場合ローカル参照を返す|
 |`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; auto&amp;amp;&amp;amp; { return (x); }`   |`T&amp;amp;` : 〇|**`T&amp;amp;&amp;amp;` :** 〇|`x`がローカル変数の場合ローカル参照を返す|
 
-右側2列の各項目内は、推論される戻り値型:コンパイル可否、のように記述しており、コンパイル可否は、〇が適格（コンパイルが通る）、×が不適格（コンパイルエラー）を表す。
+表の中2列の各項目内は、推論される戻り値型:コンパイル可否、のように記述している。また、表中の記号の意味は次のとおり
+
+- 〇 : 適格（コンパイルが通る）
+- × : 不適格（コンパイルエラー）
+- ― : 変化なし
 
 ## 例
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 暗黙的なムーブを簡略化 : サンプルコードの追加 #1021</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>ac864c9c9e78e30dd493f72b974688304ce40d59:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-02-29T12:06:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index 0596df0c1..ad6937ee1 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -21,12 +21,12 @@ struct RRefTaker {
 
 auto example1(Widget w) -&amp;gt; RRefTaker {
   // ローカル変数の暗黙ムーブ
-  return w;  // ok、C++11(CWG1579)から
+  return w;  // ok、C++11から
 }
 
 auto example2(Widget&amp;amp;&amp;amp; w) -&amp;gt; RRefTaker {
   // ローカル右辺値参照の暗黙ムーブ
-  return w;  // ok、C++20(P0527)から
+  return w;  // ok、C++20から
 }
 
 auto example3(Widget&amp;amp;&amp;amp; w) -&amp;gt; Widget&amp;amp;&amp;amp; {
@@ -96,7 +96,9 @@ auto g(int n) -&amp;gt; auto&amp;amp;&amp;amp; {
 
 `auto&amp;amp;&amp;amp;`による戻り値型推論は`decltype`と推論方法が異なるものの、やはり`return`文のオペランドの値カテゴリに応じて参照修飾が決定されるため、従来左辺値（*lvalue*）だったオペランドがC++23でムーブする資格がある式となる場合に、値カテゴリが*xvalue*となることによって推論結果が変化する。
 
-この他の場合には結果は変化しない。
+ただし、変更に関わらず、この例のような関数はどちらもローカル変数への参照を返すものであるため、書くべきではない。
+
+戻り値型推論においては、この他の場合には結果は変化しない。
 
 ```cpp
 auto f1(int n) -&amp;gt; decltype(auto) {
@@ -172,7 +174,7 @@ auto f() -&amp;gt; int&amp;amp;&amp;amp; {
 |`auto f(T x) -&amp;gt; decltype(auto) { return (x); }`  |`T&amp;amp;` : 〇|**`T&amp;amp;&amp;amp;` :** 〇|ローカル参照を返す|
 |`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; decltype(x) { return x; }`     |`T&amp;amp;&amp;amp;` : ×|`T&amp;amp;&amp;amp;` : **〇**||
 |`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; decltype((x)) { return (x); }` |`T&amp;amp;` : 〇|`T&amp;amp;` : **×**||
-|`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; decltype(auto) { return x; }`  |`T&amp;amp;&amp;amp;` : ×|`T&amp;amp;&amp;amp;` : **〇**|`x`がローカル変数の場合ローカル参照を返す|
+|`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; decltype(auto) { return x; }`  |`T&amp;amp;&amp;amp;` : ×|`T&amp;amp;&amp;amp;` : **〇**|`x`がローカル変数の場合ローカル参照を返すようになる|
 |`auto f(T&amp;amp;&amp;amp; x) -&amp;gt; decltype(auto) { return (x); }`|`T&amp;amp;` : 〇|**`T&amp;amp;&amp;amp;` :** 〇|`x`がローカル変数の場合ローカル参照を返す|
 |`auto f(T x) -&amp;gt; auto&amp;amp;&amp;amp; { return x; }`       |`T&amp;amp;` : 〇|**`T&amp;amp;&amp;amp;` :** 〇|ローカル参照を返す|
 |`auto f(T x) -&amp;gt; auto&amp;amp;&amp;amp; { return (x); }`   |`T&amp;amp;` : 〇|**`T&amp;amp;&amp;amp;` :** 〇|ローカル参照を返す|
@@ -182,32 +184,100 @@ auto f() -&amp;gt; int&amp;amp;&amp;amp; {
 右側2列の各項目内は、推論される戻り値型:コンパイル可否、のように記述しており、コンパイル可否は、〇が適格（コンパイルが通る）、×が不適格（コンパイルエラー）を表す。
 
 ## 例
-(執筆中)
 
-```cpp example
-// (ここには、言語機能の使い方を解説するための、サンプルコードを記述します。)
-// (インクルードとmain()関数を含む、実行可能なサンプルコードを記述してください。そのようなコードブロックにはexampleタグを付けます。)
+```cpp
+struct Weird {
+  Weird();
+  Weird(Weird&amp;amp;);
+};
 
-#include &amp;lt;iostream&amp;gt;
+auto g(bool b) -&amp;gt; Weird {
+  static Weird w1;
+  Weird w2;
 
-int main()
-{
-  int variable = 0;
-  std::cout &amp;lt;&amp;lt; variable &amp;lt;&amp;lt; std::endl;
+  if (b) {
+    return w1;  // ok、w1はムーブする資格のある式ではなく、Weird(Weird&amp;amp;)が呼ばれる
+  } else {
+    return w2;  // ng、w2はムーブする資格のある式であり、xvalue（Weird&amp;amp;&amp;amp;）となる
+  }
 }
 ```
-* variable[color ff0000]
 
-(コードブロック中の識別子に、文字色を付ける例です。)
+```cpp
+// 例示用のムーブ可能な型
+struct Widget {
+  Widget(Widget&amp;amp;&amp;amp;);
+};
 
-### 出力
-```
-0
-```
+auto f1(Widget w) -&amp;gt; Widget {
+  return w;  // ローカル変数の暗黙ムーブ、C++11から
+}
+
+// Widgetの右辺値から構築可能な型
+struct RRefTaker {
+  // Widgetの右辺値からの変換コンストラクタ
+  RRefTaker(Widget&amp;amp;&amp;amp;);
+};
+
+auto f2(Widget w) -&amp;gt; RRefTaker {
+  return w;  // 暗黙ムーブされて構築（変換）、C++11から
+}
+
+auto f3(Widget&amp;amp;&amp;amp; w) -&amp;gt; RRefTaker {
+  return w;  // ローカル右辺値参照の暗黙ムーブ、C++20から
+}
 
-(ここには、サンプルコードの実行結果を記述します。何も出力がない場合は、項目を削除せず、空の出力にしてください。)  
-(実行結果が処理系・実行環境によって異なる場合は、項目名を「出力例」に変更し、可能であればその理由も併記してください。)
+[[noreturn]]
+void f4(Widget w) {
+  throw w;  // throw式における暗黙ムーブ、C++20から
+}
+
+struct From {
+  From(Widget const &amp;amp;);
+  From(Widget&amp;amp;&amp;amp;);
+};
+
+auto f5() -&amp;gt; From {
+  Widget w;
+  return w;  // 暗黙ムーブ（コンストラクタによる変換）、C++11から
+}
+
+struct To {
+  operator Widget() &amp;amp;&amp;amp;;
+};
+
+auto f6() -&amp;gt; Widget {
+  To t;
+  return t;  // 暗黙ムーブ（変換演算子による変換）、C++20から
+}
+
+struct V {
+  V(Widget); // 値で受け取るコンストラクタ
+};
 
+auto f7() -&amp;gt; V {
+  Widget w;
+  return w;  // 暗黙ムーブ（コンストラクタ引数へのムーブ）、C++20から
+}
+
+// DerivedはBaseを公開継承しているとき
+auto f8() -&amp;gt; Base {
+  Derived result;
+  return result;  // 暗黙ムーブ（基底クラスへの変換）、C++20から
+}
+
+auto f9(Widget&amp;amp;&amp;amp; w) -&amp;gt; Widget&amp;amp;&amp;amp; {
+  return w;  // 戻り値型が参照型の場合の暗黙ムーブ、C++23から
+}
+
+struct J {
+  operator Widget&amp;amp;() &amp;amp;&amp;amp;;
+};
+
+auto f10(J x) -&amp;gt; Widget&amp;amp; {
+  return x;  // 戻り値型が参照型の場合の暗黙ムーブ（変換演算子による変換）、C++23から
+}
+```
 
 ## この機能が必要になった背景・経緯
 (執筆中)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>