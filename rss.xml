<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-03-02T20:26:56.849639</updated>
  <id>95977227-77a2-4ca1-8e25-930a97429d9f</id>

  
    <entry>
      <title>モジュール -- モジュールの説明を再編</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>526ecca8defd288b4c2f75af2f27fc41a369c3ac:lang/cpp20/modules.md</id>
      <updated>2021-03-03T05:21:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index 96e267a80..aa8b95f6f 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -42,26 +42,85 @@ C++20では標準ライブラリはモジュール化されないが、その中
 
 ## 仕様
 
+### 翻訳単位の分類
+
+C++20では翻訳単位がその役割によって細かく分類される。
+
+まず、モジュールを構成する翻訳単位(モジュールユニット)とそれ以外(従来の翻訳単位すべて)の区別がある。
+
+モジュールユニットはさらにインターフェースと実装に分けられる。
+
+* モジュールインターフェースユニット  
+    従来のヘッダーファイルに相当する翻訳単位(`#include`のようにソースファイルに展開されることはなく、単独で翻訳単位になる)。外部(別のモジュール)に公開したい宣言や定義を書く。
+* モジュール実装ユニット  
+    従来のソースファイルに相当する翻訳単位。公開しない宣言や定義を書く。
+
+また、それぞれにモジュール本体とパーティションという区別がある。
+
+パーティションは、モジュールを構成するファイルをさらに分割するために使うもので、内部的には別モジュールのように見えるが、外部からは見えないファイルである。
+
+まとめると、以下のようになる。
+
+* 翻訳単位
+    * モジュールユニット
+        * モジュールインターフェースユニット
+            * プライマリーモジュールインターフェース
+            * モジュールインターフェースパーティション
+        * モジュール実装ユニット
+            * モジュール本体の実装ユニット(特別な名称無し)
+            * モジュール実装パーティション
+    * モジュールユニット以外(特別な名称無し)
+
 ### モジュール宣言
 
 モジュール宣言の構文は以下のようになる：
 
 ```
-export(opt) module モジュール名 属性(opt);
+export(opt) module モジュール名 :パーティション名(opt) 属性(opt);
 ```
 
-- モジュール宣言は翻訳単位あたり1回だけ、原則として翻訳単位の先頭に記述する。
-- モジュール宣言を含む翻訳単位をモジュールユニットという。
-    - `export`がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。
-    - あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。
-    - モジュール実装ユニットはモジュールインターフェースユニットを暗黙的にインポートする。
+- モジュール宣言は翻訳単位あたり1回だけ、原則として翻訳単位の先頭に記述する。モジュール宣言を含む翻訳単位をモジュールユニットという。
+- `export`がある場合はモジュールインターフェースユニット、ない場合はモジュール実装ユニットになる。
+- パーティション名がある場合はそれぞれモジュールインターフェースパーティション、モジュール実装パーティションになる。
+
+どのモジュールも、必ずただ1つのプライマリーモジュールインターフェースユニットを持たなければならない。
+それ以外のモジュールユニットの個数は任意である。ただし、パーティション名はモジュール内で重複してはならない。
+
 
 ```cpp
 export module foo;                // fooのモジュールインターフェースユニット
 module foo;                       // fooのモジュール実装ユニット
 module foo.bar;                   // foo.barのモジュール実装ユニット
 export module bar [[deprecated]]; // 属性
+export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
+module lib:internal; // libモジュールのモジュール実装パーティションinternal
+```
+
+次のモジュールAは4つの翻訳単位からなる。
+
+```cpp
+// P1103R3より引用
+// 翻訳単位1 プライマリーモジュールインターフェースユニット
+export module A;
+export import :Foo;
+export int baz();
+
+// 翻訳単位2 モジュールインターフェースパーティション
+export module A:Foo;
+import :Internals;
+export int foo() { return 2 * (bar() + 1); }
+
+// 翻訳単位3 モジュール実装パーティション
+module A:Internals;
+int bar();
+
+// 翻訳単位4 モジュール実装ユニット
+module A;
+import :Internals;
+int bar() { return baz() - 10; }
+int baz() { return 30; }
 ```
+* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]
 
 #### モジュール名の詳細
 
@@ -194,6 +253,8 @@ import lib; // libのインポート
 
 モジュールインポート宣言は、モジュールのインターフェースユニットをインポートする。
 
+- モジュール実装ユニットはモジュールインターフェースユニットを暗黙的にインポートする。ソースファイルと同名のヘッダーファイルをインクルードすることは多いが、これを自動化したものである。
+
 インポートされた翻訳単位でエクスポートされている名前は、インポート宣言を記述した翻訳単位において**可視**(visible)となる。
 名前が可視であるとき、かつそのときに限り、名前は名前探索の候補となる。
 
@@ -210,6 +271,23 @@ export import lib; // libの再エクスポート
 
 モジュールをインポートすると、そのモジュールが再エクスポートしているモジュールも同時にインポートする。
 
+#### パーティションのインポート
+
+パーティションは内部的には別のモジュールのように振る舞うので、パーティション内の宣言などを利用するにはインポートが必要である。
+
+パーティションは主となるモジュールが異なる場合はインポートできないので、間違いのないように、インポート宣言にはモジュールパーティション名だけを書く。
+
+```cpp
+export module datetime;
+export import :date; // インターフェースパーティション date をインポート
+export import :time; // インターフェースパーティション time をインポート
+```
+
+モジュールインターフェースパーティションはモジュールインターフェースを分割するものなので、内部の宣言を外へ公開しなければ意味がない。そのため、モジュールインターフェースパーティションのインポート宣言は必ず再エクスポートしなければならない。
+
+* パーティション内の宣言はエクスポートしていなくても見える
+* ただし、再エクスポートされるのはパーティションがエクスポートしている宣言のみ
+
 #### インターフェース依存
 
 翻訳単位がモジュールユニットUに**インターフェース依存**(interface dependency)を持つとは、次のことをいう：
@@ -245,69 +323,6 @@ C++20までは到達可能という用語はなかったが、前者の条件を
 
 エクスポートの有無とは関係なく、モジュールをインポートしただけでインターフェース依存が発生し、そのモジュールインターフェースユニットおよびその中の宣言へ到達可能となる。
 
-### モジュールパーティション
-
-モジュールは分割することができる。分割したモジュールをモジュールパーティションという。
-
-モジュールパーティションを宣言する構文は以下のようになる：
-
-```
-export(opt) module モジュール名:モジュールパーティション名 属性(opt);
-```
-
-- モジュールパーティション名の書式は、モジュール名と同じである。
-- `export` がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。
-
-```cpp
-export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
-```
-
-```cpp
-module lib:internal; // libモジュールのモジュール実装パーティションinternal
-```
-
-モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：
-
-- 主となるモジュールが異なる場合はインポートできない。
-    - 外部へ公開するには、モジュールインターフェースから再エクスポートする。
-    - モジュールの利用者にパーティションの存在を意識させてはいけない。
-- インポート宣言にはモジュールパーティション名だけを書く。
-- インポートするとエクスポートしていない宣言も見えるようになる。
-    - ただし、再エクスポートはできない。
-
-主となるモジュールのインターフェースとパーティションを区別する場合は、プライマリーモジュールインターフェースユニットという事がある。
-
-```cpp
-// P1103R3より引用
-// 翻訳単位1
-export module A;
-export import :Foo;
-export int baz();
-
-// 翻訳単位2
-export module A:Foo;
-import :Internals;
-export int foo() { return 2 * (bar() + 1); }
-
-// 翻訳単位3
-module A:Internals;
-int bar();
-
-// 翻訳単位4
-module A;
-import :Internals;
-int bar() { return baz() - 10; }
-int baz() { return 30; }
-```
-* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]
-
-このモジュールAは4つの翻訳単位からなる。上から順に、
-
-1. (プライマリー)モジュールインターフェースユニット
-2. モジュールインターフェースパーティション `:Foo`
-3. モジュール実装パーティション `:Internals`
-4. モジュール実装ユニット
-
 ### モジュールにおけるODR
 
 同じトークン列であれば再定義しても良いというODRの例外は、その定義が名前のあるモジュールに属する場合は適用されない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sentinel_for -- LWG Issue 3453対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/sentinel_for.html"/>
      <id>ab8c40980dd4b91e4b59755886c997fb42b49180:reference/iterator/sentinel_for.md</id>
      <updated>2021-03-02T15:46:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/sentinel_for.md b/reference/iterator/sentinel_for.md
index a1ab3fc8e..35eecb5e4 100644
--- a/reference/iterator/sentinel_for.md
+++ b/reference/iterator/sentinel_for.md
@@ -29,6 +29,7 @@ namespace std {
 
 - `i == s`が適格である（未定義動作にならない）
 - `bool(i != s) == true`の（`i`が範囲終端に到達していない）時、`i`は間接参照可能であり`[++i, s)`も範囲を示す
+- `I&amp;amp;, S`が[`assignable_from`](/reference/concepts/assignable_from.md)`&amp;lt;I&amp;amp;, S&amp;gt;`のモデルとならないなら、構文的にも`assignable_from`コンセプトを満たさない
 
 ここでの`==`の[定義域](/reference/concepts.md)は静的ではなく、実行時に変化しうる。`[i, s)`が範囲を示している時に`i == oi`となるような別のイテレータ`oi`をインクリメント（`++oi`）した後で、範囲`[i, s)`が有効であり続ける必要はない。
 
@@ -106,4 +107,5 @@ int* is not sentinel for double*
 ## 参照
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [LWG Issue 3453. Generic code cannot call `ranges::advance(i, s)`](https://cplusplus.github.io/LWG/issue3453)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_chars -- from/to_chars : GCC対応を追記</title>
      <link href="https://cpprefjp.github.io/reference/charconv/from_chars.html"/>
      <id>3cdfcef53b11de41806c8ac4ac24608bcd23f2c8:reference/charconv/from_chars.md</id>
      <updated>2021-02-27T15:34:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/from_chars.md b/reference/charconv/from_chars.md
index eb347ae65..2aa8c38e5 100644
--- a/reference/charconv/from_chars.md
+++ b/reference/charconv/from_chars.md
@@ -32,8 +32,8 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 - (2)～(4)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
 ## 引数
-- `first` -- 入力文字列の先頭のポインタ。
-- `last` -- 入力文字列の終端の次を指すポインタ。
+- `first` -- 入力文字列の先頭ポインタ。
+- `last` -- 入力文字列の終端ポインタ。
 - `value` -- 変換結果を出力する変数。
 - `base` -- 入力文字列の整数の基数（n進数のn）指定、2進数から36進数まで。
 - `fmt` -- 入力文字列の浮動小数点数のフォーマット指定、[`chars_format`](../charconv/chars_format.md)のいずれか。
@@ -243,7 +243,7 @@ nan
 
 ### 処理系
 - [Clang](/implementation.md#clang): 7.0(整数のみ)
-- [GCC](/implementation.md#gcc): 8.0(整数のみ)
+- [GCC](/implementation.md#gcc): 8.0(整数のみ), 11.1(full support)
 - [Visual C++](/implementation.md#visual_cpp): 2017 update 7(整数のみ), update 9(full support)
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>to_chars -- from/to_chars : GCC対応を追記</title>
      <link href="https://cpprefjp.github.io/reference/charconv/to_chars.html"/>
      <id>3cdfcef53b11de41806c8ac4ac24608bcd23f2c8:reference/charconv/to_chars.md</id>
      <updated>2021-02-27T15:34:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/to_chars.md b/reference/charconv/to_chars.md
index 918998467..2b983f1be 100644
--- a/reference/charconv/to_chars.md
+++ b/reference/charconv/to_chars.md
@@ -46,8 +46,8 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 - (5)～(10)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
 ## 引数
-- `first` -- 変換結果の文字列を出力する範囲の先頭のポインタ。
-- `last` -- 変換結果の文字列を出力する範囲の終端の次を指すポインタ。
+- `first` -- 変換結果の文字列を出力する範囲の先頭ポインタ。
+- `last` -- 変換結果の文字列を出力する範囲の終端ポインタ。
 - `value` -- 文字列へ変換する値。
 - `base` -- 整数の出力基数（n進数のn）指定、2進数から36進数まで。
 - `fmt` -- 浮動小数点数の出力フォーマット指定、[`chars_format`](../charconv/chars_format.md)のいずれか。
@@ -209,7 +209,7 @@ z
 
 ### 処理系
 - [Clang](/implementation.md#clang): 7.0(整数のみ)
-- [GCC](/implementation.md#gcc): 8.0(整数のみ)
+- [GCC](/implementation.md#gcc): 8.0(整数のみ), 11.1(full support)
 - [Visual C++](/implementation.md#visual_cpp): 2017 update 7(整数のみ), update 9(full support)
 
 ## 関連項目
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>indirectly_readable_traits -- LWG Issue 3446対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirectly_readable_traits.html"/>
      <id>1d7fae9e06d1a3a3533c88ccf92441455fa5dbac:reference/iterator/indirectly_readable_traits.md</id>
      <updated>2021-02-26T16:07:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirectly_readable_traits.md b/reference/iterator/indirectly_readable_traits.md
index 7be6932c0..d4b10579c 100644
--- a/reference/iterator/indirectly_readable_traits.md
+++ b/reference/iterator/indirectly_readable_traits.md
@@ -7,7 +7,7 @@
 ```cpp
 namespace std {
 
-  // 素の型を取得する、説明専用type-traits
+  // 素の型を取得しvalue_typeという名前に変換する、説明専用type-traits
   template&amp;lt;class&amp;gt;
   struct cond-value-type { };
 
@@ -39,17 +39,29 @@ namespace std {
   struct indirectly_readable_traits&amp;lt;const I&amp;gt;
     : indirectly_readable_traits&amp;lt;I&amp;gt; { };
 
-  // value_typeを定義している型についての特殊化
   template&amp;lt;class T&amp;gt;
-    requires requires { typename T::value_type; }
+  concept has-member-value-type = requires { typename T::value_type; };     // 説明専用
+
+  template&amp;lt;class T&amp;gt;
+  concept has-member-element-type = requires { typename T::element_type; }; // 説明専用
+
+  // value_typeを定義している型についての特殊化
+  template&amp;lt;has-member-value-type T&amp;gt;
   struct indirectly_readable_traits&amp;lt;T&amp;gt;
     : cond-value-type&amp;lt;typename T::value_type&amp;gt; { };
 
   // element_typeを定義している型についての特殊化
-  template&amp;lt;class T&amp;gt;
-    requires requires { typename T::element_type; }
+  template&amp;lt;has-member-element-type T&amp;gt;
   struct indirectly_readable_traits&amp;lt;T&amp;gt;
     : cond-value-type&amp;lt;typename T::element_type&amp;gt; { };
+  
+  // value_typeとelement_typeを両方定義している型についての特殊化
+  template&amp;lt;has-member-value-type T&amp;gt;
+    requires has-member-element-type&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
+             same_as&amp;lt;remove_cv_t&amp;lt;typename T::element_type&amp;gt;, 
+                     remove_cv_t&amp;lt;typename T::value_type&amp;gt;&amp;gt;; }
+  struct indirectly_readable_traits&amp;lt;T&amp;gt;
+    : cond-value-type&amp;lt;typename T::value_type&amp;gt; { };
 }
 ```
 * is_object_v[link /reference/type_traits/is_object.md]
@@ -139,3 +151,4 @@ int main() {
 ## 参照
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [LWG Issue 3446. `indirectly_readable_traits` ambiguity for types with both `value_type` and `element_type`](https://cplusplus.github.io/LWG/issue3446)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_partial_order_fallback -- LWG Issue 3465対応</title>
      <link href="https://cpprefjp.github.io/reference/compare/compare_partial_order_fallback.html"/>
      <id>4b80799943658ee46ebb52e570f350c3bbaff345:reference/compare/compare_partial_order_fallback.md</id>
      <updated>2021-02-26T15:56:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/compare/compare_partial_order_fallback.md b/reference/compare/compare_partial_order_fallback.md
index 59d2dd0bf..4ffd72d8f 100644
--- a/reference/compare/compare_partial_order_fallback.md
+++ b/reference/compare/compare_partial_order_fallback.md
@@ -28,7 +28,7 @@ namespace std {
 
 2. [`partial_order`](partial_order.md)`(a, b)`が呼び出し可能ならば`partial_order(a, b)`
 
-3. `a == b`、`a &amp;lt; b`の両方の演算子が使用可能でありその戻り値型が`bool`へ変換可能ならば、以下の式
+3. `a == b`、`a &amp;lt; b`、`b &amp;lt; a`の3つの演算子が使用可能でありその戻り値型が`bool`へ変換可能ならば、以下の式
    ```cpp
    a == b ? partial_ordering::equivalent :
    a &amp;lt;  b ? partial_ordering::less :
@@ -151,3 +151,4 @@ false
 
 - [P0768R1 Library support for the spaceship (comparison) operator](http://wg21.link/p0768)
 - [P1614R2 The Mothership has Landed (Adding &amp;lt;=&amp;gt; to the Library)](http://wg21.link/p1614)
+- [LWG Issue 3465. `compare_partial_order_fallback` requires `F &amp;lt; E`](https://cplusplus.github.io/LWG/issue3465)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>