<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-07-15T14:45:22.753854</updated>
  <id>139cf0eb-1e6c-4576-9a1d-a7d93944e8a7</id>

  
    <entry>
      <title>formatter -- formatter : 微修正</title>
      <link href="https://cpprefjp.github.io/reference/format/formatter.html"/>
      <id>d54e2129f30d7d8d76b89ab5abed51492810df72:reference/format/formatter.md</id>
      <updated>2022-07-14T01:51:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/formatter.md b/reference/format/formatter.md
index 337690122..dac02dfee 100644
--- a/reference/format/formatter.md
+++ b/reference/format/formatter.md
@@ -52,7 +52,7 @@ namespace std {
 
 型`F`がFormatter要件を満たすとは、次のことをいう。
 
-* `F`は`Cpp17DefaultConstructible`、`Cpp17CopyConstructible`、`Cpp17CopyAssignable`、`Cpp17Destructible`であること (注: ここはC++20の策定までにコンセプトで書き換えられるかもしれない)
+* `F`は`Cpp17DefaultConstructible`、`Cpp17CopyConstructible`、`Cpp17CopyAssignable`、`Cpp17Destructible`であること
 
 さらに、以下の条件を満たすこと
 
@@ -62,11 +62,11 @@ namespace std {
 2. 式 `f.format(t, fc)` が有効であり、
     * 戻り値の型が`FC::iterator`である
     * フォーマット結果を`fc.out()`へ出力し、出力後のイテレーターを返す
-    * 出力は`t`、グローバルロケール、最後に呼び出された`f.parse(pc)`の`[pc.begin(), pc.end())`の範囲以外に依存しない
+    * 出力は`t`、`fc.locale()`、最後に呼び出された`f.parse(pc)`の`[pc.begin(), pc.end())`の範囲以外に依存しない
 3. 式 `f.format(u, fc)` が有効であり、
     * 戻り値が`FC::iterator`である
     * フォーマット結果を`fc.out()`へ出力し、出力後のイテレーターを返す
-    * 出力は`t`、グローバルロケール、最後に呼び出された`f.parse(pc)`の`[pc.begin(), pc.end())`の範囲以外に依存しない
+    * 出力は`u`、`fc.locale()`、最後に呼び出された`f.parse(pc)`の`[pc.begin(), pc.end())`の範囲以外に依存しない
     * `u`を変更しない
 
 条件内の各要素を、以下のように定義する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format_to -- format_to : 制約周りを調整</title>
      <link href="https://cpprefjp.github.io/reference/format/format_to.html"/>
      <id>3de5612490bce58646a35b36846de9b659c81a1b:reference/format/format_to.md</id>
      <updated>2022-07-06T15:34:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format_to.md b/reference/format/format_to.md
index bfb437091..46ea809c4 100644
--- a/reference/format/format_to.md
+++ b/reference/format/format_to.md
@@ -51,15 +51,15 @@ format_to(back_inserter(buffer), &amp;#34;The answer is {}.&amp;#34;, 42);
 
 `Out`は以下の制約を満たす。
 
-* (1),(3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
-* (2),(4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
+* (1),(3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
+* (2),(4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
 
 ## 事前条件
 
-`out`は以下の制約を満たす型の有効なオブジェクトである。
+`Out`は以下のコンセプトのモデルである。
 
-* (1),(3): `OutputIterator&amp;lt;const char&amp;amp;&amp;gt;`
-* (2),(4): `OutputIterator&amp;lt;const wchar_t&amp;amp;&amp;gt;`
+* (1),(3): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const char&amp;amp;&amp;gt;`
+* (2),(4): [`output_iterator`](/reference/iterator/output_iterator.md)`&amp;lt;Out, const wchar_t&amp;amp;&amp;gt;`
 
 ## 効果
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cpprefjp特有の拡張構文 -- Merge pull request #977 from akinomyoga/defined_words</title>
      <link href="https://cpprefjp.github.io/editors_doc/specialized.html"/>
      <id>484463600efcd56f5fa6320238da3befca264f35:editors_doc/specialized.md</id>
      <updated>2022-06-30T14:14:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/editors_doc/specialized.md b/editors_doc/specialized.md
index 81b5de8dc..e9a426118 100644
--- a/editors_doc/specialized.md
+++ b/editors_doc/specialized.md
@@ -159,6 +159,18 @@ int main() {
 
 グローバル修飾の一覧は [GLOBAL_QUALIFY_LIST.txt](https://github.com/cpprefjp/site/blob/master/GLOBAL_QUALIFY_LIST.txt) にあります。
 
+## 定義語
+
+`GLOBAL_DEFINED_WORDS.json` に定義語を登録することができます。形式は `GLOBAL_DEFINED_WORDS.json` を参照して下さい。
+
+`link` にはその定義語の解説ページへのURLを指定します。`link` が指定されている場合、任意の記事中の (コード、リンク、見出しなどを除く) 地の文にその定義語が現れた時に、自動的に `link` へのハイパーリンクが貼られます。
+
+特に解説ページの定義箇所で `&amp;lt;dfn id=&amp;#34;識別子&amp;#34;&amp;gt;定義語&amp;lt;/dfn&amp;gt;` として `id` 属性を設定して、その箇所への直接リンクすることもできます。
+
+`desc` に簡単な説明が指定されている場合、地の文にあるその定義語にマウスカーソルを合わせると説明がツールチップとして表示されます。
+
+`yomi` には平仮名およびアルファベットでその定義語の読みを指定します。現在は使用されていませんが将来的に定義語が増えてきた時に、用語集または索引ページを自動生成する時の並び替えに使われる予定です。
+
 ## リンクの存在チェック
 
 CommonMark形式のリンクや独自拡張のプログラムの修飾`link`などで生成されるHTMLにリンクが埋め込まれるとき、リンク先がサイト内へのリンクだった場合、リンク先の存在チェックも行います。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>標準規格と処理系 -- Merge pull request #977 from akinomyoga/defined_words</title>
      <link href="https://cpprefjp.github.io/implementation-compliance.html"/>
      <id>484463600efcd56f5fa6320238da3befca264f35:implementation-compliance.md</id>
      <updated>2022-06-30T14:14:07+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;標準規格と処理系&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#summary&#34; id=&#34;summary&#34;&gt;概要&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;※ここでは各用語の日本語訳については、できるだけ JIS C++ (JIS X 3014:2003) に倣った。例外についてはそれぞれ注釈で説明を与える。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#implementation-compliance&#34; id=&#34;implementation-compliance&#34;&gt;処理系の適合 (implementation compliance)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;処理系&lt;/strong&gt; (implementation) または&lt;strong&gt;実装&lt;/strong&gt;とはプログラムの&lt;strong&gt;翻訳&lt;/strong&gt; (translation) と&lt;strong&gt;実行&lt;/strong&gt; (execution) をする一連の枠組み・ソフトウェアのことである。
C++ の処理系は、翻訳を担うコンパイラと実行を担うオペレーティングシステムから構成されるのが普通だが、後者は前提として特に前者を処理系と考えることも多い。
&lt;strong&gt;標準規格&lt;/strong&gt; (standard) または&lt;strong&gt;規格&lt;/strong&gt;とは、C++ の&lt;strong&gt;適合する処理系&lt;/strong&gt; (conforming implementation) が満たすべき&lt;strong&gt;要件&lt;/strong&gt; (requirement) を取り決めた文書である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#behavior&#34; id=&#34;behavior&#34;&gt;動作&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;適合する処理系は標準規格が定める&lt;strong&gt;抽象機械&lt;/strong&gt; (abstract machine) の&lt;strong&gt;外から見た動作&lt;/strong&gt; (observable behavior) を&lt;strong&gt;模倣&lt;/strong&gt; (emulate) しなければならない。
外から見た動作は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; &lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html&#34;&gt;glvalue&lt;/a&gt; を通した抽象機械の読み書き操作&lt;/li&gt;
&lt;li&gt;実行終了後の、ファイルに出力された内容&lt;/li&gt;
&lt;li&gt;対話的な入出力装置の読み書きの順序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;からなる。但し、一部の動作については処理系に対して自由度が認められている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dfn id=&#34;dfn-implementation-defined-behavior&#34;&gt;処理系定義の動作&lt;/dfn&gt; (implementation-defined behavior) または&lt;dfn&gt;実装定義の動作&lt;/dfn&gt;とされた動作に対しては、処理系は考えられる動作の内の1つを行って良い。処理系はその説明書にその動作を定義する必要がある。&lt;/li&gt;
&lt;li&gt;&lt;dfn id=&#34;dfn-unspecified-behavior&#34;&gt;未規定の動作&lt;/dfn&gt; (unspecified behavior) とされた動作に対しては、処理系は考えられる動作の内の1つを行って良い。処理系は説明書にその動作を定義しなくて良い。&lt;/li&gt;
&lt;li&gt;&lt;dfn id=&#34;dfn-undefined-behavior&#34;&gt;未定義の動作&lt;/dfn&gt; (undefined behavior; 通称 UB) は、処理系が実際に行う動作について標準規格が如何なる要件もおかないことを表す。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文化圏固有動作&lt;/strong&gt; (locale-specific behavior) に対しては、処理系は現地の国家・文化・言語の風習に依存した動作を行う。処理系はその動作を説明書に記述する必要がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの用語は処理系が取りうる動作の範囲を示すものであって、例えば &#34;未定義の動作&#34; という名前の具体的な動作がある訳ではないことに注意する。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#rule&#34; id=&#34;rule&#34;&gt;規則&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;標準規格の定める要件は、処理系 (抽象機械) に対する直接の要件と、処理系が受け入れるべきプログラムが満たす&lt;strong&gt;規則&lt;/strong&gt; (rule) で構成される。
規則には幾つかの分類があるが、C++ の標準規格内では具体的な分類基準は示されていない。C言語に倣えば以下の解釈になる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;構文規則&lt;/strong&gt; (syntactic rule, syntax rule): 拡張バッカス・ナウア記法の亜種である&lt;strong&gt;構文記法&lt;/strong&gt; (syntax notation) によって指定されるプログラムの構文&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;制約&lt;/strong&gt; (constraints): C言語において構文記法によって表現しきれない構文的な制限を文章で述べたもの。C++ には現れない&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意味規則&lt;/strong&gt; (semantic rule): 構文規則と制約のどちらでもないプログラムに対する規則&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各規則には&lt;dfn id=&#34;dfn-no-diagnostic-required&#34;&gt;診断不要&lt;/dfn&gt;&lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#note-1&#34; id=&#34;note_ref-1&#34;&gt;[注1]&lt;/a&gt;&lt;/sup&gt; (no diagnostic required; 通称 NDR) や「違反すると未定義の動作になる」などの属性が明記されることがあり、
診断不要とも未定義の動作になるとも明記されない規則を&lt;strong&gt;診断対象規則&lt;/strong&gt; (diagnosable rule) と呼ぶ。
&lt;strong&gt;単一定義規則&lt;/strong&gt; (ODR; one definition rule) は &#34;使用される変数・関数・クラスについてただ1つの定義を与えなければならない&#34; という一連の規則である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dfn id=&#34;dfn-well-formed&#34;&gt;適格&lt;/dfn&gt; (well-formed) とはプログラムが全ての構文規則・診断対象の意味規則・単一定義規則を満たすことである&lt;/li&gt;
&lt;li&gt;&lt;dfn id=&#34;dfn-ill-formed&#34;&gt;不適格&lt;/dfn&gt; (ill-formed) とはプログラムが適格でないことである&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プログラムが規則に違反するとき、処理系はエラーメッセージまたは警告などを出力する。
この出力を総称して&lt;dfn id=&#34;dfn-diagnostic-message&#34;&gt;診断情報&lt;/dfn&gt; (diagnostic message) または&lt;dfn&gt;診断メッセージ&lt;/dfn&gt;&lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#note-2&#34; id=&#34;note_ref-2&#34;&gt;[注2]&lt;/a&gt;&lt;/sup&gt; と呼び、その内容は処理系定義である。&lt;/p&gt;
&lt;p&gt;適合する処理系は、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;規則を全て満たすプログラムをそのリソースの範囲で正しく実行 (外から見た動作を模倣) する必要がある。&lt;/li&gt;
&lt;li&gt;診断対象規則に違反するプログラムに対して診断情報を出力する必要がある。&lt;/li&gt;
&lt;li&gt;診断不要な規則に違反するプログラムの翻訳・実行について、標準規格によって如何なる要件もおかれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#conditionally-supported&#34; id=&#34;conditionally-supported&#34;&gt;条件付き対応の構成&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一部の C++ の機能は&lt;strong&gt;条件付き対応の構成&lt;/strong&gt;&lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#note-3&#34; id=&#34;note_ref-3&#34;&gt;[注3]&lt;/a&gt;&lt;/sup&gt; (conditionally-supported constructs) とされ、処理系はこれに対応しなくても良い。
対応する場合にはその動作は処理系定義である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#implementation-limit&#34; id=&#34;implementation-limit&#34;&gt;処理系限界&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;変数名の最大の長さや仮引数の最大の数など、処理系が対応する様々なプログラムの大きさのことを&lt;strong&gt;処理系限界&lt;/strong&gt; (implementation limit, implementation quantity) と呼ぶ。
処理系は処理系限界についての情報を説明書に記述する必要がある。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#relations&#34; id=&#34;relations&#34;&gt;規則違反と動作の包含関係&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;規則に違反するプログラム・処理系依存の動作を行うプログラムの包含関係について以下の図に示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;俯瞰図&#34; src=&#34;https://raw.githubusercontent.com/cpprefjp/image/master/implementation-compliance/overview.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但し、一つのプログラムが複数の規則に違反する場合については考慮していない。&lt;/li&gt;
&lt;li&gt;構文規則の範囲は規格上曖昧なので、診断不要 (NDR) の規則を含むかどうかは解釈による。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;かつ診断不要の規則 (ill-formed; NDR) が、規格上矛盾なく定義されているかどうかは議論が分かれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#informal-terms&#34; id=&#34;informal-terms&#34;&gt;慣用語&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;処理系の性質についての慣用語&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;合法&lt;/strong&gt; (legal): 処理系が適合することを指す。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;違法&lt;/strong&gt; (illegal): 処理系が適合しないことを指す。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;QoI&lt;/strong&gt; (quality of implementation; QOI): 処理系の実装品質のこと。適合する処理系であっても処理系依存な部分で粗末な動作をするものが考えうる。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;normative&lt;/strong&gt;: (ある規格の記述が) 適合する処理系に対して強制力を持つさまを表す&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;informative&lt;/strong&gt;: (ある規格の記述が) 強制力を持たないさまを表す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プログラムの性質についての慣用語&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;処理系依存&lt;/strong&gt; (implementation-dependent): プログラムの動作が処理系によって異なりうること。
  条件付き対応の機能を使用している場合や、処理系定義の動作・未規定の動作・未定義の動作・文化圏固有動作を起こす場合、処理系限界を超える場合、規則に違反している場合を含む。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合法&lt;/strong&gt; (legal)・&lt;strong&gt;違法&lt;/strong&gt; (illegal): これらの語はプログラムに対しても慣用されるが、具体的な意味は明確でない。
  プログラムの正しさには複数の水準があるためである。
  適格、またはすべての規則を満たす、または未定義の動作を含まないなどが考えられる。
  曖昧さを避けるため、このサイトではプログラムに対して合法・違法という語は用いない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#nasal-demon&#34; id=&#34;nasal-demon&#34;&gt;「鼻から悪魔」とプログラムの可搬性&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;プログラムが&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未定義の動作 (UB) を引き起こすとき、&lt;/li&gt;
&lt;li&gt;または診断不要 (NDR) の規則に違反している&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とき、標準規格は適合する処理系に対して何らの要件も課さない。
つまり、UB または NDR 違反を含むプログラムに対して処理系がいかなる動作をしても規格には抵触しないということを表す。
例えば、このことで処理系が鼻から悪魔を出しても、それはプログラムの作者の責任であり、その処理系を責めることはできない。
この冗談を&lt;strong&gt;鼻から悪魔&lt;/strong&gt; (nasal demons)&lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#cite-1&#34; id=&#34;cite_ref-1&#34;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#cite-2&#34; id=&#34;cite_ref-2&#34;&gt;[2]&lt;/a&gt;&lt;/sup&gt; と呼ぶ。鼻から悪魔を出す処理系は今のところ実在しないが、
実際の未定義の動作として最適化の過程で或る種の「タイムトラベル」を起こす処理系は実在する&lt;sup&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#cite-3&#34; id=&#34;cite_ref-3&#34;&gt;[3]&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;処理系依存のプログラムは、たとえ或る処理系の上で期待する動作をしたとしても、他の処理系でも正しく動作することは保証されない。
可搬なプログラムを書くためには、未定義の動作を引き起こさずかつ診断不要の規則に違反しないプログラムを書くように心懸ける必要がある。
更に、処理系定義の動作や未規定の動作は、(内部的に起こしても良いが) 外から見える動作として現れて問題を起こさないようにする必要がある。
余裕があれば、文化圏固有動作や条件付き対応の構成についても気を配ると良い。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#list-of-locale-specific&#34; id=&#34;list-of-locale-specific&#34;&gt;文化圏固有動作の一覧&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ToDo&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#list-of-conditionally-supported&#34; id=&#34;list-of-conditionally-supported&#34;&gt;条件付き対応の一覧&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ToDo&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#list-of-implementation-limit&#34; id=&#34;list-of-implementation-limit&#34;&gt;処理系限界の一覧&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ToDo&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/akinomyoga/items/592e5a3b8438a0c8556b&#34; target=&#34;_blank&#34;&gt;C++er は“合法”だとか“違法”だとか言いたくて仕方がないけれど、結局どういう意味? それより適合・適格・○○動作・○○規則・診断不要いろいろの関係が謎 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.c-lang.org/detail/implementation_defined_behavior.html&#34; target=&#34;_blank&#34;&gt;処理系定義の動作&lt;/a&gt; - C言語の処理系定義の動作の一覧&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.c-lang.org/detail/undefined_behavior.html&#34; target=&#34;_blank&#34;&gt;未定義の動作&lt;/a&gt; - C言語の未定義の動作の一覧&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.c-lang.org/detail/unspecified_behavior.html&#34; target=&#34;_blank&#34;&gt;未規定の動作&lt;/a&gt; - C言語の未規定の動作の一覧&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.c-lang.org/detail/locale_specific_behavior.html&#34; target=&#34;_blank&#34;&gt;文化圏固有動作&lt;/a&gt; - C言語の文化圏固有動作の一覧&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpplover.blogspot.jp/2014/06/old-new-thing.html&#34; target=&#34;_blank&#34;&gt;本の虫: Old New Thing: 未定義動作はタイムトラベルを引き起こす（他にもいろいろあるけど、タイムトラベルが一番ぶっ飛んでる）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jpcert.or.jp/sc-rules/c-msc15-c.html&#34; target=&#34;_blank&#34;&gt;MSC15-C. 未定義の動作に依存しない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;出典&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#cite_ref-1&#34; id=&#34;cite-1&#34;&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/a&gt; &lt;cite&gt;&lt;a href=&#34;http://www.catb.org/jargon/html/N/nasal-demons.html&#34; target=&#34;_blank&#34;&gt;nasal demons&lt;/a&gt;&lt;/cite&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#cite_ref-2&#34; id=&#34;cite-2&#34;&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/a&gt; &lt;cite&gt;&lt;a href=&#34;https://cpplover.blogspot.jp/2010/01/c0x_14.html&#34; target=&#34;_blank&#34;&gt;本の虫: C++0x本：鼻から悪魔&lt;/a&gt;&lt;/cite&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#cite_ref-3&#34; id=&#34;cite-3&#34;&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/a&gt; &lt;cite&gt;&lt;a href=&#34;https://cpplover.blogspot.jp/2014/06/old-new-thing.html&#34; target=&#34;_blank&#34;&gt;本の虫: Old New Thing: 未定義動作はタイムトラベルを引き起こす（他にもいろいろあるけど、タイムトラベルが一番ぶっ飛んでる）&lt;/a&gt;&lt;/cite&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#note_ref-1&#34; id=&#34;note-1&#34;&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/a&gt; no diagnostic required: JIS C++ では一定の訳は与えられず、登場する度に異なる翻訳のされ方をしている。
  ここでは &#34;診断不要&#34; という語を割り当てることにする。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#note_ref-2&#34; id=&#34;note-2&#34;&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/a&gt; diagnostic message: JIS C++ では &#34;診断情報&#34; としている。
  JIS C言語 (JIS X 3010:2003) では &#34;診断メッセージ&#34; としている。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation-compliance.html#note_ref-3&#34; id=&#34;note-3&#34;&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/a&gt; conditionally-supported constructs: C++11 で導入されたものなので、JIS C++ には対応訳は存在しない。
  ここでは &#34;条件付き対応の構成&#34; と訳す。
  因みに JIS C++ では constructs は &#34;構文&#34; と訳している。
  現に C++98/03 で constructs という単語が使われているのは構文に対してのみである。
  しかし conditionally-supported constructs が導入された今、
  constructs という単語は構文とは言い難いものにも使われている。
  因みに、本来 constructs というのは構成要素というぐらいの意味である。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>double_t -- Merge pull request #981 from 0xbadfca11/patch-1</title>
      <link href="https://cpprefjp.github.io/reference/cmath/double_t.html"/>
      <id>046cd233cb311b08630afdd3d9777554dc699e48:reference/cmath/double_t.md</id>
      <updated>2022-06-28T23:48:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/double_t.md b/reference/cmath/double_t.md
index cb1be795d..51704418f 100644
--- a/reference/cmath/double_t.md
+++ b/reference/cmath/double_t.md
@@ -24,8 +24,9 @@ namespace std {
 - [Clang](/implementation.md#clang):
 - [GCC](/implementation.md#gcc):
 - [ICC](/implementation.md#icc):
-- [Visual C++](/implementation.md#visual_cpp): 2013, 2015, 2017
-	- 2013では、常に`double`の別名。
-	- 2015で、ターゲットのCPUアーキテクチャが`x86`以外である場合、`double`の別名。
-	- 2015で、ターゲットのCPUアーキテクチャが`x86`で、SSE2を使用する場合（`/arch:SSE2`以上のコンパイラオプション）、`double`の別名。
-	- 2015で、ターゲットのCPUアーキテクチャが`x86`で、SSE2を使用しない場合（`/arch:IA32`や`/arch:SSE`コンパイラオプション）、`long double`からの別名。
+- [Visual C++](/implementation.md#visual_cpp): 2013, 2015, 2017, 2019, 2022
+	- 2013, 2015では、常に`double`の別名。
+	- 2017以降で、ターゲットのCPUアーキテクチャが`x86`以外である場合、`double`の別名。
+	- 2017以降で、ターゲットのCPUアーキテクチャが`x86`で、SSE2を使用する場合（`/arch:SSE2`以上のコンパイラオプション）、`double`の別名。
+	- 2017以降で、ターゲットのCPUアーキテクチャが`x86`で、`/fp:fast`コンパイラオプションが指定されている場合、`double`の別名。
+	- 2017以降で、ターゲットのCPUアーキテクチャが`x86`で、SSE2を使用せず（`/arch:IA32`や`/arch:SSE`コンパイラオプション）、`/fp:fast`コンパイラオプションが指定されていない場合、`long double`の別名。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float_t -- Merge pull request #981 from 0xbadfca11/patch-1</title>
      <link href="https://cpprefjp.github.io/reference/cmath/float_t.html"/>
      <id>046cd233cb311b08630afdd3d9777554dc699e48:reference/cmath/float_t.md</id>
      <updated>2022-06-28T23:48:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/float_t.md b/reference/cmath/float_t.md
index c2fad06c2..0a05381e8 100644
--- a/reference/cmath/float_t.md
+++ b/reference/cmath/float_t.md
@@ -24,8 +24,9 @@ namespace std {
 - [Clang](/implementation.md#clang):
 - [GCC](/implementation.md#gcc):
 - [ICC](/implementation.md#icc):
-- [Visual C++](/implementation.md#visual_cpp): 2013, 2015, 2017
-	- 2013では、常に`float`の別名。
-	- 2015で、ターゲットのCPUアーキテクチャが`x86`以外である場合、`float`の別名。
-	- 2015で、ターゲットのCPUアーキテクチャが`x86`で、SSE2を使用する場合（`/arch:SSE2`以上のコンパイラオプション）、`float`の別名。
-	- 2015で、ターゲットのCPUアーキテクチャが`x86`で、SSE2を使用しない場合（`/arch:IA32`や`/arch:SSE`コンパイラオプション）、`long double`の別名。
+- [Visual C++](/implementation.md#visual_cpp): 2013, 2015, 2017, 2019, 2022
+	- 2013, 2015では、常に`float`の別名。
+	- 2017以降で、ターゲットのCPUアーキテクチャが`x86`以外である場合、`float`の別名。
+	- 2017以降で、ターゲットのCPUアーキテクチャが`x86`で、SSE2を使用する場合（`/arch:SSE2`以上のコンパイラオプション）、`float`の別名。
+	- 2017以降で、ターゲットのCPUアーキテクチャが`x86`で、`/fp:fast`コンパイラオプションが指定されている場合、`float`の別名。
+	- 2017以降で、ターゲットのCPUアーキテクチャが`x86`で、SSE2を使用せず（`/arch:IA32`や`/arch:SSE`コンパイラオプション）、`/fp:fast`コンパイラオプションが指定されていない場合、`long double`の別名。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>