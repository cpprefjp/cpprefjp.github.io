<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-07-21T14:34:42.877378</updated>
  <id>b286d2cb-5b85-4e64-9aec-922680b731db</id>

  
    <entry>
      <title>copy -- fs::copy : C++20仕様に修正</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/copy.html"/>
      <id>fdfd530a64fb5ea3b2ec4eb2e808477b9a571f61:reference/filesystem/copy.md</id>
      <updated>2020-07-21T16:12:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/copy.md b/reference/filesystem/copy.md
index ef2cb3881..0475ee7fe 100644
--- a/reference/filesystem/copy.md
+++ b/reference/filesystem/copy.md
@@ -69,6 +69,7 @@ namespace std::filesystem {
         - `(options &amp;amp; copy_options::create_hard_links) != copy_options::none`であれば、コピー元ファイルのハードリンクを、コピー先に作成する
         - コピー先がディレクトリである場合、[`copy_file`](copy_file.md)`(from, to/`[`from.filename()`](path/filename.md)`, options)`を実行する
         - いずれの条件にも合致しない場合は、[`copy_file`](copy_file.md)`(from, to, options)`を実行する
+    - コピー元がディレクトリであり、`(options &amp;amp; copy_options::create_symlinks) != copy_options::none`である場合、[`make_error_code`](/reference/system_error/make_error_code.md)`(`[`errc::is_a_directory`](/reference/system_error/errc.md)`)`と等値な[`error_code`](/reference/system_error/error_code.md)オブジェクトをエラーとして報告する
     - コピー元がディレクトリであり、`((options &amp;amp; copy_options::recursive) != copy_options::none || options == copy_options::none)`である場合、
         - コピー先にディレクトリが存在しない場合は、[`create_directory`](create_directory.md)`(to, from)`を実行する
         - その後、コピー元ディレクトリの全ての要素を、以下のようにコピーする (`in-recursive-copy`は、[`copy_options`](copy_options.md)には含まれないビットマスク要素)：
@@ -191,3 +192,6 @@ int main()
 
 ## 参照
 - [LWG Issue 3015. `copy_options::unspecified` underspecified](https://wg21.cmeerw.net/lwg/issue3015)
+- [LWG Issue 2682. `filesystem::copy()` won&amp;#39;t create a symlink to a directory](https://wg21.cmeerw.net/lwg/issue2682)
+    - C++17策定同時の仕様では、`copy(&amp;#34;/&amp;#34;, &amp;#34;root&amp;#34;, copy_options::create_symlinks);`のような状況 (コピー元がディレクトリで、`create_symlinks`オプション付き) でコピー先ディレクトリにシンボリックリンクが作られない問題があった。GNUの`cp -s`コマンドでは「ディレクトリ`&amp;#34;/&amp;#34;`の処理は省略された」と表示されてエラー終了する。この問題に対する仕様変更ではその動作に合わせて、コピー元がディレクトリで`create_symlinks`オプションが指定された場合、エラーを報告するようになった
+    - この問題は2016年4月に報告された。仕様としてはC++20に含まれるが、過去に遡ってC++17のコンパイラでもこの仕様に対応している可能性がある
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_array -- Merge pull request #787 from cpprefjp/fix-static_assert-description</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_array.html"/>
      <id>8d05c787c0bb157e1850a26b5b6a1439b2b274c3:reference/type_traits/is_array.md</id>
      <updated>2020-07-20T23:40:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_array.md b/reference/type_traits/is_array.md
index 9b469eb64..5f6b94aae 100644
--- a/reference/type_traits/is_array.md
+++ b/reference/type_traits/is_array.md
@@ -41,7 +41,7 @@ static_assert(std::is_same&amp;lt;std::is_array&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_
 static_assert(std::is_same&amp;lt;std::is_array&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_array&amp;lt;int&amp;gt;() == false, &amp;#34;is_array&amp;lt;int&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_array&amp;lt;int[]&amp;gt;::value == true, &amp;#34;int[] double is array&amp;#34;);
+static_assert(std::is_array&amp;lt;int[]&amp;gt;::value == true, &amp;#34;int[] is array&amp;#34;);
 static_assert(std::is_array&amp;lt;int*[2]&amp;gt;::value == true, &amp;#34;int*[2] is array&amp;#34;);
 static_assert(std::is_array&amp;lt;const unsigned[3][4]&amp;gt;::value == true, &amp;#34;const unsigned[3][4] is array&amp;#34;);
 static_assert(std::is_array&amp;lt;volatile long[][5]&amp;gt;::value == true, &amp;#34;volatile long[][5] is array&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>is_array -- fix static_assert description</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_array.html"/>
      <id>ea86d1bad62ce350a21791f27c75c135bd3d47fe:reference/type_traits/is_array.md</id>
      <updated>2020-07-20T22:03:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_array.md b/reference/type_traits/is_array.md
index 9b469eb64..5f6b94aae 100644
--- a/reference/type_traits/is_array.md
+++ b/reference/type_traits/is_array.md
@@ -41,7 +41,7 @@ static_assert(std::is_same&amp;lt;std::is_array&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_
 static_assert(std::is_same&amp;lt;std::is_array&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_array&amp;lt;int&amp;gt;() == false, &amp;#34;is_array&amp;lt;int&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_array&amp;lt;int[]&amp;gt;::value == true, &amp;#34;int[] double is array&amp;#34;);
+static_assert(std::is_array&amp;lt;int[]&amp;gt;::value == true, &amp;#34;int[] is array&amp;#34;);
 static_assert(std::is_array&amp;lt;int*[2]&amp;gt;::value == true, &amp;#34;int*[2] is array&amp;#34;);
 static_assert(std::is_array&amp;lt;const unsigned[3][4]&amp;gt;::value == true, &amp;#34;const unsigned[3][4] is array&amp;#34;);
 static_assert(std::is_array&amp;lt;volatile long[][5]&amp;gt;::value == true, &amp;#34;volatile long[][5] is array&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>wx257osn2@yahoo.co.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>丸カッコの値リストからの集成体初期化を許可 -- Update allow_initializing_aggregates_from_a_parenthesized_list_of_values.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html"/>
      <id>510a75587a8652d552c9cf9ff0398d758495ea5c:lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md</id>
      <updated>2020-07-19T23:04:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
index 3cd62f0ac..29079e510 100644
--- a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
+++ b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
@@ -115,3 +115,4 @@ explicit A(T1 t1, … , Tk tk);
 ## 参照
 
 - [P0960R3 Allow initializing aggregates from a parenthesized list of values](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0960r3.html)
+- [C++ Core Guidelines ES.23: Prefer the {}-initializer syntax](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es23-prefer-the--initializer-syntax) 常に波カッコで初期化することを推奨している。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>MATSUMURA Tetsuro</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>丸カッコの値リストからの集成体初期化を許可 -- Update allow_initializing_aggregates_from_a_parenthesized_list_of_values.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html"/>
      <id>2fdb23d9e2bea731c7ec3bc54d9b23d05607970f:lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md</id>
      <updated>2020-07-19T23:00:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
index f402a102c..3cd62f0ac 100644
--- a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
+++ b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
@@ -89,6 +89,25 @@ int main()
 丸カッコで集成体初期化を可能にすることで両者の差はより少なくなり、コンストラクタを書かなければいけない場面もより少なくなる。
 集成体初期化なのかコンストラクタ呼び出しなのかを意識せずに済むよう、丸カッコによる集成体初期化は丸カッコによるコンストラクタ呼び出しに近い意味論になっている。
 
+## 検討されたほかの選択肢
+
+以下のような案もあったが採用されなかった。
+
+1. 丸カッコによる集成体初期化を単純に波カッコに置き換えて解釈する
+2. コンストラクタ呼び出しと全く同じ意味論にする(コンストラクタを自動生成して呼び出す)
+
+丸カッコを単純に波カッコに置き換えて解釈すると、コンストラクタ呼び出しと同じ構文にもかかわらず意味論が異なり、混乱を招くという問題があった。
+
+コンストラクタを自動生成する案では、次のようなコンストラクタを生成することが考えられた。
+
+```cpp
+explicit A(T1&amp;amp;&amp;amp; t1, … , Tk&amp;amp;&amp;amp; tk);
+explicit A(T1 t1, … , Tk tk);
+```
+
+しかし、前者は参照型でないメンバーを左辺値で初期化することができない(関数テンプレートではないことに注意)。
+後者はムーブが必要になってしまうという問題があった。
+
 ## 関連項目
 
 - [一様初期化](/lang/cpp11/uniform_initialization.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>MATSUMURA Tetsuro</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>