<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-04-14T14:34:17.351275</updated>
  <id>d81618f4-68da-455d-9f6c-62764bf0b715</id>

  
    <entry>
      <title>cpprefjp - C++日本語リファレンス -- サイト外リンクでリンク切れしていたものを、web archiveに修正 #748</title>
      <link href="https://cpprefjp.github.io/index.html"/>
      <id>ad43a9aef71dab52026b8a5c74e5b52284755146:index.md</id>
      <updated>2020-04-14T17:56:54+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;cpprefjp - C++日本語リファレンス&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本サイトcpprefjpは、プログラミング言語C++のリファレンスを提供するWebサイトです。&lt;/p&gt;
&lt;p&gt;最新C++バージョンのリファレンスを提供していきます。&lt;/p&gt;
&lt;h2&gt;運営方針&lt;/h2&gt;
&lt;p&gt;本リファレンスサイトは、C++言語の最新のリファレンスを常に提供し続けることを目標にしています。&lt;/p&gt;
&lt;p&gt;各クラス、関数にはそれぞれ1つ以上のサンプルコードを付けていく方針です。&lt;/p&gt;
&lt;p&gt;本サイトでは、他サイトおよび規格書の直接的な翻訳ではなく、編集者の調査と考えに基づいた解説を提供していきます。&lt;/p&gt;
&lt;h2&gt;参加方法&lt;/h2&gt;
&lt;p&gt;本サイトは、多くのユーザの手によって書かれています。&lt;/p&gt;
&lt;p&gt;あなたがこの cpprefjp プロジェクトに参加したいのであれば、私達はそれをとても歓迎します。&lt;/p&gt;
&lt;p&gt;cpprefjp プロジェクトに参加する方法は簡単です。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cpprefjp/site/issues?state=open&#34; target=&#34;_blank&#34;&gt;cpprefjp の Issues&lt;/a&gt; にアクセスし、&lt;/li&gt;
&lt;li&gt;あなたが手伝えそうな、まだ誰にもアサインされていないタスクを見つけ、&lt;/li&gt;
&lt;li&gt;その Issue のコメントに「このタスクやります」と書く&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;これだけです。&lt;/p&gt;
&lt;p&gt;あとは、そのタスクを完了させて pull request を送れば、あなたも cpprefjp のコミッタになれます。&lt;/p&gt;
&lt;h2&gt;編集者向けのさらなる情報&lt;/h2&gt;
&lt;p&gt;本サイトは、GitHubのリポジトリ上で、Markdown形式でリファレンスを記載し、GitHub Pagesに自動反映するという形をとっています。本サイトのMarkdownソースは、以下のリポジトリにあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cpprefjp/site&#34; target=&#34;_blank&#34;&gt;https://github.com/cpprefjp/site&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記リポジトリのREADMEに、コアメンバの一覧を記載してありますので、何かありましたらそのうちの誰か、もしくはリポジトリへのIssueという形でご相談ください。&lt;/p&gt;
&lt;p&gt;本サイトの編集方法については、以下のドキュメントを参照してください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/editors_doc/start_editing.html&#34;&gt;cpprefjpを編集するには&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本サイトのコンテンツを作成、編集するにあたり、仕様を熟知し、一人で完璧に正しい内容を書くことは要求しません。&lt;/p&gt;
&lt;p&gt;たとえ間違ったことを記載した場合や、不安の残る内容を記載した場合でも、それに気づいた誰かが修正してくれます。&lt;/p&gt;
&lt;h2&gt;その他参考情報&lt;/h2&gt;
&lt;p&gt;以下のWebサイトから転載許可をいただいています。&lt;/p&gt;
&lt;p&gt;翻訳や解説などで活用してください：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://web.archive.org/web/20190112041213/http://episteme.wankuma.com/stlprog/index.html&#34; target=&#34;_blank&#34;&gt;Standard Template Library プログラミング on the Web&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;プライバシーポリシー&lt;/h2&gt;
&lt;p&gt;本サイトは、サイトの改善のためにGoogleアナリティクスを使用しています。本サイトをご利用中のブラウザは、Googleに特定の情報を自動的に送信します。本サイトは、この分析のためにCookieを使用します。利用者は、本サイトを利用することで、この目的においてCookieを使用することを許可したものとみなします。&lt;/p&gt;
&lt;p&gt;Googleによるデータ使用の詳細は、以下のURLで確認することができます。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.google.com/intl/ja/policies/privacy/partners/&#34; target=&#34;_blank&#34;&gt;https://www.google.com/intl/ja/policies/privacy/partners/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ライセンスについて&lt;/h2&gt;
&lt;p&gt;本サイトの情報は、&lt;a href=&#34;https://creativecommons.org/licenses/by/3.0/&#34; target=&#34;_blank&#34;&gt;クリエイティブ・コモンズ 表示 3.0 非移植 ライセンス(CC BY)&lt;/a&gt;の下に提供しています。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://i.creativecommons.org/l/by/3.0/88x31.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;cpprefjpサイトのアイコン・ロゴ画像は、&lt;a href=&#34;https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ja&#34; target=&#34;_blank&#34;&gt;クリエイティブ・コモンズ 表示 - 非営利 - 改変禁止 4.0 国際 (CC BY-NC-ND 4.0)&lt;/a&gt;の下に提供しています。&lt;/p&gt;
&lt;p&gt;高解像度画像データ： &lt;a href=&#34;https://github.com/cpprefjp/image/tree/master/cpprefjp/icon&#34; target=&#34;_blank&#34;&gt;cpprefjp/image&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://licensebuttons.net/l/by-nc-nd/4.0/88x31.png&#34; /&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>random -- サイト外リンクでリンク切れしていたものを、web archiveに修正 #748</title>
      <link href="https://cpprefjp.github.io/reference/random.html"/>
      <id>ad43a9aef71dab52026b8a5c74e5b52284755146:reference/random.md</id>
      <updated>2020-04-14T17:56:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/random.md b/reference/random.md
index 577424c09..1a09db031 100644
--- a/reference/random.md
+++ b/reference/random.md
@@ -236,7 +236,7 @@ int main()
 
 ## 参照
 ### 分布アルゴリズム
-* [さまざまな確率分布 (probability distributions)](http://www.biwako.shiga-u.ac.jp/sensei/mnaka/ut/statdist.html)
+* [さまざまな確率分布 (probability distributions)](https://web.archive.org/web/20190523080819/https://www.biwako.shiga-u.ac.jp/sensei/mnaka/ut/statdist.html)
 * [確率変数－種々の分布の特徴](https://sites.google.com/site/techdmba/distribution)
 
 ### 乱数ライブラリの使い方
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minstd_rand -- サイト外リンクでリンク切れしていたものを、web archiveに修正 #748</title>
      <link href="https://cpprefjp.github.io/reference/random/minstd_rand.html"/>
      <id>ad43a9aef71dab52026b8a5c74e5b52284755146:reference/random/minstd_rand.md</id>
      <updated>2020-04-14T17:56:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/random/minstd_rand.md b/reference/random/minstd_rand.md
index a0ba2a8ed..718600f0d 100644
--- a/reference/random/minstd_rand.md
+++ b/reference/random/minstd_rand.md
@@ -113,6 +113,6 @@ int main()
 
 ## 参照
 - [Lehmer random number generator - Wikipedia](https://en.wikipedia.org/wiki/Lehmer_random_number_generator)
-- [MINSTD - Classical LSGs](http://random.mat.sbg.ac.at/results/karl/server/node4.html#SECTION00042000000000000000)
+- [MINSTD - Classical LSGs](https://web.archive.org/web/20181030204012/http://random.mat.sbg.ac.at/results/karl/server/node4.html#SECTION00042000000000000000)
 - &amp;#34;Random Number Generators: Good ones are hard to find&amp;#34;, Stephen K. Park and Keith W. Miller, Communications of the ACM, Vol. 31, No. 10, October 1988, pp. 1192-1201
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minstd_rand0 -- サイト外リンクでリンク切れしていたものを、web archiveに修正 #748</title>
      <link href="https://cpprefjp.github.io/reference/random/minstd_rand0.html"/>
      <id>ad43a9aef71dab52026b8a5c74e5b52284755146:reference/random/minstd_rand0.md</id>
      <updated>2020-04-14T17:56:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/random/minstd_rand0.md b/reference/random/minstd_rand0.md
index 9aa0419ba..2809d0d34 100644
--- a/reference/random/minstd_rand0.md
+++ b/reference/random/minstd_rand0.md
@@ -116,6 +116,6 @@ int main()
 ## 参照
 - [Lehmer random number generator - Wikipedia](https://en.wikipedia.org/wiki/Lehmer_random_number_generator)
 - [Stephen K. Park and Keith W. Miller (1988). &amp;#34;Random Number Generators: Good Ones Are Hard To Find&amp;#34;. Communications of the ACM 31 (10): 1192–1201. doi:10.1145/63039.63042.](http://www.firstpr.com.au/dsp/rand31/p1192-park.pdf)
-- [MINSTD - Classical LSGs](http://random.mat.sbg.ac.at/results/karl/server/node4.html#SECTION00042000000000000000)
+- [MINSTD - Classical LSGs](https://web.archive.org/web/20181030204012/http://random.mat.sbg.ac.at/results/karl/server/node4.html#SECTION00042000000000000000)
 - A pseudo-random number generator for the System/360, P.A. Lewis, A.S. Goodman, J.M. Miller, IBM Systems Journal, Vol. 8, No. 2, 1969, pp. 136-146
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>スタイル -- 訳語表 : 伝播を記載</title>
      <link href="https://cpprefjp.github.io/working_style.html"/>
      <id>1859685731f023df519a5ebef3fdfada3d4757ae:working_style.md</id>
      <updated>2020-04-14T15:19:46+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;スタイル&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本サイトで作業を行う上でのスタイルです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「である」調&lt;/li&gt;
&lt;li&gt;句読点は「、」「。」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型修飾のスタイル：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A) const T &amp;amp;v&lt;/li&gt;
&lt;li&gt;B) const T&amp;amp; v&lt;/li&gt;
&lt;li&gt;C) const T &amp;amp; v&lt;/li&gt;
&lt;li&gt;D) T const &amp;amp;v&lt;/li&gt;
&lt;li&gt;E) T const&amp;amp; v&lt;/li&gt;
&lt;li&gt;F) T const &amp;amp; v&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本サイトでは、Bのスタイルで型修飾を行います。&lt;/p&gt;
&lt;h2&gt;バージョンの表記&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;p&gt;C++11以降対応については対応バージョンを明記します。バージョン表記が省略されている場合、C++03、C++98対応であることを表します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;li&gt;C++14&lt;/li&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;li&gt;C++03&lt;/li&gt;
&lt;li&gt;C++98&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;p&gt;開発環境の表記がない場合は、C++98対応のあらゆる環境で使用できるものとします。 
処理系の記載は、作業者が確認できたものを記載します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Clang: 2.1, 2.8&lt;/li&gt;
&lt;li&gt;GCC: 4.3.4, 4.4.3, 4.4.4, 4.5.2&lt;/li&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1, 12.0&lt;/li&gt;
&lt;li&gt;PathScale: 3.2&lt;/li&gt;
&lt;li&gt;QCC&lt;/li&gt;
&lt;li&gt;Visual C++: 2003, 2008, 2010&lt;/li&gt;
&lt;li&gt;pgCC: 11.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それと、訳語表を随時更新していってください。&lt;/p&gt;
&lt;h3&gt;訳語表&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英語&lt;/th&gt;
&lt;th&gt;日本語&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abstract class&lt;/td&gt;
&lt;td&gt;抽象クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;aggregate&lt;/td&gt;
&lt;td&gt;集成体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alignment&lt;/td&gt;
&lt;td&gt;アライメント (表示位置ではなくメモリの文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;apply, application&lt;/td&gt;
&lt;td&gt;適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arithmetic type&lt;/td&gt;
&lt;td&gt;算術型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;associative container(s)&lt;/td&gt;
&lt;td&gt;連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;base class&lt;/td&gt;
&lt;td&gt;基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bidirectional iterator&lt;/td&gt;
&lt;td&gt;双方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bucket&lt;/td&gt;
&lt;td&gt;バケット&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;complexity&lt;/td&gt;
&lt;td&gt;計算量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compound type&lt;/td&gt;
&lt;td&gt;複合型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const iterator&lt;/td&gt;
&lt;td&gt;読み取り専用イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const reverse iterator&lt;/td&gt;
&lt;td&gt;読み取り専用逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;covariant&lt;/td&gt;
&lt;td&gt;共変的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereference&lt;/td&gt;
&lt;td&gt;間接参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereferenceable&lt;/td&gt;
&lt;td&gt;間接参照可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;derived class&lt;/td&gt;
&lt;td&gt;派生クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;direct base class&lt;/td&gt;
&lt;td&gt;直接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;effects&lt;/td&gt;
&lt;td&gt;効果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emplace&lt;/td&gt;
&lt;td&gt;直接構築&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equal&lt;/td&gt;
&lt;td&gt;等値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence class&lt;/td&gt;
&lt;td&gt;同値分類 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence relation&lt;/td&gt;
&lt;td&gt;同値関係 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalent&lt;/td&gt;
&lt;td&gt;同値 (数学的文脈)、等価 (その他文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forward iterator&lt;/td&gt;
&lt;td&gt;前方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fundamental type&lt;/td&gt;
&lt;td&gt;単純型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ill-formed&lt;/td&gt;
&lt;td&gt;不適格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;implementation-defined&lt;/td&gt;
&lt;td&gt;処理系定義&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indirect base class&lt;/td&gt;
&lt;td&gt;間接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;inherited&lt;/td&gt;
&lt;td&gt;継承&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input iterator&lt;/td&gt;
&lt;td&gt;入力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;literal type&lt;/td&gt;
&lt;td&gt;リテラル型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load factor&lt;/td&gt;
&lt;td&gt;負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lvalue reference&lt;/td&gt;
&lt;td&gt;左辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max load factor&lt;/td&gt;
&lt;td&gt;最大負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;member&lt;/td&gt;
&lt;td&gt;メンバ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move&lt;/td&gt;
&lt;td&gt;(std::move 的な意味で)ムーブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move assignment&lt;/td&gt;
&lt;td&gt;ムーブ代入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move constructor&lt;/td&gt;
&lt;td&gt;ムーブコンストラクタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mutable iterator&lt;/td&gt;
&lt;td&gt;可変イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;non-virtual base class&lt;/td&gt;
&lt;td&gt;非仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;note&lt;/td&gt;
&lt;td&gt;注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output iterator&lt;/td&gt;
&lt;td&gt;出力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overload&lt;/td&gt;
&lt;td&gt;オーバーロード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partial ordering&lt;/td&gt;
&lt;td&gt;半順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partition&lt;/td&gt;
&lt;td&gt;区分化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ポインタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;polymorphic&lt;/td&gt;
&lt;td&gt;多相的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;power of N&lt;/td&gt;
&lt;td&gt;Nの累乗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;predicate&lt;/td&gt;
&lt;td&gt;述語&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;propagation, propagate&lt;/td&gt;
&lt;td&gt;伝播&lt;br /&gt; (伝搬は誤用が広まったものなので使わない)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pure virtual function&lt;/td&gt;
&lt;td&gt;純粋仮想関数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;random access iterator&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;範囲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;remarks&lt;/td&gt;
&lt;td&gt;備考&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;requires&lt;/td&gt;
&lt;td&gt;要件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;returns&lt;/td&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reverse iterator&lt;/td&gt;
&lt;td&gt;逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rvalue reference&lt;/td&gt;
&lt;td&gt;右辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sequence container(s)&lt;/td&gt;
&lt;td&gt;シーケンスコンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;signed&lt;/td&gt;
&lt;td&gt;符号付き&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop request&lt;/td&gt;
&lt;td&gt;停止要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop state&lt;/td&gt;
&lt;td&gt;停止状態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spurious Failure&lt;/td&gt;
&lt;td&gt;見かけ上の失敗&lt;br /&gt; &lt;a href=&#34;https://togetter.com/li/430770&#34; target=&#34;_blank&#34;&gt;https://togetter.com/li/430770&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strict weak ordering&lt;/td&gt;
&lt;td&gt;狭義の弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strong ordering&lt;/td&gt;
&lt;td&gt;全順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;synchronization&lt;/td&gt;
&lt;td&gt;同期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;total ordering relationalship&lt;/td&gt;
&lt;td&gt;全順序関係&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trailing return type&lt;/td&gt;
&lt;td&gt;後置戻り値型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trait&lt;/td&gt;
&lt;td&gt;トレイト&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trivial&lt;/td&gt;
&lt;td&gt;自明 (逆は非自明)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underlying type&lt;/td&gt;
&lt;td&gt;基底型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unordered associative container(s)&lt;/td&gt;
&lt;td&gt;非順序連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unspecified&lt;/td&gt;
&lt;td&gt;未規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;virtual base class&lt;/td&gt;
&lt;td&gt;仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;weak ordering&lt;/td&gt;
&lt;td&gt;弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;well-formed&lt;/td&gt;
&lt;td&gt;適格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- string::operator+ : 表の並び順修正</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>f758e082b24c76af5c67290766b329f830d8b519:reference/string/basic_string/op_plus.md</id>
      <updated>2020-04-14T14:09:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index b69c8b7d7..da8d2c48b 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -180,17 +180,17 @@ C++20からこの演算子による文字列連結時にアロケータがどの
 |オーバーロード|C++17まで|GCC|clang|MSVC|C++20から|
 |----|----|----|----|----|----|
 |(1) : `lhs + rhs`|`lhs`からのSOCCC|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(3) : `lhs + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 |(2) : `std::move(lhs) + rhs`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(3) : `lhs + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 |(4) : `std::move(lhs) + std::move(rhs)`|`lhs`または`rhs`|`lhs`|`lhs`|`lhs`|`lhs`|
-|(9) : `lhs + &amp;#34;rhs&amp;#34;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(11) : `lhs + &amp;#39;r&amp;#39;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(10) : `std::move(lhs) + &amp;#34;rhs&amp;#34;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
-|(12) : `std::move(lhs) + &amp;#39;r&amp;#39;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
 |(5) : `&amp;#34;lhs&amp;#34; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
-|(7) : `&amp;#39;l&amp;#39; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
 |(6) : `&amp;#34;lhs&amp;#34; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(7) : `&amp;#39;l&amp;#39; + rhs`|新規にデフォルト構築|新規にデフォルト構築|`rhs`|新規にデフォルト構築|`lhs`からのSOCCC|
 |(8) : `&amp;#39;l&amp;#39; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
+|(9) : `lhs + &amp;#34;rhs&amp;#34;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(10) : `std::move(lhs) + &amp;#34;rhs&amp;#34;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
+|(11) : `lhs + &amp;#39;r&amp;#39;`|新規にデフォルト構築|`lhs`からのSOCCC|`lhs`|新規にデフォルト構築|`lhs`からのSOCCC|
+|(12) : `std::move(lhs) + &amp;#39;r&amp;#39;`|`lhs`|`lhs`|`lhs`|`lhs`|`lhs`|
 
 
 表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝播仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>属性構文 -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/attributes.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:lang/cpp11/attributes.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/attributes.md b/lang/cpp11/attributes.md
index e060c678b..a268b81cb 100644
--- a/lang/cpp11/attributes.md
+++ b/lang/cpp11/attributes.md
@@ -52,7 +52,7 @@ int main()
 
 
 ### &amp;lt;a id=&amp;#34;carries_dependency&amp;#34; href=&amp;#34;#carries_dependency&amp;#34;&amp;gt;`[[carries_dependency]]`属性&amp;lt;/a&amp;gt;
-`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order_consume`](/reference/atomic/memory_order.md)を、関数をまたいで伝搬することを明示するための属性である。
+`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order_consume`](/reference/atomic/memory_order.md)を、関数をまたいで伝播することを明示するための属性である。
 
 以下は、[`memory_order_consume`](/reference/atomic/memory_order.md)を使用した順序付けの例である：
 
@@ -70,10 +70,10 @@ if (r1) {
 * x.load[link /reference/atomic/atomic/load.md]
 * memory_order_consume[link /reference/atomic/memory_order.md]
 
-ここでは、`r1`に関連する操作が全て同一関数内で行われているが、一部の操作が別の関数になっていると、別の関数になった操作に値の依存があるかどうか・依存として扱ってよいのかどうかがコンパイラに判断できない可能性がある。そのような状況で、関数のパラメータおよび戻り値のそれぞれが値の依存性を伝搬させることを明示するために`[[carries_dependency]]`属性を使用する。
+ここでは、`r1`に関連する操作が全て同一関数内で行われているが、一部の操作が別の関数になっていると、別の関数になった操作に値の依存があるかどうか・依存として扱ってよいのかどうかがコンパイラに判断できない可能性がある。そのような状況で、関数のパラメータおよび戻り値のそれぞれが値の依存性を伝播させることを明示するために`[[carries_dependency]]`属性を使用する。
 
 
-#### 関数の戻り値で値の依存性を伝搬させる
+#### 関数の戻り値で値の依存性を伝播させる
 関数の戻り値に対して値の依存性を持たせる場合、関数に対して`[[carries_dependency]]`属性を付加する。
 
 ```cpp
@@ -94,7 +94,7 @@ if (r1) {
 * memory_order_consume[link /reference/atomic/memory_order.md]
 
 
-#### 関数のパラメータで値の依存性を伝搬させる
+#### 関数のパラメータで値の依存性を伝播させる
 関数のパラメータに対して値の依存性を持たせる場合、各パラメータ名のうしろに`[[carries_dependency]]`属性を付加する。
 
 ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/allocator.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator.md b/reference/memory/allocator.md
index da96c6715..12acf9aef 100644
--- a/reference/memory/allocator.md
+++ b/reference/memory/allocator.md
@@ -55,7 +55,7 @@ C++11から：
 | 名前 | 説明 | 対応バージョン |
 |-------------------|----------------------------------------------|-------|
 | `value_type`      | 要素の型 `T`                                 | |
-| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータの状態を伝搬するか。 [`true_type`](/reference/type_traits/true_type.md) | C++14 |
+| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータの状態を伝播するか。 [`true_type`](/reference/type_traits/true_type.md) | C++14 |
 | `size_type`       | 要素数を表す符号なし整数型 `size_t`          | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `difference_type` | ポインタの差を表す符号付き整数型 `ptrdiff_t` | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
 | `pointer`         | 要素のポインタ型 `T*`                        | C++17から非推奨&amp;lt;br/&amp;gt; C++20で削除 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>allocator_traits -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/allocator_traits.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/allocator_traits.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/allocator_traits.md b/reference/memory/allocator_traits.md
index 7b3bc0e05..83101640f 100644
--- a/reference/memory/allocator_traits.md
+++ b/reference/memory/allocator_traits.md
@@ -45,9 +45,9 @@ namespace std {
 | `const_void_pointer`    | 読み取り専用の`void`のポインタ型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`const_void_pointer`を持っていればそれを使用し、そうでなければ[`pointer_traits`](pointer_traits.md)`&amp;lt;pointer&amp;gt;::rebind&amp;lt;const void&amp;gt;`を使用する。 | C++11 |
 | `difference_type` | ポインタの差を表す符号付き整数型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`difference_type`を持っていればそれを使用し、そうでなければ[`pointer_traits`](pointer_traits.md)`&amp;lt;pointer&amp;gt;::difference_type`を使用する。 | C++11 |
 | `size_type`       | 要素数を表す符号なし整数型。&amp;lt;br/&amp;gt; `Alloc`がメンバ型`size_type`を持っていればそれを使用し、そうでなければ[`make_unsigned`](/reference/type_traits/make_unsigned.md)`&amp;lt;difference_type&amp;gt;::type`を使用する。 | C++11 |
-| `propagate_on_container_copy_assignment` | コンテナのコピー代入時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_copy_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
-| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_move_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
-| `propagate_on_container_swap` | コンテナの交換時に、アロケータオブジェクトをコピー(伝搬)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_swap`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_copy_assignment` | コンテナのコピー代入時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_copy_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_move_assignment` | コンテナのムーブ代入時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_move_assignment`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
+| `propagate_on_container_swap` | コンテナの交換時に、アロケータオブジェクトをコピー(伝播)するか否か。&amp;lt;br/&amp;gt;`Alloc`がメンバ型`propagate_on_container_swap`を持っていればそれを使用し、そうでなければ[`false_type`](/reference/type_traits/false_type.md)を使用する。 | C++11 |
 | `is_always_equal` | `Alloc::is_always_equal`が存在する場合は`Alloc::is_always_equal`。それ以外の場合は`is_empty&amp;lt;Alloc&amp;gt;::type`。 | C++17 |
 | `rebind_alloc&amp;lt;U&amp;gt;` | 型`U`を確保するようにアロケータ型を再束縛する。&amp;lt;br/&amp;gt; `Alloc::rebind&amp;lt;U&amp;gt;::other`が有効ならそれを使用し、そうでなければ`Alloc&amp;lt;U, Args`&amp;gt;を使用する。`Alloc`がクラステンプレートでない場合、`rebind_alloc`の使用は不適格となる。 | C++11 |
 | `rebind_traits&amp;lt;U&amp;gt;` | 再束縛した型`U`に対する`allocator_traits`。`allocator_traits&amp;lt;rebind_alloc&amp;lt;U&amp;gt;&amp;gt;` | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uses_allocator -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory/uses_allocator.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory/uses_allocator.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uses_allocator.md b/reference/memory/uses_allocator.md
index 1733788f9..b312c6123 100644
--- a/reference/memory/uses_allocator.md
+++ b/reference/memory/uses_allocator.md
@@ -51,7 +51,7 @@ namespace std {
 - 本型トレイツは、主にスコープアロケータモデルを採用するアロケータで使用されることを意図している。  
 	標準ライブラリでは、[`scoped_allocator_adaptor`](/reference/scoped_allocator/scoped_allocator_adaptor.md)、[`polymorphic_allocator`](../memory_resource/polymorphic_allocator.md) クラステンプレートで使用されている。
 - 標準ライブラリで提供されるいくつかの型は本型トレイツの特殊化を提供している。（[`tuple`](../tuple/tuple.md)、[`promise`](../future/promise.md)、各種コンテナアダプタ等）  
-- [`pair`](../utility/pair.md) は [`tuple`](../tuple/tuple.md) と同列の機能と考えられるが、本型トレイツの特殊化を提供していない。このため、標準ライブラリで提供されるスコープアロケータモデルを採用したアロケータでは C++17 までは独自に [`pair`](../utility/pair.md) の各要素に対して uses-allocator 構築を適用している（ただし、ネストした [`pair`](/reference/utility/pair.md) の要素に対してはアロケータは伝搬されない）。  
+- [`pair`](../utility/pair.md) は [`tuple`](../tuple/tuple.md) と同列の機能と考えられるが、本型トレイツの特殊化を提供していない。このため、標準ライブラリで提供されるスコープアロケータモデルを採用したアロケータでは C++17 までは独自に [`pair`](../utility/pair.md) の各要素に対して uses-allocator 構築を適用している（ただし、ネストした [`pair`](/reference/utility/pair.md) の要素に対してはアロケータは伝播されない）。  
 	スコープアロケータモデルを採用したアロケータを自作する場合には、同様の対応を行う方が良いだろう。  
 	なお、C++20 で [`pair`](../utility/pair.md) に対する特殊対応を含めた uses-allocator 構築サポートのためのユーティリティ関数が追加されたため、以前に比べて容易に uses-allocator 構築への対応が可能となった。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>construct -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator/construct.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/memory_resource/polymorphic_allocator/construct.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/polymorphic_allocator/construct.md b/reference/memory_resource/polymorphic_allocator/construct.md
index bd2dacf0e..7610c3225 100644
--- a/reference/memory_resource/polymorphic_allocator/construct.md
+++ b/reference/memory_resource/polymorphic_allocator/construct.md
@@ -213,7 +213,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -227,7 +227,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -241,7 +241,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -256,7 +256,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 
@@ -270,7 +270,7 @@ int main()
 
     std::cout &amp;lt;&amp;lt; p-&amp;gt;first &amp;lt;&amp;lt; std::endl;
     std::cout &amp;lt;&amp;lt; p-&amp;gt;second &amp;lt;&amp;lt; std::endl;
-    //アロケータが伝搬している
+    //アロケータが伝播している
     std::cout &amp;lt;&amp;lt; (p-&amp;gt;second.get_allocator() == alloc) &amp;lt;&amp;lt; std::endl;
   }
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scoped_allocator_adaptor -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/scoped_allocator/scoped_allocator_adaptor.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/scoped_allocator/scoped_allocator_adaptor.md b/reference/scoped_allocator/scoped_allocator_adaptor.md
index f152fb0f2..30efb5292 100644
--- a/reference/scoped_allocator/scoped_allocator_adaptor.md
+++ b/reference/scoped_allocator/scoped_allocator_adaptor.md
@@ -24,11 +24,11 @@ namespace std {
 
 ![](https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_02.png)
 
-図2 コンテナとその要素で、アロケータオブジェクトの状態を伝搬させる(例1)
+図2 コンテナとその要素で、アロケータオブジェクトの状態を伝播させる(例1)
 
 ![](https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_03.png)
 
-図3 全ての要素にアロケータオブジェクトの状態を伝搬させる(例2)
+図3 全ての要素にアロケータオブジェクトの状態を伝播させる(例2)
 
 
 
@@ -99,7 +99,7 @@ namespace std {
 | [`(deduction_guide)`](scoped_allocator_adaptor/op_deduction_guide.md) | クラステンプレートの推論補助 | C++17 |
 
 
-## 例1 コンテナとその要素で、アロケータオブジェクトの状態を伝搬させる
+## 例1 コンテナとその要素で、アロケータオブジェクトの状態を伝播させる
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -176,7 +176,7 @@ int main()
 5
 ```
 
-## 例2 全ての要素にアロケータオブジェクトの状態を伝搬させる
+## 例2 全ての要素にアロケータオブジェクトの状態を伝播させる
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -242,7 +242,7 @@ int main()
   std::cout &amp;lt;&amp;lt; &amp;#34;container allocator : &amp;#34; &amp;lt;&amp;lt; v.get_allocator().getState() &amp;lt;&amp;lt; std::endl;
 
   // 要素に使用されるアロケータの状態を確認
-  // 全ての要素に、アロケータの状態が伝搬される
+  // 全ての要素に、アロケータの状態が伝播される
   for (const forward_list&amp;amp; x : v) {
     std::cout &amp;lt;&amp;lt; &amp;#34;element allocator : &amp;#34; &amp;lt;&amp;lt; x.get_allocator().getState() &amp;lt;&amp;lt; std::endl;
   }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>construct -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/construct.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/scoped_allocator/scoped_allocator_adaptor/construct.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/scoped_allocator/scoped_allocator_adaptor/construct.md b/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
index 539f4dd38..837bbee42 100644
--- a/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
+++ b/reference/scoped_allocator/scoped_allocator_adaptor/construct.md
@@ -137,7 +137,7 @@ void construct_propagate_alloc()
   const std::size_t n = 1;
   string* p = alloc.allocate(n);
 
-  // (1) 以下のコンストラクタを呼び出し、アロケータオブジェクトを伝搬させる
+  // (1) 以下のコンストラクタを呼び出し、アロケータオブジェクトを伝播させる
   // basic_string(const char*, Allocator)
   alloc.construct(p, &amp;#34;hello&amp;#34;);
 
@@ -157,7 +157,7 @@ void construct_pair()
 
   // (2)
   // pairの各要素に対して以下のコンストラクタを呼び出し、
-  // アロケータオブジェクトを伝搬させる。
+  // アロケータオブジェクトを伝播させる。
   // basic_string(const char*, Allocator)
   std::pair&amp;lt;string, string&amp;gt;* pair_p = p;
   alloc.construct(p, std::piecewise_construct,
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- s/伝搬/伝播/ 伝搬は誤用が広まったものであるため、伝播に修正</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_plus.html"/>
      <id>5b1ec3cab74f2126997964a21c47b7fd668ce046:reference/string/basic_string/op_plus.md</id>
      <updated>2020-04-14T13:26:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_plus.md b/reference/string/basic_string/op_plus.md
index 9cba8ea23..b69c8b7d7 100644
--- a/reference/string/basic_string/op_plus.md
+++ b/reference/string/basic_string/op_plus.md
@@ -173,9 +173,9 @@ basic_string&amp;lt;charT, traits, Allocator&amp;gt;
 ## 備考
 (5)、(6) の形式の `lhs`、および、(9)、(10) の形式の `rhs` の文字列長算出のために `traits::length()` が使用される
 
-## アロケータの伝搬
+## アロケータの伝播
 
-C++20からこの演算子による文字列連結時にアロケータがどのように伝搬するかが変更された。C++17までの仕様及び各実装とC++20からの各オーバーロード利用時の結果オブジェクトへのアロケータ供給元は次のようになる。なお、SOCCCは[`select_on_container_copy_construction`](/reference/memory/allocator_traits/select_on_container_copy_construction.md)の略。
+C++20からこの演算子による文字列連結時にアロケータがどのように伝播するかが変更された。C++17までの仕様及び各実装とC++20からの各オーバーロード利用時の結果オブジェクトへのアロケータ供給元は次のようになる。なお、SOCCCは[`select_on_container_copy_construction`](/reference/memory/allocator_traits/select_on_container_copy_construction.md)の略。
 
 |オーバーロード|C++17まで|GCC|clang|MSVC|C++20から|
 |----|----|----|----|----|----|
@@ -193,7 +193,7 @@ C++20からこの演算子による文字列連結時にアロケータがどの
 |(8) : `&amp;#39;l&amp;#39; + std::move(rhs)`|`rhs`|`rhs`|`rhs`|`rhs`|`rhs`|
 
 
-表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝搬仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
+表にあるように、C++17までの仕様に完全に準拠している実装は無かった上に各実装によって伝播仕様がバラバラだったため、この変更によって影響を受けるコードはほぼ無いと思われる。
 
 ## 例
 ```cpp example
@@ -226,4 +226,4 @@ Hello, world!
 | [`insert`](insert.md)       | 文字／文字列を挿入する |
 
 ## 参照
-- [P1165R1 Make stateful allocator propagation more consistent for operator+(basic_string)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1165r1.html)
\ No newline at end of file
+- [P1165R1 Make stateful allocator propagation more consistent for operator+(basic_string)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1165r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>