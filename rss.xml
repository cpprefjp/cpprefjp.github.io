<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-06-22T14:39:19.172153</updated>
  <id>fa880158-770b-4641-9418-160e684ead13</id>

  
    <entry>
      <title>flat_map -- flat_map : eraseを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map.html"/>
      <id>2ba5e134badc55935bde36761d61ced7bc9dcd68:reference/flat_map/flat_map.md</id>
      <updated>2023-06-22T16:47:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map.md b/reference/flat_map/flat_map.md
index c699ae3a3..a64b6db0b 100644
--- a/reference/flat_map/flat_map.md
+++ b/reference/flat_map/flat_map.md
@@ -64,7 +64,7 @@ namespace std {
 | [`emplace`](flat_map/emplace.md)                   | 要素を直接構築する                         | C++23 |
 | [`emplace_hint`](flat_map/emplace_hint.md)         | ヒントを使って要素を直接構築する           | C++23 |
 | [`try_emplace`](flat_map/try_emplace.md.nolink)           | キーが存在しない場合のみ要素を直接構築する | C++23 |
-| [`erase`](flaflat_maptmap/erase.md.nolink)                | 要素を削除する                             | C++23 |
+| [`erase`](flat_map/erase.md)                       | 要素を削除する                             | C++23 |
 | [`swap`](flat_map/swap.md.nolink)                         | コンテンツを交換する                       | C++23 |
 | [`extract`](flat_map/extract.md.nolink)                   | キーのコンテナ、値のコンテナを取得する     | C++23 |
 | [`replace`](flat_map/replace.md.nolink)                   | キーのコンテナ、値のコンテナを置き換える   | C++23 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- flat_map : eraseを追加 #1078</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/erase.html"/>
      <id>2ba5e134badc55935bde36761d61ced7bc9dcd68:reference/flat_map/flat_map/erase.md</id>
      <updated>2023-06-22T16:47:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/erase.md b/reference/flat_map/flat_map/erase.md
new file mode 100644
index 000000000..866a61380
--- /dev/null
+++ b/reference/flat_map/flat_map/erase.md
@@ -0,0 +1,169 @@
+# erase
+* flat_map[meta header]
+* std[meta namespace]
+* flat_map[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator erase(iterator position);                         // (1) C++23
+
+iterator erase(const_iterator position);                   // (2) C++23
+
+size_type erase(const key_type&amp;amp; x);                        // (3) C++23
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+iterator erase(const_iterator first, const_iterator last); // (5) C++23
+```
+
+## 概要
+単一要素またはイテレータ範囲`[first, last)`を `map` コンテナから削除する。
+
+これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
+
+- (1) : 指定されたイテレータが指す要素を削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素を削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素を削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
+
+
+## パラメータ
+- `position` : 削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
+- `x` : 削除する値のキー。`key_type` はメンバ型であり、コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素のキーの型である。
+- `first, last` : 削除するイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+
+
+## 戻り値
+- (1), (2), (5) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す。
+
+
+## 計算量
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
+
+
+## 備考
+- この関数に、範囲外のイテレータ (終端イテレータを含む) や存在しないキーを指定した場合の動作は未定義
+- 削除された要素を指すイテレータ、および、参照のみ無効になる。なお、規格書に明確な記載は無いが、削除された要素を指すポインタも無効になる
+- ループ中で `map` の要素を削除するためには、C++03 までは以下のようなコードを書く必要があった。
+    ```cpp
+    while (it != map_object.end()) {
+      if (条件) {
+        map_object.erase(it++);
+      }
+      else {
+        ++it;
+      }
+    }
+    ```
+
+    - これは、`erase` で指定したイテレータが、対象となる要素が削除されることによって無効になるため、後置インクリメント `it++` を使用することで要素が削除されるより先に削除対象の次の要素を指すようにするためである。
+    - このような書き方は C++11 以降でも依然として有効だが、`erase` が削除された次の要素を指すイテレータを返すようになったため、以下のようなコードを
+    ```cpp
+    map_object.erase(it++);
+    ```
+
+    - 以下のように書くこともできるようになった
+    ```cpp
+    it = map_object.erase(it);
+    ```
+
+
+## 例
+### 基本的な使い方 (C++23)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+
+int main()
+{
+  std::flat_map&amp;lt;int, char&amp;gt; fm = {
+    {1, &amp;#39;A&amp;#39;},
+    {2, &amp;#39;B&amp;#39;},
+    {3, &amp;#39;C&amp;#39;}
+  };
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.erase(1);
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.erase(fm.begin(), fm.end());
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+}
+```
+* erase[color ff0000]
+* fm.size()[link size.md]
+* fm.begin()[link begin.md]
+* fm.end()[link end.md]
+
+#### 出力
+```
+3
+2
+0
+```
+
+### イテレート中に要素を削除する (C++23)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+
+int main()
+{
+  std::flat_map&amp;lt;int, char&amp;gt; fm = {
+    {3, &amp;#39;a&amp;#39;},
+    {1, &amp;#39;b&amp;#39;},
+    {4, &amp;#39;c&amp;#39;}
+  };
+
+  // イテレート中に要素削除をするような場合には、
+  // 範囲for文は使用できない
+  for (auto it = fm.begin(); it != fm.end();) {
+    // 条件一致した要素を削除する
+    if (it-&amp;gt;first == 1) {
+      // 削除された要素の次を指すイテレータが返される。
+      it = fm.erase(it);
+    }
+    // 要素削除をしない場合に、イテレータを進める
+    else {
+      ++it;
+    }
+  }
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#39;:&amp;#39; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+
+#### 出力
+```
+3:a
+4:c
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|---------------------------------|----------------------|
+| [`flat_map::clear`](clear.md)   | 全ての要素を削除する |
+| [`flat_map::insert`](insert.md.nolink) | 要素を挿入する |
+| [`flat_map::find`](find.md)     | 指定したキーで要素を探す |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : サンプルコード中で未定義動作をしていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/map/map/erase.html"/>
      <id>a6c9e227b387d2aa8631acc1df6f78468d690702:reference/map/map/erase.md</id>
      <updated>2023-06-22T16:41:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/erase.md b/reference/map/map/erase.md
index 84fe25a4f..f40a1cb9a 100644
--- a/reference/map/map/erase.md
+++ b/reference/map/map/erase.md
@@ -99,9 +99,6 @@ int main()
   m.erase(1);
   std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
 
-  m.erase(5);
-  std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
-
   m.erase(m.begin(), m.end());
   std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
 
@@ -118,7 +115,6 @@ int main()
 ```
 3
 2
-2
 0
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : サンプルコード中で未定義動作をしていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/erase.html"/>
      <id>a6c9e227b387d2aa8631acc1df6f78468d690702:reference/map/multimap/erase.md</id>
      <updated>2023-06-22T16:41:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/erase.md b/reference/map/multimap/erase.md
index f52bcb6cf..47d878c4d 100644
--- a/reference/map/multimap/erase.md
+++ b/reference/map/multimap/erase.md
@@ -99,9 +99,6 @@ int main()
   m.erase(1);
   std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
 
-  m.erase(5);
-  std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
-
   m.erase(m.begin(), m.end());
   std::cout &amp;lt;&amp;lt; m.size() &amp;lt;&amp;lt; std::endl;
 
@@ -118,7 +115,6 @@ int main()
 ```
 3
 2
-2
 0
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : サンプルコード中で未定義動作をしていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/erase.html"/>
      <id>a6c9e227b387d2aa8631acc1df6f78468d690702:reference/set/multiset/erase.md</id>
      <updated>2023-06-22T16:41:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/erase.md b/reference/set/multiset/erase.md
index f8cd9641c..4ed6d8977 100644
--- a/reference/set/multiset/erase.md
+++ b/reference/set/multiset/erase.md
@@ -99,9 +99,6 @@ int main()
   c.erase(10);
   std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
 
-  c.erase(5);
-  std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
-
   c.erase(c.begin(), c.end());
   std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
 }
@@ -116,7 +113,6 @@ int main()
 ```
 3
 1
-1
 0
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : サンプルコード中で未定義動作をしていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/set/set/erase.html"/>
      <id>a6c9e227b387d2aa8631acc1df6f78468d690702:reference/set/set/erase.md</id>
      <updated>2023-06-22T16:41:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/erase.md b/reference/set/set/erase.md
index 683180d57..2b3f85a0e 100644
--- a/reference/set/set/erase.md
+++ b/reference/set/set/erase.md
@@ -99,9 +99,6 @@ int main()
   c.erase(10);
   std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
 
-  c.erase(5);
-  std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
-
   c.erase(c.begin(), c.end());
   std::cout &amp;lt;&amp;lt; c.size() &amp;lt;&amp;lt; std::endl;
 }
@@ -116,7 +113,6 @@ int main()
 ```
 3
 2
-2
 0
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- map / setのextract : C++23でのheterogeneousなオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/map/map/extract.html"/>
      <id>6eaa82d487e3c732fa17de04e4bf624125036174:reference/map/map/extract.md</id>
      <updated>2023-06-22T16:34:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/extract.md b/reference/map/map/extract.md
index 07df0c89b..d181eed22 100644
--- a/reference/map/map/extract.md
+++ b/reference/map/map/extract.md
@@ -6,13 +6,20 @@
 * cpp17[meta cpp]
 
 ```cpp
-node_type extract(const_iterator position); (1)
-node_type extract(const key_type&amp;amp; x);       (2)
+node_type extract(const_iterator position); // (1) C++17
+
+node_type extract(const key_type&amp;amp; x);       // (2) C++17
+
+template &amp;lt;class K&amp;gt;
+node_type extract(K&amp;amp;&amp;amp; x);                   // (3) C++23
 ```
 
 ## 概要
-(1) `position`が指すノードを切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を返す。  
-(2) `x`と等価なキーが見つかった場合、`x`が指すノードを切り離し、その要素を所有するノードハンドルを返す。それ以外の場合は空のノードハンドルを返す。 
+指定された要素を`*this`から切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を取得する。
+
+- (1) : `position`が指すノードを切り離す
+- (2) : `x`と等価なキーをもつノードを切り離す
+- (3) : `key_type`と比較可能な`x`と等価なキーをもつノードを切り離す
 
 
 ## 戻り値
@@ -20,13 +27,13 @@ node_type extract(const key_type&amp;amp; x);       (2)
 
 
 ## 計算量
-(1) 償却定数時間  
-(2) `map a;`のとき、log(a.size())
+- (1) : 償却定数時間
+- (2), (3) : 要素数を`N`として、`log(N)`
 
 
 ## 備考
-`extract`は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる。
-また、`extract`は再確保なしでマップ要素のキーを変更することができる。 
+- この関数は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる
+- この関数は、再確保なしでマップ要素のキーを変更することができる
 
 
 ## 例
@@ -96,4 +103,5 @@ m2 :
 
 ## 参照
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; extract(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- map / setのextract : C++23でのheterogeneousなオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/extract.html"/>
      <id>6eaa82d487e3c732fa17de04e4bf624125036174:reference/map/multimap/extract.md</id>
      <updated>2023-06-22T16:34:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/extract.md b/reference/map/multimap/extract.md
index ba164ebf2..280b5cee4 100644
--- a/reference/map/multimap/extract.md
+++ b/reference/map/multimap/extract.md
@@ -6,27 +6,34 @@
 * cpp17[meta cpp]
 
 ```cpp
-node_type extract(const_iterator position); (1)
-node_type extract(const key_type&amp;amp; x);       (2)
+node_type extract(const_iterator position); // (1) C++17
+
+node_type extract(const key_type&amp;amp; x);       // (2) C++17
+
+template &amp;lt;class K&amp;gt;
+node_type extract(K&amp;amp;&amp;amp; x);                   // (3) C++23
 ```
 
 ## 概要
-(1) `position`が指すノードを切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を返す。  
-(2) `x`と等価なキーが見つかった場合、`x`が指す最初の要素を持つノードを切り離し、その要素を所有するノードハンドルを返す。それ以外の場合は空のノードハンドルを返す。
+指定された要素を`*this`から切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を取得する。
+
+- (1) : `position`が指すノードを切り離す
+- (2) : `x`と等価なキーをもつノードをすべて切り離す
+- (3) : `key_type`と比較可能な`x`と等価なキーをもつノードをすべて切り離す
 
 
 ## 戻り値
-要素を所有するノードハンドル。ただし、オーバーロード(2)の場合は空のノードハンドルの可能性がある。
+要素を所有するノードハンドル。ただし、オーバーロード(2), (3)の場合は空のノードハンドルの可能性がある。
 
 
 ## 計算量
-(1) 償却定数時間  
-(2) log((*this).size())
+- (1) : 償却定数時間
+- (2), (3) : 要素数を`N`として、`log(N)`
 
 
 ## 備考
-`extract`は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる。
-また、`extract`は再確保なしでマップ要素のキーを変更することができる。 
+- この関数は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる
+- この関数は、再確保なしでマップ要素のキーを変更することができる
 
 
 ## 例
@@ -96,4 +103,5 @@ m2 :
 
 ## 参照
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; extract(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- map / setのextract : C++23でのheterogeneousなオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/extract.html"/>
      <id>6eaa82d487e3c732fa17de04e4bf624125036174:reference/set/multiset/extract.md</id>
      <updated>2023-06-22T16:34:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/extract.md b/reference/set/multiset/extract.md
index 468599150..960f6ac4e 100644
--- a/reference/set/multiset/extract.md
+++ b/reference/set/multiset/extract.md
@@ -6,27 +6,35 @@
 * cpp17[meta cpp]
 
 ```cpp
-node_type extract(const_iterator position); (1)
-node_type extract(const key_type&amp;amp; x);       (2)
+node_type extract(const_iterator position); // (1) C++17
+
+node_type extract(const key_type&amp;amp; x);       // (2) C++17
+
+template &amp;lt;class K&amp;gt;
+node_type extract(K&amp;amp;&amp;amp; x);                   // (3) C++23
 ```
 
 ## 概要
-(1) `position`が指すノードを切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を返す。  
-(2) `x`と等価なキーが見つかった場合、`x`が指す最初の要素を持つノードを切り離し、その要素を所有するノードハンドルを返す。それ以外の場合は空のノードハンドルを返す。
+指定された要素を`*this`から切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を取得する。
+
+- (1) : `position`が指すノードを切り離す
+- (2) : `x`と等価なキーをもつノードをすべて切り離す
+- (3) : `key_type`と比較可能な`x`と等価なキーをもつノードをすべて切り離す
 
 
 ## 戻り値
-要素を所有するノードハンドル。ただし、オーバーロード(2)の場合は空のノードハンドルの可能性がある。
+要素を所有するノードハンドル。ただし、オーバーロード(2), (3)の場合は空のノードハンドルの可能性がある。
 
 
 ## 計算量
-(1) 償却定数時間  
-(2) log((*this).size())
+- (1) : 償却定数時間
+- (2), (3) : 要素数を`N`として、`log(N)`
 
 
 ## 備考
-`extract`は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる。
-また、`extract`は、ムーブオンリーオブジェクトを`multiset`から取り出すことができる。
+- この関数は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる
+- この関数は、再確保なしでマップ要素のキーを変更することができる
+
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -132,4 +140,5 @@ s2 = { 1, 2 }
 
 ## 参照
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; extract(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- map / setのextract : C++23でのheterogeneousなオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/set/set/extract.html"/>
      <id>6eaa82d487e3c732fa17de04e4bf624125036174:reference/set/set/extract.md</id>
      <updated>2023-06-22T16:34:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/extract.md b/reference/set/set/extract.md
index 8021f6bfb..43a428d31 100644
--- a/reference/set/set/extract.md
+++ b/reference/set/set/extract.md
@@ -6,27 +6,35 @@
 * cpp17[meta cpp]
 
 ```cpp
-node_type extract(const_iterator position); (1)
-node_type extract(const key_type&amp;amp; x);       (2)
+node_type extract(const_iterator position); // (1) C++17
+
+node_type extract(const key_type&amp;amp; x);       // (2) C++17
+
+template &amp;lt;class K&amp;gt;
+node_type extract(K&amp;amp;&amp;amp; x);                   // (3) C++23
 ```
 
 ## 概要
-(1) `position`が指すノードを切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を返す。  
-(2) `x`と等価なキーが見つかった場合、`x`が指すノードを切り離し、その要素を所有するノードハンドルを返す。それ以外の場合は空のノードハンドルを返す。 
+指定された要素を`*this`から切り離し、その要素を所有する[ノードハンドル](/reference/node_handle/node_handle.md)を取得する。
+
+- (1) : `position`が指すノードを切り離す
+- (2) : `x`と等価なキーをもつノードを切り離す
+- (3) : `key_type`と比較可能な`x`と等価なキーをもつノードを切り離す
 
 
 ## 戻り値
-要素を所有するノードハンドル。ただし、オーバーロード(2)の場合は空のノードハンドルの可能性がある。
+要素を所有するノードハンドル。ただし、オーバーロード(2), (3)の場合は空のノードハンドルの可能性がある。
 
 
 ## 計算量
-(1) 償却定数時間  
-(2) log((*this).size())
+- (1) : 償却定数時間
+- (2), (3) : 要素数を`N`として、`log(N)`
 
 
 ## 備考
-`extract`は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる。
-また、`extract`は、ムーブオンリーオブジェクトを`set`から取り出すことができる。
+- この関数は、要素に対するコピーもムーブも行わずに、要素の所有権を転送することができる
+- この関数は、再確保なしでマップ要素のキーを変更することができる
+
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -132,4 +140,5 @@ s2 = { 1, 2 }
 
 ## 参照
 - [Splicing Maps and Sets(Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf)
-
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; extract(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_map/unordered_map/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/erase.md b/reference/unordered_map/unordered_map/erase.md
index cfbdeb6f0..ba3dbaa80 100644
--- a/reference/unordered_map/unordered_map/erase.md
+++ b/reference/unordered_map/unordered_map/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要。
-- (2) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
-- (3) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
+- (4) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -94,10 +96,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_map&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, um);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, um);
 
     auto count1 = um.erase(&amp;#34;5th&amp;#34;);
     auto count2 = um.erase(&amp;#34;8th&amp;#34;);
@@ -107,10 +109,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_map&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, um);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, um);
 
     auto it1 = std::next(um.cbegin());
     auto it2 = std::next(it1, 2);
@@ -135,12 +137,12 @@ argument: (3rd, 3)
 return value: (1st, 1)
 after : (9th, 9), (7th, 7), (5th, 5), (1st, 1), 
 
-(2) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
+(3) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 argument: 5th, 8th
 return value: 1, 0
 after : (9th, 9), (7th, 7), (3rd, 3), (1st, 1), 
 
-(3) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
+(4) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 arguments: (7th, 7), (3rd, 3)
 return value: (3rd, 3)
 after : (9th, 9), (3rd, 3), (1st, 1), 
@@ -200,10 +202,6 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ?
 
 
-## 参照
-- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
-
-
 ## 関連項目
 
 | 名前                                | 説明                                                   |
@@ -214,3 +212,8 @@ int main()
 | [`clear`](clear.md)               | 全要素の削除                                           |
 | [`swap`](swap.md)                 | 内容の交換                                             |
 
+
+## 参照
+- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_map/unordered_multimap/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/erase.md b/reference/unordered_map/unordered_multimap/erase.md
index 804e96d93..e93bb2ddf 100644
--- a/reference/unordered_map/unordered_multimap/erase.md
+++ b/reference/unordered_map/unordered_multimap/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。
-- (2) : 削除した要素数。
-- (3) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。
+- (4) :  「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要である。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -94,10 +96,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_multimap&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, {&amp;#34;3rd&amp;#34;, 33}, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, um);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, um);
 
     auto count1 = um.erase(&amp;#34;5th&amp;#34;);
     auto count2 = um.erase(&amp;#34;8th&amp;#34;);
@@ -108,10 +110,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_multimap&amp;lt;std::string, int&amp;gt; um{ {&amp;#34;1st&amp;#34;, 1}, {&amp;#34;3rd&amp;#34;, 3}, {&amp;#34;5th&amp;#34;, 5}, {&amp;#34;7th&amp;#34;, 7}, {&amp;#34;9th&amp;#34;, 9}, {&amp;#34;3rd&amp;#34;, 33}, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, um);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, um);
 
     auto it1 = std::next(um.cbegin());
     auto it2 = std::next(it1, 2);
@@ -136,12 +138,12 @@ argument: (3rd, 33)
 return value: (3rd, 3)
 after : (9th, 9), (7th, 7), (5th, 5), (3rd, 3), (1st, 1), 
 
-(2) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
+(3) erase(const value_type&amp;amp;) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
 argument: 5th, 8th, 3rd
 return value: 1, 0, 2
 after : (9th, 9), (7th, 7), (1st, 1), 
 
-(3) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
+(4) erase(const_iterator, const_iterator) before : (9th, 9), (7th, 7), (5th, 5), (3rd, 33), (3rd, 3), (1st, 1), 
 arguments: (7th, 7), (3rd, 33)
 return value: (3rd, 33)
 after : (9th, 9), (3rd, 33), (3rd, 3), (1st, 1), 
@@ -215,5 +217,5 @@ int main()
 ## 参照
 - [LWG Issue 518. Are `insert` and `erase` stable for `unordered_multiset` and `unordered_multimap`?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518)
     - 安定性の保証が規定された経緯のレポート
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_set/unordered_multiset/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/erase.md b/reference/unordered_set/unordered_multiset/erase.md
index 88cb5415f..b32770c2f 100644
--- a/reference/unordered_set/unordered_multiset/erase.md
+++ b/reference/unordered_set/unordered_multiset/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。
-- (2) : 削除した要素数。
-- (3) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。
+- (4) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -86,10 +88,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_multiset&amp;lt;int&amp;gt; ums{ 1, 3, 5, 7, 9, 3, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, ums);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, ums);
 
     auto count1 = ums.erase(5);
     auto count2 = ums.erase(8);
@@ -100,10 +102,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_multiset&amp;lt;int&amp;gt; ums{ 1, 3, 5, 7, 9, 3, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, ums);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, ums);
 
     auto it1 = std::next(ums.cbegin());
     auto it2 = std::next(it1, 2);
@@ -127,12 +129,12 @@ argument: 1
 return value: 3
 after : 9 7 5 3 3
 
-(2) erase(const value_type&amp;amp;) before : 9 7 5 1 3 3
+(3) erase(const value_type&amp;amp;) before : 9 7 5 1 3 3
 argument: 5, 8, 3
 return value: 1, 0, 2
 after : 9 7 1
 
-(3) erase(const_iterator, const_iterator) before : 9 7 5 1 3 3
+(4) erase(const_iterator, const_iterator) before : 9 7 5 1 3 3
 arguments: 7, 1
 return value: 1
 after : 9 1 3 3
@@ -202,5 +204,5 @@ int main()
 ## 参照
 - [LWG Issue 518. Are `insert` and `erase` stable for `unordered_multiset` and `unordered_multimap`?](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518)
     - 安定性の保証が規定された経緯のレポート
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- unordered_map / setのerase : erase(iterator)のオーバーロードを追加</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/erase.html"/>
      <id>217669cf06e0ac6b4e4bc3058cf3871da48d7630:reference/unordered_set/unordered_set/erase.md</id>
      <updated>2023-06-22T16:15:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/erase.md b/reference/unordered_set/unordered_set/erase.md
index 8a6c214ac..cab1403e8 100644
--- a/reference/unordered_set/unordered_set/erase.md
+++ b/reference/unordered_set/unordered_set/erase.md
@@ -6,11 +6,13 @@
 * cpp11[meta cpp]
 
 ```cpp
-iterator erase(const_iterator position);                   // (1)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; k);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-iterator erase(const_iterator first, const_iterator last); // (3)
+size_type erase(const key_type&amp;amp; k);                        // (3) C++11
+
+iterator erase(const_iterator first, const_iterator last); // (4) C++11
 ```
 
 ## 概要
@@ -24,30 +26,30 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 
 
 ## 効果
-- (1) : `position` で指定された要素を削除する。
-- (2) : `k` と等価なキーの要素を削除する。
-- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
+- (1), (2) : `position` で指定された要素を削除する。
+- (3) : `k` と等価なキーの要素を削除する。
+- (4) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
-- (1) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
+- (1), (2) : 「削除前に、削除された要素の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`std::`[`next`](/reference/iterator/next.md)`(position)` と同じ位置を指す `iterator` である。  
 	なお、`position` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。
-- (2) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
-- (3) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
+- (3) : 削除した要素数。つまり、`k` と等価なキーの要素があれば 1、無ければ 0。
+- (4) : 「削除前に、削除された要素の範囲の次だった位置」を指すイテレータ。`erase()` を呼び出しても削除された要素以外を指す全てのイテレータは無効にならないため、`last` と同じ位置を指す `iterator` である。  
 	なお、`first` 及び `last` は `const_iterator` なのに対して、戻り値は `iterator` であるため注意が必要だが、非順序連想コンテナの場合いずれにせよどちらも読み取り専用イテレータである。  
 	また、要件に示したように `first` が間接参照可能である必要がなかった場合にも、他の種類のコンテナの戻り値と照らし合わせると、`last` と同じ位置を指す `iterator` を返すのが適切であるものと思われる。
 
 
 ## 例外
-- (1) : 投げない。
-- (2) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
-- (3) : 投げない。
+- (1), (2) : 投げない。
+- (3) : コンテナの `key_equal` と `hasher` のオブジェクト（それぞれ `key_eq()` と `hash_function()` が返すオブジェクト）が例外を投げなければ、例外を投げない。
+- (4) : 投げない。
 
 
 ## 計算量
-- (1) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (2) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
-- (3) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (1), (2) : 平均的なケースでは定数（O(`1`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (3) : 平均的なケースでは削除された要素数に比例（O([`count`](count.md)`(k)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
+- (4) : 平均的なケースでは指定された範囲の要素数に比例（O(`std::`[`distance`](/reference/iterator/distance.md)`(first, last)`)）だが、最悪のケースではコンテナの要素数に比例（O([`size`](size.md)`()`)）
 
 
 ## 備考
@@ -86,10 +88,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定したキーと等価な要素を削除（(2)の形式）
+  // 指定したキーと等価な要素を削除（(3)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 1, 3, 5, 7, 9, };
-    print(&amp;#34;(2) erase(const value_type&amp;amp;) before&amp;#34;, us);
+    print(&amp;#34;(3) erase(const value_type&amp;amp;) before&amp;#34;, us);
 
     auto count1 = us.erase(5);
     auto count2 = us.erase(8);
@@ -99,10 +101,10 @@ int main()
     std::cout &amp;lt;&amp;lt; std::endl;
   }
 
-  // 指定した位置にある要素を削除（(3)の形式）
+  // 指定した位置にある要素を削除（(4)の形式）
   {
     std::unordered_set&amp;lt;int&amp;gt; us{ 1, 3, 5, 7, 9, };
-    print(&amp;#34;(3) erase(const_iterator, const_iterator) before&amp;#34;, us);
+    print(&amp;#34;(4) erase(const_iterator, const_iterator) before&amp;#34;, us);
 
     auto it1 = std::next(us.cbegin());
     auto it2 = std::next(it1, 2);
@@ -126,12 +128,12 @@ argument: 3
 return value: 1
 after : 9 7 5 1
 
-(2) erase(const value_type&amp;amp;) before : 9 7 5 3 1
+(3) erase(const value_type&amp;amp;) before : 9 7 5 3 1
 argument: 5, 8
 return value: 1, 0
 after : 9 7 3 1
 
-(3) erase(const_iterator, const_iterator) before : 9 7 5 3 1
+(4) erase(const_iterator, const_iterator) before : 9 7 5 3 1
 arguments: 7, 3
 return value: 3
 after : 9 3 1
@@ -186,9 +188,6 @@ int main()
 - [ICC](/implementation.md#icc): ?
 - [Visual C++](/implementation.md#visual_cpp): ?
 
-## 参照
-- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
-
 
 ## 関連項目
 
@@ -200,3 +199,8 @@ int main()
 | [`clear`](clear.md)               | 全要素の削除                                           |
 | [`swap`](swap.md)                 | 内容の交換                                             |
 
+
+## 参照
+- [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を追加
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : オーバーロード仕様が古くなっていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/map/map/erase.html"/>
      <id>6251e4abe9d90fab42621ba97fea3a0b4a3c94aa:reference/map/map/erase.md</id>
      <updated>2023-06-22T16:06:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/erase.md b/reference/map/map/erase.md
index 868c9e440..84fe25a4f 100644
--- a/reference/map/map/erase.md
+++ b/reference/map/map/erase.md
@@ -5,13 +5,18 @@
 * function[meta id-type]
 
 ```cpp
-void erase(iterator position);                             // (1) C++03
-iterator erase(const_iterator position);                   // (1) C++11
+void erase(iterator position);                             // (1) C++03 (C++11で一旦削除)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; x);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-void erase(iterator first, iterator last);                 // (3) C++03
-iterator erase(const_iterator first, const_iterator last); // (3) C++11
+size_type erase(const key_type&amp;amp; x);                        // (3) C++03
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+void erase(iterator first, iterator last);                 // (5) C++03
+iterator erase(const_iterator first, const_iterator last); // (5) C++11
 ```
 
 ## 概要
@@ -20,8 +25,10 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 - (1) : 指定されたイテレータが指す要素を削除する
-- (2) : 指定されたキーをもつ要素を削除する
-- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素を削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素を削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
 
 
 ## パラメータ
@@ -31,16 +38,20 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 
 ## 戻り値
-- (1), (3)
+- (1) :
+    - C++03 : 戻り値なし
+    - C++17 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (2) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す
+- (5) :
     - C++03 : 戻り値なし
     - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
-- (2) 削除された要素の数を返す。
 
 
 ## 計算量
-- (1) 定数時間。
-- (2) コンテナの [`size()`](/reference/map/map/size.md) について対数時間。
-- (3) コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間。
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
 
 
 ## 備考
@@ -174,7 +185,11 @@ int main()
 
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+    - C++11で、`erase(iterator)`を`erase(const_iterator)`に変更
 - [LWG Issue 2258. `a.erase(q1, q2)` unable to directly return `q2`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258)
     - C++11では、「`a.erase(q1, q2)`の結果として`q2`が返る」という仕様だったが、`const_iterator`型が渡された場合に`iterator`型を返せない問題があった。そのためC++14では、`q2`が指す要素を指すイテレータが返る、ということが明記された
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を再追加
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; erase(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : オーバーロード仕様が古くなっていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/erase.html"/>
      <id>6251e4abe9d90fab42621ba97fea3a0b4a3c94aa:reference/map/multimap/erase.md</id>
      <updated>2023-06-22T16:06:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/erase.md b/reference/map/multimap/erase.md
index 2f45485d8..f52bcb6cf 100644
--- a/reference/map/multimap/erase.md
+++ b/reference/map/multimap/erase.md
@@ -5,13 +5,18 @@
 * function[meta id-type]
 
 ```cpp
-void erase(iterator position);                             // (1) C++03
-iterator erase(const_iterator position);                   // (1) C++11
+void erase(iterator position);                             // (1) C++03 (C++11で一旦削除)
+iterator erase(iterator position);                         // (1) C++17
 
-size_type erase(const key_type&amp;amp; x);                        // (2)
+iterator erase(const_iterator position);                   // (2) C++11
 
-void erase(iterator first, iterator last);                 // (3) C++03
-iterator erase(const_iterator first, const_iterator last); // (3) C++11
+size_type erase(const key_type&amp;amp; x);                        // (3) C++03
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+void erase(iterator first, iterator last);                 // (5) C++03
+iterator erase(const_iterator first, const_iterator last); // (5) C++11
 ```
 
 
@@ -21,9 +26,10 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 - (1) : 指定されたイテレータが指す要素を削除する
-- (2) : 指定されたキーをもつ要素をすべて削除する
-- (3) : 指定されたイテレータ範囲の要素をすべて削除する
-
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素をすべて削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素をすべて削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
 
 ## パラメータ
 - `position` : `multimap` から削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
@@ -32,16 +38,20 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 
 ## 戻り値
-- (1), (3)
+- (1) :
+    - C++03 : 戻り値なし
+    - C++17 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (2) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す
+- (5) :
     - C++03 : 戻り値なし
     - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
-- (2) 削除された要素の数を返す。
 
 
 ## 計算量
-- (1) 定数時間。
-- (2) コンテナの [`size()`](/reference/map/map/size.md) について対数時間。
-- (3) コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間。
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
 
 
 ## 備考
@@ -164,7 +174,10 @@ int main()
 
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+    - C++11で、`erase(iterator)`を`erase(const_iterator)`に変更
 - [LWG Issue 2258. `a.erase(q1, q2)` unable to directly return `q2`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258)
     - C++11では、「`a.erase(q1, q2)`の結果として`q2`が返る」という仕様だったが、`const_iterator`型が渡された場合に`iterator`型を返せない問題があった。そのためC++14では、`q2`が指す要素を指すイテレータが返る、ということが明記された
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を再追加
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; erase(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : オーバーロード仕様が古くなっていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/erase.html"/>
      <id>6251e4abe9d90fab42621ba97fea3a0b4a3c94aa:reference/set/multiset/erase.md</id>
      <updated>2023-06-22T16:06:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/erase.md b/reference/set/multiset/erase.md
index 4aed5f014..f8cd9641c 100644
--- a/reference/set/multiset/erase.md
+++ b/reference/set/multiset/erase.md
@@ -5,13 +5,18 @@
 * function[meta id-type]
 
 ```cpp
-void erase(iterator position);                             // (1) C++03 まで
-iterator erase(const_iterator position);                   // (1) C++11 から
+void erase(iterator position);                             // (1) C++03 (C++11で一旦削除)
+iterator erase(iterator position);                         // (1) C++17
 
-void erase(iterator first, iterator last);                 // (2) C++03 まで
-iterator erase(const_iterator first, const_iterator last); // (2) C++11 から
+iterator erase(const_iterator position);                   // (2) C++11
 
-size_type erase(const key_type&amp;amp; x);                        // (3)
+size_type erase(const key_type&amp;amp; x);                        // (3) C++03
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+void erase(iterator first, iterator last);                 // (5) C++03
+iterator erase(const_iterator first, const_iterator last); // (5) C++11
 ```
 
 
@@ -20,8 +25,10 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 - (1) : 指定されたイテレータが指す要素を削除する
-- (2) : 指定されたキーをもつ要素をすべて削除する
-- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素をすべて削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素をすべて削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
 
 
 ## パラメータ
@@ -31,16 +38,20 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 戻り値
-- (1), (2) :
-    - C++03 まで : なし
+- (1) :
+    - C++03 : 戻り値なし
+    - C++17 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (2) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す
+- (5) :
+    - C++03 : 戻り値なし
     - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
-- (3) : 削除された要素の数を返す。
 
 
 ## 計算量
-- (1) : 定数時間
-- (2) : コンテナの [`size()`](size.md) についての対数時間と、それに加えて `first` と `last` の間の距離に対する線形時間。
-- (3) : コンテナの [`size()`](size.md) についての対数時間と、それに加えて `x` と等価なキーの要素数に対する線形時間。
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
 
 
 ## 備考
@@ -157,7 +168,10 @@ int main()
 
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+    - C++11で、`erase(iterator)`を`erase(const_iterator)`に変更
 - [LWG Issue 2258. `a.erase(q1, q2)` unable to directly return `q2`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258)
     - C++11では、「`a.erase(q1, q2)`の結果として`q2`が返る」という仕様だったが、`const_iterator`型が渡された場合に`iterator`型を返せない問題があった。そのためC++14では、`q2`が指す要素を指すイテレータが返る、ということが明記された
-
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を再追加
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; erase(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- map / setのerase : オーバーロード仕様が古くなっていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/set/set/erase.html"/>
      <id>6251e4abe9d90fab42621ba97fea3a0b4a3c94aa:reference/set/set/erase.md</id>
      <updated>2023-06-22T16:06:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/erase.md b/reference/set/set/erase.md
index 1138910f9..683180d57 100644
--- a/reference/set/set/erase.md
+++ b/reference/set/set/erase.md
@@ -5,13 +5,18 @@
 * function[meta id-type]
 
 ```cpp
-void erase(iterator position);                             // (1) C++03 まで
-iterator erase(const_iterator position);                   // (1) C++11 から
+void erase(iterator position);                             // (1) C++03 (C++11で一旦削除)
+iterator erase(iterator position);                         // (1) C++17
 
-void erase(iterator first, iterator last);                 // (2) C++03 まで
-iterator erase(const_iterator first, const_iterator last); // (2) C++11 から
+iterator erase(const_iterator position);                   // (2) C++11
 
-size_type erase(const key_type&amp;amp; x);                        // (3)
+size_type erase(const key_type&amp;amp; x);                        // (3) C++03
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+void erase(iterator first, iterator last);                 // (5) C++03
+iterator erase(const_iterator first, const_iterator last); // (5) C++11
 ```
 
 
@@ -20,8 +25,10 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 - (1) : 指定されたイテレータが指す要素を削除する
-- (2) : 指定されたキーをもつ要素を削除する
-- (3) : 指定されたイテレータ範囲の要素をすべて削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素を削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素を削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
 
 
 ## パラメータ
@@ -31,16 +38,20 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 戻り値
-- (1), (2) :
-    - C++03 まで : なし
+- (1) :
+    - C++03 : 戻り値なし
+    - C++17 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (2) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す
+- (5) :
+    - C++03 : 戻り値なし
     - C++11 : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
-- (3) : 削除された要素の数を返す。
 
 
 ## 計算量
-- (1) : 定数時間
-- (2) : コンテナの [`size()`](size.md) についての対数時間と、それに加えて `first` と `last` の間の距離に対する線形時間。
-- (3) : コンテナの [`size()`](size.md) について対数時間。
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間
+- (5) : コンテナの [`size()`](/reference/map/map/size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
 
 
 ## 備考
@@ -158,7 +169,11 @@ int main()
 
 ## 参照
 - [N2350 Container insert/erase and iterator constness (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2350.pdf)
+    - C++11で、`erase(iterator)`を`erase(const_iterator)`に変更
 - [LWG Issue 2258. `a.erase(q1, q2)` unable to directly return `q2`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2258)
     - C++11では、「`a.erase(q1, q2)`の結果として`q2`が返る」という仕様だったが、`const_iterator`型が渡された場合に`iterator`型を返せない問題があった。そのためC++14では、`q2`が指す要素を指すイテレータが返る、ということが明記された
-
+- [LWG Issue 2059. C++0x ambiguity problem with `map::erase`](https://cplusplus.github.io/LWG/issue2059)
+    - C++17で、`erase(iterator)`を再追加
+- [P2077R3 Heterogeneous erasure overloads for associative containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2077r3.html)
+    - C++23で、`template &amp;lt;class K&amp;gt; erase(K&amp;amp;&amp;amp; x)`のオーバーロードが追加された
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>