<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-22T06:10:24.798363</updated>
  <id>15ba3739-30ef-498c-be83-1399cb2a47bc</id>

  
    <entry>
      <title>bucket -- unordered_map::bucket : C++26異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/bucket.html"/>
      <id>567ae393df32e6e6a8bd4e7275da6ad2ae966712:reference/unordered_map/unordered_map/bucket.md</id>
      <updated>2025-05-22T15:06:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/bucket.md b/reference/unordered_map/unordered_map/bucket.md
index 2f7729450..25418c5de 100644
--- a/reference/unordered_map/unordered_map/bucket.md
+++ b/reference/unordered_map/unordered_map/bucket.md
@@ -6,20 +6,29 @@
 * cpp11[meta cpp]
 
 ```cpp
-size_type bucket(const key_type&amp;amp; k) const;
+size_type bucket(const key_type&amp;amp; k) const; // (1) C++11
+
+template &amp;lt;class K&amp;gt;
+size_type bucket(const K&amp;amp; k) const;        // (2) C++26
 ```
 
 ## 概要
 指定したキーと等価な要素が格納されている場合、そのバケットのインデックス（添え字）を取得する。
 
 
-## 要件
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent` が妥当な式であること
+
+
+## 事前条件
 当該コンテナは [`bucket_count`](bucket_count.md)`() &amp;gt; 0` であること
 
 
 ## 戻り値
 パラメータ `k` と等価なキーの要素が格納されているバケットのインデックス（添え字）
 
+
+## 事後条件
 戻り値は `[0,` [`bucket_count`](bucket_count.md)`())` の範囲である。
 
 
@@ -28,7 +37,10 @@ size_type bucket(const key_type&amp;amp; k) const;
 
 
 ## 備考
-指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- 指定したキーと等価な要素が格納されていない場合、そのキーを挿入した際に [`rehash`](rehash.md) が発生しなければ格納されるバケットのインデックス（添え字）が返る。
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -95,3 +107,7 @@ key = H, bucket = 6, bucket_size = 0
 |---------------------------------------------|----------------------|
 | [`max_bucket_count`](max_bucket_count.md) | 最大バケット数の取得 |
 
+
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>at -- unordered_map : atとoperator[]をC++26異種混合ルックアップに対応</title>
      <link href="https://cpprefjp.github.io/reference/map/map/at.html"/>
      <id>bd07d857fbfcbbd5b70f17025d583d9a88d84945:reference/map/map/at.md</id>
      <updated>2025-05-22T14:54:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/at.md b/reference/map/map/at.md
index a73dc3c21..dd0782d6a 100644
--- a/reference/map/map/at.md
+++ b/reference/map/map/at.md
@@ -10,9 +10,9 @@ T&amp;amp; at(const key_type&amp;amp; x);              // (1) C++11
 const T&amp;amp; at(const key_type &amp;amp; x) const; // (2) C++11
 
 template&amp;lt;class K&amp;gt;
-mapped_type&amp;amp; at(const K&amp;amp; x);             // (3) C++26
+T&amp;amp; at(const K&amp;amp; x);                     // (3) C++26
 template&amp;lt;class K&amp;gt;
-const mapped_type&amp;amp; at(const K&amp;amp; x) const; // (4) C++26
+const T&amp;amp; at(const K&amp;amp; x) const;         // (4) C++26
 ```
 
 ## 概要
@@ -40,7 +40,7 @@ const mapped_type&amp;amp; at(const K&amp;amp; x) const; // (4) C++26
 
 
 ## 例外
-- 対応する要素が存在しない場合、[`std::out_of_range`](/reference/stdexcept.md)例外を送出する
+- 指定されたキーに対応する要素が存在しない場合、[`std::out_of_range`](/reference/stdexcept.md)例外を送出する
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>at -- unordered_map : atとoperator[]をC++26異種混合ルックアップに対応</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/at.html"/>
      <id>bd07d857fbfcbbd5b70f17025d583d9a88d84945:reference/unordered_map/unordered_map/at.md</id>
      <updated>2025-05-22T14:54:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/at.md b/reference/unordered_map/unordered_map/at.md
index a6e81bd1f..aa49034fd 100644
--- a/reference/unordered_map/unordered_map/at.md
+++ b/reference/unordered_map/unordered_map/at.md
@@ -6,24 +6,49 @@
 * cpp11[meta cpp]
 
 ```cpp
-T&amp;amp; at(const key_type&amp;amp; x);
-const T&amp;amp; at(const key_type &amp;amp; x) const;
+T&amp;amp; at(const key_type&amp;amp; x);              // (1) C++11
+const T&amp;amp; at(const key_type &amp;amp; x) const; // (2) C++11
+
+template&amp;lt;class K&amp;gt;
+T&amp;amp; at(const K&amp;amp; x);                     // (3) C++26
+template&amp;lt;class K&amp;gt;
+const T&amp;amp; at(const K&amp;amp; x) const;         // (4) C++26
 ```
 
 ## 概要
 参照のためのメソッドで、取り出す時にキーの存在チェックをする。
 
+- (1), (2) : クラスのテンプレートパラメータ`key_type`型のキーに対応する要素を取得する
+- (3), (4) : `key_type`と比較可能な`K`型のキーに対応する要素を取得する
+
+
+## テンプレートパラメータ制約
+- (3), (4) : `key_compare::is_transparent` が妥当な式であること
+
+
+## 事前条件
+- (3), (4) : [`find`](find.md)`(x)`が妥当な式であり、定義された動作をすること
+
+
 ## 戻り値
-キーxに対応する値を返す。
+キー`x`に対応する値を返す。
+
 
 ## 例外
-オブジェクトが存在しないときは、out_of_range例外を投げる。
+- 指定されたキーに対応する要素が存在しない場合、[`std::out_of_range`](/reference/stdexcept.md)例外を送出する
+
 
 ## 計算量
 - 平均： 定数時間
 - 最悪： [`size`](size.md) について線形時間
 
 
+## 備考
+- (3), (4) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -81,3 +106,5 @@ exception std::out_of_range
 
 ## 参照
 - [LWG Issue 761. `unordered_map` needs an `at()` member function](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761)
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator[] -- unordered_map : atとoperator[]をC++26異種混合ルックアップに対応</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_at.html"/>
      <id>bd07d857fbfcbbd5b70f17025d583d9a88d84945:reference/unordered_map/unordered_map/op_at.md</id>
      <updated>2025-05-22T14:54:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_at.md b/reference/unordered_map/unordered_map/op_at.md
index d4d4e7910..a06ea7946 100644
--- a/reference/unordered_map/unordered_map/op_at.md
+++ b/reference/unordered_map/unordered_map/op_at.md
@@ -6,24 +6,44 @@
 * cpp11[meta cpp]
 
 ```cpp
-T&amp;amp; operator[](const key_type&amp;amp; x);
-T&amp;amp; operator[](key_type&amp;amp;&amp;amp; x);
+T&amp;amp; operator[](const key_type&amp;amp; x); // (1) C++11
+
+T&amp;amp; operator[](key_type&amp;amp;&amp;amp; x);      // (2) C++11
+
+template &amp;lt;class K&amp;gt;
+T&amp;amp; operator[](K&amp;amp;&amp;amp; k);             // (3) C++26
 ```
 
 ## 概要
-要素へのアクセス
+要素へのアクセス。
+
+- (1), (2) : クラスのテンプレートパラメータ`key_type`型のキーに対応する要素を取得する
+- (3) : `key_type`と比較可能な`K`型のキーに対応する要素を取得する
+
+
+## テンプレートパラメータ制約
+- (3) : `key_compare::is_transparent` が妥当な式であること
+
 
 ## 戻り値
 キー`x`に対応する値を返す。対応する要素が存在しない場合は、要素を値初期化して参照を返す。
 
+
 ## 例外
 ハッシュ関数以外から例外が投げられた場合には、対応する要素がない場合の新規要素の挿入処理は実施されない。
 
+
 ## 計算量
 - 平均： 定数時間
 - 最悪： [`size`](size.md) について線形時間
 
 
+## 備考
+- (3) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -78,3 +98,8 @@ size=2
 |-----------------------------|----------------|
 | [`operator=`](op_assign.md) | 代入演算子     |
 | [`insert`](insert.md)       | 要素を挿入する |
+
+
+## 参照
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_or_assign -- unordered_map::insert_or_assign : C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/insert_or_assign.html"/>
      <id>6580bd966e200af44dc548b313e93b0a3f84340e:reference/unordered_map/unordered_map/insert_or_assign.md</id>
      <updated>2025-05-22T14:47:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/insert_or_assign.md b/reference/unordered_map/unordered_map/insert_or_assign.md
index a1fc699bd..259f0ef98 100644
--- a/reference/unordered_map/unordered_map/insert_or_assign.md
+++ b/reference/unordered_map/unordered_map/insert_or_assign.md
@@ -7,16 +7,37 @@
 
 ```cpp
 template &amp;lt;class M&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; insert_or_assign(const key_type&amp;amp; k, M&amp;amp;&amp;amp; obj);              // (1)
+pair&amp;lt;iterator, bool&amp;gt;
+  insert_or_assign(const key_type&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (1) C++17
 
 template &amp;lt;class M&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; insert_or_assign(key_type&amp;amp;&amp;amp; k, M&amp;amp;&amp;amp; obj);                   // (2)
+pair&amp;lt;iterator, bool&amp;gt;
+  insert_or_assign(key_type&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (2) C++17
+
+template &amp;lt;class K, class M&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  insert_or_assign(K&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (3) C++26
 
 template &amp;lt;class M&amp;gt;
-iterator insert_or_assign(const_iterator hint, const key_type&amp;amp; k, M&amp;amp;&amp;amp; obj);     // (3)
+iterator
+  insert_or_assign(const_iterator hint,
+                   const key_type&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (4) C++17
 
 template &amp;lt;class M&amp;gt;
-iterator insert_or_assign(const_iterator hint, key_type&amp;amp;&amp;amp; k, M&amp;amp;&amp;amp; obj);          // (4)
+iterator
+  insert_or_assign(const_iterator hint,
+                   key_type&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (5) C++17
+
+template &amp;lt;class K, class M&amp;gt;
+iterator
+  insert_or_assign(const_iterator hint,
+                   K&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);            // (6) C++26
 ```
 * pair[link /reference/utility/pair.md]
 
@@ -25,41 +46,48 @@ iterator insert_or_assign(const_iterator hint, key_type&amp;amp;&amp;amp; k, M&amp;amp;&amp;amp; obj);
 
 引数 `hint` は、`k` を検索する際のヒントに使用される。（が、実際に使用されることはないものと思われる。[`emplace_hint`](emplace_hint.md) の備考を参照）
 
+- (1) : `key_type`型のキーをとって挿入もしくは代入する
+- (2) : `key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
+- (3) : `key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
+- (4) : 挿入位置のヒントをともない、`key_type`型のキーをとって挿入もしくは代入する
+- (5) : 挿入位置のヒントをともない、`key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
+- (6) : 挿入位置のヒントをともない、`key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
+
 
 ## テンプレートパラメータ制約
-- (1)、(3) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
-- (2)、(4) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (3), (6) : `key_compare::is_transparent` が妥当な式であること
+
+
+## 適格要件
+- (1)、(3)、(4)、(6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (2)、(5) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
 
 
 ## 効果
-- (1)、(3) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1)、(3)、(4)、(6) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2)、(5) : `unordered_map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 代入された場合には、`first` に代入された要素へのイテレータ、`second` に `false` が設定される。
-- (3)、(4) :
+- (4)、(5)、(6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 代入された場合には、代入された要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2) : [`emplace`](emplace.md) と同じ。
-- (3)、(4) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1)、(2)、(3) : [`emplace`](emplace.md) と同じ。
+- (4)、(5)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
 - 規格にはこの関数の例外安全性についての記載が無いが、[`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) と等価と考えて問題ないと思われる。
-
 - 規格にはこの関数が呼ばれた後のイテレータや要素へのポインタ・参照の有効性についての記載が無いが、[`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) と等価と考えて問題ないと思われる。
-
-- このメンバ関数の[`機能テストマクロ`](/lang/cpp17/feature_test_macros.md)は以下の通り。
-
-    | マクロ名                              | 値       |
-    |---------------------------------------|----------|
-    | `__cpp_lib_unordered_map_try_emplace` | `201411` |
+- (3), (6) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -107,8 +135,6 @@ key = two, value = 42, is inserted = false, is empty = true
 ```
 
 
-
-
 ## バージョン
 ### 言語
 - C++17
@@ -142,3 +168,5 @@ key = two, value = 42, is inserted = false, is empty = true
 - [N4006 An improved emplace() for unique-key maps](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html)
 - [N4240 Improved insertion interface for unique-key maps (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html)
 - [N4279 Improved insertion interface for unique-key maps (Revision 2.3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html)
+- [P2363R5 Extending associative containers with the remaining heterogeneous overloads](http://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_or_assign -- map::insert_or_assign : オーバーロード番号を振り直し #1189</title>
      <link href="https://cpprefjp.github.io/reference/map/map/insert_or_assign.html"/>
      <id>6b1650ab2dfc76432983b5162f80c9164883ea1c:reference/map/map/insert_or_assign.md</id>
      <updated>2025-05-22T14:41:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/insert_or_assign.md b/reference/map/map/insert_or_assign.md
index 9fddf5c7e..f6c5c07df 100644
--- a/reference/map/map/insert_or_assign.md
+++ b/reference/map/map/insert_or_assign.md
@@ -14,21 +14,20 @@ template &amp;lt;class M&amp;gt;
 pair&amp;lt;iterator, bool&amp;gt;
   insert_or_assign(key_type&amp;amp;&amp;amp; k,
                    M&amp;amp;&amp;amp; obj);          // (2) C++17
+template &amp;lt;class K, class M&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  insert_or_assign(K&amp;amp;&amp;amp; k,
+                   M&amp;amp;&amp;amp; obj);          // (3) C++26
 template &amp;lt;class M&amp;gt;
 iterator
   insert_or_assign(const_iterator hint,
                    const key_type&amp;amp; k,
-                   M&amp;amp;&amp;amp; obj);          // (3) C++17
+                   M&amp;amp;&amp;amp; obj);          // (4) C++17
 template &amp;lt;class M&amp;gt;
 iterator
   insert_or_assign(const_iterator hint,
                    key_type&amp;amp;&amp;amp; k,
-                   M&amp;amp;&amp;amp; obj);          // (4) C++17
-
-template &amp;lt;class K, class M&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt;
-  insert_or_assign(K&amp;amp;&amp;amp; k,
-                   M&amp;amp;&amp;amp; obj);          // (5) C++26
+                   M&amp;amp;&amp;amp; obj);          // (5) C++17
 template &amp;lt;class K, class M&amp;gt;
 iterator
   insert_or_assign(const_iterator hint,
@@ -44,44 +43,44 @@ iterator
 
 - (1) : `key_type`型のキーをとって挿入もしくは代入する
 - (2) : `key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
-- (3) : 挿入位置のヒントをともない、`key_type`型のキーをとって挿入もしくは代入する
-- (4) : 挿入位置のヒントをともない、`key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
-- (5) : `key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
+- (3) : `key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
+- (4) : 挿入位置のヒントをともない、`key_type`型のキーをとって挿入もしくは代入する
+- (5) : 挿入位置のヒントをともない、`key_type`型の一時オブジェクトのキーをとって挿入もしくは代入する
 - (6) : 挿入位置のヒントをともない、`key_type`と比較可能な`K`型のキーをとって挿入もしくは代入する
 
 
 ## テンプレートパラメータ制約
-- (5), (6) : `key_compare::is_transparent` が妥当な式であること
+- (3), (6) : `key_compare::is_transparent` が妥当な式であること
 
 
 ## 適格要件
-- (1)、(3)、(5)、(6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
-- (2)、(4) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (1)、(3)、(4)、(6) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
+- (2)、(5) : [`is_assignable_v`](/reference/type_traits/is_assignable.md)`&amp;lt;mapped_type&amp;amp;, M&amp;amp;&amp;amp;&amp;gt;` が `true` であること。`value_type` は、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から `map` に直接構築可能であること
 
 なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
 
 
 ## 効果
-- (1)、(3)、(5)、(6) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1)、(3)、(4)、(6) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、`k`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2)、(5) : `map` が `k` と同値のキーを持つ要素 `e` を持っている場合、`e.second` に [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` を代入する。そうでなければ、[`move`](/reference/utility/move.md)`(k)`, [`forward`](/reference/utility/forward.md)`&amp;lt;M&amp;gt;(obj)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2)、(5) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 代入された場合には、`first` に代入された要素へのイテレータ、`second` に `false` が設定される。
-- (3)、(4)、(6) :
+- (4)、(5)、(6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 代入された場合には、代入された要素へのイテレータを返す。
 
 
 ## 計算量
-- (1)、(2)、(5) : [`emplace`](emplace.md) と同じ。
-- (3)、(4)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (1)、(2)、(3) : [`emplace`](emplace.md) と同じ。
+- (4)、(5)、(6) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
-- (5), (6) :
+- (3), (6) :
     - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
     - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_emplace -- unordered_map::try_emplace: C++26の異種混合ルックアップに対応 #1189</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/try_emplace.html"/>
      <id>e8b37eff3b349680414defd2a1dbc70547111eaa:reference/unordered_map/unordered_map/try_emplace.md</id>
      <updated>2025-05-20T19:21:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/try_emplace.md b/reference/unordered_map/unordered_map/try_emplace.md
index d172d00eb..b4a3ccbd2 100644
--- a/reference/unordered_map/unordered_map/try_emplace.md
+++ b/reference/unordered_map/unordered_map/try_emplace.md
@@ -7,16 +7,37 @@
 
 ```cpp
 template &amp;lt;class... Args&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; try_emplace(const key_type&amp;amp; k, Args&amp;amp;&amp;amp;... args);            // (1)
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(const key_type&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (1) C++17
 
 template &amp;lt;class... Args&amp;gt;
-pair&amp;lt;iterator, bool&amp;gt; try_emplace(key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);                 // (2)
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(key_type&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (2) C++17
+
+template&amp;lt;class K, class... Args&amp;gt;
+pair&amp;lt;iterator, bool&amp;gt;
+  try_emplace(K&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (3) C++26
 
 template &amp;lt;class... Args&amp;gt;
-iterator try_emplace(const_iterator hint, const key_type&amp;amp; k, Args&amp;amp;&amp;amp;... args);   // (3)
+iterator
+  try_emplace(const_iterator hint,
+              const key_type&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (4) C++17
 
 template &amp;lt;class... Args&amp;gt;
-iterator try_emplace(const_iterator hint, key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);        // (4)
+iterator
+  try_emplace(const_iterator hint,
+              key_type&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (5) C++17
+
+template&amp;lt;class K, class... Args&amp;gt;
+iterator
+  try_emplace(const_iterator hint,
+              K&amp;amp;&amp;amp; k,
+              Args&amp;amp;&amp;amp;... args);     // (6) C++26
 ```
 * pair[link /reference/utility/pair.md]
 
@@ -26,46 +47,52 @@ iterator try_emplace(const_iterator hint, key_type&amp;amp;&amp;amp; k, Args&amp;amp;&amp;amp;... args);
 
 引数 `hint` は、`k` を検索する際のヒントに使用される。（が、実際に使用されることはないものと思われる。[`emplace_hint`](emplace_hint.md) の備考を参照）
 
+- (1) : キーをコピーし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (2) : キーをムーブし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (3) : `key_type`型と比較可能なキーを転送し、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (4) : 検索位置のヒントを受け取ってキーをコピーし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (5) : 検索位置のヒントを受け取ってキーをムーブし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+- (6) : 検索位置のヒントを受け取って`key_type`型と比較可能なキーをムーブし、値型のコンストラクタ引数をとり直接構築して、新たな要素を挿入する
+
 
 ## テンプレートパラメータ制約
-- (1)、(3) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
-- (2)、(4) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
+- (1)、(3)、(4)、(6) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
+- (2)、(5) : `value_type` は、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から `unordered_map` に直接構築可能であること
+- (3)、(6) :
+    - `key_compare::is_transparent` が妥当な式であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, const_iterator&amp;gt; == false`であること
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;K&amp;amp;&amp;amp;, iterator&amp;gt; == false`であること
 
 なお、規格に記載はないが、`hint` は [`emplace_hint`](emplace_hint.md) と同様、コンテナの有効な読み取り専用イテレータである必要があるものと思われる。
 
 
 ## 効果
-- (1)、(3) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
-- (2)、(4) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (1)、(3)、(4)、(6) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(k)`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
+- (2)、(5) : `unordered_map` が `k` と同値のキーを持つ要素を持っている場合、何もしない（引数への副作用もない）。そうでなければ、[`piecewise_construct`](/reference/utility/piecewise_construct_t.md), [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`move`](/reference/utility/move.md)`(k))`, [`forward_as_tuple`](/reference/tuple/forward_as_tuple.md)`(`[`forward`](/reference/utility/forward.md)`&amp;lt;Args&amp;gt;(args)...)` から構築した `value_type` 型のオブジェクトを挿入する。
 
 
 ## 戻り値
-- (1)、(2) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
+- (1)、(2)、(3) : イテレータと `bool` 値の [`pair`](/reference/utility/pair.md) を返す。
     - 挿入された場合には、`first` に挿入された要素へのイテレータ、`second` に `true` が設定される。
     - 挿入されなかった場合には、`first` に `k` と等価のキーを持つ既存の要素へのイテレータ、`second` に `false` が設定される。
-- (3)、(4) :
+- (4)、(5)、(6) :
     - 挿入された場合には、挿入された要素へのイテレータを返す。
     - 挿入されなかった場合には、`k` と等価のキーを持つ既存の要素へのイテレータを返す。
 
 
 ## 計算量
 - (1)、(2) : [`emplace`](emplace.md) と同じ。
-- (3)、(4) : [`emplace_hint`](emplace_hint.md) と同じ。
+- (4)、(5) : [`emplace_hint`](emplace_hint.md) と同じ。
 
 
 ## 備考
 - 概要に記載されているように、本メンバ関数は指定されたキーと等価の要素が既に存在する場合には、引数に副作用が発生しない。  
-    一方、[`emplace`](emplace.md)、[`emplace_hint`](emplace_hint.md)、[`insert`](insert.md) にはそのような規定は無く、挿入がされなかった場合でも引数に副作用（引数からのムーブ）が発生してしまう可能性があるため、注意が必要である。
-
+    - 一方、[`emplace`](emplace.md)、[`emplace_hint`](emplace_hint.md)、[`insert`](insert.md) にはそのような規定は無く、挿入がされなかった場合でも引数に副作用（引数からのムーブ）が発生してしまう可能性があるため、注意が必要である。
 - 規格にはこの関数の例外安全性についての記載が無いが、[`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) と等価と考えて問題ないと思われる。
-
 - 規格にはこの関数が呼ばれた後のイテレータや要素へのポインタ・参照の有効性についての記載が無いが、[`emplace`](emplace.md) や [`emplace_hint`](emplace_hint.md) と等価と考えて問題ないと思われる。
-
-- このメンバ関数の[`機能テストマクロ`](/lang/cpp17/feature_test_macros.md)は以下の通り。
-
-    | マクロ名                              | 値       |
-    |---------------------------------------|----------|
-    | `__cpp_lib_unordered_map_try_emplace` | `201411` |
+- (3), (6) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
 
 
 ## 例
@@ -147,3 +174,5 @@ key = two, value = 2, is inserted = false, is empty = false
 - [N4006 An improved emplace() for unique-key maps](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4006.html)
 - [N4240 Improved insertion interface for unique-key maps (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4240.html)
 - [N4279 Improved insertion interface for unique-key maps (Revision 2.3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4279.html)
+- [P2363R5: Extending associative containers with the remaining heterogeneous overloads](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html)
+    - C++26で`template &amp;lt;class K&amp;gt;`のバージョンが追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>