<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-03-21T15:32:18.517960</updated>
  <id>7953230e-10f6-4242-a5d7-b036cb5341fb</id>

  
    <entry>
      <title>algorithm -- heap系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>ad0f2d7258af154c53ba3fe6a4e0e84a24e5d57d:reference/algorithm.md</id>
      <updated>2022-03-22T00:27:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 18335ca6c..1da373fe2 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -352,12 +352,12 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`sort_heap`](algorithm/sort_heap.md)         | ヒープ化された範囲を並べ替える | |
 | [`is_heap_until`](algorithm/is_heap_until.md) | 範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する | C++11 |
 | [`is_heap`](algorithm/is_heap.md)             | 範囲がヒープ化されているか判定する | C++11 |
-| [`ranges::push_heap`](algorithm/ranges_push_heap.md.nolink)         | ヒープ化された範囲に要素を追加したヒープ範囲を得る                                         | C++20 |
-| [`ranges::pop_heap`](algorithm/ranges_pop_heap.md.nolink)           | ヒープ化された範囲の先頭と末尾を入れ替え、ヒープ範囲を作り直す                             | C++20 |
-| [`ranges::make_heap`](algorithm/ranges_make_heap.md.nolink)         | 範囲をヒープ化する                                                                         | C++20 |
-| [`ranges::sort_heap`](algorithm/ranges_sort_heap.md.nolink)         | ヒープ化された範囲を並べ替える                                                             | C++20 |
-| [`ranges::is_heap_until`](algorithm/ranges_is_heap_until.md.nolink) | 範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する | C++20 |
-| [`ranges::is_heap`](algorithm/ranges_is_heap.md.nolink)             | 範囲がヒープ化されているか判定する                                                         | C++20 |
+| [`ranges::push_heap`](algorithm/ranges_push_heap.md)         | ヒープ化された範囲に要素を追加したヒープ範囲を得る                                         | C++20 |
+| [`ranges::pop_heap`](algorithm/ranges_pop_heap.md)           | ヒープ化された範囲の先頭と末尾を入れ替え、ヒープ範囲を作り直す                             | C++20 |
+| [`ranges::make_heap`](algorithm/ranges_make_heap.md)         | 範囲をヒープ化する                                                                         | C++20 |
+| [`ranges::sort_heap`](algorithm/ranges_sort_heap.md)         | ヒープ化された範囲を並べ替える                                                             | C++20 |
+| [`ranges::is_heap_until`](algorithm/ranges_is_heap_until.md) | 範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する | C++20 |
+| [`ranges::is_heap`](algorithm/ranges_is_heap.md)             | 範囲がヒープ化されているか判定する                                                         | C++20 |
 
 ### 最小と最大
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap -- heap系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap.html"/>
      <id>ad0f2d7258af154c53ba3fe6a4e0e84a24e5d57d:reference/algorithm/ranges_is_heap.md</id>
      <updated>2022-03-22T00:27:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap.md b/reference/algorithm/ranges_is_heap.md
new file mode 100644
index 000000000..e1af59137
--- /dev/null
+++ b/reference/algorithm/ranges_is_heap.md
@@ -0,0 +1,77 @@
+# is_heap
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
+
+  // (2)
+  template&amp;lt;random_access_range R, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool is_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+範囲がヒープ化されているか判定する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 効果
+[`ranges​::​is_­heap_­until`](ranges_is_heap_until.md)`(first, last, comp, proj) == last` と等しい。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is heap? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_heap(v) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::make_heap(v);
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is heap? &amp;#34;
+            &amp;lt;&amp;lt; std::ranges::is_heap(v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_heap[color ff0000]
+* std::ranges::make_heap[link ranges_make_heap.md]
+
+### 出力
+```
+before: is heap? false
+ after: is heap? true
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_heap_until -- heap系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_heap_until.html"/>
      <id>ad0f2d7258af154c53ba3fe6a4e0e84a24e5d57d:reference/algorithm/ranges_is_heap_until.md</id>
      <updated>2022-03-22T00:27:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_heap_until.md b/reference/algorithm/ranges_is_heap_until.md
new file mode 100644
index 000000000..95ed64d26
--- /dev/null
+++ b/reference/algorithm/ranges_is_heap_until.md
@@ -0,0 +1,81 @@
+# is_heap_until
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
+
+  // (2)
+  template&amp;lt;random_access_range R, class Proj = identity, indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; is_heap_until(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 戻り値
+[`distance`](/reference/iterator/distance.md)`(first, last) &amp;lt; 2` の場合は `last` を返す。そうでない場合、`[first,last]` 内のイテレータ `i` について、`[first,i)` が `heap` であるような最後の `i` を返す。
+
+
+## 計算量
+線形時間
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;before: is heap? &amp;#34;
+            &amp;lt;&amp;lt; (std::ranges::is_heap_until(v) == v.end()) &amp;lt;&amp;lt; std::endl;
+
+  std::ranges::make_heap(v);
+  std::cout &amp;lt;&amp;lt; &amp;#34; after: is heap? &amp;#34;
+            &amp;lt;&amp;lt; (std::ranges::is_heap_until(v) == v.end()) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_heap_until[color ff0000]
+* std::ranges::make_heap[link ranges_make_heap.md]
+
+### 出力
+```
+before: is heap? false
+ after: is heap? true
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_heap -- heap系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_make_heap.html"/>
      <id>ad0f2d7258af154c53ba3fe6a4e0e84a24e5d57d:reference/algorithm/ranges_make_heap.md</id>
      <updated>2022-03-22T00:27:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_make_heap.md b/reference/algorithm/ranges_make_heap.md
new file mode 100644
index 000000000..5f4bd322c
--- /dev/null
+++ b/reference/algorithm/ranges_make_heap.md
@@ -0,0 +1,86 @@
+# make_heap
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr I make_heap(I first, S last, Comp comp = {}, Proj proj = {});
+
+  // (2)
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; make_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+範囲をヒープ化する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 効果
+`[first,last)` の範囲で heap を構築する
+
+
+## 戻り値
+`last`
+
+
+## 計算量
+最大で `3 * (last - first)` 回比較する
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
+
+  // ヒープ化する
+  std::ranges::make_heap(v);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::make_heap[color ff0000]
+
+### 出力
+```
+4
+1
+3
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pop_heap -- heap系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_pop_heap.html"/>
      <id>ad0f2d7258af154c53ba3fe6a4e0e84a24e5d57d:reference/algorithm/ranges_pop_heap.md</id>
      <updated>2022-03-22T00:27:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_pop_heap.md b/reference/algorithm/ranges_pop_heap.md
new file mode 100644
index 000000000..da6000f65
--- /dev/null
+++ b/reference/algorithm/ranges_pop_heap.md
@@ -0,0 +1,98 @@
+# pop_heap
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr I pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
+
+  // (2)
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; pop_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+ヒープ化された範囲の先頭と末尾を入れ替え、ヒープ範囲を作り直す
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 事前条件
+- `[first,last)` は空でない heap でなければならない。
+
+
+## 効果
+`first` にある値を `last - 1` と交換し、その後 `[first,last - 1)` が有効な heap となるように配置する。
+
+
+## 戻り値
+`last`
+
+
+## 計算量
+最大で `2 * log(last - first)` 回比較する
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
+
+  std::ranges::make_heap(v);
+
+  // 最後尾要素を削除してヒープ化
+  std::ranges::pop_heap(v);
+  v.pop_back();
+
+  std::ranges::sort_heap(v);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::pop_heap[color ff0000]
+* std::ranges::make_heap[link ranges_make_heap.md]
+* v.pop_back()[link /reference/vector/vector/pop_back.md]
+* std::ranges::sort_heap[link ranges_sort_heap.md]
+
+### 出力
+```
+1
+3
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>push_heap -- heap系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_push_heap.html"/>
      <id>ad0f2d7258af154c53ba3fe6a4e0e84a24e5d57d:reference/algorithm/ranges_push_heap.md</id>
      <updated>2022-03-22T00:27:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_push_heap.md b/reference/algorithm/ranges_push_heap.md
new file mode 100644
index 000000000..777d489e8
--- /dev/null
+++ b/reference/algorithm/ranges_push_heap.md
@@ -0,0 +1,99 @@
+# push_heap
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr I push_heap(I first, S last, Comp comp = {}, Proj proj = {});
+
+  // (2)
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; push_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+ヒープ化された範囲に要素を追加したヒープ範囲を得る
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 事前条件
+- `[first,last - 1)` は有効な heap である必要がある。
+
+
+## 効果
+`last - 1` の値を、`[first,last)` が有効な heap となるように配置する
+
+
+## 戻り値
+`last`
+
+
+## 計算量
+最大で `log(last - first)` 回比較する。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
+
+  std::ranges::make_heap(v);
+
+  // 要素を追加してヒープ化
+  v.push_back(2);
+  std::ranges::push_heap(v);
+
+  std::ranges::sort_heap(v);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::push_heap[color ff0000]
+* std::ranges::make_heap[link ranges_make_heap.md]
+* v.push_back[link /reference/vector/vector/push_back.md]
+* std::ranges::sort_heap[link ranges_sort_heap.md]
+
+### 出力
+```
+1
+2
+3
+4
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sort_heap -- heap系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_sort_heap.html"/>
      <id>ad0f2d7258af154c53ba3fe6a4e0e84a24e5d57d:reference/algorithm/ranges_sort_heap.md</id>
      <updated>2022-03-22T00:27:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_sort_heap.md b/reference/algorithm/ranges_sort_heap.md
new file mode 100644
index 000000000..602197e78
--- /dev/null
+++ b/reference/algorithm/ranges_sort_heap.md
@@ -0,0 +1,93 @@
+# sort_heap
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;random_access_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr I sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
+
+  // (2)
+  template&amp;lt;random_access_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; sort_heap(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+}
+```
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* random_access_range[link /reference/ranges/random_access_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+ヒープ化された範囲を並べ替える
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 事前条件
+- `[first,last)` は有効なヒープである必要がある。
+
+
+## 効果
+ヒープ化されている `[first,last)` をソートする
+
+
+## 戻り値
+`last`
+
+
+## 計算量
+最大で N log(N) 回比較する（N == `last - first`）
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
+  std::ranges::make_heap(v);
+
+  // ヒープ化された範囲をソート
+  std::ranges::sort_heap(v);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::sort_heap[color ff0000]
+* std::ranges::make_heap[link ranges_make_heap.md]
+
+### 出力
+```
+1
+3
+4
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- partition系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>2029a42e73a0acab24b822a0d67aaba70311dafb:reference/algorithm.md</id>
      <updated>2022-03-22T00:12:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 07a89e8e5..18335ca6c 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -213,11 +213,11 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::shift_right`](algorithm/ranges_shift_right.md)           | 要素を右にシフトさせる                                                                                          | C++23 |
 | [`ranges::sample`](algorithm/ranges_sample.md)                     | 範囲から指定された個数の要素をランダムに抽出する                                                                | C++20 |
 | [`ranges::shuffle`](algorithm/ranges_shuffle.md)                   | それぞれの要素をランダムな位置に移動させる                                                                      | C++20 |
-| [`ranges::is_partitioned`](algorithm/ranges_is_partitioned.md.nolink)     | 与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する       | C++20 |
-| [`ranges::partition`](algorithm/ranges_partition.md.nolink)               | 与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する                       | C++20 |
-| [`ranges::stable_partition`](algorithm/ranges_stable_partition.md.nolink) | 与えられた範囲を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する   | C++20 |
-| [`ranges::partition_copy`](algorithm/ranges_partition_copy.md.nolink)     | 与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする                                                 | C++20 |
-| [`ranges::partition_point`](algorithm/ranges_partition_point.md.nolink)   | 与えられた範囲から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る     | C++20 |
+| [`ranges::is_partitioned`](algorithm/ranges_is_partitioned.md)     | 与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する       | C++20 |
+| [`ranges::partition`](algorithm/ranges_partition.md)               | 与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する                       | C++20 |
+| [`ranges::stable_partition`](algorithm/ranges_stable_partition.md) | 与えられた範囲を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する   | C++20 |
+| [`ranges::partition_copy`](algorithm/ranges_partition_copy.md)     | 与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする                                                 | C++20 |
+| [`ranges::partition_point`](algorithm/ranges_partition_point.md)   | 与えられた範囲から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る     | C++20 |
 
 ## ソートや、それに関連した操作
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_out_out_result -- partition系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_out_out_result.html"/>
      <id>2029a42e73a0acab24b822a0d67aaba70311dafb:reference/algorithm/ranges_in_out_out_result.md</id>
      <updated>2022-03-22T00:12:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_out_out_result.md b/reference/algorithm/ranges_in_out_out_result.md
index 7d83207a1..1e33f5896 100644
--- a/reference/algorithm/ranges_in_out_out_result.md
+++ b/reference/algorithm/ranges_in_out_out_result.md
@@ -41,7 +41,7 @@ namespace std::ranges {
 
 ## 概要
 * (1): 3つのイテレータを格納する型
-* (2): [`ranges::partition_copy`](ranges_partition_copy.md.nolink)で使用するエイリアス
+* (2): [`ranges::partition_copy`](ranges_partition_copy.md)で使用するエイリアス
 
 この型は、関数が入力用の範囲と2つの出力用の範囲を受け取る場合に、それぞれ処理した範囲の末尾を返すために使用される。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_partitioned -- partition系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_partitioned.html"/>
      <id>2029a42e73a0acab24b822a0d67aaba70311dafb:reference/algorithm/ranges_is_partitioned.md</id>
      <updated>2022-03-22T00:12:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_partitioned.md b/reference/algorithm/ranges_is_partitioned.md
new file mode 100644
index 000000000..b4cdf7976
--- /dev/null
+++ b/reference/algorithm/ranges_is_partitioned.md
@@ -0,0 +1,92 @@
+# is_partitioned
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
+
+  // (2)
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr bool is_partitioned(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する。
+
+
+## 戻り値
+`[first,last)` が空、 または `[first,last)` が `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているなら `true` 、そうでなければ `false` を返す。
+
+つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現するなら `true` を返す。
+
+
+## 計算量
+線形時間。最大で `last - first` 回 `pred` が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  auto pred = [](int x) { return x % 2 == 0; };
+
+  // 偶数グループと奇数グループに分ける
+  std::ranges::partition(v, pred);
+
+  for (int x : v) {
+   std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 偶数グループと奇数グループに分かれているか
+  if (std::ranges::is_partitioned(v, pred)) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;partitioned&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not partitioned&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::is_partitioned[color ff0000]
+* std::ranges::partition[link ranges_partition.md]
+
+### 出力
+```
+4
+2
+3
+1
+5
+partitioned
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition -- partition系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition.html"/>
      <id>2029a42e73a0acab24b822a0d67aaba70311dafb:reference/algorithm/ranges_partition.md</id>
      <updated>2022-03-22T00:12:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition.md b/reference/algorithm/ranges_partition.md
new file mode 100644
index 000000000..70b08cb06
--- /dev/null
+++ b/reference/algorithm/ranges_partition.md
@@ -0,0 +1,106 @@
+# partition
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; partition(I first, S last, Pred pred, Proj proj = {});
+
+  // (2)
+  template&amp;lt;forward_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; partition(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+}
+```
+* permutable[link /reference/iterator/permutable.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* subrange[link /reference/ranges/subrange.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+## 概要
+与えられた範囲を条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 効果
+`[first,last)` 内にある `pred` を満たす全ての要素を、`pred` を満たさない全ての要素より前に移動させる。
+
+
+## 戻り値
+`{i, last}`
+
+ただし、`[first,i)` 内にあるイテレータ `j` について `pred(*j) != false` を満たし、`[i,last)` 内にあるイテレータ `k` について `pred(*k) == false` を満たすようなイテレータ (つまり、[区分化](/reference/algorithm.md#sequence-is-partitioned)された境界を指すイテレータ) を `i` とする。
+
+
+
+## 計算量
+
+`N = last - first`として
+
+- (1) : `I` が [`bidirectional_iterator`](/reference/iterator/bidirectional_iterator.md)のモデルとなる場合、最大で `N / 2` 回 swap され、そうでない場合、最大で `N` 回 swap される。それに加えて、正確に `N` 回だけ述語が適用される
+- (2) : O(NlogN) 回の swap に加え、述語が O(N) 回適用される
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 偶数グループと奇数グループに分ける
+  std::ranges::subrange latter = std::ranges::partition(v, [](int x) { return x % 2 == 0; });
+  std::ranges::subrange former = {v.begin(), latter.begin()};
+
+  // 条件x % 2 == 0を満たす要素
+  for (int x : former) {
+   std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+
+  // それ以外の要素
+  std::cout &amp;lt;&amp;lt; &amp;#34;----&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (int x : latter) {
+   std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::partition[color ff0000]
+* std::ranges::subrange[link /reference/ranges/subrange.md]
+
+### 出力
+```
+4
+2
+----
+3
+1
+5
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_copy -- partition系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_copy.html"/>
      <id>2029a42e73a0acab24b822a0d67aaba70311dafb:reference/algorithm/ranges_partition_copy.md</id>
      <updated>2022-03-22T00:12:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_copy.md b/reference/algorithm/ranges_partition_copy.md
new file mode 100644
index 000000000..50dae8cf2
--- /dev/null
+++ b/reference/algorithm/ranges_partition_copy.md
@@ -0,0 +1,110 @@
+# partition_copy
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O1, weakly_incrementable O2, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;I, O2&amp;gt;
+  constexpr partition_copy_result&amp;lt;I, O1, O2&amp;gt;
+    partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
+
+  // (2)
+  template&amp;lt;input_range R, weakly_incrementable O1, weakly_incrementable O2, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O1&amp;gt; &amp;amp;&amp;amp; indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O2&amp;gt;
+  constexpr partition_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O1, O2&amp;gt;
+    partition_copy(R&amp;amp;&amp;amp; r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
+* partition_copy_result[link ranges_in_out_out_result.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+
+## 概要
+与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 事前条件
+- 入力範囲は出力範囲のどちらとも重なっていてはならない。
+
+
+## 効果
+`[first,last)` 内にあるそれぞれのイテレータ `i` について、`pred(*i)` が `true` なら `*i` を `out_true` へコピーし、そうでない場合は `out_false` へコピーする。
+
+
+## 戻り値
+`o1` を `out_true` の終端、`o2` を `out_false` の終端とするとき、`{ .in = last, .out1 = o1, .out2 = o2 }`
+
+## 計算量
+正確に `last - first` 回述語が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+void print(const std::string&amp;amp; name, const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
+{
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; : &amp;#34;;
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;,&amp;#34;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+bool is_even(int x) { return x % 2 == 0; }
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 偶数グループと奇数グループに分ける
+  std::vector&amp;lt;int&amp;gt; evens;
+  std::vector&amp;lt;int&amp;gt; odds;
+  std::ranges::partition_copy(v, std::back_inserter(evens), std::back_inserter(odds), is_even);
+
+  print(&amp;#34;v&amp;#34;, v);
+  print(&amp;#34;evens&amp;#34;, evens);
+  print(&amp;#34;odds&amp;#34;, odds);
+}
+```
+* std::ranges::partition_copy[color ff0000]
+
+### 出力
+```
+v : 1,2,3,4,5,
+evens : 2,4,
+odds : 1,3,5,
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partition_point -- partition系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partition_point.html"/>
      <id>2029a42e73a0acab24b822a0d67aaba70311dafb:reference/algorithm/ranges_partition_point.md</id>
      <updated>2022-03-22T00:12:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partition_point.md b/reference/algorithm/ranges_partition_point.md
new file mode 100644
index 000000000..c28391c15
--- /dev/null
+++ b/reference/algorithm/ranges_partition_point.md
@@ -0,0 +1,97 @@
+# partition_point
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
+
+  // (2)
+  template&amp;lt;forward_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; partition_point(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+
+## 概要
+与えられた範囲から条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されている位置を得る。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 事前条件
+- `[first,last)` は `pred` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。つまり、`pred` を満たす全ての要素が、`pred` を満たさない全ての要素より前に出現してなければならない。
+
+
+## 戻り値
+[`all_of`](ranges_all_of.md)`(first, mid, pred)` と [`none_of`](ranges_none_of.md)`(mid, last, pred)` が `true` であるようなイテレータ `mid` を返す。
+
+
+## 計算量
+`pred` が O(log(`last - first`)) 回適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+void print(const char* name, const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
+{
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; : &amp;#34;;
+  std::for_each(v.begin(), v.end(), [](int x) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;,&amp;#34;;
+  });
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+bool is_even(int x) { return x % 2 == 0; }
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  std::ranges::partition(v, is_even);
+
+  // 偶数グループと奇数グループに分かれた位置を得る
+  auto it = std::ranges::partition_point(v, is_even);
+
+  print(&amp;#34;v&amp;#34;, v);
+  std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::partition_point[color ff0000]
+* std::ranges::partition[link ranges_partition.md]
+
+### 出力
+```
+v : 4,2,3,1,5,
+3
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stable_partition -- partition系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_stable_partition.html"/>
      <id>2029a42e73a0acab24b822a0d67aaba70311dafb:reference/algorithm/ranges_stable_partition.md</id>
      <updated>2022-03-22T00:12:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_stable_partition.md b/reference/algorithm/ranges_stable_partition.md
new file mode 100644
index 000000000..513d6d409
--- /dev/null
+++ b/reference/algorithm/ranges_stable_partition.md
@@ -0,0 +1,98 @@
+# stable_partition
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  subrange&amp;lt;I&amp;gt; stable_partition(I first, S last, Pred pred, Proj proj = {});
+
+  // (2)
+  template&amp;lt;bidirectional_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  borrowed_subrange_t&amp;lt;R&amp;gt; stable_partition(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+}
+```
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* permutable[link /reference/iterator/permutable.md]
+* subrange[link /reference/ranges/subrange.md]
+* bidirectional_range[link /reference/ranges/bidirectional_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+
+## 概要
+与えられた範囲を相対順序を保ちながら条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 効果
+`[first,last)` 内にある `pred` を満たす全ての要素を、`pred` を満たさない全ての要素より前に移動させる。
+
+
+## 戻り値
+`{i, last}`
+
+ただし、`[first,i)` 内にあるイテレータ `j` について `pred(*j) != false` を満たし、`[i,last)` 内にあるイテレータ `k` について `pred(*k) == false` を満たすようなイテレータ(つまり、[区分化](/reference/algorithm.md#sequence-is-partitioned)された境界を指すイテレータ)を `i` とする。
+
+条件を満たす・満たさない両グループ内での要素間の相対順序は保たれる。
+
+
+## 計算量
+`N = last - first`として説明する。
+
+- (1) : 最大でN log N回 swap が行われるが、余分なメモリを使って構わないのであれば線形回数の swap になる。それに加えて、正確にN回だけ述語が適用される
+- (2) : O(N log N) 回の swap に加え、述語が O(N) 回適用される
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  // 偶数グループと奇数グループに分ける
+  std::ranges::stable_partition(v, [](int x) { return x % 2 == 0; });
+
+  for (int x : v) {
+   std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::stable_partition[color ff0000]
+
+### 出力
+```
+2
+4
+1
+3
+5
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- reverse系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>58e4abc887d9570b2587c6e78ea96ee9907554df:reference/algorithm.md</id>
      <updated>2022-03-21T23:47:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index fce99979e..07a89e8e5 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -205,8 +205,8 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::remove_copy_if`](algorithm/ranges_remove_copy_if.md)     | 条件を満たす要素を除け、その結果を出力の範囲へコピーする                                                        | C++20 |
 | [`ranges::unique`](algorithm/ranges_unique.md)                     | 重複した要素を除ける                                                                                            | C++20 |
 | [`ranges::unique_copy`](algorithm/ranges_unique_copy.md)           | 重複した要素を除け、その結果を出力の範囲へコピーする                                                            | C++20 |
-| [`ranges::reverse`](algorithm/ranges_reverse.md.nolink)                   | 要素の並びを逆にする                                                                                            | C++20 |
-| [`ranges::reverse_copy`](algorithm/ranges_reverse_copy.md.nolink)         | 要素の並びを逆にし、その結果を出力の範囲へコピーする                                                            | C++20 |
+| [`ranges::reverse`](algorithm/ranges_reverse.md)                   | 要素の並びを逆にする                                                                                            | C++20 |
+| [`ranges::reverse_copy`](algorithm/ranges_reverse_copy.md)         | 要素の並びを逆にし、その結果を出力の範囲へコピーする                                                            | C++20 |
 | [`ranges::rotate`](algorithm/ranges_rotate.md)                     | 要素の並びを回転させる                                                                                          | C++20 |
 | [`ranges::rotate_copy`](algorithm/ranges_rotate_copy.md)           | 要素の並びを回転させ、その結果を出力の範囲へコピーする                                                          | C++20 |
 | [`ranges::shift_left`](algorithm/ranges_shift_left.md)             | 要素を左にシフトさせる                                                                                          | C++23 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_out_result -- reverse系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_out_result.html"/>
      <id>58e4abc887d9570b2587c6e78ea96ee9907554df:reference/algorithm/ranges_in_out_result.md</id>
      <updated>2022-03-21T23:47:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_out_result.md b/reference/algorithm/ranges_in_out_result.md
index c03087326..ad8f72ba2 100644
--- a/reference/algorithm/ranges_in_out_result.md
+++ b/reference/algorithm/ranges_in_out_result.md
@@ -108,7 +108,7 @@ namespace std::ranges {
 * (11): [`ranges::remove_copy`](ranges_remove_copy.md)で使用するエイリアス
 * (12): [`ranges::remove_copy_if`](ranges_remove_copy_if.md)で使用するエイリアス
 * (13): [`ranges::unique_copy`](ranges_unique_copy.md)で使用するエイリアス
-* (14): [`ranges::reverse_copy`](ranges_reverse_copy.md.nolink)で使用するエイリアス
+* (14): [`ranges::reverse_copy`](ranges_reverse_copy.md)で使用するエイリアス
 * (15): [`ranges::rotate_copy`](ranges_rotate_copy.md)で使用するエイリアス
 * (16): [`ranges::partial_sort_copy`](ranges_partial_sort_copy.md)で使用するエイリアス
 * (17): [`ranges::set_difference`](ranges_set_difference.md)で使用するエイリアス
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse -- reverse系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse.html"/>
      <id>58e4abc887d9570b2587c6e78ea96ee9907554df:reference/algorithm/ranges_reverse.md</id>
      <updated>2022-03-21T23:47:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse.md b/reference/algorithm/ranges_reverse.md
new file mode 100644
index 000000000..9d81cc832
--- /dev/null
+++ b/reference/algorithm/ranges_reverse.md
@@ -0,0 +1,81 @@
+# reverse
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    requires permutable&amp;lt;I&amp;gt;
+  constexpr I reverse(I first, S last);
+
+  // (2)
+  template&amp;lt;bidirectional_range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; reverse(R&amp;amp;&amp;amp; r);
+}
+```
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* permutable[link /reference/iterator/permutable.md]
+* bidirectional_range[link /reference/ranges/bidirectional_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+要素の並びを逆にする。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 要件
+`*first` は `Swappable` でなければならない
+
+
+## 効果
+0 以上 `(last - first) / 2` 未満の整数 `i` について、[`iter_swap`](iter_swap.md)`(first + i, (last - i) - 1)` を行う
+
+
+## 戻り値
+`last`
+
+
+## 計算量
+正確に `(last - first) / 2` 回 swap する
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main() {
+  std::string str = &amp;#34;reverse&amp;#34;;
+
+  std::ranges::reverse(str);
+  std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::reverse[color ff0000]
+
+### 出力
+```
+esrever
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_copy -- reverse系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_reverse_copy.html"/>
      <id>58e4abc887d9570b2587c6e78ea96ee9907554df:reference/algorithm/ranges_reverse_copy.md</id>
      <updated>2022-03-21T23:47:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_reverse_copy.md b/reference/algorithm/ranges_reverse_copy.md
new file mode 100644
index 000000000..a6202a5dc
--- /dev/null
+++ b/reference/algorithm/ranges_reverse_copy.md
@@ -0,0 +1,85 @@
+# reverse_copy
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  constexpr reverse_copy_result&amp;lt;I, O&amp;gt;
+    reverse_copy(I first, S last, O result);
+
+  // (2)
+  template&amp;lt;bidirectional_range R, weakly_incrementable O&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+  constexpr reverse_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    reverse_copy(R&amp;amp;&amp;amp; r, O result);
+}
+```
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
+* reverse_copy_result[link ranges_in_out_result.md]
+* bidirectional_range[link /reference/ranges/bidirectional_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+要素の並びを逆にし、その結果を出力の範囲へコピーする。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 事前条件
+`[first,last)` と `[result,result+(last-first))` は領域が重なっていてはならない。
+
+
+## 効果
+0 以上 `last - first` 未満の整数 `i` について、`*(result + (last - first) -1 - i) = *(first + i)` を行うことで、`[first,last)` の範囲を `[result,result+(last-first))` へコピーする。
+
+
+## 戻り値
+`{ .in = last, .out = result + (last - first) }`
+
+
+## 計算量
+正確に `last - first` 回代入する
+
+
+## 使用例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+int main() {
+  std::string str = &amp;#34;reverse&amp;#34;;
+
+  std::ranges::reverse_copy(str, std::ostream_iterator&amp;lt;char&amp;gt;(std::cout, &amp;#34;&amp;#34;));
+}
+```
+* std::ranges::reverse_copy[color ff0000]
+
+### 出力
+```
+esrever
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- unique系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>8b440c06a3e32bfbddebaf9dc7af87ce816b1110:reference/algorithm.md</id>
      <updated>2022-03-21T23:42:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index e802bcc6e..fce99979e 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -203,8 +203,8 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::remove_if`](algorithm/ranges_remove_if.md)               | 条件を満たす要素を除ける                                                                                        | C++20 |
 | [`ranges::remove_copy`](algorithm/ranges_remove_copy.md)           | 指定された要素を除け、その結果を出力の範囲へコピーする                                                          | C++20 |
 | [`ranges::remove_copy_if`](algorithm/ranges_remove_copy_if.md)     | 条件を満たす要素を除け、その結果を出力の範囲へコピーする                                                        | C++20 |
-| [`ranges::unique`](algorithm/ranges_unique.md.nolink)                     | 重複した要素を除ける                                                                                            | C++20 |
-| [`ranges::unique_copy`](algorithm/ranges_unique_copy.md.nolink)           | 重複した要素を除け、その結果を出力の範囲へコピーする                                                            | C++20 |
+| [`ranges::unique`](algorithm/ranges_unique.md)                     | 重複した要素を除ける                                                                                            | C++20 |
+| [`ranges::unique_copy`](algorithm/ranges_unique_copy.md)           | 重複した要素を除け、その結果を出力の範囲へコピーする                                                            | C++20 |
 | [`ranges::reverse`](algorithm/ranges_reverse.md.nolink)                   | 要素の並びを逆にする                                                                                            | C++20 |
 | [`ranges::reverse_copy`](algorithm/ranges_reverse_copy.md.nolink)         | 要素の並びを逆にし、その結果を出力の範囲へコピーする                                                            | C++20 |
 | [`ranges::rotate`](algorithm/ranges_rotate.md)                     | 要素の並びを回転させる                                                                                          | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_out_result -- unique系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_out_result.html"/>
      <id>8b440c06a3e32bfbddebaf9dc7af87ce816b1110:reference/algorithm/ranges_in_out_result.md</id>
      <updated>2022-03-21T23:42:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_out_result.md b/reference/algorithm/ranges_in_out_result.md
index 883f560e0..c03087326 100644
--- a/reference/algorithm/ranges_in_out_result.md
+++ b/reference/algorithm/ranges_in_out_result.md
@@ -107,7 +107,7 @@ namespace std::ranges {
 * (10): [`ranges::replace_copy_if`](ranges_replace_copy_if.md)で使用するエイリアス
 * (11): [`ranges::remove_copy`](ranges_remove_copy.md)で使用するエイリアス
 * (12): [`ranges::remove_copy_if`](ranges_remove_copy_if.md)で使用するエイリアス
-* (13): [`ranges::unique_copy`](ranges_unique_copy.md.nolink)で使用するエイリアス
+* (13): [`ranges::unique_copy`](ranges_unique_copy.md)で使用するエイリアス
 * (14): [`ranges::reverse_copy`](ranges_reverse_copy.md.nolink)で使用するエイリアス
 * (15): [`ranges::rotate_copy`](ranges_rotate_copy.md)で使用するエイリアス
 * (16): [`ranges::partial_sort_copy`](ranges_partial_sort_copy.md)で使用するエイリアス
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- unique系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique.html"/>
      <id>8b440c06a3e32bfbddebaf9dc7af87ce816b1110:reference/algorithm/ranges_unique.md</id>
      <updated>2022-03-21T23:42:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique.md b/reference/algorithm/ranges_unique.md
new file mode 100644
index 000000000..2aa84245e
--- /dev/null
+++ b/reference/algorithm/ranges_unique.md
@@ -0,0 +1,129 @@
+# unique
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; unique(I first, S last, C comp = {}, Proj proj = {});
+
+  // (2)
+  template&amp;lt;forward_range R, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; unique(R&amp;amp;&amp;amp; r, C comp = {}, Proj proj = {});
+}
+```
+* permutable[link /reference/iterator/permutable.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_equivalence_relation[link /reference/iterator/indirect_equivalence_relation.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+* subrange[link /reference/ranges/subrange.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+
+## 概要
+重複した要素を除ける。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+この関数は、隣り合った重複要素を除いた要素を、範囲の先頭に集める。この関数によってコンテナから直接要素が削除され、コンテナの要素数が減るようなことはない。コンテナから実際に要素を削除する場合は、この関数の戻り値として、先頭に集められた重複なし範囲の末尾の次を指すイテレータが返るため、そのイテレータを介してコンテナの`erase()`メンバ関数などを呼び出し、削除を行うこと。
+
+この関数の戻り値として返されるイテレータ以降の値は未規定。
+
+
+## 効果
+`[first,last)` が空の範囲でない場合、`[first + 1,last)` 内のイテレータ `i` について、
+
+- (1) では`*(i - 1) == *i`
+- (2) では`pred(*(i - 1), *i) != false`
+
+による等値の比較によって連続したグループに分け、それぞれのグループの先頭以外を取り除く。
+
+
+## 戻り値
+`j`を重複を除いた範囲の末尾の次を指すイテレータとするとき、`{j, last}`
+
+
+## 計算量
+`[first,last)` が空の範囲でない場合、正確に `last - first - 1` 回の比較または述語の適用を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+void print(const char* tag, const std::vector&amp;lt;int&amp;gt;&amp;amp; v) {
+  std::cout &amp;lt;&amp;lt; tag &amp;lt;&amp;lt; &amp;#34; : &amp;#34;;
+  bool first = true;
+  for (int x : v) {
+    if (first) {
+      first = false;
+    }
+    else {
+      std::cout &amp;lt;&amp;lt; &amp;#39;,&amp;#39;;
+    }
+    std::cout &amp;lt;&amp;lt; x;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+int main() {
+  // 入力の配列がソート済みではない場合、
+  // 隣り合った重複要素が取り除かれる
+  {
+    std::vector&amp;lt;int&amp;gt; v = { 2,5,3,3,1,2,4,2,1,1,4,4,3,3,3 };
+
+    auto result = std::ranges::unique(v);
+
+    // [v.begin(), result.begin())の範囲に、重複を除いた結果が入っている。
+    // 不要になった要素を削除
+    v.erase(result.begin(), result.end());
+
+    print(&amp;#34;unsorted unique&amp;#34;, v);
+  }
+
+  // 入力の配列がソート済みである場合、
+  // 重複している全ての要素が取り除かれて一意になる
+  {
+    std::vector&amp;lt;int&amp;gt; v = { 2,5,3,3,1,2,4,2,1,1,4,4,3,3,3 };
+
+    std::sort(v.begin(), v.end());
+    auto result = std::ranges::unique(v);
+
+    // 不要になった要素を削除
+    v.erase(result.begin(), result.end());
+
+    print(&amp;#34;sorted unique&amp;#34;, v);
+  }
+}
+```
+* std::ranges::unique[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+### 出力
+```
+unsorted unique : 2,5,3,1,2,4,2,1,4,3
+sorted unique : 1,2,3,4,5
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique_copy -- unique系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_unique_copy.html"/>
      <id>8b440c06a3e32bfbddebaf9dc7af87ce816b1110:reference/algorithm/ranges_unique_copy.md</id>
      <updated>2022-03-21T23:42:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_unique_copy.md b/reference/algorithm/ranges_unique_copy.md
new file mode 100644
index 000000000..4e85f76ff
--- /dev/null
+++ b/reference/algorithm/ranges_unique_copy.md
@@ -0,0 +1,135 @@
+# unique_copy
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+      (forward_iterator&amp;lt;I&amp;gt; || (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;iter_value_t&amp;lt;I&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) || indirectly_copyable_storable&amp;lt;I, O&amp;gt;)
+  constexpr unique_copy_result&amp;lt;I, O&amp;gt;
+    unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
+
+  // (2)
+  template&amp;lt;input_range R, weakly_incrementable O, class Proj = identity, indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; C = ranges::equal_to&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
+      (forward_iterator&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; || (input_iterator&amp;lt;O&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;range_value_t&amp;lt;R&amp;gt;, iter_value_t&amp;lt;O&amp;gt;&amp;gt;) || indirectly_copyable_storable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;)
+  constexpr unique_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    unique_copy(R&amp;amp;&amp;amp; r, O result, C comp = {}, Proj proj = {});
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* identity[link /reference/functional/identity.md]
+* indirect_equivalence_relation[link /reference/iterator/indirect_equivalence_relation.md]
+* indirectly_copyable[link /reference/iterator/indirectly_copyable.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* same_as[link /reference/concepts/same_as.md]
+* iter_value_t[link /reference/iterator/iter_value_t.md]
+* indirectly_copyable_storable[link /reference/iterator/indirectly_copyable_storable.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+* unique_copy_result[link ranges_in_out_result.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+隣り合った重複要素を取り除き、その結果を出力の範囲へコピーする。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 事前条件
+- `[first,last)` と `[result,result + (last - first))` は重なっていてはならない
+
+
+## 効果
+`[first,last)` 内のイテレータ `i` について、
+
+- (1) では `*(i - 1) == *i`
+- (2) では `pred(*(i - 1), *i) != false`
+
+による等値の比較によって連続したグループに分け、それぞれのグループの先頭を `result` へコピーする。
+
+
+## 戻り値
+`{ .in = last, .out = result + (last - first) }`
+
+## 計算量
+`[first,last)` が空の範囲でない場合、正確に `last - first - 1` 回の比較または述語の適用を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+void print(const char* tag, const std::vector&amp;lt;int&amp;gt;&amp;amp; v) {
+  std::cout &amp;lt;&amp;lt; tag &amp;lt;&amp;lt; &amp;#34; : &amp;#34;;
+  bool first = true;
+  for (int x : v) {
+    if (first) {
+      first = false;
+    }
+    else {
+      std::cout &amp;lt;&amp;lt; &amp;#39;,&amp;#39;;
+    }
+    std::cout &amp;lt;&amp;lt; x;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+int main() {
+  // 入力の配列がソート済みではない場合、
+  // 隣り合った重複要素が取り除かれる
+  {
+    std::vector&amp;lt;int&amp;gt; v = { 2,5,3,3,1,2,4,2,1,1,4,4,3,3,3 };
+    std::vector&amp;lt;int&amp;gt; uniqued;
+
+    // 重複を除いた要素がuniquedに追加されていく
+    std::ranges::unique_copy(v, std::back_inserter(uniqued));
+
+    print(&amp;#34;unsorted unique&amp;#34;, uniqued);
+  }
+
+  // 入力の配列がソート済みである場合、
+  // 重複している全ての要素が取り除かれて一意になる
+  {
+    std::vector&amp;lt;int&amp;gt; v = { 2,5,3,3,1,2,4,2,1,1,4,4,3,3,3 };
+    std::vector&amp;lt;int&amp;gt; uniqued;
+
+    std::ranges::sort(v);
+    std::ranges::unique_copy(v, std::back_inserter(uniqued));
+
+    print(&amp;#34;sorted unique&amp;#34;, uniqued);
+  }
+}
+```
+* std::ranges::unique_copy[color ff0000]
+* std::ranges::sort[link ranges_sort.md]
+
+### 出力
+```
+unsorted unique : 2,5,3,1,2,4,2,1,4,3
+sorted unique : 1,2,3,4,5
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- rotate/shift系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>7e2bafa148a026cc524887ac34026a23f0ca2f1a:reference/algorithm.md</id>
      <updated>2022-03-21T23:24:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 90699b5db..e802bcc6e 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -207,10 +207,10 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::unique_copy`](algorithm/ranges_unique_copy.md.nolink)           | 重複した要素を除け、その結果を出力の範囲へコピーする                                                            | C++20 |
 | [`ranges::reverse`](algorithm/ranges_reverse.md.nolink)                   | 要素の並びを逆にする                                                                                            | C++20 |
 | [`ranges::reverse_copy`](algorithm/ranges_reverse_copy.md.nolink)         | 要素の並びを逆にし、その結果を出力の範囲へコピーする                                                            | C++20 |
-| [`ranges::rotate`](algorithm/ranges_rotate.md.nolink)                     | 要素の並びを回転させる                                                                                          | C++20 |
-| [`ranges::rotate_copy`](algorithm/ranges_rotate_copy.md.nolink)           | 要素の並びを回転させ、その結果を出力の範囲へコピーする                                                          | C++20 |
-| [`ranges::shift_left`](algorithm/ranges_shift_left.md.nolink)             | 要素を左にシフトさせる                                                                                          | C++20 |
-| [`ranges::shift_right`](algorithm/ranges_shift_right.md.nolink)           | 要素を右にシフトさせる                                                                                          | C++20 |
+| [`ranges::rotate`](algorithm/ranges_rotate.md)                     | 要素の並びを回転させる                                                                                          | C++20 |
+| [`ranges::rotate_copy`](algorithm/ranges_rotate_copy.md)           | 要素の並びを回転させ、その結果を出力の範囲へコピーする                                                          | C++20 |
+| [`ranges::shift_left`](algorithm/ranges_shift_left.md)             | 要素を左にシフトさせる                                                                                          | C++23 |
+| [`ranges::shift_right`](algorithm/ranges_shift_right.md)           | 要素を右にシフトさせる                                                                                          | C++23 |
 | [`ranges::sample`](algorithm/ranges_sample.md)                     | 範囲から指定された個数の要素をランダムに抽出する                                                                | C++20 |
 | [`ranges::shuffle`](algorithm/ranges_shuffle.md)                   | それぞれの要素をランダムな位置に移動させる                                                                      | C++20 |
 | [`ranges::is_partitioned`](algorithm/ranges_is_partitioned.md.nolink)     | 与えられた範囲が条件によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されているか判定する       | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_out_result -- rotate/shift系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_out_result.html"/>
      <id>7e2bafa148a026cc524887ac34026a23f0ca2f1a:reference/algorithm/ranges_in_out_result.md</id>
      <updated>2022-03-21T23:24:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_out_result.md b/reference/algorithm/ranges_in_out_result.md
index 14bfe8a81..883f560e0 100644
--- a/reference/algorithm/ranges_in_out_result.md
+++ b/reference/algorithm/ranges_in_out_result.md
@@ -109,7 +109,7 @@ namespace std::ranges {
 * (12): [`ranges::remove_copy_if`](ranges_remove_copy_if.md)で使用するエイリアス
 * (13): [`ranges::unique_copy`](ranges_unique_copy.md.nolink)で使用するエイリアス
 * (14): [`ranges::reverse_copy`](ranges_reverse_copy.md.nolink)で使用するエイリアス
-* (15): [`ranges::rotate_copy`](ranges_rotate_copy.md.nolink)で使用するエイリアス
+* (15): [`ranges::rotate_copy`](ranges_rotate_copy.md)で使用するエイリアス
 * (16): [`ranges::partial_sort_copy`](ranges_partial_sort_copy.md)で使用するエイリアス
 * (17): [`ranges::set_difference`](ranges_set_difference.md)で使用するエイリアス
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate -- rotate/shift系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate.html"/>
      <id>7e2bafa148a026cc524887ac34026a23f0ca2f1a:reference/algorithm/ranges_rotate.md</id>
      <updated>2022-03-21T23:24:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate.md b/reference/algorithm/ranges_rotate.md
new file mode 100644
index 000000000..923fb73ce
--- /dev/null
+++ b/reference/algorithm/ranges_rotate.md
@@ -0,0 +1,151 @@
+# rotate
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; rotate(I first, I middle, S last);
+
+  // (2)
+  template&amp;lt;forward_range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; rotate(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle);
+}
+```
+* permutable[link /reference/iterator/permutable.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* subrange[link /reference/ranges/subrange.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+## 概要
+`middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させる。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 事前条件
+- `[first,middle)` と `[middle,last)` は有効な範囲である必要がある。
+
+
+## 効果
+0 以上 `last - first` 未満の整数 `i` について、`first + i` の要素を `first + (i + (last - middle)) % (last - first)` の位置へ移動させる。
+
+
+## 戻り値
+末尾を除く回転前の列を表す部分Range `{first + (last - middle), last}`
+
+
+## 備考
+これは左への回転である
+
+
+## 計算量
+最大で `last - first` 回 swap する。
+
+
+## 例
+### 基本的な使い方
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main() {
+  std::string str = &amp;#34;rotate&amp;#34;;
+
+  std::ranges::rotate(str, str.begin() + 2);
+  std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::rotate[color ff0000]
+* str.begin()[link /reference/string/basic_string/begin.md]
+* str.end()[link /reference/string/basic_string/end.md]
+
+#### 出力
+```
+tatero
+```
+
+### swapをフックして可視化した例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+class Elem
+{
+public:
+  Elem() : c_(&amp;#39;\0&amp;#39;) {}
+  explicit Elem(char c) : c_(c) {}
+  Elem&amp;amp; operator=(const char c) { c_ = c; return *this; }
+  operator char() const { return c_; }
+private:
+  char c_;
+};
+
+std::vector&amp;lt;Elem&amp;gt; seq;
+
+void swap(Elem&amp;amp; lhs, Elem&amp;amp; rhs)
+{
+  // std::rotate内部で実行されるswapを可視化できる。
+  // ライブラリの実装によってスワップの順番が異なることがある。
+  std::cout &amp;lt;&amp;lt; &amp;#34;swapping &amp;#34;
+            &amp;lt;&amp;lt; &amp;amp;lhs &amp;lt;&amp;lt; &amp;#34;(&amp;#34; &amp;lt;&amp;lt; lhs &amp;lt;&amp;lt; &amp;#34;) &amp;lt;-&amp;gt; &amp;#34;
+            &amp;lt;&amp;lt; &amp;amp;rhs &amp;lt;&amp;lt; &amp;#34;(&amp;#34; &amp;lt;&amp;lt; rhs &amp;lt;&amp;lt; &amp;#34;)&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::swap(lhs, rhs);
+  std::ranges::copy(seq, std::ostream_iterator&amp;lt;char&amp;gt;(std::cout));
+  std::cout &amp;lt;&amp;lt; &amp;#34;\n\n&amp;#34;;
+}
+
+int main()
+{
+  char str[] = &amp;#34;012345&amp;#34;;
+  seq.assign(str, str + sizeof(str) - 1);
+  std::ranges::rotate(seq, seq.begin() + 2);
+}
+```
+* std::ranges::rotate[color ff0000]
+* std::ranges::copy[link ranges_copy.md]
+* seq.begin()[link /reference/vector/vector/begin.md]
+* seq.end[link /reference/vector/vector/end.md]
+* seq.assign[link /reference/vector/vector/assign.md]
+* std::swap[link /reference/utility/swap.md]
+
+#### 出力例
+```
+swapping 0x1806040(0) &amp;lt;-&amp;gt; 0x1806042(2)
+210345
+
+swapping 0x1806041(1) &amp;lt;-&amp;gt; 0x1806043(3)
+230145
+
+swapping 0x1806042(0) &amp;lt;-&amp;gt; 0x1806044(4)
+234105
+
+swapping 0x1806043(1) &amp;lt;-&amp;gt; 0x1806045(5)
+234501
+```
+
+## 実装例
+- [std::rotate を読んでみた](http://www.kmonos.net/wlog/115.html#_0007101223)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rotate_copy -- rotate/shift系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_rotate_copy.html"/>
      <id>7e2bafa148a026cc524887ac34026a23f0ca2f1a:reference/algorithm/ranges_rotate_copy.md</id>
      <updated>2022-03-21T23:24:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_rotate_copy.md b/reference/algorithm/ranges_rotate_copy.md
new file mode 100644
index 000000000..59d81c1a3
--- /dev/null
+++ b/reference/algorithm/ranges_rotate_copy.md
@@ -0,0 +1,89 @@
+# rotate_copy
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+ template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, weakly_incrementable O&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt;
+  constexpr rotate_copy_result&amp;lt;I, O&amp;gt;
+    rotate_copy(I first, I middle, S last, O result);
+
+  // (2)
+  template&amp;lt;forward_range R, weakly_incrementable O&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+  constexpr rotate_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    rotate_copy(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, O result);
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* rotate_copy_result[link ranges_in_out_result.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+`middle`の要素が先頭、`middle-1`の要素が末尾となるように、`[first,last)`の要素の並びを回転させ、その結果を出力の範囲へコピーする。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 事前条件
+`[first,last)` と `[result,result + (last - first))` の範囲は重なっていてはならない。
+
+
+## 効果
+0 以上 `last - first` 未満の整数 `i` について、`*(result + i) = *(first + (i + (middle - first)) % (last - first))` という操作によって `[first,last)` の範囲を `[result,result + (last - first))` の範囲へコピーする
+
+
+## 戻り値
+回転前の先頭の要素を指すイテレータ`result + (last - first)`
+
+
+## 計算量
+正確に `last - first` 回代入する。
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+int main() {
+  std::string str = &amp;#34;rotate&amp;#34;;
+  std::string result;
+
+  std::ranges::rotate_copy(str, str.begin() + 2, std::back_inserter(result));
+
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::rotate_copy[color ff0000]
+* str.begin()[link /reference/string/basic_string/begin.md]
+* str.end()[link /reference/string/basic_string/end.md]
+
+### 出力
+```
+tatero
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_left -- rotate/shift系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_left.html"/>
      <id>7e2bafa148a026cc524887ac34026a23f0ca2f1a:reference/algorithm/ranges_shift_left.md</id>
      <updated>2022-03-21T23:24:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_left.md b/reference/algorithm/ranges_shift_left.md
new file mode 100644
index 000000000..adc75fe7c
--- /dev/null
+++ b/reference/algorithm/ranges_shift_left.md
@@ -0,0 +1,104 @@
+# shift_left
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    constexpr subrange&amp;lt;I&amp;gt; shift_left(I first, S last, iter_difference_t&amp;lt;I&amp;gt; n);
+
+  // (2)
+  template&amp;lt;forward_range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; shift_left(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; n)
+}
+```
+* permutable[link /reference/iterator/permutable.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* subrange[link /reference/ranges/subrange.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+
+## 概要
+範囲の要素をn個だけ左にシフトさせる。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
+
+この関数によって要素をn個だけ左にシフトすると、`[first + n, last)`の範囲は、ムーブされたあとの「使用してはいけないオブジェクト」となる。その範囲には、循環バッファ (circular buffer) のように新たな要素を代入するか、コンテナの`erase()`メンバ関数を使用して使わなくなった範囲を削除するなどの対応が必要になる。
+
+
+## 事前条件
+`n &amp;gt;= 0`
+
+
+## 効果
+- `n &amp;lt;= 0`である場合、なにもしない
+- `n &amp;gt;= last - first`である場合、なにもしない
+- `i &amp;lt; (last - first) - n`である非負の各`i`について、`first + n + i`位置の要素を`first + i`位置にムーブする
+    - (1)では、`i = 0`から`i = (last - first) - n - 1`の順に処理する
+
+
+## 戻り値
+`new_last`を次のように定義する。
+
+- `n &amp;gt; 0`かつ`n &amp;lt; last - first`である場合、`first + (last - first - n)`を返す
+- `n &amp;gt; 0`である場合、`first`を返す
+- いずれでもない場合、`last`を返す
+
+このとき、 `{first, new_last}`
+
+## 計算量
+最大で`(last - first) - n`回の代入を行う
+
+
+## 備考
+- シフト数として負数を指定するとなにも起こらないが、この関数には符号付き整数型を指定することとなっている。これは、Bidirectional Iterator向けの最適化した実装をする場合に[`std::prev()`](/reference/iterator/prev.md)関数を使用するため、そちらのパラメータ型と合わせたことによる
+- `shift_left()`と[`shift_right()`](ranges_shift_right.md)で関数が分かれているのは、コンパイルしたコードサイズを小さくするためと、左シフトと右シフトでは最大パフォーマンスのための実装が異なるためである
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  std::ranges::shift_left(v, 2);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39;,&amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::shift_left[color ff0000]
+
+### 出力
+```
+3,4,5,4,5,
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+## 参照
+- [N4901 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shift_right -- rotate/shift系関数の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_shift_right.html"/>
      <id>7e2bafa148a026cc524887ac34026a23f0ca2f1a:reference/algorithm/ranges_shift_right.md</id>
      <updated>2022-03-21T23:24:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_shift_right.md b/reference/algorithm/ranges_shift_right.md
new file mode 100644
index 000000000..55b05d1fa
--- /dev/null
+++ b/reference/algorithm/ranges_shift_right.md
@@ -0,0 +1,105 @@
+# shift_right
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;permutable I, sentinel_for&amp;lt;I&amp;gt; S&amp;gt;
+    constexpr subrange&amp;lt;I&amp;gt; shift_right(I first, S last, iter_difference_t&amp;lt;I&amp;gt; n);
+
+  // (2)
+  template&amp;lt;forward_range R&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; shift_right(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; n);
+}
+```
+* permutable[link /reference/iterator/permutable.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* subrange[link /reference/ranges/subrange.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+
+
+## 概要
+範囲の要素をn個だけ右にシフトさせる。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+この関数に符号付き整数型のシフト数として、0および負数を指定した場合はなにもしない。
+
+この関数によって要素をn個だけ右にシフトすると、`[first, first + n)`の範囲は、ムーブされたあとの「使用してはいけないオブジェクト」となる。その範囲には、循環バッファ (circular buffer) のように新たな要素を代入するか、コンテナの`erase()`メンバ関数を使用して使わなくなった範囲を削除するなどの対応が必要になる。
+
+
+## 事前条件
+`n &amp;gt;= 0`
+
+
+## 効果
+- `n &amp;lt;= 0`である場合、なにもしない
+- `n &amp;gt;= last - first`である場合、なにもしない
+- `i &amp;lt; (last - first) - n`である非負の各`i`について、`first + i`位置の要素を`first + n + i`位置にムーブする
+    - (1)では、`I`型が[`bidirectional_iterator`](/reference/iterator/bidirectional_iterator.md)のモデルとなる場合は、`i = (last - first) - n - 1`から`i = 0`の順に処理する
+
+
+## 戻り値
+`new_first`を次のように定義する。
+
+- `n &amp;gt; 0`かつ`n &amp;lt; last - first`である場合、`first + n`を返す
+- `n &amp;gt; 0`である場合、`last`を返す
+- いずれでもない場合、`first`を返す
+
+このとき、 `{new_first, last}`
+
+## 計算量
+最大で`(last - first) - n`回の代入もしくはswap操作を行う
+
+
+## 備考
+- シフト数として負数を指定するとなにも起こらないが、この関数には符号付き整数型を指定することとなっている。これは、Bidirectional Iterator向けの最適化した実装をする場合に[`std::prev()`](/reference/iterator/prev.md)関数を使用するため、そちらのパラメータ型と合わせたことによる
+- [`shift_left()`](ranges_shift_left.md)と`shift_right()`で関数が分かれているのは、コンパイルしたコードサイズを小さくするためと、左シフトと右シフトでは最大パフォーマンスのための実装が異なるためである
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  std::ranges::shift_right(v, 2);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39;,&amp;#39;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::shift_right[color ff0000]
+
+### 出力
+```
+1,2,1,2,3,
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+## 参照
+- [N4901 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>