<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-12-16T07:02:22.675098</updated>
  <id>32283f14-cfc9-463c-8095-3dd056b98a1c</id>

  
    <entry>
      <title>is_abstract -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_abstract.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_abstract.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_abstract.md b/reference/type_traits/is_abstract.md
index 12a9965fb..d2b774dc1 100644
--- a/reference/type_traits/is_abstract.md
+++ b/reference/type_traits/is_abstract.md
@@ -51,8 +51,8 @@ static_assert(std::is_same&amp;lt;std::is_abstract&amp;lt;non_abstract_class&amp;gt;::value_type, boo
 static_assert(std::is_same&amp;lt;std::is_abstract&amp;lt;non_abstract_class&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_abstract&amp;lt;non_abstract_class&amp;gt;() == false, &amp;#34;is_abstract&amp;lt;non_abstract_class&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_abstract&amp;lt;const volatile abstract_class&amp;gt;::value == true, &amp;#34;value == true, const volatile abstract_class is abstract&amp;#34;);
-static_assert(std::is_abstract&amp;lt;abstract_class&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, abstract_class&amp;amp; is not abstract&amp;#34;);
+static_assert(std::is_abstract&amp;lt;const volatile abstract_class&amp;gt;::value == true, &amp;#34;const volatile abstract_class is abstract&amp;#34;);
+static_assert(std::is_abstract&amp;lt;abstract_class&amp;amp;&amp;gt;::value == false, &amp;#34;abstract_class&amp;amp; is not abstract&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_const -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_const.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_const.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_const.md b/reference/type_traits/is_const.md
index 8f9d9f79c..4aad67ee4 100644
--- a/reference/type_traits/is_const.md
+++ b/reference/type_traits/is_const.md
@@ -40,8 +40,8 @@ static_assert(std::is_same&amp;lt;std::is_const&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_
 static_assert(std::is_same&amp;lt;std::is_const&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_const&amp;lt;int&amp;gt;() == false, &amp;#34;is_const&amp;lt;int&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_const&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;value == true, const volatile int is const-qualified&amp;#34;);
-static_assert(std::is_const&amp;lt;const int&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, const int&amp;amp; is not const-qualified&amp;#34;);
+static_assert(std::is_const&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;const volatile int is const-qualified&amp;#34;);
+static_assert(std::is_const&amp;lt;const int&amp;amp;&amp;gt;::value == false, &amp;#34;const int&amp;amp; is not const-qualified&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_empty -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_empty.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_empty.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_empty.md b/reference/type_traits/is_empty.md
index 321395e79..ee4aeeb6a 100644
--- a/reference/type_traits/is_empty.md
+++ b/reference/type_traits/is_empty.md
@@ -60,8 +60,8 @@ static_assert(std::is_same&amp;lt;std::is_empty&amp;lt;non_empty_class&amp;gt;::value_type, bool&amp;gt;::va
 static_assert(std::is_same&amp;lt;std::is_empty&amp;lt;non_empty_class&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_empty&amp;lt;non_empty_class&amp;gt;() == false, &amp;#34;is_empty&amp;lt;non_empty_class&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_empty&amp;lt;const volatile empty_class&amp;gt;::value == true, &amp;#34;value == true, const volatile empty_class is empty&amp;#34;);
-static_assert(std::is_empty&amp;lt;empty_class&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, empty_class&amp;amp; is not empty&amp;#34;);
+static_assert(std::is_empty&amp;lt;const volatile empty_class&amp;gt;::value == true, &amp;#34;const volatile empty_class is empty&amp;#34;);
+static_assert(std::is_empty&amp;lt;empty_class&amp;amp;&amp;gt;::value == false, &amp;#34;empty_class&amp;amp; is not empty&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_pod -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_pod.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_pod.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_pod.md b/reference/type_traits/is_pod.md
index c7ae6b1c2..00a11495f 100644
--- a/reference/type_traits/is_pod.md
+++ b/reference/type_traits/is_pod.md
@@ -53,15 +53,15 @@ static_assert(std::is_same&amp;lt;std::is_pod&amp;lt;int&amp;amp;&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;value_t
 static_assert(std::is_same&amp;lt;std::is_pod&amp;lt;int&amp;amp;&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_pod&amp;lt;int&amp;amp;&amp;gt;() == false, &amp;#34;is_pod&amp;lt;int&amp;amp;&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_pod&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;value == true, const volatile int is POD&amp;#34;);
-static_assert(std::is_pod&amp;lt;int&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, int&amp;amp; is not POD&amp;#34;);
+static_assert(std::is_pod&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;const volatile int is POD&amp;#34;);
+static_assert(std::is_pod&amp;lt;int&amp;amp;&amp;gt;::value == false, &amp;#34;int&amp;amp; is not POD&amp;#34;);
 
 struct POD_struct{};
 struct non_POD_struct {
   non_POD_struct() {}    // デフォルトコンストラクタが非トリビアル
 };
-static_assert(std::is_pod&amp;lt;POD_struct&amp;gt;::value == true, &amp;#34;value == true, POD_struct is POD&amp;#34;);
-static_assert(std::is_pod&amp;lt;non_POD_struct&amp;gt;::value == false, &amp;#34;value == true, non_POD_struct is not POD&amp;#34;);
+static_assert(std::is_pod&amp;lt;POD_struct&amp;gt;::value == true, &amp;#34;POD_struct is POD&amp;#34;);
+static_assert(std::is_pod&amp;lt;non_POD_struct&amp;gt;::value == false, &amp;#34;non_POD_struct is not POD&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_polymorphic -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_polymorphic.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_polymorphic.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_polymorphic.md b/reference/type_traits/is_polymorphic.md
index ec55371ca..ff07303a2 100644
--- a/reference/type_traits/is_polymorphic.md
+++ b/reference/type_traits/is_polymorphic.md
@@ -49,8 +49,8 @@ static_assert(std::is_same&amp;lt;std::is_polymorphic&amp;lt;non_polymorphic_class&amp;gt;::value_typ
 static_assert(std::is_same&amp;lt;std::is_polymorphic&amp;lt;non_polymorphic_class&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_polymorphic&amp;lt;non_polymorphic_class&amp;gt;() == false, &amp;#34;is_polymorphic&amp;lt;non_polymorphic_class&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_polymorphic&amp;lt;const volatile polymorphic_class&amp;gt;::value == true, &amp;#34;value == true, const volatile polymorphic_class is polymorphic&amp;#34;);
-static_assert(std::is_polymorphic&amp;lt;polymorphic_class&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, polymorphic_class&amp;amp; is not polymorphic&amp;#34;);
+static_assert(std::is_polymorphic&amp;lt;const volatile polymorphic_class&amp;gt;::value == true, &amp;#34;const volatile polymorphic_class is polymorphic&amp;#34;);
+static_assert(std::is_polymorphic&amp;lt;polymorphic_class&amp;amp;&amp;gt;::value == false, &amp;#34;polymorphic_class&amp;amp; is not polymorphic&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_signed -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_signed.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_signed.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_signed.md b/reference/type_traits/is_signed.md
index d9956efc1..d7165dc7f 100644
--- a/reference/type_traits/is_signed.md
+++ b/reference/type_traits/is_signed.md
@@ -42,12 +42,12 @@ static_assert(std::is_same&amp;lt;std::is_signed&amp;lt;unsigned int&amp;gt;::value_type, bool&amp;gt;::valu
 static_assert(std::is_same&amp;lt;std::is_signed&amp;lt;unsigned int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_signed&amp;lt;unsigned int&amp;gt;() == false, &amp;#34;is_signed&amp;lt;unsigned int&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_signed&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;value == true, const volatile int is signed&amp;#34;);
-static_assert(std::is_signed&amp;lt;int&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, int&amp;amp; is not signed&amp;#34;);
+static_assert(std::is_signed&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;const volatile int is signed&amp;#34;);
+static_assert(std::is_signed&amp;lt;int&amp;amp;&amp;gt;::value == false, &amp;#34;int&amp;amp; is not signed&amp;#34;);
 
 class c{};
-static_assert(std::is_signed&amp;lt;float&amp;gt;::value == true, &amp;#34;value == true, float is signed&amp;#34;);
-static_assert(std::is_signed&amp;lt;c&amp;gt;::value == false, &amp;#34;value == true, class is not signed&amp;#34;);
+static_assert(std::is_signed&amp;lt;float&amp;gt;::value == true, &amp;#34;float is signed&amp;#34;);
+static_assert(std::is_signed&amp;lt;c&amp;gt;::value == false, &amp;#34;class is not signed&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_trivial -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_trivial.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_trivial.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_trivial.md b/reference/type_traits/is_trivial.md
index bc45a88b9..38031617e 100644
--- a/reference/type_traits/is_trivial.md
+++ b/reference/type_traits/is_trivial.md
@@ -44,17 +44,17 @@ static_assert(std::is_same&amp;lt;std::is_trivial&amp;lt;int&amp;amp;&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;val
 static_assert(std::is_same&amp;lt;std::is_trivial&amp;lt;int&amp;amp;&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_trivial&amp;lt;int&amp;amp;&amp;gt;() == false, &amp;#34;is_trivial&amp;lt;int&amp;amp;&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_trivial&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;value == true, const volatile int is trivial&amp;#34;);
-static_assert(std::is_trivial&amp;lt;int&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, int&amp;amp; is not trivial&amp;#34;);
+static_assert(std::is_trivial&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;const volatile int is trivial&amp;#34;);
+static_assert(std::is_trivial&amp;lt;int&amp;amp;&amp;gt;::value == false, &amp;#34;int&amp;amp; is not trivial&amp;#34;);
 
 class trivial_class{};
 struct non_trivial_class {
   non_trivial_class() {}    // デフォルトコンストラクタが非トリビアル
 };
-static_assert(std::is_trivial&amp;lt;trivial_class&amp;gt;::value == true, &amp;#34;value == true, trivial_class is trivial&amp;#34;);
-static_assert(std::is_trivial&amp;lt;trivial_class&amp;amp;&amp;gt;::value == true, &amp;#34;value == true, trivial_class&amp;amp; is trivial&amp;#34;);
-static_assert(std::is_trivial&amp;lt;non_trivial_class&amp;gt;::value == false, &amp;#34;value == true, non_trivial_class is not trivial&amp;#34;);
-static_assert(std::is_trivial&amp;lt;non_trivial_class&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, non_trivial_class&amp;amp; is not trivial&amp;#34;);
+static_assert(std::is_trivial&amp;lt;trivial_class&amp;gt;::value == true, &amp;#34;trivial_class is trivial&amp;#34;);
+static_assert(std::is_trivial&amp;lt;trivial_class&amp;amp;&amp;gt;::value == true, &amp;#34;trivial_class&amp;amp; is trivial&amp;#34;);
+static_assert(std::is_trivial&amp;lt;non_trivial_class&amp;gt;::value == false, &amp;#34;non_trivial_class is not trivial&amp;#34;);
+static_assert(std::is_trivial&amp;lt;non_trivial_class&amp;amp;&amp;gt;::value == false, &amp;#34;non_trivial_class&amp;amp; is not trivial&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_unsigned -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_unsigned.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_unsigned.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_unsigned.md b/reference/type_traits/is_unsigned.md
index c6707d006..5ec14ed1b 100644
--- a/reference/type_traits/is_unsigned.md
+++ b/reference/type_traits/is_unsigned.md
@@ -42,12 +42,12 @@ static_assert(std::is_same&amp;lt;std::is_unsigned&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;val
 static_assert(std::is_same&amp;lt;std::is_unsigned&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_unsigned&amp;lt;int&amp;gt;() == false, &amp;#34;is_unsigned&amp;lt;int&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_unsigned&amp;lt;const volatile unsigned int&amp;gt;::value == true, &amp;#34;value == true, const volatile unsigned int is unsigned&amp;#34;);
-static_assert(std::is_unsigned&amp;lt;unsigned int&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, unsigned int&amp;amp; is not unsigned&amp;#34;);
+static_assert(std::is_unsigned&amp;lt;const volatile unsigned int&amp;gt;::value == true, &amp;#34;const volatile unsigned int is unsigned&amp;#34;);
+static_assert(std::is_unsigned&amp;lt;unsigned int&amp;amp;&amp;gt;::value == false, &amp;#34;unsigned int&amp;amp; is not unsigned&amp;#34;);
 
 class c{};
-static_assert(std::is_unsigned&amp;lt;float&amp;gt;::value == false, &amp;#34;value == true, float is not unsigned&amp;#34;);
-static_assert(std::is_unsigned&amp;lt;c&amp;gt;::value == false, &amp;#34;value == true, class is not unsigned&amp;#34;);
+static_assert(std::is_unsigned&amp;lt;float&amp;gt;::value == false, &amp;#34;float is not unsigned&amp;#34;);
+static_assert(std::is_unsigned&amp;lt;c&amp;gt;::value == false, &amp;#34;class is not unsigned&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_volatile -- Merge pull request #826 from ToruNiina/typo-comment</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_volatile.html"/>
      <id>a29c8404b464ed6d09740ee4ab509c073ffdd3b5:reference/type_traits/is_volatile.md</id>
      <updated>2020-12-16T15:50:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_volatile.md b/reference/type_traits/is_volatile.md
index a595765ea..bb0dfb59c 100644
--- a/reference/type_traits/is_volatile.md
+++ b/reference/type_traits/is_volatile.md
@@ -40,8 +40,8 @@ static_assert(std::is_same&amp;lt;std::is_volatile&amp;lt;int&amp;gt;::value_type, bool&amp;gt;::value, &amp;#34;val
 static_assert(std::is_same&amp;lt;std::is_volatile&amp;lt;int&amp;gt;::type, std::false_type&amp;gt;::value, &amp;#34;type == false_type&amp;#34;);
 static_assert(std::is_volatile&amp;lt;int&amp;gt;() == false, &amp;#34;is_volatile&amp;lt;int&amp;gt;() == false&amp;#34;);
 
-static_assert(std::is_volatile&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;value == true, const volatile int is volatile-qualified&amp;#34;);
-static_assert(std::is_volatile&amp;lt;volatile int&amp;amp;&amp;gt;::value == false, &amp;#34;value == true, volatile int&amp;amp; is not volatile-qualified&amp;#34;);
+static_assert(std::is_volatile&amp;lt;const volatile int&amp;gt;::value == true, &amp;#34;const volatile int is volatile-qualified&amp;#34;);
+static_assert(std::is_volatile&amp;lt;volatile int&amp;amp;&amp;gt;::value == false, &amp;#34;volatile int&amp;amp; is not volatile-qualified&amp;#34;);
 
 int main(){}
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>範囲for文 -- Merge pull request #828 from cpprefjp/range-based-for-patch</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/range_based_for.html"/>
      <id>5245f060891676fea4162fda38a02dedd26e737d:lang/cpp11/range_based_for.md</id>
      <updated>2020-12-16T15:49:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/range_based_for.md b/lang/cpp11/range_based_for.md
index 29d52e3ca..87174efe6 100644
--- a/lang/cpp11/range_based_for.md
+++ b/lang/cpp11/range_based_for.md
@@ -62,8 +62,39 @@ for-range-initializerにはfor文が処理すべき範囲を表す値を書く
 
 C++03のfor文と異なりセミコロンではなくコロンで区切ることに注意する。
 
+範囲for文に配列を範囲として渡したとき、以下のように展開される：
 
-範囲for文に配列以外の型を範囲として渡したとき、以下のように展開される：
+```cpp
+{
+  auto &amp;amp;&amp;amp; __range = range-init;
+
+  for (auto __begin = __range, __end = __range + __bound; __begin != __end; ++__begin) {
+    for-range-declaration = *__begin;
+
+    statement
+  }
+}
+```
+
+* ただし、`__bound`は配列の要素数である。要素数が不明な場合はill-formedである。
+
+範囲の型がクラスであって、メンバ`begin`**または**`end`が存在するとき、以下のように展開される：
+
+```cpp
+{
+  auto &amp;amp;&amp;amp; __range = range-init;
+
+  for (auto __begin = __range.begin(), __end = __range.end(); __begin != __end; ++__begin) {
+    for-range-declaration = *__begin;
+
+    statement
+  }
+}
+```
+
+* メンバ`begin`、`end`が片方しかない場合や、関数ではない場合でもこのように展開されるが、当然エラーとなる。この問題は[C++20で部分的に緩和される](/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md)。
+
+範囲の型が配列でもメンバ`begin`、`end`のいずれかを持つクラスでもないとき、以下のように展開される：
 
 ```cpp
 {
@@ -77,6 +108,8 @@ C++03のfor文と異なりセミコロンではなくコロンで区切ること
 }
 ```
 
+* 展開されたコード内の`begin()`と`end()`が正確に何を呼びだすかについては、引数依存の名前探索（argument-dependent name lookup; ADL）を参照のこと。
+
 従って概要で挙げた例は以下のように展開される：
 
 ```cpp
@@ -89,7 +122,7 @@ for (const auto&amp;amp; e : vec) {
 {
   auto &amp;amp;&amp;amp; __range = vec;
 
-  for (auto __begin = begin(__range), __end = end(__range); __begin != __end; ++__begin) {
+  for (auto __begin = __range.begin(), __end = __range.end(); __begin != __end; ++__begin) {
     const auto&amp;amp; e = *__begin;
 
     std::cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; std::endl;
@@ -97,8 +130,6 @@ for (const auto&amp;amp; e : vec) {
 }
 ```
 
-展開されたコード内の`begin()`と`end()`が正確に何を呼びだすかについては、引数依存の名前探索（argument-dependent name lookup; ADL）を参照のこと。
-
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>counted_iterator -- counted_iterator : 非メンバ-追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator.html"/>
      <id>96e028905e6bff13204885857562950c8a58ec86:reference/iterator/counted_iterator.md</id>
      <updated>2020-12-16T12:31:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator.md b/reference/iterator/counted_iterator.md
index 3a3678404..1bdf1235c 100644
--- a/reference/iterator/counted_iterator.md
+++ b/reference/iterator/counted_iterator.md
@@ -63,7 +63,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |------------------------------------------------------|-------------|-------|
-| [`operator-`](counted_iterator/op_minus.md.nolink)          | 2つの`counted_iterator`の差を求める | C++20 |
+| [`operator-`](counted_iterator/op_minus.md)          | 2つの`counted_iterator`の差を求める | C++20 |
 | [`operator+`](counted_iterator/op_plus.md)           | イテレータを進める | C++20 |
 | [`operator==`](counted_iterator/op_equal.md.nolink)         | 等値比較 | C++20 |
 | `operator!=`     | 非等値比較 (`==`により使用可能) | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator- (非メンバ関数) -- counted_iterator : 非メンバ-追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/op_minus.html"/>
      <id>96e028905e6bff13204885857562950c8a58ec86:reference/iterator/counted_iterator/op_minus.md</id>
      <updated>2020-12-16T12:31:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/op_minus.md b/reference/iterator/counted_iterator/op_minus.md
new file mode 100644
index 000000000..33394a7bf
--- /dev/null
+++ b/reference/iterator/counted_iterator/op_minus.md
@@ -0,0 +1,89 @@
+# operator- (非メンバ関数)
+* iterator[meta header]
+* std[meta namespace]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+template&amp;lt;common_with&amp;lt;I&amp;gt; I2&amp;gt;
+friend constexpr iter_difference_t&amp;lt;I2&amp;gt; operator-(
+  const counted_iterator&amp;amp; x, const counted_iterator&amp;lt;I2&amp;gt;&amp;amp; y);  // (1)
+
+friend constexpr iter_difference_t&amp;lt;I&amp;gt; operator-(
+  const counted_iterator&amp;amp; x, default_sentinel_t);             // (2)
+
+friend constexpr iter_difference_t&amp;lt;I&amp;gt; operator-(
+  default_sentinel_t, const counted_iterator&amp;amp; y);             // (3)
+```
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* default_sentinel_t[link /reference/iterator/default_sentinel_t.md]
+
+## 概要
+
+イテレータ間あるいは番兵との間の距離を求める。
+
+## 事前条件
+
+- (1) : `x, y`はともに同じシーケンス（範囲）についてのイテレータであること。
+
+## 効果
+
+現在のイテレータとカウントの値をそれぞれ、`current`、`length`メンバ変数に保持するとする。
+
+- (1) : `return y.length - x.length;`
+- (2) : `return -x.length;`
+- (3) : `return y.length;`
+
+## 戻り値
+
+左辺のイテレータ（番兵）と右辺のイテレータ（番兵）間の距離。
+
+## 備考
+
+これらの関数は全て[*Hidden friends*](/article/lib/hidden_friends.md)として定義される。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  std::counted_iterator ci{std::ranges::begin(vec), 5};
+  auto ci2 = ci + 3;
+
+  // (1) イテレータ間距離
+  std::cout &amp;lt;&amp;lt; (ci2 - ci) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+  std::cout &amp;lt;&amp;lt; (ci - ci2) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+
+  // (2) 終端からの距離
+  std::cout &amp;lt;&amp;lt; (ci - std::default_sentinel) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+
+  // (3) 終端までの距離
+  std::cout &amp;lt;&amp;lt; (std::default_sentinel - ci) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+}
+```
+* ranges::begin[link /reference/ranges/begin.md.nolink]
+
+### 出力
+```
+3
+-3
+-5
+5
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 9
+
+## 参照
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>counted_iterator -- counted_iterator : 複合代入演算子追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator.html"/>
      <id>e429a19ad588660457c4d44d5a48e6c2e5b47e7a:reference/iterator/counted_iterator.md</id>
      <updated>2020-12-16T12:01:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator.md b/reference/iterator/counted_iterator.md
index 1c905b30d..3a3678404 100644
--- a/reference/iterator/counted_iterator.md
+++ b/reference/iterator/counted_iterator.md
@@ -54,9 +54,9 @@ namespace std {
 | [`operator++`](counted_iterator/op_increment.md)      | イテレータをインクリメントする | C++20 |
 | [`operator--`](counted_iterator/op_decrement.md)      | イテレータをインクリメントする | C++20 |
 | [`operator+`](counted_iterator/op_plus.md)      | イテレータを進める | C++20 |
-| [`operator+=`](counted_iterator/op_plus_assign.md.nolink)    | イテレータ自身を進める | C++20 |
+| [`operator+=`](counted_iterator/op_plus_assign.md)    | イテレータ自身を進める | C++20 |
 | [`operator-`](counted_iterator/op_unary_minus.md)     | イテレータを逆に進める | C++20 |
-| [`operator-=`](counted_iterator/op_minus_assign.md.nolink)   | イテレータ自身を逆に進める | C++20 |
+| [`operator-=`](counted_iterator/op_minus_assign.md)   | イテレータ自身を逆に進める | C++20 |
 | [`operator[]`](counted_iterator/op_at.md)             | 任意の位置にランダムアクセスする | C++20 |
 
 ## 非メンバ（*Hidden friends*）関数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator-= -- counted_iterator : 複合代入演算子追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/op_minus_assign.html"/>
      <id>e429a19ad588660457c4d44d5a48e6c2e5b47e7a:reference/iterator/counted_iterator/op_minus_assign.md</id>
      <updated>2020-12-16T12:01:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/op_minus_assign.md b/reference/iterator/counted_iterator/op_minus_assign.md
new file mode 100644
index 000000000..6858aa93d
--- /dev/null
+++ b/reference/iterator/counted_iterator/op_minus_assign.md
@@ -0,0 +1,72 @@
+# operator-=
+* iterator[meta header]
+* std[meta namespace]
+* counted_iterator[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+constexpr counted_iterator&amp;amp; operator-=(iter_difference_t&amp;lt;I&amp;gt; n) requires random_access_iterator&amp;lt;I&amp;gt;;
+```
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+
+
+## 概要
+
+イテレータ自身を`n`回逆に進める。
+
+## 事前条件
+
+現在のカウントの値を`length`メンバ変数に保持するとして、`n &amp;lt;= length`
+
+## 効果
+
+現在のイテレータとカウントの値をそれぞれ、`current`、`length`メンバ変数に保持するとして、以下と等価
+
+```cpp
+current -= n;
+length += n;
+return *this;
+```
+
+## 戻り値
+
+`*this`
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  std::counted_iterator ci{std::ranges::begin(vec), 5};
+  ci += 5;
+
+  ci -= 2;
+
+  std::cout &amp;lt;&amp;lt; *ci &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+}
+```
+* ranges::begin[link /reference/ranges/begin.md.nolink]
+
+### 出力
+```
+5
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 9
+
+## 参照
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+= -- counted_iterator : 複合代入演算子追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator/op_plus_assign.html"/>
      <id>e429a19ad588660457c4d44d5a48e6c2e5b47e7a:reference/iterator/counted_iterator/op_plus_assign.md</id>
      <updated>2020-12-16T12:01:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator/op_plus_assign.md b/reference/iterator/counted_iterator/op_plus_assign.md
new file mode 100644
index 000000000..65f916d4f
--- /dev/null
+++ b/reference/iterator/counted_iterator/op_plus_assign.md
@@ -0,0 +1,71 @@
+# operator+=
+* iterator[meta header]
+* std[meta namespace]
+* counted_iterator[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+constexpr counted_iterator&amp;amp; operator+=(iter_difference_t&amp;lt;I&amp;gt; n) requires random_access_iterator&amp;lt;I&amp;gt;;
+```
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* random_access_iterator[link /reference/iterator/random_access_iterator.md]
+
+
+## 概要
+
+イテレータ自身を`n`回進める。
+
+## 事前条件
+
+現在のカウントの値を`length`メンバ変数に保持するとして、`n &amp;lt;= length`
+
+## 効果
+
+現在のイテレータとカウントの値をそれぞれ、`current`、`length`メンバ変数に保持するとして、以下と等価
+
+```cpp
+current += n;
+length -= n;
+return *this;
+```
+
+## 戻り値
+
+`*this`
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  std::counted_iterator ci{std::ranges::begin(vec), 5};
+
+  ci += 3;
+
+  std::cout &amp;lt;&amp;lt; *ci &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+}
+```
+* ranges::begin[link /reference/ranges/begin.md.nolink]
+
+### 出力
+```
+4
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 9
+
+## 参照
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>範囲for文 -- Update range_based_for.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/range_based_for.html"/>
      <id>e0a8bdd708dce463ecc4b874f74a0296adbd7f65:lang/cpp11/range_based_for.md</id>
      <updated>2020-12-16T06:43:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/range_based_for.md b/lang/cpp11/range_based_for.md
index 29d52e3ca..87174efe6 100644
--- a/lang/cpp11/range_based_for.md
+++ b/lang/cpp11/range_based_for.md
@@ -62,8 +62,39 @@ for-range-initializerにはfor文が処理すべき範囲を表す値を書く
 
 C++03のfor文と異なりセミコロンではなくコロンで区切ることに注意する。
 
+範囲for文に配列を範囲として渡したとき、以下のように展開される：
 
-範囲for文に配列以外の型を範囲として渡したとき、以下のように展開される：
+```cpp
+{
+  auto &amp;amp;&amp;amp; __range = range-init;
+
+  for (auto __begin = __range, __end = __range + __bound; __begin != __end; ++__begin) {
+    for-range-declaration = *__begin;
+
+    statement
+  }
+}
+```
+
+* ただし、`__bound`は配列の要素数である。要素数が不明な場合はill-formedである。
+
+範囲の型がクラスであって、メンバ`begin`**または**`end`が存在するとき、以下のように展開される：
+
+```cpp
+{
+  auto &amp;amp;&amp;amp; __range = range-init;
+
+  for (auto __begin = __range.begin(), __end = __range.end(); __begin != __end; ++__begin) {
+    for-range-declaration = *__begin;
+
+    statement
+  }
+}
+```
+
+* メンバ`begin`、`end`が片方しかない場合や、関数ではない場合でもこのように展開されるが、当然エラーとなる。この問題は[C++20で部分的に緩和される](/lang/cpp20/relaxing_the_range_for_loop_customization_point_finding_rules.md)。
+
+範囲の型が配列でもメンバ`begin`、`end`のいずれかを持つクラスでもないとき、以下のように展開される：
 
 ```cpp
 {
@@ -77,6 +108,8 @@ C++03のfor文と異なりセミコロンではなくコロンで区切ること
 }
 ```
 
+* 展開されたコード内の`begin()`と`end()`が正確に何を呼びだすかについては、引数依存の名前探索（argument-dependent name lookup; ADL）を参照のこと。
+
 従って概要で挙げた例は以下のように展開される：
 
 ```cpp
@@ -89,7 +122,7 @@ for (const auto&amp;amp; e : vec) {
 {
   auto &amp;amp;&amp;amp; __range = vec;
 
-  for (auto __begin = begin(__range), __end = end(__range); __begin != __end; ++__begin) {
+  for (auto __begin = __range.begin(), __end = __range.end(); __begin != __end; ++__begin) {
     const auto&amp;amp; e = *__begin;
 
     std::cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; std::endl;
@@ -97,8 +130,6 @@ for (const auto&amp;amp; e : vec) {
 }
 ```
 
-展開されたコード内の`begin()`と`end()`が正確に何を呼びだすかについては、引数依存の名前探索（argument-dependent name lookup; ADL）を参照のこと。
-
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>