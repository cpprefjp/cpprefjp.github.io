<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-07-06T14:35:30.973584</updated>
  <id>05fd2480-b017-456d-b732-be81d9213a8c</id>

  
    <entry>
      <title>一貫比較 -- cpp20/一貫比較: P1959による{weak,strong}_equality削除を明記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html"/>
      <id>aa7a3daf3d4acc085c9d254d0e4c8e9aa8ad333a:lang/cpp20/consistent_comparison.md</id>
      <updated>2020-07-06T22:50:12+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/consistent_comparison.md b/lang/cpp20/consistent_comparison.md
index b5ec41b3a..1dab324d4 100644
--- a/lang/cpp20/consistent_comparison.md
+++ b/lang/cpp20/consistent_comparison.md
@@ -88,7 +88,7 @@ bool is_equal = comp == 0.0;
 三方比較演算子の戻り値型は`int`などの整数型ではなく、比較カテゴリ型と呼ばれる専用の型である。  
 これは、比較対象となる型の満たしている同値や順序の関係についてを専用の型によって表明し、コンセプト等の機構によってその性質に応じた適切な処理へのディスパッチを行うことを出来るようにするためである（例えば、以下で述べる比較カテゴリ型によって導出する演算子を変化させるのに利用されている）。
 
-以下の5つの比較カテゴリ型が提供される。
+以下の3つの比較カテゴリ型が提供される。
 
 |比較カテゴリ型|対応する数学的な関係|導出される演算子|
 |:---|:---:|:---:|
@@ -108,7 +108,7 @@ bool is_equal = comp == 0.0;
 各比較カテゴリ型はその条件の強いものから弱いものへの暗黙変換が定義される。この方向は各カテゴリに対応する数学的な関係の包含関係によって定義されている。  
 
 ![]( https://raw.githubusercontent.com/cpprefjp/image/master/lang/cpp20/consistent_comparison_01.png)  
-図1 比較カテゴリ間の変換関係（[P0515R3](http://wg21.link/p0515)より引用）
+図1 比較カテゴリ間の変換関係（[P0515R3](http://wg21.link/p0515)より引用； 最終的なC++20仕様では`weak_equality`/`strong_equality`は[削除されている](http://wg21.link/p1959)）
 
 
 これはつまり、各比較カテゴリ間の順序関係を示している。この順序は半順序となる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++17 -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/lang/cpp17.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:lang/cpp17.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17.md b/lang/cpp17.md
index 001b7d0db..d72dcc2f8 100644
--- a/lang/cpp17.md
+++ b/lang/cpp17.md
@@ -181,7 +181,7 @@ C++17以降、言語の策定にship train modelというリリース体制が
     - 値を変換しながら部分和を求める関数として、[`transform_inclusive_scan()`](/reference/numeric/transform_inclusive_scan.md)と[`transform_exclusive_scan()`](/reference/numeric/transform_exclusive_scan.md)を追加
 - 値を範囲内に収める[`clamp()`](/reference/algorithm/clamp.md)関数を追加
 - `bool`を返す関数オブジェクトの結果を反転させる[`not_fn()`](/reference/functional/not_fn.md)関数を追加
-- [*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った関数呼び出しをする[`invoke()`](/reference/functional/invoke.md)関数を追加
+- [*INVOKE*](/reference/concepts/Invoke.md)要件に従った関数呼び出しをする[`invoke()`](/reference/functional/invoke.md)関数を追加
 - [`reference_wrapper`](/reference/functional/reference_wrapper.md)がTriviallyCopyableであることを保証
 - オブジェクトを`const`にする[`as_const()`](/reference/utility/as_const.md)関数を追加
 - 未初期化メモリのアルゴリズムと、デストラクタ呼び出しの関数として、以下の関数を追加： [`destroy_at()`](/reference/memory/destroy_at.md), [`destroy()`](/reference/memory/destroy.md), [`destroy_n()`](/reference/memory/destroy_n.md), [`uninitialized_move()`](/reference/memory/uninitialized_move.md), [`uninitialized_move_n()`](/reference/memory/uninitialized_move_n.md), [`uninitialized_value_construct()`](/reference/memory/uninitialized_value_construct.md), [`uninitialized_value_construct_n()`](/reference/memory/uninitialized_value_construct_n.md), [`uninitialized_default_construct()`](/reference/memory/uninitialized_default_construct.md), [`uninitialized_default_construct_n()`](/reference/memory/uninitialized_default_construct_n.md)
@@ -264,7 +264,7 @@ C++17以降、言語の策定にship train modelというリリース体制が
 
 ### 乱数
 - ランダムサンプリングアルゴリズムとして、[`sample()`](/reference/algorithm/sample.md)を追加
-- 乱数用語を変更。乱数生成器のコンセプトに 「URNG (Uniform Random Number Generator, 一様乱数生成器)」という用語を使用していたが、一般的なURNGの用語とは異なり、C++の乱数生成器は一度の呼び出しで、(32ビットを超えるような) より多くのビットを単一の符号なし整数にパックして返すという動作が許可されている。動作の誤解を避けるために、「URBG (Uniform Random Bit Generator)」という用語に変更する
+- 乱数用語を変更。乱数生成器の要件に 「URNG (Uniform Random Number Generator, 一様乱数生成器)」という用語を使用していたが、一般的なURNGの用語とは異なり、C++の乱数生成器は一度の呼び出しで、(32ビットを超えるような) より多くのビットを単一の符号なし整数にパックして返すという動作が許可されている。動作の誤解を避けるために、「URBG (Uniform Random Bit Generator)」という用語に変更する
 
 
 ### エラーハンドリング
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:reference/algorithm.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 08d465e70..48ecfd9c5 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -161,7 +161,7 @@ return distance(a, b);
   これにより、例えばソートされていない整数列 `[5, 1, 25, 13, 17]` に対しても `10` をキーとして [`lower_bound()`](algorithm/lower_bound.md) を用いることにより `10` より小さい範囲の境界を取り出すことが可能になっている。しかし `15` をキーとすることは不正である。  
   ただ、 C++03 の要件に合わない（特にソートされていない範囲に対する）二分探索を行いたい場合は、同じく C++11 で追加された [`partition_point()`](algorithm/partition_point.md) の使用も検討したほうがよい。  
 
-順序関係を扱う関数の説明において、この節では安定性 (stability) のようなコンセプトを説明するために同値性 (equivalence) の概念を頻繁に使う。  
+順序関係を扱う関数の説明において、この節では安定性 (stability) のような考え方を説明するために同値性 (equivalence) の概念を頻繁に使う。
 この節で参照する同値性は必ずしも `operator==` ではなく、[狭義の弱順序](/reference/algorithm.md#strict-weak-ordering)によって示される同値関係である。つまりそれは、２つの要素 `a` と `b` は `!(a &amp;lt; b) &amp;amp;&amp;amp; !(b &amp;lt; a)` の時かつその時に限り同値とみなされるということである。  
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>functional -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/reference/functional.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:reference/functional.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional.md b/reference/functional.md
index 6e2a12ff2..5dc8cd46f 100644
--- a/reference/functional.md
+++ b/reference/functional.md
@@ -163,7 +163,7 @@ struct doubler {
 | `bind2nd` | 第2引数を部分適用する関数オブジェクト(function template) | C++11から非推奨&amp;lt;br/&amp;gt; C++17で削除 |
 
 
-## コンセプト
+## 名前付き要件
 
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------|--------------------------|-------|
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>invoke -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/reference/functional/invoke.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:reference/functional/invoke.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/invoke.md b/reference/functional/invoke.md
index e34684237..5a4806653 100644
--- a/reference/functional/invoke.md
+++ b/reference/functional/invoke.md
@@ -19,19 +19,19 @@ namespace std {
 * is_nothrow_invocable_v[link /reference/type_traits/is_nothrow_invocable.md]
 
 ## 概要
-関数呼び出し可能なオブジェクト`f`とその引数`args...`の組み合わせで[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った関数呼び出しを行う。
+関数呼び出し可能なオブジェクト`f`とその引数`args...`の組み合わせで[*INVOKE*](/reference/concepts/Invoke.md)要件に従った関数呼び出しを行う。
 
-[*INVOKE*](/reference/concepts/Invoke.md)コンセプトとはC++における関数呼び出しという性質を抽象化しまとめた概念（コンセプト）であり、この関数はその実体化、すなわち関数呼び出しという操作を統一したものである。
+[*INVOKE*](/reference/concepts/Invoke.md)要件とはC++における関数呼び出しという性質を抽象化しまとめた概念であり、`invoke`はその実体化、すなわち関数呼び出しという操作を統一したものである。
 
 ## 要件
-型`F`および`Args`の組み合わせで[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った関数呼び出しが可能であり、オーバーロード解決の結果が曖昧にならないこと。そうでない場合はコンパイルエラーとなる。
+型`F`および`Args...`の組み合わせで[*INVOKE*](/reference/concepts/Invoke.md)要件に従った関数呼び出しが可能であり、オーバーロード解決の結果が曖昧にならないこと。そうでない場合はコンパイルエラーとなる。
 
 ## 引数
 - `f` -- [*Callable*](/reference/concepts/Callable.md) オブジェクト（関数ポインタ/参照・関数オブジェクト・メンバポインタ）
 - `args...` -- `f`に与える引数列。`f`がメンバポインタである場合は対応するクラスのオブジェクト（もしくはその[reference_wrapper](reference_wrapper.md)）が`args...`の先頭になければならない
 
 ## 戻り値
-`f`と`args...`により[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った関数呼び出しを行い、その結果を戻り値として返す。
+`f`と`args...`により[*INVOKE*](/reference/concepts/Invoke.md)要件に従った関数呼び出しを行い、その結果を戻り値として返す。
 
 ## 例外
 `f`の`args...`による関数呼び出しに際して例外を投げない（[`is_nothrow_invocable_v&amp;lt;F, Args...&amp;gt;`](/reference/type_traits/is_nothrow_invocable.md) ` == true`）ならば、この関数も例外を投げない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>invoke_result -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/invoke_result.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:reference/type_traits/invoke_result.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/invoke_result.md b/reference/type_traits/invoke_result.md
index d7fcc9791..7a0b6ada5 100644
--- a/reference/type_traits/invoke_result.md
+++ b/reference/type_traits/invoke_result.md
@@ -23,7 +23,7 @@ namespace std {
 
 
 ## 効果
-[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しの結果（戻り値）となる型をメンバ型`type`として定義する。そのような呼び出しが出来ない（ill-formedな）場合、メンバ型`type`は定義されない。
+[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しの結果（戻り値）となる型をメンバ型`type`として定義する。そのような呼び出しが出来ない（ill-formedな）場合、メンバ型`type`は定義されない。
 
 すなわち、関数呼び出し出来ない型と引数列の組み合わせが渡された場合、SFINAEが働く。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_invocable -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_invocable.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:reference/type_traits/is_invocable.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_invocable.md b/reference/type_traits/is_invocable.md
index f6a03757e..fec8f8729 100644
--- a/reference/type_traits/is_invocable.md
+++ b/reference/type_traits/is_invocable.md
@@ -23,7 +23,7 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しが可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 結果が`true`となる場合、以下のような呼び出しが可能であるということと等価である：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_invocable_r -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_invocable_r.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:reference/type_traits/is_invocable_r.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_invocable_r.md b/reference/type_traits/is_invocable_r.md
index fce88da0d..c207f4fcb 100644
--- a/reference/type_traits/is_invocable_r.md
+++ b/reference/type_traits/is_invocable_r.md
@@ -23,7 +23,7 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 結果は以下と等価である：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_nothrow_invocable -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_nothrow_invocable.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:reference/type_traits/is_nothrow_invocable.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_nothrow_invocable.md b/reference/type_traits/is_nothrow_invocable.md
index d653065b3..956266de9 100644
--- a/reference/type_traits/is_nothrow_invocable.md
+++ b/reference/type_traits/is_nothrow_invocable.md
@@ -24,7 +24,7 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しが可能であり、いかなる例外も投げない場合[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、いかなる例外も投げない場合[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_nothrow_invocable_r -- Merge pull request #784 from cpprefjp/term-concept</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_nothrow_invocable_r.html"/>
      <id>7fd8a11f68330c6a910e140015e885f08719fc02:reference/type_traits/is_nothrow_invocable_r.md</id>
      <updated>2020-07-06T18:07:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_nothrow_invocable_r.md b/reference/type_traits/is_nothrow_invocable_r.md
index 41d03abc3..765cf26eb 100644
--- a/reference/type_traits/is_nothrow_invocable_r.md
+++ b/reference/type_traits/is_nothrow_invocable_r.md
@@ -24,7 +24,7 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能かつ、その呼び出し及び変換に際していかなる例外も投げない場合[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能かつ、その呼び出し及び変換に際していかなる例外も投げない場合[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>identity -- identity : 間違いを訂正</title>
      <link href="https://cpprefjp.github.io/reference/functional/identity.html"/>
      <id>8df7318f93b91bad28d2110b2782d213f847c17c:reference/functional/identity.md</id>
      <updated>2020-07-06T16:45:23+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/identity.md b/reference/functional/identity.md
index 6433181f6..d30aecd8c 100644
--- a/reference/functional/identity.md
+++ b/reference/functional/identity.md
@@ -35,7 +35,7 @@ namespace std {
 
 | 名前                   | 説明                                                                                                                                                       | 対応バージョン |
 |------------------------|--------------------------------|----------------|
-| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。（`T` が `void` の場合のみ） | C++20          |
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。| C++20          |
 
 ## 備考
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++17 -- 用語整理: C++20 Conceptsを意味しない&#34;コンセプト&#34;から表現変更</title>
      <link href="https://cpprefjp.github.io/lang/cpp17.html"/>
      <id>f29da42d902c3a17436f931918b8c4ea6e7e7513:lang/cpp17.md</id>
      <updated>2020-07-06T15:00:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17.md b/lang/cpp17.md
index 34e44ae60..d72dcc2f8 100644
--- a/lang/cpp17.md
+++ b/lang/cpp17.md
@@ -264,7 +264,7 @@ C++17以降、言語の策定にship train modelというリリース体制が
 
 ### 乱数
 - ランダムサンプリングアルゴリズムとして、[`sample()`](/reference/algorithm/sample.md)を追加
-- 乱数用語を変更。乱数生成器のコンセプトに 「URNG (Uniform Random Number Generator, 一様乱数生成器)」という用語を使用していたが、一般的なURNGの用語とは異なり、C++の乱数生成器は一度の呼び出しで、(32ビットを超えるような) より多くのビットを単一の符号なし整数にパックして返すという動作が許可されている。動作の誤解を避けるために、「URBG (Uniform Random Bit Generator)」という用語に変更する
+- 乱数用語を変更。乱数生成器の要件に 「URNG (Uniform Random Number Generator, 一様乱数生成器)」という用語を使用していたが、一般的なURNGの用語とは異なり、C++の乱数生成器は一度の呼び出しで、(32ビットを超えるような) より多くのビットを単一の符号なし整数にパックして返すという動作が許可されている。動作の誤解を避けるために、「URBG (Uniform Random Bit Generator)」という用語に変更する
 
 
 ### エラーハンドリング
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- 用語整理: C++20 Conceptsを意味しない&#34;コンセプト&#34;から表現変更</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>f29da42d902c3a17436f931918b8c4ea6e7e7513:reference/algorithm.md</id>
      <updated>2020-07-06T15:00:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 08d465e70..48ecfd9c5 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -161,7 +161,7 @@ return distance(a, b);
   これにより、例えばソートされていない整数列 `[5, 1, 25, 13, 17]` に対しても `10` をキーとして [`lower_bound()`](algorithm/lower_bound.md) を用いることにより `10` より小さい範囲の境界を取り出すことが可能になっている。しかし `15` をキーとすることは不正である。  
   ただ、 C++03 の要件に合わない（特にソートされていない範囲に対する）二分探索を行いたい場合は、同じく C++11 で追加された [`partition_point()`](algorithm/partition_point.md) の使用も検討したほうがよい。  
 
-順序関係を扱う関数の説明において、この節では安定性 (stability) のようなコンセプトを説明するために同値性 (equivalence) の概念を頻繁に使う。  
+順序関係を扱う関数の説明において、この節では安定性 (stability) のような考え方を説明するために同値性 (equivalence) の概念を頻繁に使う。
 この節で参照する同値性は必ずしも `operator==` ではなく、[狭義の弱順序](/reference/algorithm.md#strict-weak-ordering)によって示される同値関係である。つまりそれは、２つの要素 `a` と `b` は `!(a &amp;lt; b) &amp;amp;&amp;amp; !(b &amp;lt; a)` の時かつその時に限り同値とみなされるということである。  
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>functional -- 用語整理: C++20 Conceptsを意味しない&#34;コンセプト&#34;から表現変更</title>
      <link href="https://cpprefjp.github.io/reference/functional.html"/>
      <id>f29da42d902c3a17436f931918b8c4ea6e7e7513:reference/functional.md</id>
      <updated>2020-07-06T15:00:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional.md b/reference/functional.md
index 6e2a12ff2..5dc8cd46f 100644
--- a/reference/functional.md
+++ b/reference/functional.md
@@ -163,7 +163,7 @@ struct doubler {
 | `bind2nd` | 第2引数を部分適用する関数オブジェクト(function template) | C++11から非推奨&amp;lt;br/&amp;gt; C++17で削除 |
 
 
-## コンセプト
+## 名前付き要件
 
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------|--------------------------|-------|
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++17 -- 用語整理: s/INVOKEコンセプト/INVOKE要件/</title>
      <link href="https://cpprefjp.github.io/lang/cpp17.html"/>
      <id>106ff07f375bd1b0750fa4818eb16860572f437c:lang/cpp17.md</id>
      <updated>2020-07-06T14:44:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17.md b/lang/cpp17.md
index 001b7d0db..34e44ae60 100644
--- a/lang/cpp17.md
+++ b/lang/cpp17.md
@@ -181,7 +181,7 @@ C++17以降、言語の策定にship train modelというリリース体制が
     - 値を変換しながら部分和を求める関数として、[`transform_inclusive_scan()`](/reference/numeric/transform_inclusive_scan.md)と[`transform_exclusive_scan()`](/reference/numeric/transform_exclusive_scan.md)を追加
 - 値を範囲内に収める[`clamp()`](/reference/algorithm/clamp.md)関数を追加
 - `bool`を返す関数オブジェクトの結果を反転させる[`not_fn()`](/reference/functional/not_fn.md)関数を追加
-- [*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った関数呼び出しをする[`invoke()`](/reference/functional/invoke.md)関数を追加
+- [*INVOKE*](/reference/concepts/Invoke.md)要件に従った関数呼び出しをする[`invoke()`](/reference/functional/invoke.md)関数を追加
 - [`reference_wrapper`](/reference/functional/reference_wrapper.md)がTriviallyCopyableであることを保証
 - オブジェクトを`const`にする[`as_const()`](/reference/utility/as_const.md)関数を追加
 - 未初期化メモリのアルゴリズムと、デストラクタ呼び出しの関数として、以下の関数を追加： [`destroy_at()`](/reference/memory/destroy_at.md), [`destroy()`](/reference/memory/destroy.md), [`destroy_n()`](/reference/memory/destroy_n.md), [`uninitialized_move()`](/reference/memory/uninitialized_move.md), [`uninitialized_move_n()`](/reference/memory/uninitialized_move_n.md), [`uninitialized_value_construct()`](/reference/memory/uninitialized_value_construct.md), [`uninitialized_value_construct_n()`](/reference/memory/uninitialized_value_construct_n.md), [`uninitialized_default_construct()`](/reference/memory/uninitialized_default_construct.md), [`uninitialized_default_construct_n()`](/reference/memory/uninitialized_default_construct_n.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>invoke -- 用語整理: s/INVOKEコンセプト/INVOKE要件/</title>
      <link href="https://cpprefjp.github.io/reference/functional/invoke.html"/>
      <id>106ff07f375bd1b0750fa4818eb16860572f437c:reference/functional/invoke.md</id>
      <updated>2020-07-06T14:44:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/invoke.md b/reference/functional/invoke.md
index e34684237..5a4806653 100644
--- a/reference/functional/invoke.md
+++ b/reference/functional/invoke.md
@@ -19,19 +19,19 @@ namespace std {
 * is_nothrow_invocable_v[link /reference/type_traits/is_nothrow_invocable.md]
 
 ## 概要
-関数呼び出し可能なオブジェクト`f`とその引数`args...`の組み合わせで[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った関数呼び出しを行う。
+関数呼び出し可能なオブジェクト`f`とその引数`args...`の組み合わせで[*INVOKE*](/reference/concepts/Invoke.md)要件に従った関数呼び出しを行う。
 
-[*INVOKE*](/reference/concepts/Invoke.md)コンセプトとはC++における関数呼び出しという性質を抽象化しまとめた概念（コンセプト）であり、この関数はその実体化、すなわち関数呼び出しという操作を統一したものである。
+[*INVOKE*](/reference/concepts/Invoke.md)要件とはC++における関数呼び出しという性質を抽象化しまとめた概念であり、`invoke`はその実体化、すなわち関数呼び出しという操作を統一したものである。
 
 ## 要件
-型`F`および`Args`の組み合わせで[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った関数呼び出しが可能であり、オーバーロード解決の結果が曖昧にならないこと。そうでない場合はコンパイルエラーとなる。
+型`F`および`Args...`の組み合わせで[*INVOKE*](/reference/concepts/Invoke.md)要件に従った関数呼び出しが可能であり、オーバーロード解決の結果が曖昧にならないこと。そうでない場合はコンパイルエラーとなる。
 
 ## 引数
 - `f` -- [*Callable*](/reference/concepts/Callable.md) オブジェクト（関数ポインタ/参照・関数オブジェクト・メンバポインタ）
 - `args...` -- `f`に与える引数列。`f`がメンバポインタである場合は対応するクラスのオブジェクト（もしくはその[reference_wrapper](reference_wrapper.md)）が`args...`の先頭になければならない
 
 ## 戻り値
-`f`と`args...`により[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った関数呼び出しを行い、その結果を戻り値として返す。
+`f`と`args...`により[*INVOKE*](/reference/concepts/Invoke.md)要件に従った関数呼び出しを行い、その結果を戻り値として返す。
 
 ## 例外
 `f`の`args...`による関数呼び出しに際して例外を投げない（[`is_nothrow_invocable_v&amp;lt;F, Args...&amp;gt;`](/reference/type_traits/is_nothrow_invocable.md) ` == true`）ならば、この関数も例外を投げない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>invoke_result -- 用語整理: s/INVOKEコンセプト/INVOKE要件/</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/invoke_result.html"/>
      <id>106ff07f375bd1b0750fa4818eb16860572f437c:reference/type_traits/invoke_result.md</id>
      <updated>2020-07-06T14:44:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/invoke_result.md b/reference/type_traits/invoke_result.md
index d7fcc9791..7a0b6ada5 100644
--- a/reference/type_traits/invoke_result.md
+++ b/reference/type_traits/invoke_result.md
@@ -23,7 +23,7 @@ namespace std {
 
 
 ## 効果
-[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しの結果（戻り値）となる型をメンバ型`type`として定義する。そのような呼び出しが出来ない（ill-formedな）場合、メンバ型`type`は定義されない。
+[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しの結果（戻り値）となる型をメンバ型`type`として定義する。そのような呼び出しが出来ない（ill-formedな）場合、メンバ型`type`は定義されない。
 
 すなわち、関数呼び出し出来ない型と引数列の組み合わせが渡された場合、SFINAEが働く。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_invocable -- 用語整理: s/INVOKEコンセプト/INVOKE要件/</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_invocable.html"/>
      <id>106ff07f375bd1b0750fa4818eb16860572f437c:reference/type_traits/is_invocable.md</id>
      <updated>2020-07-06T14:44:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_invocable.md b/reference/type_traits/is_invocable.md
index f6a03757e..fec8f8729 100644
--- a/reference/type_traits/is_invocable.md
+++ b/reference/type_traits/is_invocable.md
@@ -23,7 +23,7 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しが可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 結果が`true`となる場合、以下のような呼び出しが可能であるということと等価である：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_invocable_r -- 用語整理: s/INVOKEコンセプト/INVOKE要件/</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_invocable_r.html"/>
      <id>106ff07f375bd1b0750fa4818eb16860572f437c:reference/type_traits/is_invocable_r.md</id>
      <updated>2020-07-06T14:44:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_invocable_r.md b/reference/type_traits/is_invocable_r.md
index fce88da0d..c207f4fcb 100644
--- a/reference/type_traits/is_invocable_r.md
+++ b/reference/type_traits/is_invocable_r.md
@@ -23,7 +23,7 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能であれば[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 結果は以下と等価である：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_nothrow_invocable -- 用語整理: s/INVOKEコンセプト/INVOKE要件/</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_nothrow_invocable.html"/>
      <id>106ff07f375bd1b0750fa4818eb16860572f437c:reference/type_traits/is_nothrow_invocable.md</id>
      <updated>2020-07-06T14:44:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_nothrow_invocable.md b/reference/type_traits/is_nothrow_invocable.md
index d653065b3..956266de9 100644
--- a/reference/type_traits/is_nothrow_invocable.md
+++ b/reference/type_traits/is_nothrow_invocable.md
@@ -24,7 +24,7 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しが可能であり、いかなる例外も投げない場合[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、いかなる例外も投げない場合[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_nothrow_invocable_r -- 用語整理: s/INVOKEコンセプト/INVOKE要件/</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_nothrow_invocable_r.html"/>
      <id>106ff07f375bd1b0750fa4818eb16860572f437c:reference/type_traits/is_nothrow_invocable_r.md</id>
      <updated>2020-07-06T14:44:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_nothrow_invocable_r.md b/reference/type_traits/is_nothrow_invocable_r.md
index 41d03abc3..765cf26eb 100644
--- a/reference/type_traits/is_nothrow_invocable_r.md
+++ b/reference/type_traits/is_nothrow_invocable_r.md
@@ -24,7 +24,7 @@ namespace std {
 
 
 ## 効果
-型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)コンセプトに従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能かつ、その呼び出し及び変換に際していかなる例外も投げない場合[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
+型`F`に対して引数`ArgsTypes...`による[*INVOKE*](/reference/concepts/Invoke.md)要件に従った呼び出しが可能であり、その結果となる戻り値の型が`R`に変換可能かつ、その呼び出し及び変換に際していかなる例外も投げない場合[`true_type`](true_type.md)から派生し、そうでなければ[`false_type`](false_type.md)から派生する。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>