<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-06-25T08:38:54.128261</updated>
  <id>7c67096e-3224-441d-aa70-f91a4c8eee84</id>

  
    <entry>
      <title>de-ice -- span,mdspan: C++26 P3029R1対応</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/de-ice.html"/>
      <id>17c594a2e02c0f17280415486fc4491812ca4e0c:reference/mdspan/de-ice.md</id>
      <updated>2024-06-25T17:35:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/de-ice.md b/reference/mdspan/de-ice.md
index b2f611d27..9d555cf63 100644
--- a/reference/mdspan/de-ice.md
+++ b/reference/mdspan/de-ice.md
@@ -10,7 +10,7 @@ constexpr T de-ice(T val) { return val; }
 template&amp;lt;integral-constant-like T&amp;gt;
 constexpr auto de-ice(T) { return T::value; }
 ```
-* integral-constant-like[link integral-constant-like.md]
+* integral-constant-like[link /reference/span/integral-constant-like.md]
 
 ## 概要
 `de-ice`は[`submdspan`](submdspan.md)動作説明用の関数テンプレートである。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- span,mdspan: C++26 P3029R1対応</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/mdspan/op_deduction_guide.html"/>
      <id>17c594a2e02c0f17280415486fc4491812ca4e0c:reference/mdspan/mdspan/op_deduction_guide.md</id>
      <updated>2024-06-25T17:35:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/mdspan/op_deduction_guide.md b/reference/mdspan/mdspan/op_deduction_guide.md
index 9cc9bff94..5e84cc0b6 100644
--- a/reference/mdspan/mdspan/op_deduction_guide.md
+++ b/reference/mdspan/mdspan/op_deduction_guide.md
@@ -19,7 +19,7 @@ namespace std {
   template&amp;lt;class ElementType, class... Integrals&amp;gt;
     requires ((is_convertible_v&amp;lt;Integrals, size_t&amp;gt; &amp;amp;&amp;amp; ...) &amp;amp;&amp;amp; sizeof...(Integrals) &amp;gt; 0)
     explicit mdspan(ElementType*, Integrals...)
-      -&amp;gt; mdspan&amp;lt;ElementType, dextents&amp;lt;size_t, sizeof...(Integrals)&amp;gt;&amp;gt;;  // (3)
+      -&amp;gt; mdspan&amp;lt;ElementType, extents&amp;lt;size_t, maybe-static-ext&amp;lt;Integrals&amp;gt;...&amp;gt;&amp;gt;;  // (3)
 
   template&amp;lt;class ElementType, class OtherIndexType, size_t N&amp;gt;
     mdspan(ElementType*, span&amp;lt;OtherIndexType, N&amp;gt;)
@@ -52,6 +52,7 @@ namespace std {
 * extents[link ../extents.md]
 * dextents[link ../extents.md]
 * span[link /reference/span/span.md]
+* maybe-static-ext[link /reference/span/maybe-static-ext.md]
 * array[link /reference/array/array.md]
 * is_array_v[link /reference/type_traits/is_array.md]
 * is_pointer_v[link /reference/type_traits/is_pointer.md]
@@ -76,6 +77,10 @@ namespace std {
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;span&amp;gt;
 #include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+
+template &amp;lt;int N&amp;gt;
+constexpr auto Int = std::integral_constant&amp;lt;int, N&amp;gt;{};
 
 int main()
 {
@@ -101,10 +106,15 @@ int main()
     // m2 := 0次元配列ビュー
   }
   { // (3) : 要素数リストから型推論
-    std::mdspan m3{arr, 2, 3};
-    static_assert(m3.rank_dynamic() == 2);
-    assert(m3.size() == 6);
-    // m3 := 動的要素数 2x3 の2次元配列ビュー
+    std::mdspan m3a{arr, 2, 3};
+    static_assert(m3a.rank_dynamic() == 2);
+    assert(m3a.size() == 6);
+    // m3a := 動的要素数 2x3 の2次元配列ビュー
+
+    std::mdspan m3b{arr, Int&amp;lt;2&amp;gt;, Int&amp;lt;3&amp;gt;};
+    static_assert(m3b.rank_dynamic() == 0);
+    assert(m3b.size() == 6);
+    // m3b := 静的要素数 2x3 の2次元配列ビュー
   }
   { // (4) : 要素数spanから型推論
     int exts[] = {2, 3};
@@ -179,3 +189,4 @@ int main()
 
 ## 参照
 - [P0009R18 MDSPAN](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r18.html)
+- [P3029R1 Better `mdspan`&amp;#39;s CTAD](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3029r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>strided_slice -- span,mdspan: C++26 P3029R1対応</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/strided_slice.html"/>
      <id>17c594a2e02c0f17280415486fc4491812ca4e0c:reference/mdspan/strided_slice.md</id>
      <updated>2024-06-25T17:35:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/strided_slice.md b/reference/mdspan/strided_slice.md
index b7003c043..0636491d0 100644
--- a/reference/mdspan/strided_slice.md
+++ b/reference/mdspan/strided_slice.md
@@ -36,7 +36,7 @@ std::strided_slice{.offset=1, .extent=10, .stride=3}
 
 
 ## 適格要件
-`OffsetType`, `ExtentType`, `StrideType`は符号付き整数型または符号無し整数型、もしくは[`integral-constant-like`](integral-constant-like.md)のモデルであること。
+`OffsetType`, `ExtentType`, `StrideType`は符号付き整数型または符号無し整数型、もしくは[`integral-constant-like`](/reference/span/integral-constant-like.md)のモデルであること。
 
 
 ## メンバ型
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>submdspan_extents -- span,mdspan: C++26 P3029R1対応</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/submdspan_extents.html"/>
      <id>17c594a2e02c0f17280415486fc4491812ca4e0c:reference/mdspan/submdspan_extents.md</id>
      <updated>2024-06-25T17:35:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/submdspan_extents.md b/reference/mdspan/submdspan_extents.md
index 13ba564f8..4c885ac34 100644
--- a/reference/mdspan/submdspan_extents.md
+++ b/reference/mdspan/submdspan_extents.md
@@ -55,9 +55,9 @@ namespace std {
 - [`SubExtents::rank()`](extents/rank.md)は、型`S_k`が[`convertible_to`](/reference/concepts/convertible_to.md)`&amp;lt;IndexType&amp;gt;`のモデルではない`k`の個数に等しく、かつ
 - `map-rank[k] !=` [`dynamic_extent`](/reference/span/dynamic_extent.md)を満たす`Extents`の次元インデクス`k`について、[`SubExtents::static_extent`](extents/static_extent.md)`(map-rank[k])`が下記と等しいこと
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;S_k,` [`full_extent_t`](full_extent_t.md)`&amp;gt;`が`true`のとき、[`SubExtents::static_extent`](extents/static_extent.md)`(k)`、そうでなければ、
-    - 型`S_k`が[`index-pair-like`](index-pair-like.md)のモデルかつ`tuple_element_t&amp;lt;0, S_k&amp;gt;`および`tuple_element_t&amp;lt;1, S_k&amp;gt;`がいずれも[`integral-constant-like`](integral-constant-like.md)のモデルであるとき、[`de-ice`](de-ice.md)`(tuple_element_t&amp;lt;1, S_k&amp;gt;) -` [`de-ice`](de-ice.md)`(tuple_element_t&amp;lt;0, S_k&amp;gt;)`、そうでなければ
-    - 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化かつメンバ型`extent_type`が`S_k::extent_type() == 0`かつ[`integral-constant-like`](integral-constant-like.md)のモデルであるとき、値`0`、そうでなければ
-    - 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化かつメンバ型`extent_type`および`stride_type`がいずれも[`integral-constant-like`](integral-constant-like.md)のモデルであるとき、`1 + (`[`de-ice`](de-ice.md)`(S_k::extent_type()) - 1) /` [`de-ice`](de-ice.md)`(S_k::stride_type())`、そうでなければ
+    - 型`S_k`が[`index-pair-like`](index-pair-like.md)のモデルかつ`tuple_element_t&amp;lt;0, S_k&amp;gt;`および`tuple_element_t&amp;lt;1, S_k&amp;gt;`がいずれも[`integral-constant-like`](/reference/span/integral-constant-like.md)のモデルであるとき、[`de-ice`](de-ice.md)`(tuple_element_t&amp;lt;1, S_k&amp;gt;) -` [`de-ice`](de-ice.md)`(tuple_element_t&amp;lt;0, S_k&amp;gt;)`、そうでなければ
+    - 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化かつメンバ型`extent_type`が`S_k::extent_type() == 0`かつ[`integral-constant-like`](/reference/span/integral-constant-like.md)のモデルであるとき、値`0`、そうでなければ
+    - 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化かつメンバ型`extent_type`および`stride_type`がいずれも[`integral-constant-like`](/reference/span/integral-constant-like.md)のモデルであるとき、`1 + (`[`de-ice`](de-ice.md)`(S_k::extent_type()) - 1) /` [`de-ice`](de-ice.md)`(S_k::stride_type())`、そうでなければ
     - [`dynamic_extent`](/reference/span/dynamic_extent.md)
 
 以下を満たす`SubExtents`型の値`ext`を返す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>integral-constant-like -- span,mdspan: C++26 P3029R1対応</title>
      <link href="https://cpprefjp.github.io/reference/span/integral-constant-like.html"/>
      <id>17c594a2e02c0f17280415486fc4491812ca4e0c:reference/span/integral-constant-like.md</id>
      <updated>2024-06-25T17:35:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/integral-constant-like.md b/reference/span/integral-constant-like.md
new file mode 100644
index 000000000..3af084489
--- /dev/null
+++ b/reference/span/integral-constant-like.md
@@ -0,0 +1,34 @@
+# integral-constant-like
+* span[meta header]
+* concept[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class T&amp;gt;
+concept integral-constant-like =  // exposition only
+  is_integral_v&amp;lt;decltype(T::value)&amp;gt; &amp;amp;&amp;amp;
+  !is_same_v&amp;lt;bool, remove_const_t&amp;lt;decltype(T::value)&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+  convertible_to&amp;lt;T, decltype(T::value)&amp;gt; &amp;amp;&amp;amp;
+  equality_comparable_with&amp;lt;T, decltype(T::value)&amp;gt; &amp;amp;&amp;amp;
+  bool_constant&amp;lt;T() == T::value&amp;gt;::value &amp;amp;&amp;amp;
+  bool_constant&amp;lt;static_cast&amp;lt;decltype(T::value)&amp;gt;(T()) == T::value&amp;gt;::value;
+```
+* is_integral_v[link /reference/type_traits/is_integral.md]
+* is_same_v[link /reference/type_traits/is_same.md]
+* remove_const_t[link /reference/type_traits/remove_const.md]
+* bool_constant[link /reference/type_traits/bool_constant.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
+
+## 概要
+`integral-constant-like`は、型`T`が整数定数型[`std::integral_constant`](/reference/type_traits/integral_constant.md)と互換があることを表す説明専用コンセプトである。
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
+- [P3029R1 Better `mdspan`&amp;#39;s CTAD](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3029r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>maybe-static-ext -- span,mdspan: C++26 P3029R1対応</title>
      <link href="https://cpprefjp.github.io/reference/span/maybe-static-ext.html"/>
      <id>17c594a2e02c0f17280415486fc4491812ca4e0c:reference/span/maybe-static-ext.md</id>
      <updated>2024-06-25T17:35:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/maybe-static-ext.md b/reference/span/maybe-static-ext.md
new file mode 100644
index 000000000..54c3d1d0b
--- /dev/null
+++ b/reference/span/maybe-static-ext.md
@@ -0,0 +1,25 @@
+# maybe-static-ext
+* span[meta header]
+* variable[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class T&amp;gt;
+  constexpr size_t maybe-static-ext = dynamic_extent;  // exposition only
+template&amp;lt;integral-constant-like T&amp;gt;
+  constexpr size_t maybe-static-ext&amp;lt;T&amp;gt; = {T::value};
+```
+* dynamic_extent[link dynamic_extent.md]
+* integral-constant-like[link integral-constant-like.md]
+
+## 概要
+`maybe-static-ext`は、型`T`から[`dynamic_extent`](dynamic_extent.md)または静的要素数を取り出す説明専用定数である。
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P3029R1 Better `mdspan`&amp;#39;s CTAD](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3029r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- span,mdspan: C++26 P3029R1対応</title>
      <link href="https://cpprefjp.github.io/reference/span/span/op_deduction_guide.html"/>
      <id>17c594a2e02c0f17280415486fc4491812ca4e0c:reference/span/span/op_deduction_guide.md</id>
      <updated>2024-06-25T17:35:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/op_deduction_guide.md b/reference/span/span/op_deduction_guide.md
index 6d0053b01..5afd8ea6b 100644
--- a/reference/span/span/op_deduction_guide.md
+++ b/reference/span/span/op_deduction_guide.md
@@ -7,30 +7,41 @@
 ```cpp
 namespace std {
 
-  template&amp;lt;class It, class End&amp;gt;
-  span(It, End) -&amp;gt; span&amp;lt;remove_reference_t&amp;lt;iter_reference_t&amp;lt;It&amp;gt;&amp;gt;&amp;gt;;     // (1)
+  template&amp;lt;class It, class EndOrSize&amp;gt;
+  span(It, EndOrSize)
+    -&amp;gt; span&amp;lt;remove_reference_t&amp;lt;iter_reference_t&amp;lt;It&amp;gt;&amp;gt;&amp;gt;;          // (1) C++20
+  template&amp;lt;class It, class EndOrSize&amp;gt;
+  span(It, EndOrSize)
+    -&amp;gt; span&amp;lt;remove_reference_t&amp;lt;iter_reference_t&amp;lt;It&amp;gt;&amp;gt;,
+            maybe-static-ext&amp;lt;EndOrSize&amp;gt;&amp;gt;;                       // (1) C++26
 
-  template &amp;lt;class T, size_t N&amp;gt;
-  span(T (&amp;amp;)[N]) -&amp;gt; span&amp;lt;T, N&amp;gt;;                                        // (2)
+  template&amp;lt;class T, size_t N&amp;gt;
+  span(T (&amp;amp;)[N]) -&amp;gt; span&amp;lt;T, N&amp;gt;;                                 // (2)
 
-  template &amp;lt;class T, size_t N&amp;gt;
-  span(array&amp;lt;T, N&amp;gt;&amp;amp;) -&amp;gt; span&amp;lt;T, N&amp;gt;;                                    // (3)
+  template&amp;lt;class T, size_t N&amp;gt;
+  span(array&amp;lt;T, N&amp;gt;&amp;amp;) -&amp;gt; span&amp;lt;T, N&amp;gt;;                             // (3)
 
-  template &amp;lt;class T, size_t N&amp;gt;
-  span(const array&amp;lt;T, N&amp;gt;&amp;amp;) -&amp;gt; span&amp;lt;const T, N&amp;gt;;                        // (4)
+  template&amp;lt;class T, size_t N&amp;gt;
+  span(const array&amp;lt;T, N&amp;gt;&amp;amp;) -&amp;gt; span&amp;lt;const T, N&amp;gt;;                 // (4)
 
   template&amp;lt;class R&amp;gt;
-  span(R&amp;amp;&amp;amp;) -&amp;gt; span&amp;lt;remove_reference_t&amp;lt;ranges::range_reference_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;; // (5)
+  span(R&amp;amp;&amp;amp;)
+    -&amp;gt; span&amp;lt;remove_reference_t&amp;lt;ranges::range_reference_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;;  // (5)
 
 }
 ```
+* remove_reference_t[link /reference/type_traits/remove_reference.md]
+* iter_reference_t[link /reference/iterator/iter_reference_t.md]
+* maybe-static-ext[link /reference/span/maybe-static-ext.md]
 * array[link /reference/array/array.md]
 * size_t[link /reference/cstddef/size_t.md]
 
 ## 概要
 `std::span`クラステンプレートの型推論補助。
 
-- (1) : メモリ連続性をもつイテレータから、要素型を推論する。要素数はデフォルトの[`std::dynamic_extent`](/reference/span/dynamic_extent.md)を使用する
+- (1) : メモリ連続性をもつイテレータから、要素型を推論する。
+    - C++20 : 要素数はデフォルトの[`std::dynamic_extent`](/reference/span/dynamic_extent.md)を使用する
+    - C++26 : `EndOrSize`が整数定数型[`std::integral_constant`](/reference/type_traits/integral_constant.md)互換のときは静的な要素数を推論し、そうでなければ動的な要素数を使用する
 - (2) : 組み込み配列への参照から、要素型と静的な要素数を推論する
 - (3) : `std::array`型オブジェクトから、要素型と静的な要素数を推論する
 - (4) : `const`の`std::array`型オブジェクトから、要素型と静的な要素数を推論する
@@ -63,6 +74,18 @@ int main()
 
     static_assert(decltype(s)::extent == std::dynamic_extent);
   }
+  // (1): C++26以降
+  {
+    std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+    std::span s{v.begin(), std::integral_constant&amp;lt;int, 5&amp;gt;{}};
+    // std::span&amp;lt;int, 5&amp;gt;
+
+    static_assert(std::is_same_v&amp;lt;
+      decltype(s)::element_type,
+      int
+    &amp;gt;);
+    static_assert(decltype(s)::extent == 5);
+  }
 
   // (2)
   {
@@ -130,3 +153,8 @@ int main()
 - [Clang](/implementation.md#clang): 9.0 [mark verified]
 - [GCC](/implementation.md#gcc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P3029R1 Better `mdspan`&amp;#39;s CTAD](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3029r1.html)
+    - C++26から、(1)で静的な要素数への推論がサポートされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- layout_blas_packed/mapping: fix markup</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_blas_packed/mapping/op_call.html"/>
      <id>5d0c10029a321139af2564da89b833c44b40b50d:reference/linalg/layout_blas_packed/mapping/op_call.md</id>
      <updated>2024-06-25T16:29:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_blas_packed/mapping/op_call.md b/reference/linalg/layout_blas_packed/mapping/op_call.md
index f19ba3761..acbfd10ee 100644
--- a/reference/linalg/layout_blas_packed/mapping/op_call.md
+++ b/reference/linalg/layout_blas_packed/mapping/op_call.md
@@ -27,6 +27,7 @@ constexpr index_type operator() (Index0 ind0, Index1 ind1) const noexcept;
 
 ## 戻り値
 `N`を[`extetns_.extent`](/reference/mdspan/extents/extent.md)`(0)`としたとき
+
 - `i &amp;gt; j`ならば`(*this)(j, i)`、そうでなければ
 - 下記いずれの条件を満たすならば`i + j * (j + 1)/2`、そうでなければ
     - [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;StorageOrder, column_major_t&amp;gt; &amp;amp;&amp;amp;` [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;Triangle, upper_triangle_t&amp;gt;`が`true`または
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>layout_blas_packed -- linalg : 例の修正とコードの整理 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_blas_packed.html"/>
      <id>4f45356bb536068c5e28e244bcbf632f2dd66027:reference/linalg/layout_blas_packed.md</id>
      <updated>2024-06-25T16:20:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_blas_packed.md b/reference/linalg/layout_blas_packed.md
index 27663437c..a1be8da21 100644
--- a/reference/linalg/layout_blas_packed.md
+++ b/reference/linalg/layout_blas_packed.md
@@ -70,7 +70,7 @@ int main()
   // 2 5 -  -
   // 3 6 8  -
   // 4 7 9 10
-  print_mat(&amp;#34;mat1&amp;#34;, mat);
+  print_mat(&amp;#34;mat1&amp;#34;, mat1);
 
   // 行優先格納順の下三角要素から4x4対称行列を構築
   std::mdspan&amp;lt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>matrix_vector_product -- linalg : 例の修正とコードの整理 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/matrix_vector_product.html"/>
      <id>4f45356bb536068c5e28e244bcbf632f2dd66027:reference/linalg/matrix_vector_product.md</id>
      <updated>2024-06-25T16:20:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/matrix_vector_product.md b/reference/linalg/matrix_vector_product.md
index 2b862f919..8c08e3b38 100644
--- a/reference/linalg/matrix_vector_product.md
+++ b/reference/linalg/matrix_vector_product.md
@@ -64,7 +64,7 @@ namespace std::linalg {
 
 
 ## 事前条件
-- (1), (2), (3), (4): [`multipliable`](multipliable.md)`(A,x,y) == true`
+- (1), (2), (3), (4): [`multipliable`](multipliable.md)`(A, x, y) == true`
 - (3), (4): [`addable`](addable.md)`(x, y, z) == true`
 
 
@@ -123,10 +123,10 @@ int main()
   }
 
   for(int j = 0; j &amp;lt; x.extent(0); ++j) {
-    x[j] = 1.0 * j;
+    x[j] = j;
   }
   for(int i = 0; i &amp;lt; y.extent(0); ++i) {
-    y[i] = -1.0 * i;
+    y[i] = -i;
   }
 
   // (1)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>linalg -- linalg : symmetric_matrix_vector_productを追加 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg.html"/>
      <id>902bbcac00c3e36c5104db735fcfd68980b284de:reference/linalg.md</id>
      <updated>2024-06-25T16:19:32+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;linalg&lt;/span&gt;&lt;span class=&#34;cpp cpp26&#34; title=&#34;C++26で追加&#34;&gt;(C++26)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダでは、線形代数(linear algebra)に関する基礎的な演算アルゴリズムを提供する。
ベクトルや行列の成分にアクセスするアルゴリズムは、多次元配列ビュー&lt;a href=&#34;mdspan/mdspan.html&#34;&gt; &lt;code&gt;std::mdspan&lt;/code&gt; &lt;/a&gt;を通してその要素にアクセスする。
本ヘッダが提供するエンティティは、すべて名前空間&lt;code&gt;std::linalg&lt;/code&gt;に属する。&lt;/p&gt;
&lt;p&gt;1次元データであるベクトル(vector)や2次元データである行列(matrix)に対して、線形代数分野のデファクトスタンダードとされる BLAS(Basic Linear Algebra Subprograms) 互換のアルゴリズム群、いくつかの LAPACK(Linear Algebra PACKage) 互換のアルゴリズムが提供される。
BLAS互換アルゴリズムは、演算対象データの次元数や計算オーダーに応じて3段階に区分される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Level 1 BLAS : ベクトルーベクトルの演算&lt;/li&gt;
&lt;li&gt;Level 2 BLAS : 行列ーベクトルの演算&lt;/li&gt;
&lt;li&gt;Level 3 BLAS : 行列ー行列の演算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例えば、2個の一般行列の積を求める&lt;code&gt;std::linalg::matrix_product&lt;/code&gt;はLevel 3 BLASルーチン&lt;code&gt;xGEMM&lt;/code&gt;に対応する。
（実際のBLASルーチン名は、浮動小数点数型の単精度&lt;code&gt;S&lt;/code&gt;／倍精度&lt;code&gt;D&lt;/code&gt;とそれぞれの複素数版&lt;code&gt;C&lt;/code&gt;,&lt;code&gt;Z&lt;/code&gt;として、プレフィックス&lt;code&gt;x&lt;/code&gt;部は文字4種類のいずれか。）&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;std::mdspan&lt;/code&gt;と組み合わせて利用する拡張機能が提供される。&lt;/p&gt;
&lt;h2&gt;共通要件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダが提供する演算アルゴリズムは、スカラ値およびベクトル／行列の要素型として線形代数値型(linear algebra value types)を取り扱う。&lt;/p&gt;
&lt;p&gt;線形代数値型はBLASが取り扱う&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;をはじめ、&lt;code&gt;&lt;a href=&#34;concepts/semiregular.html&#34;&gt;semiregular&lt;/a&gt;&lt;/code&gt;のモデルであれば良い。
また、線形代数値型の値初期化は加法元（算術型であれば値&lt;code&gt;0&lt;/code&gt;）であること。&lt;/p&gt;
&lt;p&gt;プログラム定義型を利用する場合、演算アルゴリズムはカスタマイゼーションポイントとして&lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;imag&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;を非修飾名で呼び出す。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;std::mdspan&lt;/code&gt;向け機能拡張&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/layout_blas_packed.html&#34;&gt;layout_blas_packed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列要素のBLAS互換パックレイアウトに対応する&lt;a href=&#34;mdspan/LayoutMappingPolicy.html&#34;&gt;レイアウトマッピングポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/scaled_accessor.html&#34;&gt;scaled_accessor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scaled&lt;/code&gt;関数用の&lt;a href=&#34;mdspan/AccessorPolicy.html&#34;&gt;アクセサポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/scaled.html&#34;&gt;scaled&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素値をスカラー倍した読み取り専用&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/conjugated_accessor.html&#34;&gt;conjugated_accessor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;conjugated&lt;/code&gt;関数用の&lt;a href=&#34;mdspan/AccessorPolicy.html&#34;&gt;アクセサポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/conjugated.html&#34;&gt;conjugated&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取り専用の複素共役ビュー&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/layout_transpose.html&#34;&gt;layout_transpose&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;transposed&lt;/code&gt;関数用の&lt;a href=&#34;mdspan/LayoutMappingPolicy.html&#34;&gt;レイアウトマッピングポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/transposed.html&#34;&gt;transposed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2次元&lt;code&gt;std::mdspan&lt;/code&gt;の行列転置ビューを作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/conjugate_transposed.html&#34;&gt;conjugate_transposed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取り専用の複素共役転置ビュー&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLASの要件&lt;/h2&gt;
&lt;p&gt;BLAS 1, 2, 3のアルゴリズムでテンプレートパラメータが特に制約されていない場合、テンプレートパラメータの名前によって以下の制約を満たすとする。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;制約&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ExecutionPolicy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;is_execution_policy&amp;lt;ExecutionPolicy&amp;gt;::value == true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;complex&amp;lt;Real&amp;gt;&lt;/code&gt;が規定できる型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Triangle&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;upper_triangle_t&lt;/code&gt;または&lt;code&gt;lower_triangle_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DiagonalStorage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;implicit_unit_diagonal_t&lt;/code&gt;または&lt;code&gt;implicit_unit_diagonal_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 1アルゴリズム&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;std::mpspan&lt;/code&gt;をパラメータに持つ、この節の全てのアルゴリズムの計算量は渡された&lt;code&gt;std::mdspan&lt;/code&gt;の&lt;code&gt;extents&lt;/code&gt;の積の最大値、つまりベクトルや行列の要素数の最大値に線形である。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/setup_givens_rotation_result.html&#34;&gt;setup_givens_rotation_result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;setup_givens_rotation&lt;/code&gt;の結果型 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/setup_givens_rotation.html&#34;&gt;setup_givens_rotation&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xLARTG: ギブンス回転をセットアップする (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/apply_givens_rotation.html&#34;&gt;apply_givens_rotation&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xROT: ベクトルにギブンス回転を適用する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/swap_elements.html&#34;&gt;swap_elements&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSWAP: 2つのベクトル／行列の要素を交換する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/scale.html&#34;&gt;scale&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSCAL: ベクトル／行列の要素にスカラ値を乗算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/copy.html&#34;&gt;copy&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xCOPY: ベクトル／行列の要素をコピーする (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/add.html&#34;&gt;add&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xAXPY: 2つのベクトル／行列の要素を加算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/dot.html&#34;&gt;dot&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xDOT, xDOTU: 2つのベクトルのドット積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/dotc.html&#34;&gt;dotc&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xDOTC: 2つのベクトルの複素共役ドット積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/sum_of_squares_result.html&#34;&gt;sum_of_squares_result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector_sum_of_squares&lt;/code&gt;の結果型 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/vector_sum_of_squares.html&#34;&gt;vector_sum_of_squares&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xLASSQ: ベクトル要素の平方和を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/vector_two_norm.html&#34;&gt;vector_two_norm&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xNRM2: ベクトルのユークリッドノルム(Euclidean norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/vector_abs_sum.html&#34;&gt;vector_abs_sum&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xASUM: ベクトル要素の絶対値和を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/vector_idx_abs_max.html&#34;&gt;vector_idx_abs_max&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xIAMAX: ベクトル要素のうち最大絶対値インデクスを返す (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_frob_norm.html&#34;&gt;matrix_frob_norm&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列のフロベニウスノルム(Frobenius norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_one_norm.html&#34;&gt;matrix_one_norm&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列の1ノルム(One norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_inf_norm.html&#34;&gt;matrix_inf_norm&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列の無限大ノルム(Infinity norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 2アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/matrix_vector_product.html&#34;&gt;matrix_vector_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGEMV: 一般行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/symmetric_matrix_vector_product.html&#34;&gt;symmetric_matrix_vector_product&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYMV: 対称行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHEMV: ハミルトニアン行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMV: 三角行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_vector_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSV: 三角行列を係数とする行列方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGER, xGERU: 行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_rank_1_update_c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGERC: 複素行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR: 対称行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER: ハミルトニアン行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_2_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR2: 対称行列のRank-2更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_2_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER2: ハミルトニアン行列のRank-2更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 3アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGEMM: 2つの一般行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYMM: 対称行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHEMM: ハミルトニアン行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: 三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_left_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: In-placeに三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_right_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: In-placeに三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYRK: 対称行列のRank-k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHERK: ハミルトニアン行列のRank-k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_2k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR2K: 対称行列のRank-2k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_2k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER2K: ハミルトニアン行列のRank-2k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_matrix_left_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSM: 三角行列の連立一次方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_matrix_right_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSM: 三角行列の連立一次方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;タグ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダでは、行列の格納順序や三角行列の上下をタグを使って表現している。&lt;/p&gt;
&lt;h3&gt;格納順序&lt;/h3&gt;
&lt;p&gt;行列の格納順序を表すタグ。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/column_major_t.html&#34;&gt;column_major_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(column-major)を表すタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/column_major_t.html&#34;&gt;column_major&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(column-major)を表すタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/row_major_t.html&#34;&gt;row_major_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(row-major)を表すタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/row_major_t.html&#34;&gt;row_major&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(row-major)を表すタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;三角行列&lt;/h3&gt;
&lt;p&gt;上三角行列か下三角行列かを表すタグ。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/upper_triangle_t.html&#34;&gt;upper_triangle_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上三角行列を表すタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/upper_triangle_t.html&#34;&gt;upper_triangle&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上三角行列を表すタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/lower_triangle_t.html&#34;&gt;lower_triangle_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下三角行列を表すタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/lower_triangle_t.html&#34;&gt;lower_triangle&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下三角行列を表すタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;対角成分&lt;/h3&gt;
&lt;p&gt;行列の全ての対角成分を暗黙に乗法における単位元とみなすかどうかを表すタグ。みなした場合、行列の対角成分にはアクセスせず、値が乗法における単位元であるとして計算する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/implicit_unit_diagonal_t.html&#34;&gt;implicit_unit_diagonal_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての対角成分を暗黙に乗法における単位元とみなすタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/implicit_unit_diagonal_t.html&#34;&gt;implicit_unit_diagonal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての対角成分を暗黙に乗法における単位元とみなすタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/explicit_diagonal_t.html&#34;&gt;explicit_diagonal_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての対角成分にアクセスするタグ型&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;linalg/explicit_diagonal_t.html&#34;&gt;explicit_diagonal&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての対角成分にアクセスするタグ値&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++26&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html&#34; target=&#34;_blank&#34;&gt;P1673R13 A free function linear algebra interface based on the BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1674r2.html&#34; target=&#34;_blank&#34;&gt;P1674R2: Evolving a Standard C++ Linear Algebra Library from the BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CppCon/CppCon2023/blob/main/Presentations/stdlinalg_linear_algebra_coming_to_standard_cpp.pdf&#34; target=&#34;_blank&#34;&gt;std::linalg: Linear Algebra Coming to Standard C++&lt;/a&gt;, CppCon 2023&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.netlib.org/blas/&#34; target=&#34;_blank&#34;&gt;BLAS (Basic Linear Algebra Subprograms)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eel.is/c++draft/complex.numbers&#34; target=&#34;_blank&#34;&gt;Numerics library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>symmetric_matrix_vector_product -- linalg : symmetric_matrix_vector_productを追加 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/symmetric_matrix_vector_product.html"/>
      <id>902bbcac00c3e36c5104db735fcfd68980b284de:reference/linalg/symmetric_matrix_vector_product.md</id>
      <updated>2024-06-25T16:19:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/symmetric_matrix_vector_product.md b/reference/linalg/symmetric_matrix_vector_product.md
new file mode 100644
index 000000000..1120a318d
--- /dev/null
+++ b/reference/linalg/symmetric_matrix_vector_product.md
@@ -0,0 +1,223 @@
+# symmetric_matrix_vector_product
+
+
+* [mathjax enable]
+* linalg[meta header]
+* function template[meta id-type]
+* std::linalg[meta namespace]
+* cpp26[meta cpp]
+
+
+```cpp
+namespace std::linalg {
+  template&amp;lt;in-matrix InMat,
+           class Triangle,
+           in-vector InVec,
+           out-vector OutVec&amp;gt;
+  void symmetric_matrix_vector_product(InMat A,
+                                       Triangle t,
+                                       InVec x,
+                                       OutVec y); // (1)
+
+  template&amp;lt;class ExecutionPolicy,
+           in-matrix InMat,
+           class Triangle,
+           in-vector InVec,
+           out-vector OutVec&amp;gt;
+  void symmetric_matrix_vector_product(ExecutionPolicy&amp;amp;&amp;amp; exec,
+                                       InMat A,
+                                       Triangle t,
+                                       InVec x,
+                                       OutVec y); // (2)
+
+  template&amp;lt;in-matrix InMat,
+           class Triangle,
+           in-vector InVec1,
+           in-vector InVec2,
+           out-vector OutVec&amp;gt;
+  void symmetric_matrix_vector_product(
+    InMat A,
+    Triangle t,
+    InVec1 x,
+    InVec2 y,
+    OutVec z); // (3)
+
+  template&amp;lt;class ExecutionPolicy,
+           in-matrix InMat,
+           class Triangle,
+           in-vector InVec1,
+           in-vector InVec2,
+           out-vector OutVec&amp;gt;
+  void symmetric_matrix_vector_product(
+    ExecutionPolicy&amp;amp;&amp;amp; exec,
+    InMat A,
+    Triangle t,
+    InVec1 x,
+    InVec2 y,
+    OutVec z); // (4)
+}
+```
+
+
+## 概要
+対称行列とベクトルの積を計算する。
+引数`t`は対称行列の成分が上三角にあるのか、それとも下三角にあるのかを示す。
+
+- (1): $y \leftarrow Ax$
+- (2): (1)を指定された実行ポリシーで実行する。
+- (3): $z \leftarrow y + Ax$
+- (4): (3)を指定された実行ポリシーで実行する。
+
+
+## 適格要件
+- (1), (2), (3), (4): `InMat`が[`layout_blas_packed`](layout_blas_packed.md)を持つなら、レイアウトの`Triangle`テンプレート引数とこの関数の`Triangle`テンプレート引数が同じ型
+- (1), (2), (3), (4): [`compatible-static-extents`](compatible-static-extents.md)`&amp;lt;decltype(A), decltype(A)&amp;gt;(0, 1)`が`true` (つまり`A`が正方行列であること)
+- (1), (2), (3), (4): [`possibly-multipliable`](possibly-multipliable.md)`&amp;lt;decltype(A), decltype(x), decltype(y)&amp;gt;()`が`true`
+- (3), (4): [`possibly-addable`](possibly-addable.md)`&amp;lt;decltype(x),decltype(y),decltype(z)&amp;gt;()`が`true`
+
+
+## 事前条件
+- (1), (2), (3), (4): `A.extent(0) == A.extent(1)`
+- (1), (2), (3), (4): [`multipliable`](multipliable.md)`(A, x, y) == true`
+- (3), (4): [`addable`](addable.md)`(x, y, z) == true`
+
+
+## 効果
+対称行列の成分の位置を示す`t`を考慮した、対称行列とベクトルの積を計算する。
+
+- (1), (2): $y \leftarrow Ax$
+- (3), (4): $z \leftarrow y + Ax$
+
+
+## 戻り値
+なし
+
+
+## 計算量
+$O(\verb|A.extent(1)|\times \verb|x.extent(0)|)$
+
+
+## 備考
+- (3), (4): `z`に`y`を入れても良い。
+
+
+## 例
+**[注意] 処理系にあるコンパイラで確認していないため、間違っているかもしれません。**
+
+```cpp example
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;linalg&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+template &amp;lt;class Vector&amp;gt;
+void print(const Vector&amp;amp; v, const std::string&amp;amp; name) {
+  for (int i = 0; i &amp;lt; v.extent(0); ++i) {
+    std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;[&amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34;]&amp;#34; &amp;lt;&amp;lt; &amp;#34; = &amp;#34; &amp;lt;&amp;lt; v[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+  }
+}
+
+int main()
+{
+  constexpr size_t N = 4;
+  constexpr size_t M = 4;
+
+  std::vector&amp;lt;double&amp;gt; A_vec(N*M);
+  std::vector&amp;lt;double&amp;gt; x_vec(M);
+  std::array&amp;lt;double, N&amp;gt; y_vec, z_vec;
+
+  std::mdspan&amp;lt;
+    double,
+    std::extents&amp;lt;size_t, N, M&amp;gt;,
+    std::linalg::layout_blas_packed&amp;lt;
+      std::linalg::upper_triangle_t,
+      std::linalg::row_major_t&amp;gt;
+  &amp;gt; A(A_vec.data());
+  std::mdspan x(x_vec.data(), M);
+  std::mdspan y(y_vec.data(), N);
+  std::mdspan z(z_vec.data(), N);
+
+  for(int i = 0; i &amp;lt; A.extent(0); ++i) {
+    for(int j = i; j &amp;lt; A.extent(1); ++j) {
+      A[i,j] = A.extent(1) * i + j;
+    }
+  }
+
+  for(int j = 0; j &amp;lt; x.extent(0); ++j) {
+    x[j] = j;
+  }
+  for(int i = 0; i &amp;lt; y.extent(0); ++i) {
+    y[i] = -i;
+  }
+
+  // (1)
+  std::cout &amp;lt;&amp;lt; &amp;#34;(1)\n&amp;#34;;
+  std::linalg::symmetric_matrix_vector_product(A, std::linalg::upper_triangle, x, y);
+  print(y, &amp;#34;y&amp;#34;);
+
+  // (2)
+  std::cout &amp;lt;&amp;lt; &amp;#34;(2)\n&amp;#34;;
+  std::linalg::symmetric_matrix_vector_product(std::execution::par, A, std::linalg::upper_triangle, x, y);
+  print(y, &amp;#34;y&amp;#34;);
+
+  // (3)
+  std::cout &amp;lt;&amp;lt; &amp;#34;(3)\n&amp;#34;;
+  std::linalg::symmetric_matrix_vector_product(A, std::linalg::upper_triangle, x, y, z);
+  print(z, &amp;#34;z&amp;#34;);
+
+  // (4)
+  std::cout &amp;lt;&amp;lt; &amp;#34;(4)\n&amp;#34;;
+  std::linalg::symmetric_matrix_vector_product(std::execution::par, A, std::linalg::upper_triangle, x, y, z);
+  print(z, &amp;#34;z&amp;#34;);
+
+  return 0;
+}
+```
+
+
+### 出力
+```
+(1)
+y[0] = 14
+y[1] = 38
+y[2] = 59
+y[3] = 74
+(2)
+y[0] = 14
+y[1] = 38
+y[2] = 59
+y[3] = 74
+(3)
+z[0] = 28
+z[1] = 76
+z[2] = 118
+z[3] = 148
+(4)
+z[0] = 28
+z[1] = 76
+z[2] = 118
+z[3] = 148
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`execution`](/reference/execution.md)
+- [`mdspan`](/reference/mdspan.md)
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
+- [LAPACK: csymv](https://netlib.org/lapack/explore-html/db/d17/group__hemv_gab137e328e44dc1530ab0a93ff65c108a.html#gab137e328e44dc1530ab0a93ff65c108a)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dot -- linalg : C++のバージョンを修正 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/dot.html"/>
      <id>7f99ecebe5642aa1eeaa85ae69b01fecb42cdfa2:reference/linalg/dot.md</id>
      <updated>2024-06-25T13:39:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/dot.md b/reference/linalg/dot.md
index c04c8e84e..d5884d797 100644
--- a/reference/linalg/dot.md
+++ b/reference/linalg/dot.md
@@ -88,7 +88,7 @@ $$
 
 ## バージョン
 ### 言語
-- C++11
+- C++26
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dotc -- linalg : C++のバージョンを修正 (#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/dotc.html"/>
      <id>7f99ecebe5642aa1eeaa85ae69b01fecb42cdfa2:reference/linalg/dotc.md</id>
      <updated>2024-06-25T13:39:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/dotc.md b/reference/linalg/dotc.md
index e910eaf20..59efd533a 100644
--- a/reference/linalg/dotc.md
+++ b/reference/linalg/dotc.md
@@ -127,7 +127,7 @@ int main()
 
 ## バージョン
 ### 言語
-- C++11
+- C++26
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuya Asano</name>
        <email>64895419+sukeya@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>