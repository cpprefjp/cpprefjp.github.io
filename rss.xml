<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-04-21T08:53:53.384734</updated>
  <id>25a1c32e-dc81-4e4d-9b59-bc7b8cbb4db5</id>

  
    <entry>
      <title>ほとんどの`volatile`を非推奨化 -- 文面調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html"/>
      <id>6418cf3d29ebe3602dc1e6a3734cf611e4272a75:lang/cpp20/deprecating_volatile.md</id>
      <updated>2021-04-21T16:52:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecating_volatile.md b/lang/cpp20/deprecating_volatile.md
index 02f4607da..4e12a709d 100644
--- a/lang/cpp20/deprecating_volatile.md
+++ b/lang/cpp20/deprecating_volatile.md
@@ -196,27 +196,27 @@ auto&amp;amp;&amp;amp; [a, b, c] = f();  // OK、一時オブジェクト内各要素へのバ
 標準ライブラリのクラステンプレートには、`volatile`な対象に対する特殊化が提供されているものがある。
 
 - [`numeric_limits`](/reference/limits/numeric_limits.md)
+- `atomic`関連
 - [`tuple_size`](/reference/tuple/tuple_size.md)
 - [`tuple_element`](/reference/tuple/tuple_element.md)
 - [`variant_size`](/reference/variant/variant_size.md)
 - [`variant_alternative`](/reference/variant/variant_alternative.md)
-- `atomic`関連
 
 このうち、`numeric_limits`に関しては有用性が明らかであるのでそのままにされ、`atomic`関連のものはあとで説明する。
 
-残ったのは`tuple`と`variant`に関連したものであるが、C++標準は`tuple`と`variant`にどのように実装するかを指定しておらず、これらの型の`volatile`オブジェクトへのアクセスがどのように振る舞うのかが不透明である。さらに、メンバ関数は特に`volatile`修飾されたものが用意されているわけではなく、標準ライブラリのそのほかのクラスも特に`volatile`を意識してはいない。
+残ったのは`tuple`と`variant`に関連したものであるが、C++標準は`tuple`と`variant`がどのように実装されるかを指定しておらず、これらの型の`volatile`オブジェクトへのアクセスがどのように振る舞うのかは不透明である。さらに、メンバ関数は特に`volatile`修飾されたものが用意されているわけではなく、標準ライブラリのそのほかのクラスも特に`volatile`を意識してはいない。
 
-`tuple`と`variant`そのものは`volatile`で使用されるために設計されておらず、これらのクラステンプレートの特殊化はCV修飾を網羅するために用意されているだけであるため、非推奨とされる。
+従って、`tuple`と`variant`そのものは`volatile`で使用されるために設計されておらず、これら4つのクラステンプレートの`volatile`特殊化はCV修飾を網羅するために用意されているだけであるため、非推奨とされる。
 
 ### `std::atomic`の`volatile`メンバ関数
 
 `volatile`なアクセスは不可分ではなく、順序保証がなく、各バイトに正確に一度だけアクセスされ、コンパイラの最適化の対象とならない。
 
-`atomic`なアクセスは不可分であり（原子性が保証され）、メモリモデルによってその順序が保証され、ループによって処理される可能性があり（各バイト一度だけのアクセスは保証されない）、コンパイラの最適化の対象となりえます。
+`atomic`なアクセスは不可分であり（原子性が保証され）、メモリモデルによってその順序が保証され、ループによって処理される可能性があり（各バイト一度だけのアクセスは保証されない）、コンパイラの最適化の対象となりえる。
 
-`volatile std::atomic&amp;lt;T&amp;gt;`はこれらの性質を組み合わせたものとなるはずだが、そうはなっていない。
+`volatile std::atomic&amp;lt;T&amp;gt;`はこれらの性質を組み合わせたものとなる事が期待されるが、そうなっていない。
 
-ロックフリーではない`std::atomic`が`volatile`修飾されている場合、そのアクセスの不可分性（原子性）が必ずしも保証されない。
+ロックフリーではない`std::atomic`が`volatile`修飾されている場合、そのアクセスの不可分性（原子性）が必ずしも保証されない。例えば、C++プログラム上では`mutex`などでロックして正しく`atomic`にアクセスされていたとしても、その領域にアクセスするプログラム外部の観測者にとってはそのアクセスは分割されて見えうる。
 
 また、`volatile`かつ`atomic`な複合代入操作を正しく行う（不可分に、各バイトに正確に一度だけアクセスする）実装は限られているが、そのような実装詳細を指定することはC++標準の範囲内ではない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ほとんどの`volatile`を非推奨化 -- deprecating volatile : ライブラリパート追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html"/>
      <id>13c375ccaf39884aaba9b3f5e2e4da493aa4be42:lang/cpp20/deprecating_volatile.md</id>
      <updated>2021-04-21T16:35:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecating_volatile.md b/lang/cpp20/deprecating_volatile.md
index 68d695f10..02f4607da 100644
--- a/lang/cpp20/deprecating_volatile.md
+++ b/lang/cpp20/deprecating_volatile.md
@@ -190,7 +190,37 @@ auto&amp;amp;&amp;amp; [a, b, c] = f();  // OK、一時オブジェクト内各要素へのバ
 ```
 
 ## ライブラリにおける非推奨化
-（執筆中）
+
+### クラステンプレートの`volatile`な特殊化
+
+標準ライブラリのクラステンプレートには、`volatile`な対象に対する特殊化が提供されているものがある。
+
+- [`numeric_limits`](/reference/limits/numeric_limits.md)
+- [`tuple_size`](/reference/tuple/tuple_size.md)
+- [`tuple_element`](/reference/tuple/tuple_element.md)
+- [`variant_size`](/reference/variant/variant_size.md)
+- [`variant_alternative`](/reference/variant/variant_alternative.md)
+- `atomic`関連
+
+このうち、`numeric_limits`に関しては有用性が明らかであるのでそのままにされ、`atomic`関連のものはあとで説明する。
+
+残ったのは`tuple`と`variant`に関連したものであるが、C++標準は`tuple`と`variant`にどのように実装するかを指定しておらず、これらの型の`volatile`オブジェクトへのアクセスがどのように振る舞うのかが不透明である。さらに、メンバ関数は特に`volatile`修飾されたものが用意されているわけではなく、標準ライブラリのそのほかのクラスも特に`volatile`を意識してはいない。
+
+`tuple`と`variant`そのものは`volatile`で使用されるために設計されておらず、これらのクラステンプレートの特殊化はCV修飾を網羅するために用意されているだけであるため、非推奨とされる。
+
+### `std::atomic`の`volatile`メンバ関数
+
+`volatile`なアクセスは不可分ではなく、順序保証がなく、各バイトに正確に一度だけアクセスされ、コンパイラの最適化の対象とならない。
+
+`atomic`なアクセスは不可分であり（原子性が保証され）、メモリモデルによってその順序が保証され、ループによって処理される可能性があり（各バイト一度だけのアクセスは保証されない）、コンパイラの最適化の対象となりえます。
+
+`volatile std::atomic&amp;lt;T&amp;gt;`はこれらの性質を組み合わせたものとなるはずだが、そうはなっていない。
+
+ロックフリーではない`std::atomic`が`volatile`修飾されている場合、そのアクセスの不可分性（原子性）が必ずしも保証されない。
+
+また、`volatile`かつ`atomic`な複合代入操作を正しく行う（不可分に、各バイトに正確に一度だけアクセスする）実装は限られているが、そのような実装詳細を指定することはC++標準の範囲内ではない。
+
+従って、`volatile std::atomic&amp;lt;T&amp;gt;`は必ずしも両方の性質を備えた実装になっておらず、それを保証する事が困難であるため、`std::atomic&amp;lt;T&amp;gt;::is_always_lock_free`が`true`となる特殊化を除いて`std::atomic`の`volatile`メンバ関数は非推奨とされる。
 
 ## 検討されたほかの選択肢
 
@@ -200,6 +230,9 @@ auto&amp;amp;&amp;amp; [a, b, c] = f();  // OK、一時オブジェクト内各要素へのバ
 
 おそらく、間違っていたり意味がなかったとしても、`volatile`と比べて幅広く使用されているために非推奨とする事が忌避されたものと思われる。
 
+### メンバ関数の`volatile`修飾
+（執筆中）
+
 ## 備考
 
 非推奨化で触れられてはいないが、`volatile`変数を並行処理の共有変数として使用することは常に間違っている。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ほとんどの`volatile`を非推奨化 -- 文面調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html"/>
      <id>e2cb1b6933c302c5f58cfe0882acf31910f0a524:lang/cpp20/deprecating_volatile.md</id>
      <updated>2021-04-21T01:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecating_volatile.md b/lang/cpp20/deprecating_volatile.md
index 1554aef9f..68d695f10 100644
--- a/lang/cpp20/deprecating_volatile.md
+++ b/lang/cpp20/deprecating_volatile.md
@@ -9,7 +9,7 @@ C++20より、`volatile`の本来の役割に照らして不正確、あるい
 
 ## `volatile`
 
-`volatile`な変数（メモリ領域）への1度のアクセスは正確に1度だけ行われる必要があり、0回にも2回にもなってはならない。そして、`volatile`領域へのアクセスはその順序がコード上の順序と一致する必要がある。
+`volatile`な変数（メモリ領域）への1度のアクセスは正確に1度だけ行われる必要があり、0回にも2回以上にもなってはならない。そして、`volatile`領域へのアクセスはその順序がコード上の順序と一致する必要がある。
 
 `volatile`の効果（保証）は単純にはこれだけである。
 
@@ -100,7 +100,7 @@ v1 = n = v3;      // OK
 
 また、呼出規約によっては一部の引数を配置するレジスタが`volatile`となる事があるが、呼出規約はC++コード上で意味を持たず、そのような呼び出し規約がマークされている関数は非`volatile`関数宣言と同様に扱われる。しかし、一部のレジスタが`volatile`である事はABIによって処理されている。
 
-結局、関数引数の`volatile`修飾は有用ではないため非推奨とされる。関数の引数を`volatile`としたい場合、関数内で`volatile`ローカル変数に引数をコピーする事が推奨される。一部の実装では、そのようなコピーは省略され、オーバーヘッドとはならない。
+このように、関数引数の`volatile`修飾は有用ではないため非推奨とされる。関数の引数を`volatile`としたい場合、関数内で`volatile`ローカル変数に引数をコピーする事が推奨される。一部の実装では、そのようなコピーは省略され、オーバーヘッドとはならない。
 
 ```cpp
 void f1(volatile int n);   // NG（非推奨）
@@ -113,7 +113,7 @@ void f6(int * volatile p); // NG（非推奨）
 
 また、参照・ポインタではない関数戻り値型の`volatile`修飾は完全に意味を持たない。
 
-例えば、ローカル`volatile`変数を返す場合、そのアクセスは関数リターン時に値をコピーするために一度実行されるが、コピーした後の値はもはや元の`volatile`領域とは別の場所にある。`volatile`において重要なのは特定領域へのアクセスであり、暗黙にそのようなコピーが走る事はほとんどの場合にプログラマの意図とは異なる。
+例えば、ローカル`volatile`変数を返す場合、そのアクセスは関数リターン時に値をコピーするために一度実行されるが、コピーした後の値はもはや元の`volatile`領域とは別のスタック領域にある。`volatile`において重要なのは特定領域へのアクセスであり、暗黙にそのようなコピーが行われる事はほとんどの場合にプログラマの意図とは異なる。
 
 ローカルの非`volatile`変数を`volatile`として返すことには意味がない。戻り値を`volatile`領域に配置したい場合、関数の呼び出し側で`volatile`変数に受ければよい。
 
@@ -159,13 +159,13 @@ volatile auto [a, b, c] = array; // OK
 static_assert(std::is_volatile_v&amp;lt;decltype(a)&amp;gt;); // OK
 ```
 
-このような非一貫性の他にも、構造化束縛の裏で行われている事が`volatile`には適さない。
+このような挙動の非一貫性を受け入れたとしても、構造化束縛の裏で行われている事が`volatile`には適していない。
 
-構造化束縛の`volatile`修飾はその右辺にある暗黙のオブジェクトに対して行われるが、その事は構文からは完全に隠蔽されている。右辺の式の結果オブジェクトも場合によってコピーされたり参照のまま利用されたりと、扱いが変化しうる。また、構造化束縛宣言に指定した変数名はコンパイラの扱いとしては変数名ではなく、右辺の暗黙のオブジェクト内の対応する要素にバインドされた名前でしかない。そのような名前に対する`volatile`の効果は不明瞭であり、右辺の式の直接の結果の型もその要素の型も`volatile`ではない場合には意味をなさない。
+構造化束縛の`volatile`修飾はその右辺にある暗黙のオブジェクトに対して行われるが、その事は構文からは完全に隠蔽されている。右辺の式の結果オブジェクトも場合によってコピーされたり参照のまま利用されたりと、扱いが変化しうる。また、構造化束縛宣言に指定した変数名はコンパイラの扱いとしては変数名ではなく、右辺の暗黙のオブジェクト内の対応する要素にバインドされた名前でしかない。そのような名前に対する`volatile`の効果は不明瞭であり、束縛先の要素の型が`volatile`ではない場合には意味をなさない。
 
-`volatile`においてはその領域へのアクセスが重要であり、1度のアクセスは正確に1度だけ行われる必要があり、その順序は前後してはならない。構造化束縛宣言はその裏側で多くの事が起こりそれは場合によって変化しうるが、そこでどのオブジェクトが`volatile`となりどのような順番でアクセスが発生するのかは非常に不透明である。
+`volatile`においてはその領域へのアクセスが重要であり、1度のアクセスは正確に1度だけ行われる必要があり、その順序は前後してはならない。構造化束縛宣言はその裏側で多くの事が行われており、それはCV・参照修飾と右辺の式の結果型によって様々に変化するが、そこでどのオブジェクトが`volatile`となりどのような順番でアクセスが発生するのかは非常に不明瞭である。
 
-従って、構造化束縛宣言の`volatile`修飾は非推奨とされる。
+従って、構造化束縛宣言の`volatile`修飾を正しく扱う事は非常に困難であるため、非推奨とされる。
 
 構造化束縛した名前が`volatile`である必要がある場合は、分解対象の右辺の結果オブジェクトの各要素型をあらかじめ`volatile`修飾しておく事が推奨される。
 
@@ -180,6 +180,15 @@ auto g() -&amp;gt; std::tuple&amp;lt;volatile int*, volatile int*, volatile double&amp;amp;&amp;gt;;
 auto [a, b, c] = g();  // OK
 ```
 
+この場合でも、各要素型のトップレベル`volatile`修飾は意味をなさない。
+
+```cpp
+auto f() -&amp;gt; std::tuple&amp;lt;volatile int, volatile int, volatile double&amp;gt;;
+
+auto [a, b, c] = f();  // OK、要素ごとコピーされている、volatile修飾は無意味
+auto&amp;amp;&amp;amp; [a, b, c] = f();  // OK、一時オブジェクト内各要素へのバインド、volatile修飾は無意味
+```
+
 ## ライブラリにおける非推奨化
 （執筆中）
 
@@ -205,4 +214,4 @@ auto [a, b, c] = g();  // OK
 - [P1152R2 Deprecating `volatile`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1152r2)
 - [P1152R4 Deprecating `volatile`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1152r4.html)
 - [P1831R0 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1831r0.html)
-- [P1831R0 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
\ No newline at end of file
+- [P1831R0 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform -- 前後の説明に合わせて変数名を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/transform.html"/>
      <id>33d4c2c29271fd969b9513d9c01e1194e2550ac1:reference/algorithm/transform.md</id>
      <updated>2021-04-20T21:10:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/transform.md b/reference/algorithm/transform.md
index ecb542eeb..2fde7dbbf 100644
--- a/reference/algorithm/transform.md
+++ b/reference/algorithm/transform.md
@@ -82,7 +82,7 @@ namespace std {
 
 ## 計算量
 - (1) : 正確に `last - first` 回の `op` の適用が行われる。
-- (2) : 正確に `last - first` 回の `binary_op` の適用が行われる。
+- (2) : 正確に `last1 - first1` 回の `binary_op` の適用が行われる。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>komori-n</name>
        <email>ikamat.kmr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ほとんどの`volatile`を非推奨化 -- deprecating volatile : 構造化束縛追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html"/>
      <id>f7e9fce4d5d5a4a566d20f7f1db91404a8d19061:lang/cpp20/deprecating_volatile.md</id>
      <updated>2021-04-20T16:23:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecating_volatile.md b/lang/cpp20/deprecating_volatile.md
index 4dadf76cf..1554aef9f 100644
--- a/lang/cpp20/deprecating_volatile.md
+++ b/lang/cpp20/deprecating_volatile.md
@@ -134,7 +134,51 @@ int* volatile f6();   // NG（非推奨）
 
 
 ### 構造化束縛宣言
-（執筆中）
+
+構造化束縛宣言にも`volatile`修飾を行う事ができるが、ここでのCV修飾は右辺にある式の結果である暗黙のオブジェクトに対して作用している。
+
+右辺の式の結果が`std::tuple/std::pair`等の`tuple-like`な型のオブジェクトである場合、構造化束縛はまずその結果オブジェクトを`volatile`修飾して受けておき、その結果オブジェクトに対して`std::get`で要素の取得を行う。しかし、`std::get`には`volatile`オーバーロードが欠けており、コンパイルエラーを起こす。
+
+一方、構造化束縛の残りのケース（配列・構造体）の場合は`std::get`を用いないためこのような問題は起こらない。
+
+```cpp
+auto f() -&amp;gt; std::tuple&amp;lt;int, int, double&amp;gt;;
+
+volatile auto [a, b, c] = f();  // NG
+// ここでは以下の様な事が行われている
+// volatile auto tmp = f();
+// std::tuple_element_t&amp;lt;0, decltype(tmp)&amp;gt; a = std::get&amp;lt;0&amp;gt;(tmp);
+
+int array[3]{};
+
+volatile auto [a, b, c] = array; // OK
+// ここでは以下の様な事が行われている
+// volatile int tmp[] = {array[0], array[1], array[2]};
+// volatile int a = tmp[0];
+
+static_assert(std::is_volatile_v&amp;lt;decltype(a)&amp;gt;); // OK
+```
+
+このような非一貫性の他にも、構造化束縛の裏で行われている事が`volatile`には適さない。
+
+構造化束縛の`volatile`修飾はその右辺にある暗黙のオブジェクトに対して行われるが、その事は構文からは完全に隠蔽されている。右辺の式の結果オブジェクトも場合によってコピーされたり参照のまま利用されたりと、扱いが変化しうる。また、構造化束縛宣言に指定した変数名はコンパイラの扱いとしては変数名ではなく、右辺の暗黙のオブジェクト内の対応する要素にバインドされた名前でしかない。そのような名前に対する`volatile`の効果は不明瞭であり、右辺の式の直接の結果の型もその要素の型も`volatile`ではない場合には意味をなさない。
+
+`volatile`においてはその領域へのアクセスが重要であり、1度のアクセスは正確に1度だけ行われる必要があり、その順序は前後してはならない。構造化束縛宣言はその裏側で多くの事が起こりそれは場合によって変化しうるが、そこでどのオブジェクトが`volatile`となりどのような順番でアクセスが発生するのかは非常に不透明である。
+
+従って、構造化束縛宣言の`volatile`修飾は非推奨とされる。
+
+構造化束縛した名前が`volatile`である必要がある場合は、分解対象の右辺の結果オブジェクトの各要素型をあらかじめ`volatile`修飾しておく事が推奨される。
+
+```cpp
+auto f() -&amp;gt; std::tuple&amp;lt;int, int, double&amp;gt;;
+int array[3]{};
+
+volatile auto [a, b, c] = f();   // NG（非推奨）
+volatile auto [a, b, c] = array; // NG（非推奨）
+
+auto g() -&amp;gt; std::tuple&amp;lt;volatile int*, volatile int*, volatile double&amp;amp;&amp;gt;;
+auto [a, b, c] = g();  // OK
+```
 
 ## ライブラリにおける非推奨化
 （執筆中）
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>