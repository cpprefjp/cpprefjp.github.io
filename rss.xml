<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-11-12T08:38:05.097108</updated>
  <id>d9498510-bbcc-43f4-8a2b-efcae03fd302</id>

  
    <entry>
      <title>span -- span : const_iterator関係を削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span.html"/>
      <id>a2026c9c51d37a08982ff46e7d9070a53745d223:reference/span/span.md</id>
      <updated>2020-11-12T17:33:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span.md b/reference/span/span.md
index 05890245f..e1768e7ba 100644
--- a/reference/span/span.md
+++ b/reference/span/span.md
@@ -91,12 +91,8 @@ namespace std {
 |------|------|----------------|
 | [`begin`](span/begin.md) | 先頭要素を指すイテレータを取得する | C++20 |
 | [`end`](span/end.md) | 末尾要素の次を指すイテレータを取得する | C++20 |
-| [`cbegin`](span/cbegin.md) | 先頭要素を指す読み取り専用イテレータを取得する | C++20 |
-| [`cend`](span/cend.md) | 末尾要素の次を指す読み取り専用イテレータを取得する | C++20 |
 | [`rbegin`](span/rbegin.md) | 末尾要素を指す逆順イテレータを取得する | C++20 |
 | [`rend`](span/rend.md) | 先頭要素の前を指す逆順イテレータを取得する | C++20 |
-| [`crbegin`](span/crbegin.md) | 末尾要素を指す読み取り専用逆順イテレータを取得する | C++20 |
-| [`crend`](span/crend.md) | 先頭要素の前を指す読み取り専用逆順イテレータを取得する | C++20 |
 
 
 ### メンバ定数
@@ -119,9 +115,7 @@ namespace std {
 | `reference` | 参照型 `element_type&amp;amp;` | C++20 |
 | `const_reference` | `const`参照型 `const element_type&amp;amp;` | C++20 |
 | `iterator` | 実装定義のイテレータ型 | C++20 |
-| `const_iterator` | 実装定義の読み取り専用イテレータ | C++20 |
 | `reverse_iterator` | 逆順イテレータ [`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;iterator&amp;gt;` | C++20 |
-| `const_reverse_iterator` | 読み取り専用逆イテレータ [`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;const_iterator&amp;gt;` | C++20 |
 
 
 ## 非メンバ関数
@@ -265,4 +259,6 @@ int main()
 - [LWG Issue 3144. `span` does not have a `const_pointer` typedef](https://wg21.cmeerw.net/lwg/issue3144)
 - [LWG Issue 3203. `span` element access invalidation](https://cplusplus.github.io/LWG/lwg-active.html#3203)
 - [P1872R0 `span` should have `size_type`, not `index_type`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1872r0.pdf)
+- [P2051R0 C++ Standard Library Issues to be moved in Prague](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2051r0.html)
+    - `const_iterator`, `const_reverse_iterator`, `cbegin()`, `cend()`, `crbegin()`, `crend()`を削除
 - [P2116R0 Remove tuple-like protocol support from fixed-extent `span`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2116r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cbegin.md -- span : const_iterator関係を削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span/cbegin.html"/>
      <id>a2026c9c51d37a08982ff46e7d9070a53745d223:reference/span/span/cbegin.md</id>
      <updated>2020-11-12T17:33:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/cbegin.md b/reference/span/span/cbegin.md
deleted file mode 100644
index 5f2a1beac..000000000
--- a/reference/span/span/cbegin.md
+++ /dev/null
@@ -1,66 +0,0 @@
-# cbegin
-* span[meta header]
-* std[meta namespace]
-* span[meta class]
-* function[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-constexpr const_iterator cbegin() const noexcept;
-```
-
-## 概要
-先頭要素を指す読み取り専用イテレータを取得する。
-
-
-## 戻り値
-`span`オブジェクトが参照している範囲の、最初の要素を参照する読み取り専用イテレータを返す。[`empty()`](empty.md)が`true`である場合、[`cend()`](cend.md)と同じ値が返る。
-
-
-## 例外
-投げない
-
-
-## 計算量
-定数時間
-
-
-## 例
-```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;span&amp;gt;
-#include &amp;lt;vector&amp;gt;
-#include &amp;lt;algorithm&amp;gt;
-
-int main()
-{
-  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
-
-  // vの先頭3要素を部分シーケンスとして参照する
-  std::span&amp;lt;int, 3&amp;gt; s = std::span(v).first(3);
-
-  // アルゴリズム内で要素の変更操作を行わない
-  std::for_each(s.cbegin(), s.cend(), [](int x) {
-    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
-  });
-}
-```
-* s.cbegin[color ff0000]
-* s.cend()[link cend.md]
-* first[link first.md]
-
-### 出力
-```
-1
-2
-3
-```
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): 9.0
-- [GCC](/implementation.md#gcc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cend.md -- span : const_iterator関係を削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span/cend.html"/>
      <id>a2026c9c51d37a08982ff46e7d9070a53745d223:reference/span/span/cend.md</id>
      <updated>2020-11-12T17:33:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/cend.md b/reference/span/span/cend.md
deleted file mode 100644
index 04b4ebbef..000000000
--- a/reference/span/span/cend.md
+++ /dev/null
@@ -1,66 +0,0 @@
-# cend
-* span[meta header]
-* std[meta namespace]
-* span[meta class]
-* function[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-constexpr const_iterator cend() const noexcept;
-```
-
-## 概要
-末尾要素の次を指す読み取り専用イテレータを取得する。
-
-
-## 戻り値
-`span`オブジェクトが参照している範囲の、末尾要素の次を参照する読み取り専用イテレータを返す。
-
-
-## 例外
-投げない
-
-
-## 計算量
-定数時間
-
-
-## 例
-```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;span&amp;gt;
-#include &amp;lt;vector&amp;gt;
-#include &amp;lt;algorithm&amp;gt;
-
-int main()
-{
-  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
-
-  // vの先頭3要素を部分シーケンスとして参照する
-  std::span&amp;lt;int, 3&amp;gt; s = std::span(v).first(3);
-
-  // アルゴリズム内で要素の変更操作を行わない
-  std::for_each(s.cbegin(), s.cend(), [](int x) {
-    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
-  });
-}
-```
-* s.cend[color ff0000]
-* s.cbegin()[link cend.md]
-* first[link first.md]
-
-### 出力
-```
-1
-2
-3
-```
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): 9.0
-- [GCC](/implementation.md#gcc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>crbegin.md -- span : const_iterator関係を削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span/crbegin.html"/>
      <id>a2026c9c51d37a08982ff46e7d9070a53745d223:reference/span/span/crbegin.md</id>
      <updated>2020-11-12T17:33:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/crbegin.md b/reference/span/span/crbegin.md
deleted file mode 100644
index 19cf03d1b..000000000
--- a/reference/span/span/crbegin.md
+++ /dev/null
@@ -1,72 +0,0 @@
-# crbegin
-* span[meta header]
-* std[meta namespace]
-* span[meta class]
-* function[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-constexpr const_reverse_iterator crbegin() const noexcept;
-```
-
-## 概要
-先頭要素を指す読み取り専用逆順イテレータを取得する。
-
-
-## 戻り値
-以下と等価：
-
-```cpp
-return const_reverse_iterator(cend());
-```
-* cend()[link cend.md]
-
-
-## 例外
-投げない
-
-
-## 計算量
-定数時間
-
-
-## 例
-```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;span&amp;gt;
-#include &amp;lt;vector&amp;gt;
-#include &amp;lt;algorithm&amp;gt;
-
-int main()
-{
-  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
-
-  // vの先頭3要素を部分シーケンスとして参照する
-  std::span&amp;lt;int, 3&amp;gt; s = std::span(v).first(3);
-
-  // 逆順に出力。
-  // アルゴリズム内で要素の変更操作を行わない
-  std::for_each(s.crbegin(), s.crend(), [](int x) {
-    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
-  });
-}
-```
-* crbegin[color ff0000]
-* s.crend()[link crend.md]
-* first[link first.md]
-
-### 出力
-```
-3
-2
-1
-```
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): 9.0
-- [GCC](/implementation.md#gcc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>crend.md -- span : const_iterator関係を削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span/crend.html"/>
      <id>a2026c9c51d37a08982ff46e7d9070a53745d223:reference/span/span/crend.md</id>
      <updated>2020-11-12T17:33:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/crend.md b/reference/span/span/crend.md
deleted file mode 100644
index 04fe3dd9e..000000000
--- a/reference/span/span/crend.md
+++ /dev/null
@@ -1,72 +0,0 @@
-# crend
-* span[meta header]
-* std[meta namespace]
-* span[meta class]
-* function[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-constexpr const_reverse_iterator crend() const noexcept;
-```
-
-## 概要
-末尾要素の次を指す読み取り専用逆順イテレータを取得する。
-
-
-## 戻り値
-以下と等価：
-
-```cpp
-return const_reverse_iterator(cbegin());
-```
-* cbegin()[link cbegin.md]
-
-
-## 例外
-投げない
-
-
-## 計算量
-定数時間
-
-
-## 例
-```cpp example
-#include &amp;lt;iostream&amp;gt;
-#include &amp;lt;span&amp;gt;
-#include &amp;lt;vector&amp;gt;
-#include &amp;lt;algorithm&amp;gt;
-
-int main()
-{
-  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
-
-  // vの先頭3要素を部分シーケンスとして参照する
-  std::span&amp;lt;int, 3&amp;gt; s = std::span(v).first(3);
-
-  // 逆順に出力。
-  // アルゴリズム内で要素の変更操作を行わない
-  std::for_each(s.crbegin(), s.crend(), [](int x) {
-    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
-  });
-}
-```
-* crend[color ff0000]
-* s.crbegin()[link crbegin.md]
-* first[link first.md]
-
-### 出力
-```
-3
-2
-1
-```
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): 9.0
-- [GCC](/implementation.md#gcc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>span -- span : タプルインタフェースを削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span.html"/>
      <id>efbc6c62a0d1c9e3592daf3208d000adaa1baa99:reference/span/span.md</id>
      <updated>2020-11-12T17:24:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span.md b/reference/span/span.md
index c21a9406a..05890245f 100644
--- a/reference/span/span.md
+++ b/reference/span/span.md
@@ -35,7 +35,7 @@ namespace std {
 ### 静的な要素数と、動的な要素数
 `std::span`は、静的な要素数をもつ場合と、動的な要素数をもつ場合の両方をサポートする。それはテンプレートパラメータ`Extent`によって表される。動的な要素数をもつ場合は、`Extent`として[`std::dynamic_extent`](/reference/span/dynamic_extent.md)を指定する。動的な要素数は、[`std::vector`](/reference/vector/vector.md)を参照したり、ポインタと要素数の組を扱ったり、参照範囲を動的に変更したりする場合に必要となる。
 
-静的な要素数をもつ場合、メンバ定数`extent`に要素数が保持されるため、メンバ変数として要素数を保持する必要がなく、領域を節約する最適化を行える。また、静的な要素数をもつ`std::span`型に対しては、タプルインタフェースを適用できる。
+静的な要素数をもつ場合、メンバ定数`extent`に要素数が保持されるため、メンバ変数として要素数を保持する必要がなく、領域を節約する最適化を行える。
 
 
 ### テンプレートパラメータ制約
@@ -132,14 +132,6 @@ namespace std {
 | [`as_bytes`](span/as_bytes.md) | 読み取り専用バイト列としてシーケンスを参照する | C++20 |
 | [`as_writable_bytes`](span/as_writable_bytes.md) | 書込み可能なバイト列としてシーケンスを参照する | C++20 |
 
-## タプルインタフェース
-
-| 名前 | 説明 | 対応バージョン |
-|------|------|----------------|
-| [`tuple_size`](span/tuple_size.md)       | 要素数を取得する (class template)           | C++20 |
-| [`tuple_element`](span/tuple_element.md) | `i`番目の要素型を取得する (class template)  | C++20 |
-| [`get`](span/get.md)                     | 任意の位置の要素を取得する | C++20 |
-
 
 ## 推論補助
 
@@ -273,3 +265,4 @@ int main()
 - [LWG Issue 3144. `span` does not have a `const_pointer` typedef](https://wg21.cmeerw.net/lwg/issue3144)
 - [LWG Issue 3203. `span` element access invalidation](https://cplusplus.github.io/LWG/lwg-active.html#3203)
 - [P1872R0 `span` should have `size_type`, not `index_type`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1872r0.pdf)
+- [P2116R0 Remove tuple-like protocol support from fixed-extent `span`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2116r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get.md -- span : タプルインタフェースを削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span/get.html"/>
      <id>efbc6c62a0d1c9e3592daf3208d000adaa1baa99:reference/span/span/get.md</id>
      <updated>2020-11-12T17:24:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/get.md b/reference/span/span/get.md
deleted file mode 100644
index cc43ec7cc..000000000
--- a/reference/span/span/get.md
+++ /dev/null
@@ -1,73 +0,0 @@
-# get
-* span[meta header]
-* std[meta namespace]
-* function template[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-namespace std {
-  template &amp;lt;size_t I, class ElementType, size_t Extent&amp;gt;
-  constexpr ElementType&amp;amp; get(span&amp;lt;ElementType, Extent&amp;gt; s) noexcept;
-}
-```
-* size_t[link /reference/cstddef/size_t.md]
-
-## 概要
-タプルと見なせる型から指定した位置の要素を取得する。
-
-`&amp;lt;span&amp;gt;`ヘッダでは、`span`クラスに関するオーバーロードを定義する。
-
-静的な要素数をもつ`span`クラスオブジェクトに対してのみ、タプルインタフェースを使用できる。
-
-
-## 適格要件
-- `Extent !=` [`dynamic_extent`](/reference/span/dynamic_extent.md) `&amp;amp;&amp;amp; I &amp;lt; Extent`であること
-
-
-## 戻り値
-以下と等価：
-
-```cpp
-return `s[I]`;
-```
-
-
-## 例外
-投げない
-
-
-## 計算量
-定数時間
-
-
-## 例
-```cpp example
-#include &amp;lt;span&amp;gt;
-#include &amp;lt;cassert&amp;gt;
-
-int main()
-{
-  int ar[] = {1, 2, 3, 4, 5};
-  std::span s{ar};
-
-  // 1番目の要素を取得
-  int&amp;amp; x = std::get&amp;lt;1&amp;gt;(s);
-  assert(x == 2);
-}
-```
-* std::get[color ff0000]
-
-
-### 出力
-```
-```
-
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): 9.0
-- [GCC](/implementation.md#gcc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_element.md -- span : タプルインタフェースを削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span/tuple_element.html"/>
      <id>efbc6c62a0d1c9e3592daf3208d000adaa1baa99:reference/span/span/tuple_element.md</id>
      <updated>2020-11-12T17:24:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/tuple_element.md b/reference/span/span/tuple_element.md
deleted file mode 100644
index eb913f535..000000000
--- a/reference/span/span/tuple_element.md
+++ /dev/null
@@ -1,64 +0,0 @@
-# tuple_element
-* span[meta header]
-* std[meta namespace]
-* class template[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-namespace std {
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element; // 先行宣言
-
-  template &amp;lt;std::size_t I, class ElementType, std::size_t Extent&amp;gt;
-  struct tuple_element&amp;lt;I, span&amp;lt;ElementType, Extent&amp;gt;&amp;gt; {
-    static_assert(I &amp;lt; N, implementation-defined);
-    using type = ElementType;
-  }
-}
-```
-
-## 概要
-`tuple_element`は、タプルとして見なせる型から、`I`番目の要素型を取得するためのクラスである。
-
-`&amp;lt;span&amp;gt;`ヘッダでは、`span`クラスに関する特殊化を定義する。
-`span`の特殊化では、`tuple_element::type`は常に`ElementType`である。
-
-
-## 適格要件
-- `I &amp;lt; Extent`であること
-
-
-## 例
-```cpp example
-#include &amp;lt;span&amp;gt;
-#include &amp;lt;type_traits&amp;gt;
-
-int main()
-{
-  using S = std::span&amp;lt;int, 3&amp;gt;;
-
-  static_assert(std::is_same_v&amp;lt;
-                  std::tuple_element&amp;lt;0, S&amp;gt;::type,
-                  int
-                &amp;gt;);
-
-  static_assert(std::is_same_v&amp;lt;
-                  std::tuple_element&amp;lt;1, S&amp;gt;::type,
-                  int
-                &amp;gt;);
-}
-```
-* std::tuple_element[color ff0000]
-
-### 出力
-```
-```
-
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): 9.0
-- [GCC](/implementation.md#gcc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_size.md -- span : タプルインタフェースを削除</title>
      <link href="https://cpprefjp.github.io/reference/span/span/tuple_size.html"/>
      <id>efbc6c62a0d1c9e3592daf3208d000adaa1baa99:reference/span/span/tuple_size.md</id>
      <updated>2020-11-12T17:24:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/tuple_size.md b/reference/span/span/tuple_size.md
deleted file mode 100644
index 4ade0ea4a..000000000
--- a/reference/span/span/tuple_size.md
+++ /dev/null
@@ -1,56 +0,0 @@
-# tuple_size
-* span[meta header]
-* std[meta namespace]
-* class template[meta id-type]
-* cpp20[meta cpp]
-
-```cpp
-namespace std {
-  template &amp;lt;class T&amp;gt; class tuple_size; // 先行宣言
-
-  template &amp;lt;class ElementType, std::size_t Extent&amp;gt;
-  struct tuple_size&amp;lt;span&amp;lt;ElementType, Extent&amp;gt;&amp;gt;
-    : integral_constant&amp;lt;std::size_t, Extent&amp;gt; {};
-
-  template &amp;lt;class ElementType&amp;gt;
-  struct tuple_size&amp;lt;span&amp;lt;ElementType, dynamic_extent&amp;gt;&amp;gt;; // 宣言のみで定義なし
-}
-```
-* integral_constant[link /reference/type_traits/integral_constant.md]
-* dynamic_extent[link /reference/span/dynamic_extent.md]
-
-## 概要
-`tuple_size`は、タプルとして見なせる型の要素数を取得するためのクラスである。
-
-要素数は、[`integral_constant`](/reference/type_traits/integral_constant.md)の機能を利用してコンパイル時の定数値として取得できる。
-
-`&amp;lt;span&amp;gt;`ヘッダでは、静的な要素数をもつ[`std::span`](/reference/span/span.md)クラスに関する特殊化を定義する。
-
-動的な要素数を表す[`std::dynamic_extent`](/reference/span/dynamic_extent.md)をもつ[`std::span`](/reference/span/span.md)型は、タプルとしては扱えない。
-
-
-## 例
-```cpp example
-#include &amp;lt;span&amp;gt;
-
-int main()
-{
-  static_assert(std::tuple_size&amp;lt;std::span&amp;lt;int, 3&amp;gt;&amp;gt;::value == 3);
-}
-```
-* std::tuple_size[color ff0000]
-
-
-### 出力
-```
-```
-
-
-## バージョン
-### 言語
-- C++20
-
-### 処理系
-- [Clang](/implementation.md#clang): 9.0
-- [GCC](/implementation.md#gcc): ??
-- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- spanのコンストラクタ : dynamic rangeを考慮したexplicit(bool)に対応</title>
      <link href="https://cpprefjp.github.io/reference/span/span/op_constructor.html"/>
      <id>a6675f8048efa85f1f9d6ced16fb9bca4e7272a8:reference/span/span/op_constructor.md</id>
      <updated>2020-11-12T17:18:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/op_constructor.md b/reference/span/span/op_constructor.md
index 8c0822a87..9fbec545f 100644
--- a/reference/span/span/op_constructor.md
+++ b/reference/span/span/op_constructor.md
@@ -6,33 +6,38 @@
 * cpp20[meta cpp]
 
 ```cpp
-constexpr span() noexcept;                                             // (1)
+constexpr span() noexcept;                                     // (1) C++20
 
 template &amp;lt;class It&amp;gt;
-constexpr span(It first, size_type count);                             // (2)
+constexpr explicit(extent != dynamic_extent)
+  span(It first, size_type count);                             // (2) C++20
 
 template &amp;lt;class It, class End&amp;gt;
-constexpr span(It first, End last);                                    // (3)
+constexpr explicit(extent != dynamic_extent)
+  span(It first, End last);                                    // (3) C++20
 
 template &amp;lt;size_t N&amp;gt;
-constexpr span(element_type (&amp;amp;arr)[N]) noexcept;                       // (4)
+constexpr span(element_type (&amp;amp;arr)[N]) noexcept;               // (4) C++20
 
 template &amp;lt;size_t N&amp;gt;
-constexpr span(array&amp;lt;value_type, N&amp;gt;&amp;amp; arr) noexcept;                    // (5)
+constexpr span(array&amp;lt;value_type, N&amp;gt;&amp;amp; arr) noexcept;            // (5) C++20
 
 template &amp;lt;size_t N&amp;gt;
-constexpr span(const array&amp;lt;value_type, N&amp;gt;&amp;amp; arr) noexcept;              // (6)
+constexpr span(const array&amp;lt;value_type, N&amp;gt;&amp;amp; arr) noexcept;      // (6) C++20
 
 template &amp;lt;class R&amp;gt;
-constexpr span(R&amp;amp;&amp;amp; r);                                                 // (7)
+constexpr explicit(extent != dynamic_extent)
+  span(R&amp;amp;&amp;amp; r);                                                 // (7) C++20
 
-constexpr span(const span&amp;amp; other) noexcept = default;                  // (8)
+constexpr span(const span&amp;amp; other) noexcept = default;          // (8) C++20
 
 template &amp;lt;class OtherElementType, size_t OtherExtent&amp;gt;
-constexpr span(const span&amp;lt;OtherElementType, OtherExtent&amp;gt;&amp;amp; s) noexcept; // (9)
+constexpr explicit(extent != dynamic_extent &amp;amp;&amp;amp; OtherExtent == dynamic_extent)
+  span(const span&amp;lt;OtherElementType, OtherExtent&amp;gt;&amp;amp; s) noexcept; // (9) C++20
 ```
 * size_t[link /reference/cstddef/size_t.md]
 * array[link /reference/array/array.md]
+* dynamic_extent[link /reference/span/dynamic_extent.md]
 
 ## 概要
 `span`オブジェクトを構築する。
@@ -57,45 +62,48 @@ constexpr span(const span&amp;lt;OtherElementType, OtherExtent&amp;gt;&amp;amp; s) noexcept; // (9)
     - `Extent ==` [`dynamic_extent`](/reference/span/dynamic_extent.md) `|| Extent == 0`が`true`であること
         - 値`-1`はオーバーフローによって正の最大値になるので`false`
 - (2) :
-    - 型 `U` を `std::remove_reference_t&amp;lt;std::iter_reference_t&amp;lt;It&amp;gt;&amp;gt;`とするとき
-        - 型 `It` はコンセプト `std::contiguous_iterator` を満たしていること
-        - `std::is_convertible_v&amp;lt;U(*)[], element_type(*)[]&amp;gt;` が `true` であること。(その意図は、イテレータ参照型から `element_type` への `qualification conversions`のみを許可することである。)
+    - 型 `U` を [`std::remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;`[`std::iter_reference_t`](/reference/iterator/iter_reference_t.md)`&amp;lt;It&amp;gt;&amp;gt;`とするとき
+        - 型 `It` はコンセプト [`std::contiguous_iterator`](/reference/iterator/contiguous_iterator.md) を満たしていること
+        - [`std::is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U(*)[], element_type(*)[]&amp;gt;` が `true` であること。(この制約の意図は、イテレータ参照型から `element_type` への修飾の変換のみを許可すること)
 - (3) :
-    - 型 `U` を `std::remove_reference_t&amp;lt;std::iter_reference_t&amp;lt;It&amp;gt;&amp;gt;`とするとき
-        - 型 `It` はコンセプト `std::contiguous_iterator` を満たしていること
-        - `std::is_convertible_v&amp;lt;U(*)[], element_type(*)[]&amp;gt;` が `true` であること。(その意図は、イテレータ参照型から `element_type` への `qualification conversions`のみを許可することである。)
-        - 型 `End` はコンセプト `std::sized_sentinel_for&amp;lt;It&amp;gt;` を満たしていること
-        - `std::is_convertible_v&amp;lt;End, size_t&amp;gt;` が `false`であること
+    - 型 `U` を [`std::remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;`[`std::iter_reference_t`](/reference/iterator/iter_reference_t.md)`&amp;lt;It&amp;gt;&amp;gt;`とするとき
+        - 型 `It` はコンセプト [`std::contiguous_iterator`](/reference/iterator/contiguous_iterator.md) を満たしていること
+        - [`std::is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U(*)[], element_type(*)[]&amp;gt;` が `true` であること。(この制約の意図は、イテレータ参照型から `element_type` への修飾の変換のみを許可すること)
+        - 型 `End` はコンセプト [`std::sized_sentinel_for&amp;lt;It&amp;gt;`](/reference/iterator/sized_sentinel_for.md) を満たしていること
+        - [`std::is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;End, size_t&amp;gt;` が `false`であること
 - (4), (5), (6) :
     - `extent ==` [`dynamic_extent`](/reference/span/dynamic_extent.md) `|| N == extent`が`true`であること
-    - [`remove_pointer_t`](/reference/type_traits/remove_pointer.md)`&amp;lt;decltype(`[`data`](/reference/iterator/data.md)`(arr)))&amp;gt;(*)[]`型が`ElementType(*)[]`型に変換可能であること
+    - [`remove_pointer_t`](/reference/type_traits/remove_pointer.md)`&amp;lt;decltype(`[`data`](/reference/iterator/data.md)`(arr)))&amp;gt;`を型`U`であるとして、
+        - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U(*)[], element_type(*)[]&amp;gt;`が`trueであること` (この制約の意図は、配列の要素型から`element_type`へ、修飾の変換のみを許可すること)
 - (7) :
-    - 型 `U` を `std::remove_reference_t&amp;lt;std::iter_reference_t&amp;lt;R&amp;gt;&amp;gt;`とするとき
-        - `extent ==` [`dynamic_extent`](/reference/span/dynamic_extent.md)が`true`であること
+    - 型 `U` を [`std::remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;`[`std::iter_reference_t`](/reference/iterator/iter_reference_t.md)`&amp;lt;R&amp;gt;&amp;gt;`とするとき
         - 型 `R` はコンセプト `std::ranges::contiguous_range` 及び `std::ranges::sized_range` を満たしていること
         - 型 `R` がコンセプト `std::ranges::safe_range` を満たすか、`std::is_const_v&amp;lt;element_type&amp;gt;` が`true`であること
         - `std::remove_cvref_t&amp;lt;R&amp;gt;`が`std::span`の特殊化ではないこと
         - `std::remove_cvref_t&amp;lt;R&amp;gt;`が`std::array`の特殊化ではないこと
         - `std::is_array_v&amp;lt;std::remove_cvref_t&amp;lt;R&amp;gt;&amp;gt;` が `false` であること
-        - `std::is_convertible_v&amp;lt;U(*)[], element_type(*)[]&amp;gt;` が `true` であること。(その意図は、イテレータ参照型から `element_type` への `qualification conversions`のみを許可することである。)
+        - `std::is_convertible_v&amp;lt;U(*)[], element_type(*)[]&amp;gt;` が `true` であること。(この制約の意図は、イテレータ参照型から `element_type` への修飾変換のみを許可すること)
 - (9) :
-    - `Extent ==` [`dynamic_extent`](/reference/span/dynamic_extent.md) `|| Extent == OtherExtent`が`true`であること (受け取り側が[`dynamic_extent`](/reference/span/dynamic_extent.md)を持っていれば任意の`Extent`から変換できる)
+    - `extent ==` [`dynamic_extent`](/reference/span/dynamic_extent.md) `|| OtherExtent ==` [`dynamic_extent`](/reference/span/dynamic_extent.md) `|| extent == OtherExtent`が`true`であること (受け取り側が[`dynamic_extent`](/reference/span/dynamic_extent.md)を持っていれば任意の`Extent`から変換できる)
     - `OtherElementType(*)[]`型が`ElementType(*)[]`型に変換可能であること
 
 
 ## 事前条件
 - (2) :
     - `[first, first + count)`が妥当な範囲であること
-    - 型 `It` はコンセプト `std::contiguous_iterator` のモデルであること
+    - 型 `It` はコンセプト [`std::contiguous_iterator`](/reference/iterator/contiguous_iterator.md) のモデルであること
     - メンバ定数`extent`が[`dyanmic_extent`](/reference/span/dynamic_extent.md)と等値ではない場合、`count`と`extent`が等値であること
 - (3) :
     - `[first, last)`が妥当な範囲であること
     - メンバ定数`extent`が[`dyanmic_extent`](/reference/span/dynamic_extent.md)と等値ではない場合、`last - first`と`extent`が等値であること
-    - 型 `It` はコンセプト `std::contiguous_iterator` のモデルであること
-    - 型 `End` はコンセプト `std::sized_sentinel_for&amp;lt;It&amp;gt;` のモデルであること
+    - 型 `It` はコンセプト [`std::contiguous_iterator`](/reference/iterator/contiguous_iterator.md) のモデルであること
+    - 型 `End` はコンセプト [`std::sized_sentinel_for`](/reference/iterator/sized_sentinel_for.md)`&amp;lt;It&amp;gt;` のモデルであること
 - (7) :
+    - `extent`が[`dynamic_extent`](/reference/span/dynamic_extent.md)と等値でない場合、`extent`は[`ranges::size`](/reference/ranges/size.md.nolink)`(r)`と等値になる
     - 型 `R` はコンセプト `std::ranges::contiguous_range` 及び `std::ranges::sized_range` のモデルであること
-    - `std::is_const_v&amp;lt;element_type&amp;gt;` が `false`であるとき、型 `R` は `std::ranges::safe_range` のモデルであること
+    - [`std::is_const_v`](/reference/type_traits/is_const.md)`&amp;lt;element_type&amp;gt;` が `false`であるとき、型 `R` は `std::ranges::safe_range` のモデルであること
+- (9) :
+    - `extent`が[`dynamic_extent`](/reference/span/dynamic_extent.md)と等値でない場合、`extent`は[`s.size()`](size.md)と等値になる
 
 
 ## 効果
@@ -272,3 +280,4 @@ int main()
 - [LWG Issue 3198. Bad constraint on `std::span::span()`](https://cplusplus.github.io/LWG/issue3198)
 - [P1872R0 `span` should have `size_type`, not `index_type`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1872r0.pdf)
 - [P1394R4 Range constructor for `std::span`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1394r4.pdf)
+- [P1976R2 Fixed-size `span` construction from dynamic range](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1976r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reverse_iterator -- reverse_iterator iter_swap_move 追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/reverse_iterator.html"/>
      <id>3d265348f08eb15d0f99728a7b94dbd7c53e530d:reference/iterator/reverse_iterator.md</id>
      <updated>2020-11-12T10:53:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/reverse_iterator.md b/reference/iterator/reverse_iterator.md
index 2a6c24ce1..8c90aa5f9 100644
--- a/reference/iterator/reverse_iterator.md
+++ b/reference/iterator/reverse_iterator.md
@@ -101,8 +101,8 @@ namespace std {
 | [`operator&amp;lt;=&amp;gt;`](reverse_iterator/op_compare_3way.md.nolink)           | 三方比較を行う | C++20 |
 | [`operator-`](reverse_iterator/op_minus.md) | 2つの`reverse_iterator`の差を求める | |
 | [`operator+`](reverse_iterator/op_plus.md) | イテレータを進める | |
-| [`iter_move`](reverse_iterator/iter_move.md.nolink)     | イテレータの要素の移動 | C++20 |
-| [`iter_swap`](reverse_iterator/iter_swap.md.nolink)     | イテレータの要素の交換 | C++20 |
+| [`iter_move`](reverse_iterator/iter_move.md)     | イテレータの要素の移動 | C++20 |
+| [`iter_swap`](reverse_iterator/iter_swap.md)     | イテレータの要素の交換 | C++20 |
 
 ### ヘルパ関数
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iter_move -- reverse_iterator iter_swap_move 追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/reverse_iterator/iter_move.html"/>
      <id>3d265348f08eb15d0f99728a7b94dbd7c53e530d:reference/iterator/reverse_iterator/iter_move.md</id>
      <updated>2020-11-12T10:53:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/reverse_iterator/iter_move.md b/reference/iterator/reverse_iterator/iter_move.md
new file mode 100644
index 000000000..d9487d89e
--- /dev/null
+++ b/reference/iterator/reverse_iterator/iter_move.md
@@ -0,0 +1,96 @@
+# iter_move
+* iterator[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class Iterator&amp;gt;
+  class reverse_iterator {
+
+    friend constexpr iter_rvalue_reference_t&amp;lt;Iterator&amp;gt;
+      iter_move(const reverse_iterator&amp;amp; i) noexcept(/*see below*/);
+  };
+}
+```
+* reverse_iterator[link /reference/iterator/reverse_iterator.md]
+* iter_rvalue_reference_t[link /reference/iterator/iter_rvalue_reference_t.md]
+
+## 概要
+
+逆順イテレータ`i`の指す要素をムーブする。
+
+## 効果
+
+以下と等価
+
+```cpp
+auto tmp = i.base();
+return ranges::iter_move(--tmp);
+```
+* base[link /reference/iterator/reverse_iterator/base.md]
+* ranges::iter_move[link /reference/iterator/iter_move.md.nolink]
+
+## 例外
+
+以下の式が指定される
+
+```cpp
+is_nothrow_copy_constructible_v&amp;lt;Iterator&amp;gt; &amp;amp;&amp;amp;
+noexcept(ranges::iter_move(--declval&amp;lt;Iterator&amp;amp;&amp;gt;()))
+```
+* is_nothrow_copy_constructible_v[link /reference/type_traits/is_nothrow_copy_constructible.md]
+* ranges::iter_move[link /reference/iterator/iter_move.md.nolink]
+
+## 備考
+
+この関数は`reverse_iterator`のクラス定義内で`friend`関数として定義される。そのため、メンバ関数としても非メンバ関数としても明示的に呼び出すことはできず、ADLによってのみ呼び出すことができる。  
+基本的には[`ranges::iter_move`](/reference/iterator/iter_move.md.nolink)カスタマイゼーションポイントオブジェクトを通して利用する。
+
+## 例
+```cpp example
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+
+  std::reverse_iterator&amp;lt;decltype(v)::iterator&amp;gt; it(v.end());
+
+  // ADLによる呼び出し
+  int n1 = iter_move(it);
+  std::cout &amp;lt;&amp;lt; n1 &amp;lt;&amp;lt; std::endl;
+  
+  ++it;
+
+  // ranges::iter_move CPOによる呼び出し
+  int n2 = std::ranges::iter_move(it);
+  std::cout &amp;lt;&amp;lt; n2 &amp;lt;&amp;lt; std::endl;
+}
+```
+* iter_move[color ff0000]
+* ranges::iter_move[link /reference/iterator/iter_move.md.nolink]
+
+### 出力
+```
+5
+4
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 6
+
+## 関連項目
+
+- [`ranges::iter_move`](/reference/iterator/iter_move.md.nolink)
+
+## 参照
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iter_swap -- reverse_iterator iter_swap_move 追加 #712</title>
      <link href="https://cpprefjp.github.io/reference/iterator/reverse_iterator/iter_swap.html"/>
      <id>3d265348f08eb15d0f99728a7b94dbd7c53e530d:reference/iterator/reverse_iterator/iter_swap.md</id>
      <updated>2020-11-12T10:53:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/reverse_iterator/iter_swap.md b/reference/iterator/reverse_iterator/iter_swap.md
new file mode 100644
index 000000000..c8f391475
--- /dev/null
+++ b/reference/iterator/reverse_iterator/iter_swap.md
@@ -0,0 +1,111 @@
+# iter_swap
+* iterator[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class Iterator&amp;gt;
+  class reverse_iterator {
+
+    template&amp;lt;indirectly_swappable&amp;lt;Iterator&amp;gt; Iterator2&amp;gt;
+    friend constexpr void
+      iter_swap(const reverse_iterator&amp;amp; x,
+              const reverse_iterator&amp;lt;Iterator2&amp;gt;&amp;amp; y) noexcept(see below);
+  };
+}
+```
+* reverse_iterator[link /reference/iterator/reverse_iterator.md]
+* indirectly_swappable[link /reference/iterator/indirectly_swappable.md]
+
+## 概要
+
+逆順イテレータ`x, y`の指す要素を交換する。
+
+## 効果
+
+以下と等価
+
+```cpp
+auto xtmp = x.base();
+auto ytmp = y.base();
+ranges::iter_swap(--xtmp, --ytmp);
+```
+* base[link /reference/iterator/reverse_iterator/base.md]
+* ranges::iter_swap[link /reference/iterator/iter_swap.md.nolink]
+
+## 例外
+
+以下の式が指定される
+
+```cpp
+is_nothrow_copy_constructible_v&amp;lt;Iterator&amp;gt; &amp;amp;&amp;amp;
+is_nothrow_copy_constructible_v&amp;lt;Iterator2&amp;gt; &amp;amp;&amp;amp;
+noexcept(ranges::iter_swap(--declval&amp;lt;Iterator&amp;amp;&amp;gt;(), --declval&amp;lt;Iterator2&amp;amp;&amp;gt;()))
+```
+* is_nothrow_copy_constructible_v[link /reference/type_traits/is_nothrow_copy_constructible.md]
+* ranges::iter_swap[link /reference/iterator/iter_swap.md.nolink]
+
+## 備考
+
+この関数は`reverse_iterator`のクラス定義内で`friend`関数として定義される。そのため、メンバ関数としても非メンバ関数としても明示的に呼び出すことはできず、ADLによってのみ呼び出すことができる。  
+基本的には[`ranges::iter_swap`](/reference/iterator/iter_swap.md.nolink)カスタマイゼーションポイントオブジェクトを通して利用する。
+
+## 例
+```cpp example
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5};
+  int array[] = {6, 7, 8, 9, 10};
+
+  std::reverse_iterator&amp;lt;decltype(v)::iterator&amp;gt; it1(v.end());
+  std::reverse_iterator&amp;lt;int*&amp;gt; it2(std::ranges::end(array));
+
+  // ADLによる呼び出し
+  iter_swap(it1, it2);
+
+  ++it1;
+  ++it2;
+
+  // ranges::iter_swap CPOによる呼び出し
+  std::ranges::iter_swap(it1, it2);
+
+  for (int n : v) {
+    std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+
+  std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+
+  for (int n : array) {
+    std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
+  }
+}
+```
+* iter_swap[color ff0000]
+* ranges::iter_swap[link /reference/iterator/iter_swap.md.nolink]
+
+### 出力
+```
+1 2 3 9 10 
+6 7 8 4 5 
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 6
+
+## 関連項目
+
+- [`ranges::iter_swap`](/reference/iterator/iter_swap.md.nolink)
+
+## 参照
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iter_value_t -- iter_value_t : 書き方の変更</title>
      <link href="https://cpprefjp.github.io/reference/iterator/iter_value_t.html"/>
      <id>48f9debc7024dc8dbcb7683d80423d43e1baae62:reference/iterator/iter_value_t.md</id>
      <updated>2020-11-11T16:43:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/iter_value_t.md b/reference/iterator/iter_value_t.md
index 3e077d691..49d2b47cc 100644
--- a/reference/iterator/iter_value_t.md
+++ b/reference/iterator/iter_value_t.md
@@ -19,10 +19,10 @@ namespace std {
 
 `RI = remove_cvref_t&amp;lt;I&amp;gt;`とすると、次のどちらか
 
-- [`indirectly_readable_traits`](indirectly_readable_traits.md)`&amp;lt;RI&amp;gt;::value_type`
-    - [`iterator_traits`](iterator_traits.md)`&amp;lt;RI&amp;gt;`がプライマリテンプレートの特殊化となる場合
-- [`iterator_traits`](iterator_traits.md)`&amp;lt;RI&amp;gt;::value_type`
-    - その他の場合
+- [`iterator_traits`](iterator_traits.md)`&amp;lt;RI&amp;gt;`がプライマリテンプレートの特殊化となる場合
+    - [`indirectly_readable_traits`](indirectly_readable_traits.md)`&amp;lt;RI&amp;gt;::value_type`
+- その他の場合
+    - [`iterator_traits`](iterator_traits.md)`&amp;lt;RI&amp;gt;::value_type`
 
 ## 備考
 
@@ -62,4 +62,4 @@ int main() {
 
 ## 参照
 
-- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
\ No newline at end of file
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>