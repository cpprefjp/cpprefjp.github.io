<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-03-02T15:14:49.813119</updated>
  <id>6c6b5663-0d87-487e-a890-a047863131fd</id>

  
    <entry>
      <title>linalg -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;linalg&lt;/span&gt;&lt;span class=&#34;cpp cpp26&#34; title=&#34;C++26で追加&#34;&gt;(C++26)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダでは、線形代数(linear algebra)に関する基礎的な演算アルゴリズムを提供する。
本ヘッダが提供するエンティティは、すべて名前空間&lt;code&gt;std::linalg&lt;/code&gt;に属する。&lt;/p&gt;
&lt;p&gt;1次元データであるベクトル(vector)や2次元データである行列(matrix)に対して、線形代数分野のデファクトスタンダードとされる BLAS(Basic Linear Algebra Subprograms) 互換のアルゴリズム群、いくつかの LAPACK(Linear Algebra PACKage) 互換のアルゴリズムが提供される。
BLAS互換アルゴリズムは、演算対象データの次元数や計算オーダーに応じて3段階に区分される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Level 1 BLAS : ベクトルーベクトルの演算&lt;/li&gt;
&lt;li&gt;Level 2 BLAS : 行列ーベクトルの演算&lt;/li&gt;
&lt;li&gt;Level 3 BLAS : 行列ー行列の演算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例えば、2個の一般行列の積を求める&lt;code&gt;std::linalg::matrix_product&lt;/code&gt;はLevel 3 BLASルーチン&lt;code&gt;xGEMM&lt;/code&gt;に対応する。
（実際のBLASルーチン名は、浮動小数点数型の単精度&lt;code&gt;S&lt;/code&gt;／倍精度&lt;code&gt;D&lt;/code&gt;とそれぞれの複素数版&lt;code&gt;C&lt;/code&gt;,&lt;code&gt;Z&lt;/code&gt;として、プレフィックス&lt;code&gt;x&lt;/code&gt;部は文字4種類のいずれか。）&lt;/p&gt;
&lt;p&gt;また、多次元配列ビュー&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/mdspan.html&#34;&gt;std::mdpan&lt;/a&gt;&lt;/code&gt;と組み合わせて利用する拡張機能が提供される。&lt;/p&gt;
&lt;h2&gt;共通要件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;linalg&amp;gt;&lt;/code&gt;ヘッダが提供する演算アルゴリズムは、スカラ値およびベクトル／行列の要素型として線形代数値型(linear algebra value types)を取り扱う。&lt;/p&gt;
&lt;p&gt;線形代数値型はBLASが取り扱う&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;をはじめ、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts/semiregular.html&#34;&gt;semiregular&lt;/a&gt;&lt;/code&gt;のモデルであれば良い。
また、線形代数値型の値初期化は加法元（算術型であれば値&lt;code&gt;0&lt;/code&gt;）であること。&lt;/p&gt;
&lt;p&gt;プログラム定義型を利用する場合、演算アルゴリズムはカスタマイゼーションポイントとして&lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;imag&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;を非修飾名で呼び出す。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;std::mdspan&lt;/code&gt;向け機能拡張&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/layout_blas_packed.html&#34;&gt;layout_blas_packed&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列要素のBLAS互換パックレイアウトに対応する&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/LayoutMappingPolicy.html&#34;&gt;レイアウトマッピングポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scaled&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素値をスカラ倍した読み取り専用&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scaled_accessor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scaled&lt;/code&gt;関数用の&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/AccessorPolicy.html&#34;&gt;アクセサポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;conjugated_accessor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;conjugated&lt;/code&gt;関数用の&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/AccessorPolicy.html&#34;&gt;アクセサポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;conjugated&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取り専用の複素共役ビュー&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/layout_transpose.html&#34;&gt;layout_transpose&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;transposed&lt;/code&gt;関数用の&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/LayoutMappingPolicy.html&#34;&gt;レイアウトマッピングポリシー&lt;/a&gt; (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transposed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2次元&lt;code&gt;std::mdspan&lt;/code&gt;の行列転置ビューを作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;conjugate_transposed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取り専用の複素共役転置ビュー&lt;code&gt;std::mdspan&lt;/code&gt;を作る (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 1アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;setup_givens_rotation_result&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;setup_givens_rotation&lt;/code&gt;の結果型 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;setup_givens_rotation&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xLARTG: ギブンス回転をセットアップする (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;apply_givens_rotation&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xROT: ベクトルにギブンス回転を適用する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;swap_elements&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSWAP: 2つのベクトル／行列の要素を交換する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSCAL: ベクトル／行列の要素にスカラ値を乗算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xCOPY: ベクトル／行列の要素をコピーする (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xAXPY: 2つのベクトル／行列の要素を加算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dot&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xDOT, xDOTU: 2つのベクトルのドット積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dotc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xDOTC: 2つのベクトルの複素共役ドット積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sum_of_squares_result&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector_sum_of_squares&lt;/code&gt;の結果型 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector_sum_of_squares&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xLASSQ: ベクトル要素の平方和を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector_two_norm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xNRM2: ベクトルのユークリッドノルム(Euclidean norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector_abs_sum&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xASUM: ベクトル要素の絶対値和を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector_idx_abs_max&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xIAMAX: ベクトル要素のうち最大絶対値インデクスを返す (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_frob_norm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列のフロベニウスノルム(Frobenius norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_one_norm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列の1ノルム(One norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_inf_norm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行列の無限大ノルム(Infinity norm)を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 2アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGEMV: 一般行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYMV: 対称行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHEMV: ハミルトニアン行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_vector_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMV: 三角行列とベクトルの積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_vector_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSV: 三角行列を係数とする行列方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGER, xGERU: 行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_rank_1_update_c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGERC: 複素行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR: 対称行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_1_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER: ハミルトニアン行列のRank-1更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_2_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR2: 対称行列のRank-2更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_2_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER2: ハミルトニアン行列のRank-2更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;BLAS 3アルゴリズム&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xGEMM: 2つの一般行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYMM: 対称行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHEMM: ハミルトニアン行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: 三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_left_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: In-placeに三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_right_product&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRMM: In-placeに三角行列と行列の積を求める (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYRK: 対称行列のRank-k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHERK: ハミルトニアン行列のRank-k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;symmetric_matrix_rank_2k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xSYR2K: 対称行列のRank-2k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hermitian_matrix_rank_2k_update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xHER2K: ハミルトニアン行列のRank-2k更新 (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_matrix_left_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSM: 三角行列の連立一次方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;triangular_matrix_matrix_right_solve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;xTRSM: 三角行列の連立一次方程式を解く (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;タグ型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/column_major_t.html&#34;&gt;column_major_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(column-major)順序を表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/column_major_t.html&#34;&gt;column_major&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(column-major)順序を表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/row_major_t.html&#34;&gt;row_major_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(row-major)順序を表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/row_major_t.html&#34;&gt;row_major&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(row-major)順序を表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/upper_triangle_t.md.nolink&#34;&gt;upper_triangle_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上三角行列を表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/upper_triangle_t.md.nolink&#34;&gt;upper_triangle&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上三角行列を表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/lower_triangle_t.md.nolink&#34;&gt;lower_triangle_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下三角行列を表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg/lower_triangle_t.md.nolink&#34;&gt;lower_triangle&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下三角行列を表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;implicit_unit_diagonal_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;implicit unit diagonalを表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;implicit_unit_diagonal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;implicit unit diagonalを表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;explicit_diagonal_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;explicit diagonalを表現するためのタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;explicit_diagonal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;explicit diagonalを表現するためのタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++26&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html&#34; target=&#34;_blank&#34;&gt;P1673R13 A free function linear algebra interface based on the BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1674r2.html&#34; target=&#34;_blank&#34;&gt;P1674R2: Evolving a Standard C++ Linear Algebra Library from the BLAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CppCon/CppCon2023/blob/main/Presentations/stdlinalg_linear_algebra_coming_to_standard_cpp.pdf&#34; target=&#34;_blank&#34;&gt;std::linalg: Linear Algebra Coming to Standard C++&lt;/a&gt;, CppCon 2023&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.netlib.org/blas/&#34; target=&#34;_blank&#34;&gt;BLAS (Basic Linear Algebra Subprograms)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>column_major_t -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/column_major_t.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/column_major_t.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/column_major_t.md b/reference/linalg/column_major_t.md
new file mode 100644
index 000000000..ae5a0f4ad
--- /dev/null
+++ b/reference/linalg/column_major_t.md
@@ -0,0 +1,38 @@
+# column_major_t
+* linalg[meta header]
+* class[meta id-type]
+* std::linalg[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::linalg {
+  struct column_major_t { explicit column_major_t() = default; };
+
+  inline constexpr column_major_t column_major{};
+}
+```
+
+## 概要
+`column_major_t`は、[`layout_blas_packed`](layout_blas_packed.md)を指定した多次元配列ビュー[`mdspan`](/reference/mdspan/mdspan.md)において、要素の格納順が列優先(column-major)であることを指示するためのタグ型である。
+
+`column_major_t`型の定数`column_major`が提供される。
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`mdspan`](/reference/mdspan/mdspan.md)
+- [`layout_blas_packed`](layout_blas_packed.md)
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>layout_blas_packed -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_blas_packed.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_blas_packed.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_blas_packed.md b/reference/linalg/layout_blas_packed.md
index 3138c5537..67fd43010 100644
--- a/reference/linalg/layout_blas_packed.md
+++ b/reference/linalg/layout_blas_packed.md
@@ -15,14 +15,14 @@ namespace std::linalg {
 `layout_blas_packed`は、多次元配列ビュー[`mdspan`](/reference/mdspan/mdspan.md)を用いた正方行列(square matrix)に対して、BLASにおけるパックレイアウトと互換性のある行列要素メモリ配置を表現する[レイアウトマッピングポリシー](/reference/mdspan/LayoutMappingPolicy.md)クラスである。
 
 - `Triangle` : 指定する行列要素の種別を、上三角[`upper_triangle_t`](upper_triangle_t.md.nolink)または下三角[`lower_triangle_t`](lower_triangle_t.md.nolink)から指定する。
-- `StorageOrder` : 行列要素の格納順を、列優先[`column_major_t`](column_major_t.md.nolink)または行優先[`row_major_t`](row_major_t.md.nolink)から指定する。
+- `StorageOrder` : 行列要素の格納順を、列優先[`column_major_t`](column_major_t.md)または行優先[`row_major_t`](row_major_t.md)から指定する。
 
-`layout_blas_packed`を用いて、BLASの Symmetric Packed (SP), Hermitian Packed (HP), Triangular Packed (TP) 行列レイアウトを表現できる。
+`layout_blas_packed`を用いて、BLASの Symmetric Packed (SP), Hermitian Packed (HP), Triangular Packed (TP) で利用される行列レイアウトを表現できる。
 
 
 ## 適格要件
 - `Triangle`は[`upper_triangle_t`](upper_triangle_t.md.nolink)または[`lower_triangle_t`](lower_triangle_t.md.nolink)のいずれか
-- `StorageOrder`は[`column_major_t`](column_major_t.md.nolink)または[`row_major_t`](row_major_t.md.nolink)のいずれか
+- `StorageOrder`は[`column_major_t`](column_major_t.md)または[`row_major_t`](row_major_t.md)のいずれか
 
 
 ## メンバ型
@@ -31,7 +31,7 @@ namespace std::linalg {
 |------|------|----------------|
 | `triangle_type` | `Triangle` | C++26 |
 | `storage_order_type` | `StorageOrder` | C++26 |
-| [`mapping`](layout_blas_packed/mapping.md) | レイアウトマッピング | C++26 |
+| [`mapping`](layout_blas_packed/mapping.md) | レイアウトマッピング (class template) | C++26 |
 
 
 ## 例
@@ -87,8 +87,8 @@ int main()
 ```
 * linalg::layout_blas_packed[color ff0000]
 * linalg::lower_triangle_t[link lower_triangle_t.md.nolink]
-* linalg::column_major_t[link column_major_t.md.nolink]
-* linalg::row_major_t[link row_major_t.md.nolink]
+* linalg::column_major_t[link column_major_t.md]
+* linalg::row_major_t[link row_major_t.md]
 * mat.extent[link /reference/mdspan/mdspan/extent.md]
 * std::print[link /reference/print/print.md]
 * std::println[link /reference/print/println.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mapping -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_blas_packed/mapping.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_blas_packed/mapping.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_blas_packed/mapping.md b/reference/linalg/layout_blas_packed/mapping.md
index 7e1f27246..2074f2590 100644
--- a/reference/linalg/layout_blas_packed/mapping.md
+++ b/reference/linalg/layout_blas_packed/mapping.md
@@ -44,7 +44,7 @@ namespace std::linalg {
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| [`(constructor)`](mapping/op_constructor.md.nolink) | コンストラクタ | C++26 |
+| [`(constructor)`](mapping/op_constructor.md) | コンストラクタ | C++26 |
 | `(destructor)` | デストラクタ | C++26 |
 | `operator=`    | コピー代入演算子 | C++26 |
 
@@ -53,8 +53,8 @@ namespace std::linalg {
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
 | `extents` | 多次元配列のサイズ`extents_`を取得する | C++26 |
-| [`required_span_size`](mapping/required_span_size.md.nolink) | 要素アクセス範囲を取得する | C++26 |
-| [`operator()`](mapping/op_call.md.nolink) | 多次元配列インデクスから要素位置へ変換する | C++26 |
+| [`required_span_size`](mapping/required_span_size.md) | 要素アクセス範囲を取得する | C++26 |
+| [`operator()`](mapping/op_call.md) | 多次元配列インデクスから要素位置へ変換する | C++26 |
 | `stride` | 行列サイズ1x1ならば`1` | C++26 |
 | `is_unique`     | 行列サイズ1x1ならば`true` | C++26 |
 | `is_exhaustive` | `true`を返す | C++26 |
@@ -67,7 +67,7 @@ namespace std::linalg {
 |------|------|----------------|
 | `is_always_unique` | 行または列の静的要素数が1ならば`true` | C++26 |
 | `is_always_exhaustive` | `true`を返す | C++26 |
-| `is_always_strided` | `is_always_unique();` | C++26 |
+| `is_always_strided` | `is_always_unique()` | C++26 |
 
 
 ## メンバ型
@@ -86,8 +86,8 @@ namespace std::linalg {
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| [`operator==`](mapping/op_equal.md.nolink) | 等値比較 | C++26 |
-| [`operator!=`](mapping/op_equal.md.nolink) | 非等値比較 (`==`により使用可能) | C++26 |
+| [`operator==`](mapping/op_equal.md) | 等値比較 | C++26 |
+| [`operator!=`](mapping/op_equal.md) | 非等値比較 (`==`により使用可能) | C++26 |
 
 
 ## 例
@@ -120,8 +120,6 @@ int main()
 ```
 * linalg::layout_blas_packed[color ff0000]
 * LayoutPacked::mapping[color ff0000]
-* linalg::upper_triangle_t[link upper_triangle_t.md.nolink]
-* linalg::row_major_t[link row_major_t.md.nolink]
 * mat.extent[link /reference/mdspan/mdspan/extent.md]
 * std::print[link /reference/print/print.md]
 * std::println[link /reference/print/println.md]
@@ -151,4 +149,3 @@ int main()
 
 ## 参照
 - [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
-- [P1674R2: Evolving a Standard C++ Linear Algebra Library from the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1674r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_blas_packed/mapping/op_call.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_blas_packed/mapping/op_call.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_blas_packed/mapping/op_call.md b/reference/linalg/layout_blas_packed/mapping/op_call.md
new file mode 100644
index 000000000..f19ba3761
--- /dev/null
+++ b/reference/linalg/layout_blas_packed/mapping/op_call.md
@@ -0,0 +1,81 @@
+# operator()
+* linalg[meta header]
+* function template[meta id-type]
+* std::linalg[meta namespace]
+* layout_blas_packed::mapping[meta class]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class Index0, class Index1&amp;gt;
+constexpr index_type operator() (Index0 ind0, Index1 ind1) const noexcept;
+```
+
+## 概要
+2次元インデクス値`ind0, ind1`に対応する要素位置を求める。
+
+
+## テンプレートパラメータ制約
+- [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;Index0, index_type&amp;gt; == true`
+- [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;Index1, index_type&amp;gt; == true`
+- [`is_nothrow_convertible_v`](/reference/type_traits/is_nothrow_convertible.md)`&amp;lt;index_type, Index0&amp;gt; == true`
+- [`is_nothrow_convertible_v`](/reference/type_traits/is_nothrow_convertible.md)`&amp;lt;index_type, Index1&amp;gt; == true`
+
+
+## 事前条件
+`i`を[`extents_type::index-cast`](/reference/mdspan/extents/index-cast.md)`(ind0)`、`j`を[`extents_type::index-cast`](/reference/mdspan/extents/index-cast.md)`(ind1)`としたとき、2次元インデクス値`i, j`は多次元配列サイズ`extents_`における有効なインデクスであること。
+
+
+## 戻り値
+`N`を[`extetns_.extent`](/reference/mdspan/extents/extent.md)`(0)`としたとき
+- `i &amp;gt; j`ならば`(*this)(j, i)`、そうでなければ
+- 下記いずれの条件を満たすならば`i + j * (j + 1)/2`、そうでなければ
+    - [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;StorageOrder, column_major_t&amp;gt; &amp;amp;&amp;amp;` [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;Triangle, upper_triangle_t&amp;gt;`が`true`または
+    - [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;StorageOrder, row_major_t&amp;gt; &amp;amp;&amp;amp;` [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;Triangle, lower_triangle_t&amp;gt;`が`true`
+- `j + N * i - i * (i + 1)/2`
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;linalg&amp;gt;
+namespace linalg = std::linalg;
+
+int main()
+{
+  using Ext3x3 = std::extents&amp;lt;size_t, 3, 3&amp;gt;;
+  linalg::layout_blas_packed&amp;lt;linalg::lower_triangle_t, linalg::column_major_t&amp;gt;::mapping&amp;lt;Ext3x3&amp;gt; map;
+  // 0 1 2
+  // 1 3 4
+  // 2 4 5
+  assert(map(0, 0) == 0);
+  assert(map(0, 1) == 1);
+  assert(map(2, 1) == 4);
+}
+```
+* mapping[color ff0000]
+* linalg::layout_blas_packed[link ../../layout_blas_packed.md]
+
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_blas_packed/mapping/op_constructor.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_blas_packed/mapping/op_constructor.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_blas_packed/mapping/op_constructor.md b/reference/linalg/layout_blas_packed/mapping/op_constructor.md
new file mode 100644
index 000000000..12c90f3e7
--- /dev/null
+++ b/reference/linalg/layout_blas_packed/mapping/op_constructor.md
@@ -0,0 +1,111 @@
+# コンストラクタ
+* linalg[meta header]
+* function[meta id-type]
+* std::linalg[meta namespace]
+* layout_blas_packed::mapping[meta class]
+* cpp26[meta cpp]
+
+```cpp
+constexpr mapping() noexcept = default; // (1)
+
+constexpr mapping(const mapping&amp;amp;) noexcept = default; // (2)
+
+constexpr mapping(const extents_type&amp;amp;) noexcept; // (3)
+
+template&amp;lt;class OtherExtents&amp;gt;
+constexpr explicit(!is_convertible_v&amp;lt;OtherExtents, extents_type&amp;gt;)
+  mapping(const mapping&amp;lt;OtherExtents&amp;gt;&amp;amp; other) noexcept; // (4)
+```
+
+## 概要
+- (1) : デフォルトコンストラクタ
+- (2) : コピーコンストラクタ
+- (3) : [`extents`](/reference/mdspan/extents.md)からの変換コンストラクタ
+- (4) : 他`mapping`からの変換コンストラクタ
+
+
+## テンプレートパラメータ制約
+- (4) : [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;extents_type, OtherExtents&amp;gt;`
+
+
+## 事前条件
+- (3) :
+    - Nを`e.extent(0)`としたとき、N * (N + 1)を`index_type`型で表現できること。
+    - `e.extent(0) == e.extent(1)`
+- (4) :
+    - Nを`other.extents().extent(0)`としたとき、N * (N + 1)を`index_type`型で表現できること。
+
+
+## 効果
+- (3) : `e`を用いて`extents_`を直接非リスト初期化する。
+- (4) : `other.extetns()`を用いて`extents_`を直接非リスト初期化する。
+
+
+## 例外
+投げない
+
+
+## explicitになる条件
+- (4) : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;OtherExtents, extents_type&amp;gt;`
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;linalg&amp;gt;
+namespace linalg = std::linalg;
+
+using LayoutPacked = linalg::layout_blas_packed&amp;lt;linalg::lower_triangle_t, linalg::column_major_t&amp;gt;
+using Ext3x3 = std::extents&amp;lt;size_t, 3, 3&amp;gt;;
+using ExtNxN = std::dextents&amp;lt;size_t, 2&amp;gt;;
+
+int main()
+{
+  // (1) : デフォルトコンストラクタ
+  {
+    LayoutPacked::mapping&amp;lt;Ext3x3&amp;gt; map1;
+    assert(map1.required_span_size() == 6);
+  }
+  // (2) : コピーコンストラクタ
+  {
+    LayoutPacked::mapping&amp;lt;Ext3x3&amp;gt; map2_a;
+    LayoutPacked::mapping&amp;lt;Ext3x3&amp;gt; map2_b = map2_a;
+    assert(map2_a == map2_b);
+  }
+  // (3) : extentsからの変換コンストラクタ
+  {
+    ExtNxN ext{3, 3};
+    LayoutPacked::mapping&amp;lt;ExtNxN&amp;gt; map3 = ext;
+    assert(map3.extents() == ext);
+  }
+  // (4) : 他mappingからの変換コンストラクタ
+  {
+    LayoutPacked::mapping&amp;lt;Ext3x3&amp;gt; map4_a;
+    LayoutPacked::mapping&amp;lt;ExtNxN&amp;gt; map4_b = map4_a;
+    assert(map4_a == map4_b);
+  }
+}
+```
+* mapping[color ff0000]
+* linalg::layout_blas_packed[link ../../layout_blas_packed.md]
+
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_blas_packed/mapping/op_equal.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_blas_packed/mapping/op_equal.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_blas_packed/mapping/op_equal.md b/reference/linalg/layout_blas_packed/mapping/op_equal.md
new file mode 100644
index 000000000..e5cc2fc3b
--- /dev/null
+++ b/reference/linalg/layout_blas_packed/mapping/op_equal.md
@@ -0,0 +1,69 @@
+# operator==
+* linalg[meta header]
+* function template[meta id-type]
+* std::linalg[meta namespace]
+* layout_blas_packed::mapping[meta class]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class OtherExtents&amp;gt;
+friend constexpr bool
+  operator==(const mapping&amp;amp; x, const mapping&amp;lt;OtherExtents&amp;gt;&amp;amp; y) noexcept;
+
+//operator==により、以下のオーバーロードが使用可能になる        
+template&amp;lt;class OtherExtents&amp;gt;
+friend constexpr bool
+  operator!=(const mapping&amp;amp; x, const mapping&amp;lt;OtherExtents&amp;gt;&amp;amp; y) noexcept;
+```
+
+## 概要
+`mapping`の等値比較を行う。
+
+
+## 戻り値
+`x.extents() == y.extents()`
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;linalg&amp;gt;
+namespace linalg = std::linalg;
+
+int main()
+{
+  using LayoutPacked = linalg::layout_blas_packed&amp;lt;linalg::lower_triangle_t, linalg::column_major_t&amp;gt;;
+  using Ext3x3 = std::extents&amp;lt;size_t, 3, 3&amp;gt;;
+  using ExtNxN = std::dextents&amp;lt;size_t, 2&amp;gt;;
+  LayoutPacked::mapping&amp;lt;Ext3x3&amp;gt; map1;
+  LayoutPacked::mapping&amp;lt;ExtNxN&amp;gt; map2{ExtNxN{3, 3}};
+  assert(map1 == map2);
+}
+```
+* mapping[color ff0000]
+* linalg::layout_blas_packed[link ../../layout_blas_packed.md]
+
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>required_span_size -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_blas_packed/mapping/required_span_size.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_blas_packed/mapping/required_span_size.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_blas_packed/mapping/required_span_size.md b/reference/linalg/layout_blas_packed/mapping/required_span_size.md
new file mode 100644
index 000000000..5eceaf35b
--- /dev/null
+++ b/reference/linalg/layout_blas_packed/mapping/required_span_size.md
@@ -0,0 +1,59 @@
+# required_span_size
+* linalg[meta header]
+* function[meta id-type]
+* std::linalg[meta namespace]
+* layout_blas_packed::mapping[meta class]
+* cpp26[meta cpp]
+
+```cpp
+constexpr index_type required_span_size() const noexcept;
+```
+
+## 概要
+メモリブロックに対する要素アクセス範囲を取得する。
+
+
+## 戻り値
+[`extents_.extent`](/reference/mdspan/extents/extent.md)`(0) * (`[`extents_.extent`](/reference/mdspan/extents/extent.md)`(0) + 1)/2`
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;linalg&amp;gt;
+namespace linalg = std::linalg;
+
+int main()
+{
+  using Ext5x5 = std::extents&amp;lt;size_t, 5, 5&amp;gt;;
+  linalg::layout_blas_packed&amp;lt;linalg::lower_triangle_t, linalg::column_major_t&amp;gt;::mapping&amp;lt;Ext5x5&amp;gt; map;
+  assert(map.required_span_size() == 15);
+}
+```
+* required_span_size()[color ff0000]
+* linalg::layout_blas_packed[link ../../layout_blas_packed.md]
+
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>layout_transpose -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_transpose.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_transpose.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_transpose.md b/reference/linalg/layout_transpose.md
index 0db977228..33e6a26fb 100644
--- a/reference/linalg/layout_transpose.md
+++ b/reference/linalg/layout_transpose.md
@@ -26,7 +26,7 @@ namespace std::linalg {
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
 | `nested_layout_type` | `Layout` | C++26 |
-| [`mapping`](layout_transpose/mapping.md.nolink) | レイアウトマッピング | C++26 |
+| [`mapping`](layout_transpose/mapping.md) | レイアウトマッピング (class template) | C++26 |
 
 
 ## バージョン
@@ -42,6 +42,7 @@ namespace std::linalg {
 
 ## 関連項目
 - [`mdspan`](/reference/mdspan/mdspan.md)
+- [`transpose`](transpose.md.nolink)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mapping -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_transpose/mapping.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_transpose/mapping.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_transpose/mapping.md b/reference/linalg/layout_transpose/mapping.md
new file mode 100644
index 000000000..1f7b64928
--- /dev/null
+++ b/reference/linalg/layout_transpose/mapping.md
@@ -0,0 +1,104 @@
+# mapping
+* linalg[meta header]
+* class template[meta id-type]
+* std::linalg[meta namespace]
+* layout_transpose[meta class]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::linalg {
+  template&amp;lt;class Layout&amp;gt;
+  class layout_transpose {
+    template&amp;lt;class Extents&amp;gt;
+    struct mapping;
+  };
+}
+```
+* layout_transpose[link ../layout_transpose.md]
+* Extents[link /reference/mdspan/extents.md]
+
+## 概要
+`layout_transpose::mapping`は、任意の[レイアウトマッピングポリシー](/reference/mdspan/LayoutMappingPolicy.md)に対して行列転置操作を行った[レイアウトマッピング](/reference/mdspan/LayoutMapping.md)を表現するクラスである。
+
+### 説明専用メンバ
+説明専用メンバ型`nested-mapping-type`を`Layout::mapping&amp;lt;transpose-extents-t&amp;lt;Extents&amp;gt;&amp;gt;`とする。
+
+`layout_transpose::mapping`クラステンプレートは、下記の説明専用メンバ変数を保持する。
+
+- `nested-mapping_` : `nested-mapping-type`型の入れ子[レイアウトマッピング](/reference/mdspan/LayoutMapping.md)
+- `extents_` : `extents_type`型の[多次元配列サイズ情報](/reference/mdspan/extents.md)
+
+
+## 適格要件
+- `Extents`は[`extents`](/reference/mdspan/extents.md)の特殊化であること
+- [`Extents::rank()`](/reference/mdspan/extents/rank.md) `== 2`
+
+
+## メンバ関数
+### 構築・破棄
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`(constructor)`](mapping/op_constructor.md) | コンストラクタ | C++26 |
+| `(destructor)` | デストラクタ | C++26 |
+
+### 観測
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| `extents` | 多次元配列のサイズ`extents_`を取得する | C++26 |
+| `required_span_size` | `nested-mapping_.required_span_size()` | C++26 |
+| [`operator()`](mapping/op_call.md) | 多次元配列インデクスから要素位置へ変換する | C++26 |
+| `nested_mapping` | 入れ子レイアウトマッピング`nested-mapping_`を取得する　| C++26 |
+| [`stride`](mapping/stride.md) | 指定次元のストライド幅を取得する | C++26 |
+| `is_unique`     | `nested-mapping_.is_unique()` | C++26 |
+| `is_exhaustive` | `nested-mapping_.is_exhaustive()` | C++26 |
+| `is_strided`    | `nested-mapping_.is_strided()` | C++26 |
+
+
+## 静的メンバ関数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| `is_always_unique`     | `nested-mapping-type::is_always_unique` | C++26 |
+| `is_always_exhaustive` | `nested-mapping-type::is_always_exhaustive` | C++26 |
+| `is_always_strided`    | `nested-mapping-type::is_always_strided` | C++26 |
+
+
+## メンバ型
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| `extents_type` | [`Extents`](/reference/mdspan/extents.md) | C++26 |
+| `index_type` | [`Extents::index_type`](/reference/mdspan/extents.md) | C++26 |
+| `size_type` | [`Extents::size_type`](/reference/mdspan/extents.md) | C++26 |
+| `rank_type` | [`Extents::rank_type`](/reference/mdspan/extents.md) | C++26 |
+| `layout_type` | [`layout_transpose`](../layout_transpose.md) | C++26 |
+
+
+## 非メンバ（*Hidden friends*）関数
+### 比較演算子
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`operator==`](mapping/op_equal.md) | 等値比較 | C++26 |
+| [`operator!=`](mapping/op_equal.md) | 非等値比較 (`==`により使用可能) | C++26 |
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`transpose`](transpose.md.nolink)
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_transpose/mapping/op_call.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_transpose/mapping/op_call.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_transpose/mapping/op_call.md b/reference/linalg/layout_transpose/mapping/op_call.md
new file mode 100644
index 000000000..63e62f983
--- /dev/null
+++ b/reference/linalg/layout_transpose/mapping/op_call.md
@@ -0,0 +1,33 @@
+# operator()
+* linalg[meta header]
+* function template[meta id-type]
+* std::linalg[meta namespace]
+* layout_transpose::mapping[meta class]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class Index0, class Index1&amp;gt;
+constexpr index_type operator()(Index0 ind0, Index1 ind1) const;
+```
+
+## 概要
+2次元インデクス値`ind0, ind1`に対応する要素位置を求める。
+
+
+## 戻り値
+`nested-mapping_(ind1, ind0)`
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_transpose/mapping/op_constructor.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_transpose/mapping/op_constructor.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_transpose/mapping/op_constructor.md b/reference/linalg/layout_transpose/mapping/op_constructor.md
new file mode 100644
index 000000000..92a7781e1
--- /dev/null
+++ b/reference/linalg/layout_transpose/mapping/op_constructor.md
@@ -0,0 +1,32 @@
+# コンストラクタ
+* linalg[meta header]
+* function[meta id-type]
+* std::linalg[meta namespace]
+* layout_transpose::mapping[meta class]
+* cpp26[meta cpp]
+
+```cpp
+constexpr explicit mapping(const nested-mapping-type&amp;amp; map);
+```
+
+## 概要
+入れ子[レイアウトマッピング](/reference/mdspan/LayoutMapping.md)からの変換コンストラクタ
+
+
+## 効果
+説明専用メンバ`nested-mapping_`を`map`で、`extents_`を`transpose-extents(map.extents())`で初期化する。
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_transpose/mapping/op_equal.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_transpose/mapping/op_equal.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_transpose/mapping/op_equal.md b/reference/linalg/layout_transpose/mapping/op_equal.md
new file mode 100644
index 000000000..3dbadebe0
--- /dev/null
+++ b/reference/linalg/layout_transpose/mapping/op_equal.md
@@ -0,0 +1,43 @@
+# operator==
+* linalg[meta header]
+* function template[meta id-type]
+* std::linalg[meta namespace]
+* layout_transpose::mapping[meta class]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class OtherExtents&amp;gt;
+friend constexpr bool
+  operator==(const mapping&amp;amp; x, const mapping&amp;lt;OtherExtents&amp;gt;&amp;amp; y);
+
+//operator==により、以下のオーバーロードが使用可能になる        
+template&amp;lt;class OtherExtents&amp;gt;
+friend constexpr bool
+  operator!=(const mapping&amp;amp; x, const mapping&amp;lt;OtherExtents&amp;gt;&amp;amp; y);
+```
+
+## 概要
+`mapping`の等値比較を行う。
+
+
+## テンプレートパラメータ制約
+式`x.nested-mapping_ == y.nested-mapping_`が適格、かつ結果が`bool`に変換可能であること。
+
+
+## 戻り値
+`x.nested-mapping_ == y.nested-mapping_`
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stride -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/layout_transpose/mapping/stride.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/layout_transpose/mapping/stride.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/layout_transpose/mapping/stride.md b/reference/linalg/layout_transpose/mapping/stride.md
new file mode 100644
index 000000000..069cd3544
--- /dev/null
+++ b/reference/linalg/layout_transpose/mapping/stride.md
@@ -0,0 +1,36 @@
+# stride
+* linalg[meta header]
+* function[meta id-type]
+* std::linalg[meta namespace]
+* layout_transpose::mapping[meta class]
+* cpp26[meta cpp]
+
+```cpp
+constexpr index_type stride(size_t r) const;
+```
+
+## 概要
+`i`番目次元のストライド幅を取得する。
+
+
+## 事前条件
+`is_strided() == true`かつ`r &amp;lt; 2`
+
+
+## 戻り値
+`nested-mapping_.stride(r == 0 ? 1 : 0)`
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>row_major_t -- linalg: layout_* 個別メンバ(#1233)</title>
      <link href="https://cpprefjp.github.io/reference/linalg/row_major_t.html"/>
      <id>300f467b154fc15ab169574de793da0cacb92216:reference/linalg/row_major_t.md</id>
      <updated>2024-03-03T00:10:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/linalg/row_major_t.md b/reference/linalg/row_major_t.md
new file mode 100644
index 000000000..5ac84fc9f
--- /dev/null
+++ b/reference/linalg/row_major_t.md
@@ -0,0 +1,38 @@
+# row_major_t
+* linalg[meta header]
+* class[meta id-type]
+* std::linalg[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std::linalg {
+  struct row_major_t { explicit row_major_t() = default; };
+
+  inline constexpr row_major_t row_major{};
+}
+```
+
+## 概要
+`row_major_t`は、[`layout_blas_packed`](layout_blas_packed.md)を指定した多次元配列ビュー[`mdspan`](/reference/mdspan/mdspan.md)において、要素の格納順が行優先(row-major)であることを指示するためのタグ型である。
+
+`row_major_t`型の定数`row_major`が提供される。
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`mdspan`](/reference/mdspan/mdspan.md)
+- [`layout_blas_packed`](layout_blas_packed.md)
+
+
+## 参照
+- [P1673R13 A free function linear algebra interface based on the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1673r13.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 微修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>dd9230e50d7909b013e4930f029f7b252dc63d70:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-03-01T14:35:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index ac669ea6a..d6d4ceaa3 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -299,7 +299,7 @@ auto f10(J x) -&amp;gt; Widget&amp;amp; {
 
 ## この機能が必要になった背景・経緯
 
-C++20までは戻り値型が参照型である場合に暗黙ムーブが行われていなかった。より正確には、関数戻り値の初期化時に戻り値構築のためのコンストラクタを選択するオーバーロード解決が行われる場合にのみ、暗黙ムーブが考慮されていたが、戻り値型が参照型の場合は参照の初期化だけが起こりコンストラクタ呼び出しは関与しないため暗黙ムーブは考慮されていなかった。
+C++20までは戻り値型が参照型である場合に暗黙ムーブが行われていなかった。より正確には、関数戻り値の初期化時に初期化のためのコンストラクタを選択するオーバーロード解決が行われる場合にのみ、暗黙ムーブが考慮されていたが、戻り値型が参照型の場合は参照の初期化だけが起こりコンストラクタ呼び出しは関与しないため暗黙ムーブは考慮されていなかった。
 
 これによって、同じ`return`文でも戻り値型が異なることでそのオペランドの扱いが変化してしまっていた。
 
@@ -318,9 +318,7 @@ auto g(Widget&amp;amp;&amp;amp; w) -&amp;gt; Widget&amp;amp;&amp;amp; {
 
 この非一貫性を解消することがまず求められていた。
 
-また、C++20時点の暗黙ムーブの使用は二段階のオーバーロード解決を行う複雑なものであり、暗黙ムーブが行われるかどうかについて実装間で挙動に差異が生じていた。
-
-C++20の仕様は次のようになっていた。
+また、C++20時点の暗黙ムーブの使用は二段階のオーバーロード解決を行う複雑なものであり、暗黙ムーブが行われるかどうかについて実装間で挙動に差異が生じていた。C++20時点の暗黙ムーブの仕様は次のようになっていた
 
 暗黙ムーブ可能なエンティティが次のコピー初期化が行われる場所で指名されている場合、コピーの代わりにムーブが使用される場合がある
 
@@ -334,9 +332,9 @@ C++20の仕様は次のようになっていた。
 1. オペランドのid式を右辺値（*rvalue*）としてオーバーロード解決を実行する
 2. 1が失敗した（もしくは行われなかった）場合、オペランドのid式を左辺値（*lvalue*）としてオーバーロード解決を実行する
 
-この最後の手順の1回目のオーバーロード解決時にコピーコンストラクタの代わりにムーブコンストラクタが選択されることによって、C++20の暗黙ムーブは達成されていた。しかし、この手順2における「失敗」という言葉の意味が明確ではなく、それによって実装間で暗黙ムーブが行われるかどうか、あるいは選択されるコンストラクタに差異が生じていた。
+この最後の手順の1回目のオーバーロード解決時にコピーコンストラクタの代わりにムーブコンストラクタが選択されることによって、C++20の暗黙ムーブは実行される。しかし、この手順における「失敗」という言葉の意味が明確ではなく、それによって実装間で暗黙ムーブが行われるかどうか、あるいは選択されるコンストラクタに差異が生じていた。
 
-`return`文オペランドの扱いの戻り値型の違いによる非一貫性と、使用の複雑さと曖昧さによる実装間の差異の2つの問題を解決するために、C++23ではムーブする資格がある式という概念を用いて暗黙ムーブの仕様が単純化された。
+`return`文オペランドの扱いの戻り値型の違いによる非一貫性と、仕様の複雑さと曖昧さによる実装間の差異の2つの問題を解決するために、C++23ではムーブする資格がある式という概念を用いて暗黙ムーブの仕様が単純化された。
 
 ## 参照
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 不可視文字の削除</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>c4b15eaed4ad336a858490578ffbb2bd63907a59:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-03-01T14:13:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index dc7b5733b..ac669ea6a 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -329,7 +329,7 @@ C++20の仕様は次のようになっていた。
 - `throw`式のオペランド
     - （諸条件はC++23仕様と同一なので省略）
 
-これらのコピー初期化が行われる場所において、呼び出されるコンストラクタまたは[`return_­value()`オーバーロード](/lang/cpp20/coroutines.md)を選択するオーバーロード解決は次の順序で実行される
+これらのコピー初期化が行われる場所において、呼び出されるコンストラクタまたは[`return_value()`オーバーロード](/lang/cpp20/coroutines.md)を選択するオーバーロード解決は次の順序で実行される
 
 1. オペランドのid式を右辺値（*rvalue*）としてオーバーロード解決を実行する
 2. 1が失敗した（もしくは行われなかった）場合、オペランドのid式を左辺値（*lvalue*）としてオーバーロード解決を実行する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>暗黙的なムーブを簡略化 -- 暗黙ムーブ : 経緯を追加 #1021</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.html"/>
      <id>8384e0bb49cce5acc30eca4215df91ecd554eddb:lang/cpp23/simpler_implicit_move.md</id>
      <updated>2024-03-01T12:46:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/simpler_implicit_move.md b/lang/cpp23/simpler_implicit_move.md
index f61ff2f24..dc7b5733b 100644
--- a/lang/cpp23/simpler_implicit_move.md
+++ b/lang/cpp23/simpler_implicit_move.md
@@ -207,6 +207,20 @@ auto g(bool b) -&amp;gt; Weird {
 }
 ```
 
+```cpp
+// ムーブしないことを明示する関数、C++20までは使用可能
+template&amp;lt;typename T&amp;gt;
+auto unmove(T&amp;amp;&amp;amp; v) -&amp;gt; T&amp;amp; {
+  return v; // C++23からng、vはxvalue
+}
+
+// C++23では次のように修正する必要がある
+template&amp;lt;typename T&amp;gt;
+auto unmove(T&amp;amp;&amp;amp; v) -&amp;gt; T&amp;amp; {
+  return static_cast&amp;lt;T&amp;amp;&amp;gt;(v); // ok、キャスト式はムーブする資格のある式ではない
+}
+```
+
 ```cpp
 // 例示用のムーブ可能な型
 struct Widget {
@@ -284,15 +298,48 @@ auto f10(J x) -&amp;gt; Widget&amp;amp; {
 ```
 
 ## この機能が必要になった背景・経緯
-(執筆中)
 
-## 検討されたほかの選択肢
-(執筆中)
+C++20までは戻り値型が参照型である場合に暗黙ムーブが行われていなかった。より正確には、関数戻り値の初期化時に戻り値構築のためのコンストラクタを選択するオーバーロード解決が行われる場合にのみ、暗黙ムーブが考慮されていたが、戻り値型が参照型の場合は参照の初期化だけが起こりコンストラクタ呼び出しは関与しないため暗黙ムーブは考慮されていなかった。
+
+これによって、同じ`return`文でも戻り値型が異なることでそのオペランドの扱いが変化してしまっていた。
+
+```cpp
+// Widget, RRefTakerは上の例を参照
+// どちらも、C++20の場合
+
+auto f(Widget&amp;amp;&amp;amp; w) -&amp;gt; RRefTaker {
+  return w;  // ok、wは右辺値として扱われる
+}
+
+auto g(Widget&amp;amp;&amp;amp; w) -&amp;gt; Widget&amp;amp;&amp;amp; {
+  return w;  // ng、wは左辺値として扱われる
+}
+```
+
+この非一貫性を解消することがまず求められていた。
+
+また、C++20時点の暗黙ムーブの使用は二段階のオーバーロード解決を行う複雑なものであり、暗黙ムーブが行われるかどうかについて実装間で挙動に差異が生じていた。
+
+C++20の仕様は次のようになっていた。
+
+暗黙ムーブ可能なエンティティが次のコピー初期化が行われる場所で指名されている場合、コピーの代わりにムーブが使用される場合がある
+
+- `return/co_return`文のオペランド
+    - （諸条件はC++23仕様と同一なので省略）
+- `throw`式のオペランド
+    - （諸条件はC++23仕様と同一なので省略）
+
+これらのコピー初期化が行われる場所において、呼び出されるコンストラクタまたは[`return_­value()`オーバーロード](/lang/cpp20/coroutines.md)を選択するオーバーロード解決は次の順序で実行される
+
+1. オペランドのid式を右辺値（*rvalue*）としてオーバーロード解決を実行する
+2. 1が失敗した（もしくは行われなかった）場合、オペランドのid式を左辺値（*lvalue*）としてオーバーロード解決を実行する
+
+この最後の手順の1回目のオーバーロード解決時にコピーコンストラクタの代わりにムーブコンストラクタが選択されることによって、C++20の暗黙ムーブは達成されていた。しかし、この手順2における「失敗」という言葉の意味が明確ではなく、それによって実装間で暗黙ムーブが行われるかどうか、あるいは選択されるコンストラクタに差異が生じていた。
 
-## 関連項目
-(執筆中)
+`return`文オペランドの扱いの戻り値型の違いによる非一貫性と、使用の複雑さと曖昧さによる実装間の差異の2つの問題を解決するために、C++23ではムーブする資格がある式という概念を用いて暗黙ムーブの仕様が単純化された。
 
 ## 参照
 
 - [P2266R3 Simpler implicit move](https://wg21.link/p2266r3)
-- [The Complete Guide to `return x;` - Arthur O&amp;#39;Dwyer - [CppNow 2021] - YouTube](https://www.youtube.com/watch?v=OGKAJD7bmr8)
\ No newline at end of file
+- [The Complete Guide to `return x;` - Arthur O&amp;#39;Dwyer - [CppNow 2021] - YouTube](https://www.youtube.com/watch?v=OGKAJD7bmr8)
+- [c++ - Does c++23 break unmove - Stack Overflow](https://stackoverflow.com/questions/76647046/does-c23-break-unmove)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>const_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/const_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/const_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/const_pointer_cast.md b/reference/memory/shared_ptr/const_pointer_cast.md
index 6df15cd64..628c1ad98 100644
--- a/reference/memory/shared_ptr/const_pointer_cast.md
+++ b/reference/memory/shared_ptr/const_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(const_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dynamic_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/dynamic_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/dynamic_pointer_cast.md b/reference/memory/shared_ptr/dynamic_pointer_cast.md
index aa1c77dff..ae416865b 100644
--- a/reference/memory/shared_ptr/dynamic_pointer_cast.md
+++ b/reference/memory/shared_ptr/dynamic_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(dynamic_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reinterpret_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/reinterpret_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/reinterpret_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/reinterpret_pointer_cast.md b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
index 9054ca33f..81c9ba5c2 100644
--- a/reference/memory/shared_ptr/reinterpret_pointer_cast.md
+++ b/reference/memory/shared_ptr/reinterpret_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(reinterpret_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>static_pointer_cast -- Merge pull request #1258 from ToruNiina/typo-undefined-behavior</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/static_pointer_cast.html"/>
      <id>4a58c6b16d2774d44468b081cca3e1c8eecb092b:reference/memory/shared_ptr/static_pointer_cast.md</id>
      <updated>2024-03-01T00:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/static_pointer_cast.md b/reference/memory/shared_ptr/static_pointer_cast.md
index 5514da616..9bed817c3 100644
--- a/reference/memory/shared_ptr/static_pointer_cast.md
+++ b/reference/memory/shared_ptr/static_pointer_cast.md
@@ -35,7 +35,7 @@ namespace std {
 
 
 ## 備考
-- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は動作未定義となるので使用しないこと。
+- `shared_ptr&amp;lt;T&amp;gt;(static_cast&amp;lt;T*&amp;gt;(r.get()))` という方法は未定義動作となるので使用しないこと。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>