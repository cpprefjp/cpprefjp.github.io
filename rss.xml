<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-01-22T07:06:19.506904</updated>
  <id>81e7d44e-f752-46cb-a974-449ee3214773</id>

  
    <entry>
      <title>adjacent_find -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
index 622ddb3b2..13e149535 100644
--- a/reference/algorithm/ranges_adjacent_find.md
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -71,7 +71,7 @@ found: index==2
 ```cpp
 struct adjacent_find_impl {
   template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr I adjacent_find(I first, S last, Pred pred = {}, Proj proj = {}) {
+  constexpr I operator()(I first, S last, Pred pred = {}, Proj proj = {}) const {
     if (first == last)
       return last;
 
@@ -84,7 +84,7 @@ struct adjacent_find_impl {
   }
 
   template&amp;lt;forward_range R, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>all_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_all_of.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_all_of.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_all_of.md b/reference/algorithm/ranges_all_of.md
index 146c1d15e..da98f8ef5 100644
--- a/reference/algorithm/ranges_all_of.md
+++ b/reference/algorithm/ranges_all_of.md
@@ -70,14 +70,14 @@ false
 ```cpp
 struct all_of_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for (; first != last; ++first)
       if (!invoke(pred, invoke(proj, *first))) return false;
     return true;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>any_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_any_of.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_any_of.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_any_of.md b/reference/algorithm/ranges_any_of.md
index dea211956..e4386d795 100644
--- a/reference/algorithm/ranges_any_of.md
+++ b/reference/algorithm/ranges_any_of.md
@@ -72,14 +72,14 @@ true
 ```cpp
 struct any_of_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first))) return true;
     return false;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_count.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index 748e65a72..f0ed20105 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -71,7 +71,7 @@ count of 1: 3
 struct count_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
+  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) const {
     iter_difference_t&amp;lt;I&amp;gt; count = 0;
     for ( ; first != last; ++first)
       if (value == invoke(proj, *first)) count++;
@@ -80,7 +80,7 @@ struct count_impl {
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
+  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) const {
     return (*this)(begin(r), end(r), value, ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_count_if.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 8168a5098..b4aa6c9be 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -71,7 +71,7 @@ count of 1 or 3: 5
 ```cpp
 struct count_if_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, Pred pred, Proj proj = {}) const {
     iter_difference_t&amp;lt;I&amp;gt; count = 0;
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first))) count++;
@@ -79,7 +79,7 @@ struct count_if_impl {
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_equal.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
index 06dd47a12..b1faa1bda 100644
--- a/reference/algorithm/ranges_equal.md
+++ b/reference/algorithm/ranges_equal.md
@@ -78,7 +78,7 @@ true
 struct equal_impl {
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr bool operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     if constexpr (sized_sentinel_for&amp;lt;S1, I1&amp;gt; &amp;amp;&amp;amp; sized_sentinel_for&amp;lt;S2, I2&amp;gt;)
       if (distance(first1, last1) != distance(first2, last2))
         return false;
@@ -90,7 +90,7 @@ struct equal_impl {
 
   template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr bool operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr bool operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 0bf006583..1bb8378f9 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -65,7 +65,7 @@ found: 1
 struct find_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-  constexpr I operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
+  constexpr I operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (*first == value) return first;
     return last;
@@ -73,7 +73,7 @@ struct find_impl {
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
     requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) const {
     return (*this)(begin(r), end(r), value, ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find_end.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
index ec3bc16d8..d229238c8 100644
--- a/reference/algorithm/ranges_find_end.md
+++ b/reference/algorithm/ranges_find_end.md
@@ -70,7 +70,7 @@ found: index==2
 struct find_end_impl {
   template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     if (first2 == last2)
       return last1;
     I1 result = last1;
@@ -83,7 +83,7 @@ struct find_end_impl {
 
   template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index b8b5c40e5..03fb751ac 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -75,7 +75,7 @@ found: index==3, value==4
 struct find_first_of_impl {
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr I1 operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr I1 operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     for ( ; first1 != last1; ++first1)
       for (I2 it = first2; it != last2; ++it)
         if (invoke(pred, invoke(proj1, *first1), invoke(proj2, *it))) return first1;
@@ -84,7 +84,7 @@ struct find_first_of_impl {
 
   template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find_if.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
index d66779145..c2181730f 100644
--- a/reference/algorithm/ranges_find_if.md
+++ b/reference/algorithm/ranges_find_if.md
@@ -63,14 +63,14 @@ found: 1
 ```cpp
 struct find_if_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first)))
         return first;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate &amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
index 5b3b75fd3..b92565a21 100644
--- a/reference/algorithm/ranges_find_if_not.md
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -63,14 +63,14 @@ found: 1
 ```cpp
 struct find_if_not_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (!invoke(pred, invoke(proj, *first)))
         return first;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate &amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_for_each.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each.md b/reference/algorithm/ranges_for_each.md
index 9e7a54315..6837a0f22 100644
--- a/reference/algorithm/ranges_for_each.md
+++ b/reference/algorithm/ranges_for_each.md
@@ -106,7 +106,7 @@ int main() {
 struct for_each_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
     requires copy_constructible&amp;lt;Fun&amp;gt;
-  constexpr for_each_result&amp;lt;I, Fun&amp;gt; operator()(I first, S last, Fun f, Proj proj = {}) {
+  constexpr for_each_result&amp;lt;I, Fun&amp;gt; operator()(I first, S last, Fun f, Proj proj = {}) const {
     for (; first != last; ++first) {
       invoke(f, invoke(proj, *first));
     }
@@ -115,7 +115,7 @@ struct for_each_impl {
 
   template&amp;lt;input_range R, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Fun&amp;gt;
     requires copy_constructible&amp;lt;Fun&amp;gt;
-  constexpr for_each_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, Fun&amp;gt; operator()(R&amp;amp;&amp;amp; r, Fun f, Proj proj = {}) {
+  constexpr for_each_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, Fun&amp;gt; operator()(R&amp;amp;&amp;amp; r, Fun f, Proj proj = {}) const {
     return (*this)(begin(r), end(r), move(f), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index 7f8aaa302..29560990c 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -91,7 +91,7 @@ int main()
 struct for_each_n_impl {
   template&amp;lt;input_iterator I, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
     requires copy_constructible&amp;lt;Fun&amp;gt;
-  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; operator()(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {}) {
+  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; operator()(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {}) const {
     for (iter_difference_t&amp;lt;I&amp;gt; i = 0; i &amp;lt; n; ++i) {
       invoke(f, invoke(proj, *first));
       ++first;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_mismatch.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index 3f7e70a58..fc2907d51 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -110,7 +110,7 @@ mismatch value: (end,2)
 struct mismatch_impl {
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr ranges::mismatch_result&amp;lt;I1, I2&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr ranges::mismatch_result&amp;lt;I1, I2&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     for ( ; first1 != last1 &amp;amp;&amp;amp; first != last2; ++first1, ++first2)
       if (!bool(invoke(pred, invoke(proj1, *first1), invoke(proj2, *first2))))
         return {first1, first2};
@@ -119,7 +119,7 @@ struct mismatch_impl {
 
   template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>none_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_none_of.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_none_of.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_none_of.md b/reference/algorithm/ranges_none_of.md
index ca86e2667..565f38ae2 100644
--- a/reference/algorithm/ranges_none_of.md
+++ b/reference/algorithm/ranges_none_of.md
@@ -84,14 +84,14 @@ true
 ```cpp
 struct none_of_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const {
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first))) return false;
     return true;
   }
 
   template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+  constexpr bool operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) const {
     return (*this)(begin(r), end(r), ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_search.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index c5fcd40e1..da4d59038 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -74,7 +74,7 @@ struct search_impl {
   template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
   sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     for ( ; first1 != last1; ++first1) {
       I1 p1 = first1;
       I2 p2 = first2;
@@ -89,7 +89,7 @@ struct search_impl {
 
   template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search_n -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search_n.html"/>
      <id>933a824a6adc68e8a7ad7f819ba50258dcb7fff6:reference/algorithm/ranges_search_n.md</id>
      <updated>2022-01-22T16:02:04+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search_n.md b/reference/algorithm/ranges_search_n.md
index 60dbcc95f..738defe83 100644
--- a/reference/algorithm/ranges_search_n.md
+++ b/reference/algorithm/ranges_search_n.md
@@ -83,7 +83,7 @@ found: index==0
 struct search_n_impl {
   template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I, const T*, Pred, Proj&amp;gt;
-  constexpr subrange&amp;lt;I&amp;gt; operator()(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) {
+  constexpr subrange&amp;lt;I&amp;gt; operator()(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) const {
     if (first == last || count &amp;lt;= 0)
       return first;
 
@@ -107,7 +107,7 @@ struct search_n_impl {
 
   template&amp;lt;forward_range R, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T*, Pred, Proj&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) {
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) const {
     return (*this)(begin(r1), end(r1), count, value, ref(pred), ref(proj));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ends_with -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_ends_with.html"/>
      <id>ccb471ae54bd284f720fcc7d99f632b02db90e72:reference/algorithm/ranges_ends_with.md</id>
      <updated>2022-01-22T15:57:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_ends_with.md b/reference/algorithm/ranges_ends_with.md
index 15fe0518f..84cd76c80 100644
--- a/reference/algorithm/ranges_ends_with.md
+++ b/reference/algorithm/ranges_ends_with.md
@@ -113,6 +113,7 @@ inline constexpr ends_with_impl ends_with;
 * forward_range[link /reference/ranges/forward_range.md]
 * sized_range[link /reference/ranges/sized_range.md]
 * iterator_t[link /reference/ranges/iterator_t.md]
+* distance[link /reference/iterator/distance.md]
 * equal[link ranges_equal.md]
 * drop_view[link /reference/ranges/drop_view.md]
 * ref_view[link /reference/ranges/ref_view.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::starts_with/ends_withを追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>0f3a18e43a04e4aa44394772384c43d669884ff8:reference/algorithm.md</id>
      <updated>2022-01-22T14:52:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 4dc8bf17e..872da4fe4 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -137,8 +137,8 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::equal`](algorithm/ranges_equal.md)                 | 2つの範囲を等値比較する                              | C++20 |
 | [`ranges::search`](algorithm/ranges_search.md)               | 指定された最初のサブシーケンスを検索する             | C++20 |
 | [`ranges::search_n`](algorithm/ranges_search_n.md)           | 指定された最初のサブシーケンスを検索する             | C++20 |
-| [`ranges::starts_with`](algorithm/ranges_starts_with.md.nolink)     | 先頭が指定されたシーケンスと一致するかを調べる       | C++23 |
-| [`ranges::ends_with`](algorithm/ranges_ends_with.md.nolink)         | 末尾が指定されたシーケンスと一致するかを調べる       | C++23 |
+| [`ranges::starts_with`](algorithm/ranges_starts_with.md)     | 先頭が指定されたシーケンスと一致するかを調べる       | C++23 |
+| [`ranges::ends_with`](algorithm/ranges_ends_with.md)         | 末尾が指定されたシーケンスと一致するかを調べる       | C++23 |
 
 ## シーケンスを変更する操作
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ends_with -- ranges::starts_with/ends_withを追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_ends_with.html"/>
      <id>0f3a18e43a04e4aa44394772384c43d669884ff8:reference/algorithm/ranges_ends_with.md</id>
      <updated>2022-01-22T14:52:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_ends_with.md b/reference/algorithm/ranges_ends_with.md
new file mode 100644
index 000000000..15fe0518f
--- /dev/null
+++ b/reference/algorithm/ranges_ends_with.md
@@ -0,0 +1,132 @@
+# ends_with
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires (forward_iterator&amp;lt;I1&amp;gt; || sized_sentinel_for&amp;lt;S1, I1&amp;gt;) &amp;amp;&amp;amp;
+             (forward_iterator&amp;lt;I2&amp;gt; || sized_sentinel_for&amp;lt;S2, I2&amp;gt;) &amp;amp;&amp;amp;
+             indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires (forward_range&amp;lt;R1&amp;gt; || sized_range&amp;lt;R1&amp;gt;) &amp;amp;&amp;amp;
+             (forward_range&amp;lt;R2&amp;gt; || sized_range&amp;lt;R2&amp;gt;) &amp;amp;&amp;amp;
+             indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool ends_with(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+* identity[link /reference/functional/identity.md]
+* indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* sized_range[link /reference/ranges/sized_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+
+## 概要
+シーケンスの末尾が指定されたシーケンスと一致するかを調べる
+
+## 戻り値
+
+* (1): 
+    * `N1 = last1 - first1`, `N2 = last2 - first2` とする。
+    * `N1 &amp;lt; N2` のとき、`false`
+    * それ以外のとき、[`ranges::equal`](ranges_equal.md)`(`[`std::move`](/reference/utility/move.md)`(first1) + (N1 - N2), last1, `[`std::move`](/reference/utility/move.md)`(first2), last2, pred, proj1, proj2)`
+* (2): 
+    * `N1 = `[`ranges::distance`](/reference/iterator/ranges_distance.md)`(r1)`, `N2 = `[`ranges::distance`](/reference/iterator/ranges_distance.md)`(r2)` とする。
+    * `N1 &amp;lt; N2` のとき、`false`
+    * それ以外のとき、[`ranges::equal`](ranges_equal.md)`(`[`ranges::drop_view`](/reference/ranges/drop_view.md)`(`[`ranges::ref_view`](/reference/ranges/ref_view.md)`(r1), N1 - N2), r2, pred, proj1, proj2)`
+
+
+## 計算量
+最大で `N2` 回の対応する述語が適用される。
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  const std::vector v  = { 1,2,3,4,5,6 };
+  const std::vector v1 = { 1,2,3 };
+  const std::vector v2 = { 4,5,6 };
+
+  std::cout &amp;lt;&amp;lt; std::ranges::ends_with(v1, v) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::ends_with(v, v1) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::ends_with(v, v2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::ends_with[color ff0000]
+
+### 出力
+```
+0
+0
+1
+```
+
+
+## 実装例
+```cpp
+struct ends_with_impl {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires (forward_iterator&amp;lt;I1&amp;gt; || sized_sentinel_for&amp;lt;S1, I1&amp;gt;) &amp;amp;&amp;amp;
+             (forward_iterator&amp;lt;I2&amp;gt; || sized_sentinel_for&amp;lt;S2, I2&amp;gt;) &amp;amp;&amp;amp;
+             indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
+    const auto N1 = distance(first1, last1);
+    const auto N2 = distance(first2, last2);
+    return N1 &amp;lt; N2 ? false :
+      equal(move(first1) + (N1 - N2), last1, move(first2), last2, pred, proj1, proj2);
+  }
+
+  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires (forward_range&amp;lt;R1&amp;gt; || sized_range&amp;lt;R1&amp;gt;) &amp;amp;&amp;amp;
+             (forward_range&amp;lt;R2&amp;gt; || sized_range&amp;lt;R2&amp;gt;) &amp;amp;&amp;amp;
+             indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
+    const auto N1 = distance(r1);
+    const auto N2 = distance(r2);
+    return N1 &amp;lt; N2 ? false :
+      equal(drop_view(ref_view(r1), N1 - N2), r2, pred, proj1, proj2);
+  }
+};
+
+inline constexpr ends_with_impl ends_with;
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* sized_sentinel_for[link /reference/iterator/sized_sentinel_for.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+* identity[link /reference/functional/identity.md]
+* indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* sized_range[link /reference/ranges/sized_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* equal[link ranges_equal.md]
+* drop_view[link /reference/ranges/drop_view.md]
+* ref_view[link /reference/ranges/ref_view.md]
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [N4892 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>starts_with -- ranges::starts_with/ends_withを追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_starts_with.html"/>
      <id>0f3a18e43a04e4aa44394772384c43d669884ff8:reference/algorithm/ranges_starts_with.md</id>
      <updated>2022-01-22T14:52:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_starts_with.md b/reference/algorithm/ranges_starts_with.md
new file mode 100644
index 000000000..3587ee965
--- /dev/null
+++ b/reference/algorithm/ranges_starts_with.md
@@ -0,0 +1,106 @@
+# starts_with
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool starts_with(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+* identity[link /reference/functional/identity.md]
+* indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+
+## 概要
+シーケンスの先頭が指定されたシーケンスと一致するかを調べる
+
+## 戻り値
+
+[`ranges::mismatch`](ranges_mismatch.md)`(`[`std::move`](/reference/utility/move.md)`(first1), last1, `[`std::move`](/reference/utility/move.md)`(first2), last2, pred, proj1, proj2).in2 == last2`
+
+## 計算量
+最大で `min(last1 - first1, last2 - first2)` 回の対応する述語が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  const std::vector v  = { 1,2,3,4,5,6 };
+  const std::vector v1 = { 1,2,3 };
+  const std::vector v2 = { 2,3,4 };
+
+  std::cout &amp;lt;&amp;lt; std::ranges::starts_with(v, v1) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::starts_with(v, v2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::starts_with[color ff0000]
+
+### 出力
+```
+1
+0
+```
+
+
+## 実装例
+```cpp
+struct starts_with_impl {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
+    return mismatch(move(first1), last1, move(first2), last2, pred, proj1, proj2).in2 == last2;
+  }
+
+  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool starts_with(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
+
+inline constexpr starts_with_impl starts_with;
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+* identity[link /reference/functional/identity.md]
+* indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* move[link /reference/utility/move.md]
+* mismatch[link ranges_mismatch.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [N4892 25 Algorithms library](https://timsong-cpp.github.io/cppwp/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>属性構文 -- Merge pull request #935 from cpprefjp/fix_typos</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/attributes.html"/>
      <id>8a7df6b961f4eaaa01b5962b51a4ac595bfdfaf7:lang/cpp11/attributes.md</id>
      <updated>2022-01-18T23:14:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/attributes.md b/lang/cpp11/attributes.md
index 049eb8cc1..b56d298c5 100644
--- a/lang/cpp11/attributes.md
+++ b/lang/cpp11/attributes.md
@@ -52,7 +52,7 @@ int main()
 
 
 ### &amp;lt;a id=&amp;#34;carries_dependency&amp;#34; href=&amp;#34;#carries_dependency&amp;#34;&amp;gt;`[[carries_dependency]]`属性&amp;lt;/a&amp;gt;
-`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order_consume`](/reference/atomic/memory_order.md)を、関数をまたいで伝播することを明示するための属性である。
+`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order`](/reference/atomic/memory_order.md)を、関数をまたいで伝播することを明示するための属性である。
 
 以下は、[`memory_order_consume`](/reference/atomic/memory_order.md)を使用した順序付けの例である：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>quiet_NaN -- Merge pull request #935 from cpprefjp/fix_typos</title>
      <link href="https://cpprefjp.github.io/reference/limits/numeric_limits/quiet_nan.html"/>
      <id>8a7df6b961f4eaaa01b5962b51a4ac595bfdfaf7:reference/limits/numeric_limits/quiet_nan.md</id>
      <updated>2022-01-18T23:14:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/limits/numeric_limits/quiet_nan.md b/reference/limits/numeric_limits/quiet_nan.md
index 000d8e518..39e8cc581 100644
--- a/reference/limits/numeric_limits/quiet_nan.md
+++ b/reference/limits/numeric_limits/quiet_nan.md
@@ -38,7 +38,7 @@ static constexpr T quiet_NaN() noexcept;
 int main()
 {
   constexpr float f = std::numeric_limits&amp;lt;float&amp;gt;::quiet_NaN();
-  constexpr float d = std::numeric_limits&amp;lt;double&amp;gt;::quiet_NaN();
+  constexpr double d = std::numeric_limits&amp;lt;double&amp;gt;::quiet_NaN();
 
   std::cout &amp;lt;&amp;lt; &amp;#34;float : &amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; &amp;#34;double : &amp;#34; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>signaling_NaN -- Merge pull request #935 from cpprefjp/fix_typos</title>
      <link href="https://cpprefjp.github.io/reference/limits/numeric_limits/signaling_nan.html"/>
      <id>8a7df6b961f4eaaa01b5962b51a4ac595bfdfaf7:reference/limits/numeric_limits/signaling_nan.md</id>
      <updated>2022-01-18T23:14:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/limits/numeric_limits/signaling_nan.md b/reference/limits/numeric_limits/signaling_nan.md
index aebf4c09e..164aa0d04 100644
--- a/reference/limits/numeric_limits/signaling_nan.md
+++ b/reference/limits/numeric_limits/signaling_nan.md
@@ -6,7 +6,7 @@
 
 ```cpp
 // C++03
-static const T signaling_NaN() noexcept;
+static const T signaling_NaN() throw();
 
 // C++11
 static constexpr T signaling_NaN() noexcept;
@@ -36,7 +36,7 @@ static constexpr T signaling_NaN() noexcept;
 int main()
 {
   constexpr float f = std::numeric_limits&amp;lt;float&amp;gt;::signaling_NaN();
-  constexpr float d = std::numeric_limits&amp;lt;double&amp;gt;::signaling_NaN();
+  constexpr double d = std::numeric_limits&amp;lt;double&amp;gt;::signaling_NaN();
 
   std::cout &amp;lt;&amp;lt; &amp;#34;float : &amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; &amp;#34;double : &amp;#34; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yumetodo</name>
        <email>yume-wikijp@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>属性構文 -- fix: fix some typos</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/attributes.html"/>
      <id>02ff31ac7508f4f199f857907e987fa65b5d74b9:lang/cpp11/attributes.md</id>
      <updated>2022-01-18T18:56:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/attributes.md b/lang/cpp11/attributes.md
index 049eb8cc1..b56d298c5 100644
--- a/lang/cpp11/attributes.md
+++ b/lang/cpp11/attributes.md
@@ -52,7 +52,7 @@ int main()
 
 
 ### &amp;lt;a id=&amp;#34;carries_dependency&amp;#34; href=&amp;#34;#carries_dependency&amp;#34;&amp;gt;`[[carries_dependency]]`属性&amp;lt;/a&amp;gt;
-`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order_consume`](/reference/atomic/memory_order.md)を、関数をまたいで伝播することを明示するための属性である。
+`[[carries_dependency]]`は、並行プログラミングのアトミック操作において、値に依存した順序付け [`memory_order`](/reference/atomic/memory_order.md)を、関数をまたいで伝播することを明示するための属性である。
 
 以下は、[`memory_order_consume`](/reference/atomic/memory_order.md)を使用した順序付けの例である：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>quiet_NaN -- fix: fix some typos</title>
      <link href="https://cpprefjp.github.io/reference/limits/numeric_limits/quiet_nan.html"/>
      <id>02ff31ac7508f4f199f857907e987fa65b5d74b9:reference/limits/numeric_limits/quiet_nan.md</id>
      <updated>2022-01-18T18:56:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/limits/numeric_limits/quiet_nan.md b/reference/limits/numeric_limits/quiet_nan.md
index 000d8e518..39e8cc581 100644
--- a/reference/limits/numeric_limits/quiet_nan.md
+++ b/reference/limits/numeric_limits/quiet_nan.md
@@ -38,7 +38,7 @@ static constexpr T quiet_NaN() noexcept;
 int main()
 {
   constexpr float f = std::numeric_limits&amp;lt;float&amp;gt;::quiet_NaN();
-  constexpr float d = std::numeric_limits&amp;lt;double&amp;gt;::quiet_NaN();
+  constexpr double d = std::numeric_limits&amp;lt;double&amp;gt;::quiet_NaN();
 
   std::cout &amp;lt;&amp;lt; &amp;#34;float : &amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; &amp;#34;double : &amp;#34; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>signaling_NaN -- fix: fix some typos</title>
      <link href="https://cpprefjp.github.io/reference/limits/numeric_limits/signaling_nan.html"/>
      <id>02ff31ac7508f4f199f857907e987fa65b5d74b9:reference/limits/numeric_limits/signaling_nan.md</id>
      <updated>2022-01-18T18:56:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/limits/numeric_limits/signaling_nan.md b/reference/limits/numeric_limits/signaling_nan.md
index aebf4c09e..164aa0d04 100644
--- a/reference/limits/numeric_limits/signaling_nan.md
+++ b/reference/limits/numeric_limits/signaling_nan.md
@@ -6,7 +6,7 @@
 
 ```cpp
 // C++03
-static const T signaling_NaN() noexcept;
+static const T signaling_NaN() throw();
 
 // C++11
 static constexpr T signaling_NaN() noexcept;
@@ -36,7 +36,7 @@ static constexpr T signaling_NaN() noexcept;
 int main()
 {
   constexpr float f = std::numeric_limits&amp;lt;float&amp;gt;::signaling_NaN();
-  constexpr float d = std::numeric_limits&amp;lt;double&amp;gt;::signaling_NaN();
+  constexpr double d = std::numeric_limits&amp;lt;double&amp;gt;::signaling_NaN();
 
   std::cout &amp;lt;&amp;lt; &amp;#34;float : &amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; std::endl;
   std::cout &amp;lt;&amp;lt; &amp;#34;double : &amp;#34; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
</feed>