<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-04-01T22:39:09.926767</updated>
  <id>fed656ae-8ab8-4844-8cd2-1495d8401ffb</id>

  
    <entry>
      <title>vformat_to -- 実装例を追加</title>
      <link href="https://cpprefjp.github.io/reference/format/vformat_to.html"/>
      <id>5398590e45f46a3ceeebed25fc7e23c6f1c6a893:reference/format/vformat_to.md</id>
      <updated>2024-04-02T07:35:09+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/vformat_to.md b/reference/format/vformat_to.md
index ce3287278..78737ce05 100644
--- a/reference/format/vformat_to.md
+++ b/reference/format/vformat_to.md
@@ -65,6 +65,98 @@ namespace std {
 
 書式文字列が正しくなかったり、フォーマット実行時に失敗したりした場合、[`format_error`](format_error.md)を投げる。
 
+## 実装例
+
+```cpp
+template&amp;lt;class ParseContext, class FormatContext&amp;gt;
+struct ArgVisitor {
+  ParseContext&amp;amp; pctx;
+  FormatContext&amp;amp; fctx;
+
+  void operator()(std::monostate) {
+  }
+
+  using handle = std::basic_format_arg&amp;lt;FormatContext&amp;gt;::handle;
+  void operator()(const handle&amp;amp; handle) {
+    handle.format(pctx, fctx);
+  }
+
+  template&amp;lt;class T&amp;gt;
+  void operator()(const T&amp;amp; arg) {
+    using Formatter = FormatContext::template formatter_type&amp;lt;T&amp;gt;;
+    Formatter formatter;
+    pctx.advance_to(formatter.parse(pctx));
+    fctx.advance_to(formatter.format(arg, fctx));
+  }
+};
+
+template&amp;lt;std::output_iterator&amp;lt;char&amp;gt; Out, class Context = basic_format_context&amp;lt;Out, char&amp;gt;&amp;gt;
+Out vformat_to(Out out, std::string_view fmt, std::basic_format_args&amp;lt;Context&amp;gt; args) {
+  using ParseContext = std::basic_format_parse_context&amp;lt;decltype(fmt)::value_type&amp;gt;;
+  ParseContext pctx{fmt};
+  Context fctx{out, args}; // このコンストラクタの存在は未規定
+  ArgVisitor&amp;lt;ParseContext, Context&amp;gt; visitor{pctx, fctx};
+
+  size_t next_arg_index = 0;
+  while (!std::ranges::empty(pctx)) {
+    auto it = pctx.begin();
+    if (*it == &amp;#39;{&amp;#39;) {
+      ++it;
+      if (it == pctx.end()) {
+        throw std::format_error(&amp;#34;invalid format&amp;#34;);
+      } else if (*it != &amp;#39;{&amp;#39;) {
+        // インデックスを解析する
+        size_t index;
+        if (auto [ptr, ec] = std::from_chars(it, pctx.end(), index); ec == std::errc{}) {
+          it += (ptr - std::to_address(it));
+          pctx.check_arg_id(index);
+        } else {
+          index = next_arg_index;
+          pctx.next_arg_id();
+          ++next_arg_index;
+        }
+        // オプション開始マークを解析する
+        if (it == pctx.end()) {
+          throw std::format_error(&amp;#34;invalid format&amp;#34;);
+        } else if (*it == &amp;#39;:&amp;#39;) {
+          ++it;
+        } else if (*it != &amp;#39;}&amp;#39;) {
+          throw std::format_error(&amp;#34;invalid format&amp;#34;);
+        }
+        pctx.advance_to(it);
+        // フォーマッターを呼び出す
+        std::visit_format_arg(visitor, args.get(index));
+        // 置換フィールドの終端を解析する
+        if (it == pctx.end() || *it != &amp;#39;}&amp;#39;) {
+          throw std::format_error(&amp;#34;invalid format&amp;#34;);
+        }
+        pctx.advance_to(++it);
+        continue;
+      }
+    } else if (*it == &amp;#39;}&amp;#39;) {
+      ++it;
+      if (it == pctx.end() || *it != &amp;#39;}&amp;#39;) {
+        throw std::format_error(&amp;#34;invalid format&amp;#34;);
+      }
+    }
+    *out = *it;
+    pctx.advance_to(++it);
+    fctx.advance_to(++out);
+  }
+  return out;
+}
+```
+* pctx.advance_to[link /reference/format/basic_format_parse_context/advance_to.md]
+* fctx.advance_to[link /reference/format/basic_format_context/advance_to.md]
+* formatter.parse[link /reference/format/formatter/parse.md]
+* formatter.format[link /reference/format/formatter/format.md]
+* std::format_error[link /reference/format/format_error.md]
+* std::basic_format_parse_context[link /reference/format/basic_format_parse_context.md]
+* std::basic_format_context[link /reference/format/basic_format_context.md]
+* std::basic_format_args[link /reference/format/basic_format_args.md]
+* std::visit_format_arg[link /reference/format/visit_format_arg.md]
+* std::from_chars[link /reference/charconv/from_chars.md]
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_format_context -- 補足説明を追加</title>
      <link href="https://cpprefjp.github.io/reference/format/basic_format_context.html"/>
      <id>d548d89055843d52b6c01b4883dd1ac49674d006:reference/format/basic_format_context.md</id>
      <updated>2024-04-02T07:30:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/basic_format_context.md b/reference/format/basic_format_context.md
index 17cf7666a..e3f5d4020 100644
--- a/reference/format/basic_format_context.md
+++ b/reference/format/basic_format_context.md
@@ -26,6 +26,9 @@ namespace std {
 ## テンプレートパラメータ制約
 - `Out`は`OutputIterator&amp;lt;const charT&amp;amp;&amp;gt;`であること
 
+## 備考
+
+出力イテレータの型はフォーマット関数に指定したイテレータである必要はない。内部でバッファリングを行う実装が可能である。
 
 ## メンバ関数
 
@@ -51,26 +54,33 @@ namespace std {
   class basic_format_context {
     basic_format_args&amp;lt;basic_format_context&amp;gt; args_;
     Out out_;
+    std::optional&amp;lt;std::locale&amp;gt; locale;
 
   public:
     using iterator = Out;
     using char_type = charT;
     template&amp;lt;class T&amp;gt; using formatter_type = formatter&amp;lt;T, charT&amp;gt;;
 
-    basic_format_arg&amp;lt;basic_format_context&amp;gt; arg(size_t id) const
+    basic_format_context(iterator out, std::basic_format_args&amp;lt;basic_format_context&amp;gt; args, std::optional&amp;lt;std::locale&amp;gt; locale = std::nullopt)
+      :args_(args)
+      ,out_(out)
+      ,locale_(locale)
     {
+    }
+
+    basic_format_arg&amp;lt;basic_format_context&amp;gt; arg(size_t id) const {
       return args_.get(id);
     }
 
-    std::locale locale();
+    std::locale locale() {
+      return locale_.value_or(std::locale());
+    }
 
-    iterator out();
-    {
+    iterator out() {
       return out_;
     }
 
-    void advance_to(iterator it)
-    {
+    void advance_to(iterator it) {
       out_ = it;
     }
   };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format -- 書式文字列の取得のしかたを修正</title>
      <link href="https://cpprefjp.github.io/reference/format/format.html"/>
      <id>f71ba40b132264533267c4eafb43f5fb4a0d9402:reference/format/format.md</id>
      <updated>2024-04-02T07:25:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format.md b/reference/format/format.md
index 56ac12599..8745522d7 100644
--- a/reference/format/format.md
+++ b/reference/format/format.md
@@ -622,25 +622,25 @@ int main()
 template&amp;lt;class... Args&amp;gt;
 string format(format_string&amp;lt;Args...&amp;gt; fmt, const Args&amp;amp;... args)
 {
-  return vformat(fmt.str, make_format_args(args...));
+  return vformat(fmt.get(), make_format_args(args...));
 }
 
 template&amp;lt;class... Args&amp;gt;
 wstring format(wformat_string&amp;lt;Args...&amp;gt; fmt, const Args&amp;amp;... args)
 {
-  return vformat(fmt.str, make_wformat_args(args...));
+  return vformat(fmt.get(), make_wformat_args(args...));
 }
 
 template&amp;lt;class... Args&amp;gt;
 string format(const locale&amp;amp; loc, format_string&amp;lt;Args...&amp;gt; fmt, const Args&amp;amp;... args)
 {
-  return vformat(loc, fmt.str, make_format_args(args...));
+  return vformat(loc, fmt.get(), make_format_args(args...));
 }
 
 template&amp;lt;class... Args&amp;gt;
 wstring format(const locale&amp;amp; loc, wformat_string&amp;lt;Args...&amp;gt; fmt, const Args&amp;amp;... args)
 {
-  return vformat(loc, fmt.str, make_wformat_args(args...));
+  return vformat(loc, fmt.get(), make_wformat_args(args...));
 }
 ```
 * string[link /reference/string/basic_string.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>formatter -- formatter: 説明を追加</title>
      <link href="https://cpprefjp.github.io/reference/format/formatter.html"/>
      <id>a659a6b0b282b6a5000a8986ee11f8e61d70ef1d:reference/format/formatter.md</id>
      <updated>2024-04-02T07:24:59+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/formatter.md b/reference/format/formatter.md
index 24a788f1a..800229fdd 100644
--- a/reference/format/formatter.md
+++ b/reference/format/formatter.md
@@ -44,28 +44,14 @@ namespace std {
 
 (1)は、`charT`を`char`または`wchar_t`とすると、標準で以下の特殊化が利用できる。
 
-- 1 以下のもの。
-    ```cpp
-    template&amp;lt;&amp;gt; struct formatter&amp;lt;charT, charT&amp;gt;;
-
-    template&amp;lt;&amp;gt; struct formatter&amp;lt;char, wchar_t&amp;gt;;
-
-    template&amp;lt;&amp;gt; struct formatter&amp;lt;charT*, charT&amp;gt;;
-
-    template&amp;lt;&amp;gt; struct formatter&amp;lt;const charT*, charT&amp;gt;;
-
-    template&amp;lt;size_t N&amp;gt; struct formatter&amp;lt;const charT[N], charT&amp;gt;;
-
-    template&amp;lt;class traits, class Allocator&amp;gt;
-    struct formatter&amp;lt;basic_string&amp;lt;charT, traits, Allocator&amp;gt;, charT&amp;gt;;
-
-    template&amp;lt;class traits&amp;gt;
-    struct formatter&amp;lt;basic_string_view&amp;lt;charT, traits&amp;gt;, charT&amp;gt;;
-    ```
-    * basic_string[link /reference/string/basic_string.md]
-    * basic_string_view[link /reference/string_view/basic_string_view.md]
-
-- 2 第1テンプレート引数が`nullptr_t`, `void*`, `const void*`, `bool`, すべてのCV修飾されない標準の整数型, 拡張整数型, 浮動小数点数型であり、第2テンプレート引数が`charT`であるもの。
+- `template&amp;lt;&amp;gt; struct formatter&amp;lt;charT, charT&amp;gt;`
+- `template&amp;lt;&amp;gt; struct formatter&amp;lt;char, wchar_t&amp;gt;`
+- `template&amp;lt;&amp;gt; struct formatter&amp;lt;charT*, charT&amp;gt;`
+- `template&amp;lt;&amp;gt; struct formatter&amp;lt;const charT*, charT&amp;gt;`
+- `template&amp;lt;size_t N&amp;gt; struct formatter&amp;lt;const charT[N], charT&amp;gt;`
+- `template&amp;lt;class traits, class Allocator&amp;gt; struct formatter&amp;lt;`[`basic_string`](/reference/string/basic_string.md)`&amp;lt;charT, traits, Allocator&amp;gt;, charT&amp;gt;`
+- `template&amp;lt;class traits&amp;gt; struct formatter&amp;lt;`[`basic_string_view`](/reference/string_view/basic_string_view.md)`&amp;lt;charT, traits&amp;gt;, charT&amp;gt;`
+- 第1テンプレート引数が`nullptr_t`, `void*`, `const void*`, `bool`, すべてのCV修飾されない標準の整数型, 拡張整数型, 浮動小数点数型であり、第2テンプレート引数が`charT`であるもの。
 
 さらに、ユーザーが`formatter`を特殊化した場合、それも有効である。
 
@@ -96,7 +82,7 @@ namespace std {
     - 出力は`u`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
     - `u`を変更しない
 
-条件内の各要素を、以下のように定義する
+条件内の各要素を、以下のように定義する。
 
 - 文字の型を`charT`
 - 出力イテレータの型を`Out`
@@ -109,11 +95,28 @@ namespace std {
 - `FC`を[`basic_format_context`](basic_format_context.md)`&amp;lt;Out, charT&amp;gt;`
 - `pc`を`PC`のlvalue
 - `fc`を`FC`のlvalue
-- `pc.begin()`は書式文字列中の対応する置換フィールドのオプションの先頭を指す
+
+ただし、[`parse`](formatter/parse.md)の呼び出し前の状態で、`pc.begin()`は書式文字列中の対応する置換フィールドのオプションの先頭を指す。
+
+- オプションが空でなければ、`*pc.begin()`は`:`の次の文字
 - オプションが空なら、`pc.begin() == pc.end()`または`*pc.begin() == &amp;#39;}&amp;#39;`である
 
 [`std::formattable`](/reference/format/formattable.md)コンセプトも参照。
 
+フォーマッターは、書式文字列中に置換フィールドが見つかるたびに次のコードと近い形で呼び出される。
+
+```cpp
+typename FC::template formatter_type&amp;lt;T&amp;gt; f;
+pc.advance_to(f.parse(pc));      // オプションを解析し状態を保存する
+fc.advance_to(f.format(u, fc));  // 状態をもとにフォーマットを行う
+assert(pc.begin() == pc.end() || *pc.begin() == &amp;#39;}&amp;#39;);
+```
+* pc.advance_to[link /reference/format/basic_format_parse_context/advance_to.md]
+* fc.advance_to[link /reference/format/basic_format_context/advance_to.md]
+* f.parse[link formatter/parse.md]
+* f.format[link formatter/format.md]
+
+[handle](/reference/format/basic_format_arg/handle.md)も参照。
 
 ## メンバ関数
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace -- map::emplace : 戻り値の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/map/map/emplace.html"/>
      <id>194f60ccc5e77e265dafef472e83e4482e62c421:reference/map/map/emplace.md</id>
      <updated>2024-04-01T18:24:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/emplace.md b/reference/map/map/emplace.md
index f9118597f..94d10465e 100644
--- a/reference/map/map/emplace.md
+++ b/reference/map/map/emplace.md
@@ -61,6 +61,41 @@ int main()
 4 : C
 ```
 
+### 戻り値の例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;map&amp;gt;
+
+int main()
+{
+  std::map&amp;lt;int, char&amp;gt; m;
+
+  std::pair&amp;lt;std::map&amp;lt;int, char&amp;gt;::iterator, bool&amp;gt; x = m.emplace(3, &amp;#39;A&amp;#39;);
+  const std::pair&amp;lt;const int, char&amp;gt;&amp;amp; v = *x.first;
+  std::cout &amp;lt;&amp;lt; v.first &amp;lt;&amp;lt; std::endl;  // キー
+  std::cout &amp;lt;&amp;lt; v.second &amp;lt;&amp;lt; std::endl; // 値
+  std::cout &amp;lt;&amp;lt; x.second &amp;lt;&amp;lt; std::endl; // 挿入が成功したかどうか
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  auto y = m.emplace(3, &amp;#39;A&amp;#39;);
+  std::cout &amp;lt;&amp;lt; y.first-&amp;gt;first &amp;lt;&amp;lt; std::endl;  // キー
+  std::cout &amp;lt;&amp;lt; y.first-&amp;gt;second &amp;lt;&amp;lt; std::endl; // 値
+  std::cout &amp;lt;&amp;lt; y.second &amp;lt;&amp;lt; std::endl;        // 挿入が成功したかどうか
+}
+```
+* emplace[color ff0000]
+
+#### 出力
+```
+3
+A
+1
+
+3
+A
+0
+```
+
 ### キーと値もそれぞれコンストラクタ引数を渡す例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>