<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-12-29T23:33:26.071847</updated>
  <id>9c7e9b66-90ac-40f6-bdbc-95f5bccee6f2</id>

  
    <entry>
      <title>algorithm -- ranges::find/find_if/find_if_notを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>e830336aa667fd98741a7a92ab7e4bf550172d2c:reference/algorithm.md</id>
      <updated>2021-12-30T08:28:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 2ec416178..0c66010e4 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -124,9 +124,9 @@ ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 | [`ranges::none_of`](algorithm/ranges_none_of.md)             | 全ての要素が条件を満たしていないかを調べる           | C++20 |
 | [`ranges::for_each`](algorithm/ranges_for_each.md)           | 全ての要素に対して処理を行う                         | C++20 |
 | [`ranges::for_each_n`](algorithm/ranges_for_each_n.md)       | 範囲の先頭N個の要素に対して処理を行う                | C++20 |
-| [`ranges::find`](algorithm/ranges_find.md.nolink)                   | 指定された値を検索する                               | C++20 |
-| [`ranges::find_if`](algorithm/ranges_find_if.md.nolink)             | 条件を満たす最初の要素を検索する                     | C++20 |
-| [`ranges::find_if_not`](algorithm/ranges_find_if_not.md.nolink)     | 条件を満たしていない最初の要素を検索する             | C++20 |
+| [`ranges::find`](algorithm/ranges_find.md)                   | 指定された値を検索する                               | C++20 |
+| [`ranges::find_if`](algorithm/ranges_find_if.md)             | 条件を満たす最初の要素を検索する                     | C++20 |
+| [`ranges::find_if_not`](algorithm/ranges_find_if_not.md)     | 条件を満たしていない最初の要素を検索する             | C++20 |
 | [`ranges::find_end`](algorithm/ranges_find_end.md.nolink)           | 指定された最後のサブシーケンスを検索する             | C++20 |
 | [`ranges::find_first_of`](algorithm/ra.nolinknges_find_first_of.md.nolink) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
 | [`ranges::adjacent_find`](algorithm/ra.nolinknges_adjacent_find.md.nolink) | 隣接する要素で条件を満たしている最初の要素を検索する | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- ranges::find/find_if/find_if_notを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>e830336aa667fd98741a7a92ab7e4bf550172d2c:reference/algorithm/ranges_find.md</id>
      <updated>2021-12-30T08:28:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
new file mode 100644
index 000000000..1cf2408c7
--- /dev/null
+++ b/reference/algorithm/ranges_find.md
@@ -0,0 +1,104 @@
+# find
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr I find(I first, S last, const T&amp;amp; value, Proj proj = {});
+
+  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+}
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+- equal_to[link /reference/functional/equal_to.md]
+- input_range[link /reference/ranges/input_range.md]
+- projected[link /reference/iterator/projected.md]
+
+## 概要
+指定された値を検索する。
+
+
+## 戻り値
+`[first,last)` あるいは `r` 内のイテレータ i について、[`invoke`](/reference/functional/invoke.md)`(proj, *i) == value` であるような最初のイテレータを返す。そのようなイテレータが見つからなかった場合は `last` を返す。
+
+## 計算量
+最大で `last - first` 回比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;array&amp;gt;
+
+int main() {
+  constexpr std::array v = { 3, 1, 4 };
+  constexpr auto result = std::ranges::find(v, 1);
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find[color ff0000]
+
+### 出力
+```
+found: 1
+```
+
+
+## 実装例
+```cpp
+struct find_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr I operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
+    for ( ; first != last; ++first)
+      if (*first == value) return first;
+    return last;
+  }
+
+  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
+    return (*this)(begin(r), end(r), value, ref(proj));
+  }
+};
+
+inline constexpr find_impl find;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+* equal_to[link /reference/functional/equal_to.md]
+* projected[link /reference/iterator/projected.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- ranges::find/find_if/find_if_notを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>e830336aa667fd98741a7a92ab7e4bf550172d2c:reference/algorithm/ranges_find_if.md</id>
      <updated>2021-12-30T08:28:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
new file mode 100644
index 000000000..152fce3e4
--- /dev/null
+++ b/reference/algorithm/ranges_find_if.md
@@ -0,0 +1,102 @@
+# find_if
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+}
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+- input_range[link /reference/ranges/input_range.md]
+- projected[link /reference/iterator/projected.md]
+
+## 概要
+範囲の中から、指定された条件を満たす最初の要素を検索する。
+
+
+## 戻り値
+`[first,last)` あるいは `r` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *i)) != false` である最初のイテレータを返す。そのようなイテレータが見つからなかった場合は `last` を返す。
+
+
+## 計算量
+最大で `last - first` 回述語による比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 3, 1, 4 };
+  // 3ではない最初の要素を検索する
+  auto result = std::ranges::find_if(v, [](int x) { return x != 3; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if[color ff0000]
+
+### 出力
+```
+found: 1
+```
+
+
+## 実装例
+```cpp
+struct find_if_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I perator()(I first, S last, Pred pred, Proj proj = {}) {
+    for ( ; first != last; ++first)
+      if (invoke(pred, invoke(proj, *first)))
+        return first;
+  }
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate &amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+    return (*this)(begin(r), end(r), ref(pred), ref(proj));
+  }
+};
+
+inline constexpr find_if_impl find_if;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- ranges::find/find_if/find_if_notを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>e830336aa667fd98741a7a92ab7e4bf550172d2c:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2021-12-30T08:28:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
new file mode 100644
index 000000000..32d9b47ea
--- /dev/null
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -0,0 +1,102 @@
+# find_if_not
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find_if_not(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});
+}
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+- input_range[link /reference/ranges/input_range.md]
+- projected[link /reference/iterator/projected.md]
+
+## 概要
+範囲の中から、指定された条件を満たさない最初の要素を検索する。
+
+
+## 戻り値
+`[first,last)` あるいは `r` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *i)) == false` である最初のイテレータを返す。そのようなイテレータが見つからなかった場合は `last` を返す。
+
+
+## 計算量
+最大で `last - first` 回述語による比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 3, 1, 4 };
+  // 3ではない最初の要素を検索する
+  auto result = std::ranges::find_if_not(v, [](int x) { return x == 3; });
+  if (result == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_if_not[color ff0000]
+
+### 出力
+```
+found: 1
+```
+
+
+## 実装例
+```cpp
+struct find_if_not_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr I perator()(I first, S last, Pred pred, Proj proj = {}) {
+    for ( ; first != last; ++first)
+      if (!invoke(pred, invoke(proj, *first)))
+        return first;
+  }
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate &amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+    return (*this)(begin(r), end(r), ref(pred), ref(proj));
+  }
+};
+
+inline constexpr find_if_not_impl find_if_not;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>6e1108a14d5e51b030b369b047a6d115dfeadd23:reference/algorithm/ranges_count_if.md</id>
      <updated>2021-12-30T08:22:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 91e06e948..99310f936 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -15,7 +15,7 @@ namespace std {
 ```
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
-* indirect_binarindirect_unary_predicatey_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
 * projected[link /reference/iterator/projected.md]
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 * range_difference_t[link /reference/ranges/range_difference_t.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::conut/count_ifを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>19ad00b6639e426c1e71560a3de49e1e5051f908:reference/algorithm.md</id>
      <updated>2021-12-29T23:48:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 75a3d626a..2ec416178 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -130,8 +130,8 @@ ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 | [`ranges::find_end`](algorithm/ranges_find_end.md.nolink)           | 指定された最後のサブシーケンスを検索する             | C++20 |
 | [`ranges::find_first_of`](algorithm/ra.nolinknges_find_first_of.md.nolink) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
 | [`ranges::adjacent_find`](algorithm/ra.nolinknges_adjacent_find.md.nolink) | 隣接する要素で条件を満たしている最初の要素を検索する | C++20 |
-| [`ranges::count`](algorithm/ranges_count.md.nolink)                 | 指定された値である要素の数を数える                   | C++20 |
-| [`ranges::count_if`](algorithm/ranges_count_if.md.nolink)           | 条件を満たしている要素の数を数える                   | C++20 |
+| [`ranges::count`](algorithm/ranges_count.md)                 | 指定された値である要素の数を数える                   | C++20 |
+| [`ranges::count_if`](algorithm/ranges_count_if.md)           | 条件を満たしている要素の数を数える                   | C++20 |
 | [`ranges::mismatch`](algorithm/ranges_mismatch.md.nolink)           | 2つの範囲が一致していない場所を検索する              | C++20 |
 | [`ranges::equal`](algorithm/ranges_equal.md.nolink)                 | 2つの範囲を等値比較する                              | C++20 |
 | [`ranges::search`](algorithm/ranges_search.md.nolink)               | 指定された最初のサブシーケンスを検索する             | C++20 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- ranges::conut/count_ifを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>19ad00b6639e426c1e71560a3de49e1e5051f908:reference/algorithm/ranges_count.md</id>
      <updated>2021-12-29T23:48:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
new file mode 100644
index 000000000..b0ff3b076
--- /dev/null
+++ b/reference/algorithm/ranges_count.md
@@ -0,0 +1,110 @@
+# count
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt; count(I first, S last, const T&amp;amp; value, Proj proj = {}); // (1)
+
+  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt; count(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});          // (2)
+}
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+* equal_to[link /reference/functional/equal_to.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+
+## 概要
+指定された値と等値な要素の数を数える。
+
+## テンプレートパラメータ制約
+- (1):
+    - `I`が[`input_iterator`](/reference/iterator/input_iterator.md)である
+    - `S`が[`I`に対する番兵](/reference/iterator/sentinel_for.md)である
+    - `I`を`Proj`で射影した値と指定された値が[`equal_to`](/reference/functional/equal_to.md)によって等値比較できる
+- (2):
+    - `R`が[`input_range`](/reference/ranges/input_range.md)である
+    - `Pred`は`R`のイテレータを`Proj`で射影した値が[`equal_to`](/reference/functional/equal_to.md)によって等値比較できる
+
+## 戻り値
+`[first,last)` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(proj, *i) == value` であるイテレータの数を返す
+
+## 計算量
+正確に `last - first` 回の比較を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;array&amp;gt;
+
+int main() {
+  constexpr std::array v = { 1,4,3,3,1,2,2,1 };
+
+  // 値が 1 の要素がいくつあるかを数える
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of 1: &amp;#34; &amp;lt;&amp;lt; std::ranges::count(v, 1) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count[color ff0000]
+
+### 出力
+```
+count of 1: 3
+```
+
+
+## 実装例
+```cpp
+struct count_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
+    iter_difference_t&amp;lt;I&amp;gt; count = 0;
+    for ( ; first != last; ++first)
+      if (value == invoke(proj, *first)) count++;
+    return count;
+  }
+
+  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
+    return (*this)(begin(r), end(r), value, ref(proj));
+  }
+};
+
+inline constexpr count_impl count;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
+* equal_to[link /reference/functional/equal_to.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- ranges::conut/count_ifを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>19ad00b6639e426c1e71560a3de49e1e5051f908:reference/algorithm/ranges_count_if.md</id>
      <updated>2021-12-29T23:48:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
new file mode 100644
index 000000000..91e06e948
--- /dev/null
+++ b/reference/algorithm/ranges_count_if.md
@@ -0,0 +1,108 @@
+# count_if
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt; count_if(I first, S last, Pred pred, Proj proj = {}); // (1)
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt; count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});          // (2)
+}
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_binarindirect_unary_predicatey_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+
+
+## 概要
+条件を満たしている要素の数を数える。
+
+## テンプレートパラメータ制約
+- (1):
+    - `I`が[`input_iterator`](/reference/iterator/input_iterator.md)である
+    - `S`が[`I`に対する番兵](/reference/iterator/sentinel_for.md)である
+    - `Pred`は`I`を`Proj`で射影した値を[参照で渡すことができる1引数の述語](/reference/iterator/indirect_unary_predicate.md)である
+- (2):
+    - `R`が[`input_range`](/reference/ranges/input_range.md)である
+    - `Pred`は`R`のイテレータを`Proj`で射影した値を[参照で渡すことができる1引数の述語](/reference/iterator/indirect_unary_predicate.md)である
+
+
+## 戻り値
+`[first,last)` 内のイテレータ `i` について、[`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *i)) != false` であるイテレータの数を返す
+
+
+## 計算量
+正確に `last - first` 回の述語の適用を行う
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;array&amp;gt;
+
+int main() {
+  constexpr std::array v = { 1,4,3,3,1,2,2,1 };
+
+  // 値が 1 または 3 の要素がいくつあるかを数える
+  auto count = std::ranges::count_if(v, [](int x) { return x == 1 || x == 3; });
+  std::cout &amp;lt;&amp;lt; &amp;#34;count of 1 or 3: &amp;#34; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::count_if[color ff0000]
+
+### 出力
+```cpp
+count of 1 or 3: 5
+```
+
+
+## 実装例
+```cpp
+struct count_if_impl {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, Pred pred, Proj proj = {}) {
+    iter_difference_t&amp;lt;I&amp;gt; count = 0;
+    for ( ; first != last; ++first)
+      if (invoke(pred, invoke(proj, *first))) count++;
+    return count;
+  }
+
+  template&amp;lt;input_range R, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred&amp;gt;
+  constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {}) {
+    return (*this)(begin(r), end(r), ref(pred), ref(proj));
+  }
+};
+
+inline constexpr count_if_impl count_if;
+```
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* identity[link /reference/functional/identity.md]
+* indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
+* projected[link /reference/iterator/projected.md]
+* iter_difference_t[link /reference/iterator/iter_difference_t.md]
+* range_difference_t[link /reference/ranges/range_difference_t.md]
+* invoke[link /reference/functional/invoke.md]
+* begin[link /reference/ranges/begin.md]
+* end[link /reference/ranges/end.md]
+* ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ratio -- Merge pull request #933 from cpprefjp/improve_ratio</title>
      <link href="https://cpprefjp.github.io/reference/ratio/ratio.html"/>
      <id>f6cd6dc0ed7c803173fe0b35ae5e659814e6cbc9:reference/ratio/ratio.md</id>
      <updated>2021-12-29T22:52:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ratio/ratio.md b/reference/ratio/ratio.md
index b13c7883f..593f1bd02 100644
--- a/reference/ratio/ratio.md
+++ b/reference/ratio/ratio.md
@@ -25,6 +25,9 @@ namespace std {
 - `num` : [`sign`](https://ja.wikipedia.org/wiki/符号関数)`(N) *` [`sign`](https://ja.wikipedia.org/wiki/符号関数)`(D) *` [`abs`](/reference/cmath/abs.md)`(N) /` [`gcd`](https://ja.wikipedia.org/wiki/最大公約数)`(N, D)`
 - `den` : [`abs`](/reference/cmath/abs.md)`(D) /` [`gcd`](https://ja.wikipedia.org/wiki/最大公約数)`(N, D)`
 
+## 要件
+`den`の値が`0`でもなく、[`intmax_t`](/reference/cstdint/intmax_t.md)の最小値でもないこと。
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ratio_add -- Merge pull request #933 from cpprefjp/improve_ratio</title>
      <link href="https://cpprefjp.github.io/reference/ratio/ratio_add.html"/>
      <id>f6cd6dc0ed7c803173fe0b35ae5e659814e6cbc9:reference/ratio/ratio_add.md</id>
      <updated>2021-12-29T22:52:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ratio/ratio_add.md b/reference/ratio/ratio_add.md
index 6c533c8fb..42a100ec5 100644
--- a/reference/ratio/ratio_add.md
+++ b/reference/ratio/ratio_add.md
@@ -18,6 +18,8 @@ namespace std {
 ## 効果
 加算結果は、[`ratio`](ratio.md)`&amp;lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&amp;gt;`という型になる。
 
+実装によっては、演算アルゴリズムによってオーバーフローが起こる可能性がある。オーバーフローが起こった場合、プログラムは不適格となる。
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ratio_divide -- Merge pull request #933 from cpprefjp/improve_ratio</title>
      <link href="https://cpprefjp.github.io/reference/ratio/ratio_divide.html"/>
      <id>f6cd6dc0ed7c803173fe0b35ae5e659814e6cbc9:reference/ratio/ratio_divide.md</id>
      <updated>2021-12-29T22:52:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ratio/ratio_divide.md b/reference/ratio/ratio_divide.md
index 22dc34e96..36c53f13d 100644
--- a/reference/ratio/ratio_divide.md
+++ b/reference/ratio/ratio_divide.md
@@ -18,6 +18,8 @@ namespace std {
 ## 効果
 除算結果は、[`ratio`](ratio.md)`&amp;lt;R1::num * R2::den, R1::den * R2::num&amp;gt;`という型になる。
 
+実装によっては、演算アルゴリズムによってオーバーフローが起こる可能性がある。オーバーフローが起こった場合、プログラムは不適格となる。
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ratio_multiply -- Merge pull request #933 from cpprefjp/improve_ratio</title>
      <link href="https://cpprefjp.github.io/reference/ratio/ratio_multiply.html"/>
      <id>f6cd6dc0ed7c803173fe0b35ae5e659814e6cbc9:reference/ratio/ratio_multiply.md</id>
      <updated>2021-12-29T22:52:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ratio/ratio_multiply.md b/reference/ratio/ratio_multiply.md
index af98c8023..ef9a5c30a 100644
--- a/reference/ratio/ratio_multiply.md
+++ b/reference/ratio/ratio_multiply.md
@@ -18,6 +18,8 @@ namespace std {
 ## 効果
 乗算結果は、[`ratio`](ratio.md)`&amp;lt;R1::num * R2::num, R1::den * R2::den&amp;gt;`という型になる。
 
+実装によっては、演算アルゴリズムによってオーバーフローが起こる可能性がある。オーバーフローが起こった場合、プログラムは不適格となる。
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ratio_subtract -- Merge pull request #933 from cpprefjp/improve_ratio</title>
      <link href="https://cpprefjp.github.io/reference/ratio/ratio_subtract.html"/>
      <id>f6cd6dc0ed7c803173fe0b35ae5e659814e6cbc9:reference/ratio/ratio_subtract.md</id>
      <updated>2021-12-29T22:52:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ratio/ratio_subtract.md b/reference/ratio/ratio_subtract.md
index 57dc32036..97b26ccfd 100644
--- a/reference/ratio/ratio_subtract.md
+++ b/reference/ratio/ratio_subtract.md
@@ -18,6 +18,8 @@ namespace std {
 ## 効果
 減算結果は、[`ratio`](ratio.md)`&amp;lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&amp;gt;`という型になる。
 
+実装によっては、演算アルゴリズムによってオーバーフローが起こる可能性がある。オーバーフローが起こった場合、プログラムは不適格となる。
+
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::版の説明を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>6f7f531aeeb39a188d6f0347479f282de6529eee:reference/algorithm.md</id>
      <updated>2021-12-29T22:38:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 8bd494692..75a3d626a 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -61,7 +61,18 @@ C++20ではアルゴリズム関数の新しいバージョンが`std::ranges`
 * テンプレート引数がコンセプトによって制約される
 * イテレータの組に加えて、範囲(Range)も直接渡せる
 * 射影(Projection)をサポートする
-* ADLで発見されない
+* [ADLで発見されない](/article/lib/disable_adl_function.md)
+
+新しいアルゴリズム関数には範囲(Range)を直接渡すことができる。
+
+```cpp
+// 従来のアルゴリズム関数
+sort(v.begin(), v.end());
+// C++20以降の新しいアルゴリズム関数: Rangeを直接渡せる
+ranges::sort(v);
+// イテレータ対も渡せる
+ranges::sort(v.begin(), v.end());
+```
 
 射影は、述語とは別に渡すことができる関数オブジェクトで、特定のメンバだけを対象にアルゴリズムを実行するために用いる。
 
@@ -87,30 +98,6 @@ ranges::sort(pv.begin(), pv.end(), {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 ```
 
-### ADLの無効化
-
-`std::ranges`以下のアルゴリズムは`std`以下のものより先に見つかるようにするため、ADLで発見されない(ADLより前に見つかる)ことが規定されている。
-
-```cpp
-using namespace std::ranges;
-std::vector v = {1, 3, 2, 0};
-// ADLに従えばstd::sortが呼ばれてしまうが、ranges::sortはADL以前に見つかるため、ranges::sortが呼ばれる
-sort(v.begin(), v.end());
-```
-
-ADLを無効化するには変数名にするのが最も簡単であり、アルゴリズムは関数オブジェクトとして実装されると考えられる。
-
-```cpp
-struct f_impl {
-  void operator() { … }
-};
-
-inline constexpr f_impl f; // f は変数名なのでADLで発見されない
-```
-
-しかし、規格上は関数のように説明されているため、ここでも関数として解説する。
-
-
 ## シーケンスを変更しない操作
 
 | 名前 | 説明 | 対応バージョン |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>