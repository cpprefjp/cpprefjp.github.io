<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-09-26T07:34:37.078494</updated>
  <id>7d666e10-497b-4cb7-8b1a-9da441532011</id>

  
    <entry>
      <title>counted_iterator -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator.html"/>
      <id>46f89bc560d8c35c13641cf89f9dd5eba2774b8a:reference/iterator/counted_iterator.md</id>
      <updated>2023-09-26T16:29:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator.md b/reference/iterator/counted_iterator.md
index d2e2903b1..10b5711b3 100644
--- a/reference/iterator/counted_iterator.md
+++ b/reference/iterator/counted_iterator.md
@@ -24,10 +24,9 @@ namespace std {
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
-* incrementable_traits[link /reference/iterator/incrementable_traits.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * same_as[link /reference/concepts/same_as.md]
-* ITER_CONCEPT[link /reference/iterator/input_iterator.md#iter_concept]
+* ITER_TRAITS[link /reference/iterator/input_iterator.md#iter_concept]
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 * conditional_t[link /reference/type_traits/conditional.md]
 * contiguous_iterator[link /reference/iterator/contiguous_iterator.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>counted_iterator -- counted_iterator : P2259R1対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/counted_iterator.html"/>
      <id>331a036a791df9df02b66a054ad7f70448fb205d:reference/iterator/counted_iterator.md</id>
      <updated>2023-09-26T16:26:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/counted_iterator.md b/reference/iterator/counted_iterator.md
index 766955b16..d2e2903b1 100644
--- a/reference/iterator/counted_iterator.md
+++ b/reference/iterator/counted_iterator.md
@@ -15,24 +15,24 @@ namespace std {
   };
 
 
-  // incrementable_traitsにアダプトする
-  template&amp;lt;class I&amp;gt;
-  struct incrementable_traits&amp;lt;counted_iterator&amp;lt;I&amp;gt;&amp;gt; {
-    using difference_type = iter_difference_t&amp;lt;I&amp;gt;;
-  };
-
   // iterator_traitsにアダプトする
   template&amp;lt;input_iterator I&amp;gt;
+    requires same_as&amp;lt;ITER_TRAITS(I), iterator_traits&amp;lt;I&amp;gt;&amp;gt;
   struct iterator_traits&amp;lt;counted_iterator&amp;lt;I&amp;gt;&amp;gt; : iterator_traits&amp;lt;I&amp;gt; {
-    using pointer = void;
+    using pointer = conditional_t&amp;lt;contiguous_iterator&amp;lt;I&amp;gt;, add_pointer_t&amp;lt;iter_reference_t&amp;lt;I&amp;gt;&amp;gt;, void&amp;gt;;
   };
 }
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * incrementable_traits[link /reference/iterator/incrementable_traits.md]
-* iter_difference_t[link /reference/iterator/iter_difference_t.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
+* same_as[link /reference/concepts/same_as.md]
+* ITER_CONCEPT[link /reference/iterator/input_iterator.md#iter_concept]
 * iterator_traits[link /reference/iterator/iterator_traits.md]
+* conditional_t[link /reference/type_traits/conditional.md]
+* contiguous_iterator[link /reference/iterator/contiguous_iterator.md]
+* add_pointer_t[link /reference/type_traits/add_pointer.md]
+* iter_reference_t[link /reference/iterator/iter_reference_t.md]
 
 ## 概要
 `counted_iterator`は、イテレータをラップしてそこから指定されたカウント数の範囲を表現するイテレータアダプタである。
@@ -50,6 +50,7 @@ namespace std {
 | [`base`](counted_iterator/base.md)          | 元のイテレータを取得する | C++20 |
 | [`count`](counted_iterator/count.md)          | 代入演算子 | C++20 |
 | [`operator*`](counted_iterator/op_deref.md)           | 間接参照演算子 | C++20 |
+| [`operator-&amp;gt;`](counted_iterator/op_arrow.md.nolink)          | メンバアクセス演算子 | C++20 |
 | [`operator++`](counted_iterator/op_increment.md)      | イテレータをインクリメントする | C++20 |
 | [`operator--`](counted_iterator/op_decrement.md)      | イテレータをデクリメントする | C++20 |
 | [`operator+`](counted_iterator/op_plus.md)      | イテレータを進める | C++20 |
@@ -77,9 +78,15 @@ namespace std {
 ## メンバ型
 
 | 名前 | 説明 | 対応バージョン |
-|-----------------|-----|-------|
-| `iterator_type` | `I` | C++20 |
+|---------------------|-----|-------|
+| `iterator_type`     | `I` | C++20 |
+| `value_type`        | [`iter_value_t`](/reference/iterator/iter_value_t.md)`&amp;lt;I&amp;gt;`※1 | C++20 |
+| `difference_type`   | [`iter_difference_t`](/reference/iterator/iter_difference_t.md)`&amp;lt;I&amp;gt;` | C++20 |
+| `iterator_concept`  | `typename I::iterator_concept`※2 | C++20 |
+| `iterator_category` | `typename I::iterator_category`※2 | C++20 |
 
+- ※1 `I`が[`indirectly_readable`](/reference/iterator/indirectly_readable.md)のモデルである場合にのみ定義される
+- ※2 どちらも、対応するメンバ型が定義されている場合にのみ定義される
 
 ## 例
 
@@ -136,3 +143,4 @@ int main() {
 ## 参照
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [Hidden Friends - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20190531/p1)
+- [P2259R1 Repairing input range adaptors and `counted_iterator`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2259r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コルーチン -- Merge pull request #1169 from yknishidate/check-spell</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/coroutines.html"/>
      <id>9e167410f2b4f8f67e4c7a202dab872b788d46a2:lang/cpp20/coroutines.md</id>
      <updated>2023-09-22T01:34:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/coroutines.md b/lang/cpp20/coroutines.md
index 4796f99c3..133f5dce0 100644
--- a/lang/cpp20/coroutines.md
+++ b/lang/cpp20/coroutines.md
@@ -28,7 +28,7 @@ for (int v: g) {
 
 一般的なアプリケーション実装者からの利用を想定した、ジェネレータや非同期タスク・非同期I/Oといったハイレベルなコルーチンライブラリは、C++23以降での導入にむけて検討されている。
 
-C++23ではジェネレータコルーチンを実現する[`&amp;lt;generetor&amp;gt;`](/reference/generator.md)が追加された。
+C++23ではジェネレータコルーチンを実現する[`&amp;lt;generator&amp;gt;`](/reference/generator.md)が追加された。
 
 
 ### 特徴
@@ -601,7 +601,7 @@ C++20コルーチンはスタックレスコルーチンとして導入された
 （本ページ執筆時点では[提案文書P0876R10](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0876r10.pdf)が最新）
 
 C++20コルーチンでは、コルーチン・ステートのために動的メモリ確保が行われる可能性がある。
-一定条件を満たせばコンパイラ最適化によって動的メモリ確保が省略されるとしているが、言語仕様として動的メモリ確保を避ける仕様も検討された（通称&amp;#34;Core Coroutines&amp;#34;)。
+一定条件を満たせばコンパイラ最適化によって動的メモリ確保が省略されるとしているが、言語仕様として動的メモリ確保を避ける仕様も検討された（通称&amp;#34;Core Coroutines&amp;#34;）。
 最終的には既に実績のあるCoroutinesTS（発案者の名前にちなみ&amp;#34;Gor-routines&amp;#34;と呼ばれた）ベースのコルーチン仕様が採用されることになった。
 
 C++20コルーチンに関するキーワードは、いずれも接頭辞`co_`が付与されている。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ほとんどの`volatile`を非推奨化 -- Merge pull request #1169 from yknishidate/check-spell</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html"/>
      <id>9e167410f2b4f8f67e4c7a202dab872b788d46a2:lang/cpp20/deprecating_volatile.md</id>
      <updated>2023-09-22T01:34:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecating_volatile.md b/lang/cpp20/deprecating_volatile.md
index 8de6ac723..92c5e983f 100644
--- a/lang/cpp20/deprecating_volatile.md
+++ b/lang/cpp20/deprecating_volatile.md
@@ -254,7 +254,7 @@ auto&amp;amp;&amp;amp; [a, b, c] = f();  // OK、一時オブジェクト内各要素へのバ
 
 あるクラスが`volatile`な領域に配置されることもあればそうでない場合もある、という状況は考えづらく、そのような状況にあったとして、メンバ関数がどう有意義に異なるのかはさらに不明瞭である。
 
-さらに、コンストラクタやデストラクタは`const`も`voaltile`修飾もできないため、クラスのオブジェクトへの`volatile`性が有効になるのは派生先も含めてコンストラクタの呼び出しが完了した後からとなる（同様に、`volatile`性はデストラクタの呼び出し前までしか有効ではない）。
+さらに、コンストラクタやデストラクタは`const`も`volatile`修飾もできないため、クラスのオブジェクトへの`volatile`性が有効になるのは派生先も含めてコンストラクタの呼び出しが完了した後からとなる（同様に、`volatile`性はデストラクタの呼び出し前までしか有効ではない）。
 
 `volatile`においてはその領域へのアクセスが重要であり、1度のアクセスは正確に1度だけ行われる必要があり、その順序は前後してはならない。クラスのオブジェクトが`volatile`な領域に配置されるとき、`volatile`の保証なしで構築や破棄をすることは間違っている。クラスオブジェクトが`volatile`な領域に配置される場合は、そのメンバ変数を`volatile`修飾しておく事が望ましい。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- Merge pull request #1169 from yknishidate/check-spell</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>9e167410f2b4f8f67e4c7a202dab872b788d46a2:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-09-22T01:34:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index ece3e8084..88fa89496 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -167,8 +167,8 @@ C++においては、ポインタに対する演算（`+ -`など）はそのポ
 標準ライブラリ中の次の関数は、*implicit-lifetime types*に対して使用した場合に、その振る舞いの一環として指定された領域内にそのオブジェクトを暗黙的に構築する
 
 - `new`演算子
-    - `opreator new`
-    - `opreator new[]`
+    - `operator new`
+    - `operator new[]`
 - アロケータ
     - [`std::allocator&amp;lt;T&amp;gt;::allocate`](/reference/memory/allocator/allocate.md)
 - Cライブラリ関数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>確率が高い分岐と低い分岐を伝える属性 [[likely]], [[unlikely]] -- Merge pull request #1169 from yknishidate/check-spell</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/likely_and_unlikely_attributes.html"/>
      <id>9e167410f2b4f8f67e4c7a202dab872b788d46a2:lang/cpp20/likely_and_unlikely_attributes.md</id>
      <updated>2023-09-22T01:34:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/likely_and_unlikely_attributes.md b/lang/cpp20/likely_and_unlikely_attributes.md
index ffc6b9ed6..378e98ad6 100644
--- a/lang/cpp20/likely_and_unlikely_attributes.md
+++ b/lang/cpp20/likely_and_unlikely_attributes.md
@@ -52,7 +52,7 @@ std::string fizzbuzz(int n)
   }
 }
 // 上記例のlikely属性利用は適切ではない可能性もあり、
-// swtich文ラベルへ属性指定構文例示として解釈すること。
+// switch文ラベルへ属性指定構文例示として解釈すること。
 // 入力nがランダムと仮定すると 8/15=53.3% の分岐確率となり、
 // この程度の偏りに対して最適化効果が得られるかは未知数である。
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- Merge pull request #1169 from yknishidate/check-spell</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>9e167410f2b4f8f67e4c7a202dab872b788d46a2:lang/cpp20/modules.md</id>
      <updated>2023-09-22T01:34:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index d76553872..18ac40167 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -239,7 +239,7 @@ export using namespace N; // エラー: 新たな名前を宣言していない
 export {
   struct Foo { /*...*/ };                           // エクスポートされる
   static_assert(std::is_trivially_copyable_v&amp;lt;Foo&amp;gt;); // エラー: 新たな名前を宣言していない
-  using namespase std;                              // エラー: 新たな名前を宣言していない
+  using namespace std;                              // エラー: 新たな名前を宣言していない
 }
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>評価されない文脈でのラムダ式 -- Merge pull request #1169 from yknishidate/check-spell</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html"/>
      <id>9e167410f2b4f8f67e4c7a202dab872b788d46a2:lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md</id>
      <updated>2023-09-22T01:34:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md b/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md
index 1429ec81f..91a11fb10 100644
--- a/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md
+++ b/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md
@@ -51,7 +51,7 @@ auto s2 = sizeof([]{ return 0;}()); // 4
 6. 評価されない文脈であっても、ラムダ式の本体内で使用されている変数は暗黙的にキャプチャされる
     - 評価されない文脈で現れているラムダ式の本体内は評価されない文脈ではない
 7. 関数の本体の外側で、その関数の引数をキャプチャする事はできない
-8. `concpet`の定義内及び`requires`節の内部に現れているラムダ式本体のエラーはコンパイルエラーとなる
+8. `concept`の定義内及び`requires`節の内部に現れているラムダ式本体のエラーはコンパイルエラーとなる
 
 ```cpp
 // 1 クロージャ型にリンケージを付加できない（これらのCはリンケージを持たない）
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>評価されない文脈でのラムダ式 -- fix spell &#34;concpet&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html"/>
      <id>082b914d32b5d5baf063d4c1419979063ed1dd6c:lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md</id>
      <updated>2023-09-22T00:52:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md b/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md
index 1429ec81f..91a11fb10 100644
--- a/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md
+++ b/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.md
@@ -51,7 +51,7 @@ auto s2 = sizeof([]{ return 0;}()); // 4
 6. 評価されない文脈であっても、ラムダ式の本体内で使用されている変数は暗黙的にキャプチャされる
     - 評価されない文脈で現れているラムダ式の本体内は評価されない文脈ではない
 7. 関数の本体の外側で、その関数の引数をキャプチャする事はできない
-8. `concpet`の定義内及び`requires`節の内部に現れているラムダ式本体のエラーはコンパイルエラーとなる
+8. `concept`の定義内及び`requires`節の内部に現れているラムダ式本体のエラーはコンパイルエラーとなる
 
 ```cpp
 // 1 クロージャ型にリンケージを付加できない（これらのCはリンケージを持たない）
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>nishidate-yuki</name>
        <email>yuki18425@gmail.com</email>
      </author>
    </entry>
  
</feed>