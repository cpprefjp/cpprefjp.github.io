<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-16T04:09:55.669239</updated>
  <id>3ace7b42-2567-40ac-8ebf-7f48e852ad12</id>

  
    <entry>
      <title>cmath -- &lt;cmath&gt; : lerpの説明を補足</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>eaf722b020984fde1abdb2b50c1f39d8863ecb1b:reference/cmath.md</id>
      <updated>2023-02-16T13:04:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index 3ac2fc19f..484776a1d 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -98,7 +98,7 @@ C++23で`constexpr`対応する関数の条件は以下：
 
 [`nearbyint`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
-なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである。
+なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである ([`errno`](cerrno/errno.md)や浮動小数点例外のようなグローバル状態を使用しない)。
 
 #### 拡張浮動小数点数型への対応
 C++23では[`&amp;lt;stdfloat&amp;gt;`](stdfloat.md.nolink)に拡張浮動小数点数型が追加された。その対応として、以下のような`float`、`double`、`long double`に対するオーバーロードは、
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- abs, frexp, ilogb, ldexp : constexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/abs.html"/>
      <id>d3cb0839fde2f6b6534b5ba13db0c0c045804d9d:reference/cmath/abs.md</id>
      <updated>2023-02-16T12:56:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/abs.md b/reference/cmath/abs.md
index 4f35a45bf..1505b65f0 100644
--- a/reference/cmath/abs.md
+++ b/reference/cmath/abs.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std {
-  float abs(float x);             // (1)
-  double abs(double x);           // (2)
-  long double abs(long double x); // (3)
+  float abs(float x);                       // (1) C++03からC++20まで
 
-  double abs(Integral x);     // (4) C++11 から C++14 まで
+  double abs(double x);                     // (2) C++03からC++20まで
 
-  int abs(int x);             // (5) C++17 から
-  long abs(long int x);       // (6) C++17 から
-  long long abs(long long x); // (7) C++17 から
+  long double abs(long double x);           // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    abs(floating-point-type x);             // (4) C++23
+
+  double abs(Integral x);                   // (5) C++11 から C++14 まで
+
+  int abs(int x);                           // (6) C++17
+  constexpr int abs(int x);                 // (6) C++23
+
+  long abs(long int x);                     // (7) C++17
+  constexpr long abs(long int x);           // (7) C++23
+
+  long long abs(long long x);               // (8) C++17
+  constexpr long long abs(long long x);     // (8) C++23
 }
 ```
 * Integral[italic]
@@ -22,6 +32,15 @@ namespace std {
 ## 概要
 浮動小数点数型の絶対値を求める。abs は absolute value（絶対値）の略。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `int`に対するオーバーロード
+- (7) : `long int`に対するオーバーロード
+- (8) : `long long`に対するオーバーロード
+
 
 ## 戻り値
 引数 `x` の絶対値を返す。
@@ -31,7 +50,8 @@ namespace std {
 
 ## 備考
 - $$ f(x) = | x | $$
-- 任意の整数型に対するオーバーロード(4)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(5),(6),(7)が追加された。
+- 任意の整数型に対するオーバーロード(5)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(6),(7),(8)が追加された
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -76,3 +96,10 @@ namespace std {
   }
 }
 ```
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>frexp -- abs, frexp, ilogb, ldexp : constexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/frexp.html"/>
      <id>d3cb0839fde2f6b6534b5ba13db0c0c045804d9d:reference/cmath/frexp.md</id>
      <updated>2023-02-16T12:56:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/frexp.md b/reference/cmath/frexp.md
index edef8a649..27e351ad4 100644
--- a/reference/cmath/frexp.md
+++ b/reference/cmath/frexp.md
@@ -5,25 +5,46 @@
 
 ```cpp
 namespace std {
-  float frexp(float value, int* exp);
-  double frexp(double value, int* exp);
-  long double frexp(long double value, int* exp);
-
-  double frexp(Integral value, int* exp);           // C++11 から
-
-  float frexpf(float value, int* exp);              // C++17 から
-  long double frexpl(long double value, int* exp);  // C++17 から
+  float frexp(float value, int* exp);             // (1) C++03からC++20まで
+  double frexp(double value, int* exp);           // (2) C++03からC++20まで
+  long double frexp(long double value, int* exp); // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    frexp(floating-point-type value, int* exp);   // (4) C++23
+
+  double
+    frexp(Integral value, int* exp);              // (5) C++11
+  constexpr double
+    frexp(Integral value, int* exp);              // (5) C++23
+
+  float
+    frexpf(float value, int* exp);                // (6) C++17
+  constexpr float
+    frexpf(float value, int* exp);                // (6) C++23
+
+  long double
+    frexpl(long double value, int* exp);          // (7) C++17
+  constexpr long double
+    frexpl(long double value, int* exp);          // (7) C++23
 }
 ```
 * Integral[italic]
 
 ## 概要
-`frexp`関数 (fraction and exponent)は、浮動小数点数`value`を、正規化された仮数部と 2 の累乗へ分解する。
+`frexp`関数 (fraction and exponent) は、浮動小数点数`value`を、正規化された仮数部と 2 の累乗へ分解する。
 
 この関数は、与えられた浮動小数点数`value`を仮数部と指数部に分解し、仮数部を戻り値で返し、指数を`*exp`に書き込んで返す。
 
 この関数と反対に、[`std::ldexp()`](ldexp.md)関数を使用することで、仮数部と指数部の値から浮動小数点数を作り出せる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `value` が浮動小数点数ではない、もしくは2の乗数が `int` の範囲外である場合、戻り値は未規定。
@@ -39,7 +60,8 @@ C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std:
 - `value = ±0` の場合、戻り値は `±0` となり、`*exp` にはゼロが設定される。
 - `value = ±∞` の場合、戻り値は `±∞` となり、`*exp` には未規定の値が設定される。
 - `value` が NaN の場合、戻り値は NaN となり、`*exp` には未規定の値が設定される。
-- `frexp` は浮動小数点例外を全く発生させない。
+- この関数は浮動小数点例外を発生させない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -68,4 +90,7 @@ int main()
 ## 参照
 - [Why does `frexp()` not yield scientific notation?](http://stackoverflow.com/questions/24928833/why-does-frexp-not-yield-scientific-notation)
     - `frexp()`が戻り値を`[1, 2)`の範囲ではなく、`[0.5, 1)`の範囲に収めるようにしている理由は、IEEE 754およびISO/IEC 60559が策定される前に作られた関数であることが理由と考えられる
-
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ilogb -- abs, frexp, ilogb, ldexp : constexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ilogb.html"/>
      <id>d3cb0839fde2f6b6534b5ba13db0c0c045804d9d:reference/cmath/ilogb.md</id>
      <updated>2023-02-16T12:56:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ilogb.md b/reference/cmath/ilogb.md
index 7822ca28d..7c1faa8e7 100644
--- a/reference/cmath/ilogb.md
+++ b/reference/cmath/ilogb.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  int ilogb(float);
-  int ilogb(double);
-  int ilogb(long double);
+  int ilogb(float x);             // (1) C++11からC++20まで
+  int ilogb(double x);            // (2) C++11からC++20まで
+  int ilogb(long double x);       // (3) C++11からC++20まで
 
-  int ilogb(Integral);
+  constexpr int
+    ilogb(floating-point-type x); // (3) C++23
 
-  int ilogbf(float x);          // C++17 から
-  int ilogbl(long double x);    // C++17 から
+  int
+    ilogb(Integral);              // (4) C++11
+  constexpr int
+    ilogb(Integral);              // (4) C++23
+
+  int
+    ilogbf(float x);              // (5) C++17
+  constexpr int
+    ilogbf(float x);              // (5) C++23
+
+  int
+    ilogbl(long double x);        // (6) C++17
+  constexpr int
+    ilogbl(long double x);        // (6) C++23
 }
 ```
 * Integral[italic]
@@ -21,6 +34,14 @@ namespace std {
 ## 概要
 `ilogb`関数(integer log binary)は、浮動小数点数 `x` の指数部を `int` として返す。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `x` がゼロの場合は [`FP_ILOGB0`](fp_ilogb0.md) を、無限大の場合は [`INT_MAX`](/reference/climits/int_max.md) を、`NaN` の場合は [`FP_ILOGBNAN`](fp_ilogbnan.md) を返す。
@@ -34,6 +55,7 @@ namespace std {
 	- 正しい結果が戻り値の型（`int`）の範囲で表現可能な場合は、戻り値は正確で、現在の丸め方式に依存しない。
 	- 正しい結果が戻り値の型（`int`）の範囲外の場合は、戻り値は未規定で、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
 	- `x` がゼロ、無限大、あるいは NaN の場合には、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -74,3 +96,10 @@ ilogb(1e-309) = -1027
 - [GCC](/implementation.md#gcc): 4.3.6
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ldexp -- abs, frexp, ilogb, ldexp : constexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ldexp.html"/>
      <id>d3cb0839fde2f6b6534b5ba13db0c0c045804d9d:reference/cmath/ldexp.md</id>
      <updated>2023-02-16T12:56:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ldexp.md b/reference/cmath/ldexp.md
index 188760182..c8e973c15 100644
--- a/reference/cmath/ldexp.md
+++ b/reference/cmath/ldexp.md
@@ -5,14 +5,27 @@
 
 ```cpp
 namespace std {
-  float ldexp(float x, int exp);
-  double ldexp(double x, int exp);
-  long double ldexp(long double x, int exp);
-
-  double ldexp(Integral x, int exp);            // C++11 から
-
-  float ldexpf(float x, int exp);               // C++17 から
-  long double ldexpl(long double x, int exp);   // C++17 から
+  float ldexp(float x, int exp);                // (1) C++03からC++20まで
+  double ldexp(double x, int exp);              // (2) C++03からC++20まで
+  long double ldexp(long double x, int exp);    // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    ldexp(floating-point-type x, int exp);      // (4) C++23
+
+  double
+    ldexp(Integral x, int exp);                 // (5) C++11
+  constexpr double
+    ldexp(Integral x, int exp);                 // (5) C++23
+
+  float
+    ldexpf(float x, int exp);                   // (6) C++17
+  constexpr float
+    ldexpf(float x, int exp);                   // (6) C++23
+
+  long double
+    ldexpl(long double x, int exp);             // (7) C++17
+  constexpr long double
+    ldexpl(long double x, int exp);             // (7) C++23
 }
 ```
 * Integral[italic]
@@ -24,6 +37,14 @@ namespace std {
 
 この関数と反対に、[`std::frexp()`](frexp.md)関数を使用することで、浮動小数点数を仮数部と指数部に分解できる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 &amp;lt;code&amp;gt;x * 2&amp;lt;sup&amp;gt;exp&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt;
@@ -34,6 +55,7 @@ namespace std {
 ## 備考
 - オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、かつ、基数が 2 の場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`radix`](../limits/numeric_limits/radix.md)`() == 2`）、[`scalbn`](scalbn.md)`(x, exp)` と等価である。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -89,3 +111,9 @@ namespace std {
 }
 ```
 * std::pow[link pow.md]
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : C++23での変更概要をまとめた #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>a26647ae2a5f030130be55e76162716598002d6c:reference/cmath.md</id>
      <updated>2023-02-16T12:40:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index 9bfc4a6cd..3ac2fc19f 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -85,6 +85,37 @@
     * Promoted[italic]
 
 
+### C++23での差異
+#### constexpr対応
+C++23では、多くの数学関数が`constexpr`に対応し、定数式内で使用できるようになった。C++23時点では、コンパイラベンダの負担が低い機能を`constexpr`対応した。
+
+C++23で`constexpr`対応する関数の条件は以下：
+
+1. 有理数の集合、または実数のどこにも密でない部分集合に作用すると見なされ、関数が閉じていること
+2. 関数が丸めモードに強く依存しないこと
+
+[`exp()`](cmath/exp.md)、[`sqrt()`](cmath/sqrt.md)、[`cos()`](cmath/cos.md)、[`sin()`](cmath/sin.md)は1. の条件を満たさないため、C++23では`constexpr`に対応しない。
+
+[`nearbyint`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
+
+なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである。
+
+#### 拡張浮動小数点数型への対応
+C++23では[`&amp;lt;stdfloat&amp;gt;`](stdfloat.md.nolink)に拡張浮動小数点数型が追加された。その対応として、以下のような`float`、`double`、`long double`に対するオーバーロードは、
+
+```cpp
+float abs(float x);
+double abs(double x);
+long double abs(long double x);
+```
+
+以下のように`floating-point-type`へのオーバーロードに統合され、拡張浮動小数点数型も扱えるようになった。
+
+```cpp
+floating-point-type abs(floating-point-type x);
+```
+
+
 ## &amp;lt;a id=&amp;#34;error-handling&amp;#34; href=&amp;#34;#error-handling&amp;#34;&amp;gt;エラーの扱い&amp;lt;/a&amp;gt;
 `&amp;lt;cmath&amp;gt;` で提供される各関数は、特に明記されていない限り、引数の型が表現できる全ての値についての挙動が定義されている。
 なお、ここで言う「挙動が定義されている」とは、未定義動作を引き起こさないというだけで、エラーが発生したり、実装依存の挙動となる場合がある事に注意。
@@ -169,6 +200,18 @@ C++03 までの場合、[`errno`](cerrno/errno.md) でしか通知されない
 特に、[`fesetround`](cfenv/fesetround.md) で設定した丸め方式に従うとは限らないため、注意が必要である。
 
 
+## 定数式になる条件
+
+`constexpr`対応する数学関数において、以下のいずれかの条件に合致する場合、定数式とならない (引数によってコンパイルエラーになる)
+
+- [`FE_INEXACT`](cfenv/fe_inexact.md)以外の、以下の浮動小数点例外が発生した場合：
+    - [`FE_DIVBYZERO`](cfenv/fe_divbyzero.md) (ゼロ除算)
+    - [`FE_INVALID`](cfenv/fe_invalid.md) (不正な演算)
+    - [`FE_OVERFLOW`](cfenv/fe_overflow.md) (オーバーフロー)
+    - [`FE_UNDERFLOW`](cfenv/fe_underflow.md) (アンダーフロー)
+- [`math_errhandling`](cmath/math_errhandling.md) `&amp;amp;` [`MATH_ERRNO`](cmath/math_errno.md)が真で、[`errno`](cerrno/errno.md)が設定された場合
+
+
 ## &amp;lt;a id=&amp;#34;trigonometric-functions&amp;#34; href=&amp;#34;#trigonometric-functions&amp;#34;&amp;gt;三角関数&amp;lt;/a&amp;gt;
 
 | 名前 | 説明 | 対応バージョン |
@@ -417,3 +460,5 @@ NaN を返さなければならないが定義域エラーを報告してはな
 - [N1568 Proposed additions to TR-1 to improve compatibility with C99](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1568.htm)
 - [P00175R0 Synopses for the C library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0175r0.html)
     - C++17 から`f`、`l`サフィックス付きのC関数を導入
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shared_timed_mutex -- Merge pull request #1126 from cpprefjp/yutopp-patch-1</title>
      <link href="https://cpprefjp.github.io/reference/shared_mutex/shared_timed_mutex.html"/>
      <id>24c4e8a3e69f4bba9ea5eb43ad44588fb8340f3f:reference/shared_mutex/shared_timed_mutex.md</id>
      <updated>2023-02-15T19:07:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/shared_mutex/shared_timed_mutex.md b/reference/shared_mutex/shared_timed_mutex.md
index 64940c2d7..07aaa1a92 100644
--- a/reference/shared_mutex/shared_timed_mutex.md
+++ b/reference/shared_mutex/shared_timed_mutex.md
@@ -96,7 +96,7 @@ public:
   {
     int local_count;
     {
-      std::shared_lock&amp;lt;std::shared_mutex&amp;gt; lock(mtx_);
+      std::shared_lock&amp;lt;std::shared_timed_mutex&amp;gt; lock(mtx_);
       local_count = count_;
     } // 共有ロックをここで手放す
     print_value(local_count);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shared_timed_mutex -- typo/コンパイルエラーの修正: shared_mutex→shared_timed_mutex</title>
      <link href="https://cpprefjp.github.io/reference/shared_mutex/shared_timed_mutex.html"/>
      <id>20ed53df537f4456bc971969411f1277bbeb22f0:reference/shared_mutex/shared_timed_mutex.md</id>
      <updated>2023-02-15T17:44:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/shared_mutex/shared_timed_mutex.md b/reference/shared_mutex/shared_timed_mutex.md
index 64940c2d7..07aaa1a92 100644
--- a/reference/shared_mutex/shared_timed_mutex.md
+++ b/reference/shared_mutex/shared_timed_mutex.md
@@ -96,7 +96,7 @@ public:
   {
     int local_count;
     {
-      std::shared_lock&amp;lt;std::shared_mutex&amp;gt; lock(mtx_);
+      std::shared_lock&amp;lt;std::shared_timed_mutex&amp;gt; lock(mtx_);
       local_count = count_;
     } // 共有ロックをここで手放す
     print_value(local_count);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yutopp</name>
        <email>yutopp@gmail.com</email>
      </author>
    </entry>
  
</feed>