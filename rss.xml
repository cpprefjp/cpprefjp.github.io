<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-17T05:57:05.081077</updated>
  <id>51bfee8d-2a33-4598-82a2-7a0c61119c3e</id>

  
    <entry>
      <title>hash -- functional/hash: メンバ型is_transparent 説明文を見直し</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>16cab03355668b5b677440ac2a954a3d72817aa2:reference/functional/hash.md</id>
      <updated>2023-02-17T14:51:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index a2df8a8dd..f2bcb7730 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -80,7 +80,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt; 標準ライブラリの`hash`クラスの特殊化がこの型を持つかは未規定。&amp;lt;br/&amp;gt; この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
+| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt;この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functional/hash: 透過的ハッシュ/等値比較の例示コードを改善</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>5415e29dfd912b953b8249e2d1b51dd18f57c4b5:reference/functional/hash.md</id>
      <updated>2023-02-17T14:13:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index 09717118b..a2df8a8dd 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -123,16 +123,25 @@ int main()
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;unordered_map&amp;gt;
 #include &amp;lt;string&amp;gt;
+#include &amp;lt;string_view&amp;gt;
+
+struct string_hash {
+  using is_transparent = void;
+  // string/string_view/const char*共用ハッシュ計算
+  size_t operator()(std::string_view sv) const {
+    return std::hash&amp;lt;std::string_view&amp;gt;{}(sv);
+  }
+};
 
 int main()
 {
-  std::unordered_map&amp;lt;std::string, int&amp;gt; um = {
+  std::unordered_map&amp;lt;std::string, int, string_hash, std::equal_to&amp;lt;&amp;gt;&amp;gt; um = {
     {&amp;#34;Alice&amp;#34;, 3},
     {&amp;#34;Bob&amp;#34;, 1},
     {&amp;#34;Carol&amp;#34;, 4}
   };
 
-  // std::equal_to&amp;lt;std::string&amp;gt;とstd::hash&amp;lt;std::string&amp;gt;がis_transparent型を持つ場合、
+  // string_hashおよびstd::equal_to&amp;lt;&amp;gt;はいずれもメンバ型にis_transparentを持つため、
   // find()などの検索関数に引数を渡す場合に、std::string一時オブジェクトが作られない
   auto it = um.find(&amp;#34;Alice&amp;#34;);
   if (it != um.end()) {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>畳み込み式 -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/folding_expressions.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:lang/cpp17/folding_expressions.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/folding_expressions.md b/lang/cpp17/folding_expressions.md
index 91dfaec80..a27b9224f 100644
--- a/lang/cpp17/folding_expressions.md
+++ b/lang/cpp17/folding_expressions.md
@@ -200,16 +200,16 @@ template&amp;lt;typename BinaryFunction&amp;gt; struct empty_fold
 
 この方法は可能な限りジェネリックであるが、以下のような問題があった:
 
-* 空のパラメータパックは型付けされていないが、返り値の型は他の型に文脈的に変換可能である (暗黙の型変換につながり得る)
+* 空のパラメータパックは型付けされていないが、戻り値の型は他の型に文脈的に変換可能である (暗黙の型変換につながり得る)
 * テンプレート特殊化だけのために関数をオブジェクトしなければならない
 * サポートする演算子と等価な関数オブジェクト間のマッピングを用意しなければならない
 
 結局のところこれは問題の解決にはつながらず、負担も大きいことから採用されなかった。
 
 
-##### 返り値の型推論
+##### 戻り値の型推論
 
-可能であれば空の畳み込みから返り値の型推論を行い、そうでなければプログラムを不適格とする。  
+可能であれば空の畳み込みから戻り値の型推論を行い、そうでなければプログラムを不適格とする。  
 例えば以下の例では `std::string` に推論する:
 ```cpp
 auto res =  (std::string(args) + ...);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cmath.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index a0b536acc..6104a3c3a 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -62,11 +62,11 @@
 	なお、C++11 の記載にある無条件のキャストは規格のバグとされたため、C++11 であってもスコープ付き列挙型や explicit な変換演算子のあるクラス型に、上記規則にある無条件のキャストが適用されると想定すべきではない。  
 	（[LWG 2086. Overly generic type support for math functions](http://cplusplus.github.io/LWG/lwg-defects.html#2086) 参照）
 
-	各関数の個別ページでは、上記のオーバーロード関数をコードで示す際には、引数や返値の型を斜体で示す。
+	各関数の個別ページでは、上記のオーバーロード関数をコードで示す際には、引数や戻り値の型を斜体で示す。
     ```cpp
     Integral      // 任意の整数型
     Arithmetic    // 任意の算術型
-    Promoted      // 決定された返値型
+    Promoted      // 決定された戻り値型
     ```
     * Integral[italic]
     * Arithmetic[italic]
@@ -447,8 +447,8 @@ NaN を返さなければならないが定義域エラーを報告してはな
 | [`FP_FAST_FMA`](cmath/fp_fast_fma.md)   | `double` 型の `fma` 関数がより高速な実装であるか | C++11 |
 | [`FP_FAST_FMAF`](cmath/fp_fast_fmaf.md) | `float` 型の `fma` 関数がより高速な実装であるか  | C++11 |
 | [`FP_FAST_FMAL`](cmath/fp_fast_fmal.md) | `long double` 型の `fma` 関数がより高速な実装であるか | C++11 |
-| [`FP_ILOGB0`](cmath/fp_ilogb0.md)       | `ilogb(0)` の返値を表す整数定数式 | C++11 |
-| [`FP_ILOGBNAN`](cmath/fp_ilogbnan.md)   | `ilogb(NaN)` の返値を表す整数定数式 | C++11 |
+| [`FP_ILOGB0`](cmath/fp_ilogb0.md)       | `ilogb(0)` の戻り値を表す整数定数式 | C++11 |
+| [`FP_ILOGBNAN`](cmath/fp_ilogbnan.md)   | `ilogb(NaN)` の戻り値を表す整数定数式 | C++11 |
 | [`MATH_ERRNO`](cmath/math_errno.md)             | 数学ライブラリ内で`errno`にエラーが設定されたかを表す整数定数 | C++11 |
 | [`MATH_ERREXCEPT`](cmath/math_errexcept.md)     | 数学ライブラリ内で浮動小数点例外が発生したかを表す整数定数 | C++11 |
 | [`math_errhandling`](cmath/math_errhandling.md) | `&amp;lt;cmath&amp;gt;` 内の関数がエラーをどのように取り扱うかを表すマクロ | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>beta -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cmath/beta.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cmath/beta.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/beta.md b/reference/cmath/beta.md
index a6750ca45..ef26eca01 100644
--- a/reference/cmath/beta.md
+++ b/reference/cmath/beta.md
@@ -64,7 +64,7 @@ beta(2, 4)      = 0.05
 GCC 7.1.0–8.0.0 では `beta` は [`exp`](exp.md) と [`lgamma`](lgamma.md) を用いて
 $ |\mathrm{B}(x, y)| = \exp(\ln |\Gamma(x) \Gamma(y) / \Gamma(x + y)|)) $
 を計算する。
-`x &amp;lt; 0 || y &amp;lt; 0` でも定義域エラーを報告せずに値を返すが、返り値は必ず正になる。
+`x &amp;lt; 0 || y &amp;lt; 0` でも定義域エラーを報告せずに値を返すが、戻り値は必ず正になる。
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>FP_ILOGB0 -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fp_ilogb0.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cmath/fp_ilogb0.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fp_ilogb0.md b/reference/cmath/fp_ilogb0.md
index c36b8665b..98b04c263 100644
--- a/reference/cmath/fp_ilogb0.md
+++ b/reference/cmath/fp_ilogb0.md
@@ -9,7 +9,7 @@
 * implementation_defined[italic]
 
 ## 概要
-`FP_ILOGB0` は、[`std::ilogb`](ilogb.md)`(0)` の返り値を表す整数定数式である。
+`FP_ILOGB0` は、[`std::ilogb`](ilogb.md)`(0)` の戻り値を表す整数定数式である。
 
 [`INT_MIN`](/reference/climits/int_min.md) と `-`[`INT_MAX`](/reference/climits/int_max.md) のうち少なくとも片方と等しい値でなければならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>FP_ILOGBNAN -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fp_ilogbnan.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cmath/fp_ilogbnan.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fp_ilogbnan.md b/reference/cmath/fp_ilogbnan.md
index 66243c1ef..1e45da9ec 100644
--- a/reference/cmath/fp_ilogbnan.md
+++ b/reference/cmath/fp_ilogbnan.md
@@ -9,7 +9,7 @@
 * implementation_defined[italic]
 
 ## 概要
-`FP_ILOGBNAN` は、[`std::ilogb()`](ilogb.md) に `NaN` を渡したときの返り値を表す整数定数式である。
+`FP_ILOGBNAN` は、[`std::ilogb()`](ilogb.md) に `NaN` を渡したときの戻り値を表す整数定数式である。
 
 [`INT_MIN`](/reference/climits/int_min.md) と [`INT_MAX`](/reference/climits/int_max.md) いずれかと等しい値でなければならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>size_t -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/cstddef/size_t.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/cstddef/size_t.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstddef/size_t.md b/reference/cstddef/size_t.md
index f669a2d23..55cd26b59 100644
--- a/reference/cstddef/size_t.md
+++ b/reference/cstddef/size_t.md
@@ -13,7 +13,7 @@ namespace std {
 `size_t`は、オブジェクトのバイト数を表現できる程度に十分に大きい符号なし整数型である。
 C++03まではC言語と同じく「`sizeof`演算子によって返される符号なし整数型」と規定されていた。
 
-オブジェクトのバイト数（例えば[`malloc`](/reference/cstdlib.md)の引数）やコンテナの要素数（例えば[`std::size()`](/reference/iterator/size.md)の返り値）を表現するために用いられる。
+オブジェクトのバイト数（例えば[`malloc`](/reference/cstdlib.md)の引数）やコンテナの要素数（例えば[`std::size()`](/reference/iterator/size.md)の戻り値）を表現するために用いられる。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>make_from_tuple -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/tuple/make_from_tuple.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/tuple/make_from_tuple.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/make_from_tuple.md b/reference/tuple/make_from_tuple.md
index b11772dab..5aca1111f 100644
--- a/reference/tuple/make_from_tuple.md
+++ b/reference/tuple/make_from_tuple.md
@@ -25,7 +25,7 @@ namespace std {
 
 また、型`T`の初期化はそのコンストラクタで行われ集成体初期化は考慮されない。つまり、`Tuple`に含まれる型が空かただ一つの`T`でない場合、型`T`は集成体（aggregate）であってはならない（C++17のみ、C++20以降はok）。
 
-更に、C++23以降は`make_from_tuple`の返り値が参照である場合でダングリング参照を生成しないために、`make_from_tuple`の内部で`T`が構築される際に、`Tuple`から取得されるオブジェクト（参照の初期化であるので、`Tuple`のサイズは1である必要がある）の寿命が延長されないことも要求され、これを満たさない場合はコンパイルエラーとなる。
+更に、C++23以降は`make_from_tuple`の戻り値が参照である場合でダングリング参照を生成しないために、`make_from_tuple`の内部で`T`が構築される際に、`Tuple`から取得されるオブジェクト（参照の初期化であるので、`Tuple`のサイズは1である必要がある）の寿命が延長されないことも要求され、これを満たさない場合はコンパイルエラーとなる。
 正確には、[`tuple_size_v`](tuple_size.md)`&amp;lt;`[`remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;Tuple&amp;gt;&amp;gt; == 1`である場合、[`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;T, decltype(get&amp;lt;0&amp;gt;(`[`declval`](/reference/utility/declval.md)`&amp;lt;Tuple&amp;gt;()))&amp;gt; == false`であること。
 
 ## 引数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_cat -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_cat.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/tuple/tuple_cat.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_cat.md b/reference/tuple/tuple_cat.md
index 5827bea6e..095d19d56 100644
--- a/reference/tuple/tuple_cat.md
+++ b/reference/tuple/tuple_cat.md
@@ -28,7 +28,7 @@ namespace std {
     - `Tuples...`の全ての型が[`std::tuple`](tuple.md)`&amp;lt;Args...&amp;gt;`であること。
     - `Args...`の各型が左辺値参照であればコピー構築可能、そうでなければムーブ構築可能であること。
 - C++23から :
-    - 本関数の返り値の[`tuple`](tuple.md)のテンプレートパラメーターパックを`Ctypes`とし、`Ctypes`の全ての要素について、引数`tpls`において対応する要素の型から構築可能であること。
+    - 本関数の戻り値の[`tuple`](tuple.md)のテンプレートパラメーターパックを`Ctypes`とし、`Ctypes`の全ての要素について、引数`tpls`において対応する要素の型から構築可能であること。
     - より厳密には、次のように定義を行い、`(`[`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;CTypes, decltype(celems)&amp;gt; &amp;amp;&amp;amp; ...) == true`であること。
         - `n`を`sizeof...(Tuples)`とし、`i`を範囲`[0, n)`における整数値とする
         - `T(i)`を`Tuples`の`i`番目とする
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_invocable_r -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/is_invocable_r.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/type_traits/is_invocable_r.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/is_invocable_r.md b/reference/type_traits/is_invocable_r.md
index 6620732bf..84996582c 100644
--- a/reference/type_traits/is_invocable_r.md
+++ b/reference/type_traits/is_invocable_r.md
@@ -66,8 +66,8 @@ int main()
 
   std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
 
-  // INVOKE、つまり std::invoke の返り値である S が
-  // R に束縛されて R の寿命と同じ寿命に延長された上で std::invoke_r の返り値となる
+  // INVOKE、つまり std::invoke の戻り値である S が
+  // R に束縛されて R の寿命と同じ寿命に延長された上で std::invoke_r の戻り値となる
   // しかし R の寿命はこの1文の間だけなので、S もこの1文が終了する際に破棄される
   const S&amp;amp; a = std::invoke_r&amp;lt;R&amp;gt;([]() { return S{}; });
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reference_constructs_from_temporary -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/reference_constructs_from_temporary.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/type_traits/reference_constructs_from_temporary.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/reference_constructs_from_temporary.md b/reference/type_traits/reference_constructs_from_temporary.md
index c02a78c88..05d91676b 100644
--- a/reference/type_traits/reference_constructs_from_temporary.md
+++ b/reference/type_traits/reference_constructs_from_temporary.md
@@ -37,9 +37,9 @@ namespace std {
 
 
 ## 備考
-多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「返り値の型が右辺値参照である関数」の返り値を束縛することを考える。（再現コードは、説明の最後に付す）
+多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「戻り値の型が右辺値参照である関数」の戻り値を束縛することを考える。（再現コードは、説明の最後に付す）
 
-この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は返り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
+この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は戻り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
 
 このような場面においては、本メタ関数が`pvalue`と`xvalue`を、`pvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
 
@@ -55,11 +55,11 @@ S&amp;amp;&amp;amp; f() { return S{}; }
 
 int main() {
   std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
-  
-  // f の返り値は s に束縛されて寿命が延長されたか？
-  // 実際にはこの宣言の1文が終了した際に f の返り値は破棄されている
+
+  // f の戻り値は s に束縛されて寿命が延長されたか？
+  // 実際にはこの宣言の1文が終了した際に f の戻り値は破棄されている
   S&amp;amp;&amp;amp; s(f());
-  
+
   std::cout &amp;lt;&amp;lt; &amp;#34;2&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reference_converts_from_temporary -- 返り値、返値 : 訳語表に基づいて「戻り値」に修正</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html"/>
      <id>ba05560fb997bdded15d10da0863ffb56166bee0:reference/type_traits/reference_converts_from_temporary.md</id>
      <updated>2023-02-16T18:06:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/reference_converts_from_temporary.md b/reference/type_traits/reference_converts_from_temporary.md
index 0cff142fc..63ea01dea 100644
--- a/reference/type_traits/reference_converts_from_temporary.md
+++ b/reference/type_traits/reference_converts_from_temporary.md
@@ -33,9 +33,9 @@ namespace std {
 
 
 ## 備考
-多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「返り値の型が右辺値参照である関数」の返り値を束縛することを考える。（再現コードは、説明の最後に付す）
+多くのメタ関数は`pvalue`と`xvalue`を区別しないが、このメタ関数は区別する。例えば、右辺値参照に「戻り値の型が右辺値参照である関数」の戻り値を束縛することを考える。（再現コードは、説明の最後に付す）
 
-この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は返り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
+この事自体は即座に不適格とはならない。しかし、その関数が実際には`pvalue`を返しているとすれば、その`pvalue`は戻り値の時点で右辺値参照に束縛されるため、それを右辺値参照に束縛したとしても寿命は延長されることはない。そのため、最終的にダングリング参照を生じることとなる。
 
 このような場面においては、本メタ関数が`pvalue`と`xvalue`を、`pvalue`を`T`（参照なしの型）として、`xvalue`を`T&amp;amp;&amp;amp;`（右辺値参照である型、転送参照(Forwarding Reference) を意味しているわけではない）として区別すれば検出が可能となる。
 
@@ -51,11 +51,11 @@ S&amp;amp;&amp;amp; f() { return S{}; }
 
 int main() {
   std::cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; std::endl;
-  
-  // f の返り値は s に束縛されて寿命が延長されたか？
-  // 実際にはこの宣言の1文が終了した際に f の返り値は破棄されている
+
+  // f の戻り値は s に束縛されて寿命が延長されたか？
+  // 実際にはこの宣言の1文が終了した際に f の戻り値は破棄されている
   S&amp;amp;&amp;amp; s = f();
-  
+
   std::cout &amp;lt;&amp;lt; &amp;#34;2&amp;#34; &amp;lt;&amp;lt; std::endl;
 }
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : small fix</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>5419582e559fd5c88d719564587a9ca714844e5d:reference/cmath.md</id>
      <updated>2023-02-16T17:57:36+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index d444ed428..a0b536acc 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -94,9 +94,9 @@ C++23で`constexpr`対応する関数の条件は以下：
 1. 有理数の集合、または実数のどこにも密でない部分集合に作用すると見なされ、関数が閉じていること
 2. 関数が丸めモードに強く依存しないこと
 
-[`exp()`](cmath/exp.md)、[`sqrt()`](cmath/sqrt.md)、[`cos()`](cmath/cos.md)、[`sin()`](cmath/sin.md)は1. の条件を満たさないため、C++23では`constexpr`に対応しない。
+[`exp()`](cmath/exp.md)、[`log()`](cmath/log.md)、[`sqrt()`](cmath/sqrt.md)、[`cos()`](cmath/cos.md)、[`sin()`](cmath/sin.md)は1. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
-[`nearbyint`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
+[`nearbyint()`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
 ただし、コンパイラが先行して`constexpr`非対応の関数も対応している可能性がある。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index c16eeaa1a..d444ed428 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -255,13 +255,13 @@ C++03 までの場合、[`errno`](cerrno/errno.md) でしか通知されない
 
 | 名前 | 説明 | 対応バージョン |
 |-----------|----------------------------------|-------|
-| [`ldexp`](cmath/ldexp.md)    | 2 の累乗との乗算                 | |
-| [`frexp`](cmath/frexp.md)    | 仮数部と 2 の累乗への分解        | |
-| [`ilogb`](cmath/ilogb.md)    | 指数部を符号付き整数値として抽出 | C++11 |
-| [`logb`](cmath/logb.md)      | 指数部を浮動小数点数値として抽出 | C++11 |
-| [`modf`](cmath/modf.md)      | 整数部と小数部への分解           | |
-| [`scalbn`](cmath/scalbn.md)  | 内部表現の基数 (`FLT_RADIX`) の累乗との乗算 | C++11 |
-| [`scalbln`](cmath/scalbn.md) | 内部表現の基数 (`FLT_RADIX`) の累乗との乗算 | C++11 |
+| [`ldexp`](cmath/ldexp.md)     | 2 の累乗との乗算                 | |
+| [`frexp`](cmath/frexp.md)     | 仮数部と 2 の累乗への分解        | |
+| [`ilogb`](cmath/ilogb.md)     | 指数部を符号付き整数値として抽出 | C++11 |
+| [`logb`](cmath/logb.md)       | 指数部を浮動小数点数値として抽出 | C++11 |
+| [`modf`](cmath/modf.md)       | 整数部と小数部への分解           | |
+| [`scalbn`](cmath/scalbn.md)   | 内部表現の基数 (`FLT_RADIX`) の累乗との乗算 | C++11 |
+| [`scalbln`](cmath/scalbln.md) | 内部表現の基数 (`FLT_RADIX`) の累乗との乗算。乗数として`long`をとる | C++11 |
 
 
 ## &amp;lt;a id=&amp;#34;power-and-absolute-value-functions&amp;#34; href=&amp;#34;#power-and-absolute-value-functions&amp;#34;&amp;gt;累乗・冪根と絶対値&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/abs.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/abs.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/abs.md b/reference/cmath/abs.md
index 1505b65f0..2fd23a231 100644
--- a/reference/cmath/abs.md
+++ b/reference/cmath/abs.md
@@ -75,7 +75,7 @@ abs(-1.5) = 1.500000
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ceil -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ceil.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/ceil.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ceil.md b/reference/cmath/ceil.md
index d2f6c3cf1..dd4d662f7 100644
--- a/reference/cmath/ceil.md
+++ b/reference/cmath/ceil.md
@@ -5,14 +5,27 @@
 
 ```cpp
 namespace std {
-  float ceil(float x);
-  double ceil(double x);
-  long double ceil(long double x);
-
-  double ceil(Integral x);          // C++11 から
-
-  float ceilf(float x);             // C++17 から
-  long double ceill(long double x); // C++17 から
+  float ceil(float x);              // (1) C++03からC++20まで
+  double ceil(double x);            // (2) C++03からC++20まで
+  long double ceil(long double x);  // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+   ceil(floating-point-type x);     // (4) C++23
+
+  double
+    ceil(Integral x);               // (5) C++11
+  constexpr double
+    ceil(Integral x);               // (5) C++23
+
+  float
+    ceilf(float x);                 // (6) C++17
+  constexpr float
+    ceilf(float x);                 // (6) C++17
+
+  long double
+    ceill(long double x);           // (7) C++17
+  constexpr long double
+    ceill(long double x);           // (7) C++17
 }
 ```
 * Integral[italic]
@@ -20,6 +33,14 @@ namespace std {
 ## 概要
 引数 `x` 以上で最小の整数値を得る。（天井関数）
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` 以上で最小の整数値
@@ -35,6 +56,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_UPWARD`](/reference/cfenv/fe_upward.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -97,3 +119,10 @@ FE_INEXACT = true
 ```
 
 引数と結果が異なる場合に例外 `FE_INEXACT` が発生するか否かは実装によって異なる。
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copysign -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/copysign.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/copysign.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/copysign.md b/reference/cmath/copysign.md
index edb18a5f7..22f5656c6 100644
--- a/reference/cmath/copysign.md
+++ b/reference/cmath/copysign.md
@@ -6,14 +6,40 @@
 
 ```cpp
 namespace std {
-  double copysign(double x, double y);
-  float copysign(float x, float y);
-  long double copysign(long double x, long double y);
-
-  Integral copysign(Integral x, Integral y);
-
-  float copysignf(float x, float y);                   // C++17 から
-  long double copysignl(long double x, long double y); // C++17 から
+  float
+    copysign(float x,
+             float y);               // (1) C++11からC++20まで
+  double
+    copysign(double x,
+             double y);              // (2) C++11からC++20まで
+  long double
+    copysign(long double x,
+             long double y);         // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    copysign(floating-point-type x,
+             floating-point-type y); // (4) C++23
+
+  Integral
+    copysign(Integral x
+             Integral y);            // (5) C++11
+  constexpr Integral
+    copysign(Integral x
+             Integral y);            // (5) C++23
+
+  float
+    copysignf(float x,
+              float y);              // (6) C++17
+  constexpr float
+    copysignf(float x,
+              float y);              // (6) C++23
+
+  long double
+    copysignl(long double x,
+              long double y);        // (7) C++17
+  constexpr long double
+    copysignl(long double x,
+              long double y);        // (7) C++23
 }
 ```
 * Integral[italic]
@@ -21,6 +47,14 @@ namespace std {
 ## 概要
 `x`の絶対値に`y`の符号が付いた値を生成する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `x`の絶対値に`y`の符号が付いた値を返す。
@@ -29,7 +63,8 @@ namespace std {
 
 
 ## 備考
-符号付きゼロを表現するが負のゼロを取り扱わない実装では、この関数はゼロを正と見なす。
+- 符号付きゼロを表現するが負のゼロを取り扱わない実装では、この関数はゼロを正と見なす。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -55,7 +90,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -102,3 +137,10 @@ namespace std {
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fabs -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fabs.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fabs.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fabs.md b/reference/cmath/fabs.md
index 3fb04cb1e..dff3100ed 100644
--- a/reference/cmath/fabs.md
+++ b/reference/cmath/fabs.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float fabs(float x);
-  double fabs(double x);
-  long double fabs(long double x);
-
-  double fabs(Integral x);          // C++11 から
-
-  float fabsf(float x);             // C++17 から
-  long double fabsl(long double x); // C++17 から
+  float fabs(float x);              // (1) C++03からC++20まで
+  double fabs(double x);            // (2) C++03からC++20まで
+  long double fabs(long double x);  // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    fabs(floating-point-type x);    // (4) C++23
+
+  double
+    fabs(Integral x);               // (5) C++11
+  constexpr double
+    fabs(Integral x);               // (5) C++23
+
+  float
+    fabsf(float x);                 // (6) C++17
+  constexpr float
+    fabsf(float x);                 // (6) C++23
+
+  long double
+    fabsl(long double x);           // (7) C++17
+  constexpr long double
+    fabsl(long double x);           // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +34,14 @@ namespace std {
 ## 概要
 算術型の絶対値を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の絶対値を返す。
@@ -34,6 +55,7 @@ namespace std {
 - `value = ±0` の場合、戻り値は `+0` となる。
 - `value = ±∞` の場合、戻り値は `+∞` となる。
 - 戻り値は正確で、現在の丸め方式には依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -77,7 +99,7 @@ fabs(-∞)   = inf
 - [Visual C++](/implementation.md#visual_cpp): 2003, 2005, 2008, 2010
 
 #### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -108,3 +130,9 @@ namespace std {
 * signbit[link signbit.md]
 * is_integral[link ../type_traits/is_integral.md]
 * enable_if[link ../type_traits/enable_if.md]
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fdim -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fdim.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fdim.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fdim.md b/reference/cmath/fdim.md
index 10fbfd994..34f6d84bd 100644
--- a/reference/cmath/fdim.md
+++ b/reference/cmath/fdim.md
@@ -6,14 +6,30 @@
 
 ```cpp
 namespace std {
-  float fdim(float x, float y);
-  double fdim(double x, double y);
-  long double fdim(long double x, long double y);
+  float fdim(float x, float y);                   // (1) C++11からC++20まで
+  double fdim(double x, double y);                // (2) C++11からC++20まで
+  long double fdim(long double x, long double y); // (3) C++11からC++20まで
 
-  Promoted fdim(Arithmetic1 x, Arithmetic2 y);
+  constexpr floating-point-type
+    fdim(floating-point-type x,
+         floating-point-type y);                  // (4) C++23
 
-  float fdimf(float x, float y);                   // C++17 から
-  long double fdiml(long double x, long double y); // C++17 から
+  Promoted
+    fdim(Arithmetic1 x,
+         Arithmetic2 y);                          // (5) C++11
+  constexpr Promoted
+    fdim(Arithmetic1 x,
+         Arithmetic2 y);                          // (5) C++23
+
+  float
+    fdimf(float x, float y);                      // (6) C++17
+  constexpr float
+    fdimf(float x, float y);                      // (6) C++23
+
+  long double
+    fdiml(long double x, long double y);          // (7) C++17
+  constexpr long double
+    fdiml(long double x, long double y);          // (7) C++23
 }
 ```
 * Promoted[italic]
@@ -23,11 +39,25 @@ namespace std {
 ## 概要
 算術型の正の差を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
+
 ## 戻り値
 引数の正の差を返す。
 
 `x - y &amp;gt; 0` の場合は `x - y` を、それ以外の場合は `+0` を返す。
 
+
+## 備考
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;cmath&amp;gt;
@@ -61,6 +91,13 @@ fdim(+1.0, 0.0) = +1
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 #### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>floor -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/floor.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/floor.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/floor.md b/reference/cmath/floor.md
index 8c3c77693..b3bb3b5b9 100644
--- a/reference/cmath/floor.md
+++ b/reference/cmath/floor.md
@@ -5,14 +5,27 @@
 
 ```cpp
 namespace std {
-  float floor(float x);
-  double floor(double x);
-  long double floor(long double x);
-
-  double floor(Integral x);          // C++11 から
-
-  float floorf(float x);             // C++17 から
-  long double floorl(long double x); // C++17 から
+  float floor(float x);             // (1) C++03からC++20まで
+  double floor(double x);           // (2) C++03からC++20まで
+  long double floor(long double x); // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    floor(floating-point-type x);   // (4) C++23
+
+  double
+    floor(Integral x);              // (5) C++11
+  constexpr double
+    floor(Integral x);              // (5) C++23
+
+  float
+    floorf(float x);                // (6) C++17
+  constexpr float
+    floorf(float x);                // (6) C++23
+
+  long double
+    floorl(long double x);          // (7) C++17
+  constexpr long double
+    floorl(long double x);          // (7) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +33,14 @@ namespace std {
 ## 概要
 引数 `x` 以下で最大の整数値を得る。（床関数）
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` 以下で最大の整数値
@@ -35,6 +56,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_DOWNWARD`](/reference/cfenv/fe_downward.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -97,3 +119,10 @@ FE_INEXACT = true
 ```
 
 引数と結果が異なる場合に例外 `FE_INEXACT` が発生するか否かは実装によって異なる。
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fma -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fma.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fma.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fma.md b/reference/cmath/fma.md
index 77924d164..7e633925f 100644
--- a/reference/cmath/fma.md
+++ b/reference/cmath/fma.md
@@ -6,14 +6,50 @@
 
 ```cpp
 namespace std {
-  float fma(float x, float y, float z);
-  double fma(double x, double y, double z);
-  long double fma(long double x, long double y, long double z);
-
-  Promoted fma(Arithmetic1 x, Arithmetic2 y, Arithmetic3 z);
-
-  float fmaf(float x, float y, float z);                         // C++17 から
-  long double fmal(long double x, long double y, long double z); // C++17 から
+  float
+    fma(float x,
+        float y,
+        float z);                 // (1) C++11からC++20まで
+  double
+    fma(double x,
+        double y,
+        double z);                // (2) C++11からC++20まで
+  long double
+    fma(long double x,
+        long double y,
+        long double z);           // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    fma(floating-point-type x,
+        floating-point-type y,
+        floating-point-type z);   // (4) C++23
+
+  Promoted
+    fma(Arithmetic1 x,
+        Arithmetic2 y,
+        Arithmetic3 z);           // (5) C++11
+  constexpr Promoted
+    fma(Arithmetic1 x,
+        Arithmetic2 y,
+        Arithmetic3 z);           // (5) C++23
+
+  float
+    fmaf(float x,
+         float y,
+         float z);                // (6) C++17
+  constexpr float
+    fmaf(float x,
+         float y,
+         float z);                // (6) C++23
+
+  long double
+    fmal(long double x,
+         long double y,
+         long double z);          // (7) C++17
+  constexpr long double
+    fmal(long double x,
+         long double y,
+         long double z);          // (7) C++23
 }
 ```
 * Promoted[italic]
@@ -29,6 +65,14 @@ namespace std {
 
 `fma` は fused multiply-add の略。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `x * y + z` を無限精度で計算した後、現在の丸めモードで丸めた結果
@@ -46,6 +90,7 @@ namespace std {
 
 - 本関数が単純に `x * y + z` を計算するのと等価か、より速い場合には、引数の型に応じて [`FP_FAST_FMA`](fp_fast_fma.md)（`double` の場合）、[`FP_FAST_FMAF`](fp_fast_fmaf.md)（`float` の場合）、[`FP_FAST_FMAL`](fp_fast_fmal.md)（`long double` の場合）と言ったマクロが定義される。  
 	これらのマクロは、一般的に本関数がハードウェアによる積和演算命令を使用している場合にのみ定義される。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -162,3 +207,9 @@ FE_INVALID
 inf * 1.0 + -inf = -nan
 
 ```
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmax -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmax.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fmax.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmax.md b/reference/cmath/fmax.md
index 9bc851fe1..897dc964c 100644
--- a/reference/cmath/fmax.md
+++ b/reference/cmath/fmax.md
@@ -6,14 +6,31 @@
 
 ```cpp
 namespace std {
-  float fmax(float x, float y);
-  double fmax(double x, double y);
-  long double fmax(long double x, long double y);
-
-  Promoted fmax(Arithmetic1 x, Arithmetic2 y);
-
-  float fmaxf(float x, float y);                   // C++17 から
-  long double fmaxl(long double x, long double y); // C++17 から
+  float fmax(float x, float y);          // (1) C++11からC++20まで
+  double fmax(double x, double y);       // (2) C++11からC++20まで
+  long double
+    fmax(long double x, long double y);  // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    fmax(floating-point-type x,
+         floating-point-type y);         // (4) C++23
+
+  Promoted
+    fmax(Arithmetic1 x,
+         Arithmetic2 y);                 // (5) C++11
+  constexpr Promoted
+    fmax(Arithmetic1 x,
+         Arithmetic2 y);                 // (5) C++23
+
+  float
+    fmaxf(float x, float y);             // (6) C++17
+  constexpr float
+    fmaxf(float x, float y);             // (6) C++23
+
+  long double
+    fmaxl(long double x, long double y); // (7) C++17
+  constexpr long double
+    fmaxl(long double x, long double y); // (7) C++17
 }
 ```
 * Promoted[italic]
@@ -23,6 +40,15 @@ namespace std {
 ## 概要
 算術型の最大値を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
+
 ## 戻り値
 引数の最大値を返す。
 
@@ -32,6 +58,8 @@ namespace std {
     - 引数の1つが NaN の場合 NaN でない方を返す。
     - 引数が2つとも NaN の場合 NaN を返す。
 - 理想的には `fmax(-0.0, +0.0)` は `+0` を返す。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
 
 ## 例
 ```cpp example
@@ -71,7 +99,7 @@ fmax( nan, nan)  = +nan
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 #### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -105,3 +133,10 @@ namespace std {
 * std::enable_if[link ../type_traits/enable_if.md]
 * std::is_arithmetic[link ../type_traits/is_arithmetic.md]
 * std::common_type[link ../type_traits/common_type.md]
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmin -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmin.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fmin.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmin.md b/reference/cmath/fmin.md
index ad1d547ab..d342f48a4 100644
--- a/reference/cmath/fmin.md
+++ b/reference/cmath/fmin.md
@@ -6,14 +6,31 @@
 
 ```cpp
 namespace std {
-  float fmin(float x, float y);
-  double fmin(double x, double y);
-  long double fmin(long double x, long double y);
-
-  Promoted fmin(Arithmetic1 x, Arithmetic2 y);
-
-  float fminf(float x, float y);                   // C++17 から
-  long double fminl(long double x, long double y); // C++17 から
+  float fmin(float x, float y);          // (1) C++11からC++20まで
+  double fmin(double x, double y);       // (2) C++11からC++20まで
+  long double
+    fmin(long double x, long double y);  // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    fmin(floating-point-type x,
+         floating-point-type y);         // (4) C++23
+
+  Promoted
+    fmin(Arithmetic1 x,
+         Arithmetic2 y);                 // (5) C++11
+  constexpr Promoted
+    fmin(Arithmetic1 x,
+         Arithmetic2 y);                 // (5) C++23
+
+  float
+    fminf(float x, float y);             // (6) C++17
+  constexpr float
+    fminf(float x, float y);             // (6) C++17
+
+  long double
+    fminl(long double x, long double y); // (7) C++17
+  constexpr long double
+    fminl(long double x, long double y); // (7) C++17
 }
 ```
 * Promoted[italic]
@@ -23,15 +40,27 @@ namespace std {
 ## 概要
 算術型の最小値を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
+
 ## 戻り値
 引数の最小値を返す。
 
+
 ## 備考
 - 戻り値は正確で、現在の丸めモードに依存しない。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - 引数の1つが NaN の場合 NaN でない方を返す。
     - 引数が2つとも NaN の場合 NaN を返す。
 - 理想的には `fmin(-0.0, +0.0)` は `-0` を返す。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
 
 ## 例
 ```cpp example
@@ -71,7 +100,7 @@ fmin( nan, nan)  = +nan
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 #### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -105,3 +134,10 @@ namespace std {
 * std::enable_if[link ../type_traits/enable_if.md]
 * std::is_arithmetic[link ../type_traits/is_arithmetic.md]
 * std::common_type[link ../type_traits/common_type.md]
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmod -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmod.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fmod.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmod.md b/reference/cmath/fmod.md
index 1666e7831..b74689fa3 100644
--- a/reference/cmath/fmod.md
+++ b/reference/cmath/fmod.md
@@ -5,14 +5,31 @@
 
 ```cpp
 namespace std {
-  double fmod(double x, double y);
-  float fmod(float x, float y);
-  long double fmod(long double x, long double y);
-
-  Integral fmod(Integral x, Integral y);           // C++11 から
-
-  float fmodf(float x, float y);                   // C++17 から
-  long double fmodl(long double x, long double y); // C++17 から
+  float fmod(float x, float y);    // (1) C++03からC++20まで
+  double fmod(double x, double y); // (2) C++03からC++20まで
+  long double fmod(long double x,
+                   long double y); // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    fmod(floating-point-type x,
+         floating-point-type y);   // (4) C++23
+
+  Integral
+    fmod(Integral x, Integral y);  // (5) C++11
+  constexpr Integral
+    fmod(Integral x, Integral y);  // (5) C++23
+
+  float
+    fmodf(float x, float y);       // (6) C++17
+  constexpr float
+    fmodf(float x, float y);       // (6) C++23
+
+  long double
+    fmodl(long double x,
+          long double y);          // (7) C++17
+  constexpr long double
+    fmodl(long double x,
+          long double y);          // (8) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +39,14 @@ namespace std {
 
 整数に対する剰余は`%`演算子で求められるが、浮動小数点数に対しては本関数を使用する必要がある。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `x / y`の余りを返す。
@@ -97,3 +122,8 @@ fmod(6.3, 3.15) = 0
 fmod(6, 2) = 0
 ```
 
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fpclassify -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fpclassify.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fpclassify.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fpclassify.md b/reference/cmath/fpclassify.md
index f855a47ac..16242d32d 100644
--- a/reference/cmath/fpclassify.md
+++ b/reference/cmath/fpclassify.md
@@ -6,13 +6,17 @@
 
 ```cpp
 namespace std {
-  int fpclassify(float x);
+  int fpclassify(float x);             // (1) C++11からC++20まで
+  int fpclassify(double x);            // (2) C++11からC++20まで
+  int fpclassify(long double x);       // (3) C++11からC++20まで
 
-  int fpclassify(double x);
+  constexpr int
+    fpclassify(floating-point-type x); // (4) C++23
 
-  int fpclassify(long double x);
-
-  int fpclassify(Integral x);
+  int
+    fpclassify(Integral x);            // (5) C++11
+  constexpr int
+    fpclassify(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -21,6 +25,12 @@ namespace std {
 ## 概要
 指定された値の数値分類を返す。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 引数 `x` で指定された値の数値分類を表すマクロの整数値を返す。
@@ -37,7 +47,8 @@ namespace std {
 
 
 ## 備考
-本関数は、C 言語の `fpclassify` マクロと等価の機能を持つ。
+- C標準ライブラリでは`fpclassify`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -74,3 +85,10 @@ true
 true
 true
 ```
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isfinite -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isfinite.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isfinite.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isfinite.md b/reference/cmath/isfinite.md
index 12e54f7c8..395305d82 100644
--- a/reference/cmath/isfinite.md
+++ b/reference/cmath/isfinite.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool isfinite(float x);
-  bool isfinite(double x);
-  bool isfinite(long double x);
+  bool isfinite(float x);            // (1) C++11からC++20まで
+  bool isfinite(double x);           // (2) C++11からC++20まで
+  bool isfinite(long double x);      // (3) C++11からC++20まで
 
-  bool isfinite(Integral x);
+  constexpr bool
+    isfinite(floating-point-type x); // (4) C++23
+
+  bool
+    isfinite(Integral x);            // (5) C++11
+  constexpr bool
+    isfinite(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,13 +24,20 @@ namespace std {
 ## 概要
 数値が有限(finite value)であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`がゼロ、非正規化数、正規化数のいずれかであり、無限大とNaNのいずれでもない場合に有限値であると見なし、`true`を返す。そうでない場合、`false`を返す。
 
 
 ## 備考
-C標準ライブラリでは`isfinite`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`isfinite`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -73,7 +86,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -87,3 +100,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isgreater -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isgreater.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isgreater.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isgreater.md b/reference/cmath/isgreater.md
index 7b7cd8a32..37537ccee 100644
--- a/reference/cmath/isgreater.md
+++ b/reference/cmath/isgreater.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool isgreater(double x, double y);
-
-  bool isgreater(float x, float y);
-
-  bool isgreater(long double x, long double y);
-
-  bool isgreater(Integral x, Integral y);
+  bool isgreater(float x, float y);             // (1) C++11からC++20まで
+  bool isgreater(double x, double y);           // (2) C++11からC++20まで
+  bool isgreater(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    isgreater(floating-point-type x,
+              floating-point-type y);           // (4) C++23
+
+  bool
+    isgreater(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    isgreater(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,11 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺より大きいかを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
 
 
 ## 戻り値
@@ -29,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -92,3 +103,10 @@ isgreater(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isgreaterequal -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isgreaterequal.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isgreaterequal.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isgreaterequal.md b/reference/cmath/isgreaterequal.md
index 465af642e..c8c03b169 100644
--- a/reference/cmath/isgreaterequal.md
+++ b/reference/cmath/isgreaterequal.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool isgreaterequal(double x, double y);
-
-  bool isgreaterequal(float x, float y);
-
-  bool isgreaterequal(long double x, long double y);
-
-  bool isgreaterequal(Integral x, Integral y);
+  bool isgreaterequal(float x, float y);             // (1) C++11からC++20まで
+  bool isgreaterequal(double x, double y);           // (2) C++11からC++20まで
+  bool isgreaterequal(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    isgreaterequal(floating-point-type x,
+                   floating-point-type y);           // (4) C++23
+
+  bool
+    isgreaterequal(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    isgreaterequal(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,11 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺以上かを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
 
 
 ## 戻り値
@@ -29,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -92,3 +103,10 @@ isgreaterequal(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isinf -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isinf.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isinf.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isinf.md b/reference/cmath/isinf.md
index dfcc50590..2dfd8e152 100644
--- a/reference/cmath/isinf.md
+++ b/reference/cmath/isinf.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool isinf(float x);
-  bool isinf(double x);
-  bool isinf(long double x);
+  bool isinf(float x);            // (1) C++11からC++20まで
+  bool isinf(double x);           // (2) C++11からC++20まで
+  bool isinf(long double x);      // (3) C++11からC++20まで
 
-  bool isinf(Integral x);
+  constexpr bool
+    isinf(floating-point-type x); // (4) C++23
+
+  bool
+    isinf(Integral x);            // (5) C++11
+  constexpr bool
+    isinf(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,13 +24,20 @@ namespace std {
 ## 概要
 数値が無限大(infinity)であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`が(正もしくは負の)無限大である場合、`true`を返す。そうでない場合、`false`を返す。
 
 
 ## 備考
-C標準ライブラリでは`isinf`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`isinf`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -47,7 +60,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -61,3 +74,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isless -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isless.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isless.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isless.md b/reference/cmath/isless.md
index 4234fd8d4..30e5078f2 100644
--- a/reference/cmath/isless.md
+++ b/reference/cmath/isless.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool isless(double x, double y);
-
-  bool isless(float x, float y);
-
-  bool isless(long double x, long double y);
-
-  bool isless(Integral x, Integral y);
+  bool isless(float x, float y);             // (1) C++11からC++20まで
+  bool isless(double x, double y);           // (2) C++11からC++20まで
+  bool isless(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    isless(floating-point-type x,
+           floating-point-type y);           // (4) C++23
+
+  bool
+    isless(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    isless(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,11 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺より小さいかを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
 
 
 ## 戻り値
@@ -29,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -92,3 +103,10 @@ isless(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>islessequal -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/islessequal.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/islessequal.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/islessequal.md b/reference/cmath/islessequal.md
index cc8e05921..ffe0a4dd7 100644
--- a/reference/cmath/islessequal.md
+++ b/reference/cmath/islessequal.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool islessequal(double x, double y);
-
-  bool islessequal(float x, float y);
-
-  bool islessequal(long double x, long double y);
-
-  bool islessequal(Integral x, Integral y);
+  bool islessequal(float x, float y);             // (1) C++11からC++20まで
+  bool islessequal(double x, double y);           // (2) C++11からC++20まで
+  bool islessequal(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    islessequal(floating-point-type x,
+                floating-point-type y);           // (4) C++23
+
+  bool
+    islessequal(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    islessequal(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,12 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺以下かを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 `x &amp;lt;= y`と等価の演算によって、`x`が`y`以下であれば`true`、そうでなければ`false`を返す。
@@ -28,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -91,3 +103,10 @@ islessequal(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>islessgreater -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/islessgreater.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/islessgreater.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/islessgreater.md b/reference/cmath/islessgreater.md
index 00c796d2a..a31690fff 100644
--- a/reference/cmath/islessgreater.md
+++ b/reference/cmath/islessgreater.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool islessgreater(double x, double y);
-
-  bool islessgreater(float x, float y);
-
-  bool islessgreater(long double x, long double y);
-
-  bool islessgreater(Integral x, Integral y);
+  bool islessgreater(float x, float y);             // (1) C++11からC++20まで
+  bool islessgreater(double x, double y);           // (2) C++11からC++20まで
+  bool islessgreater(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    islessgreater(floating-point-type x,
+                  floating-point-type y);           // (4) C++23
+
+  bool
+    islessgreater(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    islessgreater(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,12 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺より小さい、もしくは左辺が右辺より大きい、のいずれかに該当するかを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 `x &amp;lt; y || x &amp;gt; y`と等価の演算によって、`x`が`y`より小さい、もしくは`x`が`y`より大きければ`true`、そうでなければ`false`を返す。
@@ -28,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -91,3 +103,10 @@ islessgreater(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isnan -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isnan.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isnan.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isnan.md b/reference/cmath/isnan.md
index 1c41a90d5..d9ef05266 100644
--- a/reference/cmath/isnan.md
+++ b/reference/cmath/isnan.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool isnan(float x);
-  bool isnan(double x);
-  bool isnan(long double x);
+  bool isnan(float x);            // (1) C++11からC++20まで
+  bool isnan(double x);           // (2) C++11からC++20まで
+  bool isnan(long double x);      // (3) C++11からC++20まで
 
-  bool isnan(Integral x);
+  constexpr bool
+    isnan(floating-point-type x); // (4) C++23
+
+  bool
+    isnan(Integral x);            // (5) C++11
+  constexpr bool
+    isnan(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,13 +24,20 @@ namespace std {
 ## 概要
 数値が NaN であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`がNaNである場合、`true`を返す。そうでない場合、`false`を返す。
 
 
 ## 備考
-C標準ライブラリでは`isnan`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`isnan`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -51,7 +64,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -65,3 +78,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isnormal -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isnormal.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isnormal.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isnormal.md b/reference/cmath/isnormal.md
index 3e9aa6c8c..108f92a63 100644
--- a/reference/cmath/isnormal.md
+++ b/reference/cmath/isnormal.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool isnormal(float x);
-  bool isnormal(double x);
-  bool isnormal(long double x);
+  bool isnormal(float x);            // (1) C++11からC++20まで
+  bool isnormal(double x);           // (2) C++11からC++20まで
+  bool isnormal(long double x);      // (3) C++11からC++20まで
 
-  bool isnormal(Integral x);
+  constexpr bool
+    isnormal(floating-point-type x); // (4) C++23
+
+  bool
+    isnormal(Integral x);            // (5) C++11
+  constexpr bool
+    isnormal(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,13 +24,20 @@ namespace std {
 ## 概要
 数値が正規化数(normalized value)であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`がゼロ、非正規化数、無限大、NaNのいずれでもない場合に正規化数であると見なし、`true`を返す。そうでない場合、`false`を返す。
 
 
 ## 備考
-C標準ライブラリでは`isnormal`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`isnormal`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -73,7 +86,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -87,3 +100,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isunordered -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isunordered.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isunordered.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isunordered.md b/reference/cmath/isunordered.md
index dd88c6441..3c29cc16a 100644
--- a/reference/cmath/isunordered.md
+++ b/reference/cmath/isunordered.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool isunordered(double x, double y);
-
-  bool isunordered(float x, float y);
-
-  bool isunordered(long double x, long double y);
-
-  bool isunordered(Integral x, Integral y);
+  bool isunordered(float x, float y);             // (1) C++11からC++20まで
+  bool isunordered(double x, double y);           // (2) C++11からC++20まで
+  bool isunordered(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    isunordered(floating-point-type x,
+              floating-point-type y);           // (4) C++23
+
+  bool
+    isunordered(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    isunordered(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -22,6 +27,11 @@ namespace std {
 
 NaNに対する順序付けはされないため、`x`と`y`のいずれかがNaNである場合、この関数は`true`を返す。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
 
 
 ## 戻り値
@@ -29,8 +39,9 @@ NaNに対する順序付けはされないため、`x`と`y`のいずれかがNa
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -75,3 +86,10 @@ isunordered(1, inf) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ldexp -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ldexp.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/ldexp.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ldexp.md b/reference/cmath/ldexp.md
index c8e973c15..00ca44339 100644
--- a/reference/cmath/ldexp.md
+++ b/reference/cmath/ldexp.md
@@ -86,7 +86,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>llround -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/llround.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/llround.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/llround.md b/reference/cmath/llround.md
index 5bc0ff98f..fe26bc96e 100644
--- a/reference/cmath/llround.md
+++ b/reference/cmath/llround.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  long long llround(float x);
-  long long llround(double x);
-  long long llround(long double x);
-
-  long long llround(Integral x);
-
-  long long int llroundf(float x);       // C++17 から
-  long long int llroundl(long double x); // C++17 から
+  long long llround(float x);       // (1) C++11からC++20まで
+  long long llround(double x);      // (2) C++11からC++20まで
+  long long llround(long double x); // (3) C++11からC++20まで
+
+  constexpr long long
+    llround(floating-point-type x); // (4) C++23
+
+  long long
+    llround(Integral x);            // (5) C++11
+  constexpr long long
+    llround(Integral x);            // (5) C++23
+
+  long long
+    llroundf(float x);              // (6) C++17
+  constexpr long long
+    llroundf(float x);              // (6) C++23
+
+  long long
+    llroundl(long double x);        // (7) C++17
+  constexpr long long
+    llroundl(long double x);        // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +36,14 @@ namespace std {
 ここで引数 `x` の四捨五入とは、`x` を最も近い整数に丸めるが、`x` の小数部分が `0.5` の場合には、`x` の符号が正負のいずれであってもゼロから遠い方向に丸めることを指す。  
 具体例は下記の出力例を参照。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を四捨五入により丸めた整数値を、[`long long`型](/lang/cpp11/long_long_type.md)型の範囲に収めて返す。
@@ -33,6 +54,7 @@ namespace std {
 - [`round`](round.md)関数と違い、本関数において戻り値が非整数型引数 `x` と異なる場合に、例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) を発生させる必要はない。
 - 戻り値が[`long long`型](/lang/cpp11/long_long_type.md)型の範囲を超えた場合、定義域エラーが起こる可能性がある。その際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -82,3 +104,9 @@ llround(-2.9) = -3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>logb -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/logb.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/logb.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/logb.md b/reference/cmath/logb.md
index 9224c4552..465951a6b 100644
--- a/reference/cmath/logb.md
+++ b/reference/cmath/logb.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float logb(float x);
-  double logb(double x);
-  long double logb(long double x);
-
-  double logb(Integral);
-
-  float logbf(float x);             // C++17 から
-  long double logbl(long double x); // C++17 から
+  float logb(float x);              // (1) C++11からC++20まで
+  double logb(double x);            // (2) C++11からC++20まで
+  long double logb(long double x);  // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    logb(floating-point-type x);    // (4) C++23
+
+  double
+    logb(Integral);                 // (5) C++11
+  constexpr double
+    logb(Integral);                 // (5) C++23
+
+  float
+    logbf(float x);                 // (6) C++17
+  constexpr float
+    logbf(float x);                 // (6) C++23
+
+  long double
+    logbl(long double x);           // (7) C++17
+  constexpr long double
+    logbl(long double x);           // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +36,14 @@ namespace std {
 
 `log` が名前に入っているが、通常の対数関数と異なり、引数の符号は無視されることに注意。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `|x| *` [`FLT_RADIX`](/reference/cfloat/flt_radix.md)&amp;lt;code&amp;gt;&amp;lt;sup&amp;gt;-logb(x)&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt; が範囲 `[1,` [`FLT_RADIX`](/reference/cfloat/flt_radix.md)`)` に収まるように指数を求めて返す。（非正規化数の場合でも正しい値が返る）
@@ -36,6 +57,7 @@ namespace std {
 	- `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
 	- `x = ±∞` の場合、戻り値は `+∞` となる。
 	- 戻り値は正確で、現在の丸め方式に依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -76,3 +98,9 @@ logb(1e-309) = -1027
 - [GCC](/implementation.md#gcc): 4.3.6
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lround -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lround.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/lround.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lround.md b/reference/cmath/lround.md
index 705fe24d0..788e89eaf 100644
--- a/reference/cmath/lround.md
+++ b/reference/cmath/lround.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  long lround(float x);
-  long lround(double x);
-  long lround(long double x);
-
-  long lround(Integral x);
-
-  long int lroundf(float x);       // C++17 から
-  long int lroundl(long double x); // C++17 から
+  long lround(float x);            // (1) C++11からC++20まで
+  long lround(double x);           // (2) C++11からC++20まで
+  long lround(long double x);      // (3) C++11からC++20まで
+
+  constexpr long
+    lround(floating-point-type x); // (4) C++23
+
+  long
+    lround(Integral x);            // (5) C++11
+  constexpr long
+    lround(Integral x);            // (5) C++23
+
+  long int
+    lroundf(float x);              // (6) C++17
+  constexpr long int
+    lroundf(float x);              // (6) C++23
+
+  long int
+    lroundl(long double x);        // (7) C++17
+  constexpr long int
+    lroundl(long double x);        // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +36,14 @@ namespace std {
 ここで引数 `x` の四捨五入とは、`x` を最も近い整数に丸めるが、`x` の小数部分が `0.5` の場合には、`x` の符号が正負のいずれであってもゼロから遠い方向に丸めることを指す。  
 具体例は下記の出力例を参照。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を四捨五入により丸めた整数値を、`long`型の範囲に収めて返す。
@@ -33,6 +54,7 @@ namespace std {
 - [`round`](round.md)関数と違い、本関数において戻り値が非整数型引数 `x` と異なる場合に、例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) を発生させる必要はない。
 - 戻り値が`long`型の範囲を超えた場合、定義域エラーが起こる可能性がある。その際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -82,3 +104,9 @@ lround(-2.9) = -3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>modf -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/modf.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/modf.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/modf.md b/reference/cmath/modf.md
index b20911a3a..b0f620b46 100644
--- a/reference/cmath/modf.md
+++ b/reference/cmath/modf.md
@@ -5,14 +5,34 @@
 
 ```cpp
 namespace std {
-  double modf(double value, double* iptr);
-  float modf(float value, float* iptr);
-  long double modf(long double value, long double* iptr);
-
-  double modf(Integral value, double* iptr);                // C++11 から
-
-  float modff(float value, float* iptr);                    // C++17 から
-  long double modfl(long double value, long double* iptr);  // C++17 から
+  float
+    modf(float value, float* iptr);     // (1) C++03からC++20まで
+  double
+    modf(double value, double* iptr);   // (2) C++03からC++20まで
+  long double
+    modf(long double value,
+         long double* iptr);            // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    modf(floating-point-type value,
+         floating-point-type* iptr);    // (4) C++23
+
+  double
+    modf(Integral value, double* iptr); // (5) C++11
+  constexpr double
+    modf(Integral value, double* iptr); // (5) C++23
+
+  float
+    modff(float value, float* iptr);    // (6) C++17
+  constexpr float
+    modff(float value, float* iptr);    // (6) C++23
+
+  long double
+    modfl(long double value,
+          long double* iptr);           // (7) C++17
+  constexpr long double
+    modfl(long double value,
+          long double* iptr);           // (7) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +40,14 @@ namespace std {
 ## 概要
 浮動小数点数を、整数部と小数部に分解する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数`value`の小数部を符号付きとして返す。また、引数`value`の整数部を`*iptr`に書き込む。
@@ -29,12 +57,13 @@ namespace std {
 
 ## 備考
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `value = ±∞` の場合、戻り値は `±0` となり、`*exp` には `±∞` が設定される。
-	- `value` が NaN の場合、戻り値は NaN となり、`*exp` には NaN が設定される。
-	- 戻り値は正確で、現在の丸め方式には依存しない。
+    - `value = ±∞` の場合、戻り値は `±0` となり、`*exp` には `±∞` が設定される。
+    - `value` が NaN の場合、戻り値は NaN となり、`*exp` には NaN が設定される。
+    - 戻り値は正確で、現在の丸め方式には依存しない。
 
 - C++11 で `value` が整数型のオーバーロードが追加されているが、`iptr` の型によって呼び出されるオーバーロードが一意に決まるため、存在意義は無いものと思われる。  
     （`value` に整数型、`iptr` に `nullptr` を渡した場合のみ当該オーバーロードによって呼び出しが曖昧ではなくなるが、その場合は未定義動作となってしまうため、本オーバーロードの存在はむしろ有害）
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -78,9 +107,9 @@ int main()
 ```
 
 ### 備考
-- 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
-	- GCC 4.6.1 以上
-- GCC、Clang では、C++11 で追加されたオーバーロードは存在しない。
+- 特定の環境では、早期に `constexpr` 対応されている場合がある：
+    - GCC 4.6.1 以上
+- GCC、Clang では、C++11 で追加された整数型オーバーロードは存在しない。
 
 
 ## 実装例
@@ -143,3 +172,10 @@ namespace std {
 * FE_TOWARDZERO[link ../cfenv/fe_towardzero.md]
 * enable_if[link ../type_traits/enable_if.md]
 * is_integral[link ../type_traits/is_integral.md]
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nextafter -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/nextafter.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/nextafter.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/nextafter.md b/reference/cmath/nextafter.md
index 46184131b..abecec649 100644
--- a/reference/cmath/nextafter.md
+++ b/reference/cmath/nextafter.md
@@ -6,14 +6,40 @@
 
 ```cpp
 namespace std {
-  float nextafter(float x, float y);
-  double nextafter(double x, double y);
-  long double nextafter(long double x, long double y);
-
-  Promoted nextafter(Arithmetic1 x, Arithmetic2 y);
-
-  float nextafterf(float x, float y);                   // C++17 から
-  long double nextafterl(long double x, long double y); // C++17 から
+  float
+    nextafter(float x,
+              float y);               // (1) C++11からC++20まで
+  double
+    nextafter(double x,
+              double y);              // (2) C++11からC++20まで
+  long double
+    nextafter(long double x,
+              long double y);         // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    nextafter(floating-point-type x,
+              floating-point-type y); // (4) C++23
+
+  Promoted
+    nextafter(Arithmetic1 x,
+              Arithmetic2 y);         // (5) C++11
+  constexpr Promoted
+    nextafter(Arithmetic1 x,
+              Arithmetic2 y);         // (5) C++23
+
+  float
+    nextafterf(float x,
+               float y);              // (6) C++17
+  constexpr float
+    nextafterf(float x,
+               float y);              // (6) C++23
+
+  long double
+    nextafterl(long double x,
+               long double y);        // (7) C++17
+  constexpr long double
+    nextafterl(long double x,
+               long double y);        // (7) C++23
 }
 ```
 * Arithmetic1[italic]
@@ -25,6 +51,14 @@ namespace std {
 
 この関数は、パラメータ`x`の値をパラメータ`y`の値の方向に対して、その環境で表現可能な最小の値だけ進める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 パラメータ`x`の値をパラメータ`x`の方向に、表現可能な最小の値だけ進めた値を返す。
@@ -34,6 +68,10 @@ namespace std {
 進めた結果が無限大、もしくは表現できない場合、値域エラーとなる。
 
 
+## 備考
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -57,7 +95,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -71,3 +109,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nexttoward -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/nexttoward.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/nexttoward.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/nexttoward.md b/reference/cmath/nexttoward.md
index ac63ae810..2ede9b204 100644
--- a/reference/cmath/nexttoward.md
+++ b/reference/cmath/nexttoward.md
@@ -6,14 +6,40 @@
 
 ```cpp
 namespace std {
-  float nexttoward(float x, long double y);
-  double nexttoward(double x, long double y);
-  long double nexttoward(long double x, long double y);
-
-  Promoted nexttoward(Integral x, long double y);
-
-  float nexttowardf(float x, long double y);             // C++17 から
-  long double nexttowardl(long double x, long double y); // C++17 から
+  float
+    nexttoward(float x,
+               long double y);         // (1) C++11からC++20まで
+  double
+    nexttoward(double x,
+               long double y);         // (2) C++11からC++20まで
+  long double
+    nexttoward(long double x,
+               long double y);         // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    nexttoward(floating-point-type x,
+               floating-point-type y); // (4) C++23
+
+  Promoted
+    nexttoward(Integral x,
+               long double y);         // (5) C++11
+  constexpr Promoted
+    nexttoward(Integral x,
+               floating-point-type y); // (5) C++23
+
+  float
+    nexttowardf(float x,
+                long double y);        // (6) C++17
+  constexpr float
+    nexttowardf(float x,
+                long double y);        // (6) C++23
+
+  long double
+    nexttowardl(long double x,
+                long double y);        // (7) C++17
+  constexpr long double
+    nexttowardl(long double x,
+                long double y);        // (7) C++23
 }
 ```
 * Integral[italic]
@@ -24,7 +50,15 @@ namespace std {
 
 この関数は、パラメータ`x`の値をパラメータ`y`の値の方向に対して、その環境で表現可能な最小の値だけ進める。
 
-この関数はパラメータ`y`の型が`long double`固定であることを除いて、[`std::nextafter()`](nextafter.md)関数と等価である。
+この関数はパラメータ`y`の型が`long double`固定であることを除いて、[`std::nextafter()`](nextafter.md)関数と等価である (C++23以降では精度規定の関数を除いて`y`は`long double`ではなく任意の浮動小数点数型であるため、[`std::nextafter()`](nextafter.md)関数と等価である)。
+
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
 
 
 ## 戻り値
@@ -35,6 +69,10 @@ namespace std {
 進めた結果が無限大、もしくは表現できない場合、値域エラーとなる。
 
 
+## 備考
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -58,7 +96,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -72,3 +110,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remainder -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/remainder.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/remainder.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/remainder.md b/reference/cmath/remainder.md
index 435d83f58..54d5b3a54 100644
--- a/reference/cmath/remainder.md
+++ b/reference/cmath/remainder.md
@@ -6,14 +6,31 @@
 
 ```cpp
 namespace std {
-  double remainder(double x, double y);
-  float remainder(float x, float y);
-  long double remainder(long double x, long double y);
-
-  Integral remainder(Integral x, Integral y);
-
-  float remainderf(float x, float y);                   // C++17 から
-  long double remainderl(long double x, long double y); // C++17 から
+  float remainder(float x, float y);    // (1) C++11からC++20まで
+  double remainder(double x, double y); // (2) C++11からC++20まで
+  long double remainder(long double x,
+                        long double y); // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    remainder(floating-point-type x,
+              floating-point-type y);   // (4) C++23
+
+  Integral
+    remainder(Integral x, Integral y);  // (5) C++11
+  constexpr Integral
+    remainder(Integral x, Integral y);  // (5) C++23
+
+  float
+    remainderf(float x, float y);       // (6) C++17
+  constexpr float
+    remainderf(float x, float y);       // (6) C++23
+
+  long double
+    remainderl(long double x,
+               long double y);          // (7) C++17
+  constexpr long double
+    remainderl(long double x,
+               long double y);          // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +40,14 @@ namespace std {
 
 整数に対する剰余は`%`演算子で求められるが、浮動小数点数に対しては本関数を使用する必要がある。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 IEC 60559で要求された`x REM y`を計算して返す。
@@ -34,6 +59,7 @@ IEC 60559で要求された`x REM y`を計算して返す。
 - 本関数は、C99 の規格にある `remainder`（より正確には `math.h` ヘッダの `remainder`、`remainderf`、`remainderl` の 3 つ。それぞれ C++ の `double`、`float`、`long double` バージョンに相当）と等価である。
 - IEC 60559で要求された`x REM y`の計算とは以下のようなものであり、全ての実装に適用できる。
     - 「y≠0である場合、剰余r = x REM yは、丸めモードに関係なく数学的な関係r = x - nyによって定義される。ここで、nはx/yの正確な値に最も近い整数である。| n - x/y | = 1/2ならば、nは常に偶数である。したがって、剰余は常に正確である。r = 0の場合、その符号はxの符号とする」
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -81,3 +107,10 @@ remainder(6, 2) = 0
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remquo -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/remquo.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/remquo.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/remquo.md b/reference/cmath/remquo.md
index d7b448b3c..1dd97d8b8 100644
--- a/reference/cmath/remquo.md
+++ b/reference/cmath/remquo.md
@@ -6,14 +6,50 @@
 
 ```cpp
 namespace std {
-  double remquo(double x, double y, int* quo);
-  float remquo(float x, float y, int* quo);
-  long double remquo(long double x, long double y, int* quo);
+  float
+    remquo(float x,
+           float y,
+           int* quo);             // (1) C++11からC++20まで
+  double
+    remquo(double x,
+           double y,
+           int* quo);             // (2) C++11からC++20まで
+  long double
+    remquo(long double x,
+           long double y,
+           int* quo);             // (3) C++11からC++20まで
 
-  Integral remquo(Integral x, Integral y, int* quo);
+  constexpr floating-point-type
+    remquo(floating-point-type x,
+           floating-point-type y,
+           int* quo);             // (4) C++23
 
-  float remquof(float x, float y, int* quo);                   // C++17 から
-  long double remquol(long double x, long double y, int* quo); // C++17 から
+  Integral
+    remquo(Integral x,
+           Integral y,
+           int* quo);             // (5) C++11
+  constexpr Integral
+    remquo(Integral x,
+           Integral y,
+           int* quo);             // (5) C++23
+
+  float
+    remquof(float x,
+            float y,
+            int* quo);            // (6) C++17
+  constexpr float
+    remquof(float x,
+            float y,
+            int* quo);            // (6) C++23
+
+  long double
+    remquol(long double x,
+            long double y,
+            int* quo);            // (7) C++17
+  constexpr long double
+    remquol(long double x,
+            long double y,
+            int* quo);            // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +59,14 @@ namespace std {
 
 この関数は、浮動小数点数に対して除算を行い、除算の結果(商)と、その余り(剰余)を同時に求める。戻り値として剰余が返され、ポインタ引数`quo`に商の値が書き込まれる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 - [`remainder()`](remainder.md)関数と同じ方法で剰余を求めて、戻り値として返す。
@@ -31,6 +75,10 @@ namespace std {
 `y`がゼロである場合、`quo`が指す値は未規定となる。またその際、定義域エラーを発生させるかゼロを返すかは、実装定義となる。定義域エラーが発生した際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 
 
+## 備考
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -80,3 +128,10 @@ remquo(6, 2) = quotient:3 remainder:0
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>round -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/round.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/round.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/round.md b/reference/cmath/round.md
index 7eed527ee..0eb888f83 100644
--- a/reference/cmath/round.md
+++ b/reference/cmath/round.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float round(float x);
-  double round(double x);
-  long double round(long double x);
-
-  double round(Integral x);
-
-  float roundf(float x);             // C++17 から
-  long double roundl(long double x); // C++17 から
+  float round(float x);             // (1) C++11からC++20まで
+  double round(double x);           // (2) C++11からC++20まで
+  long double round(long double x); // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    round(floating-point-type x);   // (4) C++23
+
+  double
+    round(Integral x);              // (5) C++11
+  constexpr double
+    round(Integral x);              // (5) C++23
+
+  float
+    roundf(float x);                // (6) C++17
+  constexpr float
+    roundf(float x);                // (6) C++17
+
+  long double
+    roundl(long double x);          // (7) C++17
+  constexpr long double
+    roundl(long double x);          // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +36,14 @@ namespace std {
 ここで引数 `x` の四捨五入とは、`x` を最も近い整数に丸めるが、`x` の小数部分が `0.5` の場合には、`x` の符号が正負のいずれであってもゼロから遠い方向に丸めることを指す。  
 具体例は下記の出力例を参照。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を四捨五入により丸めた整数値
@@ -64,6 +85,7 @@ namespace std {
 
 	ただし、本関数において戻り値が引数 `x` と異なる場合に、上記の実装のように例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -126,3 +148,10 @@ FE_INEXACT = false
 ```
 
 引数と結果が異なる場合に例外 `FE_INEXACT` が発生するか否かは実装によって異なる。
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scalbln -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/scalbln.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/scalbln.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/scalbln.md b/reference/cmath/scalbln.md
new file mode 100644
index 000000000..41caa90a4
--- /dev/null
+++ b/reference/cmath/scalbln.md
@@ -0,0 +1,110 @@
+# scalbln
+* cmath[meta header]
+* std[meta namespace]
+* function[meta id-type]
+* cpp11[meta cpp]
+
+```cpp
+namespace std {
+  float scalbln(float x, long int n);             // (1) C++11からC++20まで
+  double scalbln(double x, long int n);           // (2) C++11からC++20まで
+  long double scalbln(long double x, long int n); // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    scalbln(floating-point-type x, long int n);   // (4) C++23
+
+  double
+    scalbln(Integral x, long int n);              // (5) C++11
+  constexpr double
+    scalbln(Integral x, long int n);              // (5) C++23
+
+  float
+    scalblnf(float x, long int n);                // (6) C++17
+  constexpr float
+    scalblnf(float x, long int n);                // (6) C++23
+
+  long double
+    scalblnl(long double x, long int n);          // (7) C++17
+  constexpr long double
+    scalblnl(long double x, long int n);          // (7) C++23
+}
+```
+* Integral[italic]
+
+## 概要
+[`scalbn()`](scalbn.md)の、乗数として`int`の代わりに`long int`をとるバージョン。
+
+`x` に、浮動小数点数の内部表現の基数 [`FLT_RADIX`](/reference/cfloat/flt_radix.md) の `n` 乗を掛けた値を効率的に（通常は [`FLT_RADIX`](/reference/cfloat/flt_radix.md)&amp;lt;sup&amp;gt;n&amp;lt;/sup&amp;gt; を明示的には計算せずに）計算する。scalbは「scale binary」を意味する。
+
+この関数は、[`FLT_RADIX`](/reference/cfloat/flt_radix.md) が `2` であるシステム上では、[`ldexp()`](ldexp.md) 関数と等価である。
+
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
+
+## 戻り値
+&amp;lt;code&amp;gt;x * [FLT_RADIX](/reference/cfloat/flt_radix.md)&amp;lt;sup&amp;gt;n&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt;
+
+オーバーフローエラー、アンダーフローエラーが発生する可能性がある。
+
+
+## 備考
+- この関数は元々 `scalb()` という名前で提案されていたが、非標準の同名関数が広く実装されていた。そのため、`new` の意味を持つ `n` を関数名の末尾に付けて `scalbn()` 関数として標準ライブラリに定義された。
+- オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
+- 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
+	- `x = ±0` の場合、戻り値は `±0` となる。
+	- `n = 0` の場合、戻り値は `x` となる。
+	- `x = ±∞` の場合、戻り値は `±∞` となる。
+	- もしオーバーフローエラーやアンダーフローエラーを起こさなければ、結果は正確で現在の丸め方式には依存しない。
+
+- `scalbln()` 関数は、パラメータ `n` の型が `long int` であることを除いて、`scalbn()` 関数と等価である。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;cmath&amp;gt;
+
+int main()
+{
+  // 3.0 * (FLT_RADIX^4)
+  double result = std::scalbln(3.0, 4);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::scalbln[color ff0000]
+
+### 出力例
+```
+48
+```
+
+### 備考
+特定の環境では、早期に `constexpr` 対応されている場合がある：
+
+- GCC 4.6.1 以上
+
+
+## バージョン
+### 言語
+- C++11
+
+### 処理系
+- [Clang](/implementation.md#clang): 3.0
+- [GCC](/implementation.md#gcc): 4.3.6
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [WG14 N657 Floating-Point and Complex Arithmetic Enhancements](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n657.ps)
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scalbn -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/scalbn.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/scalbn.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/scalbn.md b/reference/cmath/scalbn.md
index 893959dc6..8ff816b4f 100644
--- a/reference/cmath/scalbn.md
+++ b/reference/cmath/scalbn.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float scalbn(float x, int n);
-  double scalbn(double x, int n);
-  long double scalbn(long double x, int n);
+  float scalbn(float x, int n);             // (1) C++11からC++20まで
+  double scalbn(double x, int n);           // (2) C++11からC++20まで
+  long double scalbn(long double x, int n); // (3) C++11からC++20まで
 
-  double scalbn(Integral x, int n);
+  constexpr floating-point-type
+    scalbn(floating-point-type x, int n);   // (4) C++23
 
-  float scalbnf(float x, int n);                // C++17 から
-  long double scalbnl(long double x, int n);    // C++17 から
+  double
+    scalbn(Integral x, int n);              // (5) C++11
+  constexpr double
+    scalbn(Integral x, int n);              // (5) C++23
+
+  float
+    scalbnf(float x, int n);                // (6) C++17
+  constexpr float
+    scalbnf(float x, int n);                // (6) C++23
+
+  long double
+    scalbnl(long double x, int n);          // (7) C++17
+  constexpr long double
+    scalbnl(long double x, int n);          // (7) C++23
 
   // 乗数としてlong int型を受け取るバージョン
   float scalbln(float x, long int n);
@@ -33,6 +46,14 @@ namespace std {
 
 この関数は、[`FLT_RADIX`](/reference/cfloat/flt_radix.md) が `2` であるシステム上では、[`ldexp()`](ldexp.md) 関数と等価である。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 &amp;lt;code&amp;gt;x * [FLT_RADIX](/reference/cfloat/flt_radix.md)&amp;lt;sup&amp;gt;n&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt;
@@ -50,6 +71,7 @@ namespace std {
 	- もしオーバーフローエラーやアンダーフローエラーを起こさなければ、結果は正確で現在の丸め方式には依存しない。
 
 - `scalbln()` 関数は、パラメータ `n` の型が `long int` であることを除いて、`scalbn()` 関数と等価である。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -72,7 +94,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -112,4 +134,7 @@ namespace std {
 
 ## 参照
 - [WG14 N657 Floating-Point and Complex Arithmetic Enhancements](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n657.ps)
-
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>signbit -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/signbit.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/signbit.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/signbit.md b/reference/cmath/signbit.md
index 6d7ec3a65..9f39e4a2a 100644
--- a/reference/cmath/signbit.md
+++ b/reference/cmath/signbit.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool signbit(float x);
-  bool signbit(double x);
-  bool signbit(long double x);
+  bool signbit(float x);            // (1) C++11からC++20まで
+  bool signbit(double x);           // (2) C++11からC++20まで
+  bool signbit(long double x);      // (3) C++11からC++20まで
 
-  bool signbit(Integral x);
+  constexpr bool
+    signbit(floating-point-type x); // (4) C++23
+
+  bool
+    signbit(Integral x);            // (5) C++11
+  constexpr bool
+    signbit(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,6 +24,12 @@ namespace std {
 ## 概要
 数値の符号が負であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`が負数である場合、`true`を返す。そうでない場合、`false`を返す。
@@ -27,7 +39,8 @@ namespace std {
 
 
 ## 備考
-C標準ライブラリでは`signbit`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`signbit`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -42,7 +55,7 @@ int main()
 
   assert(!std::signbit(1.0f));
   assert(!std::signbit(0.0f));
-  
+
   constexpr float nan = std::numeric_limits&amp;lt;float&amp;gt;::quiet_NaN();
   assert(!std::signbit(nan));
   assert(std::signbit(-nan));
@@ -55,7 +68,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -69,3 +82,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>trunc -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/trunc.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/trunc.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/trunc.md b/reference/cmath/trunc.md
index 69f44cb47..d81a623db 100644
--- a/reference/cmath/trunc.md
+++ b/reference/cmath/trunc.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float trunc(float x);
-  double trunc(double x);
-  long double trunc(long double x);
-
-  double trunc(Integral x);
-
-  float truncf(float x);             // C++17 から
-  long double truncl(long double x); // C++17 から
+  float trunc(float x);             // (1) C++11からC++20まで
+  double trunc(double x);           // (2) C++11からC++20まで
+  long double trunc(long double x); // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    trunc(floating-point-type x);   // (4) C++23
+
+  double
+    trunc(Integral x);              // (5) C++11
+  constexpr double
+    trunc(Integral x);              // (5) C++23
+
+  float
+    truncf(float x);                // (6) C++17
+  constexpr float
+    truncf(float x);                // (6) C++23
+
+  long double
+    truncl(long double x);          // (7) C++17
+  constexpr long double
+    truncl(long double x);          // (7) C++23
 }
 ```
 * Integral[italic]
@@ -22,6 +35,14 @@ namespace std {
 引数 `x` をゼロ方向に丸めた整数値を得る。  
 ゼロ方向への丸めた整数値とは、絶対値が引数 `x` の絶対値以下で、かつ、引数 `x` に最も近い整数値である。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` をゼロ方向に丸めた整数値
@@ -37,6 +58,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_TOWARDZERO`](/reference/cfenv/fe_towardzero.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -99,3 +121,10 @@ FE_INEXACT = false
 ```
 
 引数と結果が異なる場合に例外 `FE_INEXACT` が発生するか否かは実装によって異なる。
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>