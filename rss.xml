<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-27T05:47:18.472860</updated>
  <id>fc8bfc21-596d-4ff8-bf4b-c28747619925</id>

  
    <entry>
      <title>lower_bound -- lower_bound / upper_bound : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/lower_bound.html"/>
      <id>8eae9db6e6aa52ad8e2a4f4fc5cca009be560b16:reference/algorithm/lower_bound.md</id>
      <updated>2025-05-27T14:43:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/lower_bound.md b/reference/algorithm/lower_bound.md
index 24bc996d4..64d79a241 100644
--- a/reference/algorithm/lower_bound.md
+++ b/reference/algorithm/lower_bound.md
@@ -5,31 +5,49 @@
 
 ```cpp
 namespace std {
-  template&amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   ForwardIterator
     lower_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);       // (1) C++03
-
-  template&amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
+  constexpr ForwardIterator
+    lower_bound(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value);       // (1) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
   constexpr ForwardIterator
     lower_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);       // (1) C++20
 
-  template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   ForwardIterator
     lower_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);         // (2) C++03
-
-  template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   constexpr ForwardIterator
     lower_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);         // (2) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type,
+            class Compare&amp;gt;
+  constexpr ForwardIterator
+    lower_bound(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value,
+                Compare comp);         // (2) C++26
 }
 ```
 
@@ -71,9 +89,16 @@ namespace std {
 	具体的には、[`partition_point`](partition_point.md)`(first, last, [value](const T&amp;amp; e) { return e &amp;lt; value; })`、あるいは、[`partition_point`](partition_point.md)`(first, last, [value, comp](const T&amp;amp; e) { return comp(e, value); })` とすることで等価の結果が得られる。
 - 本関数の要件は、上記の通り C++03 までの方が C++11 よりも厳しい。
 	しかし、本アルゴリズムの特性上、処理系が C++03 までにしか準拠していない場合でも、昇順に並んでいなくても正常に動作する可能性は高いものと思われる。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::lower_bound(v.begin(), v.end(), {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -152,13 +177,53 @@ int main()
 ```
 * std::lower_bound[color ff0000]
 
-### 出力
+#### 出力
 ```
 4 pos=2
 4 pos=2
 id=4 name=Carol pos=2
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {1, 2},
+    {3, 4},
+    {5, 6},
+  };
+
+  auto it = std::lower_bound(v.begin(), v.end(), {3, 4});
+
+  // lower_boundでは指定した値&amp;#34;以上&amp;#34;の値が見つかるので、
+  // 指定した値を見つけたいなら検索結果の値を比較する必要がある
+  if (it != v.end() &amp;amp;&amp;amp; *it == Point{3, 4}) {
+    std::size_t pos = std::distance(v.begin(), it);
+    std::cout &amp;lt;&amp;lt; &amp;#34;pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::lower_bound[color ff0000]
+
+#### 出力
+```
+pos=2
+```
+
 
 ## 実装例
 ```cpp
@@ -201,3 +266,5 @@ lower_bound(ForwardIterator first, ForwardIterator last, const T&amp;amp; value)
 - [LWG Issue 384. `equal_range` has unimplementable runtime complexity](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384)
 - [LWG Issue 2150. Unclear specification of `find_end`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2150)
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- lower_bound / upper_bound : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lower_bound.html"/>
      <id>8eae9db6e6aa52ad8e2a4f4fc5cca009be560b16:reference/algorithm/ranges_lower_bound.md</id>
      <updated>2025-05-27T14:43:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lower_bound.md b/reference/algorithm/ranges_lower_bound.md
index 08c91d33a..9fb2c5659 100644
--- a/reference/algorithm/ranges_lower_bound.md
+++ b/reference/algorithm/ranges_lower_bound.md
@@ -10,23 +10,57 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr I
     lower_bound(I first,
                 S last,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (1) C++20
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    lower_bound(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;,
+              Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
     lower_bound(R&amp;amp;&amp;amp; r,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;,
+              Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    lower_bound(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -64,7 +98,17 @@ namespace std::ranges {
 ## 計算量
 最大で log2(`last - first`) + O(1) 回の比較を行う
 
+
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::ranges::lower_bound(v, {a, b});
+        ```
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;algorithm&amp;gt;
@@ -139,13 +183,53 @@ int main()
 * std::ranges::distance[link /reference/iterator/ranges_distance.md]
 * std::ranges::lower_bound[color ff0000]
 
-### 出力
+#### 出力
 ```
 4 pos=2
 4 pos=2
 id=4 name=Bob pos=2
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {1, 2},
+    {3, 4},
+    {5, 6},
+  };
+
+  auto it = std::ranges::lower_bound(v, {3, 4});
+
+  // lower_boundでは指定した値&amp;#34;以上&amp;#34;の値が見つかるので、
+  // 指定した値を見つけたいなら検索結果の値を比較する必要がある
+  if (it != v.end() &amp;amp;&amp;amp; *it == Point{3, 4}) {
+    std::size_t pos = std::distance(v.begin(), it);
+    std::cout &amp;lt;&amp;lt; &amp;#34;pos=&amp;#34; &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::lower_bound[color ff0000]
+
+#### 出力
+```
+pos=2
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -158,3 +242,5 @@ id=4 name=Bob pos=2
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- lower_bound / upper_bound : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_upper_bound.html"/>
      <id>8eae9db6e6aa52ad8e2a4f4fc5cca009be560b16:reference/algorithm/ranges_upper_bound.md</id>
      <updated>2025-05-27T14:43:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_upper_bound.md b/reference/algorithm/ranges_upper_bound.md
index 427567d23..22151d4dc 100644
--- a/reference/algorithm/ranges_upper_bound.md
+++ b/reference/algorithm/ranges_upper_bound.md
@@ -10,13 +10,30 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr I
     upper_bound(I first,
                 S last,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (1) C++20
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    upper_bound(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
@@ -30,6 +47,18 @@ namespace std::ranges {
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    upper_bound(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -69,9 +98,15 @@ namespace std::ranges {
 ## 備考
 - 本関数は、本質的に [`partition_point`](ranges_partition_point.md) と等価である。  
 	具体的には、[`partition_point`](ranges_partition_point.md)`(first, last, [value](const T&amp;amp; e) { return !bool(value &amp;lt; e); })`、あるいは、[`partition_point`](ranges_partition_point.md)`(first, last, [value, comp](const T&amp;amp; e) { return !bool(comp(value, e)); })` とすることで等価の結果が得られる。
-
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::ranges::upper_bound(v, {a, b});
+        ```
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -128,12 +163,56 @@ int main()
 * std::ranges::upper_bound[color ff0000]
 
 
-### 出力
+#### 出力
 ```
 4
 100:1 100:2 200:1 200:2 300:1 300:2
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}が見つかる範囲を取得
+  auto first = std::ranges::lower_bound(v, {3, 4});
+  auto last = std::ranges::upper_bound(v, {3, 4});
+
+  if (first != v.end() &amp;amp;&amp;amp; last != v.end()) {
+    while (first != last) {
+      std::cout &amp;lt;&amp;lt; first-&amp;gt;x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; first-&amp;gt;y &amp;lt;&amp;lt; std::endl;
+      ++first;
+    }
+  }
+}
+```
+* std::ranges::upper_bound[color ff0000]
+* std::ranges::lower_bound[link /reference/algorithm/lower_bound.md]
+
+#### 出力
+```
+3,4
+3,4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -146,3 +225,5 @@ int main()
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- lower_bound / upper_bound : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/upper_bound.html"/>
      <id>8eae9db6e6aa52ad8e2a4f4fc5cca009be560b16:reference/algorithm/upper_bound.md</id>
      <updated>2025-05-27T14:43:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/upper_bound.md b/reference/algorithm/upper_bound.md
index 3ce4be90a..2f86c5121 100644
--- a/reference/algorithm/upper_bound.md
+++ b/reference/algorithm/upper_bound.md
@@ -5,31 +5,49 @@
 
 ```cpp
 namespace std {
-  template&amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   ForwardIterator
     upper_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);       // (1) C++03
-
-  template&amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   constexpr ForwardIterator
     upper_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);       // (1) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
+  constexpr ForwardIterator
+    upper_bound(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value);       // (1) C++26
 
-  template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   ForwardIterator
     upper_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);         // (2) C++03
-
-  template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   constexpr ForwardIterator
     upper_bound(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);         // (2) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type,
+            class Compare&amp;gt;
+  constexpr ForwardIterator
+    upper_bound(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value,
+                Compare comp);         // (2) C++26
 }
 ```
 
@@ -68,9 +86,16 @@ namespace std {
 	具体的には、[`partition_point`](partition_point.md)`(first, last, [value](const T&amp;amp; e) { return !bool(value &amp;lt; e); })`、あるいは、[`partition_point`](partition_point.md)`(first, last, [value, comp](const T&amp;amp; e) { return !bool(comp(value, e)); })` とすることで等価の結果が得られる。
 - 本関数の要件は、上記の通り C++03 までの方が C++11 よりも厳しい。  
 	しかし、本アルゴリズムの特性上、処理系が C++03 までにしか準拠していない場合でも、昇順に並んでいなくても正常に動作する可能性は高いものと思われる。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::upper_bound(v.begin(), v.end(), {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -132,13 +157,57 @@ int main()
 * std::upper_bound[color ff0000]
 
 
-### 出力
+#### 出力
 ```
 4
 100:1 100:2 200:1 200:2 300:1 300:2
 ```
 
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}が見つかる範囲を取得
+  auto first = std::lower_bound(v.begin(), v.end(), {3, 4});
+  auto last = std::upper_bound(v.begin(), v.end(), {3, 4});
+
+  if (first != v.end() &amp;amp;&amp;amp; last != v.end()) {
+    while (first != last) {
+      std::cout &amp;lt;&amp;lt; first-&amp;gt;x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; first-&amp;gt;y &amp;lt;&amp;lt; std::endl;
+      ++first;
+    }
+  }
+}
+```
+* std::upper_bound[color ff0000]
+* std::lower_bound[link /reference/algorithm/lower_bound.md]
+
+#### 出力
+```
+3,4
+3,4
+```
+
+
 ## 実装例
 ```cpp
 template&amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
@@ -180,3 +249,5 @@ upper_bound(ForwardIterator first, ForwardIterator last, const T&amp;amp; value)
 - [LWG Issue 384. `equal_range` has unimplementable runtime complexity](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384)
 - [LWG Issue 2150. Unclear specification of `find_end`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2150)
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- replace_copy_if : コンパイルエラー修正 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_replace_copy_if.html"/>
      <id>bd1ef79d48ec9fd9f3ac5a7950ab86ea82844b83:reference/algorithm/ranges_replace_copy_if.md</id>
      <updated>2025-05-27T14:19:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_replace_copy_if.md b/reference/algorithm/ranges_replace_copy_if.md
index 75cd00256..1993964cd 100644
--- a/reference/algorithm/ranges_replace_copy_if.md
+++ b/reference/algorithm/ranges_replace_copy_if.md
@@ -164,7 +164,7 @@ int main() {
   // 値が{1, 2}の要素をすべて{9, 9}に置き換えたものを出力する
   std::ranges::replace_copy_if(
     v,
-    std::ostream_iterator&amp;lt;int&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
+    std::ostream_iterator&amp;lt;Point&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
     [](const Point&amp;amp; p) { return p.x == 1 &amp;amp;&amp;amp; p.y == 2; },
     {9, 9}
   );
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace_copy_if -- replace_copy_if : コンパイルエラー修正 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/replace_copy_if.html"/>
      <id>bd1ef79d48ec9fd9f3ac5a7950ab86ea82844b83:reference/algorithm/replace_copy_if.md</id>
      <updated>2025-05-27T14:19:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/replace_copy_if.md b/reference/algorithm/replace_copy_if.md
index afcf0e642..39692570c 100644
--- a/reference/algorithm/replace_copy_if.md
+++ b/reference/algorithm/replace_copy_if.md
@@ -150,7 +150,7 @@ int main() {
   std::replace_copy_if(
     v.begin(),
     v.end(),
-    std::ostream_iterator&amp;lt;int&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
+    std::ostream_iterator&amp;lt;Point&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
     [](const Point&amp;amp; p) { return p.x == 1 &amp;amp;&amp;amp; p.y == 2; },
     {9, 9}
   );
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- algorithm/remove_copy : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove_copy.html"/>
      <id>260bfc553044c57089e17e64687fd428d2c49e4c:reference/algorithm/ranges_remove_copy.md</id>
      <updated>2025-05-27T14:13:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove_copy.md b/reference/algorithm/ranges_remove_copy.md
index baf9c7334..d47feda88 100644
--- a/reference/algorithm/ranges_remove_copy.md
+++ b/reference/algorithm/ranges_remove_copy.md
@@ -23,6 +23,23 @@ namespace std::ranges {
                 O result,
                 const T&amp;amp; value,
                 Proj proj = {}); // (1) C++20
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            weakly_incrementable O,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirectly_copyable&amp;lt;I, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr remove_copy_result&amp;lt;I, O&amp;gt;
+    remove_copy(I first,
+                S last,
+                O result,
+                const T&amp;amp; value,
+                Proj proj = {}); // (1) C++26
 
   template &amp;lt;input_range R,
             weakly_incrementable O,
@@ -39,6 +56,21 @@ namespace std::ranges {
                 O result,
                 const T&amp;amp; value,
                 Proj proj = {}); // (2) C++20
+  template &amp;lt;input_range R,
+            weakly_incrementable O,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirectly_copyable&amp;lt;iterator_t&amp;lt;R&amp;gt;, O&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr remove_copy_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, O&amp;gt;
+    remove_copy(R&amp;amp;&amp;amp; r,
+                O result,
+                const T&amp;amp; value,
+                Proj proj = {}); // (2) C++26
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -76,10 +108,17 @@ namespace std::ranges {
 
 
 ## 備考
-安定。
+- 安定。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        std::ranges::remove_copy(v, result, {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -95,11 +134,53 @@ int main() {
 ```
 * std::ranges::remove_copy[color ff0000]
 
-### 出力
+#### 出力
 ```
 2,3,2,
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Point&amp;amp; p) {
+  return os &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; p.y;
+}
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {5, 6},
+    {1, 2},
+  };
+
+  // 値{1, 2}を除去した結果を出力する
+  std::ranges::remove_copy(
+    v,
+    std::ostream_iterator&amp;lt;Point&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
+    {1, 2}
+  );
+}
+```
+* std::ranges::remove_copy[color ff0000]
+
+#### 出力
+```
+3,4
+5,6
+```
+
 
 ## バージョン
 ### 言語
@@ -113,3 +194,5 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove_copy -- algorithm/remove_copy : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove_copy.html"/>
      <id>260bfc553044c57089e17e64687fd428d2c49e4c:reference/algorithm/remove_copy.md</id>
      <updated>2025-05-27T14:13:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove_copy.md b/reference/algorithm/remove_copy.md
index 2e9046c39..a7d0807a7 100644
--- a/reference/algorithm/remove_copy.md
+++ b/reference/algorithm/remove_copy.md
@@ -5,21 +5,34 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class InputIterator, class OutputIterator, class T&amp;gt;
+  template &amp;lt;class InputIterator,
+            class OutputIterator,
+            class T&amp;gt;
   OutputIterator
     remove_copy(InputIterator first,
                 InputIterator last,
                 OutputIterator result,
                 const T&amp;amp; value);         // (1) C++03
-
-  template &amp;lt;class InputIterator, class OutputIterator, class T&amp;gt;
+  template &amp;lt;class InputIterator,
+            class OutputIterator,
+            class T&amp;gt;
   constexpr OutputIterator
     remove_copy(InputIterator first,
                 InputIterator last,
                 OutputIterator result,
                 const T&amp;amp; value);         // (1) C++20
+  template &amp;lt;class InputIterator,
+            class OutputIterator,
+            class T = typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type&amp;gt;
+  constexpr OutputIterator
+    remove_copy(InputIterator first,
+                InputIterator last,
+                OutputIterator result,
+                const T&amp;amp; value);         // (1) C++26
 
-  template &amp;lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
+  template &amp;lt;class ExecutionPolicy,
+            class ForwardIterator1,
+            class ForwardIterator2,
             class T&amp;gt;
   ForwardIterator2
     remove_copy(ExecutionPolicy&amp;amp;&amp;amp; exec,
@@ -27,6 +40,16 @@ namespace std {
                 ForwardIterator1 last,
                 ForwardIterator2 result,
                 const T&amp;amp; value);         // (2) C++17
+  template &amp;lt;class ExecutionPolicy,
+            class ForwardIterator1,
+            class ForwardIterator2,
+            class T = typename iterator_traits&amp;lt;ForwardIterator1&amp;gt;::value_type&amp;gt;
+  ForwardIterator2
+    remove_copy(ExecutionPolicy&amp;amp;&amp;amp; exec,
+                ForwardIterator1 first,
+                ForwardIterator1 last,
+                ForwardIterator2 result,
+                const T&amp;amp; value);         // (2) C++26
 }
 ```
 
@@ -34,7 +57,7 @@ namespace std {
 イテレータ範囲`[first, last)`から指定された要素を除け、その結果を出力の範囲へコピーする。
 
 
-## テンプレートパラメータ制約
+## 適格要件
 - `*result = *first` という式が有効であること
 
 
@@ -55,10 +78,17 @@ namespace std {
 
 
 ## 備考
-安定。
+- 安定。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        std::remove_copy(v.begin(), v.end(), result, {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -75,11 +105,54 @@ int main() {
 ```
 * std::remove_copy[color ff0000]
 
-### 出力
+#### 出力
 ```
 2,3,2,
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Point&amp;amp; p) {
+  return os &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; p.y;
+}
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {5, 6},
+    {1, 2},
+  };
+
+  // 値{1, 2}を除去した結果を出力する
+  std::remove_copy(
+    v.begin(),
+    v.end(),
+    std::ostream_iterator&amp;lt;Point&amp;gt;(std::cout, &amp;#34;\n&amp;#34;),
+    {1, 2}
+  );
+}
+```
+* std::remove_copy[color ff0000]
+
+#### 出力
+```
+3,4
+5,6
+```
+
 
 ## 実装例
 ```cpp
@@ -97,3 +170,5 @@ OutputIterator remove_copy(InputIterator first, InputIterator last,
 ## 参照
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
 - [P0467R2 Iterator Concerns for Parallel Algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0467r2.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- algorithm/remove : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_remove.html"/>
      <id>b810699ddaff07d777dd421a8600be32cb5df601:reference/algorithm/ranges_remove.md</id>
      <updated>2025-05-26T19:08:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_remove.md b/reference/algorithm/ranges_remove.md
index 515d89247..5a3564710 100644
--- a/reference/algorithm/ranges_remove.md
+++ b/reference/algorithm/ranges_remove.md
@@ -16,6 +16,16 @@ namespace std::ranges {
            S last,
            const T&amp;amp; value,
            Proj proj = {}); // (1) C++20
+  template &amp;lt;permutable I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    remove(I first,
+           S last,
+           const T&amp;amp; value,
+           Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
@@ -30,6 +40,19 @@ namespace std::ranges {
     remove(R&amp;amp;&amp;amp; r,
            const T&amp;amp; value,
            Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires permutable&amp;lt;iterator_t&amp;lt;R&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+             indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    remove(R&amp;amp;&amp;amp; r,
+           const T&amp;amp; value,
+           Proj proj = {}); // (2) C++26
 }
 ```
 * permutable[link /reference/iterator/permutable.md]
@@ -67,12 +90,18 @@ namespace std::ranges {
 
 
 ## 備考
-有効な要素を範囲の前方に集める処理には、ムーブを使用する。
-
-取り除いた要素の先頭を指すイテレータを`ret`とし、範囲`[ret, last)`の各要素には、有効な要素からムーブされた値が設定される。それらの値は、「有効だが未規定な値」となる。
+- 有効な要素を範囲の前方に集める処理には、ムーブが使用される
+    - 取り除いた要素の先頭を指すイテレータを`ret`とし、範囲`[ret, last)`の各要素には、有効な要素からムーブされた値が設定される。それらの値は、「有効だが未規定な値」となる
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto sr = std::ranges::remove(v, {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -101,17 +130,57 @@ int main() {
 ```
 * result[color ff0000]
 * std::ranges::remove[color ff0000]
-* v.erase[color ff0000][link /reference/vector/vector/erase.md]
+* v.erase[link /reference/vector/vector/erase.md]
 * std::ranges::subrange[link /reference/ranges/subrange.md]
 * Erase-remove イディオム[link https://ja.wikibooks.org/wiki/More_C%2B%2B_Idioms/%E6%B6%88%E5%8E%BB%E3%83%BB%E5%89%8A%E9%99%A4(Erase-Remove)]
 
-### 出力
+#### 出力
 ```
 2,3,2,
 size before: 5
 size after: 3
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {5, 6},
+    {1, 2},
+  };
+
+  // 値{1, 2}を除去する
+  std::ranges::subrange sr = std::ranges::remove(v, {1, 2});
+  v.erase(sr.begin(), v.end());
+
+  for (const Point&amp;amp; p : v) {
+    std::cout &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; p.y &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::remove[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+* std::ranges::subrange[link /reference/ranges/subrange.md]
+
+#### 出力
+```
+3,4
+5,6
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -124,3 +193,5 @@ size after: 3
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remove -- algorithm/remove : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/remove.html"/>
      <id>b810699ddaff07d777dd421a8600be32cb5df601:reference/algorithm/remove.md</id>
      <updated>2025-05-26T19:08:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/remove.md b/reference/algorithm/remove.md
index fbbca8269..425eb8894 100644
--- a/reference/algorithm/remove.md
+++ b/reference/algorithm/remove.md
@@ -5,24 +5,41 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   ForwardIterator
     remove(ForwardIterator first,
            ForwardIterator last,
            const T&amp;amp; value);        // (1) C++03
-
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   constexpr ForwardIterator
     remove(ForwardIterator first,
            ForwardIterator last,
            const T&amp;amp; value);        // (1) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
+  constexpr ForwardIterator
+    remove(ForwardIterator first,
+           ForwardIterator last,
+           const T&amp;amp; value);        // (1) C++26
 
-  template &amp;lt;class ExecutionPolicy, class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ExecutionPolicy,
+            class ForwardIterator,
+            class T&amp;gt;
   ForwardIterator
     remove(ExecutionPolicy&amp;amp;&amp;amp; exec,
            ForwardIterator first,
            ForwardIterator last,
            const T&amp;amp; value);        // (2) C++17
+  template &amp;lt;class ExecutionPolicy,
+            class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
+  ForwardIterator
+    remove(ExecutionPolicy&amp;amp;&amp;amp; exec,
+           ForwardIterator first,
+           ForwardIterator last,
+           const T&amp;amp; value);        // (2) C++26
 }
 ```
 
@@ -51,12 +68,18 @@ namespace std {
 
 
 ## 備考
-有効な要素を範囲の前方に集める処理には、ムーブを使用する。
-
-取り除いた要素の先頭を指すイテレータを`ret`とし、範囲`[ret, last)`の各要素には、有効な要素からムーブされた値が設定される。それらの値は、「有効だが未規定な値」となる。
+- 有効な要素を範囲の前方に集める処理には、ムーブが使用される
+    - 取り除いた要素の先頭を指すイテレータを`ret`とし、範囲`[ret, last)`の各要素には、有効な要素からムーブされた値が設定される。それらの値は、「有効だが未規定な値」となる
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto it = std::remove(v.begin(), v.end(), {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -83,16 +106,55 @@ int main() {
 ```
 * result[color ff0000]
 * std::remove[color ff0000]
-* v.erase[color ff0000][link /reference/vector/vector/erase.md]
+* v.erase[link /reference/vector/vector/erase.md]
 * Erase-remove イディオム[link https://ja.wikibooks.org/wiki/More_C%2B%2B_Idioms/%E6%B6%88%E5%8E%BB%E3%83%BB%E5%89%8A%E9%99%A4(Erase-Remove)]
 
-### 出力
+#### 出力
 ```
 2,3,2,
 size before: 5
 size after: 3
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {5, 6},
+    {1, 2},
+  };
+
+  // 値{1, 2}を除去する
+  auto it = std::remove(v.begin(), v.end(), {1, 2});
+  v.erase(it, v.end());
+
+  for (const Point&amp;amp; p : v) {
+    std::cout &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; p.y &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::remove[color ff0000]
+* v.erase[link /reference/vector/vector/erase.md]
+
+#### 出力
+```
+3,4
+5,6
+```
+
 
 ## 実装例
 ```cpp
@@ -113,3 +175,5 @@ ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp;amp; val
 - [LWG Issue 2110. `remove` can&amp;#39;t swap but note says it might](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2110)
     - C++11までのこのアルゴリズムは、要素の移動にswap操作が行われるかもしれない、と書いていた。だが、このアルゴリズムの要件は`MoveAssignable`のみであるため、swapはできない。そのため、C++14からは、ムーブのみで要素の移動が行われるようになった。
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- algorithm/fill_n : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/fill_n.html"/>
      <id>e463c2f1b30245bf44d5d57c3eaa3cfb0e5dbb9a:reference/algorithm/fill_n.md</id>
      <updated>2025-05-26T18:42:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/fill_n.md b/reference/algorithm/fill_n.md
index d737860ca..d79e725d8 100644
--- a/reference/algorithm/fill_n.md
+++ b/reference/algorithm/fill_n.md
@@ -5,31 +5,53 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class OutputIterator, class Size, class T&amp;gt;
+  template &amp;lt;class OutputIterator,
+            class Size,
+            class T&amp;gt;
   void
     fill_n(OutputIterator first,
            Size n,
            const T&amp;amp; value);        // (1) C++03
-
-  template &amp;lt;class OutputIterator, class Size, class T&amp;gt;
+  template &amp;lt;class OutputIterator,
+            class Size,
+            class T&amp;gt;
   OutputIterator
     fill_n(OutputIterator first,
            Size n,
            const T&amp;amp; value);        // (1) C++11
-
-  template &amp;lt;class OutputIterator, class Size, class T&amp;gt;
+  template &amp;lt;class OutputIterator,
+            class Size,
+            class T&amp;gt;
   constexpr OutputIterator
     fill_n(OutputIterator first,
            Size n,
            const T&amp;amp; value);        // (1) C++20
+  template &amp;lt;class OutputIterator,
+            class Size,
+            class T = typename iterator_traits&amp;lt;OutputIterator&amp;gt;::value_type&amp;gt;
+  constexpr OutputIterator
+    fill_n(OutputIterator first,
+           Size n,
+           const T&amp;amp; value);        // (1) C++26
 
-  template &amp;lt;class ExecutionPolicy, class ForwardIterator,
-            class Size, class T&amp;gt;
+  template &amp;lt;class ExecutionPolicy,
+            class ForwardIterator,
+            class Size,
+            class T&amp;gt;
   ForwardIterator
     fill_n(ExecutionPolicy&amp;amp;&amp;amp; exec,
            ForwardIterator first,
            Size n,
            const T&amp;amp; value);        // (2) C++17
+  template &amp;lt;class ExecutionPolicy,
+            class ForwardIterator,
+            class Size,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
+  ForwardIterator
+    fill_n(ExecutionPolicy&amp;amp;&amp;amp; exec,
+           ForwardIterator first,
+           Size n,
+           const T&amp;amp; value);        // (2) C++26
 }
 ```
 
@@ -37,7 +59,7 @@ namespace std {
 イテレータ範囲`[first, first + n)`のすべての要素に指定された値を書き込む。
 
 
-## 要件
+## 適格要件
 - `value` は `output iterator` へ書き込み可能でなければならない。
 - `Size` は `integral type` に変換可能でなければならない。
 
@@ -57,24 +79,69 @@ namespace std {
 `n` が 1 以上の場合は `n` 回、そうでない場合は 0 回の代入を行う。
 
 
+## 備考
+- (1), (2) :
+    - C++26 : `value`パラメータとして波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        std::fill_n(v.begin(), n, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;iterator&amp;gt;
 
 int main() {
-  // 3 を出力しまくる
+  // 値3を10個出力する
   std::fill_n(std::ostream_iterator&amp;lt;int&amp;gt;(std::cout, &amp;#34;,&amp;#34;), 10, 3);
 }
 ```
 * std::fill_n[color ff0000]
 
-### 出力
+#### 出力
 ```
 3,3,3,3,3,3,3,3,3,3,
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v(5);
+
+  // 先頭3個の要素を値{1, 2}で埋める
+  std::fill_n(v.begin(), 3, {1, 2});
+
+  for (const Point&amp;amp; p : v) {
+    std::cout &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; p.y &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::fill_n[color ff0000]
+
+#### 出力
+```
+1,2
+1,2
+1,2
+0,0
+0,0
+```
+
 
 ## 実装例
 ```cpp
@@ -107,3 +174,5 @@ fill_n(OutputIterator first, Size n, const T&amp;amp; value) {
 	戻り値が追加されるきっかけとなったレポート
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
 - [P0467R2 Iterator Concerns for Parallel Algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0467r2.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fill_n -- algorithm/fill_n : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fill_n.html"/>
      <id>e463c2f1b30245bf44d5d57c3eaa3cfb0e5dbb9a:reference/algorithm/ranges_fill_n.md</id>
      <updated>2025-05-26T18:42:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fill_n.md b/reference/algorithm/ranges_fill_n.md
index 4ccd268ed..6a89db71c 100644
--- a/reference/algorithm/ranges_fill_n.md
+++ b/reference/algorithm/ranges_fill_n.md
@@ -6,9 +6,19 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T, output_iterator&amp;lt;const T&amp;amp;&amp;gt; O&amp;gt;
+  template &amp;lt;class T,
+            output_iterator&amp;lt;const T&amp;amp;&amp;gt; O&amp;gt;
   constexpr O
-    fill_n(O first, iter_difference_t&amp;lt;O&amp;gt; n, const T&amp;amp; value); // (1) C++20
+    fill_n(O first,
+           iter_difference_t&amp;lt;O&amp;gt; n,
+           const T&amp;amp; value);   // (1) C++20
+  template &amp;lt;class O,
+            class T = iter_value_t&amp;lt;O&amp;gt;&amp;gt;
+    requires output_iterator&amp;lt;O, const T&amp;amp;&amp;gt;
+  constexpr O
+    fill_n(O first,
+           iter_difference_t&amp;lt;O&amp;gt; n,
+           const T&amp;amp; value);   // (1) C++26
 }
 ```
 * output_iterator[link /reference/iterator/output_iterator.md]
@@ -30,24 +40,69 @@ namespace std::ranges {
 `n` が 1 以上の場合は `n` 回、そうでない場合は 0 回の代入を行う。
 
 
+## 備考
+- (1) :
+    - C++26 : `value`パラメータとして波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        std::ranges::fill_n(v.begin(), n, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;iterator&amp;gt;
 
 int main() {
-  // 3 を10回出力する
+  // 値3を10個出力する
   std::ranges::fill_n(std::ostream_iterator&amp;lt;int&amp;gt;(std::cout, &amp;#34;,&amp;#34;), 10, 3);
 }
 ```
 * std::ranges::fill_n[color ff0000]
 
-### 出力
+#### 出力
 ```
 3,3,3,3,3,3,3,3,3,3,
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v(5);
+
+  // 先頭3個の要素を値{1, 2}で埋める
+  std::ranges::fill_n(v.begin(), 3, {1, 2});
+
+  for (const Point&amp;amp; p : v) {
+    std::cout &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; p.y &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::fill_n[color ff0000]
+
+#### 出力
+```
+1,2
+1,2
+1,2
+0,0
+0,0
+```
+
 
 ## バージョン
 ### 言語
@@ -61,3 +116,5 @@ int main() {
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>