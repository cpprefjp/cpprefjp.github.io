<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-06-09T03:48:02.864369</updated>
  <id>efc2bfe3-132c-4cd2-b2ff-cfbeb57dd568</id>

  
    <entry>
      <title>comp_ellint_1 -- comp_ellint_1 : サンプルコードを追記</title>
      <link href="https://cpprefjp.github.io/reference/cmath/comp_ellint_1.html"/>
      <id>50a7c5ec1aaf8cf29e268259011460d4ddafbe2f:reference/cmath/comp_ellint_1.md</id>
      <updated>2021-06-09T12:43:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/comp_ellint_1.md b/reference/cmath/comp_ellint_1.md
index 5b5285cec..96c669a22 100644
--- a/reference/cmath/comp_ellint_1.md
+++ b/reference/cmath/comp_ellint_1.md
@@ -7,9 +7,9 @@
 
 ```cpp
 namespace std {
-float comp_ellint_1f(float k);
-double comp_ellint_1(double k);
-long double comp_ellint_1l(long double k);
+  float comp_ellint_1f(float k);
+  double comp_ellint_1(double k);
+  long double comp_ellint_1l(long double k);
 }
 ```
 
@@ -47,6 +47,46 @@ comp_ellint_1(0.5) = 1.68575
 comp_ellint_1(1)   = nan
 ```
 
+## 単振り子の周期と等時性の破れ
+
+単振り子の周期$ T $は、第一種完全楕円積分$ K $を用いて、$ T = 4 \sqrt{\frac{l}{g}} K(\sin(\frac{\theta}{2})) $と書ける（$ l $は長さ、$ g $は重力加速度）。$ l = 1 [m]$の時の周期 $ T [s]$と、近似値$ T_0 = 2\pi\sqrt{\frac{l}{g}}$との比$T/T_0$を計算する例。
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;cmath&amp;gt;
+#include &amp;lt;iomanip&amp;gt;
+
+constexpr double pi = 3.141592653589793;
+constexpr double g = 9.80665;
+
+double pendulum_period(double l, double theta) {
+  return 4.0 * std::sqrt(l/g) * std::comp_ellint_1(std::sin(theta/2.0));
+}
+
+double pendulum_period_shift(double theta) {
+  return (2.0 * std::comp_ellint_1(std::sin(theta/2.0))) / pi;
+}
+
+int main() {
+  std::cout &amp;lt;&amp;lt; std::setprecision(16);
+  
+  for (const auto theta : {15.0, 30.0, 45.0, 60.0}) {
+    const auto angle = theta * pi / 180.0;
+    std::cout &amp;lt;&amp;lt; theta &amp;lt;&amp;lt; &amp;#34; [°] : &amp;#34;;
+    std::cout &amp;lt;&amp;lt; &amp;#34;T = &amp;#34; &amp;lt;&amp;lt; pendulum_period(1.0, angle) &amp;lt;&amp;lt; &amp;#34; [s], T/T0 = &amp;#34;;
+    std::cout &amp;lt;&amp;lt; pendulum_period_shift(angle) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
+  }
+}
+```
+* std::comp_ellint_1[color ff0000]
+
+### 出力例
+```
+15 [°] : T = 2.015038014606197 [s], T/T0 = 1.004300579173466
+30 [°] : T = 2.041338465858369 [s], T/T0 = 1.017408797595956
+45 [°] : T = 2.08661217983496 [s], T/T0 = 1.039973343196804
+60 [°] : T = 2.153242351783843 [s], T/T0 = 1.073182007149365
+```
 
 ## バージョン
 ### 言語
@@ -72,7 +112,7 @@ GCC 7.1.0–8.0.0 では定義域エラーが発生したときに [`std::numeri
 - [N3060 JTC1.22.29124 Programming Language C++ — Special Math Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3060.pdf)
 - [WG21 P0226R1 Mathematical Special Functions for C++17, v5](https://isocpp.org/files/papers/P0226R1.pdf)
 - [ISO/IEC 29124:2010 Information technology -- Programming languages, their environments and system software interfaces -- Extensions to the C++ Library to support mathematical special functions](https://www.iso.org/standard/50511.html)
-
+- [振り子 - Wikipedia](https://ja.wikipedia.org/wiki/振り子)
 
 ## 実装例
 ### 級数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>invocable -- invocable: 例示コードstd::regular_invocable動作へのコメント補足</title>
      <link href="https://cpprefjp.github.io/reference/concepts/invocable.html"/>
      <id>7605b9cb624af37d15f238e6167f2eff3425136b:reference/concepts/invocable.md</id>
      <updated>2021-06-07T18:09:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/invocable.md b/reference/concepts/invocable.md
index 6da8359d9..a3dc2b4f9 100644
--- a/reference/concepts/invocable.md
+++ b/reference/concepts/invocable.md
@@ -144,7 +144,10 @@ int main() {
   // 内部状態を保ち、等しさを保持しない呼び出し可能な型
   f&amp;lt;decltype(mut_lambda), int&amp;gt;(&amp;#34;mut_lambda(int)&amp;#34;);
   f&amp;lt;std::mt19937&amp;gt;(&amp;#34;std::mt19937()&amp;#34;);
-  
+  // これらの型は std::regular_invocable コンセプトのモデルではないが
+  // C++構文上では std::invocable との差異を区別しない／できないため
+  // それぞれ「XXX is regular_invocable」と出力される。
+
   std::cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
   f&amp;lt;decltype(func), int*&amp;gt;(&amp;#34;func(int*)&amp;#34;);
   f&amp;lt;not_invocable&amp;gt;(&amp;#34;not_invocable()&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>右辺値参照・ムーブセマンティクス -- Merge pull request #874 from cpprefjp/fix-perfect-forwarding</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html"/>
      <id>21813e4a9a121fb6b7eeb8af0383be06fe89510e:lang/cpp11/rvalue_ref_and_move_semantics.md</id>
      <updated>2021-06-06T22:27:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/rvalue_ref_and_move_semantics.md b/lang/cpp11/rvalue_ref_and_move_semantics.md
index 63e2555cc..fa0bcb4d6 100644
--- a/lang/cpp11/rvalue_ref_and_move_semantics.md
+++ b/lang/cpp11/rvalue_ref_and_move_semantics.md
@@ -276,33 +276,44 @@ public:
 
 
 ### ユニヴァーサル参照
-テンプレート変数や`auto`に`&amp;amp;&amp;amp;`をつけた場合には、通常の右辺値参照とは異なる動作をする。
+関数テンプレートの型パラメータ`T`や[型推論プレースホルダ`auto`](auto.md)に参照修飾子`&amp;amp;&amp;amp;`をつけて宣言したものはユニヴァーサル参照と呼ばれ、通常の右辺値参照とは異なる動作をする。
+なお「ユニヴァーサル参照(Universal Reference)」は[Scott Mayers氏による解説](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)由来の俗称であり、後にC++17仕様において「転送参照(Fowarding Reference)」という正式名称が与えられた。
 
 ```cpp
+// ユニヴァーサル参照
 template &amp;lt;typename T&amp;gt;
 void f(T&amp;amp;&amp;amp; x) {}
 ```
 
-とした場合、`f()`に渡された実引数が左辺値の場合には左辺値参照となり、右辺値の場合は右辺値参照となる。  
+関数テンプレート`f()`の型パラメータ`T`はユニヴァーサル参照であり、
+`f()`に渡された実引数が左辺値の場合には左辺値参照となり、右辺値の場合は右辺値参照となる。  
 これは、次で説明する完全転送に関わる。
 
 ### 完全転送（Perfect Forwarding）
 
-ある関数内で引数を別の関数に渡したいことがある。  
-引数を右辺値参照した場合は別の関数に渡すときにも右辺値として渡すことが自然である。  
-一度右辺値参照すると、変数は左辺値であるのでもう一度ムーブする必要がある。  
-しかし、引数をユニヴァーサル参照で宣言した場合安易にムーブできない。  
-引数は右辺値参照の場合と左辺値参照の場合両方があり得るからである。  
-左辺値参照の場合はムーブせず、右辺値参照の場合はムーブして渡す機能が必要となる。  
-そのような機能として、[`std::forward()`](/reference/utility/forward.md)関数が用意されている。  
+あるが関数が受け取ったパラメータを別の関数へそのまま渡したいとき、
+右辺値は右辺値として、左辺値は左辺値として別の関数へ転送したいことがある（完全転送）。  
+ユニヴァーサル参照を用いると、呼び出し元における右辺値／左辺値という情報が、受け取り側で右辺値参照／左辺値参照という型情報によって区別可能となる。  
+しかし右辺値を右辺値参照で受け取った場合、その引数をそのまま使うと左辺値になるため再び右辺値へ変換する必要が生じる。  
 
+つまり左辺値参照の場合は左辺値として、右辺値参照の場合は右辺値に変換して渡す機能が必要となる。  
+そのような機能として、[`std::forward()`](/reference/utility/forward.md)関数が用意されている。  
+利用時には `std::forward&amp;lt;T&amp;gt;(a)` のように、テンプレートパラメータとしてユニヴァーサル参照宣言時の型パラメータ名を明示する必要がある。
 
 ```cpp
+#include &amp;lt;utility&amp;gt;
+
+template &amp;lt;typename T&amp;gt; void g(T);
+
 template &amp;lt;typename T&amp;gt;
 void f(T&amp;amp;&amp;amp; a)
 {
-  // 実引数が右辺値参照型の場合のみムーブされる
+  // 引数 a が左辺値参照の場合は 左辺値 に
+  // 右辺値参照の場合は 右辺値 に変換してから
+  // 別関数 g() の実引数として渡す。
   g( std::forward&amp;lt;T&amp;gt;(a) ) ;
+  // 関数 g() は値型 T としてパラメータを取るため
+  // 左辺値ではコピーが、右辺値ではムーブが行われる。
 }
 ```
 * std::forward[link /reference/utility/forward.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Hidden Friends -- Hidden Friends : 定義を追加した</title>
      <link href="https://cpprefjp.github.io/article/lib/hidden_friends.html"/>
      <id>2e1fce53de48ab7be25c5a9b19eebf0539f0f303:article/lib/hidden_friends.md</id>
      <updated>2021-06-06T17:05:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/article/lib/hidden_friends.md b/article/lib/hidden_friends.md
index e6a6ff895..1da63417a 100644
--- a/article/lib/hidden_friends.md
+++ b/article/lib/hidden_friends.md
@@ -7,14 +7,14 @@ namespace NS {
   struct C {
 
     // メンバ関数
-    void mem_func();
+    void mem_func() {}
 
     // Hidden Friends
-    friend void hidden_friend(C&amp;amp; self);
+    friend void hidden_friend(C&amp;amp; self) {}
   };
 
   // 普通の非メンバ関数
-  void free_func(C&amp;amp; c);
+  void free_func(C&amp;amp; c) {}
 }
 
 int main() {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンパイル時初期化を強制する`constinit`キーワードを追加 -- constinit: 静的変数の動的初期化タイミングに関する記述を一旦削除</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/constinit.html"/>
      <id>47e0186912cfb6aa2992bc92ee2e653c5d046998:lang/cpp20/constinit.md</id>
      <updated>2021-06-04T23:18:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/constinit.md b/lang/cpp20/constinit.md
index e89b6be0f..8d9a370fa 100644
--- a/lang/cpp20/constinit.md
+++ b/lang/cpp20/constinit.md
@@ -95,7 +95,7 @@ int S::M = 12;  // NG、constinitはこちらに必要、おそらく警告が
 
 動的初期化は実行時に行われる初期化であり、静的初期化はコンパイル時に行われる初期化である。全ての静的変数はコンパイル完了時点で静的初期化されており、その中で動的初期化が必要となる変数だけが動的初期化される。
 
-定数初期化は静的変数に対して最初に試みられる初期化で、初期化式が定数式として実行可能である時に行われる。定数初期化できない残りの変数は全てゼロ初期化される。ゼロ初期化された変数のうち、初期化式を持つものについては実行時（プログラム開始時）に動的初期化される。
+定数初期化は静的変数に対して最初に試みられる初期化で、初期化式が定数式として実行可能である時に行われる。定数初期化できない残りの変数は全てゼロ初期化される。ゼロ初期化された変数のうち、初期化式を持つものについては実行時に動的初期化される。
 
 定数初期化は非リテラル型のクラス型であっても、対応するコンストラクタが`constexpr`コンストラクタであり、そのコンストラクタを通して全てのメンバが定数式で初期化される場合に、クラス型のオブジェクトに対しても実行可能となる（下の例ではこのコンストラクタのことを定数初期化コンストラクタと呼んでいる）。
 
@@ -160,7 +160,7 @@ int main() {
 
 ## この機能が必要になった背景・経緯
 
-静的変数の動的初期化は関数ローカルスコープのものを除いて`main()`の実行よりも前に行われる。そこではコンストラクタ呼び出しを介して通常のC++コードの実行をほぼ自由に行うことができる一方で、各変数の動的初期化順序がどうなるのかはほとんど不定である。
+静的変数の動的初期化ではコンストラクタ呼び出しを介して通常のC++コードの実行をほぼ自由に行うことができる一方で、各変数の動的初期化順序がどうなるのかはほとんど不定である。
 
 同じ翻訳単位にある静的変数の動的初期化順序はその定義の現れる順番と規定されてはいるが、テンプレートや外部リンケージを持つ変数（`extern/inline`など）およびそれらとの間には順序が規定されておらず、動的初期化の順序に依存したコードは多くの場合未定義動作に陥っている（データ競合や未初期化変数の読み取りなど）。この問題は*static initialization order fiasco*として知られている。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>