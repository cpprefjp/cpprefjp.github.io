<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-04-17T03:10:13.230406</updated>
  <id>542fb0f3-4908-4acd-a637-853c7f319cbb</id>

  
    <entry>
      <title>append -- basic_string::append : コメントアウトが外れていたのを修正</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/append.html"/>
      <id>5eaa8eebe4f6275b47229ed76bfb655ae73896a6:reference/string/basic_string/append.md</id>
      <updated>2023-04-17T12:05:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/append.md b/reference/string/basic_string/append.md
index 8ebc7b88d..aec336438 100644
--- a/reference/string/basic_string/append.md
+++ b/reference/string/basic_string/append.md
@@ -54,12 +54,12 @@ template&amp;lt;class T&amp;gt;
 basic_string&amp;amp;
   append(const T&amp;amp; t,
         size_type pos,
-        size_type n = npos); / (9) C++17
+        size_type n = npos); // (9) C++17
 template&amp;lt;class T&amp;gt;
 constexpr basic_string&amp;amp;
   append(const T&amp;amp; t,
         size_type pos,
-        size_type n = npos); / (9) C++20
+        size_type n = npos); // (9) C++20
 ```
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator!= -- type_info::operator!= : =が変だったのを修正</title>
      <link href="https://cpprefjp.github.io/reference/typeinfo/type_info/op_not_equal.html"/>
      <id>b240dfdc804d6675c712e38bad9e666d79964225:reference/typeinfo/type_info/op_not_equal.md</id>
      <updated>2023-04-14T16:22:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/typeinfo/type_info/op_not_equal.md b/reference/typeinfo/type_info/op_not_equal.md
index 77ae97dc9..4f5b6435f 100644
--- a/reference/typeinfo/type_info/op_not_equal.md
+++ b/reference/typeinfo/type_info/op_not_equal.md
@@ -12,7 +12,7 @@ bool operator!=(const type_info&amp;amp; rhs) const noexcept; // (1) C++11
 
 ## 概要
 2つの型が異なるかを判定する
-（C++20からは、`operator＝=`から導出される）
+（C++20からは、`operator==`から導出される）
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- pairコンストラクタ : explicitになる条件の調整</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_constructor.html"/>
      <id>abc25987eceb7bfea7f0dee74dd39a6239e074b3:reference/utility/pair/op_constructor.md</id>
      <updated>2023-04-11T10:37:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_constructor.md b/reference/utility/pair/op_constructor.md
index f4a009000..c0eedfa56 100644
--- a/reference/utility/pair/op_constructor.md
+++ b/reference/utility/pair/op_constructor.md
@@ -128,11 +128,13 @@ constexpr pair(piecewise_construct_t,
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
 - (6)-(10) :
     - `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して
-    - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p))), T1&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p))), T2&amp;gt;`である場合、`explicit`指定される
+    - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p))), first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p))), second_type&amp;gt;`である場合、`explicit`指定される
 - (7) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U1&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U2&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
+    - C++23 : (6)-(10) での定義参照（複雑であるが、条件は同等である）
 - (8) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
+    - C++23 : (6)-(10) での定義参照（複雑であるが、条件は同等である）
 
 ## 備考
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- pairコンストラクタ : explicit/delete条件の整理</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_constructor.html"/>
      <id>bbf0c78e4950b3cec5fba5986840fcd0064a38da:reference/utility/pair/op_constructor.md</id>
      <updated>2023-04-11T10:24:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_constructor.md b/reference/utility/pair/op_constructor.md
index 2556f04c2..f4a009000 100644
--- a/reference/utility/pair/op_constructor.md
+++ b/reference/utility/pair/op_constructor.md
@@ -109,26 +109,34 @@ constexpr pair(piecewise_construct_t,
 - (11) :
     - [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;first_type, Args1&amp;amp;&amp;amp;...&amp;gt;::value &amp;amp;&amp;amp;` [`is_constructible`](/reference/type_traits/is_constructible.md)`&amp;lt;second_type, Args2&amp;amp;&amp;amp;...&amp;gt;::value`であること
 
+## delete定義される条件（C++23）
+
+- (5) : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;`である場合、このコンストラクタは削除定義される
+- (6)-(10) :
+    - `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して
+    - [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p)))&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p)))&amp;gt;`である場合、このコンストラクタは削除定義される
+- (11) : 要素型（`T1, T2`のどちらかもしくは両方）が参照型であり、初期化によって一時オブジェクトを束縛することになる場合、このコンストラクタは削除定義される
+    - 上記のコンストラクタと同様に、[`reference_constructs_from_temporary`](/reference/type_traits/reference_constructs_from_temporary.md)を使用して判定される
+
+## explicitになる条件
 
-## 備考
 - (1) :
     - C++17 : `first_type`と`second_type`のどちらかが非暗黙にデフォルト構築できない場合、`explicit`指定される
 - (4) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const first_type&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const second_type&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
 - (5) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
-    - C++23 : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;`である場合、このコンストラクタは削除定義される
 - (6)-(10) :
     - `FWD(u)`を`static_cast&amp;lt;deccltype(u)&amp;gt;(u)`と定義して
     - C++23 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p))), T1&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p))), T2&amp;gt;`である場合、`explicit`指定される
-    - C++23 : [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;first_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;0&amp;gt;(FWD(p)))&amp;gt; ||` [`reference_constructs_from_temporary_v`](/reference/type_traits/reference_constructs_from_temporary.md)`&amp;lt;second_type, decltype(`[`get`](/reference/utility/pair/get.md)`&amp;lt;1&amp;gt;(FWD(p)))&amp;gt;`である場合、このコンストラクタは削除定義される
 - (7) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U1&amp;amp;, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const U2&amp;amp;, second_type&amp;gt;`である場合、`explicit`指定される
-    - C++23 : (6)-(10) での定義参照
 - (8) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
-    - C++23 : (6)-(10) での定義参照
-- (11) : このコンストラクタでは`first`/`second`をそのコンストラクタ引数から直接構築するため、ムーブもコピーもできないような型でも初期化することができる
+
+## 備考
+
+- (11)のコンストラクタでは`first`/`second`をそのコンストラクタ引数から直接構築するため、コピーもムーブもできないような型でも初期化することができる
 
 - C++17では、コンストラクタの各オーバーロードが条件付きで`explicit`となるよう規定された。これは、以下のような初期化子リストを使用したC++17での初期化が不適格になっていたため、適格になるようにするための変更である：
     ```cpp
@@ -143,7 +151,7 @@ constexpr pair(piecewise_construct_t,
 
     - この変更はC++17に対するものであるが、コンパイラが早期に対応していたため、一部処理系ではC++14の段階から適格となっていた
 
-- C++23 では、ダングリング参照の作成が簡単にできていた状態を改善するべく、[`reference_constructs_from_temporary`](/reference/type_traits/reference_constructs_from_temporary.md)が追加され、ダングリング参照が作成される場合には不適格とするようになった :
+- C++23 では、ダングリング参照の作成が簡単にできていた状態を改善するべく、[`reference_constructs_from_temporary`](/reference/type_traits/reference_constructs_from_temporary.md)が追加され、一部のコンストラクタにおいてダングリング参照が作成される場合には不適格とするようになった :
     ```cpp
     // コンストラクタ引数で std::string が構築され
     // その一時オブジェクトが束縛されるため、ダングリング参照となっていた
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- pair : piecewise constructionの説明を改善</title>
      <link href="https://cpprefjp.github.io/reference/utility/pair/op_constructor.html"/>
      <id>ef831a1bc7916fef42e7d21cc5ecc7a90249d9db:reference/utility/pair/op_constructor.md</id>
      <updated>2023-04-11T10:09:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/pair/op_constructor.md b/reference/utility/pair/op_constructor.md
index 84bb25ebc..2556f04c2 100644
--- a/reference/utility/pair/op_constructor.md
+++ b/reference/utility/pair/op_constructor.md
@@ -84,7 +84,8 @@ constexpr pair(piecewise_construct_t,
 - (8) : 変換可能な他の[`pair`](../pair.md)オブジェクトからムーブ構築
 - (9) : 変換可能な他の[`pair`](../pair.md)オブジェクトから構築
 - (10) : [`pair-like`](/reference/tuple/tuple-like.md)なオブジェクトから構築
-- (11) : `first`と`second`のコンストラクタ引数を受け取り、`first_args`と`second_args`それぞれの要素から`first`と`second`をムーブ構築
+- (11) : `first`と`second`のコンストラクタ引数を`std::tuple`に詰めて受け取り、`first_args`と`second_args`内のそれぞれの要素を転送して`first`と`second`を直接構築
+    - 転送は、`std::tuple`オブジェクト（`first_args`/`second_args`）内の要素`x`とその型`U`（`Args1...`/`Args2...`に含まれる型）によって、`std::forward&amp;lt;U&amp;gt;(x)`のようにしてコンストラクタに渡される
 
 
 ## テンプレートパラメータ制約
@@ -127,6 +128,7 @@ constexpr pair(piecewise_construct_t,
 - (8) :
     - C++17 : `!`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U1, first_type&amp;gt; || !`[`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;U2, second_type&amp;gt;`である場合、`explicit`指定される
     - C++23 : (6)-(10) での定義参照
+- (11) : このコンストラクタでは`first`/`second`をそのコンストラクタ引数から直接構築するため、ムーブもコピーもできないような型でも初期化することができる
 
 - C++17では、コンストラクタの各オーバーロードが条件付きで`explicit`となるよう規定された。これは、以下のような初期化子リストを使用したC++17での初期化が不適格になっていたため、適格になるようにするための変更である：
     ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>