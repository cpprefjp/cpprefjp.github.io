<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-03-20T21:00:54.764986</updated>
  <id>2637cf94-10ee-4b90-bb9d-972e482cb6bd</id>

  
    <entry>
      <title>algorithm -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index f8e74ad2d..ec57f7a87 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -408,15 +408,15 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 
 これらの型は、複数の値を1つの戻り値として返すために使われる汎用的な型である。構造化束縛で受け取ることが想定されている。
 
-| 名前 | 説明 | 対応バージョン |
-|-------------------------------------------------------|------------------------|-------|
-| [`ranges::in_fun_result`](algorithm/ranges_in_fun_result.md.nolink)         | イテレータと関数オブジェクトを格納する型 | C++20 |
-| [`ranges::in_in_result`](algorithm/ranges_in_in_result.md.nolink)           | 2つのイテレータを格納する型              | C++20 |
-| [`ranges::in_out_result`](algorithm/ranges_in_out_result.md.nolink)         | 2つのイテレータを格納する型              | C++20 |
-| [`ranges::in_in_out_result`](algorithm/ranges_in_in_out_result.md.nolink)   | 3つのイテレータを格納する型              | C++20 |
-| [`ranges::in_out_out_result`](algorithm/ranges_in_out_out_result.md.nolink) | 3つのイテレータを格納する型              | C++20 |
-| [`ranges::min_max_result`](algorithm/ranges_min_max_result.md.nolink)       | 2つの値または参照を格納する型            | C++20 |
-| [`ranges::in_found_result`](algorithm/ranges_in_found_result.md.nolink)     | イテレータとbool値を格納する型           | C++20 |
+| 名前                                                                 | 説明                                     | 対応バージョン |
+|----------------------------------------------------------------------|------------------------------------------|----------------|
+| [`ranges::in_fun_result`](algorithm/ranges_in_fun_result.md)         | イテレータと関数オブジェクトを格納する型 | C++20          |
+| [`ranges::in_in_result`](algorithm/ranges_in_in_result.md)           | 2つのイテレータを格納する型              | C++20          |
+| [`ranges::in_out_result`](algorithm/ranges_in_out_result.md)         | 2つのイテレータを格納する型              | C++20          |
+| [`ranges::in_in_out_result`](algorithm/ranges_in_in_out_result.md)   | 3つのイテレータを格納する型              | C++20          |
+| [`ranges::in_out_out_result`](algorithm/ranges_in_out_out_result.md) | 3つのイテレータを格納する型              | C++20          |
+| [`ranges::min_max_result`](algorithm/ranges_min_max_result.md)       | 2つの値または参照を格納する型            | C++20          |
+| [`ranges::in_found_result`](algorithm/ranges_in_found_result.md)     | イテレータとbool値を格納する型           | C++20          |
 
 ## 関連項目
 - [`&amp;lt;numeric&amp;gt;`](/reference/numeric.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_for_each.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each.md b/reference/algorithm/ranges_for_each.md
index 3db4f4ca8..6100702e2 100644
--- a/reference/algorithm/ranges_for_each.md
+++ b/reference/algorithm/ranges_for_each.md
@@ -6,9 +6,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I, class F&amp;gt;
-  using for_each_result = in_fun_result&amp;lt;I, F&amp;gt;;
-
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
   constexpr for_each_result&amp;lt;I, Fun&amp;gt; for_each(I first, S last, Fun f, Proj proj = {});                     // (1)
 
@@ -24,7 +21,7 @@ namespace std::ranges {
 * input_range[link /reference/ranges/input_range.md]
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 * projected[link /reference/iterator/projected.md]
-* in_fun_result[link /reference/algorithm/ranges_in_fun_result.md.nolink]
+* for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
 
 
 ## 概要
@@ -49,7 +46,13 @@ namespace std::ranges {
 
 ## 戻り値
 
-`{last, std::move(f)}`
+```cpp
+for_each_result {
+  .in = last,
+  .fun = std::move(f),
+}
+```
+* for_each_result[link /reference/algorithm/ranges_in_fun_result.md]
 
 ## 計算量
 正確に `f` を `last - first` 回適用する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index 04e082207..af7a4db63 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -6,9 +6,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I, class F&amp;gt;
-  using for_each_n_result = in_fun_result&amp;lt;I, F&amp;gt;;
-
   template&amp;lt;input_iterator I, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
   constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; for_each_n(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {});
 }
@@ -18,7 +15,7 @@ namespace std::ranges {
 * indirectly_unary_invocable[link /reference/iterator/indirectly_unary_invocable.md]
 * projected[link /reference/iterator/projected.md]
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
-* in_fun_result[link /reference/algorithm/ranges_in_fun_result.md.nolink]
+* for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
 
 ## 概要
 範囲の先頭N個の要素に、指定された関数を適用する。
@@ -39,7 +36,13 @@ namespace std::ranges {
 このアルゴリズムはその他のアルゴリズムと違い、[`invoke`](/reference/functional/invoke.md)`(proj, *i)` が書き換え可能な参照であれば、関数 `f` の内部でその値を書き換えても構わない。
 
 ## 戻り値
-`{first + n, std::move(f)}`
+```cpp
+for_each_n_result {
+  .in = first + n,
+  .fun = std::move(f)
+}
+```
+* for_each_n_result[link /reference/algorithm/ranges_in_fun_result.md]
 
 ## 備考
 - 関数 `f` に戻り値がある場合、それは単に無視される
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_fun_result -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_found_result.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_in_found_result.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_found_result.md b/reference/algorithm/ranges_in_found_result.md
new file mode 100644
index 000000000..c172d324a
--- /dev/null
+++ b/reference/algorithm/ranges_in_found_result.md
@@ -0,0 +1,71 @@
+# in_fun_result
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;class I&amp;gt;
+  struct in_found_result {
+    [[no_unique_address]] I in;
+    bool found;
+
+    template&amp;lt;class I2&amp;gt;
+      requires convertible_to&amp;lt;const I&amp;amp;, I2&amp;gt;
+    constexpr operator in_found_result&amp;lt;I2&amp;gt;() const &amp;amp; {
+      return {in, found};
+    }
+    template&amp;lt;class I2&amp;gt;
+      requires convertible_to&amp;lt;I, I2&amp;gt;
+    constexpr operator in_found_result&amp;lt;I2&amp;gt;() &amp;amp;&amp;amp; {
+      return {std::move(in), found};
+    }
+  };
+
+  // (2)
+  template&amp;lt;class I&amp;gt;
+  using next_permutation_result = in_found_result&amp;lt;I&amp;gt;;
+
+  // (3)
+  template&amp;lt;class I&amp;gt;
+  using prev_permutation_result = in_found_result&amp;lt;I&amp;gt;;
+}
+```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* std::move[link /reference/utility/move.md]
+
+## 概要
+* (1): イテレータと`bool`を格納する型
+* (2): [`ranges::next_permutation`](ranges_next_permutation.md)で使用するエイリアス
+* (3): [`ranges::prev_permutation`](ranges_prev_permutation.md)で使用するエイリアス
+
+この型は、関数が範囲を受け取り、何かを発見したかどうかを返す場合に、処理した範囲の末尾と結果を返すために使用される。
+
+標準アルゴリズム関数ではこの型を直接返す代わりに、関数毎にエイリアスを定義している。
+
+## メンバ関数
+
+| 名前                           | 説明           | 対応バージョン |
+|--------------------------------|----------------|----------------|
+| `operator in_found_result&amp;lt;I2&amp;gt;` | 変換演算子     | C++20          |
+
+変換演算子は、各テンプレートパラメーターが変換できる場合のみオーバーロード解決に参加する。
+
+## 例
+(執筆中)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_fun_result -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_fun_result.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_in_fun_result.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_fun_result.md b/reference/algorithm/ranges_in_fun_result.md
new file mode 100644
index 000000000..a162a4922
--- /dev/null
+++ b/reference/algorithm/ranges_in_fun_result.md
@@ -0,0 +1,72 @@
+# in_fun_result
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;class I, class F&amp;gt;
+  struct in_fun_result {
+    [[no_unique_address]] I in;
+    [[no_unique_address]] F fun;
+
+    template&amp;lt;class I2, class F2&amp;gt;
+      requires convertible_to&amp;lt;const I&amp;amp;, I2&amp;gt; &amp;amp;&amp;amp; convertible_to&amp;lt;const F&amp;amp;, F2&amp;gt;
+    constexpr operator in_fun_result&amp;lt;I2, F2&amp;gt;() const &amp;amp; {
+      return {in, fun};
+    }
+
+    template&amp;lt;class I2, class F2&amp;gt;
+      requires convertible_to&amp;lt;I, I2&amp;gt; &amp;amp;&amp;amp; convertible_to&amp;lt;F, F2&amp;gt;
+    constexpr operator in_fun_result&amp;lt;I2, F2&amp;gt;() &amp;amp;&amp;amp; {
+      return {std::move(in), std::move(fun)};
+    }
+  };
+
+  // (2)
+  template&amp;lt;class I, class F&amp;gt;
+  using for_each_result = in_fun_result&amp;lt;I, F&amp;gt;;
+
+  // (3)
+  template&amp;lt;class I, class F&amp;gt;
+  using for_each_n_result = in_fun_result&amp;lt;I, F&amp;gt;;
+}
+```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* std::move[link /reference/utility/move.md]
+
+## 概要
+* (1): イテレータと関数オブジェクトを格納する型
+* (2): [`ranges::for_each`](ranges_for_each.md)で使用するエイリアス
+* (3): [`ranges::for_each_n`](ranges_for_each_n.md)で使用するエイリアス
+
+この型は、関数が範囲と関数オブジェクトを受け取る場合に、処理した範囲の末尾と渡した関数オブジェクトを返すために使用される。
+
+標準アルゴリズム関数ではこの型を直接返す代わりに、関数毎にエイリアスを定義している。
+
+## メンバ関数
+
+| 名前                             | 説明           | 対応バージョン |
+|----------------------------------|----------------|----------------|
+| `operator in_fun_result&amp;lt;I2, F2&amp;gt;` | 変換演算子     | C++20          |
+
+変換演算子は、各テンプレートパラメーターが変換できる場合のみオーバーロード解決に参加する。
+
+## 例
+(執筆中)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_in_out_result -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_in_out_result.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_in_in_out_result.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_in_out_result.md b/reference/algorithm/ranges_in_in_out_result.md
new file mode 100644
index 000000000..1123f4952
--- /dev/null
+++ b/reference/algorithm/ranges_in_in_out_result.md
@@ -0,0 +1,92 @@
+# in_in_out_result
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  struct in_in_out_result {
+    [[no_unique_address]] I1 in1;
+    [[no_unique_address]] I2 in2;
+    [[no_unique_address]] O  out;
+
+    template&amp;lt;class II1, class II2, class OO&amp;gt;
+      requires convertible_to&amp;lt;const I1&amp;amp;, II1&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;const I2&amp;amp;, II2&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;const O&amp;amp;, OO&amp;gt;
+    constexpr operator in_in_out_result&amp;lt;II1, II2, OO&amp;gt;() const &amp;amp; {
+      return {in1, in2, out};
+    }
+
+    template&amp;lt;class II1, class II2, class OO&amp;gt;
+      requires convertible_to&amp;lt;I1, II1&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;I2, II2&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;O, OO&amp;gt;
+    constexpr operator in_in_out_result&amp;lt;II1, II2, OO&amp;gt;() &amp;amp;&amp;amp; {
+      return {std::move(in1), std::move(in2), std::move(out)};
+    }
+  };
+
+  // (2)
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using binary_transform_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  // (3)
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using merge_result  = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  // (4)
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using set_union_result  = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  // (5)
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using set_intersection_result  = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  // (6)
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using set_symmetric_difference_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+}
+```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* std::move[link /reference/utility/move.md]
+
+## 概要
+* (1): 3つのイテレータを格納する型
+* (2): [`ranges::transform`](ranges_transform.md.nolink)で使用するエイリアス
+* (2): [`ranges::merge`](ranges_merge.md)で使用するエイリアス
+* (2): [`ranges::set_union`](ranges_set_union.md)で使用するエイリアス
+* (2): [`ranges::set_intersection`](ranges_set_intersection.md)で使用するエイリアス
+* (2): [`ranges::set_symmetric_difference`](ranges_set_symmetric_difference.md)で使用するエイリアス
+
+この型は、関数が2つの入力用の範囲と出力用の範囲を受け取る場合に、それぞれ処理した範囲の末尾を返すために使用される。
+
+標準アルゴリズム関数ではこの型を直接返す代わりに、関数毎にエイリアスを定義している。
+
+## メンバ関数
+
+| 名前                                      | 説明           | 対応バージョン |
+|-------------------------------------------|----------------|----------------|
+| `operator in_in_out_result&amp;lt;II1, II2, OO&amp;gt;` | 変換演算子     | C++20          |
+
+変換演算子は、各テンプレートパラメーターが変換できる場合のみオーバーロード解決に参加する。
+
+## 例
+(執筆中)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_in_result -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_in_result.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_in_in_result.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_in_result.md b/reference/algorithm/ranges_in_in_result.md
new file mode 100644
index 000000000..40a260e79
--- /dev/null
+++ b/reference/algorithm/ranges_in_in_result.md
@@ -0,0 +1,72 @@
+# in_in_result
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;class I1, class I2&amp;gt;
+  struct in_in_result {
+    [[no_unique_address]] I1 in1;
+    [[no_unique_address]] I2 in2;
+
+    template&amp;lt;class II1, class II2&amp;gt;
+      requires convertible_to&amp;lt;const I1&amp;amp;, II1&amp;gt; &amp;amp;&amp;amp; convertible_to&amp;lt;const I2&amp;amp;, II2&amp;gt;
+    constexpr operator in_in_result&amp;lt;II1, II2&amp;gt;() const &amp;amp; {
+      return {in1, in2};
+    }
+
+    template&amp;lt;class II1, class II2&amp;gt;
+      requires convertible_to&amp;lt;I1, II1&amp;gt; &amp;amp;&amp;amp; convertible_to&amp;lt;I2, II2&amp;gt;
+    constexpr operator in_in_result&amp;lt;II1, II2&amp;gt;() &amp;amp;&amp;amp; {
+      return {std::move(in1), std::move(in2)};
+    }
+  };
+
+  // (2)
+  template&amp;lt;class I1, class I2&amp;gt;
+  using mismatch_result = in_in_result&amp;lt;I1, I2&amp;gt;;
+
+  // (3)
+  template&amp;lt;class I1, class I2&amp;gt;
+  using swap_ranges_result = in_in_result&amp;lt;I1, I2&amp;gt;;
+}
+```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* std::move[link /reference/utility/move.md]
+
+## 概要
+* (1): 2つのイテレータを格納する型
+* (2): [`ranges::mismatch`](ranges_mismatch.md)で使用するエイリアス
+* (3): [`ranges::swap_ranges`](ranges_swap_ranges.md.nolink)で使用するエイリアス
+
+この型は、関数が入力用に2つの範囲を受け取る場合に、それぞれ処理した範囲の末尾を返すために使用される。
+
+標準アルゴリズム関数ではこの型を直接返す代わりに、関数毎にエイリアスを定義している。
+
+## メンバ関数
+
+| 名前                               | 説明           | 対応バージョン |
+|------------------------------------|----------------|----------------|
+| `operator in_in_result&amp;lt;II1, II22&amp;gt;` | 変換演算子     | C++20          |
+
+変換演算子は、各テンプレートパラメーターが変換できる場合のみオーバーロード解決に参加する。
+
+## 例
+(執筆中)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_fun_result -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_out_out_result.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_in_out_out_result.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_out_out_result.md b/reference/algorithm/ranges_in_out_out_result.md
new file mode 100644
index 000000000..bf52fb647
--- /dev/null
+++ b/reference/algorithm/ranges_in_out_out_result.md
@@ -0,0 +1,72 @@
+# in_fun_result
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;class I, class O1, class O2&amp;gt;
+  struct in_out_out_result {
+    [[no_unique_address]] I  in;
+    [[no_unique_address]] O1 out1;
+    [[no_unique_address]] O2 out2;
+
+    template&amp;lt;class II, class OO1, class OO2&amp;gt;
+      requires convertible_to&amp;lt;const I&amp;amp;, II&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;const O1&amp;amp;, OO1&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;const O2&amp;amp;, OO2&amp;gt;
+    constexpr operator in_out_out_result&amp;lt;II, OO1, OO2&amp;gt;() const &amp;amp; {
+      return {in, out1, out2};
+    }
+
+    template&amp;lt;class II, class OO1, class OO2&amp;gt;
+      requires convertible_to&amp;lt;I, II&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;O1, OO1&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;O2, OO2&amp;gt;
+    constexpr operator in_out_out_result&amp;lt;II, OO1, OO2&amp;gt;() &amp;amp;&amp;amp; {
+      return {std::move(in), std::move(out1), std::move(out2)};
+    }
+  };
+
+  // (2)
+  template&amp;lt;class I, class O1, class O2&amp;gt;
+  using partition_copy_result = in_out_out_result&amp;lt;I, O1, O2&amp;gt;;
+}
+```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* std::move[link /reference/utility/move.md]
+
+## 概要
+* (1): 3つのイテレータを格納する型
+* (2): [`ranges::partition_copy`](ranges_partition_copy.md.nolink)で使用するエイリアス
+
+この型は、関数が入力用の範囲と2つの出力用の範囲を受け取る場合に、それぞれ処理した範囲の末尾を返すために使用される。
+
+標準アルゴリズム関数ではこの型を直接返す代わりに、関数毎にエイリアスを定義している。
+
+## メンバ関数
+
+| 名前                                       | 説明           | 対応バージョン |
+|--------------------------------------------|----------------|----------------|
+| `operator in_out_out_result&amp;lt;II, OO1, OO2&amp;gt;` | 変換演算子     | C++20          |
+
+変換演算子は、各テンプレートパラメーターが変換できる場合のみオーバーロード解決に参加する。
+
+## 例
+(執筆中)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_out_result -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_out_result.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_in_out_result.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_out_result.md b/reference/algorithm/ranges_in_out_result.md
new file mode 100644
index 000000000..c2bf2f929
--- /dev/null
+++ b/reference/algorithm/ranges_in_out_result.md
@@ -0,0 +1,142 @@
+# in_out_result
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;class I, class O&amp;gt;
+  struct in_out_result {
+    [[no_unique_address]] I in;
+    [[no_unique_address]] O out;
+
+    template&amp;lt;class I2, class O2&amp;gt;
+      requires convertible_to&amp;lt;const I&amp;amp;, I2&amp;gt; &amp;amp;&amp;amp; convertible_to&amp;lt;const O&amp;amp;, O2&amp;gt;
+    constexpr operator in_out_result&amp;lt;I2, O2&amp;gt;() const &amp;amp; {
+      return {in, out};
+    }
+
+    template&amp;lt;class I2, class O2&amp;gt;
+      requires convertible_to&amp;lt;I, I2&amp;gt; &amp;amp;&amp;amp; convertible_to&amp;lt;O, O2&amp;gt;
+    constexpr operator in_out_result&amp;lt;I2, O2&amp;gt;() &amp;amp;&amp;amp; {
+      return {std::move(in), std::move(out)};
+    }
+  };
+
+  // (2)
+  template&amp;lt;class I, class O&amp;gt;
+  using copy_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (3)
+  template&amp;lt;class I, class O&amp;gt;
+  using copy_n_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (4)
+  template&amp;lt;class I, class O&amp;gt;
+  using copy_if_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (5)
+  template&amp;lt;class I, class O&amp;gt;
+  using copy_backward_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (6)
+  template&amp;lt;class I, class O&amp;gt;
+  using move_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (7)
+  template&amp;lt;class I, class O&amp;gt;
+  using move_backward_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (8)
+  template&amp;lt;class I, class O&amp;gt;
+  using unary_transform_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (9)
+  template&amp;lt;class I, class O&amp;gt;
+  using replace_copy_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (10)
+  template&amp;lt;class I, class O&amp;gt;
+  using replace_copy_if_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (11)
+  template&amp;lt;class I, class O&amp;gt;
+  using remove_copy_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (12)
+  template&amp;lt;class I, class O&amp;gt;
+  using remove_copy_if_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (13)
+  template&amp;lt;class I, class O&amp;gt;
+  using unique_copy_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (14)
+  template&amp;lt;class I, class O&amp;gt;
+  using reverse_copy_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (15)
+  template&amp;lt;class I, class O&amp;gt;
+  using rotate_copy_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (16)
+  template&amp;lt;class I, class O&amp;gt;
+  using partial_sort_copy_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  // (17)
+  template&amp;lt;class I, class O&amp;gt;
+  using set_difference_result = in_out_result&amp;lt;I, O&amp;gt;;
+}
+```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* std::move[link /reference/utility/move.md]
+
+## 概要
+* (1): 2つのイテレータを格納する型
+* (2): [`ranges::copy`](ranges_copy.md.nolink)で使用するエイリアス
+* (3): [`ranges::copy_n`](ranges_copy_n.md.nolink)で使用するエイリアス
+* (4): [`ranges::copy_if`](ranges_copy_if.md.nolink)で使用するエイリアス
+* (5): [`ranges::copy_backward`](ranges_copy_backward.md.nolink)で使用するエイリアス
+* (6): [`ranges::move`](ranges_move.md.nolink)で使用するエイリアス
+* (7): [`ranges::move_backward`](ranges_move_backward.md.nolink)で使用するエイリアス
+* (8): [`ranges::unary_transform`](ranges_unary_transform.md.nolink)で使用するエイリアス
+* (9): [`ranges::replace_copy`](ranges_replace_copy.md.nolink)で使用するエイリアス
+* (10): [`ranges::replace_copy_if`](ranges_replace_copy_if.md.nolink)で使用するエイリアス
+* (11): [`ranges::remove_copy`](ranges_remove_copy.md.nolink)で使用するエイリアス
+* (12): [`ranges::remove_copy_if`](ranges_remove_copy_if.md.nolink)で使用するエイリアス
+* (13): [`ranges::unique_copy`](ranges_unique_copy.md.nolink)で使用するエイリアス
+* (14): [`ranges::reverse_copy`](ranges_reverse_copy.md.nolink)で使用するエイリアス
+* (15): [`ranges::rotate_copy`](ranges_rotate_copy.md.nolink)で使用するエイリアス
+* (16): [`ranges::partial_sort_copy`](ranges_partial_sort_copy.md)で使用するエイリアス
+* (17): [`ranges::set_difference`](ranges_set_difference.md)で使用するエイリアス
+
+この型は、関数が入力用と出力用に範囲を受け取る場合に、それぞれ処理した範囲の末尾を返すために使用される。
+
+標準アルゴリズム関数ではこの型を直接返す代わりに、関数毎にエイリアスを定義している。
+
+## メンバ関数
+
+| 名前                             | 説明           | 対応バージョン |
+|----------------------------------|----------------|----------------|
+| `operator in_out_result&amp;lt;I2, O2&amp;gt;` | 変換演算子     | C++20          |
+
+変換演算子は、各テンプレートパラメーターが変換できる場合のみオーバーロード解決に参加する。
+
+## 例
+(執筆中)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_merge.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
index 16bcabc78..239840117 100644
--- a/reference/algorithm/ranges_merge.md
+++ b/reference/algorithm/ranges_merge.md
@@ -6,9 +6,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I1, class I2, class O&amp;gt;
-  using merge_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
-
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
@@ -20,7 +17,7 @@ namespace std::ranges {
   constexpr merge_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt; merge(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (2)
 }
 ```
-* in_in_out_result[link in_in_out_result.md.nolink]
+* merge_result[link in_in_out_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -48,8 +45,6 @@ namespace std::ranges {
 
 
 ## 戻り値
-次のメンバをもつtuple-likeオブジェクト。
-
 ```cpp
 merge_result {
   .in1 = last1,
@@ -57,6 +52,7 @@ merge_result {
   .out = result + (last1 - first1) + (last2 - first2),
 }
 ```
+* merge_result[link in_in_out_result.md]
 
 ## 計算量
 `N = (last1 - first1) + (last2 - first2)`であるとして最大で、N - 1回比較する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_fun_result -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_max_result.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_min_max_result.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_max_result.md b/reference/algorithm/ranges_min_max_result.md
new file mode 100644
index 000000000..652228c85
--- /dev/null
+++ b/reference/algorithm/ranges_min_max_result.md
@@ -0,0 +1,72 @@
+# in_fun_result
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;class T&amp;gt;
+  struct min_max_result {
+    [[no_unique_address]] T min;
+    [[no_unique_address]] T max;
+
+    template&amp;lt;class T2&amp;gt;
+      requires convertible_to&amp;lt;const T&amp;amp;, T2&amp;gt;
+    constexpr operator min_max_result&amp;lt;T2&amp;gt;() const &amp;amp; {
+      return {min, max};
+    }
+
+    template&amp;lt;class T2&amp;gt;
+      requires convertible_to&amp;lt;T, T2&amp;gt;
+    constexpr operator min_max_result&amp;lt;T2&amp;gt;() &amp;amp;&amp;amp; {
+      return {std::move(min), std::move(max)};
+    }
+  };
+
+  // (2)
+  template&amp;lt;class T&amp;gt;
+  using minmax_result = min_max_result&amp;lt;T&amp;gt;;
+
+  // (3)
+  template&amp;lt;class I&amp;gt;
+  using minmax_element_result = min_max_result&amp;lt;I&amp;gt;;
+}
+```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* std::move[link /reference/utility/move.md]
+
+## 概要
+* (1): 最小値と最大値、またはそれらのイテレータを格納する型
+* (2): [`ranges::minmax`](ranges_minmax.md)で使用するエイリアス
+* (3): [`ranges::minmax_element`](ranges_fominmax_element.md)で使用するエイリアス
+
+この型は、関数が最小値と最大値またはそれらのイテレータを返す場合に使用される。
+
+標準アルゴリズム関数ではこの型を直接返す代わりに、関数毎にエイリアスを定義している。
+
+## メンバ関数
+
+| 名前                          | 説明           | 対応バージョン |
+|-------------------------------|----------------|----------------|
+| `operator min_max_result&amp;lt;T2&amp;gt;` | 変換演算子     | C++20          |
+
+変換演算子は、各テンプレートパラメーターが変換できる場合のみオーバーロード解決に参加する。
+
+## 例
+(執筆中)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_minmax.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax.md b/reference/algorithm/ranges_minmax.md
index ab8178e25..7cb63e129 100644
--- a/reference/algorithm/ranges_minmax.md
+++ b/reference/algorithm/ranges_minmax.md
@@ -7,9 +7,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T&amp;gt;
-  using minmax_result = min_max_result&amp;lt;T&amp;gt;;
-
   template&amp;lt;class T, class Proj = identity,
            indirect_strict_weak_order&amp;lt;projected&amp;lt;const T*, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
   constexpr minmax_result&amp;lt;const T&amp;amp;&amp;gt; minmax(const T&amp;amp; a, const T&amp;amp; b, Comp comp = {}, Proj proj = {});
@@ -24,7 +21,7 @@ namespace std::ranges {
   constexpr minmax_result&amp;lt;range_value_t&amp;lt;R&amp;gt;&amp;gt; minmax(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
 }
 ```
-* min_max_result[link min_max_result.md.nolink]
+* minmax_result[link min_max_result.md]
 * identity[link /reference/functional/identity.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * projected[link /reference/iterator/projected.md]
@@ -39,7 +36,13 @@ namespace std::ranges {
 同じ型の2つの値、もしくは範囲によるN個の値のうち、最小値と最大値の組を取得する。
 
 ## 戻り値
-第1メンバ`min`が最小値、第2メンバ`max`が最大値となるtuple-likeオブジェクト([`min_max_result`](min_max_result.md.nolink))
+```cpp
+minmax_result {
+  .min = 最小値,
+  .max = 最大値,
+}
+```
+* minmax_result[link min_max_result.md]
 
 それぞれ、比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって判断された最初の値となる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
index 5914791fd..d2131b6a4 100644
--- a/reference/algorithm/ranges_minmax_element.md
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -6,19 +6,16 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class T&amp;gt;
-  using minmax_result = min_max_result&amp;lt;T&amp;gt;;
-
   template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_result&amp;lt;I&amp;gt; minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
+  constexpr minmax_element_result&amp;lt;I&amp;gt; minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
 
   template&amp;lt;forward_range R, class Proj = identity,
            indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr minmax_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; minmax_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
+  constexpr minmax_element_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; minmax_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
 }
 ```
-* min_max_result[link min_max_result.md.nolink]
+* minmax_element_result[link min_max_result.md]
 * forward_iterator[link /reference/iterator/forward_iterator.md]
 * identity[link /reference/functional/identity.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
@@ -35,8 +32,13 @@ namespace std::ranges {
 
 
 ## 戻り値
-
-第1メンバ`min`が最小の要素、第2メンバ`max`が最大の要素をそれぞれ指すイテレータとなるtuple-likeオブジェクト([`min_max_result`](min_max_result.md.nolink))
+```cpp
+minmax_element_result {
+  .min = 最小の要素を指すイテレータ,
+  .max = 最大の要素を指すイテレータ,
+}
+```
+* minmax_element_result[link min_max_result.md]
 
 それぞれ、比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって判断し、同じ値の要素が複数ある場合は、最小の要素は最初の要素、最大の要素は最後の要素となる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_mismatch.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
index 923fd5530..c25f09b6c 100644
--- a/reference/algorithm/ranges_mismatch.md
+++ b/reference/algorithm/ranges_mismatch.md
@@ -6,19 +6,16 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I1, class I2&amp;gt;
-  using mismatch_result = in_in_result&amp;lt;I1, I2&amp;gt;; // (1)
-
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;I1, I2&amp;gt; mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                      // (2)
+  constexpr mismatch_result&amp;lt;I1, I2&amp;gt; mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                      // (1)
 
   template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; mismatch(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    // (3)
+  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; mismatch(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});    // (2)
 }
 ```
-* in_fun_result[link ranges_in_fun_result.md.nolink]
+* mismatch_result[link ranges_in_in_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * ranges::equal_to[link /reference/functional/ranges_equal_to.md]
@@ -37,16 +34,18 @@ namespace std::ranges {
 ## 概要
 2つのシーケンスが一致していない場所を検索する。
 
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
 ## 戻り値
-戻り値の型 `mismatch_result` は2つのイテレータからなるtuple-likeな型である。
 
 `[first1,last1)` 内にあるイテレータ `i` と、`j == first2 + (i - first1)` であるイテレータ `j` について、
 
 - `j`が範囲`[first2, last2)`に含まれており、
 - `!(*i == *j)` もしくは
-- [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj1, *i), `[`invoke`](/reference/functional/invoke.md)`(proj2, *j)) == false` であるような、最初のイテレータのペア `{i, j}` を返す。
+- [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj1, *i), `[`invoke`](/reference/functional/invoke.md)`(proj2, *j)) == false` であるような、最初のイテレータのペア [`mismatch_result`](ranges_in_in_result.md)`{ .in1 = i, .in2 = j }` を返す。
 
-そのようなイテレータが見つからなかった場合は `{last1, first2 + (last1 - first1)}` を返す。
+そのようなイテレータが見つからなかった場合は [`mismatch_result`](ranges_in_in_result.md)`{ .in1 = last1, .in2 = first2 + (last1 - first1)}` を返す。
 
 ## 計算量
 最大で `last1 - first1` 回の対応する述語が適用される。
@@ -110,7 +109,7 @@ mismatch value: (end,2)
 struct mismatch_impl {
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr ranges::mismatch_result&amp;lt;I1, I2&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
+  constexpr mismatch_result&amp;lt;I1, I2&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const {
     for ( ; first1 != last1 &amp;amp;&amp;amp; first != last2; ++first1, ++first2)
       if (!bool(invoke(pred, invoke(proj1, *first1), invoke(proj2, *first2))))
         return {first1, first2};
@@ -126,7 +125,7 @@ struct mismatch_impl {
 
 inline constexpr mismatch_impl mismatch;
 ```
-* in_fun_result[link ranges_in_fun_result.md.nolink]
+* mismatch_result[link ranges_in_in_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * ranges::equal_to[link /reference/functional/ranges_equal_to.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>next_permutation -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_next_permutation.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_next_permutation.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_next_permutation.md b/reference/algorithm/ranges_next_permutation.md
index 94a95dbda..9185d950e 100644
--- a/reference/algorithm/ranges_next_permutation.md
+++ b/reference/algorithm/ranges_next_permutation.md
@@ -7,9 +7,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I&amp;gt;
-  using next_permutation_result = in_found_result&amp;lt;I&amp;gt;;
-
   template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
   constexpr next_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
@@ -19,7 +16,7 @@ namespace std::ranges {
   constexpr next_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
 }
 ```
-* in_found_result[link in_found_result.md.nolink]
+* next_permutation_result[link in_found_result.md]
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * ranges::less[link /reference/functional/ranges_less.md]
@@ -44,10 +41,14 @@ namespace std::ranges {
 辞書順による次の順列とは、現在の順列（`[first, last)`）よりも（上記の意味の順序で）大きい順列のうち取り得る最小のもののことである。
 
 ## 戻り値
-次のメンバをもつtuple-lileオブジェクト。
 
-1. `in`: `last`
-2. `found`: 次の順列が存在する場合は`true`、そうでなければ`false`
+```cpp
+next_permutation_result {
+  .in = last,
+  .found = 次の順列が存在する場合は true、そうでなければ false,
+}
+```
+* next_permutation_result[link in_found_result.md]
 
 ## 計算量
 高々`(last - first)/2`回の要素の交換
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sort_copy -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_partial_sort_copy.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_partial_sort_copy.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_partial_sort_copy.md b/reference/algorithm/ranges_partial_sort_copy.md
index 9c7922ca3..0842b59ba 100644
--- a/reference/algorithm/ranges_partial_sort_copy.md
+++ b/reference/algorithm/ranges_partial_sort_copy.md
@@ -6,9 +6,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I, class O&amp;gt;
-  using partial_sort_copy_result = in_out_result&amp;lt;I, O&amp;gt;;
-
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, random_access_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_copyable&amp;lt;I1, I2&amp;gt; &amp;amp;&amp;amp; sortable&amp;lt;I2, Comp, Proj2&amp;gt; &amp;amp;&amp;amp;
@@ -25,7 +22,7 @@ namespace std::ranges {
     partial_sort_copy(R1&amp;amp;&amp;amp; r, R2&amp;amp;&amp;amp; result_r, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                              // (2)
 }
 ```
-* in_out_result[link in_out_result.md.nolink]
+* partial_sort_copy_result[link in_out_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * random_access_iterator[link /reference/iterator/random_access_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
@@ -53,7 +50,13 @@ namespace std::ranges {
 
 
 ## 戻り値
-`{last, result_first + N}`
+```cpp
+partial_sort_copy_result {
+  .in = last,
+  .out = result_first + N
+}
+```
+* partial_sort_copy_result[link in_out_result.md]
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>prev_permutation -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_prev_permutation.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_prev_permutation.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_prev_permutation.md b/reference/algorithm/ranges_prev_permutation.md
index 73dd7d9d1..08fe16022 100644
--- a/reference/algorithm/ranges_prev_permutation.md
+++ b/reference/algorithm/ranges_prev_permutation.md
@@ -6,9 +6,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I&amp;gt;
-  using prev_permutation_result = in_found_result&amp;lt;I&amp;gt;;
-
   template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
   constexpr prev_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
@@ -18,7 +15,7 @@ namespace std::ranges {
   constexpr prev_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
 }
 ```
-* in_found_result[link in_found_result.md.nolink]
+* prev_permutation_result[link in_found_result.md]
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * ranges::less[link /reference/functional/ranges_less.md]
@@ -40,10 +37,13 @@ namespace std::ranges {
 比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって辞書順に並んでいる全ての順列の集合があると仮定すると、前の順列が発見される。
 
 ## 戻り値
-次のメンバをもつtuple-lileオブジェクト。
-
-1. `in`: `last`
-2. `found`: 前の順列が存在する場合は`true`、そうでなければ`false`
+```cpp
+prev_permutation_result {
+  .in = last,
+  .found = 前の順列が存在する場合は true、そうでなければ false,
+}
+```
+* prev_permutation_result[link in_found_result.md]
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_difference.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_set_difference.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_difference.md b/reference/algorithm/ranges_set_difference.md
index 7f78332e5..3541b5802 100644
--- a/reference/algorithm/ranges_set_difference.md
+++ b/reference/algorithm/ranges_set_difference.md
@@ -6,9 +6,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I, class O&amp;gt;
-  using set_union_result = in_out_result&amp;lt;I, O&amp;gt;;
-
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
@@ -22,7 +19,7 @@ namespace std::ranges {
     set_difference(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
 }
 ```
-* in_out_result[link in_out_result.md.nolink]
+* set_difference_result[link in_out_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -49,14 +46,13 @@ namespace std::ranges {
 
 
 ## 戻り値
-次のメンバをもつtuple-likeオブジェクト。
-
 ```cpp
-set_union_result {
+set_difference_result {
   .in  = last1,
   .out = result_last,
 }
 ```
+* set_difference_result[link in_out_result.md]
 
 ただし、`result_last` は構築された範囲の終端。 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_intersection.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_set_intersection.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_intersection.md b/reference/algorithm/ranges_set_intersection.md
index f62d384e3..548ad8cab 100644
--- a/reference/algorithm/ranges_set_intersection.md
+++ b/reference/algorithm/ranges_set_intersection.md
@@ -6,9 +6,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I1, class I2, class O&amp;gt;
-  using set_intersection_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
-
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
@@ -22,7 +19,7 @@ namespace std::ranges {
     set_intersection(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                          // (2)
 }
 ```
-* in_in_out_result[link in_in_out_result.md.nolink]
+* set_intersection_result[link in_in_out_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -52,12 +49,13 @@ namespace std::ranges {
 次のメンバをもつtuple-likeオブジェクト。
 
 ```cpp
-set_union_result {
+set_intersection_result {
   .in1 = last1,
   .in2 = last2,
   .out = result_last,
 }
 ```
+* set_intersection_result[link in_in_out_result.md]
 
 ただし、`result_last` は構築された範囲の終端。 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_symmetric_difference.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_set_symmetric_difference.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_symmetric_difference.md b/reference/algorithm/ranges_set_symmetric_difference.md
index dfe6bc611..2635bdf68 100644
--- a/reference/algorithm/ranges_set_symmetric_difference.md
+++ b/reference/algorithm/ranges_set_symmetric_difference.md
@@ -22,7 +22,7 @@ namespace std::ranges {
     set_symmetric_difference(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
 }
 ```
-* in_in_out_result[link in_in_out_result.md.nolink]
+* set_symmetric_difference_result[link in_in_out_result.md] 
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -49,15 +49,14 @@ namespace std::ranges {
 
 
 ## 戻り値
-次のメンバをもつtuple-likeオブジェクト。
-
 ```cpp
-set_union_result {
+set_symmetric_difference_result {
   .in1 = last1,
   .in2 = last2,
   .out = result_last,
 }
 ```
+* set_symmetric_difference_result[link in_in_out_result.md] 
 
 ただし、`result_last` は構築された範囲の終端。 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- 戻り値型の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_union.html"/>
      <id>d6071adcdc9fefae160a1d8cfc7ac6638c2736d8:reference/algorithm/ranges_set_union.md</id>
      <updated>2022-03-21T05:56:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_union.md b/reference/algorithm/ranges_set_union.md
index 84673cc4e..6133663ef 100644
--- a/reference/algorithm/ranges_set_union.md
+++ b/reference/algorithm/ranges_set_union.md
@@ -6,9 +6,6 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;class I1, class I2, class O&amp;gt;
-  using set_union_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
-
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
            class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
@@ -22,7 +19,7 @@ namespace std::ranges {
     set_union(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                           // (2)
 }
 ```
-* in_in_out_result[link in_in_out_result.md.nolink]
+* set_union_result[link in_in_out_result.md]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
@@ -48,8 +45,6 @@ namespace std::ranges {
 
 
 ## 戻り値
-次のメンバをもつtuple-likeオブジェクト。
-
 ```cpp
 set_union_result {
   .in1 = last1,
@@ -57,6 +52,7 @@ set_union_result {
   .out = result_last,
 }
 ```
+* set_union_result[link in_in_out_result.md]
 
 ただし、`result_last` は構築された範囲の終端。 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- 例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>756792647298addf922812967a445b7cfac9ac0c:reference/algorithm/ranges_equal_range.md</id>
      <updated>2022-03-21T03:01:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index 83e73b1a4..0905144fb 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -55,6 +55,7 @@ int main()
   std::vector&amp;lt;int&amp;gt; v2  = {1, 4, 2, 5};
 
   std::ranges::sort(v);
+  std::ranges::sort(v2);
 
   auto result  = std::ranges::equal_range(v, 3);
   auto result2 = std::ranges::equal_range(v2, 3);
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>04c97bbdab986678ffd15cf53cb0337400a3febe:reference/algorithm/ranges_merge.md</id>
      <updated>2022-03-21T02:35:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
index 83ecc4a2b..16bcabc78 100644
--- a/reference/algorithm/ranges_merge.md
+++ b/reference/algorithm/ranges_merge.md
@@ -20,7 +20,7 @@ namespace std::ranges {
   constexpr merge_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt; merge(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (2)
 }
 ```
-* in_in_out_result[link in_in_out_result.md]
+* in_in_out_result[link in_in_out_result.md.nolink]
 * input_iterator[link /reference/iterator/input_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- 名前空間を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_inplace_merge.html"/>
      <id>01c4a10761bfc4585b3d0125afebcb3f273b986c:reference/algorithm/ranges_inplace_merge.md</id>
      <updated>2022-03-21T02:34:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_inplace_merge.md b/reference/algorithm/ranges_inplace_merge.md
index 4b0fad40d..3ea223411 100644
--- a/reference/algorithm/ranges_inplace_merge.md
+++ b/reference/algorithm/ranges_inplace_merge.md
@@ -5,7 +5,7 @@
 * cpp20[meta cpp]
 
 ```cpp
-namespace std {
+namespace std::ranges {
   template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
     requires sortable&amp;lt;I, Comp, Proj&amp;gt;
   I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_sorted_until -- 名前空間を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_sorted_until.html"/>
      <id>01c4a10761bfc4585b3d0125afebcb3f273b986c:reference/algorithm/ranges_is_sorted_until.md</id>
      <updated>2022-03-21T02:34:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_sorted_until.md b/reference/algorithm/ranges_is_sorted_until.md
index 56950e369..7df2acc3f 100644
--- a/reference/algorithm/ranges_is_sorted_until.md
+++ b/reference/algorithm/ranges_is_sorted_until.md
@@ -5,7 +5,7 @@
 * cpp20[meta cpp]
 
 ```cpp
-namespace std {
+namespace std::ranges {
   template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity,
            indirect_strict_weak_order&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
   constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ソート済み構造に対する集合演算の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>da057c719dbd6e3002a0463f5e50b601b114d868:reference/algorithm.md</id>
      <updated>2022-03-21T02:34:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 3917d36fe..f8e74ad2d 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -329,11 +329,11 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`set_difference`](algorithm/set_difference.md)     | 2つのソート済み範囲の差集合を得る | |
 | [`set_symmetric_difference`](algorithm/set_symmetric_difference.md) | 2つのソート済み範囲の対称差集合を得る | |
 | [`includes`](algorithm/includes.md) | 2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する | |
-| [`ranges::set_union`](algorithm/ranges_set_union.md.nolink)                               | 2つのソート済み範囲の和集合を得る                                                           | C++20 |
-| [`ranges::set_intersection`](algorithm/ranges_set_intersection.md.nolink)                 | 2つのソート済み範囲の積集合を得る                                                           | C++20 |
-| [`ranges::set_difference`](algorithm/ranges_set_difference.md.nolink)                     | 2つのソート済み範囲の差集合を得る                                                           | C++20 |
-| [`ranges::set_symmetric_difference`](algorithm/ranges_set_symmetric_difference.md.nolink) | 2つのソート済み範囲の対称差集合を得る                                                       | C++20 |
-| [`ranges::includes`](algorithm/ranges_includes.md.nolink)                                 | 2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する | C++20 |
+| [`ranges::set_union`](algorithm/ranges_set_union.md)                               | 2つのソート済み範囲の和集合を得る                                                           | C++20 |
+| [`ranges::set_intersection`](algorithm/ranges_set_intersection.md)                 | 2つのソート済み範囲の積集合を得る                                                           | C++20 |
+| [`ranges::set_difference`](algorithm/ranges_set_difference.md)                     | 2つのソート済み範囲の差集合を得る                                                           | C++20 |
+| [`ranges::set_symmetric_difference`](algorithm/ranges_set_symmetric_difference.md) | 2つのソート済み範囲の対称差集合を得る                                                       | C++20 |
+| [`ranges::includes`](algorithm/ranges_includes.md)                                 | 2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する | C++20 |
 
 ### ヒープ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>includes -- ソート済み構造に対する集合演算の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_includes.html"/>
      <id>da057c719dbd6e3002a0463f5e50b601b114d868:reference/algorithm/ranges_includes.md</id>
      <updated>2022-03-21T02:34:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_includes.md b/reference/algorithm/ranges_includes.md
new file mode 100644
index 000000000..47f4fdbcb
--- /dev/null
+++ b/reference/algorithm/ranges_includes.md
@@ -0,0 +1,78 @@
+# includes
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;input_range R1, input_range R2, class Proj1 = identity, class Proj2 = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool ranges::includes(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                 // (2)
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+2つのソート済み範囲において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 戻り値
+`[first2,last2)` が `empty` であるか、`[first2,last2)` の全ての要素が `[first1,last1)` に含まれている場合は `true`、そうでない場合は `false` を返す。
+
+
+## 計算量
+最大で `2 * ((last1 - first1) + (last2 - first2)) - 1` 回比較する
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;set&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::set&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::set&amp;lt;int&amp;gt; b = {2, 4, 6};
+  std::set&amp;lt;int&amp;gt; c = {2, 4, 7};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+
+  std::cout &amp;lt;&amp;lt; std::ranges::includes(a, b) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::includes(a, c) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::includes[color ff0000]
+
+### 出力
+```
+true
+false
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_difference -- ソート済み構造に対する集合演算の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_difference.html"/>
      <id>da057c719dbd6e3002a0463f5e50b601b114d868:reference/algorithm/ranges_set_difference.md</id>
      <updated>2022-03-21T02:34:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_difference.md b/reference/algorithm/ranges_set_difference.md
new file mode 100644
index 000000000..7f78332e5
--- /dev/null
+++ b/reference/algorithm/ranges_set_difference.md
@@ -0,0 +1,117 @@
+# set_difference
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I, class O&amp;gt;
+  using set_union_result = in_out_result&amp;lt;I, O&amp;gt;;
+
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr set_difference_result&amp;lt;I1, O&amp;gt;
+    set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr set_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, O&amp;gt;
+    set_difference(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+}
+```
+* in_out_result[link in_out_result.md.nolink]
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* mergeable[link /reference/iterator/mergeable.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+
+## 概要
+2つのソート済み範囲の差集合を得る
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 事前条件
+結果の範囲は両方の入力の範囲と重なっていてはならない。
+
+
+## 効果
+`[first1,last1)` から、`[first2,last2)` に存在していない要素を `result` へコピーする。構築された範囲はソートされている。
+
+
+## 戻り値
+次のメンバをもつtuple-likeオブジェクト。
+
+```cpp
+set_union_result {
+  .in  = last1,
+  .out = result_last,
+}
+```
+
+ただし、`result_last` は構築された範囲の終端。 
+
+
+## 計算量
+最大で `2 * ((last1 - first1) + (last2 - first2)) - 1` 回の比較を行う
+
+
+## 備考
+`[first1,last1)` が `m` 個、`[first2,last2)` が `n` 個の等価な要素を含んでいる場合、`[first1,last1)` から最後の [`max`](max.md)`(m-n, 0)` 要素が出力の範囲へコピーされる。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;set&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+int main()
+{
+  std::multiset&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::multiset&amp;lt;int&amp;gt; b = {2, 3, 4};
+  std::multiset&amp;lt;int&amp;gt; result;
+
+  // a - bの差集合を作る
+  std::ranges::set_difference(a, b, std::inserter(result, result.end()));
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::set_difference[color ff0000]
+* std::multiset[link /reference/set/multiset.md]
+* begin()[link /reference/set/set/begin.md]
+* end()[link /reference/set/set/end.md]
+* std::inserter[link /reference/iterator/inserter.md]
+
+### 出力
+```
+1
+5
+6
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_intersection -- ソート済み構造に対する集合演算の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_intersection.html"/>
      <id>da057c719dbd6e3002a0463f5e50b601b114d868:reference/algorithm/ranges_set_intersection.md</id>
      <updated>2022-03-21T02:34:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_intersection.md b/reference/algorithm/ranges_set_intersection.md
new file mode 100644
index 000000000..f62d384e3
--- /dev/null
+++ b/reference/algorithm/ranges_set_intersection.md
@@ -0,0 +1,115 @@
+# set_intersection
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using set_intersection_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr set_intersection_result&amp;lt;I1, I2, O&amp;gt;
+    set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (1)
+
+  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr set_intersection_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
+    set_intersection(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                          // (2)
+}
+```
+* in_in_out_result[link in_in_out_result.md.nolink]
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* mergeable[link /reference/iterator/mergeable.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+2つのソート済み範囲の積集合を得る
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 事前条件
+結果の範囲は両方の入力の範囲と重なっていてはならない。
+
+
+## 効果
+２つの範囲からソート済みの intersection を構築する。つまり、両方の範囲のみにある要素の集合を構築する。
+
+
+## 戻り値
+次のメンバをもつtuple-likeオブジェクト。
+
+```cpp
+set_union_result {
+  .in1 = last1,
+  .in2 = last2,
+  .out = result_last,
+}
+```
+
+ただし、`result_last` は構築された範囲の終端。 
+
+## 計算量
+最大で `2 * ((last1 - first1) + (last2 - first2)) - 1` 回の比較を行う
+
+
+## 備考
+`[first1,last1)` が `m` 個、`[first2,last2)` が `n` 個の等価な要素を含んでいる場合、`[first1,last1)` から最初の [`min`](min.md)`(m, n)` 要素が出力の範囲へ順番にコピーされる。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;set&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+int main()
+{
+  std::multiset&amp;lt;int&amp;gt; a = {1, 2, 3, 4};
+  std::multiset&amp;lt;int&amp;gt; b = {4, 5, 6, 2};
+  std::multiset&amp;lt;int&amp;gt; result;
+
+  // aとbの積集合を作る
+  std::set_intersection(a, b, std::inserter(result, result.end()));
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::set_intersection[color ff0000]
+* std::multiset[link /reference/set/multiset.md]
+* end()[link /reference/set/set/end.md]
+* std::inserter[link /reference/iterator/inserter.md]
+
+### 出力
+```
+2
+4
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_symmetric_difference -- ソート済み構造に対する集合演算の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_symmetric_difference.html"/>
      <id>da057c719dbd6e3002a0463f5e50b601b114d868:reference/algorithm/ranges_set_symmetric_difference.md</id>
      <updated>2022-03-21T02:34:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_symmetric_difference.md b/reference/algorithm/ranges_set_symmetric_difference.md
new file mode 100644
index 000000000..dfe6bc611
--- /dev/null
+++ b/reference/algorithm/ranges_set_symmetric_difference.md
@@ -0,0 +1,123 @@
+# set_symmetric_difference
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using set_symmetric_difference_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr set_symmetric_difference_result&amp;lt;I1, I2, O&amp;gt;
+    set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr set_symmetric_difference_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
+    set_symmetric_difference(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+}
+```
+* in_in_out_result[link in_in_out_result.md.nolink]
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* mergeable[link /reference/iterator/mergeable.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+2つのソート済み範囲の対称差集合、すなわち2つの範囲の共通しない要素からなる集合を得る。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 事前条件
+結果の範囲は両方の入力の範囲と重なっていてはならない。
+
+
+## 効果
+`[first1,last1)` から `[first2,last2)` に存在していない要素と、`[first2,last2)` から `[first2,last2)` に存在していない要素を `result` へコピーする。構築された要素はソートされている。
+
+
+## 戻り値
+次のメンバをもつtuple-likeオブジェクト。
+
+```cpp
+set_union_result {
+  .in1 = last1,
+  .in2 = last2,
+  .out = result_last,
+}
+```
+
+ただし、`result_last` は構築された範囲の終端。 
+
+
+## 計算量
+最大で `2 * ((last1 - first1) + (last2 - first2)) - 1` 回の比較を行う
+
+
+## 備考
+`[first1,last1)` が `m` 個、`[first2,last2)` が `n` 個の等価な要素を含んでいる場合、
+
+- `m &amp;gt; n` なら `[first1,last1)` から最後の `m-n` 個の要素を出力の範囲にコピーする。
+- `n &amp;gt; m` なら `[first2,last2)` から最後の `n-m` 個の要素を出力の範囲にコピーする。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;set&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+int main()
+{
+  std::multiset&amp;lt;int&amp;gt; a = {1, 2, 3, 4, 5, 6};
+  std::multiset&amp;lt;int&amp;gt; b = {2, 3, 4, 7, 8};
+  std::multiset&amp;lt;int&amp;gt; result;
+
+  // 重ならない要素からなる集合を作る
+  std::set_symmetric_difference(a, b, std::inserter(result, result.end()));
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::set_symmetric_difference[color ff0000]
+* std::multiset[link /reference/set/multiset.md]
+* begin()[link /reference/set/set/begin.md]
+* end()[link /reference/set/set/end.md]
+* std::inserter[link /reference/iterator/inserter.md]
+
+### 出力
+```
+1
+5
+6
+7
+8
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set_union -- ソート済み構造に対する集合演算の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_set_union.html"/>
      <id>da057c719dbd6e3002a0463f5e50b601b114d868:reference/algorithm/ranges_set_union.md</id>
      <updated>2022-03-21T02:34:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_set_union.md b/reference/algorithm/ranges_set_union.md
new file mode 100644
index 000000000..84673cc4e
--- /dev/null
+++ b/reference/algorithm/ranges_set_union.md
@@ -0,0 +1,116 @@
+# set_union
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using set_union_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr set_union_result&amp;lt;I1, I2, O&amp;gt;
+    set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});   // (1)
+
+  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr set_union_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt;
+    set_union(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                           // (2)
+}
+```
+* in_in_out_result[link in_in_out_result.md.nolink]
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* mergeable[link /reference/iterator/mergeable.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+2つのソート済み範囲の和集合を得る
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 事前条件
+結果の範囲は両方の入力の範囲と重なっていてはならない。
+
+
+## 効果
+２つの範囲からソート済みの union を構築する。つまり、片方または両方の範囲にある要素の集合を構築する。
+
+
+## 戻り値
+次のメンバをもつtuple-likeオブジェクト。
+
+```cpp
+set_union_result {
+  .in1 = last1,
+  .in2 = last2,
+  .out = result_last,
+}
+```
+
+ただし、`result_last` は構築された範囲の終端。 
+
+## 計算量
+最大で `2 * ((last1 - first1) + (last2 - first2)) - 1` 回の比較を行う
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;set&amp;gt;
+#include &amp;lt;list&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;ranges&amp;gt;
+
+int main()
+{
+  std::list&amp;lt;int&amp;gt; a = {1, 2, 3, 4};
+  std::multiset&amp;lt;int&amp;gt; b = {4, 5, 6, 2};
+  std::vector&amp;lt;int&amp;gt; result;
+
+  // aとbの和集合を作る
+  std::ranges::set_union(a, b, std::inserter(result, std::ranges::end(result)));
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::set_union[color ff0000]
+* std::multiset[link /reference/set/multiset.md]
+* std::inserter[link /reference/iterator/inserter.md]
+* std::ranges::end[link /reference/ranges/end.md]
+
+### 出力
+```
+1
+2
+3
+4
+5
+6
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>