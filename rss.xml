<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-01-09T11:54:26.633587</updated>
  <id>d4a27ec7-ebe4-41ae-b9cc-fc54789d5c9d</id>

  
    <entry>
      <title>可変サイズをもつコンテナのconstexpr化 [P0784R7] -- タイポの修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>b84a2272d7ee6558d4555cc247434dff541bd4a4:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2025-01-09T20:51:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index d6eb1a19e..a693e3c5b 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -260,7 +260,7 @@ constexpr int g() {
 
 ## この機能が必要になった背景・経緯
 
-`std::vector`をはじめとする可変サイズのコンテナは実行時に非常に有用であるため、同様に定数式においても有用である可能性があり、その必要性がC++コミュニティからも示されいていた（[C++Now 2017: Ben Deane &amp;amp; Jason Turner &amp;#34;constexpr ALL the things!&amp;#34;](https://youtu.be/HMB9oXFobJc)、[P0810R0 constexpr in Practice](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0810r0.pdf)など）。
+`std::vector`をはじめとする可変サイズのコンテナは実行時に非常に有用であるため、同様に定数式においても有用である可能性があり、その必要性がC++コミュニティからも示されていた（[C++Now 2017: Ben Deane &amp;amp; Jason Turner &amp;#34;constexpr ALL the things!&amp;#34;](https://youtu.be/HMB9oXFobJc)、[P0810R0 constexpr in Practice](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0810r0.pdf)など）。
 
 また、静的リフレクション機能の導入にあたっては、コンパイル時に使用可能な可変サイズコンテナおよび可変サイズの文字列型が必要となっていた。例えば、ある型のテンプレート引数をクエリするコードは次のようなものになる
 
@@ -356,4 +356,4 @@ int main() {
 - [P0784R7 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html)
 - [動的メモリー確保 - 江添亮の入門C++](https://ezoeryou.github.io/cpp-intro/#動的メモリー確保)
 - [N3664 Clarifying Memory Allocation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html)
-- [P1974R0 Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)
\ No newline at end of file
+- [P1974R0 Non-transient constexpr allocation using propconst](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1974r0.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Yuhki Ogasawara</name>
        <email>y121516@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>svリテラル -- Merge pull request #1400 from cpprefjp/improve_op_sv</title>
      <link href="https://cpprefjp.github.io/reference/string_view/basic_string_view/op_sv.html"/>
      <id>d71d768c4a18d4e71afd5384f540ce1585f89dac:reference/string_view/basic_string_view/op_sv.md</id>
      <updated>2025-01-08T16:42:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string_view/basic_string_view/op_sv.md b/reference/string_view/basic_string_view/op_sv.md
index 73aa14604..09fff219f 100644
--- a/reference/string_view/basic_string_view/op_sv.md
+++ b/reference/string_view/basic_string_view/op_sv.md
@@ -45,8 +45,18 @@ inline namespace string_view_literals {
 
 ## 備考
 - 中間にヌル文字を含む文字列リテラルから`basic_string_view`オブジェクトを構築する場合、コンストラクタを使用するよりもこちらの関数を使用したほうがよい。
-    - `const char*`をとるコンストラクタは[`std::char_traits`](/reference/string/char_traits.md)`::`[`length()`](/reference/string/char_traits/length.md)関数を使用して文字列長を計算するため、ヌル終端となってしまう
+    - `const char*`をとるコンストラクタは[`std::char_traits`](/reference/string/char_traits.md)`::`[`length()`](/reference/string/char_traits/length.md)関数を使用して文字列長を計算するため、ヌル終端までの長さとなる。そのコンストラクタでは文字列の途中にヌル文字がある場合、文字列の終端まで扱われないので注意が必要となる
     - こちらの関数は文字列リテラルの長さを直接扱うため、文字列全体を参照する`basic_string_view`オブジェクトを構築できる
+    ```cpp
+    // コンストラクタは、ヌル文字までの長さ
+    const char* s = &amp;#34;123\0abc&amp;#34;;
+    auto sv0 = std::string_view{s};
+    assert(sv0.length() == 3); // &amp;#34;123&amp;#34;
+
+    // svリテラルは全体の長さ
+    auto sv1 = &amp;#34;123\0abc&amp;#34;sv;
+    assert(sv1.length() == 7); // &amp;#34;123\0abc&amp;#34;
+    ```
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>svリテラル -- string_view::op_sv : ヌル終端に関する説明がわかりにくかったので追記 #1398</title>
      <link href="https://cpprefjp.github.io/reference/string_view/basic_string_view/op_sv.html"/>
      <id>c2e5e06a8ffd07ad5d42d077f39e964ecd5af143:reference/string_view/basic_string_view/op_sv.md</id>
      <updated>2025-01-08T16:42:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string_view/basic_string_view/op_sv.md b/reference/string_view/basic_string_view/op_sv.md
index 73aa14604..09fff219f 100644
--- a/reference/string_view/basic_string_view/op_sv.md
+++ b/reference/string_view/basic_string_view/op_sv.md
@@ -45,8 +45,18 @@ inline namespace string_view_literals {
 
 ## 備考
 - 中間にヌル文字を含む文字列リテラルから`basic_string_view`オブジェクトを構築する場合、コンストラクタを使用するよりもこちらの関数を使用したほうがよい。
-    - `const char*`をとるコンストラクタは[`std::char_traits`](/reference/string/char_traits.md)`::`[`length()`](/reference/string/char_traits/length.md)関数を使用して文字列長を計算するため、ヌル終端となってしまう
+    - `const char*`をとるコンストラクタは[`std::char_traits`](/reference/string/char_traits.md)`::`[`length()`](/reference/string/char_traits/length.md)関数を使用して文字列長を計算するため、ヌル終端までの長さとなる。そのコンストラクタでは文字列の途中にヌル文字がある場合、文字列の終端まで扱われないので注意が必要となる
     - こちらの関数は文字列リテラルの長さを直接扱うため、文字列全体を参照する`basic_string_view`オブジェクトを構築できる
+    ```cpp
+    // コンストラクタは、ヌル文字までの長さ
+    const char* s = &amp;#34;123\0abc&amp;#34;;
+    auto sv0 = std::string_view{s};
+    assert(sv0.length() == 3); // &amp;#34;123&amp;#34;
+
+    // svリテラルは全体の長さ
+    auto sv1 = &amp;#34;123\0abc&amp;#34;sv;
+    assert(sv1.length() == 7); // &amp;#34;123\0abc&amp;#34;
+    ```
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get -- add preconditions to member functions of std::future / remove UB from example</title>
      <link href="https://cpprefjp.github.io/reference/future/future/get.html"/>
      <id>eba553f04a34c46b2d494ef772d45465de39b137:reference/future/future/get.md</id>
      <updated>2025-01-04T13:22:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/future/get.md b/reference/future/future/get.md
index 5c2343a5c..137c1f403 100644
--- a/reference/future/future/get.md
+++ b/reference/future/future/get.md
@@ -29,6 +29,11 @@ void future&amp;lt;void&amp;gt;::get();
 共有状態に例外が格納されていた場合、格納されている例外を送出する。
 
 
+## 事前条件
+- [`valid()`](valid.md) `== true`
+    - この条件を満たさなかった場合、処理系によっては[`future_error`](../future_error.md)例外を投げることがある。
+
+
 ## 事後条件
 この関数呼び出し後は共有状態が破棄され、[`valid()`](valid.md) `== false`となること。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- add preconditions to member functions of std::future / remove UB from example</title>
      <link href="https://cpprefjp.github.io/reference/future/future/wait.html"/>
      <id>eba553f04a34c46b2d494ef772d45465de39b137:reference/future/future/wait.md</id>
      <updated>2025-01-04T13:22:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/future/wait.md b/reference/future/future/wait.md
index 43bf1d5ce..397bb8436 100644
--- a/reference/future/future/wait.md
+++ b/reference/future/future/wait.md
@@ -21,6 +21,11 @@ void wait() const;
 なし
 
 
+## 事前条件
+- [`valid()`](valid.md) `== true`
+    - この条件を満たさなかった場合、処理系によっては[`future_error`](../future_error.md)例外を投げることがある。
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait_for -- add preconditions to member functions of std::future / remove UB from example</title>
      <link href="https://cpprefjp.github.io/reference/future/future/wait_for.html"/>
      <id>eba553f04a34c46b2d494ef772d45465de39b137:reference/future/future/wait_for.md</id>
      <updated>2025-01-04T13:22:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/future/wait_for.md b/reference/future/future/wait_for.md
index a2cc2921f..f2dca8bbc 100644
--- a/reference/future/future/wait_for.md
+++ b/reference/future/future/wait_for.md
@@ -29,6 +29,11 @@ future_status wait_for(const chrono::duration&amp;lt;Rep, Period&amp;gt;&amp;amp; rel_time) const;
 - C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。
 
 
+## 事前条件
+- [`valid()`](valid.md) `== true`
+    - この条件を満たさなかった場合、処理系によっては[`future_error`](../future_error.md)例外を投げることがある。
+
+
 ## 例
 ### 例1
 ```cpp example
@@ -100,14 +105,8 @@ int main()
 
   f.get(); // 一度値を取り出すと共有状態が破棄される
 
-  // 共有状態を持たない(valid() == falseな)futureでwaitをするとstd::future_error例外
-  // ただし、libc++では(少なくとも19.1.0までは)SEGVするので注意
-  try {
-    ready();
-  }
-  catch(const std::future_error&amp;amp; e) {
-    std::cout &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; std::endl;
-  }
+  // 共有状態を持たない(valid() == falseな)futureでwaitをするとUB
+  // ready();
 }
 ```
 * wait_for[color ff0000]
@@ -116,13 +115,11 @@ int main()
 * std::future_status[link /reference/future/future_status.md]
 * f.get()[link /reference/future/shared_future/get.md]
 * valid()[link /reference/future/future/valid.md]
-* std::future_error[link /reference/future/future_error.md]
 
 #### 出力例
 ```
 false
 true
-std::future_error: No associated state
 ```
 
 ## バージョン
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait_until -- add preconditions to member functions of std::future / remove UB from example</title>
      <link href="https://cpprefjp.github.io/reference/future/future/wait_until.html"/>
      <id>eba553f04a34c46b2d494ef772d45465de39b137:reference/future/future/wait_until.md</id>
      <updated>2025-01-04T13:22:52+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/future/wait_until.md b/reference/future/future/wait_until.md
index 6a84f1213..2d61fe9f2 100644
--- a/reference/future/future/wait_until.md
+++ b/reference/future/future/wait_until.md
@@ -34,6 +34,11 @@ future_status wait_until(const chrono::time_point&amp;lt;Clock, Duration&amp;gt;&amp;amp; abs_time) co
 - C++14 : 時計クラス、[`time_point`](/reference/chrono/time_point.md)クラス、[`duration`](/reference/chrono/duration.md)クラスの構築が例外を送出する場合、この関数はそれらの例外を送出する。
 
 
+## 事前条件
+- [`valid()`](valid.md) `== true`
+    - この条件を満たさなかった場合、処理系によっては[`future_error`](../future_error.md)例外を投げることがある。
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait_for -- add comment about SEGV on libc++</title>
      <link href="https://cpprefjp.github.io/reference/future/future/wait_for.html"/>
      <id>f1ae4bcfabb3cef121a1d4f6d1fc102c74c3b11f:reference/future/future/wait_for.md</id>
      <updated>2025-01-04T09:32:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/future/wait_for.md b/reference/future/future/wait_for.md
index 2f079ffd8..a2cc2921f 100644
--- a/reference/future/future/wait_for.md
+++ b/reference/future/future/wait_for.md
@@ -101,6 +101,7 @@ int main()
   f.get(); // 一度値を取り出すと共有状態が破棄される
 
   // 共有状態を持たない(valid() == falseな)futureでwaitをするとstd::future_error例外
+  // ただし、libc++では(少なくとも19.1.0までは)SEGVするので注意
   try {
     ready();
   }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>I</name>
        <email>1091761+wx257osn2@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>