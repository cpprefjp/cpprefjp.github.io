<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-16T06:07:19.528860</updated>
  <id>cdb49319-2c2e-4765-b582-1fc1a739c591</id>

  
    <entry>
      <title>cmath -- &lt;cmath&gt; : constexpr対応の説明見直し</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>019f15edfc2908d7d6678f7199696635dc2a7e92:reference/cmath.md</id>
      <updated>2023-02-16T15:03:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index e493b5cc3..c16eeaa1a 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -87,7 +87,7 @@
 
 ### &amp;lt;a id=&amp;#34;cpp23&amp;#34; href=&amp;#34;#cpp23&amp;#34;&amp;gt;C++23での差異&amp;lt;/a&amp;gt;
 #### constexpr対応
-C++23では、多くの数学関数が`constexpr`に対応し、定数式内で使用できるようになった。C++23時点では、コンパイラベンダの負担が低い機能を`constexpr`対応した。
+C++23では、多くの数学関数が`constexpr`に対応し、定数式内で使用できるようになった。C++23時点では、コンパイラベンダの負担が少ない機能を`constexpr`対応した。
 
 C++23で`constexpr`対応する関数の条件は以下：
 
@@ -98,6 +98,8 @@ C++23で`constexpr`対応する関数の条件は以下：
 
 [`nearbyint`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
+ただし、コンパイラが先行して`constexpr`非対応の関数も対応している可能性がある。
+
 なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである ([`errno`](cerrno/errno.md)や浮動小数点例外のようなグローバル状態を使用しない)。
 
 #### 拡張浮動小数点数型への対応
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : バージョン差異にページ内リンクをつけた</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>182e098dccc8482b0d0965ebd32f76dd01406bdb:reference/cmath.md</id>
      <updated>2023-02-16T13:21:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index 484776a1d..e493b5cc3 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -30,14 +30,14 @@
 ## &amp;lt;a id=&amp;#34;difference-from-c&amp;#34; href=&amp;#34;#difference-from-c&amp;#34;&amp;gt;標準Cライブラリとの差異&amp;lt;/a&amp;gt;
 `&amp;lt;cmath&amp;gt;`は基本的には、標準 C ライブラリの `&amp;lt;math.h&amp;gt;` に準拠しているが、いくつかの変更点がある。
 
-### C++03のC90との差異
+### &amp;lt;a id=&amp;#34;cpp03&amp;#34; href=&amp;#34;#cpp03&amp;#34;&amp;gt;C++03のC90との差異&amp;lt;/a&amp;gt;
 - 各関数は std 名前空間に定義されている。
 - `fabs` と等価の関数 `abs` を追加している。
 - `pow` の第 2 引数が `int` のオーバーロードを追加している。
 - 各関数（上記 2 関数を含む）に対して、引数および戻り値の `double` に対応する箇所が `float` および `long double` になっているオーバーロードバージョンを追加している。
 
 
-### C++11のC99との差異
+### &amp;lt;a id=&amp;#34;cpp11&amp;#34; href=&amp;#34;#cpp11&amp;#34;&amp;gt;C++11のC99との差異&amp;lt;/a&amp;gt;
 - 各関数は std 名前空間に定義されている。
 - `fabs` と等価の関数 `abs` を追加している。
 - 引数に `double` を含む各関数（上記 `abs` を含む）に対して、引数および戻り値の `double` に対応する箇所が `float` と `long double` のオーバーロードバージョンを追加している。  
@@ -85,7 +85,7 @@
     * Promoted[italic]
 
 
-### C++23での差異
+### &amp;lt;a id=&amp;#34;cpp23&amp;#34; href=&amp;#34;#cpp23&amp;#34;&amp;gt;C++23での差異&amp;lt;/a&amp;gt;
 #### constexpr対応
 C++23では、多くの数学関数が`constexpr`に対応し、定数式内で使用できるようになった。C++23時点では、コンパイラベンダの負担が低い機能を`constexpr`対応した。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- Merge pull request #1124 from cpprefjp/refine-algorithm</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>d158adbce888acbace8d1313edfef82eabebf32a:reference/algorithm.md</id>
      <updated>2023-02-16T13:11:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 041e10d61..fb2fcc564 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -4,10 +4,14 @@
 
 全てのアルゴリズムはデータ構造の実装の詳細から切り離されていて、イテレータによってパラメータ化されている。これはアルゴリズムの要件を満たすイテレータを提供しているなら、どのようなデータ構造であっても動作するということを示している。
 
-関数オブジェクトを使用するアルゴリズムでは、`for_each`と`for_each_n`以外、引数として渡されたオブジェクトを書き換えてはならない。
+このヘッダでは、以下の標準ヘッダをインクルードする：
+
+- [`&amp;lt;initializer_list&amp;gt;`](initializer_list.md) (C++11)
+
 
-ここでは、各アルゴリズムのテンプレートパラメータ名を、型の要件を表すために使っている。アルゴリズムを正しく利用するためには、テンプレートパラメータ名に応じたこれらの要件を満たしている必要がある。以下の通りである。
+### テンプレートパラメータ名とイテレータ要件
 
+`&amp;lt;algorithm&amp;gt;`ヘッダでは、各アルゴリズムのテンプレートパラメータ名を、型の要件を表すために使っている。アルゴリズムを正しく利用するためには、テンプレートパラメータ名に応じたこれらの要件を満たしている必要がある。以下の通りである。
 
 | テンプレートパラメータ名 | 要件 |
 |-------------------------------------------------------------------------|------------------------|
@@ -20,8 +24,6 @@
 もし「効果」のセクションで、イテレータの値を書き換えるという旨の文章が書かれている場合、その引数の型は mutable iterator の要件を満たしていなければならないという追加の要件がある。
 もちろん、output iterator は常に書き換え可能であるため、この追加の要件は無意味である。
 
-いくつかのアルゴリズムは `_copy` というサフィックスが付いている。これは `_copy` サフィックスの付いていないアルゴリズムと違い、処理の結果を別のイテレータへ出力するアルゴリズムである。コピーバージョンを含めるかどうかの判断は、通常バージョンの計算量を考慮する。操作を行うコストがコピーのコストを大きく上回る場合、コピーバージョンは含めないようになっている。例えば `sort_copy` は存在しない。なぜなら、ソートのコストは大きいし、そのような場合、ユーザは `copy` してから `sort` するからだ。
-
 テンプレートパラメータ名が `Predicate` となっている場合、`Predicate` の値 `pred` と、引数として渡すイテレータ `i` について以下の要件を満たす必要がある
 
 - `pred(*i)` が `bool` として評価できなければならない。
@@ -32,8 +34,20 @@
 - `binary_pred(*i1, *i2)` が `bool` として評価できなければならない。
 - `binary_pred(*i1, *i2)` 内で `*i1` や `*i2` を書き変えてはならない。
 
-関数オブジェクトを引数に取る `for_each` 以外のアルゴリズムは、その関数オブジェクトを自由にコピーしても構わない。そのため、アルゴリズムの利用者はそのことに注意する必要がある。コピーされてしまうことが問題である場合、`reference_wrapper&amp;lt;T&amp;gt;` や同様の解決手段を使ってオブジェクトの中身をコピーしないようなラッパークラスを使うといった対策を行う必要がある。
+### 要素の書き換え操作
+関数オブジェクトを使用するアルゴリズムでは、`for_each`と`for_each_n`以外、プログラム定義の関数に引数として渡された要素を書き換えてはならない。
+
+### 関数オブジェクトの取り扱い
+関数オブジェクトを引数に取る `for_each`, `for_each_n` 以外のアルゴリズムは、内部処理においてその関数オブジェクトをコピーする可能性がある。
+
+そのため、アルゴリズムの利用者はそのことに注意する必要がある。コピーされてしまうことが問題である場合、`reference_wrapper&amp;lt;T&amp;gt;` や同様の解決手段を使ってオブジェクトの中身をコピーしないようなラッパークラスを使うといった対策を行う必要がある。
+
+### `_copy`サフィックス付きアルゴリズム
+いくつかのアルゴリズムは `_copy` というサフィックスが付いている。これは `_copy` サフィックスの付いていないアルゴリズムと違い、処理の結果を別のイテレータへ出力するアルゴリズムである。
 
+コピーバージョンを含めるかどうかの判断は、通常バージョンの計算量を考慮する。操作を行うコストがコピーのコストを大きく上回る場合、コピーバージョンは含めないようになっている。例えば `sort_copy` は存在しない。なぜなら、ソートのコストは大きいし、そのような場合、ユーザは `copy` してから `sort` するからだ。
+
+### イテレータ操作に関する補足
 アルゴリズムの説明で `+` や `-` を使っているが、random-access iterator 以外のイテレータはそれを定義していない。そういった場合、 `a+n` というのは
 
 ```cpp
@@ -41,21 +55,18 @@ X tmp = a;
 advance(tmp, n);
 return tmp;
 ```
+* advance[link /reference/iterator/advance.md]
 
 を意味する。また、`b-a` は
 
 ```cpp
 return distance(a, b);
 ```
+* distance[link /reference/iterator/distance.md]
 
 を意味する。
 
-このヘッダでは、以下の標準ヘッダをインクルードする：
-
-- [`&amp;lt;initializer_list&amp;gt;`](initializer_list.md) (C++11)
-
-### 射影とRangeサポート
-
+### 射影とRangeサポート（C++20）
 C++20ではアルゴリズム関数の新しいバージョンが`std::ranges`名前空間に追加された。従来の関数と比べて以下の点が異なる：
 
 * テンプレート引数がコンセプトによって制約される
@@ -73,6 +84,8 @@ ranges::sort(v);
 // イテレータ対も渡せる
 ranges::sort(v.begin(), v.end());
 ```
+* sort[link algorithm/sort.md]
+* ranges::sort[link algorithm/ranges_sort.md]
 
 射影は、述語とは別に渡すことができる関数オブジェクトで、特定のメンバだけを対象にアルゴリズムを実行するために用いる。
 
@@ -88,19 +101,23 @@ vector&amp;lt;Person&amp;gt; pv = { … };
 
 sort(pv.begin(), pv.end(), [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b){ return a.name &amp;lt; b.name; });
 ```
+* sort[link algorithm/sort.md]
 
 これは、述語がメンバの選択と比較という2つの仕事をしてしまっている点でよくない。この責務を分割し、メンバの選択だけを行うようにしたものが射影である。
 
 ```cpp
-// デフォルトの述語({})で、nameでソート
+// デフォルトの述語(ranges::less{})で、nameでソート
 ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 // std::invokeで呼び出されるため、メンバ変数ポインタでもよい
 ranges::sort(pv, {}, &amp;amp;Parson::name);
 ```
+* ranges::sort[link algorithm/ranges_sort.md]
+* ranges::less[link /reference/functional/ranges_less.md]
 * std::invoke[link /reference/functional/invoke.md]
 
 なお、各関数の説明においては、射影の影響は無視していることがある。
 
+
 ## シーケンスを変更しない操作
 
 | 名前 | 説明 | 対応バージョン |
@@ -418,6 +435,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::in_found_result`](algorithm/ranges_in_found_result.md)     | イテレータとbool値を格納する型           | C++20          |
 | [`ranges::out_value_result`](algorithm/ranges_out_value_result.md)   | イテレータと値を格納する型               | C++23          |
 
+
 ## 関連項目
 - [`&amp;lt;numeric&amp;gt;`](/reference/numeric.md)
     - 数値計算のアルゴリズム
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : lerpの説明を補足</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>eaf722b020984fde1abdb2b50c1f39d8863ecb1b:reference/cmath.md</id>
      <updated>2023-02-16T13:04:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index 3ac2fc19f..484776a1d 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -98,7 +98,7 @@ C++23で`constexpr`対応する関数の条件は以下：
 
 [`nearbyint`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
-なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである。
+なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである ([`errno`](cerrno/errno.md)や浮動小数点例外のようなグローバル状態を使用しない)。
 
 #### 拡張浮動小数点数型への対応
 C++23では[`&amp;lt;stdfloat&amp;gt;`](stdfloat.md.nolink)に拡張浮動小数点数型が追加された。その対応として、以下のような`float`、`double`、`long double`に対するオーバーロードは、
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- abs, frexp, ilogb, ldexp : constexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/abs.html"/>
      <id>d3cb0839fde2f6b6534b5ba13db0c0c045804d9d:reference/cmath/abs.md</id>
      <updated>2023-02-16T12:56:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/abs.md b/reference/cmath/abs.md
index 4f35a45bf..1505b65f0 100644
--- a/reference/cmath/abs.md
+++ b/reference/cmath/abs.md
@@ -6,15 +6,25 @@
 
 ```cpp
 namespace std {
-  float abs(float x);             // (1)
-  double abs(double x);           // (2)
-  long double abs(long double x); // (3)
+  float abs(float x);                       // (1) C++03からC++20まで
 
-  double abs(Integral x);     // (4) C++11 から C++14 まで
+  double abs(double x);                     // (2) C++03からC++20まで
 
-  int abs(int x);             // (5) C++17 から
-  long abs(long int x);       // (6) C++17 から
-  long long abs(long long x); // (7) C++17 から
+  long double abs(long double x);           // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    abs(floating-point-type x);             // (4) C++23
+
+  double abs(Integral x);                   // (5) C++11 から C++14 まで
+
+  int abs(int x);                           // (6) C++17
+  constexpr int abs(int x);                 // (6) C++23
+
+  long abs(long int x);                     // (7) C++17
+  constexpr long abs(long int x);           // (7) C++23
+
+  long long abs(long long x);               // (8) C++17
+  constexpr long long abs(long long x);     // (8) C++23
 }
 ```
 * Integral[italic]
@@ -22,6 +32,15 @@ namespace std {
 ## 概要
 浮動小数点数型の絶対値を求める。abs は absolute value（絶対値）の略。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `int`に対するオーバーロード
+- (7) : `long int`に対するオーバーロード
+- (8) : `long long`に対するオーバーロード
+
 
 ## 戻り値
 引数 `x` の絶対値を返す。
@@ -31,7 +50,8 @@ namespace std {
 
 ## 備考
 - $$ f(x) = | x | $$
-- 任意の整数型に対するオーバーロード(4)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(5),(6),(7)が追加された。
+- 任意の整数型に対するオーバーロード(5)は C++11 で追加されたが、[一部の符号なし整数型に対して問題を引き起こす](http://wg21.cmeerw.net/lwg/issue2192)ことから C++17 で削除され、符号付き整数型に対するオーバーロード(6),(7),(8)が追加された
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -76,3 +96,10 @@ namespace std {
   }
 }
 ```
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>frexp -- abs, frexp, ilogb, ldexp : constexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/frexp.html"/>
      <id>d3cb0839fde2f6b6534b5ba13db0c0c045804d9d:reference/cmath/frexp.md</id>
      <updated>2023-02-16T12:56:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/frexp.md b/reference/cmath/frexp.md
index edef8a649..27e351ad4 100644
--- a/reference/cmath/frexp.md
+++ b/reference/cmath/frexp.md
@@ -5,25 +5,46 @@
 
 ```cpp
 namespace std {
-  float frexp(float value, int* exp);
-  double frexp(double value, int* exp);
-  long double frexp(long double value, int* exp);
-
-  double frexp(Integral value, int* exp);           // C++11 から
-
-  float frexpf(float value, int* exp);              // C++17 から
-  long double frexpl(long double value, int* exp);  // C++17 から
+  float frexp(float value, int* exp);             // (1) C++03からC++20まで
+  double frexp(double value, int* exp);           // (2) C++03からC++20まで
+  long double frexp(long double value, int* exp); // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    frexp(floating-point-type value, int* exp);   // (4) C++23
+
+  double
+    frexp(Integral value, int* exp);              // (5) C++11
+  constexpr double
+    frexp(Integral value, int* exp);              // (5) C++23
+
+  float
+    frexpf(float value, int* exp);                // (6) C++17
+  constexpr float
+    frexpf(float value, int* exp);                // (6) C++23
+
+  long double
+    frexpl(long double value, int* exp);          // (7) C++17
+  constexpr long double
+    frexpl(long double value, int* exp);          // (7) C++23
 }
 ```
 * Integral[italic]
 
 ## 概要
-`frexp`関数 (fraction and exponent)は、浮動小数点数`value`を、正規化された仮数部と 2 の累乗へ分解する。
+`frexp`関数 (fraction and exponent) は、浮動小数点数`value`を、正規化された仮数部と 2 の累乗へ分解する。
 
 この関数は、与えられた浮動小数点数`value`を仮数部と指数部に分解し、仮数部を戻り値で返し、指数を`*exp`に書き込んで返す。
 
 この関数と反対に、[`std::ldexp()`](ldexp.md)関数を使用することで、仮数部と指数部の値から浮動小数点数を作り出せる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `value` が浮動小数点数ではない、もしくは2の乗数が `int` の範囲外である場合、戻り値は未規定。
@@ -39,7 +60,8 @@ C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std:
 - `value = ±0` の場合、戻り値は `±0` となり、`*exp` にはゼロが設定される。
 - `value = ±∞` の場合、戻り値は `±∞` となり、`*exp` には未規定の値が設定される。
 - `value` が NaN の場合、戻り値は NaN となり、`*exp` には未規定の値が設定される。
-- `frexp` は浮動小数点例外を全く発生させない。
+- この関数は浮動小数点例外を発生させない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -68,4 +90,7 @@ int main()
 ## 参照
 - [Why does `frexp()` not yield scientific notation?](http://stackoverflow.com/questions/24928833/why-does-frexp-not-yield-scientific-notation)
     - `frexp()`が戻り値を`[1, 2)`の範囲ではなく、`[0.5, 1)`の範囲に収めるようにしている理由は、IEEE 754およびISO/IEC 60559が策定される前に作られた関数であることが理由と考えられる
-
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ilogb -- abs, frexp, ilogb, ldexp : constexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ilogb.html"/>
      <id>d3cb0839fde2f6b6534b5ba13db0c0c045804d9d:reference/cmath/ilogb.md</id>
      <updated>2023-02-16T12:56:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ilogb.md b/reference/cmath/ilogb.md
index 7822ca28d..7c1faa8e7 100644
--- a/reference/cmath/ilogb.md
+++ b/reference/cmath/ilogb.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  int ilogb(float);
-  int ilogb(double);
-  int ilogb(long double);
+  int ilogb(float x);             // (1) C++11からC++20まで
+  int ilogb(double x);            // (2) C++11からC++20まで
+  int ilogb(long double x);       // (3) C++11からC++20まで
 
-  int ilogb(Integral);
+  constexpr int
+    ilogb(floating-point-type x); // (3) C++23
 
-  int ilogbf(float x);          // C++17 から
-  int ilogbl(long double x);    // C++17 から
+  int
+    ilogb(Integral);              // (4) C++11
+  constexpr int
+    ilogb(Integral);              // (4) C++23
+
+  int
+    ilogbf(float x);              // (5) C++17
+  constexpr int
+    ilogbf(float x);              // (5) C++23
+
+  int
+    ilogbl(long double x);        // (6) C++17
+  constexpr int
+    ilogbl(long double x);        // (6) C++23
 }
 ```
 * Integral[italic]
@@ -21,6 +34,14 @@ namespace std {
 ## 概要
 `ilogb`関数(integer log binary)は、浮動小数点数 `x` の指数部を `int` として返す。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `x` がゼロの場合は [`FP_ILOGB0`](fp_ilogb0.md) を、無限大の場合は [`INT_MAX`](/reference/climits/int_max.md) を、`NaN` の場合は [`FP_ILOGBNAN`](fp_ilogbnan.md) を返す。
@@ -34,6 +55,7 @@ namespace std {
 	- 正しい結果が戻り値の型（`int`）の範囲で表現可能な場合は、戻り値は正確で、現在の丸め方式に依存しない。
 	- 正しい結果が戻り値の型（`int`）の範囲外の場合は、戻り値は未規定で、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
 	- `x` がゼロ、無限大、あるいは NaN の場合には、[`FE_INVALID`](../cfenv/fe_invalid.md)（無効演算浮動小数点例外）が発生する。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -74,3 +96,10 @@ ilogb(1e-309) = -1027
 - [GCC](/implementation.md#gcc): 4.3.6
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ldexp -- abs, frexp, ilogb, ldexp : constexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ldexp.html"/>
      <id>d3cb0839fde2f6b6534b5ba13db0c0c045804d9d:reference/cmath/ldexp.md</id>
      <updated>2023-02-16T12:56:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ldexp.md b/reference/cmath/ldexp.md
index 188760182..c8e973c15 100644
--- a/reference/cmath/ldexp.md
+++ b/reference/cmath/ldexp.md
@@ -5,14 +5,27 @@
 
 ```cpp
 namespace std {
-  float ldexp(float x, int exp);
-  double ldexp(double x, int exp);
-  long double ldexp(long double x, int exp);
-
-  double ldexp(Integral x, int exp);            // C++11 から
-
-  float ldexpf(float x, int exp);               // C++17 から
-  long double ldexpl(long double x, int exp);   // C++17 から
+  float ldexp(float x, int exp);                // (1) C++03からC++20まで
+  double ldexp(double x, int exp);              // (2) C++03からC++20まで
+  long double ldexp(long double x, int exp);    // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    ldexp(floating-point-type x, int exp);      // (4) C++23
+
+  double
+    ldexp(Integral x, int exp);                 // (5) C++11
+  constexpr double
+    ldexp(Integral x, int exp);                 // (5) C++23
+
+  float
+    ldexpf(float x, int exp);                   // (6) C++17
+  constexpr float
+    ldexpf(float x, int exp);                   // (6) C++23
+
+  long double
+    ldexpl(long double x, int exp);             // (7) C++17
+  constexpr long double
+    ldexpl(long double x, int exp);             // (7) C++23
 }
 ```
 * Integral[italic]
@@ -24,6 +37,14 @@ namespace std {
 
 この関数と反対に、[`std::frexp()`](frexp.md)関数を使用することで、浮動小数点数を仮数部と指数部に分解できる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 &amp;lt;code&amp;gt;x * 2&amp;lt;sup&amp;gt;exp&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt;
@@ -34,6 +55,7 @@ namespace std {
 ## 備考
 - オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、かつ、基数が 2 の場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`radix`](../limits/numeric_limits/radix.md)`() == 2`）、[`scalbn`](scalbn.md)`(x, exp)` と等価である。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -89,3 +111,9 @@ namespace std {
 }
 ```
 * std::pow[link pow.md]
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>