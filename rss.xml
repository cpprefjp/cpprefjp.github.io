<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-03-07T03:51:18.932665</updated>
  <id>09df44ed-5614-479a-af6a-68cb93a4b57e</id>

  
    <entry>
      <title>to_chars -- to_chars : 拡張浮動小数点数型に対応 #1022</title>
      <link href="https://cpprefjp.github.io/reference/charconv/to_chars.html"/>
      <id>985d49c758e7d255f694e0357e289c7484c47cf8:reference/charconv/to_chars.md</id>
      <updated>2023-03-07T12:46:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/to_chars.md b/reference/charconv/to_chars.md
index bfb3df034..aeb75e232 100644
--- a/reference/charconv/to_chars.md
+++ b/reference/charconv/to_chars.md
@@ -7,35 +7,93 @@
 ```cpp
 namespace std {
   //整数型用
-  to_chars_result to_chars(char* first, char* last, /*see below*/ value,  int base = 10);           // (1) C++17
-  constexpr to_chars_result to_chars(char* first, char* last, /*see below*/ value,  int base = 10); // (1) C++23
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             /*see below*/ value,
+             int base = 10);        // (1) C++17
+  constexpr to_chars_result
+    to_chars(char* first,
+             char* last,
+             integer-type value,
+             int base = 10);        // (1) C++23
 
   //boolの変換は禁止
-  to_chars_result to_chars(char* first, char* last, bool value,  int base = 10) = delete; // C++20
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             bool value,
+             int base = 10) = delete; // C++20
 
   //精度、フォーマット指定なし
-  to_chars_result to_chars(char* first, char* last, float value);        // (2)
-  to_chars_result to_chars(char* first, char* last, double value);       // (3)
-  to_chars_result to_chars(char* first, char* last, long double value);  // (4)
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             float value);               // (2) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             double value);              // (3) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             long double value);         // (4) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             floating-point-type value); // (5) C++23
 
   //精度指定なし
-  to_chars_result to_chars(char* first, char* last, float value,
-                           chars_format fmt);                            // (5)
-  to_chars_result to_chars(char* first, char* last, double value,
-                           chars_format fmt);                            // (6)
-  to_chars_result to_chars(char* first, char* last, long double value,
-                           chars_format fmt);                            // (7)
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             float value,
+             chars_format fmt);          // (6) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             double value,
+             chars_format fmt);          // (7) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             long double value,
+             chars_format fmt);          // (8) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             floating-point-type value,
+             chars_format fmt);          // (9) C++23
 
   //精度とフォーマットを指定
-  to_chars_result to_chars(char* first, char* last, float value,
-                           chars_format fmt, int precision);             // (8)
-  to_chars_result to_chars(char* first, char* last, double value,
-                           chars_format fmt, int precision);             // (9)
-  to_chars_result to_chars(char* first, char* last, long double value,
-                           chars_format fmt, int precision);             // (10)
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             float value,
+             chars_format fmt,
+             int precision);             // (10) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             double value,
+             chars_format fmt,
+             int precision);             // (11) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             long double value,
+             chars_format fmt,
+             int precision);             // (12) C++17からC++20まで
+  to_chars_result
+    to_chars(char* first,
+             char* last,
+             floating-point-type value,
+             chars_format fmt,
+             int precision);             // (13) C++23
 }
 ```
 * see below[italic]
+* integer-type[italic]
 
 ## 概要
 与えられた数値（`value`）を文字列へ変換し、`[first, last)`内へ出力する。  
@@ -43,10 +101,24 @@ namespace std {
 
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
+- (1) : 整数型に対するオーバーロード
+- (2) : `float`に対するオーバーロード (精度・フォーマット指定なし)
+- (3) : `double`に対するオーバーロード (精度・フォーマット指定なし)
+- (4) : `long double`に対するオーバーロード (精度・フォーマット指定なし)
+- (5) : 浮動小数点数型に対するオーバーロード (精度・フォーマット指定なし)
+- (6) : `float`に対するオーバーロード (精度指定なし)
+- (7) : `double`に対するオーバーロード (精度指定なし)
+- (8) : `long double`に対するオーバーロード (精度指定なし)
+- (9) : 浮動小数点数型に対するオーバーロード (精度指定なし)
+- (10) : `float`に対するオーバーロード (精度・フォーマット指定)
+- (11) : `double`に対するオーバーロード (精度・フォーマット指定)
+- (12) : `long double`に対するオーバーロード (精度・フォーマット指定)
+- (13) : 浮動小数点数型に対するオーバーロード (精度・フォーマット指定)
+
 ## 要件
 - 全て : 出力イテレータ範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
-- (5)～(10)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
+- (6)～(13)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
 ## 引数
 - `first` -- 変換結果の文字列を出力する範囲の先頭ポインタ。
@@ -64,14 +136,14 @@ C++標準はこれら関数の実装の詳細について何も規定しない
     10 &amp;lt; nの場合、10～35の値はアルファベットの小文字a～zがあてられる。  
     桁数を合わせるために左側を0をパディングすること（0埋め）は行われない。
     
-- (2)(3)(4) : Cロケールで`printf`によって行われたかのように浮動小数点数を文字列へ変換する。  
+- (2)(3)(4)(5) : Cロケールで`printf`によって行われたかのように浮動小数点数を文字列へ変換する。  
     フォーマット指定子は`%f,%e`どちらかを出力文字列が最も短くなるように（両者が同じなら`%f`が優先）選択する。
     
-- (5)(6)(7) : `fmt`によって指定されたフォーマット指定子を用いて、Cロケールで`printf`によって行われたかのように浮動小数点数を文字列へ変換する。  
+- (6)(7)(8)(9) : `fmt`によって指定されたフォーマット指定子を用いて、Cロケールで`printf`によって行われたかのように浮動小数点数を文字列へ変換する。  
     出力文字列が最も短くなるように変換される。  
-    `chars_format::general`が指定された場合は(2)(3)(4)と同等。
+    `chars_format::general`が指定された場合は(2)(3)(4)(5)と同等。
     
-- (8)(9)(10) : `fmt`と`precision`によって指定されたフォーマット指定子と精度を用いて、Cロケールで`printf`によって行われたかのように浮動小数点数を文字列へ変換する。
+- (10)(11)(12)(13) : `fmt`と`precision`によって指定されたフォーマット指定子と精度を用いて、Cロケールで`printf`によって行われたかのように浮動小数点数を文字列へ変換する。
 
 出力文字列が最も短くなるようにとは、小数点の前に少なくとも1桁あり、対応する[`from_chars`](../charconv/from_chars.md)関数によって値を正確に復元できるような最小の文字数、になることである。  
 そのような文字列表現が複数ある場合、`value`の値との差が最も小さくなる物が選ばれ、それも複数あるときは[`std::round_to_nearest`](/reference/limits/float_round_style.md)に従った丸めによって一つを選択する。
@@ -96,9 +168,10 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 投げない。
 
 ## 備考
-(1)の関数は実装によって全ての整数型（符号付、無し）および`char`のオーバーロードが提供される。
+- MSVCでは浮動小数点数→10進文字列変換の実装に[Ryu](https://github.com/ulfjack/ryu)というアルゴリズムを利用している。
+- (1) : 実装によって全ての整数型（符号付、無し）および`char`のオーバーロードが提供される
+- (5)(9)(13) : 浮動小数点数型は拡張浮動小数点数型を含む
 
-MSVCでは浮動小数点数→10進文字列変換の実装に[Ryu](https://github.com/ulfjack/ryu)というアルゴリズムを利用している。
 
 ## 例
 
@@ -145,21 +218,21 @@ int main()
     std::cout &amp;lt;&amp;lt; &amp;#34;conversion failed.&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
 
-  //(6) 精度指定なしの浮動小数点数変換、指数表記
+  //(7) 精度指定なしの浮動小数点数変換、指数表記
   if (auto [ptr, ec] = std::to_chars(begin, end, l, std::chars_format::scientific); ec == std::errc{}) {
     std::cout &amp;lt;&amp;lt; std::string_view(begin, ptr - begin) &amp;lt;&amp;lt; std::endl;
   }
   else {
     std::cout &amp;lt;&amp;lt; &amp;#34;conversion failed.&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
-  //(6) 精度指定なしの浮動小数点数変換、固定小数表記
+  //(7) 精度指定なしの浮動小数点数変換、固定小数表記
   if (auto [ptr, ec] = std::to_chars(begin, end, l, std::chars_format::fixed); ec == std::errc{}) {
     std::cout &amp;lt;&amp;lt; std::string_view(begin, ptr - begin) &amp;lt;&amp;lt; std::endl;
   }
   else {
     std::cout &amp;lt;&amp;lt; &amp;#34;conversion failed.&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
-  //(6) 精度指定なしの浮動小数点数変換、16進指数表記
+  //(7) 精度指定なしの浮動小数点数変換、16進指数表記
   if (auto [ptr, ec] = std::to_chars(begin, end, l, std::chars_format::hex); ec == std::errc{}) {
     std::cout &amp;lt;&amp;lt; std::string_view(begin, ptr - begin) &amp;lt;&amp;lt; std::endl;
   }
@@ -167,21 +240,21 @@ int main()
     std::cout &amp;lt;&amp;lt; &amp;#34;conversion failed.&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
 
-  //(9) 精度指定ありの浮動小数点数変換、指数表記
+  //(11) 精度指定ありの浮動小数点数変換、指数表記
   if (auto [ptr, ec] = std::to_chars(begin, end, l, std::chars_format::scientific, 16); ec == std::errc{}) {
     std::cout &amp;lt;&amp;lt; std::string_view(begin, ptr - begin) &amp;lt;&amp;lt; std::endl;
   }
   else {
     std::cout &amp;lt;&amp;lt; &amp;#34;conversion failed.&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
-  //(9) 精度指定ありの浮動小数点数変換、固定小数表記
+  //(11) 精度指定ありの浮動小数点数変換、固定小数表記
   if (auto [ptr, ec] = std::to_chars(begin, end, l, std::chars_format::fixed, 16); ec == std::errc{}) {
     std::cout &amp;lt;&amp;lt; std::string_view(begin, ptr - begin) &amp;lt;&amp;lt; std::endl;
   }
   else {
     std::cout &amp;lt;&amp;lt; &amp;#34;conversion failed.&amp;#34; &amp;lt;&amp;lt; std::endl;
   }
-  //(9) 精度指定ありの浮動小数点数変換、16進指数表記
+  //(11) 精度指定ありの浮動小数点数変換、16進指数表記
   if (auto [ptr, ec] = std::to_chars(begin, end, l, std::chars_format::hex, 16); ec == std::errc{}) {
     std::cout &amp;lt;&amp;lt; std::string_view(begin, ptr - begin) &amp;lt;&amp;lt; std::endl;
   }
@@ -227,3 +300,5 @@ z
 - [Visual Studio 2017 version 15.9.0 - Visual Studio 2017 version 15.9 Release Notes](https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-relnotes#-c)
 - [P2291R3: Add Constexpr Modifiers to Functions to_chars and from_chars for Integral Types in `&amp;lt;charconv&amp;gt;` Header](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2291r3.pdf)
     - C++23での(1)constexpr指定
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で拡張浮動小数点数型に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_chars -- from_chars : 拡張浮動小数点数型に対応 #1022</title>
      <link href="https://cpprefjp.github.io/reference/charconv/from_chars.html"/>
      <id>f447758159921653e9e3346942620c9c7bf074b8:reference/charconv/from_chars.md</id>
      <updated>2023-03-07T12:46:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/from_chars.md b/reference/charconv/from_chars.md
index 8a4ff6a9a..fe8be9296 100644
--- a/reference/charconv/from_chars.md
+++ b/reference/charconv/from_chars.md
@@ -7,21 +7,42 @@
 ```cpp
 namespace std {
   //整数型用
-  from_chars_result from_chars(const char* first, const char* last,
-                               /*see below*/&amp;amp; value, int base = 10);      // (1) C++17
-  constexpr from_chars_result from_chars(const char* first, const char* last,
-                               /*see below*/&amp;amp; value, int base = 10);      // (1) C++23
+  from_chars_result
+    from_chars(const char* first,
+               const char* last,
+               /*see below*/&amp;amp; value,
+               int base = 10);      // (1) C++17
+  constexpr from_chars_result
+    from_chars(const char* first,
+               const char* last,
+               integer-type&amp;amp; value,
+               int base = 10);      // (1) C++23
 
   //浮動小数点型用
-  from_chars_result from_chars(const char* first, const char* last, float&amp;amp; value,
-                               chars_format fmt = chars_format::general); // (2)
-  from_chars_result from_chars(const char* first, const char* last, double&amp;amp; value,
-                               chars_format fmt = chars_format::general); // (3)
-  from_chars_result from_chars(const char* first, const char* last, long double&amp;amp; value,
-                               chars_format fmt = chars_format::general); // (4)
+  from_chars_result
+    from_chars(const char* first,
+               const char* last,
+               float&amp;amp; value,
+               chars_format fmt = chars_format::general); // (2) C++17からC++20まで
+  from_chars_result
+    from_chars(const char* first,
+               const char* last,
+               double&amp;amp; value,
+               chars_format fmt = chars_format::general); // (3) C++17からC++20まで
+  from_chars_result
+    from_chars(const char* first,
+               const char* last,
+               long double&amp;amp; value,
+               chars_format fmt = chars_format::general); // (4) C++17からC++20まで
+  from_chars_result
+    from_chars(const char* first,
+               const char* last,
+               floating-point-type&amp;amp; value,
+               chars_format fmt = chars_format::general); // (5) C++23
 }
 ```
 * see below[italic]
+* integer-type[italic]
 
 
 ## 概要
@@ -30,6 +51,13 @@ namespace std {
 
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
+- (1) : 整数型に対するオーバーロード
+- (2) : `float`型に対するオーバーロード
+- (3) : `double`型に対するオーバーロード
+- (4) : `long double`型に対するオーバーロード
+- (5) : 浮動小数点数型に対するオーバーロード
+
+
 ## 要件
 - 全て : 入力イテレータ範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
@@ -51,7 +79,7 @@ C++標準はこれら関数の実装の詳細について何も規定しない
     nを基数としたCロケールによる`strtol`で変換する際と同様のパターンを用いる。  
     ただし、`value`の型が符号付である場合にのみ`-`は考慮され、`+`や16進数の`0x`等の他の記号は考慮されない。
     
-- (2)～(4) : 浮動小数点数字列を浮動小数点数へ変換する。  
+- (2)～(5) : 浮動小数点数字列を浮動小数点数へ変換する。  
     Cロケールによる`strtod`で変換する際と同様のパターンを用いる。ただし、以下の違いがある。  
     数字の先頭の符号は`-`のみが考慮され、`+`等は考慮されない。  
     また、`fmt`に`chars_format::general`が設定されておらず（`scientific`と`fixed`が同時に設定されておらず）
@@ -83,7 +111,9 @@ C++標準はこれら関数の実装の詳細について何も規定しない
 投げない。
 
 ## 備考
-(1)の関数は実装によって全ての整数型（符号付、無し）および`char`の参照型のオーバーロードが提供される。
+- (1) : 実装によって全ての整数型（符号付、無し）および`char`の参照型のオーバーロードが提供される
+- (5) : 浮動小数点数型は、拡張浮動小数点数型を含む
+
 
 ## 例
 
@@ -278,7 +308,7 @@ auto str_to_double(R&amp;amp;&amp;amp; r) -&amp;gt; std::optional&amp;lt;double&amp;gt; {
 
 int main() {
   std::string str = &amp;#34;3.1415926535897932384626433832795 is pi&amp;#34;;
-  
+
   if (auto opt = str_to_double(str); opt) {
     std::cout &amp;lt;&amp;lt; std::format(&amp;#34;{:.15f}\n&amp;#34;, *opt);
   } else {
@@ -286,7 +316,7 @@ int main() {
   }
 
   std::string_view strview = &amp;#34;2.7182818284590452353602874 is e&amp;#34;;
-  
+
   if (auto opt = str_to_double(strview); opt) {
     std::cout &amp;lt;&amp;lt; std::format(&amp;#34;{:.15f}\n&amp;#34;, *opt);
   } else {
@@ -295,7 +325,7 @@ int main() {
 
   const char cstr[] = &amp;#34;1.10001e-01 is Liouville number&amp;#34;;
   std::vector&amp;lt;char&amp;gt; strvec(cstr, std::ranges::end(cstr));
-  
+
   if (auto opt = str_to_double(strvec); opt) {
     std::cout &amp;lt;&amp;lt; std::format(&amp;#34;{:.15f}\n&amp;#34;, *opt);
   } else {
@@ -303,7 +333,7 @@ int main() {
   }
 
   std::span sp{cstr};
-  
+
   if (auto opt = str_to_double(sp); opt) {
     std::cout &amp;lt;&amp;lt; std::format(&amp;#34;{:.15f}\n&amp;#34;, *opt);
   } else {
@@ -349,3 +379,5 @@ int main() {
 - [How to Use The Newest C++ String Conversion Routines - std::from_chars - Bartek&amp;#39;s coding blog ](https://www.bfilipek.com/2018/12/fromchars.html)
 - [P2291R3: Add Constexpr Modifiers to Functions to_chars and from_chars for Integral Types in `&amp;lt;charconv&amp;gt;` Header](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2291r3.pdf)
     - C++23での(1)constexpr指定
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で拡張浮動小数点数型に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- string_view コンストラクタ : LWG Issue 3857対応</title>
      <link href="https://cpprefjp.github.io/reference/string_view/basic_string_view/op_constructor.html"/>
      <id>ceb817552e5037e8511165cd17271d2a86b468ca:reference/string_view/basic_string_view/op_constructor.md</id>
      <updated>2023-03-04T15:42:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string_view/basic_string_view/op_constructor.md b/reference/string_view/basic_string_view/op_constructor.md
index 1fe145265..87c4e8378 100644
--- a/reference/string_view/basic_string_view/op_constructor.md
+++ b/reference/string_view/basic_string_view/op_constructor.md
@@ -44,8 +44,6 @@ constexpr explicit basic_string_view(R&amp;amp;&amp;amp; r);                   // (7) C++23
     - [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`ranges::range_value_t`](/reference/ranges/range_value_t.md)`&amp;lt;R&amp;gt;, charT&amp;gt;`が`true`であること
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;R, const charT*&amp;gt;`が`false`であること
     - `d`を[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;R&amp;gt;`型の左辺値としたとき、`d.operator ::std::basic_string_view&amp;lt;charT, traits&amp;gt;()`が妥当な式ではないこと
-    - もし`R::traits_type`が妥当な型の場合、[`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;R&amp;gt;::traits_type, traits&amp;gt;`が`true`であること
-
 
 ## 事前条件
 - (3) : 範囲`[str, str + Traits::`[`length`](/reference/string/char_traits/length.md)`(str))`が妥当であること (アクセス可能であること)
@@ -181,3 +179,4 @@ int main()
 - [P1989R2 Range constructor for `std::string_view` 2: Constrain Harder](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf)
     - C++23での、レンジ版コンストラクタ追加
 - [P2499R0 `string_view` range constructor should be `explicit`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2499r0.html)
+- [LWG Issue 3857. `basic_string_view` should allow explicit conversion when only traits vary](https://cplusplus.github.io/LWG/issue3857)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>