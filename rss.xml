<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-12T00:49:37.211331</updated>
  <id>0f4b8f4e-3f4b-444b-8022-f1df5eff3403</id>

  
    <entry>
      <title>generator -- generator: 概要説明を修正</title>
      <link href="https://cpprefjp.github.io/reference/generator/generator.html"/>
      <id>58e407c377e144d14665e1825e9b208767c443cc:reference/generator/generator.md</id>
      <updated>2023-01-12T09:44:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/generator/generator.md b/reference/generator/generator.md
index 4335cf0b2..d49ca96d7 100644
--- a/reference/generator/generator.md
+++ b/reference/generator/generator.md
@@ -22,8 +22,10 @@ namespace std {
 戻り値型`generator`のコルーチン（以下、ジェネレータコルーチン）では`co_yield`式を用いて値を生成する。`co_yield` [`std::ranges::elements_of`](/reference/ranges/elements_of.md)`(rng)`式を用いると、ジェネレータコルーチンから入れ子Range(`rng`)の各要素を逐次生成する。
 ジェネレータコルーチンでは`co_await`式を利用できない。
 
-ジェネレータコルーチンは遅延評価される。ジェネレータコルーチンが返す`generator`オブジェクトを利用するコード（以下、ジェネレータ利用側）で先頭要素[`begin`](generator/begin.md)を指す[イテレータ](generator/iterator.md)を間接参照するまで、ジェネレータコルーチンの本体処理は実行されない。
-ジェネレータ利用側がイテレータの間接参照を試みるとジェネレータコルーチンを再開(resume)し、ジェネレータコルーチン本体処理において`co_yield`式に到達すると生成値を保持して再び中断(suspend)する。ジェネレータ利用側ではイテレータの間接参照の結果として生成値を取得する。
+ジェネレータコルーチンは遅延評価される。
+ジェネレータコルーチンが返す`generator`オブジェクトを利用するコード（以下、ジェネレータ利用側）において、先頭要素を指す[イテレータ](generator/iterator.md)を取得する([`begin`](generator/begin.md))、またはイテレータのインクリメント操作を行う(`operator++`)までジェネレータコルーチンは再開(resume)されない。
+ジェネレータコルーチン本体処理において`co_yield`式に到達すると、生成値を保持してから中断(suspend)しジェネレータ利用側へと制御を戻す。
+ジェネレータ利用側ではイテレータの間接参照(単項`operator*`)を行うことで、ジェネレータによる生成値を取得する。
 
 
 ### 説明用メンバ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>apply -- tuple/apply: P2517R1対応(#1098)</title>
      <link href="https://cpprefjp.github.io/reference/tuple/apply.html"/>
      <id>f03abf873882732606460f6f65aaed739389d8d0:reference/tuple/apply.md</id>
      <updated>2023-01-11T18:22:18+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/apply.md b/reference/tuple/apply.md
index 6332df41c..fdc9db56f 100644
--- a/reference/tuple/apply.md
+++ b/reference/tuple/apply.md
@@ -7,7 +7,10 @@
 ```cpp
 namespace std {
   template&amp;lt;class F, class Tuple&amp;gt;
-  constexpr decltype(auto) apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t);
+  constexpr decltype(auto) apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t);  // C++20まで
+
+  template&amp;lt;class F, class Tuple&amp;gt;
+  constexpr decltype(auto) apply(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t) noexcept(see below);  // C++23から
 }
 ```
 
@@ -16,7 +19,7 @@ namespace std {
 
 
 ## 要件
-適用先の関数は[`Callable`](/reference/concepts/Callable.md)要件を満たす（[INVOKE](/reference/concepts/Invoke.md)操作が可能）。展開されるものは、[`std::tuple`](../tuple.md)、[`std::array`](/reference/array/array.md)または[`std::pair`](/reference/utility/pair.md)のように、[`std::get`](/reference/array/array/get.md)と[`std::tuple_size`](/reference/array/array/tuple_size.md)をサポートする必要がある。
+適用先の関数は[`Callable`](/reference/concepts/Callable.md)要件を満たす（[INVOKE](/reference/concepts/Invoke.md)操作が可能）。展開される`Tuple`型は[`std::tuple`](../tuple.md)に限定されず、[`std::array`](/reference/array/array.md)または[`std::pair`](/reference/utility/pair.md)のように、[`std::get`](/reference/array/array/get.md)と[`std::tuple_size`](/reference/array/array/tuple_size.md)をサポートする型であればよい。
 
 
 ## 効果
@@ -28,6 +31,7 @@ constexpr decltype(auto) apply-impl(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t, std::index_sequence&amp;lt;I...&amp;gt;)
   return std::invoke(std::forward&amp;lt;F&amp;gt;(f), std::get&amp;lt;I&amp;gt;(std::forward&amp;lt;Tuple&amp;gt;(t))...);
 }
 ```
+* std::get[link tuple/get.md]
 * std::index_sequence[link /reference/utility/index_sequence.md]
 * std::invoke[link /reference/functional/invoke.md]
 * std::forward[link /reference/utility/forward.md]
@@ -38,11 +42,17 @@ constexpr decltype(auto) apply-impl(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t, std::index_sequence&amp;lt;I...&amp;gt;)
 return apply-impl(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Tuple&amp;gt;(t),
                   std::make_index_sequence&amp;lt;std::tuple_size_v&amp;lt;std::remove_reference_t&amp;lt;Tuple&amp;gt;&amp;gt;&amp;gt;{});
 ```
+* std::tuple_size_v[link tuple_size.md]
 * std::make_index_sequence[link /reference/utility/make_index_sequence.md]
+* std::forward[link /reference/utility/forward.md]
 * std::remove_reference_t[link /reference/type_traits/remove_reference.md]
 
 ## 戻り値
-適用した関数の戻り値である。
+適用した関数呼び出しの戻り値
+
+
+## 例外
+C++23から : `I`をパラメータパック`0, 1, ..., (`[`tuple_size_v`](tuple_size.md)`&amp;lt;`[`remove_reference_t`](/reference/type_traits/remove_reference.md)`&amp;lt;Tuple&amp;gt;&amp;gt;-1)`としたとき、例外指定の式は次と等価 : `noexcept(`[`invoke`](/reference/functional/invoke.md)`(std::forward&amp;lt;F&amp;gt;(f), get&amp;lt;I&amp;gt;(std::forward&amp;lt;Tuple&amp;gt;(t))...))`
 
 
 ## 例
@@ -86,7 +96,7 @@ hello
 
 
 ## 関連項目
-- [make_from_tuple](../tuple/make_from_tuple.md)
+- [`make_from_tuple`](make_from_tuple.md)
 - [`std::tuple`](../tuple.md)
 - [INVOKE](/reference/concepts/Invoke.md)
 
@@ -98,3 +108,5 @@ hello
 - [P0220R0 Adopt Library Fundamentals TS for C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r0.html)
 - [P0220R1 Adopt Library Fundamentals V1 TS Components for C++17 (R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html)
 - [C++1z タプルを展開して関数呼び出しするapply関数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/08/18/184315)
+- [P2517R1 Add a conditional `noexcept` specification to `std::apply`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2517r1.html)
+    - C++23から条件付きで`noexpcet`例外指定が行われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>coroutine_handle -- coroutine: LWG3460を反映</title>
      <link href="https://cpprefjp.github.io/reference/coroutine/coroutine_handle.html"/>
      <id>1f03563fee051b3135a3dd7ea79f14bd01b37ad3:reference/coroutine/coroutine_handle.md</id>
      <updated>2023-01-11T17:17:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/coroutine/coroutine_handle.md b/reference/coroutine/coroutine_handle.md
index 21c3dd67a..da8306f0c 100644
--- a/reference/coroutine/coroutine_handle.md
+++ b/reference/coroutine/coroutine_handle.md
@@ -15,7 +15,7 @@ namespace std {
   };
 
   template&amp;lt;class Promise&amp;gt;
-  struct coroutine_handle : coroutine_handle&amp;lt;&amp;gt; {
+  struct coroutine_handle {
     // (メンバ宣言は省略)
   };
 }
@@ -30,7 +30,7 @@ namespace std {
 例: 後述サンプルコードでは`task`クラス内に隠蔽されており、コルーチン`f`や関数`main`から間接的に利用される。
 
 `coroutine_handle&amp;lt;void&amp;gt;`または単に`coroutine_handle&amp;lt;&amp;gt;`は、Promise型について型消去(Type-erased)されたコルーチンハンドルとして取り扱える。
-コルーチンのPromise型を明示した`coroutine_handle&amp;lt;Promise&amp;gt;`は型消去された`coroutine_handle&amp;lt;&amp;gt;`から公開派生されており、前者から後者への暗黙変換を行うことが可能となっている。
+コルーチンのPromise型を明示した`coroutine_handle&amp;lt;Promise&amp;gt;`から`coroutine_handle&amp;lt;&amp;gt;`へと暗黙変換が可能となっている。
 
 C++コルーチンとC API（コールバック関数へのポインタと`void*`をとる関数）との組合せ利用を可能とするため、`coroutine_handle`とポインタ型`void*`との相互変換がサポートされる。
 
@@ -51,6 +51,12 @@ C++コルーチンとC API（コールバック関数へのポインタと`void*
 |-----------------|----------------|----------------|
 | [`address`](coroutine_handle/address.md) | コルーチンハンドルに対応するアドレス値 | C++20 |
 
+### 変換
+
+| 名前            | 説明          | 対応バージョン |
+|-----------------|---------------|----------------|
+| `operator coroutine_handle&amp;lt;&amp;gt;` | 型消去されたコルーチンハンドルを返す | C++20 |
+
 ### 観測
 
 | 名前            | 説明           | 対応バージョン |
@@ -188,3 +194,7 @@ result=42
 
 ## 関連項目
 - [C++20 コルーチン](/lang/cpp20/coroutines.md)
+
+
+## 参照
+- [LWG3460 Unimplementable `noop_coroutine_handle` guarantees](https://cplusplus.github.io/LWG/issue3460)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_promise -- coroutine: LWG3460を反映</title>
      <link href="https://cpprefjp.github.io/reference/coroutine/coroutine_handle/from_promise.html"/>
      <id>1f03563fee051b3135a3dd7ea79f14bd01b37ad3:reference/coroutine/coroutine_handle/from_promise.md</id>
      <updated>2023-01-11T17:17:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/coroutine/coroutine_handle/from_promise.md b/reference/coroutine/coroutine_handle/from_promise.md
index 435c016ff..6b8c9293e 100644
--- a/reference/coroutine/coroutine_handle/from_promise.md
+++ b/reference/coroutine/coroutine_handle/from_promise.md
@@ -25,6 +25,10 @@ Promiseオブジェクトから対応するコルーチンハンドルを取得
 [`addressof`](/reference/memory/addressof.md)`(h.`[`promise()`](promise.md)`) ==` [`addressof`](/reference/memory/addressof.md)`(p)`
 
 
+## 備考
+型消去されたコルーチンハンドル`coroutine_handle&amp;lt;&amp;gt;`では、本メンバ関数は提供されない。
+
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>promise -- coroutine: LWG3460を反映</title>
      <link href="https://cpprefjp.github.io/reference/coroutine/coroutine_handle/promise.html"/>
      <id>1f03563fee051b3135a3dd7ea79f14bd01b37ad3:reference/coroutine/coroutine_handle/promise.md</id>
      <updated>2023-01-11T17:17:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/coroutine/coroutine_handle/promise.md b/reference/coroutine/coroutine_handle/promise.md
index 2d36ee9b0..46057acdc 100644
--- a/reference/coroutine/coroutine_handle/promise.md
+++ b/reference/coroutine/coroutine_handle/promise.md
@@ -21,6 +21,10 @@ Promise&amp;amp; promise() const;
 コルーチンのPromiseオブジェクトへの参照。
 
 
+## 備考
+型消去されたコルーチンハンドル`coroutine_handle&amp;lt;&amp;gt;`では、本メンバ関数は提供されない。
+
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>noop_coroutine_handle -- coroutine: LWG3460を反映</title>
      <link href="https://cpprefjp.github.io/reference/coroutine/noop_coroutine_handle.html"/>
      <id>1f03563fee051b3135a3dd7ea79f14bd01b37ad3:reference/coroutine/noop_coroutine_handle.md</id>
      <updated>2023-01-11T17:17:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/coroutine/noop_coroutine_handle.md b/reference/coroutine/noop_coroutine_handle.md
index e9a3cdd3f..074d574d3 100644
--- a/reference/coroutine/noop_coroutine_handle.md
+++ b/reference/coroutine/noop_coroutine_handle.md
@@ -9,8 +9,10 @@ namespace std {
   struct noop_coroutine_promise {};
 
   template&amp;lt;&amp;gt;
-  struct coroutine_handle&amp;lt;noop_coroutine_promise&amp;gt; : coroutine_handle&amp;lt;&amp;gt;
+  struct coroutine_handle&amp;lt;noop_coroutine_promise&amp;gt;
   {
+    constexpr operator coroutine_handle&amp;lt;&amp;gt;() const noexcept;
+
     constexpr explicit operator bool() const noexcept;
     constexpr bool done() const noexcept;
 
@@ -29,8 +31,7 @@ namespace std {
   using noop_coroutine_handle = coroutine_handle&amp;lt;noop_coroutine_promise&amp;gt;;
 }
 ```
-* coroutine_handle&amp;lt;&amp;gt;[link coroutine_handle.md]
-* coroutine_handle&amp;lt;noop_coroutine_promise&amp;gt;[link coroutine_handle.md]
+* coroutine_handle[link coroutine_handle.md]
 * unspecified[italic]
 
 
@@ -41,6 +42,11 @@ namespace std {
 
 
 ## メンバ関数
+### 変換
+| 名前            | 説明          | 対応バージョン |
+|-----------------|---------------|----------------|
+| `operator coroutine_handle&amp;lt;&amp;gt;` | 型消去されたコルーチンハンドルを返す | C++20 |
+
 ### 観測
 
 | 名前            | 説明          | 対応バージョン |
@@ -87,4 +93,4 @@ namespace std {
 
 ## 参照
 - [P0913R1 Add symmetric coroutine control transfer](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0913r1.html)
-- [LWG3460. Unimplementable noop_coroutine_handle guarantees](https://cplusplus.github.io/LWG/issue3460)
+- [LWG3460 Unimplementable `noop_coroutine_handle` guarantees](https://cplusplus.github.io/LWG/issue3460)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generator -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/generator/generator.html"/>
      <id>df12b1d5f5725ef7c6ee40a770de935c3450af1c:reference/generator/generator.md</id>
      <updated>2023-01-11T15:15:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/generator/generator.md b/reference/generator/generator.md
index 565e90fa1..4335cf0b2 100644
--- a/reference/generator/generator.md
+++ b/reference/generator/generator.md
@@ -82,7 +82,7 @@ namespace std {
 ### アロケータサポート
 `generator`クラステンプレートの第3テンプレートパラメータ`Allocator`によって、[コルーチン・ステート](/lang/cpp20/coroutines.md)の動的メモリ確保に用いる静的アロケータ型を指定できる。省略時はデフォルトアロケータ[`allocator&amp;lt;byte&amp;gt;`](/reference/memory/allocator.md)が利用される。
 
-またジェネレータコルーチン定義の引数リストに[`allocator_arg`](reference/memory/allocator_arg_t.md)タグ型に続いてアロケータオブジェクトを指定すると、ジェネレータの生成毎に異なるアロケータ利用を指定することもできる。
+またジェネレータコルーチン定義の引数リストに[`allocator_arg`](/reference/memory/allocator_arg_t.md)タグ型に続いてアロケータオブジェクトを指定すると、ジェネレータの生成毎に異なるアロケータ利用を指定することもできる。
 
 C++コンパイラによっては、ジェネレータコルーチンに関する動的メモリ確保・解放処理は最適化によって省略され(coroutine elision)、より効率的なコードが生成されることも期待できる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>generator -- generator: クラスユーザ観点での説明追加</title>
      <link href="https://cpprefjp.github.io/reference/generator/generator.html"/>
      <id>66d4dc66d3f2259e546b1f7bc5591cf53bb8cc2c:reference/generator/generator.md</id>
      <updated>2023-01-11T11:08:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/generator/generator.md b/reference/generator/generator.md
index c7e1c9d10..565e90fa1 100644
--- a/reference/generator/generator.md
+++ b/reference/generator/generator.md
@@ -22,8 +22,8 @@ namespace std {
 戻り値型`generator`のコルーチン（以下、ジェネレータコルーチン）では`co_yield`式を用いて値を生成する。`co_yield` [`std::ranges::elements_of`](/reference/ranges/elements_of.md)`(rng)`式を用いると、ジェネレータコルーチンから入れ子Range(`rng`)の各要素を逐次生成する。
 ジェネレータコルーチンでは`co_await`式を利用できない。
 
-ジェネレータコルーチンは遅延評価される。ジェネレータコルーチンが返す`generator`オブジェクトの利用側（以下、呼び出し側）で先頭要素[`begin`](generator/begin.md)を指す[イテレータ](generator/iterator.md)を間接参照するまで、ジェネレータコルーチンの本体処理は実行されない。
-呼び出し側がイテレータの間接参照を試みるとジェネレータコルーチンを再開(resume)し、ジェネレータコルーチン本体処理において`co_yield`式に到達すると生成値を保持して再び中断(suspend)する。呼び出し側ではイテレータの間接参照の結果として生成値を取得する。
+ジェネレータコルーチンは遅延評価される。ジェネレータコルーチンが返す`generator`オブジェクトを利用するコード（以下、ジェネレータ利用側）で先頭要素[`begin`](generator/begin.md)を指す[イテレータ](generator/iterator.md)を間接参照するまで、ジェネレータコルーチンの本体処理は実行されない。
+ジェネレータ利用側がイテレータの間接参照を試みるとジェネレータコルーチンを再開(resume)し、ジェネレータコルーチン本体処理において`co_yield`式に到達すると生成値を保持して再び中断(suspend)する。ジェネレータ利用側ではイテレータの間接参照の結果として生成値を取得する。
 
 
 ### 説明用メンバ
@@ -39,6 +39,61 @@ namespace std {
 - [`unique_ptr`](/reference/memory/unique_ptr.md)`&amp;lt;`[`stack`](/reference/stack/stack.md)`&amp;lt;`[`coroutine_handle&amp;lt;&amp;gt;`](/reference/coroutine/coroutine_handle.md)`&amp;gt;&amp;gt;`: アクティブスタック(`active_`)
 
 
+### 第1テンプレートパラメータ`Ref`の概要
+`generator`クラステンプレートでは、テンプレートパラメータ`Ref`, `V`の組み合わせによってco_yieldオペランド型(`yielded`)やイテレータ間接参照の結果型(`reference`)や[イテレータの値型(`value_type`)](generator/iterator.md)を制御する。
+
+第1パラメータ`Ref`以外は省略可能となっており、ほとんどのユースケース（提案文書によれば98%）では、テンプレートパラメータ`Ref`のみの明示指定で十分とされる。
+値型`T`を生成するジェネレータにおいて、第1テンプレートパラメータ`Ref`に応じて関連する型がそれぞれ導出される。
+
+|`Ref`|co_yieldオペランド型|間接参照の結果型|イテレータの値型|
+|-----|----|----|----|
+|`T`&amp;lt;br/&amp;gt;`T&amp;amp;&amp;amp;`|`T&amp;amp;&amp;amp;` と `const T&amp;amp;`|`T&amp;amp;&amp;amp;`|`T`|
+|`T&amp;amp;`|`T&amp;amp;`|`T&amp;amp;`|`T`|
+|`const T&amp;amp;`|`const T&amp;amp;`|`const T&amp;amp;`|`T`|
+
+ジェネレータそれ自身ではイテレータの値型を直接利用しない。ジェネレータ利用側でイテレータの`value_type`型にアクセスする特殊な追加処理を行う場合のみ、第2テンプレートパラメータ`V`の明示指定が必要とされる。
+
+
+### ジェネレータと値のコピー／ムーブ
+`generator`クラステンプレートでは、その内部動作において最低限のコピー／ムーブ処理しか行わないよう設計されている。このため一定条件を満たせば、コピー不可でムーブのみ可能な型や、コピー／ムーブいずれも不可能な型の生成もサポートする。
+
+値型`T`を生成するジェネレータにおいて、第1テンプレートパラメータ`Ref`とco_yield演算子オペランドに指定する式（左辺値／右辺値やconst修飾）に応じて、ジェネレータコルーチン最大1回のコピーが発生する。
+`Ref=T&amp;amp;`とした場合、co_yieldに右辺値を指定するとコンパイルエラーになる。
+
+|`Ref`＼co_yield式|左辺値|const左辺値|右辺値|
+|-----|----|----|----|
+|`T`&amp;lt;br/&amp;gt;`T&amp;amp;&amp;amp;`|コピー 1回|コピー 1回|0回|
+|`T&amp;amp;`|コピー 1回|コピー 1回|(不適格)|
+|`const T&amp;amp;`|0回|0回|0回|
+
+またジェネレータ利用側においては、イテレータ間接参照結果を受ける変数の宣言型`X`との関係に応じて（例：[範囲for文](/lang/cpp11/range_based_for.md)の変数宣言型）、最大で1回のコピーまたはムーブが生じる。
+`Ref=T&amp;amp;`または`Ref=const T&amp;amp;`とした場合、右辺値参照型`T&amp;amp;&amp;amp;`には束縛できないためコンパイルエラーとなる。
+
+|`Ref`＼`X`|`T`|`T&amp;amp;&amp;amp;`|`const T&amp;amp;`|
+|-----|----|----|----|
+|`T`&amp;lt;br/&amp;gt;`T&amp;amp;&amp;amp;`|ムーブ 1回|0回|0回|
+|`T&amp;amp;`|コピー 1回|(不適格)|0回|
+|`const T&amp;amp;`|コピー 1回|(不適格)|0回|
+
+ムーブのみ可能な型（例：[`std::unique_ptr`](/reference/memory/unique_ptr.md)）では、上記表においてコピーが生じる組み合わせを避ければジェネレータより生成可能である。
+同様にコピー／ムーブいずれも不可能な型では、コピーまたはムーブが生じる組み合わせを避ければ生成可能である。
+
+
+### アロケータサポート
+`generator`クラステンプレートの第3テンプレートパラメータ`Allocator`によって、[コルーチン・ステート](/lang/cpp20/coroutines.md)の動的メモリ確保に用いる静的アロケータ型を指定できる。省略時はデフォルトアロケータ[`allocator&amp;lt;byte&amp;gt;`](/reference/memory/allocator.md)が利用される。
+
+またジェネレータコルーチン定義の引数リストに[`allocator_arg`](reference/memory/allocator_arg_t.md)タグ型に続いてアロケータオブジェクトを指定すると、ジェネレータの生成毎に異なるアロケータ利用を指定することもできる。
+
+C++コンパイラによっては、ジェネレータコルーチンに関する動的メモリ確保・解放処理は最適化によって省略され(coroutine elision)、より効率的なコードが生成されることも期待できる。
+
+
+### ジェネレータのネスト
+別の子ジェネレータコルーチンが返す`generator`もRangeとなっているため、ある親ジェネレータコルーチン内部で`co_yield` [`std::ranges::elements_of`](/reference/ranges/elements_of.md)構文を用いると、複数ジェネレータコルーチンのネスト構造をとることができる。
+子ジェネーレタコルーチンの遅延評価によって生成される値は、親ジェネレータコルーチンから生成されたかのように振る舞う。
+
+`generator`クラス（厳密には[`generator::promise_type`](generator/promise_type.md)）ではジェネレータコルーチンのネスト構造を検出し、[対称コルーチン](/lang/cpp20/coroutines.md)としてコルーチン間の実行フロー転送制御を効率的に行う。
+
+
 ## 適格要件
 - テンプレートパラメータ`Allocator`が`void`ではない場合、[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;Allocator&amp;gt;::pointer`はポインタ型であること。
 - 説明用のメンバ型`value`はCV修飾されないオブジェクト型であること。
@@ -70,7 +125,7 @@ namespace std {
 
 | 名前            | 説明        | 対応バージョン |
 |-----------------|-------------|-------|
-| `yielded`      | `co_yield`式の引数型（後述） | C++23 |
+| `yielded`      | `co_yield`演算子オペランド型（後述） | C++23 |
 | [`promise_type`](generator/promise_type.md) | ジェネレータコルーチンのPromise型 | C++23 |
 
 ``` cpp
@@ -169,7 +224,7 @@ struct node {
   std::unique_ptr&amp;lt;node&amp;gt; right = nullptr;
 };
 
-// 二分木を幅優先走査: 左(left)→自ノード→右(right)
+// 二分木を走査: 左(left)→自ノード→右(right)
 std::generator&amp;lt;int&amp;gt; traverse(const node&amp;amp; e)
 {
   if (e.left) {
@@ -236,3 +291,5 @@ int main()
 
 ## 参照
 - [P2502R2 `std::generator`: Synchronous Coroutine Generator for Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2502r2.pdf)
+- [P0981R0 Halo: coroutine Heap Allocation eLision Optimization: the joint response](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0981r0.html)
+    - ジェネレータコルーチン実装において、動的メモリ確保が省略最適化される条件の議論。`std::generator`の設計に反映されている。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>get_return_object -- generator: クラスユーザ観点での説明追加</title>
      <link href="https://cpprefjp.github.io/reference/generator/generator/promise_type/get_return_object.html"/>
      <id>66d4dc66d3f2259e546b1f7bc5591cf53bb8cc2c:reference/generator/generator/promise_type/get_return_object.md</id>
      <updated>2023-01-11T11:08:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/generator/generator/promise_type/get_return_object.md b/reference/generator/generator/promise_type/get_return_object.md
index ba9a6baec..c41948ed9 100644
--- a/reference/generator/generator/promise_type/get_return_object.md
+++ b/reference/generator/generator/promise_type/get_return_object.md
@@ -12,12 +12,11 @@ generator get_return_object() noexcept;
 
 ## 概要
 ジェネレータ[コルーチン](/lang/cpp20/coroutines.md)の戻り値オブジェクトを生成する。
-戻り値ジェネレータの[アクティブスタック](../../generator.md)を、空(empty)で初期化する。
 プログラマが本関数を直接利用することは想定されていない。
 
 
 ## 戻り値
-[`coroutine_handle`](/reference/coroutine/coroutine_handle.md)`&amp;lt;promise_type&amp;gt;::`[`from_promise`](/reference/coroutine/coroutine_handle/from_promise.md)`(*this)`で取得したコルーチンハンドルを保持する[`generator`](../../generator.md)オブジェクト。
+[`coroutine_handle`](/reference/coroutine/coroutine_handle.md)`&amp;lt;promise_type&amp;gt;::`[`from_promise`](/reference/coroutine/coroutine_handle/from_promise.md)`(*this)`で取得したコルーチンハンドルを保持し、[アクティブスタック](../../generator.md)を空(empty)で初期化した、[`generator`](../../generator.md)オブジェクト。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>