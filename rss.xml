<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-03-31T09:34:51.732904</updated>
  <id>91361647-9d5f-461a-9481-2ad968b5e181</id>

  
    <entry>
      <title>std -- Update std.md</title>
      <link href="https://cpprefjp.github.io/module/std.html"/>
      <id>afd10bb6e3a429da8dd2a5345219ffe5875bec96:module/std.md</id>
      <updated>2024-03-31T18:31:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/module/std.md b/module/std.md
index 8916a34fd..9da6f5bb5 100644
--- a/module/std.md
+++ b/module/std.md
@@ -47,7 +47,23 @@ int main() {
 }
 ```
 
-グローバル名前空間にも定義を導入したい場合、[`std.compat`](std.compat.md)を使用できる。
+グローバル名前空間にも定義を導入したい場合、`std`の代わりに[`std.compat`](std.compat.md)を使用できる(両方を使う必要はない)。
+
+## この機能が必要になった背景・経緯
+
+C++20に言語機能としての[モジュール](/lang/cpp20/modules.md)を追加する議論と並行して、標準ライブラリをモジュールへ再編する議論も行われていた。
+例えば、[P0581R1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0581r1.pdf)では以下のモジュールが提案されている。
+
+- `std.fundamental`
+- `std.core`
+- `std.io`
+- `std.os`
+- `std.concurrency`
+- `std.math`
+- `std`
+
+しかし、標準ライブラリ全体の再編はあまりにも壮大であり、C++20には間に合わなかった。
+これではモジュールの恩恵を受けるのが難しいということで、最小限のモジュールとして`std`がC++23に間に合うように追加された。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>std.compat -- Update std.compat.md</title>
      <link href="https://cpprefjp.github.io/module/std.compat.html"/>
      <id>fef3ffc53cd1ed014b56d454bf06c7caf090a92d:module/std.compat.md</id>
      <updated>2024-03-31T18:11:01+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/module/std.compat.md b/module/std.compat.md
index 3366271e7..c71c00285 100644
--- a/module/std.compat.md
+++ b/module/std.compat.md
@@ -18,6 +18,20 @@ int main() {
 }
 ```
 
+## 備考
+`std.compat`は[`std`](std.md)の内容をすべて含んでいるので、`std.compat`をインポートする場合は[`std`](std.md)をインポートしなくてよい。
+
+## この機能が必要になった背景・経緯
+
+標準ライブラリモジュール[`std`](std.md)で、C言語互換ライブラリの内容をグローバル名前空間に導入するかどうかで意見が分かれた結果、別のモジュールとして用意することになった。
+
+- C言語互換ライブラリの内容をグローバル名前空間に導入しない場合、既存コードベースを移行するのが難しくなる(例えば、`std::size_t`ではなく`size_t`と書いているコードは多いだろう)。
+- 一方、「`&amp;lt;foobar.h&amp;gt;`は確実にグローバル名前空間へ名前を導入する一方、`std`名前空間に導入するかどうかは未規定。`&amp;lt;cfoobar&amp;gt;`はその逆」という混乱した状況を、グローバル名前空間へ名前を導入しない方向へ解決する滅多にない機会でもあった。
+
+そこで、2つのモジュールを用意することで両方の課題を解決することとなった。グローバル名前空間を綺麗にしたいユーザーは[`std`](std.md)のみを使用すればよい。
+一方、既存コードの互換性を重視したいときは、`std.compat`をインポートすればよい。
+ただし、この場合でも標準ライブラリのマクロに依存したコードの互換性はない点には注意が必要である。
+
 ## バージョン
 ### 言語
 - C++23
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format -- Update format.md</title>
      <link href="https://cpprefjp.github.io/reference/format/format.html"/>
      <id>cf1a2310e4c8f7de4b5825b96a5173c7738864a7:reference/format/format.md</id>
      <updated>2024-03-31T04:28:30+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format.md b/reference/format/format.md
index 60a4f19d6..56ac12599 100644
--- a/reference/format/format.md
+++ b/reference/format/format.md
@@ -229,21 +229,24 @@ Range・シーケンスコンテナに対して使用できる標準のオプシ
 
 | range-type | 意味 | 効果 | 対応バージョン |
 |------------|------|------|----------------|
-| m    | `std::map`出力向けの書式 | 全体の囲み文字を`[ ]`の代わりに`{ }`とする。要素型がtuple-like型であれば要素型にも`m`書式を適用する | C++23 |
+| m    | `std::map`出力向けの書式 | 全体の囲み文字を`[ ]`の代わりに`{ }`とする。要素型にも`m`書式を適用する | C++23 |
 | s    | 文字列として出力 | 要素型が文字型であること。エスケープ処理しない文字列として書式化する | C++23 |
 | ?s   | デバッグ文字列として出力 | 要素型が文字型であること。エスケープした文字列として書式化する | C++23 |
 
-- `?s`書式を指定した場合、`n`オプションと、`range-underlying-spec`は指定できない。
+- `m`書式は、要素が[`std::pair`](/reference/utility/pair.md)とサイズ2の[`std::tuple`](/reference/tuple/tuple.md)の場合のみ指定できる
+- `?s`書式を指定した場合、`n`オプションと、`range-underlying-spec`は指定できない
 - コンテナが[`std::vector`](/reference/vector/vector.md)`&amp;lt;bool&amp;gt;`である場合、その要素型は`bool`として処理される
 - Range・シーケンスコンテナでは、要素型がデバッグ出力可能である場合、それがデフォルトで有効となる
     - 要素型の書式を指定して、デバッグ出力指定をしなければ、デフォルトで有効になっているデバッグ出力を解除できる
 - コンテナアダプタである[`std::queue`](/reference/queue/queue.md)、[`std::priority_queue`](/reference/queue/priority_queue.md)、[`std::stack`](/reference/stack/stack.md)も使用できる
-
+- [`std::basic_string`](/reference/string/basic_string.md)と[`std::basic_string_view`](/reference/string_view/basic_string_view.md)はRangeでもあるが、特殊化の優先順位によって標準のフォーマッターが選択されるため、Rangeとしてフォーマットすることはできない
 
 #### &amp;lt;a id=&amp;#34;assoc-format-options&amp;#34; href=&amp;#34;#assoc-format-options&amp;#34;&amp;gt;連想コンテナの書式 (C++23)&amp;lt;/a&amp;gt;
 
-Range・シーケンスコンテナと同じだが、デフォルトで`m`書式を適用する。
+Range・シーケンスコンテナと同じだが、デフォルトで囲み文字を`{ }`とする。
 
+- メンバ型`key_type`を持つ場合、連想コンテナとみなされる
+- さらに、メンバ型`mapped_type`を持ち、要素が[`std::pair`](/reference/utility/pair.md)またはサイズ2の[`std::tuple`](/reference/tuple/tuple.md)の場合、`map`互換のコンテナとみなされる。このとき、要素にも`m`書式を用いる
 
 #### &amp;lt;a id=&amp;#34;tuple-format-options&amp;#34; name=&amp;#34;#tuple-format-options&amp;#34;&amp;gt;pair、tupleの書式 (C++23)&amp;lt;/a&amp;gt;
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- Merge pull request #1264 from nakashima-hikaru/patch-1</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy.html"/>
      <id>7d4583d1842b717af62f9bcb2357c1557cf97831:reference/algorithm/ranges_copy.md</id>
      <updated>2024-03-30T23:52:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy.md b/reference/algorithm/ranges_copy.md
index 2e773767f..6b1d7d137 100644
--- a/reference/algorithm/ranges_copy.md
+++ b/reference/algorithm/ranges_copy.md
@@ -75,8 +75,8 @@ int main() {
   std::vector&amp;lt;int&amp;gt; v2(v.size()); // ちゃんと確保しておくこと
   std::ranges::copy(v, v2.begin());
 
-  // back_inserter を使って v3 へ設定。
-  // back_inserter は要素をコピーするときに v3.push_back() するイテレータを作る関数。
+  // back_inserter を使って ls3 へ設定。
+  // back_inserter は要素をコピーするときに ls3.push_back() するイテレータを作る関数。
   std::list&amp;lt;int&amp;gt; ls3;
   std::ranges::copy(v2, std::back_inserter(ls3));
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- Update ranges_copy.md</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy.html"/>
      <id>2bb90e8bb43097dffc3c2bc4753b24b39c9ab35c:reference/algorithm/ranges_copy.md</id>
      <updated>2024-03-30T20:20:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy.md b/reference/algorithm/ranges_copy.md
index 2e773767f..6b1d7d137 100644
--- a/reference/algorithm/ranges_copy.md
+++ b/reference/algorithm/ranges_copy.md
@@ -75,8 +75,8 @@ int main() {
   std::vector&amp;lt;int&amp;gt; v2(v.size()); // ちゃんと確保しておくこと
   std::ranges::copy(v, v2.begin());
 
-  // back_inserter を使って v3 へ設定。
-  // back_inserter は要素をコピーするときに v3.push_back() するイテレータを作る関数。
+  // back_inserter を使って ls3 へ設定。
+  // back_inserter は要素をコピーするときに ls3.push_back() するイテレータを作る関数。
   std::list&amp;lt;int&amp;gt; ls3;
   std::ranges::copy(v2, std::back_inserter(ls3));
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>hnakashima</name>
        <email>69759577+nakashima-hikaru@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>