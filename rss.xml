<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-04-20T16:39:31.715403</updated>
  <id>05adafb4-bfd4-4bd1-843a-a8c738467c76</id>

  
    <entry>
      <title>ほとんどの`volatile`を非推奨化 -- 文面調整</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html"/>
      <id>e2cb1b6933c302c5f58cfe0882acf31910f0a524:lang/cpp20/deprecating_volatile.md</id>
      <updated>2021-04-21T01:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecating_volatile.md b/lang/cpp20/deprecating_volatile.md
index 1554aef9f..68d695f10 100644
--- a/lang/cpp20/deprecating_volatile.md
+++ b/lang/cpp20/deprecating_volatile.md
@@ -9,7 +9,7 @@ C++20より、`volatile`の本来の役割に照らして不正確、あるい
 
 ## `volatile`
 
-`volatile`な変数（メモリ領域）への1度のアクセスは正確に1度だけ行われる必要があり、0回にも2回にもなってはならない。そして、`volatile`領域へのアクセスはその順序がコード上の順序と一致する必要がある。
+`volatile`な変数（メモリ領域）への1度のアクセスは正確に1度だけ行われる必要があり、0回にも2回以上にもなってはならない。そして、`volatile`領域へのアクセスはその順序がコード上の順序と一致する必要がある。
 
 `volatile`の効果（保証）は単純にはこれだけである。
 
@@ -100,7 +100,7 @@ v1 = n = v3;      // OK
 
 また、呼出規約によっては一部の引数を配置するレジスタが`volatile`となる事があるが、呼出規約はC++コード上で意味を持たず、そのような呼び出し規約がマークされている関数は非`volatile`関数宣言と同様に扱われる。しかし、一部のレジスタが`volatile`である事はABIによって処理されている。
 
-結局、関数引数の`volatile`修飾は有用ではないため非推奨とされる。関数の引数を`volatile`としたい場合、関数内で`volatile`ローカル変数に引数をコピーする事が推奨される。一部の実装では、そのようなコピーは省略され、オーバーヘッドとはならない。
+このように、関数引数の`volatile`修飾は有用ではないため非推奨とされる。関数の引数を`volatile`としたい場合、関数内で`volatile`ローカル変数に引数をコピーする事が推奨される。一部の実装では、そのようなコピーは省略され、オーバーヘッドとはならない。
 
 ```cpp
 void f1(volatile int n);   // NG（非推奨）
@@ -113,7 +113,7 @@ void f6(int * volatile p); // NG（非推奨）
 
 また、参照・ポインタではない関数戻り値型の`volatile`修飾は完全に意味を持たない。
 
-例えば、ローカル`volatile`変数を返す場合、そのアクセスは関数リターン時に値をコピーするために一度実行されるが、コピーした後の値はもはや元の`volatile`領域とは別の場所にある。`volatile`において重要なのは特定領域へのアクセスであり、暗黙にそのようなコピーが走る事はほとんどの場合にプログラマの意図とは異なる。
+例えば、ローカル`volatile`変数を返す場合、そのアクセスは関数リターン時に値をコピーするために一度実行されるが、コピーした後の値はもはや元の`volatile`領域とは別のスタック領域にある。`volatile`において重要なのは特定領域へのアクセスであり、暗黙にそのようなコピーが行われる事はほとんどの場合にプログラマの意図とは異なる。
 
 ローカルの非`volatile`変数を`volatile`として返すことには意味がない。戻り値を`volatile`領域に配置したい場合、関数の呼び出し側で`volatile`変数に受ければよい。
 
@@ -159,13 +159,13 @@ volatile auto [a, b, c] = array; // OK
 static_assert(std::is_volatile_v&amp;lt;decltype(a)&amp;gt;); // OK
 ```
 
-このような非一貫性の他にも、構造化束縛の裏で行われている事が`volatile`には適さない。
+このような挙動の非一貫性を受け入れたとしても、構造化束縛の裏で行われている事が`volatile`には適していない。
 
-構造化束縛の`volatile`修飾はその右辺にある暗黙のオブジェクトに対して行われるが、その事は構文からは完全に隠蔽されている。右辺の式の結果オブジェクトも場合によってコピーされたり参照のまま利用されたりと、扱いが変化しうる。また、構造化束縛宣言に指定した変数名はコンパイラの扱いとしては変数名ではなく、右辺の暗黙のオブジェクト内の対応する要素にバインドされた名前でしかない。そのような名前に対する`volatile`の効果は不明瞭であり、右辺の式の直接の結果の型もその要素の型も`volatile`ではない場合には意味をなさない。
+構造化束縛の`volatile`修飾はその右辺にある暗黙のオブジェクトに対して行われるが、その事は構文からは完全に隠蔽されている。右辺の式の結果オブジェクトも場合によってコピーされたり参照のまま利用されたりと、扱いが変化しうる。また、構造化束縛宣言に指定した変数名はコンパイラの扱いとしては変数名ではなく、右辺の暗黙のオブジェクト内の対応する要素にバインドされた名前でしかない。そのような名前に対する`volatile`の効果は不明瞭であり、束縛先の要素の型が`volatile`ではない場合には意味をなさない。
 
-`volatile`においてはその領域へのアクセスが重要であり、1度のアクセスは正確に1度だけ行われる必要があり、その順序は前後してはならない。構造化束縛宣言はその裏側で多くの事が起こりそれは場合によって変化しうるが、そこでどのオブジェクトが`volatile`となりどのような順番でアクセスが発生するのかは非常に不透明である。
+`volatile`においてはその領域へのアクセスが重要であり、1度のアクセスは正確に1度だけ行われる必要があり、その順序は前後してはならない。構造化束縛宣言はその裏側で多くの事が行われており、それはCV・参照修飾と右辺の式の結果型によって様々に変化するが、そこでどのオブジェクトが`volatile`となりどのような順番でアクセスが発生するのかは非常に不明瞭である。
 
-従って、構造化束縛宣言の`volatile`修飾は非推奨とされる。
+従って、構造化束縛宣言の`volatile`修飾を正しく扱う事は非常に困難であるため、非推奨とされる。
 
 構造化束縛した名前が`volatile`である必要がある場合は、分解対象の右辺の結果オブジェクトの各要素型をあらかじめ`volatile`修飾しておく事が推奨される。
 
@@ -180,6 +180,15 @@ auto g() -&amp;gt; std::tuple&amp;lt;volatile int*, volatile int*, volatile double&amp;amp;&amp;gt;;
 auto [a, b, c] = g();  // OK
 ```
 
+この場合でも、各要素型のトップレベル`volatile`修飾は意味をなさない。
+
+```cpp
+auto f() -&amp;gt; std::tuple&amp;lt;volatile int, volatile int, volatile double&amp;gt;;
+
+auto [a, b, c] = f();  // OK、要素ごとコピーされている、volatile修飾は無意味
+auto&amp;amp;&amp;amp; [a, b, c] = f();  // OK、一時オブジェクト内各要素へのバインド、volatile修飾は無意味
+```
+
 ## ライブラリにおける非推奨化
 （執筆中）
 
@@ -205,4 +214,4 @@ auto [a, b, c] = g();  // OK
 - [P1152R2 Deprecating `volatile`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1152r2)
 - [P1152R4 Deprecating `volatile`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1152r4.html)
 - [P1831R0 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1831r0.html)
-- [P1831R0 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
\ No newline at end of file
+- [P1831R0 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform -- 前後の説明に合わせて変数名を修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/transform.html"/>
      <id>33d4c2c29271fd969b9513d9c01e1194e2550ac1:reference/algorithm/transform.md</id>
      <updated>2021-04-20T21:10:00+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/transform.md b/reference/algorithm/transform.md
index ecb542eeb..2fde7dbbf 100644
--- a/reference/algorithm/transform.md
+++ b/reference/algorithm/transform.md
@@ -82,7 +82,7 @@ namespace std {
 
 ## 計算量
 - (1) : 正確に `last - first` 回の `op` の適用が行われる。
-- (2) : 正確に `last - first` 回の `binary_op` の適用が行われる。
+- (2) : 正確に `last1 - first1` 回の `binary_op` の適用が行われる。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>komori-n</name>
        <email>ikamat.kmr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ほとんどの`volatile`を非推奨化 -- deprecating volatile : 構造化束縛追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html"/>
      <id>f7e9fce4d5d5a4a566d20f7f1db91404a8d19061:lang/cpp20/deprecating_volatile.md</id>
      <updated>2021-04-20T16:23:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecating_volatile.md b/lang/cpp20/deprecating_volatile.md
index 4dadf76cf..1554aef9f 100644
--- a/lang/cpp20/deprecating_volatile.md
+++ b/lang/cpp20/deprecating_volatile.md
@@ -134,7 +134,51 @@ int* volatile f6();   // NG（非推奨）
 
 
 ### 構造化束縛宣言
-（執筆中）
+
+構造化束縛宣言にも`volatile`修飾を行う事ができるが、ここでのCV修飾は右辺にある式の結果である暗黙のオブジェクトに対して作用している。
+
+右辺の式の結果が`std::tuple/std::pair`等の`tuple-like`な型のオブジェクトである場合、構造化束縛はまずその結果オブジェクトを`volatile`修飾して受けておき、その結果オブジェクトに対して`std::get`で要素の取得を行う。しかし、`std::get`には`volatile`オーバーロードが欠けており、コンパイルエラーを起こす。
+
+一方、構造化束縛の残りのケース（配列・構造体）の場合は`std::get`を用いないためこのような問題は起こらない。
+
+```cpp
+auto f() -&amp;gt; std::tuple&amp;lt;int, int, double&amp;gt;;
+
+volatile auto [a, b, c] = f();  // NG
+// ここでは以下の様な事が行われている
+// volatile auto tmp = f();
+// std::tuple_element_t&amp;lt;0, decltype(tmp)&amp;gt; a = std::get&amp;lt;0&amp;gt;(tmp);
+
+int array[3]{};
+
+volatile auto [a, b, c] = array; // OK
+// ここでは以下の様な事が行われている
+// volatile int tmp[] = {array[0], array[1], array[2]};
+// volatile int a = tmp[0];
+
+static_assert(std::is_volatile_v&amp;lt;decltype(a)&amp;gt;); // OK
+```
+
+このような非一貫性の他にも、構造化束縛の裏で行われている事が`volatile`には適さない。
+
+構造化束縛の`volatile`修飾はその右辺にある暗黙のオブジェクトに対して行われるが、その事は構文からは完全に隠蔽されている。右辺の式の結果オブジェクトも場合によってコピーされたり参照のまま利用されたりと、扱いが変化しうる。また、構造化束縛宣言に指定した変数名はコンパイラの扱いとしては変数名ではなく、右辺の暗黙のオブジェクト内の対応する要素にバインドされた名前でしかない。そのような名前に対する`volatile`の効果は不明瞭であり、右辺の式の直接の結果の型もその要素の型も`volatile`ではない場合には意味をなさない。
+
+`volatile`においてはその領域へのアクセスが重要であり、1度のアクセスは正確に1度だけ行われる必要があり、その順序は前後してはならない。構造化束縛宣言はその裏側で多くの事が起こりそれは場合によって変化しうるが、そこでどのオブジェクトが`volatile`となりどのような順番でアクセスが発生するのかは非常に不透明である。
+
+従って、構造化束縛宣言の`volatile`修飾は非推奨とされる。
+
+構造化束縛した名前が`volatile`である必要がある場合は、分解対象の右辺の結果オブジェクトの各要素型をあらかじめ`volatile`修飾しておく事が推奨される。
+
+```cpp
+auto f() -&amp;gt; std::tuple&amp;lt;int, int, double&amp;gt;;
+int array[3]{};
+
+volatile auto [a, b, c] = f();   // NG（非推奨）
+volatile auto [a, b, c] = array; // NG（非推奨）
+
+auto g() -&amp;gt; std::tuple&amp;lt;volatile int*, volatile int*, volatile double&amp;amp;&amp;gt;;
+auto [a, b, c] = g();  // OK
+```
 
 ## ライブラリにおける非推奨化
 （執筆中）
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ほとんどの`volatile`を非推奨化 -- deprecating volatile : 関数引数・戻り値型、追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/deprecating_volatile.html"/>
      <id>a0858e9072352ecadbcf90de84d40177c7f69544:lang/cpp20/deprecating_volatile.md</id>
      <updated>2021-04-19T17:15:21+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/deprecating_volatile.md b/lang/cpp20/deprecating_volatile.md
index 125917a89..4dadf76cf 100644
--- a/lang/cpp20/deprecating_volatile.md
+++ b/lang/cpp20/deprecating_volatile.md
@@ -5,7 +5,7 @@
 
 C++20より、`volatile`の本来の役割に照らして不正確、あるいは誤解を招く用法や無意味な用法について非推奨とされるようになる。
 
-非推奨とされるだけで削除はされていないが、おそらくコンパイラはそれらの用法について警告を発するようになる。そのような用法はバグの原因となり危険であるため可能な限り使用を避けるべきである。
+非推奨とされるだけで削除されてはいないが、おそらくコンパイラはそれらの用法について警告を発するようになる。そのような用法はバグの原因となり危険であるため可能な限り使用を避けるべきである。
 
 ## `volatile`
 
@@ -19,13 +19,13 @@ C++20より、`volatile`の本来の役割に照らして不正確、あるい
 
 また、`volatile`はC++メモリモデルの一部ではなく、`volatile`領域へのアクセス順序とはC++メモリモデルにおける観測可能な順序を意味しない。プロセッサはC++コード上での順序で読み取った`volatile`領域へのアクセス命令を、アウトオブオーダーで発行・実行することができる。メモリモデルにおいて動作が保証されている同期機構を用いない場合、あるコアにおける命令の実行順は、他のコア（あるいはプロセッサの外部）からは異なった順序で実行されたかのように観測されうる。
 
-`volatile`は主として、プログラムの実行環境のハードウェアなどのプログラム外部の環境との通信手段の一つとして利用され、スレッド間のやりとりなどプログラム内部での通信の手段としては適さない。そのような`vlatile`の正しい用法によるメモリの読み書きは、他のどの手段よりも移植性があり機能的にも優れており、言語機能として有用なものである。
+`volatile`は主として、プログラムの実行環境のハードウェアなどのプログラム外部の環境との通信手段の一つとして利用され、スレッド間のやりとりなどプログラム内部での通信の手段としては適さない。そのような`volatile`の正しい用法によるメモリの読み書きは、他のどの手段よりも移植性があり機能的にも優れており、言語機能として有用なものである。
 
 ## コア言語における非推奨化
 
 ### 複合代入演算子、インクリメント演算子
 
-複合代入演算子とは`+= -= *= /=`など、ある操作とその結果の代入をまとめて行うような演算子のことである。
+複合代入演算子とは`*= /= %=  += -= &amp;gt;&amp;gt;= &amp;lt;&amp;lt;= &amp;amp;= ^= |=`の10個の演算子のことで、ある操作とその結果の代入をまとめて行うような演算子のことである。
 
 複合代入演算子およびインクリメント演算子は、「読み出し - 更新（処理） - 書き込み」という3つの操作を1文で行う。
 
@@ -47,7 +47,7 @@ a--;
 // a = tmp - 1;
 ```
 
-複合代入演算子の左辺にある変数、およびインクリメント演算子のオペランドには2回のアクセス（読み込みと書き込み1回づつ）が発生するが、このアクセスは複合代入演算子やインクリメント演算子の見た目や一般的な理解とは必ずしも一致しない。
+複合代入演算子の左辺にある`volatile`変数、およびインクリメント演算子の`volatile`オペランドには2回のアクセス（読み込みと書き込み1回づつ）が発生するが、このアクセスは複合代入演算子やインクリメント演算子の見た目や一般的な理解とは必ずしも一致しない。
 
 `volatile`変数においてはそのアクセス（読み書き）が重要であり、コード上での1回のアクセスは実行時にも1回だけアクセスされる必要がある。しかし、複合代入演算子およびインクリメント演算子のアクセス回数は多くのプログラマにとって曖昧であるか、誤解されている。
 
@@ -71,9 +71,9 @@ a = b = c = 10;
 
 このような連なった代入演算子の用法においては、どの変数にどんな順番で何回アクセスされるのかが非常に分かりづらくなる。
 
-`volatile`変数においてはそのアクセス（読み書き）が重要であり、コード上での1回のアクセスは実行時にも1回だけアクセスされ、かつその順番が前後してはならない。
+`volatile`変数においてはそのアクセス（読み書き）が重要であり、コード上での1回のアクセスは実行時にも1回だけアクセスされ、かつその順番が前後してはならない。しかし、代入演算子を連鎖させた場合、そのアクセス回数および順序は非常に認識しづらくなる。
 
-従って、非クラス型の`volatile`変数に対するこのような組み込みの代入演算子の使用はバグの元であるので、非推奨とされる。
+従って、非クラス型の`volatile`変数に対するこのような代入演算子の使用はバグの元であるので、非推奨とされる。
 
 ただし、非推奨となるのは代入演算子の両端のオペランド以外に`volatile`変数が表れるケースである。
 
@@ -93,7 +93,45 @@ v1 = n = v3;      // OK
 ```
 
 ### 関数引数と戻り値型
-（執筆中）
+
+関数引数を`volatile`修飾することは、シグナルや`setjmp/longjmp`によって外部から変更されている可能性を示唆するために有効であり、引数の`const`修飾同様に関数定義内では明確な意味を持つ。
+
+一方呼び出し側から見ると、参照・ポインタではない`volatile`引数の意味は不明瞭である。参照・ポインタではない関数引数が`volatile`修飾されている場合、その関数はシグナルハンドラや`setjmp/longjmp`と共に使用されるはずであり、呼び出し側にもそのような実装詳細の一部が漏洩してしまう。
+
+また、呼出規約によっては一部の引数を配置するレジスタが`volatile`となる事があるが、呼出規約はC++コード上で意味を持たず、そのような呼び出し規約がマークされている関数は非`volatile`関数宣言と同様に扱われる。しかし、一部のレジスタが`volatile`である事はABIによって処理されている。
+
+結局、関数引数の`volatile`修飾は有用ではないため非推奨とされる。関数の引数を`volatile`としたい場合、関数内で`volatile`ローカル変数に引数をコピーする事が推奨される。一部の実装では、そのようなコピーは省略され、オーバーヘッドとはならない。
+
+```cpp
+void f1(volatile int n);   // NG（非推奨）
+void f2(volatile int* p);  // OK
+void f3(volatile int&amp;amp; r);  // OK
+void f4(int volatile * p); // OK
+void f5(int volatile &amp;amp; r); // OK
+void f6(int * volatile p); // NG（非推奨）
+```
+
+また、参照・ポインタではない関数戻り値型の`volatile`修飾は完全に意味を持たない。
+
+例えば、ローカル`volatile`変数を返す場合、そのアクセスは関数リターン時に値をコピーするために一度実行されるが、コピーした後の値はもはや元の`volatile`領域とは別の場所にある。`volatile`において重要なのは特定領域へのアクセスであり、暗黙にそのようなコピーが走る事はほとんどの場合にプログラマの意図とは異なる。
+
+ローカルの非`volatile`変数を`volatile`として返すことには意味がない。戻り値を`volatile`領域に配置したい場合、関数の呼び出し側で`volatile`変数に受ければよい。
+
+そして、戻り値型の`volatile`修飾は容易に無視する事ができる。
+
+このように、`volatile`戻り値型は無意味であるため、非推奨とされる。戻り値を`volatile`として扱いたい場合は、戻り値を`volatile`変数に受ければよい。
+
+```cpp
+volatile int  f1();   // NG（非推奨）
+volatile int* f2();   // OK
+volatile int&amp;amp; f3();   // OK
+int volatile* f4();   // OK
+int volatile&amp;amp; f5();   // OK
+int* volatile f6();   // NG（非推奨）
+```
+
+ただし、関数引数・戻り値型いずれにしても、ポインタ・参照への`volatile`修飾は明確な意味を持ち有用である（値ではなく、領域に`volatile`とマークしているため）。従って、非推奨とされるのは関数引数・戻り値型へのトップレベル`volatile`修飾のみであって、`volatile`ポインタ・参照型は依然として許可される。
+
 
 ### 構造化束縛宣言
 （執筆中）
@@ -101,11 +139,13 @@ v1 = n = v3;      // OK
 ## ライブラリにおける非推奨化
 （執筆中）
 
-## この機能が必要になった背景・経緯
-（執筆中）
-
 ## 検討されたほかの選択肢
-（執筆中）
+
+### 関数引数・戻り値型への`const`修飾
+
+関数引数・戻り値型への`volatile`修飾が非推奨とされたのとほぼ同様の理由によって、`const`修飾も非推奨とする事が提案されていたが、合意が取れなかったため非推奨とはならなかった。
+
+おそらく、間違っていたり意味がなかったとしても、`volatile`と比べて幅広く使用されているために非推奨とする事が忌避されたものと思われる。
 
 ## 備考
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>chi_squared_distribution -- chi_squared_distribution : リンク切れしていたページをInetnet Archiveに差し替え #861</title>
      <link href="https://cpprefjp.github.io/reference/random/chi_squared_distribution.html"/>
      <id>7fe82a1dff12904cb2595fb06a291dbbe7c23f74:reference/random/chi_squared_distribution.md</id>
      <updated>2021-04-19T13:52:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/random/chi_squared_distribution.md b/reference/random/chi_squared_distribution.md
index 1dd54be81..becc6b169 100644
--- a/reference/random/chi_squared_distribution.md
+++ b/reference/random/chi_squared_distribution.md
@@ -125,5 +125,5 @@ int main()
 ### 参考
 - [カイ二乗分布 - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%AB%E3%82%A4%E4%BA%8C%E4%B9%97%E5%88%86%E5%B8%83)
 - [χ2（カイ２乗）分布](http://staff.aist.go.jp/t.ihara/chi2.html)
-- [カイ２乗分布とは](http://ogawas.cerp.u-toyama.ac.jp/e-stat/kai.html)
+- [カイ２乗分布とは](https://web.archive.org/web/20161213042559/http://ogawas.cerp.u-toyama.ac.jp/e-stat/kai.html)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>