<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-05-21T14:34:39.791228</updated>
  <id>ddcb5c88-62c2-4970-8667-22dc2f9c2612</id>

  
    <entry>
      <title>gcd -- gcd : コピペミスを修正</title>
      <link href="https://cpprefjp.github.io/reference/numeric/gcd.html"/>
      <id>821c055e85acf54e5d23f0943adef4bdd09b6cd9:reference/numeric/gcd.md</id>
      <updated>2020-05-19T18:19:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/gcd.md b/reference/numeric/gcd.md
index b3a2f6bac..5c979c673 100644
--- a/reference/numeric/gcd.md
+++ b/reference/numeric/gcd.md
@@ -85,7 +85,7 @@ gcd&amp;lt;int32_t, int32_t&amp;gt;(-2147483648, -2147483648)   -2147483648
 gcd&amp;lt;uint32_t, uint32_t&amp;gt;(-2147483648, -2147483648) 2147483648
 ```
 
-### 3つ以上の値に対する最小公倍数を求める
+### 3つ以上の値に対する最大公約数を求める
 ```cpp example
 #include &amp;lt;cassert&amp;gt;
 #include &amp;lt;numeric&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gcd -- gcd, lcm : サンプルコードをWandbox実行できるよう修正</title>
      <link href="https://cpprefjp.github.io/reference/numeric/gcd.html"/>
      <id>e3824c20dfdd6b92c44ed6913e8ad1e07d138d25:reference/numeric/gcd.md</id>
      <updated>2020-05-19T18:05:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/gcd.md b/reference/numeric/gcd.md
index b281374e8..b3a2f6bac 100644
--- a/reference/numeric/gcd.md
+++ b/reference/numeric/gcd.md
@@ -55,7 +55,7 @@ int main() {
 ```
 
 ### 負の最大公約数
-```cpp
+```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;numeric&amp;gt;
 #include &amp;lt;cstdint&amp;gt;
@@ -86,7 +86,7 @@ gcd&amp;lt;uint32_t, uint32_t&amp;gt;(-2147483648, -2147483648) 2147483648
 ```
 
 ### 3つ以上の値に対する最小公倍数を求める
-```cpp
+```cpp example
 #include &amp;lt;cassert&amp;gt;
 #include &amp;lt;numeric&amp;gt;
 #include &amp;lt;vector&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lcm -- gcd, lcm : サンプルコードをWandbox実行できるよう修正</title>
      <link href="https://cpprefjp.github.io/reference/numeric/lcm.html"/>
      <id>e3824c20dfdd6b92c44ed6913e8ad1e07d138d25:reference/numeric/lcm.md</id>
      <updated>2020-05-19T18:05:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/lcm.md b/reference/numeric/lcm.md
index 1e0942dd3..9f016c24b 100644
--- a/reference/numeric/lcm.md
+++ b/reference/numeric/lcm.md
@@ -62,7 +62,7 @@ int main() {
 ```
 
 ### オーバーフローしやすい状況の例
-```cpp
+```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;cstdint&amp;gt;
 #include &amp;lt;numeric&amp;gt;
@@ -95,7 +95,7 @@ improved lcm(20000, 40000) 40000
 ```
 
 ### 3つ以上の値に対する最小公倍数を求める
-```cpp
+```cpp example
 #include &amp;lt;cassert&amp;gt;
 #include &amp;lt;numeric&amp;gt;
 #include &amp;lt;vector&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lcm -- lcm : 実装で使用されている実装について記載</title>
      <link href="https://cpprefjp.github.io/reference/numeric/lcm.html"/>
      <id>29e6175e8fa449dcddb76c56755988dea70f7306:reference/numeric/lcm.md</id>
      <updated>2020-05-19T18:00:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/lcm.md b/reference/numeric/lcm.md
index 2a2e31261..1e0942dd3 100644
--- a/reference/numeric/lcm.md
+++ b/reference/numeric/lcm.md
@@ -35,6 +35,11 @@ namespace std {
 投げない。
 
 
+## 備考
+- この関数は、公式通りに `abs(m * n) / gcd(m, n)` として実装すると、`m * n`の箇所でオーバーフローしやすい。実装によっては、式を改良することでオーバーフローしにくいようになっている場合がある
+    - GCC (libstdc++), Clang (libc++), Visual C++ : オーバーフローしにくい改良版の式として`abs(m) / gcd(m, n) * abs(n)`という実装が使用されている
+
+
 ## 例
 ### 基本的な使い方
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gcd -- gcd, lcm : 例が大きくなったので分割</title>
      <link href="https://cpprefjp.github.io/reference/numeric/gcd.html"/>
      <id>cb4f0db313cf9949177ec0f732fd286755033e96:reference/numeric/gcd.md</id>
      <updated>2020-05-19T17:53:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/gcd.md b/reference/numeric/gcd.md
index 610d1cf17..b281374e8 100644
--- a/reference/numeric/gcd.md
+++ b/reference/numeric/gcd.md
@@ -34,24 +34,10 @@ namespace std {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
-#include &amp;lt;iostream&amp;gt;
 #include &amp;lt;cassert&amp;gt;
-#include &amp;lt;cstdint&amp;gt;
-#include &amp;lt;limits&amp;gt;
 #include &amp;lt;numeric&amp;gt;
-#include &amp;lt;vector&amp;gt;
-
-// 可変引数で最大公約数を求める関数
-template &amp;lt;class T&amp;gt;
-T vgcd(T m, T n) {
-  return std::gcd(m, n);
-}
-
-template &amp;lt;class T, class... Args&amp;gt;
-T vgcd(T a, Args... args) {
-  return vgcd(a, vgcd(args...));
-}
 
 int main() {
   assert(std::gcd(12, 42) == 6);
@@ -60,18 +46,22 @@ int main() {
   // コンパイル時に最大公約数を求めることもできる
   static_assert(std::gcd(0, 0) == 0);
   static_assert(std::gcd(3u, -7l) == 1);
+}
+```
+* std::gcd[color ff0000]
 
-  // 3つの値の最大公約数を求める
-  assert(std::gcd(std::gcd(12, 42), 72) == 6);
-
-  std::vector&amp;lt;int&amp;gt; v = {12, 42, 72};
-  int r = std::accumulate(v.begin(), v.end(), 0, [](int m, int n) {
-    return std::gcd(m, n);
-  });
-  assert(r == 6);
+#### 出力
+```
+```
 
-  assert(vgcd(12, 42, 72) == 6);
+### 負の最大公約数
+```cpp
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;numeric&amp;gt;
+#include &amp;lt;cstdint&amp;gt;
+#include &amp;lt;limits&amp;gt;
 
+int main() {
   // 符号付き整数の場合、戻り値が負になることがある
   using T = std::int32_t;
   constexpr auto m = std::numeric_limits&amp;lt;T&amp;gt;::min();
@@ -88,14 +78,51 @@ int main() {
 * min[link /reference/limits/numeric_limits/min.md]
 * std::int32_t[link /reference/cstdint/int32_t.md]
 * std::uint32_t[link /reference/cstdint/uint32_t.md]
-* std::accumulate[link accumulate.md]
 
-### 出力例
+#### 出力例
 ```
 gcd&amp;lt;int32_t, int32_t&amp;gt;(-2147483648, -2147483648)   -2147483648
 gcd&amp;lt;uint32_t, uint32_t&amp;gt;(-2147483648, -2147483648) 2147483648
 ```
 
+### 3つ以上の値に対する最小公倍数を求める
+```cpp
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;numeric&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+// 可変引数で最大公約数を求める関数
+template &amp;lt;class T&amp;gt;
+T vgcd(T m, T n) {
+  return std::gcd(m, n);
+}
+
+template &amp;lt;class T, class... Args&amp;gt;
+T vgcd(T a, Args... args) {
+  return vgcd(a, vgcd(args...));
+}
+
+int main() {
+  // 2つずつ最大公約数を求める
+  assert(std::gcd(std::gcd(12, 42), 72) == 6);
+
+  // リスト全体の最大公約数を求める
+  std::vector&amp;lt;int&amp;gt; v = {12, 42, 72};
+  int r = std::accumulate(v.begin(), v.end(), 0, [](int m, int n) {
+    return std::gcd(m, n);
+  });
+  assert(r == 6);
+
+  // 可変引数で最大公約数を求める
+  assert(vgcd(12, 42, 72) == 6);
+}
+```
+* std::gcd[color ff0000]
+* std::accumulate[link accumulate.md]
+
+#### 出力
+```
+```
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lcm -- gcd, lcm : 例が大きくなったので分割</title>
      <link href="https://cpprefjp.github.io/reference/numeric/lcm.html"/>
      <id>cb4f0db313cf9949177ec0f732fd286755033e96:reference/numeric/lcm.md</id>
      <updated>2020-05-19T17:53:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/lcm.md b/reference/numeric/lcm.md
index a875cced4..2a2e31261 100644
--- a/reference/numeric/lcm.md
+++ b/reference/numeric/lcm.md
@@ -36,23 +36,10 @@ namespace std {
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
-#include &amp;lt;iostream&amp;gt;
 #include &amp;lt;cassert&amp;gt;
-#include &amp;lt;cstdint&amp;gt;
 #include &amp;lt;numeric&amp;gt;
-#include &amp;lt;vector&amp;gt;
-
-// 可変引数で最小公倍数を求める関数
-template &amp;lt;class T&amp;gt;
-T vlcm(T m, T n) {
-  return std::lcm(m, n);
-}
-
-template &amp;lt;class T, class... Args&amp;gt;
-T vlcm(T a, Args... args) {
-  return vlcm(a, vlcm(args...));
-}
 
 int main() {
   assert(std::lcm(3, 4) == 12);
@@ -61,19 +48,21 @@ int main() {
   // コンパイル時に最小公倍数を求めることもできる
   static_assert(std::lcm(0, 1) == 0);
   static_assert(std::lcm(4u, -6l) == 12);
+}
+```
+* std::lcm[color ff0000]
 
-  // 3つの値の最小公倍数を求める
-  assert(std::lcm(std::lcm(3, 4), 6) == 12);
-
-  std::vector&amp;lt;int&amp;gt; v = {3, 4, 6};
-  int r = std::accumulate(v.begin(), v.end(), 1, [](int m, int n) {
-    return std::lcm(m, n);
-  });
-  assert(r == 12);
+#### 出力
+```
+```
 
-  assert(vlcm(3, 4, 6) == 12);
+### オーバーフローしやすい状況の例
+```cpp
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;cstdint&amp;gt;
+#include &amp;lt;numeric&amp;gt;
 
-  // 以下、オーバーフローしやすい例
+int main() {
   std::uint16_t m = 20000;
   std::uint16_t n = 40000;
 
@@ -91,16 +80,54 @@ int main() {
 ```
 * std::lcm[color ff0000]
 * std::uint16_t[link /reference/cstdint/uint16_t.md]
-* std::accumulate[link accumulate.md]
 * std::gcd[link gcd.md]
 
-### 出力例
+#### 出力例
 ```
 std::lcm(20000, 40000)     40000
 formal lcm(20000, 40000)   0
 improved lcm(20000, 40000) 40000
 ```
 
+### 3つ以上の値に対する最小公倍数を求める
+```cpp
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;numeric&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+// 可変引数で最小公倍数を求める関数
+template &amp;lt;class T&amp;gt;
+T vlcm(T m, T n) {
+  return std::lcm(m, n);
+}
+
+template &amp;lt;class T, class... Args&amp;gt;
+T vlcm(T a, Args... args) {
+  return vlcm(a, vlcm(args...));
+}
+
+int main() {
+  // 2つずつ最小公倍数を求める
+  assert(std::lcm(std::lcm(3, 4), 6) == 12);
+
+  // リスト全体の最小公倍数を求める
+  std::vector&amp;lt;int&amp;gt; v = {3, 4, 6};
+  int r = std::accumulate(v.begin(), v.end(), 1, [](int m, int n) {
+    return std::lcm(m, n);
+  });
+  assert(r == 12);
+
+  // 可変引数で最小公倍数を求める
+  assert(vlcm(3, 4, 6) == 12);
+}
+```
+* std::lcm[color ff0000]
+* std::accumulate[link accumulate.md]
+
+#### 出力
+```
+```
+
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gcd -- gcd, lcm : 可変引数の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/numeric/gcd.html"/>
      <id>480d7335dd4e2a8e072cade38b7be4623fe35a6f:reference/numeric/gcd.md</id>
      <updated>2020-05-19T17:37:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/gcd.md b/reference/numeric/gcd.md
index e8ccca3a9..610d1cf17 100644
--- a/reference/numeric/gcd.md
+++ b/reference/numeric/gcd.md
@@ -42,6 +42,17 @@ namespace std {
 #include &amp;lt;numeric&amp;gt;
 #include &amp;lt;vector&amp;gt;
 
+// 可変引数で最大公約数を求める関数
+template &amp;lt;class T&amp;gt;
+T vgcd(T m, T n) {
+  return std::gcd(m, n);
+}
+
+template &amp;lt;class T, class... Args&amp;gt;
+T vgcd(T a, Args... args) {
+  return vgcd(a, vgcd(args...));
+}
+
 int main() {
   assert(std::gcd(12, 42) == 6);
   assert(std::gcd(42, 12) == 6);
@@ -59,6 +70,8 @@ int main() {
   });
   assert(r == 6);
 
+  assert(vgcd(12, 42, 72) == 6);
+
   // 符号付き整数の場合、戻り値が負になることがある
   using T = std::int32_t;
   constexpr auto m = std::numeric_limits&amp;lt;T&amp;gt;::min();
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lcm -- gcd, lcm : 可変引数の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/numeric/lcm.html"/>
      <id>480d7335dd4e2a8e072cade38b7be4623fe35a6f:reference/numeric/lcm.md</id>
      <updated>2020-05-19T17:37:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/lcm.md b/reference/numeric/lcm.md
index 48064661a..a875cced4 100644
--- a/reference/numeric/lcm.md
+++ b/reference/numeric/lcm.md
@@ -43,6 +43,17 @@ namespace std {
 #include &amp;lt;numeric&amp;gt;
 #include &amp;lt;vector&amp;gt;
 
+// 可変引数で最小公倍数を求める関数
+template &amp;lt;class T&amp;gt;
+T vlcm(T m, T n) {
+  return std::lcm(m, n);
+}
+
+template &amp;lt;class T, class... Args&amp;gt;
+T vlcm(T a, Args... args) {
+  return vlcm(a, vlcm(args...));
+}
+
 int main() {
   assert(std::lcm(3, 4) == 12);
   assert(std::lcm(4, 3) == 12);
@@ -60,6 +71,8 @@ int main() {
   });
   assert(r == 12);
 
+  assert(vlcm(3, 4, 6) == 12);
+
   // 以下、オーバーフローしやすい例
   std::uint16_t m = 20000;
   std::uint16_t n = 40000;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>