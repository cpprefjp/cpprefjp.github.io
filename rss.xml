<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-03-20T15:08:56.779823</updated>
  <id>bbb0ad13-771f-4f50-a4cf-d6c9b9687d29</id>

  
    <entry>
      <title>merge -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>07831c60f3b4aebbc4a6da00749eec1e4a58772c:reference/algorithm/ranges_merge.md</id>
      <updated>2022-03-21T00:05:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
index d236bf85d..25c63d85a 100644
--- a/reference/algorithm/ranges_merge.md
+++ b/reference/algorithm/ranges_merge.md
@@ -9,16 +9,27 @@ namespace std::ranges {
   template&amp;lt;class I1, class I2, class O&amp;gt;
   using merge_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
 
-  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
-           weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
   constexpr merge_result&amp;lt;I1, I2, O&amp;gt; merge(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                    // (1)
 
-  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O,
+           class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
   constexpr merge_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt; merge(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (2)
 }
 ```
+* in_in_out_result[link in_in_out_result.md]
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* weakly_incrementable[link /reference/iterator/weakly_incrementable.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* mergeable[link /reference/iterator/mergeable.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 
 ## 概要
 2つのソート済み範囲をマージして、出力イテレーターへ出力する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- マージ関係の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>6b1aa1b919a376d92a729fbacb34fbc35f8825d6:reference/algorithm.md</id>
      <updated>2022-03-21T00:04:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index d70adabd9..3917d36fe 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -313,8 +313,8 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 |-------------------------------------------------|---------------------------------|-------|
 | [`merge`](algorithm/merge.md)                 | 2つのソート済み範囲をマージする | |
 | [`inplace_merge`](algorithm/inplace_merge.md) | 2つの連続したソート済み範囲をマージする | |
-| [`ranges::merge`](algorithm/ranges_merge.md.nolink)                 | 2つのソート済み範囲をマージする         | C++20 |
-| [`ranges::inplace_merge`](algorithm/ranges_inplace_merge.md.nolink) | 2つの連続したソート済み範囲をマージする | C++20 |
+| [`ranges::merge`](algorithm/ranges_merge.md)                 | 2つのソート済み範囲をマージする         | C++20 |
+| [`ranges::inplace_merge`](algorithm/ranges_inplace_merge.md) | 2つの連続したソート済み範囲をマージする | C++20 |
 
 ### ソート済み構造に対する集合演算
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inplace_merge -- マージ関係の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_inplace_merge.html"/>
      <id>6b1aa1b919a376d92a729fbacb34fbc35f8825d6:reference/algorithm/ranges_inplace_merge.md</id>
      <updated>2022-03-21T00:04:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_inplace_merge.md b/reference/algorithm/ranges_inplace_merge.md
new file mode 100644
index 000000000..4b0fad40d
--- /dev/null
+++ b/reference/algorithm/ranges_inplace_merge.md
@@ -0,0 +1,102 @@
+# inplace_merge
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
+
+  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  borrowed_iterator_t&amp;lt;R&amp;gt; inplace_merge(R&amp;amp;&amp;amp; r, iterator_t&amp;lt;R&amp;gt; middle, Comp comp = {}, Proj proj = {});
+}
+```
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* bidirectional_range[link /reference/ranges/bidirectional_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+2つの連続したソート済み範囲をマージする。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 事前条件
+- `[first,middle)` と `[middle,last)` の範囲はそれぞれソートされていること。
+
+
+## 効果
+`[first,middle)`, `[middle,last)` という、連続した２つの範囲をマージし、結果を `[first,last)` へ格納する。
+
+結果の範囲 `[first,last)` は昇順になる。
+
+
+## 戻り値
+`last`
+
+
+## 計算量
+`N = last - first`であるとして説明する。
+
+- 余分なメモリを使用する場合は、`N - 1` 回比較する。そうでない場合は、O(N log(N))回比較する
+
+## 備考
+この操作は安定である。つまり、各入力範囲内の要素の前後関係は保たれ、また、1 番目の範囲と 2 番目に等値の要素があった場合には、1 番目の範囲の要素の方が先に来る。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1,4,5,  2,3,6};
+
+  // ソートされた2つの範囲をマージ
+  std::ranges::inplace_merge(v, v.begin() + 3);
+
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::inplace_merge[color ff0000]
+
+### 出力
+```
+1
+2
+3
+4
+5
+6
+```
+
+## 実装例
+- [inplace_merge を読んでみた](http://www.kmonos.net/wlog/115.html#_2300101215)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- マージ関係の説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_merge.html"/>
      <id>6b1aa1b919a376d92a729fbacb34fbc35f8825d6:reference/algorithm/ranges_merge.md</id>
      <updated>2022-03-21T00:04:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_merge.md b/reference/algorithm/ranges_merge.md
new file mode 100644
index 000000000..d236bf85d
--- /dev/null
+++ b/reference/algorithm/ranges_merge.md
@@ -0,0 +1,106 @@
+# merge
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I1, class I2, class O&amp;gt;
+  using merge_result = in_in_out_result&amp;lt;I1, I2, O&amp;gt;;
+
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2,
+           weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;I1, I2, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr merge_result&amp;lt;I1, I2, O&amp;gt; merge(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                    // (1)
+
+  template&amp;lt;input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires mergeable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, O, Comp, Proj1, Proj2&amp;gt;
+  constexpr merge_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;, O&amp;gt; merge(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, O result, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});  // (2)
+}
+```
+
+## 概要
+2つのソート済み範囲をマージして、出力イテレーターへ出力する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+
+## 事前条件
+- `[first1,last1)` と `[first2,last2)` はソートされていること。
+- 結果の範囲と入力の範囲は重なっていてはならない。
+
+
+## 効果
+`[first1,last1)` と `[first2,last2)` の２つの要素を全て `[result,result_last)` へコピーする。その際に、[`is_sorted`](ranges_is_sorted.md)`(result, result_last, comp)` を満たすようにコピーする（`result_last` は `result + (last1 - first1) + (last2 - first2)` とする）。
+
+
+## 戻り値
+次のメンバをもつtuple-likeオブジェクト。
+
+```cpp
+merge_result {
+  .in  = last1,
+  .in2 = last2,
+  .out = result + (last1 - first1) + (last2 - first2),
+}
+```
+
+## 計算量
+`N = (last1 - first1) + (last2 - first2)`であるとして最大で、N - 1回比較する
+
+## 備考
+この操作は安定である。つまり、各入力範囲内の要素の前後関係は保たれ、また、1 番目の範囲と 2 番目に等値の要素があった場合には、1 番目の範囲の要素の方が先に来る。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;int&amp;gt; a = {3, 1, 4, 2};
+  std::vector&amp;lt;int&amp;gt; b = {2, 5, 6, 4};
+  std::vector&amp;lt;int&amp;gt; result;
+
+  std::ranges::sort(a);
+  std::ranges::sort(b);
+
+  // aとbをマージ
+  std::ranges::merge(a, b, std::back_inserter(result));
+
+  for (int x : result) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::sort[link ranges_sort.md]
+* std::ranges::merge[color ff0000]
+
+### 出力
+```
+1
+2
+2
+3
+4
+4
+5
+6
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_max_element.html"/>
      <id>1befcbdc598b49e8652bb8b32f0947dcad9ae03b:reference/algorithm/ranges_max_element.md</id>
      <updated>2022-03-20T23:07:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_max_element.md b/reference/algorithm/ranges_max_element.md
index e95211c11..fdcacd74e 100644
--- a/reference/algorithm/ranges_max_element.md
+++ b/reference/algorithm/ranges_max_element.md
@@ -15,7 +15,7 @@ namespace std::ranges {
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; max_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
 }
 ```
-* forward_iterator[link /reference/ranges/forward_iterator.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
 * identity[link /reference/functional/identity.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * projected[link /reference/iterator/projected.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>min_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_min_element.html"/>
      <id>1befcbdc598b49e8652bb8b32f0947dcad9ae03b:reference/algorithm/ranges_min_element.md</id>
      <updated>2022-03-20T23:07:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_min_element.md b/reference/algorithm/ranges_min_element.md
index d0cc89f93..1ce557869 100644
--- a/reference/algorithm/ranges_min_element.md
+++ b/reference/algorithm/ranges_min_element.md
@@ -15,7 +15,7 @@ namespace std::ranges {
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; min_element(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});
 }
 ```
-* forward_iterator[link /reference/ranges/forward_iterator.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
 * identity[link /reference/functional/identity.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * projected[link /reference/iterator/projected.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>minmax_element -- リンク修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_minmax_element.html"/>
      <id>1befcbdc598b49e8652bb8b32f0947dcad9ae03b:reference/algorithm/ranges_minmax_element.md</id>
      <updated>2022-03-20T23:07:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_minmax_element.md b/reference/algorithm/ranges_minmax_element.md
index 6c8cf95aa..5914791fd 100644
--- a/reference/algorithm/ranges_minmax_element.md
+++ b/reference/algorithm/ranges_minmax_element.md
@@ -19,7 +19,7 @@ namespace std::ranges {
 }
 ```
 * min_max_result[link min_max_result.md.nolink]
-* forward_iterator[link /reference/ranges/forward_iterator.md]
+* forward_iterator[link /reference/iterator/forward_iterator.md]
 * identity[link /reference/functional/identity.md]
 * indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
 * projected[link /reference/iterator/projected.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- ranges::lexicographical_compareの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>152c2d99d70287f1c8c34835817d4b908ff89ba8:reference/algorithm.md</id>
      <updated>2022-03-20T14:23:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 23c58e9d0..d70adabd9 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -384,7 +384,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------------------------------|---------------------------------|-------|
 | [`lexicographical_compare`](algorithm/lexicographical_compare.md) | 2つの範囲を辞書式順序で比較する | |
-| [`ranges::lexicographical_compare`](algorithm/ranges_lexicographical_compare.md.nolink) | 2つの範囲を辞書式順序で比較する | C++20 |
+| [`ranges::lexicographical_compare`](algorithm/ranges_lexicographical_compare.md) | 2つの範囲を辞書式順序で比較する | C++20 |
 
 ### 三方比較アルゴリズム
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexicographical_compare -- ranges::lexicographical_compareの説明を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_lexicographical_compare.html"/>
      <id>152c2d99d70287f1c8c34835817d4b908ff89ba8:reference/algorithm/ranges_lexicographical_compare.md</id>
      <updated>2022-03-20T14:23:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_lexicographical_compare.md b/reference/algorithm/ranges_lexicographical_compare.md
new file mode 100644
index 000000000..9cca180fe
--- /dev/null
+++ b/reference/algorithm/ranges_lexicographical_compare.md
@@ -0,0 +1,130 @@
+# lexicographical_compare
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
+           indirect_strict_weak_order&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;input_range R1, input_range R2, class Proj1 = identity, class Proj2 = identity,
+          indirect_strict_weak_order&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool lexicographical_compare(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* indirect_strict_weak_order[link /reference/iterator/indirect_strict_weak_order.md]
+* projected[link /reference/iterator/projected.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+`[first1, last1)`および`[first2, last2)`の2つの範囲を辞書式順序で比較する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+```cpp
+for ( ; first1 != last1 &amp;amp;&amp;amp; first2 != last2 ; ++first1, ++first2) {
+  if (*first1 &amp;lt; *first2) return true;
+  if (*first2 &amp;lt; *first1) return false;
+}
+return first1 == last1 &amp;amp;&amp;amp; first2 != last2;
+```
+
+
+## 戻り値
+範囲`[first1, last1)`が、辞書式比較で範囲`[first2, last2)`より小さい場合`true`を返し、そうでなければ`false`を返す。
+
+
+## 計算量
+高々`2*min((last1 - first1), (last2 - first2))`回の比較が行われる。
+
+
+## 備考
+空のシーケンスは、空でないシーケンスより小さいと判断されるが、空のシーケンスに対しては小さくないと判断される。
+
+どちらかのシーケンスの横断が先に終わる場合(つまり、範囲の長さが合わない場合)、先に終わった方が小さいと判断される。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+template &amp;lt;class X, class Y&amp;gt;
+void compare_test(const X&amp;amp; x, const Y&amp;amp; y)
+{
+  if (std::ranges::lexicographical_compare(x, y)) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;x less than y&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;x not less than y&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 比較演算のカスタマイズバージョン
+  if (std::ranges::lexicographical_compare(x, y, std::ranges::greater())) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;x less than y&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;x not less than y&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+
+int main()
+{
+  // 同じ長さの文字列比較
+  {
+    std::string x = &amp;#34;heilo&amp;#34;;
+    std::string y = &amp;#34;hello&amp;#34;;
+
+    std::cout &amp;lt;&amp;lt; &amp;#34;same length string compare:&amp;#34; &amp;lt;&amp;lt; std::endl;
+    compare_test(x, y);
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  // 異なる長さの文字列比較
+  {
+    std::string x = &amp;#34;hell&amp;#34;;
+    std::string y = &amp;#34;hello&amp;#34;;
+
+    std::cout &amp;lt;&amp;lt; &amp;#34;not same length string compare:&amp;#34; &amp;lt;&amp;lt; std::endl;
+    compare_test(x, y);
+  }
+}
+```
+* std::ranges::lexicographical_compare[color ff0000]
+* std::ranges::greater[link /reference/functional/ranges_greater.md]
+
+### 出力
+```
+same length string compare:
+x less than y
+x not less than y
+
+not same length string compare:
+x less than y
+x less than y
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- 順列関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>de01d499d90a0acc828e92125fb7e8700820b462:reference/algorithm.md</id>
      <updated>2022-03-20T14:15:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index d0052caaf..23c58e9d0 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -400,9 +400,9 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`next_permutation`](algorithm/next_permutation.md) | 次の順列を生成する     | |
 | [`prev_permutation`](algorithm/prev_permutation.md) | 前の順列を生成する     | |
 | [`is_permutation`](algorithm/is_permutation.md)     | 範囲が順列かを判定する | C++11 |
-| [`ranges::next_permutation`](algorithm/ranges_next_permutation.md.nolink) | 次の順列を生成する     | C++20 |
-| [`ranges::prev_permutation`](algorithm/ranges_prev_permutation.md.nolink) | 前の順列を生成する     | C++20 |
-| [`ranges::is_permutation`](algorithm/ranges_is_permutation.md.nolink)     | 範囲が順列かを判定する | C++20 |
+| [`ranges::next_permutation`](algorithm/ranges_next_permutation.md) | 次の順列を生成する     | C++20 |
+| [`ranges::prev_permutation`](algorithm/ranges_prev_permutation.md) | 前の順列を生成する     | C++20 |
+| [`ranges::is_permutation`](algorithm/ranges_is_permutation.md)     | 範囲が順列かを判定する | C++20 |
 
 ### 戻り値
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_permutation -- 順列関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_is_permutation.html"/>
      <id>de01d499d90a0acc828e92125fb7e8700820b462:reference/algorithm/ranges_is_permutation.md</id>
      <updated>2022-03-20T14:15:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_is_permutation.md b/reference/algorithm/ranges_is_permutation.md
new file mode 100644
index 000000000..09dc08b8a
--- /dev/null
+++ b/reference/algorithm/ranges_is_permutation.md
@@ -0,0 +1,82 @@
+# is_permutation
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Proj1 = identity, class Proj2 = identity,
+           indirect_equivalence_relation&amp;lt;projected&amp;lt;I1, Proj1&amp;gt;, projected&amp;lt;I2, Proj2&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;forward_range R1, forward_range R2, class Proj1 = identity, class Proj2 = identity,
+           indirect_equivalence_relation&amp;lt;projected&amp;lt;iterator_t&amp;lt;R1&amp;gt;, Proj1&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R2&amp;gt;, Proj2&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr bool is_permutation(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});                         // (2)
+}
+```
+* forward_iterator[link /reference/iterator/forward_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::equal_to[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* indirect_equivalence_relation[link /reference/iterator/indirect_equivalence_relation.md]
+* projected[link /reference/iterator/projected.md]
+* forward_range[link /reference/ranges/forward_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+範囲 `[first2, last2)` を並べ替えたものが、`[first1, last1)` の範囲と一致するか判定する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 戻り値
+`last2` が与えられている形式の場合、`last1 - first1 != last2 - first2` であれば `false` を返す。  
+そうでなければ、`[first1, last1)` の範囲と `[first2, first2 + (last1 - first1))` の範囲を並び変えたもので、[`equal`](equal.md)`(first1, last1, first2)`、あるいは [`equal`](equal.md)`(first1, last1, first2, pred)` が `true` を返すようなものがあれば `true` を、そうでなければ `false` を返す。  
+なお、実際に並べ替えが行われるわけではない。
+
+
+## 計算量
+`last2` が与えられている形式の場合、`ForwardIterator1` と `ForwardIterator2` がどちらもランダムアクセスイテレータの要件を満たし、かつ `last1 - first1 != last2 - first2` であれば 1 度も述語の適用を行わない。  
+そうでなければ、[`equal`](/reference/algorithm/equal.md)`(first1, last1, first2, last2) == true` もしくは [`equal`](/reference/algorithm/equal.md)`(first1, last1, first2, last2, pred) == true` の場合（`last2` が無い形式の場合、[`equal`](/reference/algorithm/equal.md) も `last2` の無い形式で置き換える）、[`distance`](/reference/iterator/distance.md)`(first1, last1)` 回の述語適用で完了する。  
+そうでなければ、[`distance`](/reference/iterator/distance.md)`(first1, last1)` をNとした場合に最悪O(N^2)回の述語適用で完了する。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+int main ()
+{
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  std::vector&amp;lt;int&amp;gt; good = {2, 3, 1};
+  std::vector&amp;lt;int&amp;gt; bad = {2, 3, 4};
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; std::ranges::is_permutation(v, good) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::ranges::is_permutation(v, bad) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::is_permutation[color ff0000]
+
+### 出力
+```
+true
+false
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>next_permutation -- 順列関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_next_permutation.html"/>
      <id>de01d499d90a0acc828e92125fb7e8700820b462:reference/algorithm/ranges_next_permutation.md</id>
      <updated>2022-03-20T14:15:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_next_permutation.md b/reference/algorithm/ranges_next_permutation.md
new file mode 100644
index 000000000..94a95dbda
--- /dev/null
+++ b/reference/algorithm/ranges_next_permutation.md
@@ -0,0 +1,110 @@
+# next_permutation
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I&amp;gt;
+  using next_permutation_result = in_found_result&amp;lt;I&amp;gt;;
+
+  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr next_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
+
+  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr next_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
+}
+```
+* in_found_result[link in_found_result.md.nolink]
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* bidirectional_range[link /reference/ranges/bidirectional_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその次の順列を生成する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+`[first, last)`の範囲を次の順列に変換する。
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって辞書順に並んでいる全ての順列の集合があると仮定すると、次の順列が発見される。
+
+順列の辞書順とは、同じ長さ`N`の順列`a, b`があった時、その最上位の項から見た時に`ai != bi`となる最初の`i`番目の項について、`ai &amp;lt; bi`（もしくは`comp(ai, bi) == true`）となる時に`a &amp;lt; b`とするように定めた順序のことである。例えばこれは、各項（`ai, bi`）が`0 ~ 9`の数であるとすれば、それらをそのまま並べて構成した数の通常の大小関係に等しい。
+
+辞書順による次の順列とは、現在の順列（`[first, last)`）よりも（上記の意味の順序で）大きい順列のうち取り得る最小のもののことである。
+
+## 戻り値
+次のメンバをもつtuple-lileオブジェクト。
+
+1. `in`: `last`
+2. `found`: 次の順列が存在する場合は`true`、そうでなければ`false`
+
+## 計算量
+高々`(last - first)/2`回の要素の交換
+
+
+## 備考
+全ての順列を取得したい場合は、この関数に最初に与える範囲が、昇順にソート済みになっていること。  
+順列の長さを`N`（`N = last - first`）とすれば、そのような順列は`N!`個存在する。
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+void print(const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
+{
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34; &amp;#34;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+int main ()
+{
+  // 昇順にソート済みの入力
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  do {
+    print(v);
+  } while (std::ranges::next_permutation(v).found);
+}
+```
+* std::ranges::next_permutation[color ff0000]
+
+### 出力
+```
+1 2 3 
+1 3 2 
+2 1 3 
+2 3 1 
+3 1 2 
+3 2 1 
+```
+
+## 関連項目
+- [`std::ranges::prev_permutation()`](ranges_prev_permutation.md)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>prev_permutation -- 順列関係の関数を追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_prev_permutation.html"/>
      <id>de01d499d90a0acc828e92125fb7e8700820b462:reference/algorithm/ranges_prev_permutation.md</id>
      <updated>2022-03-20T14:15:02+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_prev_permutation.md b/reference/algorithm/ranges_prev_permutation.md
new file mode 100644
index 000000000..73dd7d9d1
--- /dev/null
+++ b/reference/algorithm/ranges_prev_permutation.md
@@ -0,0 +1,107 @@
+# prev_permutation
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;class I&amp;gt;
+  using prev_permutation_result = in_found_result&amp;lt;I&amp;gt;;
+
+  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;I, Comp, Proj&amp;gt;
+  constexpr prev_permutation_result&amp;lt;I&amp;gt; next_permutation(I first, S last, Comp comp = {}, Proj proj = {});             // (1)
+
+  template&amp;lt;bidirectional_range R, class Comp = ranges::less, class Proj = identity&amp;gt;
+    requires sortable&amp;lt;iterator_t&amp;lt;R&amp;gt;, Comp, Proj&amp;gt;
+  constexpr prev_permutation_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;&amp;gt; next_permutation(R&amp;amp;&amp;amp; r, Comp comp = {}, Proj proj = {});  // (2)
+}
+```
+* in_found_result[link in_found_result.md.nolink]
+* bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* ranges::less[link /reference/functional/ranges_less.md]
+* identity[link /reference/functional/identity.md]
+* sortable[link /reference/iterator/sortable.md]
+* bidirectional_range[link /reference/ranges/bidirectional_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+## 概要
+与えられた時点の`[first, last)`の範囲を起点の順列として、辞書順によるその前の順列を生成する。
+
+* (1): イテレーターペアで範囲を指定する
+* (2): 範囲を直接指定する
+
+## 効果
+`[first, last)`の範囲を前の順列に変換する。
+
+比較 [`invoke`](/reference/functional/invoke.md)`(comp, `[`invoke`](/reference/functional/invoke.md)`(proj, *i), `[`invoke`](/reference/functional/invoke.md)`(proj, *j))` によって辞書順に並んでいる全ての順列の集合があると仮定すると、前の順列が発見される。
+
+## 戻り値
+次のメンバをもつtuple-lileオブジェクト。
+
+1. `in`: `last`
+2. `found`: 前の順列が存在する場合は`true`、そうでなければ`false`
+
+
+## 計算量
+高々`(last - first)/2`回の要素の交換
+
+
+## 備考
+全ての順列を取得したい場合は、この関数に最初に与える範囲が、降順にソート済みになっていること。
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+
+void print(const std::vector&amp;lt;int&amp;gt;&amp;amp; v)
+{
+  for (int x : v) {
+    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34; &amp;#34;;
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+
+int main ()
+{
+  // 降順にソート済みの入力
+  std::vector&amp;lt;int&amp;gt; v = {3, 2, 1};
+
+  do {
+    print(v);
+  } while (std::ranges::prev_permutation(v).found);
+}
+```
+* std::prev_permutation[color ff0000]
+
+### 出力
+```
+3 2 1 
+3 1 2 
+2 3 1 
+2 1 3 
+1 3 2 
+1 2 3 
+```
+
+## 関連項目
+- [`std::ranges::next_permutation()`](ranges_next_permutation.md)
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>