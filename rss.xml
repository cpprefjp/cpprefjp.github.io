<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-25T05:08:22.249530</updated>
  <id>045aa495-f93e-4a86-bae4-c90d68febf21</id>

  
    <entry>
      <title>非推奨だった古い例外仕様を削除 -- c++17-非推奨だった古い例外仕様を削除: プロポーザルのリンク追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/remove_deprecated_exception_specifications.html"/>
      <id>1e667b987dd2218f9363d273c5a23aafb4dc37da:lang/cpp17/remove_deprecated_exception_specifications.md</id>
      <updated>2021-05-25T14:03:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/remove_deprecated_exception_specifications.md b/lang/cpp17/remove_deprecated_exception_specifications.md
index f5bfc9f77..1bcadfd2e 100644
--- a/lang/cpp17/remove_deprecated_exception_specifications.md
+++ b/lang/cpp17/remove_deprecated_exception_specifications.md
@@ -61,3 +61,4 @@ C++でもJavaを含むこれらの問題は認識されており、動的例外
 
 ## 参照
 - [P0003R4 Removing Deprecated Exception Specifications from C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0003r4.html)
+- [P0003R5 Removing Deprecated Exception Specifications from C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0003r5.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akiko Kawai</name>
        <email>haruka.sao@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- リンク修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>6dc3dede1b5e6644c48402a511a75b29723dc951:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-24T15:41:06+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index b3fd1bf20..1cd12f507 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -153,7 +153,7 @@ constexpr void f() {
 
 標準ライブラリのコンテナ等は`new/delete`式を直接利用するわけではなく、`std::allocator_traits`を介して`std::allocator`を使用してメモリ確保・解放とオブジェクト構築・破棄を行う。`std::allocator/std::allocator_traits`も見かけ上はポインタの再解釈を必要とせずにそれを行うため、`std::allocator/std::allocator_traits`によるメモリ確保周りの機能もまた、コンパイル時の動的メモリ確保・解放の方法として許可される。
 
-`std::allocator/std::allocator_traits`では`new/delete`式とは異なり、メモリの確保・解放（[`allocate`](/reference/memory/allocator/allocate.md)/[`deallocate`](/reference/memory/allocator/deallocate.md)）とその領域へのオブジェクト構築・破棄（[`construct`](/reference/memory/allocator_traits/construct.md)/[`destroy`](/memory/allocator_traits/destroy.md)）の操作が複合していない。オブジェクト構築・破棄においては*placement new*と*pseudo-destructor call*が必要となるが、*placement new*はポインタの再解釈が必要となることから許可されず、そのために不必要であるので*pseudo-destructor call*も許可されない。
+`std::allocator/std::allocator_traits`では`new/delete`式とは異なり、メモリの確保・解放（[`allocate`](/reference/memory/allocator/allocate.md)/[`deallocate`](/reference/memory/allocator/deallocate.md)）とその領域へのオブジェクト構築・破棄（[`construct`](/reference/memory/allocator_traits/construct.md)/[`destroy`](/reference/memory/allocator_traits/destroy.md)）の操作が複合していない。オブジェクト構築・破棄においては*placement new*と*pseudo-destructor call*が必要となるが、*placement new*はポインタの再解釈が必要となることから許可されず、そのために不必要であるので*pseudo-destructor call*も許可されない。
 
 代わりに、*placement new*を行うライブラリ機能である[`construct_at`](/reference/memory/construct.md.nolink)を追加し、*pseudo-destructor call*を行う[`destroy_at`](/reference/memory/destroy_at.md)と共に`constexpr`を付加し定数式で使用可能とする。これによって、ポインタ再解釈を回避しつつ*placement new*と*pseudo-destructor call*が定数式で使用可能となる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- constexpr allocator/allocator_traits追記 #688</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>f704c1642877fd4cf1ac483b9d97f5646ba713e7:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-24T15:37:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 7facfa381..b3fd1bf20 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -72,7 +72,24 @@ C++17までは、クラス型のリテラル型はトリビアルデストラク
 
 そのため、そのようなポインタの再解釈が発生しない動的メモリ確保機能である`new/delete`式がコンパイル時の動的メモリ確保・解放の方法として許可される。`new/delete`式は`operator new/operator delete`とは異なり、メモリの確保・解放とその領域のオブジェクト構築・破棄を一挙に行う言語機能である。
 
-ただし、コンパイル時に実行される`new`式はグローバルのオーバーロード可能な[`operator new`](/reference/new/op_new.md)を呼び出すものでなくてはならない。そうではない`new`式の定数式における評価はコンパイルエラーとなる。
+```cpp
+constexpr int f() {
+  // 確保と構築
+  int* p = new int;
+
+  *p = 20;
+  int n = *p;
+
+  // 破棄と解放
+  delete p;
+
+  return n;
+}
+```
+
+当然ながら、`new/delete`式によって動的メモリ確保しようとする型はリテラル型であり、呼び出されるコンストラクタとデストラクタは共に定数式で実行可能でなければならない。
+
+また、コンパイル時に実行される`new`式はグローバルのオーバーロード可能な[`operator new`](/reference/new/op_new.md)を呼び出すものでなくてはならない。そうではない`new`式の定数式における評価はコンパイルエラーとなる。
 
 ```cpp
 struct S {
@@ -99,13 +116,13 @@ constexpr int f() {
 
 ```cpp
 constexpr int f() {
-  int* d = new int;
+  int* p = new int;
 
-  *d = 20;
-  int n = *d;
+  *p = 20;
+  int n = *p;
 
   // 忘れる
-  //delete d;
+  //delete p;
 
   return n;
 }
@@ -130,11 +147,103 @@ constexpr void f() {
 }
 ```
 
-実際にはどこのストレージが提供されるかは規定されていない。ただ、定数式が実行される環境はC++コンパイラの内蔵する`constexpr`インタプリタ上であり、その環境のメモリ領域とはコンパイラ実行環境のヒープ領域が対応する。
+実際にはどこのストレージが提供されるかは規定されていない。
 
 ### `std::allocator/std::allocator_traits`
-(執筆中)
 
+標準ライブラリのコンテナ等は`new/delete`式を直接利用するわけではなく、`std::allocator_traits`を介して`std::allocator`を使用してメモリ確保・解放とオブジェクト構築・破棄を行う。`std::allocator/std::allocator_traits`も見かけ上はポインタの再解釈を必要とせずにそれを行うため、`std::allocator/std::allocator_traits`によるメモリ確保周りの機能もまた、コンパイル時の動的メモリ確保・解放の方法として許可される。
+
+`std::allocator/std::allocator_traits`では`new/delete`式とは異なり、メモリの確保・解放（[`allocate`](/reference/memory/allocator/allocate.md)/[`deallocate`](/reference/memory/allocator/deallocate.md)）とその領域へのオブジェクト構築・破棄（[`construct`](/reference/memory/allocator_traits/construct.md)/[`destroy`](/memory/allocator_traits/destroy.md)）の操作が複合していない。オブジェクト構築・破棄においては*placement new*と*pseudo-destructor call*が必要となるが、*placement new*はポインタの再解釈が必要となることから許可されず、そのために不必要であるので*pseudo-destructor call*も許可されない。
+
+代わりに、*placement new*を行うライブラリ機能である[`construct_at`](/reference/memory/construct.md.nolink)を追加し、*pseudo-destructor call*を行う[`destroy_at`](/reference/memory/destroy_at.md)と共に`constexpr`を付加し定数式で使用可能とする。これによって、ポインタ再解釈を回避しつつ*placement new*と*pseudo-destructor call*が定数式で使用可能となる。
+
+そして、`std::allocator_traits`の`construct`と`destroy`は`construct_at/destroy_at`を呼び出して処理を行うように変更される。なお、これによって実行時の振る舞いが変化することはない。
+
+```cpp
+constexpr int f() {
+  std::allocator&amp;lt;int&amp;gt; alloc{};
+
+  // 確保と構築
+  int* p = alloc.allocate(1);
+  p = std::construct_at(p);
+
+  *p = 20;
+  int n = *p;
+
+  // 破棄と解放
+  std::destroy_at(p);
+  alloc.deallocate();
+
+  return n;
+}
+```
+
+当然ながら、`std::allocator`によって動的メモリ確保しようとする型はリテラル型であり、`construct_at/destroy_at`によって呼び出されるコンストラクタとデストラクタは共に定数式で実行可能でなければならない。
+
+また、`std::allocator&amp;lt;T&amp;gt;::allocate`が呼び出される場合は必ずその領域は`std::allocator&amp;lt;T&amp;gt;::deallocate`によって解放されていなければならず、`deallocate`と`construct_at`、`destroy_at`の引数の`T*`のポインタは`std::allocator&amp;lt;T&amp;gt;::allocate`によって確保された領域を指していなければならない。
+
+```cpp
+constexpr int f() {
+  std::allocator&amp;lt;int&amp;gt; alloc{};
+
+  // 確保と構築
+  int* p = alloc.allocate(1);
+  p = std::construct_at(p);
+
+  *p = 20;
+  int n = *p;
+
+  // 忘れる
+  //std::destroy_at(p);
+  //alloc.deallocate();
+
+  return n;
+}
+
+int main () {
+  constexpr int n = f();  // NG、コンパイルエラー
+}
+```
+
+すなわち、`new/delete`式と同様にコンパイル時に確保したメモリ領域を実行時へ持ち越すことはできない。
+
+この規則はまた、`std::allocator/std::allocator_traits`によって確保され`construct_at`によってオブジェクトが構築された領域を`delete`式で解放する事、またはその逆も許可されない事を示している。
+
+```cpp
+constexpr int f() {
+  std::allocator&amp;lt;int&amp;gt; alloc{};
+
+  // 確保と構築
+  int* p = alloc.allocate(1);
+  p = std::construct_at(p);
+
+  *p = 20;
+  int n = *p;
+
+  // 破棄と解放
+  delete p; // NG、コンパイルエラー
+
+  return n;
+}
+
+constexpr int g() {
+  std::allocator&amp;lt;int&amp;gt; alloc{};
+
+  // 確保と構築
+  int* p = new int;
+
+  *p = 20;
+  int n = *p;
+
+  // NG、コンパイルエラー
+  std::destroy_at(p);
+  alloc.deallocate();
+
+  return n;
+}
+```
+
+`destroy_at`には類似のファミリとして[`destroy_n`](/reference/memory/destroy_n.md)と、それらの`range`版があり（あるいは追加され）、`construct_at`も`range`版が同時に追加されるが、それらについても`construct_at/destroy_at`と同様の扱いが可能となる。
 
 ## この機能が必要になった背景・経緯
 
@@ -156,6 +265,11 @@ std::vector&amp;lt;std::metainfo&amp;gt; args = std::meta::get_template_args(reflexpr(T));
 
 ## 関連項目
 
+- [`allocator`](/reference/memory/allocator.md)
+- [`allocator_traits`](/reference/memory/allocator_traits.md)
+- [`construct_at`](/reference/memory/construct.md.nolink)
+- [`destroy_at`](/reference/memory/destroy_at.md)
+- [`destroy_n`](/reference/memory/destroy_n.md)
 - [`vector`](/reference/vector/vector.md)
 - [`basic_string`](/reference/string/basic_string.md)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- Update modules.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>08336f86b2116d3a028fddf69431ada5a36bab17:lang/cpp20/modules.md</id>
      <updated>2021-05-24T03:39:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index 9a6dc20d4..bbb8725e1 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -122,6 +122,8 @@ int baz() { return 30; }
 ```
 * P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]
 
+モジュール宣言はプリプロセッサで生成してはならない。これは、`#if`などによる切り替え、`#include`、`#define`による置換などによるものを含む。
+
 #### モジュール名の詳細
 
 モジュール名は、識別子または識別子をドットで繋いだもの(例えば、`foo`や`std.core`)である。
@@ -183,6 +185,7 @@ export module foo;  // モジュールの宣言(この上の行までがグロ
 * グローバルモジュールフラグメント内の宣言や定義は、後続のモジュールではなくグローバルモジュールに属する。
 * グローバルモジュールフラグメントにはプリプロセッサディレクティブ以外を書くことはできない。
 * グローバルモジュールフラグメント内の宣言は、後続のモジュールに属する宣言から参照されていない場合は、**破棄**(discard)される。
+* グローバルモジュールフラグメントの宣言はプリプロセッサで生成してはならない。
 
 ### エクスポート
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- Update modules.md</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>b568b88143ceaf886d75d10875854fbeaa7b2071:lang/cpp20/modules.md</id>
      <updated>2021-05-24T03:36:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index 04dd4e08e..9a6dc20d4 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -156,7 +156,6 @@ module :private;
 
 プライベートモジュールフラグメントを記述する場合、そのモジュールは翻訳単位(必然的にモジュールインターフェースユニット)を1つしか持つことができない。
 
-
 #### グローバルモジュール
 
 C++20では、名前のあるモジュールに属していない宣言はグローバルモジュールに属している。
@@ -169,6 +168,22 @@ C++20では、名前のあるモジュールに属していない宣言はグロ
 
 グローバルモジュールとは、要するに従来通りの、モジュールではないコードのことである。C++20では、`main`関数はグローバルモジュールに属していなければならない。
 
+#### グローバルモジュールフラグメント
+
+モジュール宣言の前にグローバルモジュールの実装を書ける。これをグローバルモジュールフラグメントという。
+
+```cpp
+module;             // グローバルモジュールフラグメントの宣言
+
+#include &amp;#34;lib.h&amp;#34;
+
+export module foo;  // モジュールの宣言(この上の行までがグローバルモジュールフラグメント)
+```
+
+* グローバルモジュールフラグメント内の宣言や定義は、後続のモジュールではなくグローバルモジュールに属する。
+* グローバルモジュールフラグメントにはプリプロセッサディレクティブ以外を書くことはできない。
+* グローバルモジュールフラグメント内の宣言は、後続のモジュールに属する宣言から参照されていない場合は、**破棄**(discard)される。
+
 ### エクスポート
 
 宣言の前に`export`キーワードを付加することでその宣言をエクスポートできる。
@@ -261,6 +276,8 @@ import lib; // libのインポート
 マクロや`using namespace`はエクスポートできないので、インポートによって取り込まれることはない。
 ヘッダーファイル中での `using namespace` はしばしば避けられるが、モジュールでは問題なく使うことができる。
 
+モジュールユニットの中では、インポート宣言はモジュールユニットの本体(グローバルモジュールフラグメントではない部分)の先頭で行わなければならない。
+
 #### 再エクスポート
 
 インポート宣言もエクスポートできる。これを再エクスポートという。
@@ -330,14 +347,9 @@ C++20までは到達可能という用語はなかったが、前者の条件を
 この例外はヘッダーファイルにクラス定義などを書いてインクルードした際にODR違反にならないための規定である。
 モジュールを定義する場合はヘッダーファイルは使わないから、実質的な影響はない。
 
-## 後方互換性のための機能
-
-### グローバルモジュールフラグメント
+複数のモジュールが`#include`で同じ宣言を取り込んだ場合はODR違反となってしまうので、基本的に名前のあるモジュールの本体で`#include`を使用してはならない。
 
-モジュール内ではODRの例外が働かないため、複数のモジュールが`#include`で同じ宣言を取り込んだ場合、ODR違反となってしまう。
-このため、モジュール内では基本的に`#include`を使用することはできない。
-
-しかし、それでは従来のライブラリが利用できないため、モジュール宣言の前にグローバルモジュールの実装を書けるようになっている。これをグローバルモジュールフラグメントという。
+モジュールユニットの中で`#include`を使用したい場合、グローバルモジュールフラグメント内で行えば従来通りにODRの例外となる。
 
 ```cpp
 module;             // グローバルモジュールフラグメントの宣言
@@ -349,13 +361,6 @@ export module foo;  // モジュールの宣言(この上の行までがグロ
 #include &amp;#34;lib.h&amp;#34;    // &amp;#34;lib.h&amp;#34;中の宣言がモジュールfooに含まれてしまう(ODRの例外なし = ODR違反の可能性大)。
 ```
 
-モジュールユニットでの`#include`はグローバルモジュールフラグメントで行うべきである。
-
-グローバルモジュールフラグメントにはプリプロセッサディレクティブのみ記述できる。
-翻訳フェーズ4(=プリプロセッサ実行時)以前の段階でそれ以外の記述がある場合は、エラーとなる。
-
-グローバルモジュールフラグメント内の宣言は、後続のモジュールに属する宣言から参照されていない場合は、**破棄**(discard)される。
-
 ### ヘッダーユニット
 
 一部のヘッダーファイルは、モジュールとしてインポートすることができる。この機能およびヘッダーファイルから生成される翻訳単位をヘッダーユニットという。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>