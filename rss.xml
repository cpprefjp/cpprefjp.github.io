<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-02-06T02:00:00.282208</updated>
  <id>c7f2164e-25d2-4812-894b-b4fb0ae9f4e1</id>

  
    <entry>
      <title>rcu -- rcu: 微調整 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu.html"/>
      <id>c7a7c9dcbeaf0bc60ea3c752269d693323a7db97:reference/rcu.md</id>
      <updated>2025-02-06T10:48:43+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;rcu&lt;/span&gt;&lt;span class=&#34;cpp cpp26&#34; title=&#34;C++26で追加&#34;&gt;(C++26)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;rcu&amp;gt;&lt;/code&gt;ヘッダでは、並行なデータの参照・更新を実現する&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%BC%E3%83%89%E3%83%BB%E3%82%B3%E3%83%94%E3%83%BC%E3%83%BB%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88&#34; target=&#34;_blank&#34;&gt;Read-Copy Update(RCU)機構&lt;/a&gt;のための部品を定義する。&lt;/p&gt;
&lt;p&gt;RCU同期メカニズムは、複数スレッド間で共有されるリンク方式データ構造が高頻度で参照され、稀に更新されるようなユースケースに適している。RCU機構のデータ読み取りではスレッド間の排他制御を行わず、更新操作により不要となった古いデータを安全に回収（メモリ解放）するタイミングを制御する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_obj_base.html&#34;&gt;rcu_obj_base&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCU対象オブジェクトの基底クラス(class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_domain.html&#34;&gt;rcu_domain&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCUドメイン(class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_default_domain.html&#34;&gt;rcu_default_domain&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトのRCUドメイン取得(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_synchronize.html&#34;&gt;rcu_synchronize&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCUドメインのアンロック完了を待機(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_barrier.html&#34;&gt;rcu_barrier&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ回収操作完了を待機(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_retire.html&#34;&gt;rcu_retire&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ回収操作をスケジュール(function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++26&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#icc&#34;&gt;ICC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: ??&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf&#34; target=&#34;_blank&#34;&gt;P2545R4 Read-Copy Update(RCU)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_obj_base -- rcu: 微調整 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_obj_base.html"/>
      <id>c7a7c9dcbeaf0bc60ea3c752269d693323a7db97:reference/rcu/rcu_obj_base.md</id>
      <updated>2025-02-06T10:48:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_obj_base.md b/reference/rcu/rcu_obj_base.md
index c5b30d33c..3a36d3ebc 100644
--- a/reference/rcu/rcu_obj_base.md
+++ b/reference/rcu/rcu_obj_base.md
@@ -85,8 +85,11 @@ int main()
 ```
 * std::rcu_obj_base[color ff0000]
 * std::rcu_default_domain[link rcu_default_domain.md]
+* retire()[link rcu_obj_base/retire.md]
 * std::scoped_lock[link /reference/mutex/scoped_lock.md]
-
+* std::jthread[link /reference/thread/jthread.md]
+* exchange[link /reference/atomic/atomic/exchange.md]
+* store[link /reference/atomic/atomic/store.md]
 
 ### 出力例
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>retire -- rcu: 微調整 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_obj_base/retire.html"/>
      <id>c7a7c9dcbeaf0bc60ea3c752269d693323a7db97:reference/rcu/rcu_obj_base/retire.md</id>
      <updated>2025-02-06T10:48:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_obj_base/retire.md b/reference/rcu/rcu_obj_base/retire.md
index 8c04fcde7..2a8e7edc3 100644
--- a/reference/rcu/rcu_obj_base/retire.md
+++ b/reference/rcu/rcu_obj_base/retire.md
@@ -17,7 +17,11 @@ RCU機構により保護されるオブジェクト回収をスケジュール
 
 
 ## 適格要件
-クラステンプレートパラメータ`T`がRCU保護可能(rcu-protectable)な型であること。
+クラステンプレートパラメータ`T`が、下記条件を満たすRCU保護可能(rcu-protectable)な型であること。
+
+- `rcu_obj_base&amp;lt;T,D&amp;gt;`型を唯一の基底クラスとして持つクラス型であり、かつ
+- その基底は公開(public)かつ非仮想基底クラスであり、かつ
+- 型`X`, `Y`の他の組合せに対して`rcu_obj_base&amp;lt;X, Y&amp;gt;`型を基底クラスとして持たない。
 
 
 ## 事前条件
@@ -27,8 +31,8 @@ RCU機構により保護されるオブジェクト回収をスケジュール
 
 
 ## 効果
-- `deleter = std::move(d)`を評価し、
-- RCUドメイン`dom`に対して式`deleter(addressof(x))`の評価をスケジュールする。
+- `deleter =` [`std::move`](/reference/utility/move.md)`(d)`を評価し、
+- RCUドメイン`dom`に対して式`deleter(`[`addressof`](/reference/memory/addressof.md)`(x))`の評価をスケジュールする。
     - 評価が例外で終了した場合は未定義の動作を引き起こす。
 - `dom`に対してスケジュールされた評価を呼び出す可能性がある。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_retire -- rcu: 微調整 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_retire.html"/>
      <id>c7a7c9dcbeaf0bc60ea3c752269d693323a7db97:reference/rcu/rcu_retire.md</id>
      <updated>2025-02-06T10:48:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_retire.md b/reference/rcu/rcu_retire.md
index 469ac230f..d4d63c374 100644
--- a/reference/rcu/rcu_retire.md
+++ b/reference/rcu/rcu_retire.md
@@ -31,7 +31,7 @@ RCU機構により保護されるオブジェクト回収をスケジュール
 ## 効果
 - メモリを確保する可能性がある。
     - メモリ確保が`operator new`を呼び出すか否かは未規定である。
-- `D`型のオブジェクト`d1`を`std::move(d)`で初期化する。
+- `D`型のオブジェクト`d1`を[`std::move`](/reference/utility/move.md)`(d)`で初期化する。
 - RCUドメイン`dom`に対して式`d1(p)`の評価をスケジュールする。
     - 評価が例外で終了した場合は未定義の動作を引き起こす。
 - `dom`に対してスケジュールされた評価を呼び出す可能性がある。
@@ -97,6 +97,9 @@ int main()
 * std::rcu_retire[color ff0000]
 * std::rcu_default_domain[link rcu_default_domain.md]
 * std::scoped_lock[link /reference/mutex/scoped_lock.md]
+* std::jthread[link /reference/thread/jthread.md]
+* exchange[link /reference/atomic/atomic/exchange.md]
+* store[link /reference/atomic/atomic/store.md]
 
 ### 出力例
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_synchronize -- rcu: 微調整 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_synchronize.html"/>
      <id>c7a7c9dcbeaf0bc60ea3c752269d693323a7db97:reference/rcu/rcu_synchronize.md</id>
      <updated>2025-02-06T10:48:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_synchronize.md b/reference/rcu/rcu_synchronize.md
index b86626ada..713b6ab02 100644
--- a/reference/rcu/rcu_synchronize.md
+++ b/reference/rcu/rcu_synchronize.md
@@ -88,6 +88,9 @@ int main()
 * std::rcu_synchronize[color ff0000]
 * std::rcu_default_domain[link rcu_default_domain.md]
 * std::scoped_lock[link /reference/mutex/scoped_lock.md]
+* std::jthread[link /reference/thread/jthread.md]
+* exchange[link /reference/atomic/atomic/exchange.md]
+* store[link /reference/atomic/atomic/store.md]
 
 ### 出力例
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu -- rcu: 非メンバ関数群 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu.html"/>
      <id>9a152c20b0cb59dc18745b2f1afe8ec8e73e0afc:reference/rcu.md</id>
      <updated>2025-02-05T19:01:51+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;rcu&lt;/span&gt;&lt;span class=&#34;cpp cpp26&#34; title=&#34;C++26で追加&#34;&gt;(C++26)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;rcu&amp;gt;&lt;/code&gt;ヘッダでは、並行なデータの参照・更新を実現する&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%BC%E3%83%89%E3%83%BB%E3%82%B3%E3%83%94%E3%83%BC%E3%83%BB%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88&#34; target=&#34;_blank&#34;&gt;Read-Copy Update(RCU)機構&lt;/a&gt;のための部品を定義する。&lt;/p&gt;
&lt;p&gt;RCU同期メカニズムは、複数スレッド間で共有されるデータが高頻度で参照され、稀に更新されるようなユースケースに適している。RCU機構はスレッド間の排他制御を行わず、更新操作により不要となった古いデータを安全に解放するタイミング制御を行う。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_obj_base.html&#34;&gt;rcu_obj_base&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCU対象オブジェクトの基底クラス(class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_domain.html&#34;&gt;rcu_domain&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCUドメイン(class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_default_domain.html&#34;&gt;rcu_default_domain&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトのRCUドメイン取得(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_synchronize.html&#34;&gt;rcu_synchronize&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCUドメインのアンロック完了を待機(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_barrier.html&#34;&gt;rcu_barrier&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ回収操作完了を待機(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_retire.html&#34;&gt;rcu_retire&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ回収操作をスケジュール(function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++26&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#icc&#34;&gt;ICC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: ??&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf&#34; target=&#34;_blank&#34;&gt;P2545R4 Read-Copy Update(RCU)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_barrier -- rcu: 非メンバ関数群 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_barrier.html"/>
      <id>9a152c20b0cb59dc18745b2f1afe8ec8e73e0afc:reference/rcu/rcu_barrier.md</id>
      <updated>2025-02-05T19:01:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_barrier.md b/reference/rcu/rcu_barrier.md
new file mode 100644
index 000000000..0d23366de
--- /dev/null
+++ b/reference/rcu/rcu_barrier.md
@@ -0,0 +1,57 @@
+# rcu_barrier
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  void rcu_barrier(rcu_domain&amp;amp; dom = rcu_default_domain()) noexcept;
+}
+```
+* rcu_domain[link rcu_domain.md]
+* rcu_default_domain[link rcu_default_domain.md]
+
+## 概要
+スケジュールされたメモリ回収操作の完了を待機する。
+
+
+## 効果
+RCUドメイン`dom`上でスケジュールされた回収操作を評価する可能性がある。
+`rcu_barrier`呼び出しよりも前に発生する評価で、かつ`dom`上での操作`E`をスケジュールする評価については、`E`が評価されるまでブロックする。
+
+
+## 同期操作
+`E`のあらゆる評価は、`rcu_barrier`からの戻りよりも確実に前に発生する。
+
+
+## 戻り値
+なし
+
+
+## 例外
+投げない
+
+
+## 備考
+`rcu_barrier`呼び出しは、暗黙に[`rcu_synchronize`](rcu_synchronize.md)を呼ばない。
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`rcu_retire`](rcu_retire.md)
+- [`rcu_obj_base::retire`](rcu_obj_base/retire.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_domain -- rcu: 非メンバ関数群 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_domain.html"/>
      <id>9a152c20b0cb59dc18745b2f1afe8ec8e73e0afc:reference/rcu/rcu_domain.md</id>
      <updated>2025-02-05T19:01:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_domain.md b/reference/rcu/rcu_domain.md
index b3a6b5369..07e054918 100644
--- a/reference/rcu/rcu_domain.md
+++ b/reference/rcu/rcu_domain.md
@@ -14,7 +14,7 @@ namespace std {
 RCU同期メカニズムで保護する共有データに対応付ける、RCUドメインを表現する。
 
 `rcu_domain`クラスは Cpp17Lockable 要件を満たし、共有データの読み取りをおこなうRCU保護区間を表現する。
-RCU保護区間は`lock`呼び出しから`unlock()`呼び出しのまでの区間であり、RCUドメインに対して同一スレッド上でのRCU保護区間は入れ子になってもよい。
+RCU保護区間は[`lock`](rcu_domain/lock.md)呼び出しから[`unlock`](rcu_domain/unlock.md)呼び出しのまでの区間であり、RCUドメインに対して同一スレッド上でのRCU保護区間は入れ子になってもよい。
 
 
 ## メンバ関数
@@ -67,7 +67,7 @@ int main()
 
 ## 関連項目
 - [`rcu_default_domain`](rcu_default_domain.md)
-- [`rcu_retire`](rcu_retire.md.nolink)
+- [`rcu_retire`](rcu_retire.md)
 - [`rcu_obj_base::retire`](rcu_obj_base/retire.md)
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unlock -- rcu: 非メンバ関数群 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_domain/unlock.html"/>
      <id>9a152c20b0cb59dc18745b2f1afe8ec8e73e0afc:reference/rcu/rcu_domain/unlock.md</id>
      <updated>2025-02-05T19:01:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_domain/unlock.md b/reference/rcu/rcu_domain/unlock.md
index bd315492b..acbfa07a1 100644
--- a/reference/rcu/rcu_domain/unlock.md
+++ b/reference/rcu/rcu_domain/unlock.md
@@ -19,7 +19,7 @@ RCU機構により保護される共有データの読み取り終了を宣言
 
 ## 効果
 直近に開かれたRCU保護区間を閉じる。
-`*this`上でスケジュールされた再利用操作を呼び出す可能性がある。
+`*this`上でスケジュールされた回収操作を呼び出す可能性がある。
 
 
 ## 戻り値
@@ -43,8 +43,8 @@ RCU機構により保護される共有データの読み取り終了を宣言
 
 ## 関連項目
 - [`lock`](lock.md)
-- [`rcu_retire`](../rcu_retire.md.nolink)
-- [`rcu_obj_base::retire`](../rcu_rcu_obj_base/retire.md.nolink)
+- [`rcu_retire`](../rcu_retire.md)
+- [`rcu_obj_base::retire`](../rcu_obj_base/retire.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_obj_base -- rcu: 非メンバ関数群 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_obj_base.html"/>
      <id>9a152c20b0cb59dc18745b2f1afe8ec8e73e0afc:reference/rcu/rcu_obj_base.md</id>
      <updated>2025-02-05T19:01:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_obj_base.md b/reference/rcu/rcu_obj_base.md
index 0e2bc9bce..c5b30d33c 100644
--- a/reference/rcu/rcu_obj_base.md
+++ b/reference/rcu/rcu_obj_base.md
@@ -31,7 +31,7 @@ RCU機構の保護対象とする型の基底クラス。
 | [`(constructor)`](rcu_obj_base/op_constructor.md) | コンストラクタ | C++26 |
 | `(destructor)` | デストラクタ | C++26 |
 | [`operator=`](rcu_obj_base/op_assign.md) | 代入演算子 | C++26 |
-| [`retire`](rcu_obj_base/retire.md) | オブジェクト再利用をスケジュールする | C++26 |
+| [`retire`](rcu_obj_base/retire.md) | オブジェクト回収をスケジュールする | C++26 |
 
 
 ## 例
@@ -64,7 +64,7 @@ void updater()
   Data *old_data = data.exchange(newdata);
 
   // 古いデータを読み取り中のスレッドがなくなったタイミングで
-  // データ領域の再利用(メモリ解放)を行うようスケジューリングする
+  // データ領域の回収(メモリ解放)を行うようスケジューリングする
   old_data-&amp;gt;retire();
 }
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>retire -- rcu: 非メンバ関数群 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_obj_base/retire.html"/>
      <id>9a152c20b0cb59dc18745b2f1afe8ec8e73e0afc:reference/rcu/rcu_obj_base/retire.md</id>
      <updated>2025-02-05T19:01:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_obj_base/retire.md b/reference/rcu/rcu_obj_base/retire.md
index deadc7b28..8c04fcde7 100644
--- a/reference/rcu/rcu_obj_base/retire.md
+++ b/reference/rcu/rcu_obj_base/retire.md
@@ -13,7 +13,7 @@ void retire(D d = D(),
 * rcu_default_domain[link ../rcu_default_domain.md]
 
 ## 概要
-RCU機構により保護されるオブジェクト再利用をスケジュールする。
+RCU機構により保護されるオブジェクト回収をスケジュールする。
 
 
 ## 適格要件
@@ -50,6 +50,7 @@ RCU機構により保護されるオブジェクト再利用をスケジュー
 
 ## 関連項目
 - [`rcu_domain::unlock`](../rcu_domain/unlock.md)
+- [`rcu_retire`](../rcu_retire.md)
 
 
 ## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_retire -- rcu: 非メンバ関数群 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_retire.html"/>
      <id>9a152c20b0cb59dc18745b2f1afe8ec8e73e0afc:reference/rcu/rcu_retire.md</id>
      <updated>2025-02-05T19:01:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_retire.md b/reference/rcu/rcu_retire.md
new file mode 100644
index 000000000..469ac230f
--- /dev/null
+++ b/reference/rcu/rcu_retire.md
@@ -0,0 +1,125 @@
+# rcu_retire
+* rcu[meta header]
+* function template[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std{
+  template&amp;lt;class T, class D = default_delete&amp;lt;T&amp;gt;&amp;gt;
+  void rcu_retire(T* p,
+                  D d = D(),
+                  rcu_domain&amp;amp; dom = rcu_default_domain());
+}
+```
+* default_delete[link /reference/memory/default_delete.md]
+* rcu_domain[link rcu_domain.md]
+* rcu_default_domain[link rcu_default_domain.md]
+
+## 概要
+RCU機構により保護されるオブジェクト回収をスケジュールする。
+
+
+## 適格要件
+[`is_move_constructible_v`](/reference/type_traits/is_move_constructible.md)`&amp;lt;D&amp;gt; == true`、かつ式`d(p)`が妥当であること。
+
+
+## 事前条件
+`D`はCpp17MoveCosntructible要件およびCpp17Destructible要件をみたすこと。
+
+
+## 効果
+- メモリを確保する可能性がある。
+    - メモリ確保が`operator new`を呼び出すか否かは未規定である。
+- `D`型のオブジェクト`d1`を`std::move(d)`で初期化する。
+- RCUドメイン`dom`に対して式`d1(p)`の評価をスケジュールする。
+    - 評価が例外で終了した場合は未定義の動作を引き起こす。
+- `dom`に対してスケジュールされた評価を呼び出す可能性がある。
+
+
+## 戻り値
+なし
+
+
+## 例外
+[`bad_alloc`](/reference/new/bad_alloc.md)、または`d1`初期化中に送出された例外。
+
+
+## 例
+```cpp example
+#include &amp;lt;atomic&amp;gt;
+#include &amp;lt;mutex&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;rcu&amp;gt;
+
+struct Data {
+  int m1, m2;
+};
+
+// 共有データを指すポインタ
+std::atomic&amp;lt;Data*&amp;gt; data;
+
+void reader()
+{
+  std::scoped_lock slk{std::rcu_default_domain()};
+  // 共有データを読み取り(Read)
+  Data *p = data;
+
+  std::println(&amp;#34;{} {}&amp;#34;, p-&amp;gt;m1, p-&amp;gt;m2);
+}
+
+void updater()
+{
+  Data *newdata = new Data{1, 2};
+  // 新しいデータで共有データを更新(Update)
+  Data *old_data = data.exchange(newdata);
+
+  // 古いデータを読み取り中のスレッドがなくなったタイミングで
+  // データ領域の回収(メモリ解放)を行うようスケジューリングする
+  std::rcu_retire(old_data);
+}
+
+int main()
+{
+  // 共有データ初期化
+  Data *newdata = new Data{0, 0};
+  data.store(newdata);
+
+  // 共有データへ並行アクセス
+  std::jthread th{[] {
+    for (int i = 0; i &amp;lt; 3; i++) {
+      reader();
+    }
+  }};
+  updater();
+}
+```
+* std::rcu_retire[color ff0000]
+* std::rcu_default_domain[link rcu_default_domain.md]
+* std::scoped_lock[link /reference/mutex/scoped_lock.md]
+
+### 出力例
+```
+0 0
+1 2
+1 2
+```
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`rcu_domain::unlock`](rcu_domain/unlock.md)
+- [`rcu_obj_base::retire`](rcu_obj_base/retire.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_synchronize -- rcu: 非メンバ関数群 (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_synchronize.html"/>
      <id>9a152c20b0cb59dc18745b2f1afe8ec8e73e0afc:reference/rcu/rcu_synchronize.md</id>
      <updated>2025-02-05T19:01:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_synchronize.md b/reference/rcu/rcu_synchronize.md
new file mode 100644
index 000000000..b86626ada
--- /dev/null
+++ b/reference/rcu/rcu_synchronize.md
@@ -0,0 +1,116 @@
+# rcu_synchronize
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  void rcu_synchronize(rcu_domain&amp;amp; dom = rcu_default_domain()) noexcept;
+}
+```
+* rcu_domain[link rcu_domain.md]
+* rcu_default_domain[link rcu_default_domain.md]
+
+## 概要
+RCUドメインのアンロック完了を待機する。
+
+
+## 効果
+もし`rcu_synchronize`呼び出しが`dom`上のRCU保護区間`R`のロックを開く操作よりも確実に前に発生するのでなければ、`R`を閉じる[`unlock`](rcu_domain/unlock.md)まで現スレッドをブロックする。
+
+
+## 同期操作
+`R`を閉じる[`unlock`](rcu_domain/unlock.md)は、`rcu_synchronize`からの戻りよりも確実に前に発生する。
+
+
+## 戻り値
+なし
+
+
+## 例外
+投げない
+
+
+## 備考
+`rcu_synchronize`呼び出しは、暗黙に[`rcu_barrier`](rcu_barrier.md)を呼ばない。
+
+
+## 例
+```cpp example
+#include &amp;lt;atomic&amp;gt;
+#include &amp;lt;mutex&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;rcu&amp;gt;
+
+struct Data {
+  int m1, m2;
+};
+
+// 共有データを指すポインタ
+std::atomic&amp;lt;Data*&amp;gt; data;
+
+void reader()
+{
+  std::scoped_lock slk{std::rcu_default_domain()};
+  // 共有データを読み取り(Read)
+  Data *p = data;
+
+  std::println(&amp;#34;{} {}&amp;#34;, p-&amp;gt;m1, p-&amp;gt;m2);
+}
+
+void updater()
+{
+  Data *newdata = new Data{1, 2};
+  // 新しいデータで共有データを更新(Update)
+  Data *old_data = data.exchange(newdata);
+
+  // 古いデータを読み取り中のスレッドがなくるまで待機する
+  std::rcu_synchronize();
+  delete old_data;
+}
+
+int main()
+{
+  // 共有データ初期化
+  Data *newdata = new Data{0, 0};
+  data.store(newdata);
+
+  // 共有データへ並行アクセス
+  std::jthread th{[] {
+    for (int i = 0; i &amp;lt; 3; i++) {
+      reader();
+    }
+  }};
+  updater();
+}
+```
+* std::rcu_synchronize[color ff0000]
+* std::rcu_default_domain[link rcu_default_domain.md]
+* std::scoped_lock[link /reference/mutex/scoped_lock.md]
+
+### 出力例
+```
+0 0
+1 2
+1 2
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`rcu_domain`](rcu_domain.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;rcu&lt;/span&gt;&lt;span class=&#34;cpp cpp26&#34; title=&#34;C++26で追加&#34;&gt;(C++26)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;rcu&amp;gt;&lt;/code&gt;ヘッダでは、並行なデータの参照・更新を実現する&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%BC%E3%83%89%E3%83%BB%E3%82%B3%E3%83%94%E3%83%BC%E3%83%BB%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88&#34; target=&#34;_blank&#34;&gt;Read-Copy Update(RCU)機構&lt;/a&gt;のための部品を定義する。&lt;/p&gt;
&lt;p&gt;RCU同期メカニズムは、複数スレッド間で共有されるデータが高頻度で参照され、稀に更新されるようなユースケースに適している。RCU機構はスレッド間の排他制御を行わず、更新操作により不要となった古いデータを安全に解放するタイミング制御を行う。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_obj_base.html&#34;&gt;rcu_obj_base&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCU対象オブジェクトの基底クラス(class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_domain.html&#34;&gt;rcu_domain&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCUドメイン(class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_default_domain.html&#34;&gt;rcu_default_domain&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトのRCUドメイン取得(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_synchronize.md.nolink&#34;&gt;rcu_synchronize&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCUドメインのアンロック完了を待機(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_barrier.md.nolink&#34;&gt;rcu_barrier&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ解放操作完了を待機(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_barrier.md.nolink&#34;&gt;rcu_retire&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ解放操作をスケジュル(function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++26&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#icc&#34;&gt;ICC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: ??&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf&#34; target=&#34;_blank&#34;&gt;P2545R4 Read-Copy Update(RCU)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_default_domain -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_default_domain.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_default_domain.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_default_domain.md b/reference/rcu/rcu_default_domain.md
new file mode 100644
index 000000000..8fc46425f
--- /dev/null
+++ b/reference/rcu/rcu_default_domain.md
@@ -0,0 +1,47 @@
+# rcu_default_domain
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  rcu_domain&amp;amp; rcu_default_domain() noexcept;
+}
+```
+* rcu_domain[link rcu_domain.md]
+
+## 概要
+デフォルトのRCUドメインを取得する。
+
+
+## 戻り値
+静的記憶域期間をもつ[`rcu_domain`](rcu_domain.md)オブジェクトへの参照を返す。
+この関数は常に同一オブジェクトへの参照を返す。
+
+
+## 例外
+投げない
+
+
+## 備考
+C++26時点では、この関数が[`rcu_domain`](rcu_domain.md)オブジェクトを作成する唯一の手段となっている。
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`rcu_domain`](rcu_domain.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_domain -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_domain.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_domain.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_domain.md b/reference/rcu/rcu_domain.md
new file mode 100644
index 000000000..b3a6b5369
--- /dev/null
+++ b/reference/rcu/rcu_domain.md
@@ -0,0 +1,75 @@
+# rcu_domain
+* rcu[meta header]
+* class[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  class rcu_domain;
+}
+```
+
+## 概要
+RCU同期メカニズムで保護する共有データに対応付ける、RCUドメインを表現する。
+
+`rcu_domain`クラスは Cpp17Lockable 要件を満たし、共有データの読み取りをおこなうRCU保護区間を表現する。
+RCU保護区間は`lock`呼び出しから`unlock()`呼び出しのまでの区間であり、RCUドメインに対して同一スレッド上でのRCU保護区間は入れ子になってもよい。
+
+
+## メンバ関数
+
+| 名前            | 説明           | 対応バージョン |
+|-----------------|----------------|-------|
+| `(constructor)` | コンストラクタ | C++26 |
+| `operator=`     | 代入演算子     | C++26 |
+| [`lock`](rcu_domain/lock.md) | 共有データの読み取り開始を宣言 | C++26 |
+| [`try_lock`](rcu_domain/try_lock.md) | 共有データの読み取り開始を宣言 | C++26 |
+| [`unlock`](rcu_domain/unlock.md) | 共有データの読み取り終了を宣言 | C++26 |
+
+
+## 例
+```cpp example
+#include &amp;lt;rcu&amp;gt;
+#include &amp;lt;mutex&amp;gt;
+
+int main()
+{
+  std::rcu_domain&amp;amp; dom = std::rcu_default_domain();
+
+  {
+    std::scoped_lock rlock(dom);
+    // dom.lock()が呼ばれる
+
+  } // dom.unlock()が呼ばれる
+}
+```
+* std::rcu_domain[color ff0000]
+* std::rcu_default_domain[link rcu_default_domain.md]
+* std::scoped_lock[link /reference/mutex/scoped_lock.md]
+
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`rcu_default_domain`](rcu_default_domain.md)
+- [`rcu_retire`](rcu_retire.md.nolink)
+- [`rcu_obj_base::retire`](rcu_obj_base/retire.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lock -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_domain/lock.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_domain/lock.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_domain/lock.md b/reference/rcu/rcu_domain/lock.md
new file mode 100644
index 000000000..cf7096b33
--- /dev/null
+++ b/reference/rcu/rcu_domain/lock.md
@@ -0,0 +1,44 @@
+# lock
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* rcu_domain[meta class]
+* cpp26[meta cpp]
+
+```cpp
+void lock() noexcept;
+```
+
+## 概要
+RCU機構により保護される共有データの読み取り開始を宣言する。
+
+
+## 効果
+RCU保護区間を開く。
+
+
+## 戻り値
+なし
+
+
+## 例外
+投げない
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`unlock`](unlock.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>try_lock -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_domain/try_lock.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_domain/try_lock.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_domain/try_lock.md b/reference/rcu/rcu_domain/try_lock.md
new file mode 100644
index 000000000..686a7d9d0
--- /dev/null
+++ b/reference/rcu/rcu_domain/try_lock.md
@@ -0,0 +1,44 @@
+# try_lock
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* rcu_domain[meta class]
+* cpp26[meta cpp]
+
+```cpp
+bool try_lock() noexcept;
+```
+
+## 概要
+RCU機構により保護される共有データの読み取り開始を宣言する。
+
+
+## 効果
+[`lock()`](lock.md)と等価。
+
+
+## 戻り値
+`true`
+
+
+## 例外
+投げない
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`unlock`](unlock.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unlock -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_domain/unlock.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_domain/unlock.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_domain/unlock.md b/reference/rcu/rcu_domain/unlock.md
new file mode 100644
index 000000000..bd315492b
--- /dev/null
+++ b/reference/rcu/rcu_domain/unlock.md
@@ -0,0 +1,51 @@
+# unlock
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* rcu_domain[meta class]
+* cpp26[meta cpp]
+
+```cpp
+void unlock() noexcept;
+```
+
+## 概要
+RCU機構により保護される共有データの読み取り終了を宣言する。
+
+
+## 事前条件
+まだ閉じられていないRCU保護区間を開いた[`lock`](lock.md)呼び出しが、`unlock`呼び出しよりも前に順序付けられること。
+
+
+## 効果
+直近に開かれたRCU保護区間を閉じる。
+`*this`上でスケジュールされた再利用操作を呼び出す可能性がある。
+
+
+## 戻り値
+なし
+
+
+## 例外
+投げない
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`lock`](lock.md)
+- [`rcu_retire`](../rcu_retire.md.nolink)
+- [`rcu_obj_base::retire`](../rcu_rcu_obj_base/retire.md.nolink)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu_obj_base -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_obj_base.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_obj_base.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_obj_base.md b/reference/rcu/rcu_obj_base.md
new file mode 100644
index 000000000..0e2bc9bce
--- /dev/null
+++ b/reference/rcu/rcu_obj_base.md
@@ -0,0 +1,115 @@
+# rcu_obj_base
+* rcu[meta header]
+* class template[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class T, class D = default_delete&amp;lt;T&amp;gt;&amp;gt;
+  class rcu_obj_base;
+}
+```
+* default_delete[link /reference/memory/default_delete.md]
+
+## 概要
+RCU機構の保護対象とする型の基底クラス。
+
+使用するときは、`T`で`rcu_obj_base`を公開継承した上で派生クラス`T`を`rcu_obj_base`のテンプレート引数にする(CRTP)。
+
+
+## 適格要件
+- `T`は不完全型でもよいが、特殊化された`rcu_obj_base`のメンバが参照されるまでに完全型とすること。
+- `D`は関数オブジェクト型であり、`D`型の値`d`と`T*`型の値`ptr`に対して式`d(ptr)`が有効であること。
+- `D`型は要件 Cpp17DefaultConstructible およ Cpp17MoveAssignable を満たすこと。
+
+
+## メンバ関数
+
+| 名前            | 説明           | 対応バージョン |
+|-----------------|----------------|-------|
+| [`(constructor)`](rcu_obj_base/op_constructor.md) | コンストラクタ | C++26 |
+| `(destructor)` | デストラクタ | C++26 |
+| [`operator=`](rcu_obj_base/op_assign.md) | 代入演算子 | C++26 |
+| [`retire`](rcu_obj_base/retire.md) | オブジェクト再利用をスケジュールする | C++26 |
+
+
+## 例
+```cpp example
+#include &amp;lt;atomic&amp;gt;
+#include &amp;lt;mutex&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;rcu&amp;gt;
+
+struct Data : std::rcu_obj_base&amp;lt;Data&amp;gt; {
+  int m1, m2;
+};
+
+// 共有データを指すポインタ
+std::atomic&amp;lt;Data*&amp;gt; data;
+
+void reader()
+{
+  std::scoped_lock slk{std::rcu_default_domain()};
+  // 共有データを読み取り(Read)
+  Data *p = data;
+
+  std::println(&amp;#34;{} {}&amp;#34;, p-&amp;gt;m1, p-&amp;gt;m2);
+}
+
+void updater()
+{
+  Data *newdata = new Data{1, 2};
+  // 新しいデータで共有データを更新(Update)
+  Data *old_data = data.exchange(newdata);
+
+  // 古いデータを読み取り中のスレッドがなくなったタイミングで
+  // データ領域の再利用(メモリ解放)を行うようスケジューリングする
+  old_data-&amp;gt;retire();
+}
+
+int main()
+{
+  // 共有データ初期化
+  Data *newdata = new Data{0, 0};
+  data.store(newdata);
+
+  // 共有データへ並行アクセス
+  std::jthread th{[] {
+    for (int i = 0; i &amp;lt; 3; i++) {
+      reader();
+    }
+  }};
+  updater();
+}
+```
+* std::rcu_obj_base[color ff0000]
+* std::rcu_default_domain[link rcu_default_domain.md]
+* std::scoped_lock[link /reference/mutex/scoped_lock.md]
+
+
+### 出力例
+```
+0 0
+1 2
+1 2
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`rcu_domain`](rcu_domain.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_obj_base/op_assign.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_obj_base/op_assign.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_obj_base/op_assign.md b/reference/rcu/rcu_obj_base/op_assign.md
new file mode 100644
index 000000000..e97ced383
--- /dev/null
+++ b/reference/rcu/rcu_obj_base/op_assign.md
@@ -0,0 +1,31 @@
+# operator=
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* rcu_obj_base[meta class]
+* cpp26[meta cpp]
+
+```cpp
+protected:
+  rcu_obj_base&amp;amp; operator=(const rcu_obj_base&amp;amp;) = default; // (1)
+  rcu_obj_base&amp;amp; operator=(rcu_obj_base&amp;amp;&amp;amp;) = default; // (2)
+```
+
+## 概要
+- (1): コピー代入演算子
+- (2): ムーブ代入演算子
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_obj_base/op_constructor.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_obj_base/op_constructor.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_obj_base/op_constructor.md b/reference/rcu/rcu_obj_base/op_constructor.md
new file mode 100644
index 000000000..d190c1366
--- /dev/null
+++ b/reference/rcu/rcu_obj_base/op_constructor.md
@@ -0,0 +1,33 @@
+# コンストラクタ
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* rcu_obj_base[meta class]
+* cpp26[meta cpp]
+
+```cpp
+protected:
+  rcu_obj_base() = default;  // (1)
+  rcu_obj_base(const rcu_obj_base&amp;amp;) = default;  // (2)
+  rcu_obj_base(rcu_obj_base&amp;amp;&amp;amp;) = default;  // (3)
+```
+
+## 概要
+- (1): デフォルトコンストラクタ
+- (2): コピーコンストラクタ
+- (3): ムーブコンストラクタ
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>retire -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/reference/rcu/rcu_obj_base/retire.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:reference/rcu/rcu_obj_base/retire.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/rcu/rcu_obj_base/retire.md b/reference/rcu/rcu_obj_base/retire.md
new file mode 100644
index 000000000..deadc7b28
--- /dev/null
+++ b/reference/rcu/rcu_obj_base/retire.md
@@ -0,0 +1,56 @@
+# retire
+* rcu[meta header]
+* function[meta id-type]
+* std[meta namespace]
+* rcu_obj_base[meta class]
+* cpp26[meta cpp]
+
+```cpp
+void retire(D d = D(),
+            rcu_domain&amp;amp; dom = rcu_default_domain()) noexcept;
+```
+* rcu_domain[link ../rcu_domain.md]
+* rcu_default_domain[link ../rcu_default_domain.md]
+
+## 概要
+RCU機構により保護されるオブジェクト再利用をスケジュールする。
+
+
+## 適格要件
+クラステンプレートパラメータ`T`がRCU保護可能(rcu-protectable)な型であること。
+
+
+## 事前条件
+- `*this`が型`T`のオブジェクト`x`の基底クラスサブオブジェクトであること。
+- `x`に対して`rcu_obj_base&amp;lt;T,D&amp;gt;::retire`が呼び出されていないこと。
+- `D`型の説明専用メンバ変数`deleter`への代入が例外で終了しないこと。
+
+
+## 効果
+- `deleter = std::move(d)`を評価し、
+- RCUドメイン`dom`に対して式`deleter(addressof(x))`の評価をスケジュールする。
+    - 評価が例外で終了した場合は未定義の動作を引き起こす。
+- `dom`に対してスケジュールされた評価を呼び出す可能性がある。
+
+
+## 戻り値
+なし
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`rcu_domain::unlock`](../rcu_domain/unlock.md)
+
+
+## 参照
+- [P2545R4 Read-Copy Update(RCU)](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>スタイル -- rcu: rcu_domain, rcu_obj_base (#1183)</title>
      <link href="https://cpprefjp.github.io/working_style.html"/>
      <id>eda1e0cb5ff92058b61b14f52c3704846ce008ee:working_style.md</id>
      <updated>2025-01-31T15:33:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/working_style.md b/working_style.md
index 0c28b90af..c102272fd 100644
--- a/working_style.md
+++ b/working_style.md
@@ -123,6 +123,7 @@ C++11以降対応については対応バージョンを明記します。バー
 | pure virtual function              | 純粋仮想関数                 |
 | random access iterator             | ランダムアクセスイテレータ   |
 | range                              | 一般用途の場合：範囲&amp;lt;br/&amp;gt; Rangeアルゴリズム・Rangeアダプタ・Rangeオブジェクトの場合：Range&amp;lt;br/&amp;gt; range-based for：範囲for文&amp;lt;br/&amp;gt; 2つのイテレータによる範囲：イテレータ範囲 |
+| region of RCU protection           | RCU保護区間                  |
 | remarks                            | 備考                         |
 | requires                           | 要件                         |
 | returns                            | 戻り値                       |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>数値リテラルの桁区切り文字 [N3781] -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/lang/cpp14/digit_separators.html"/>
      <id>8fba13b4661d7c43d75deee657c43799e40a73a2:lang/cpp14/digit_separators.md</id>
      <updated>2025-01-30T20:30:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp14/digit_separators.md b/lang/cpp14/digit_separators.md
index c677b1915..d5c489e59 100644
--- a/lang/cpp14/digit_separators.md
+++ b/lang/cpp14/digit_separators.md
@@ -33,8 +33,8 @@ int binary_value = 0b1000&amp;#39;1111;
 - 桁区切り文字(digit separators)は、数値リテラルの読みやすさを向上させるため導入された、数値リテラルの間に挿入することを許可された特殊な文字である
 - 桁区切り文字には、シングルクォーテーション(`&amp;#39;`)を使用する
 - 桁区切り文字は、整数リテラルと浮動小数点数リテラルに対して使用できる
-- 桁区切り文字は、リテラルの先頭に入力することはできない
-- 浮動小数点数リテラルでは、小数部にも桁区切り文字を入力できる
+- 桁区切り文字は、数字並びの先頭や末尾に配置したり、2個以上を連続して配置することはできない
+- 浮動小数点数リテラルでは、小数部や指数部にも桁区切り文字を配置できる
 
 
 ## 例
@@ -50,7 +50,7 @@ int main()
   int octal_value = 0123&amp;#39;456;
   std::cout &amp;lt;&amp;lt; octal_value &amp;lt;&amp;lt; std::endl;
 
-  int hex_value = 0x123&amp;#39;456;
+  int hex_value = 0x12&amp;#39;34&amp;#39;56;
   std::cout &amp;lt;&amp;lt; hex_value &amp;lt;&amp;lt; std::endl;
 
   int binary_value = 0b1010&amp;#39;1010;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>条件付きで特殊メンバ関数をトリビアルに定義するように -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/conditionally_trivial_special_member_functions.html"/>
      <id>8fba13b4661d7c43d75deee657c43799e40a73a2:lang/cpp20/conditionally_trivial_special_member_functions.md</id>
      <updated>2025-01-30T20:30:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/conditionally_trivial_special_member_functions.md b/lang/cpp20/conditionally_trivial_special_member_functions.md
index 79ba772c0..6820cc28b 100644
--- a/lang/cpp20/conditionally_trivial_special_member_functions.md
+++ b/lang/cpp20/conditionally_trivial_special_member_functions.md
@@ -12,6 +12,7 @@
 ```cpp
 template&amp;lt;typename T&amp;gt;
 struct wrap {
+  T t;
   
   // 1. 制約されたdefaultなコピーコンストラクタ
   wrap(const wrap&amp;amp;) requires std::is_trivially_copy_constructible_v&amp;lt;T&amp;gt; = default;
@@ -23,14 +24,43 @@ struct wrap {
 };
 ```
 
-`T`が`std::is_trivially_copy_constructible`を満たす場合、1の宣言が選択され`wrap&amp;lt;T&amp;gt;`のコピーコンストラクタは`default`実装される（2のコンストラクタが選択されることは無い）。`T`が`std::is_trivially_copy_constructible`を満たさない場合、2の宣言が選択され`wrap&amp;lt;T&amp;gt;`のコピーコンストラクタはユーザー定義される。
+`T`が`std::is_trivially_copy_constructible`を満たす場合、1の宣言が選択され`wrap&amp;lt;T&amp;gt;`のコピーコンストラクタは`default`実装される（2のコンストラクタが選択されることは無い）。`T`が`std::is_trivially_copy_constructible`を満たさない場合、2の宣言が選択され`wrap&amp;lt;T&amp;gt;`のコピーコンストラクタはユーザー定義される（1のコンストラクタが選択されることは無い）。
 
-特に、`T`がトリビアルコピー可能である場合にこの仕組みによって1のコンストラクタが選択されれば、（他の条件を満たしているものとして）`wrap&amp;lt;T&amp;gt;`もまたトリビアルコピー可能となる。
+特に、`T`がトリビアルコピー可能である場合にこの仕組みによって1のコンストラクタが選択されれば、（他の条件を満たしているものとして）`wrap&amp;lt;T&amp;gt;`もまたトリビアルコピー可能となる。トリビアル性に関する他の性質も同様に伝播することが可能となる。
 
 ## 仕様
 
-(執筆中)
+次のいずれかの場合、2つの特殊メンバ関数は同種となる
+
+1. 両方ともデフォルトコンストラクタ
+2. 両方ともコピー/ムーブコンストラクタであり、最初の引数型が同じ
+3. 両方ともコピー/ムーブ代入演算子であり、最初の引数型と参照・CV修飾が同じ
+
+ある特殊メンバ関数が次の全てを満たす場合、それは資格のある（*eligible*）特殊メンバ関数となる
+
+1. `delete`されていない
+2. 関連制約がある場合（コンセプト機能により制約がなされている場合）、それが満たされている
+3. 同種の特殊メンバ関数で、より制約されているものがない
+
+次に、宣言されている全てのデストラクタはデストラクタ候補（*prospective destructor*）として扱われるようになる。そして、クラスの定義の最後（`};`が出現した場所と思って差し支えない）において、全てのデストラクタ候補の間で空の引数リストで呼び出す形でオーバーロード解決を実行し、そのクラスのデストラクタを選択する。
+
+こうして選ばれたデストラクタの事を選択されたデストラクタ（*selected destructor*）とも呼ぶが、この選択されたデストラクタだけがそのクラスのデストラクタとなる（規格書中の他のすべての箇所で単にデストラクタ（*destructor*）と呼ばれるものは、この選択されたデストラクタの事を指す）。なお、何らかの理由でオーバーロード解決が失敗した場合、プログラムは不適格となる。
+
+そして、あるクラスは次の条件を全て満たす場合にトリビアルコピー可能である
 
+1. 少なくとも1つの、資格のあるコピーコンストラクタ、ムーブコンストラクタ、コピー代入演算子、またはムーブ代入演算子を持つ
+2. それら資格のあるコピーコンストラクタ、ムーブコンストラクタ、コピー代入演算子、ムーブ代入演算子、はそれぞれすべてトリビアルである
+3. トリビアルで削除されていないデストラクタ（選択されたデストラクタ）を持つ
+
+また、あるクラスは次の条件をすべて満たす場合にトリビアルである
+
+1. トリビアルコピー可能である
+2. 1つ以上の資格のあるデフォルトコンストラクタを持つ
+3. それらのデフォルトコンストラクタは全てトリビアルである
+
+`default`宣言の扱いについては、選択されたデストラクタ以外の`default`指定されたデストラクタ候補は`delete`定義され、デストラクタ候補でも資格があるわけでもない`default`指定された特殊メンバ関数は`delete`定義される。
+
+コンセプトによって制約された特殊メンバ関数があるとき、どれが使用されるか（オーバーロード解決）については通常の制約された関数と同じルールに従って選択される。そして、そのような特殊メンバ関数を持つ型のトリビアル性に関する性質については、特殊メンバ関数のオーバーロードのうち資格があるもの（デストラクタの場合は選択されたもの）によって決定される。
 
 ## 例
 
@@ -57,13 +87,13 @@ int main()
 
 ## この機能が必要になった背景・経緯
 
-(執筆中)
-
+例にあるように、C++17まで、`std::optional`のようにテンプレートパラメータで指定された型の値を保持するラッパクラス型において、その指定された型のトリビアル性を伝播するためには非常に複雑な実装を必要としていた。
 
-## 検討されたほかの選択肢
+C++20のコンセプトの導入によって、コンセプトによって特殊メンバ関数の宣言を選択することができるようになっていたものの、トリビアル性（特にトリビアルコピー可能性）の規格上の定義がそれを考慮したものになっておらず、コンセプトによる特殊メンバ関数の選択は仕様として完全なものではなかった。
 
-(執筆中)
+この機能はそれを補うための仕組みであり、特殊メンバ関数に対するコンセプト制約自体は最初のコンセプト導入時から可能になっていたため、この機能は厳密にいえば仕様の調整のみである。
 
+この機能は、C++23の`std::expceted`の実装で活用されるだろう。
 
 ## ## &amp;lt;a id=&amp;#34;relative-page&amp;#34; href=&amp;#34;#relative-page&amp;#34;&amp;gt;関連項目&amp;lt;/a&amp;gt;
 
@@ -73,3 +103,4 @@ int main()
 
 - [P0848R0 Conditionally Trivial Special Member Functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0848r0.html)
 - [P0848R3 Conditionally Trivial Special Member Functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0848r3.html)
+- [What is a &amp;#34;prospective destructor&amp;#34; in C++20? - stackoverflow](https://stackoverflow.com/questions/66055641/what-is-a-prospective-destructor-in-c20)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++26 -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/lang/cpp26.html"/>
      <id>8fba13b4661d7c43d75deee657c43799e40a73a2:lang/cpp26.md</id>
      <updated>2025-01-30T20:30:43+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++26&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++26とは、2026年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中のためC++2cと呼ばれることがある。「(2020年代の3つ目のバージョンが) 202c年にリリースされる」という伏せ字として「c」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/static_storage_for_braced_initializers.md.nolink&#34;&gt;&lt;code&gt;std::initializer_list&lt;/code&gt;の配列を静的ストレージに配置する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::vector v = {1, 2, 3};&lt;/code&gt;のような初期化で初期化子リストを静的ストレージに配置することで無駄なコピーをなくす&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/nice_placeholder_with_no_name.html&#34;&gt;宣言のみで使用しない変数の名前として&lt;code&gt;_&lt;/code&gt;をサポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数名&lt;code&gt;_&lt;/code&gt;は暗黙で&lt;code&gt;[[maybe_unused]]&lt;/code&gt;が指定される&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/remove_deprecated_arithmetic_conversion_on_enumerations.html&#34;&gt;非推奨となっていた列挙型の算術変換を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++20から非推奨となっていた列挙値への算術演算で算術型に暗黙変換される仕様を削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/deleting_a_pointer_to_an_incomplete_type_should_be_ill-formed.md.nolink&#34;&gt;不完全型へのポインタに対する&lt;code&gt;delete&lt;/code&gt;を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;未定義動作を引き起こす操作をコンパイルエラーとする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/disallow_binding_a_returned_glvalue_to_a_temporary.md.nolink&#34;&gt;返却された左辺値から暗黙変換された一時オブジェクトが参照に束縛されることを禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;寿命切れの変数によって引き起こされるバグを防止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/clarifying_rules_for_brace_elision_in_aggregate_initialization.md.nolink&#34;&gt;要素数不明の配列を集成体初期化する規則を明確化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;配列要素の集成体初期化で&lt;code&gt;{}&lt;/code&gt;が省略された場合の矛盾していた規定を修正&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/erroneous_behavior_for_uninitialized_reads.html&#34;&gt;未初期化変数の読み取りをエラー性動作とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;初期化されていない自動変数の読み取りの安全性を規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/structured_bindings_can_introduce_a_pack.md.nolink&#34;&gt;構造化束縛でパックを導入できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;タプルを分解する際に複数の変数をパックとして宣言できるようにする。&lt;code&gt;auto [a, ...xs] = f();&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/making_non-encodable_string_literals_ill-formed.md.nolink&#34;&gt;文字列リテラルの文字エンコーディング失敗を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルのエンコーディング時に文字表現が失われる場合にコンパイルエラーにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/unevaluated_strings.md.nolink&#34;&gt;コンパイル時にのみ使用される文字列の扱いを明確化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static_assert&lt;/code&gt;や&lt;code&gt;[[deprecated]]&lt;/code&gt;などで使用されるコンパイル時の文字列について、文字コードの指定を禁止し、実行時エンコーディングが行われないことを規定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;分岐・ループ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/structured_binding_declaration_as_a_condition.html&#34;&gt;条件式での構造化束縛の使用を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;式全体を&lt;code&gt;bool&lt;/code&gt;値に変換できる場合に条件式で構造化束縛を使用できることとする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/trivial_infinite_loops_are_not_undefined_behavior.md.nolink&#34;&gt;自明な無限ループは未定義動作ではないと規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;並行プログラムの進行保証などを考慮して無限ループを未定義動作ではないものとする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/delete_reason.html&#34;&gt;関数宣言を削除する理由を指定できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;f() = delete(&#34;reason&#34;);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;属性&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/on_the_ignorability_of_standard_attributes.md.nolink&#34;&gt;属性の無視性を見直し&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構文として適格な属性のみを無視できるようにし、そうでない属性の使用を&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;とする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/attributes_for_structured_bindings.html&#34;&gt;構造化束縛への属性を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto [a, b [[maybe_unused]], c] = f();&lt;/code&gt;のように構造化束縛の要素に対して属性を付加できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/pack_indexing.md.nolink&#34;&gt;パラメータパックへのインデックスアクセスを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;可変引数テンプレートのパラメータパックに添字アクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/ordering_of_constraints_involving_fold_expressions.md.nolink&#34;&gt;制約式内での畳み込み式の順序付け&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;畳み込み式では全体ではなく個別の制約を原子制約式として扱う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/variadic_friends.md.nolink&#34;&gt;可変引数テンプレートで&lt;code&gt;friend&lt;/code&gt;宣言をできるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クラステンプレートの可変引数テンプレートでまとめて&lt;code&gt;friend&lt;/code&gt;宣言できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_cast_from_voidptr.md.nolink&#34;&gt;定数式での&lt;code&gt;void*&lt;/code&gt;からポインタ型へのキャストを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型消去のために&lt;code&gt;void*&lt;/code&gt;からポインタ型へのキャストを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/user-generated_static_assert_messages.html&#34;&gt;&lt;code&gt;static_assert&lt;/code&gt;の診断メッセージにユーザーが生成した文字列の指定を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;な&lt;code&gt;S.size()&lt;/code&gt;と&lt;code&gt;S.data()&lt;/code&gt;メンバ関数をもつオブジェクトをコンパイル時文字列として指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_placement_new.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;配置&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式の文脈での配置&lt;code&gt;new&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/constexpr_structured_bindings_and_references_to_constexpr_variables.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;構造化束縛の許可と、定数式への参照を定数式とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式に対する構造化束縛を許可し、関連する定数式への参照が定数式になるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/allowing_exception_throwing_in_constant-evaluation.md.nolink&#34;&gt;定数評価での例外送出を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式の文脈での例外の送出と捕捉を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ソースコード&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/add_atsign_dollar_graveaccent_to_the_basic_character_set.html&#34;&gt;基本文字集合に@、$、`を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C言語との互換性のためにこれらの文字を基本文字集合に追加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;モジュール&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/module_declarations_shouldnt_be_macros.md.nolink&#34;&gt;モジュール宣言でのモジュール名のマクロ展開を禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;export module MACRO_NAME;&lt;/code&gt;を禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/remove_deprecated_array_comparisons.md.nolink&#34;&gt;非推奨だった配列の比較を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++20で非推奨となっていた配列比較を削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp26/the_oxford_variadic_comma.md.nolink&#34;&gt;先行するカンマのない省略記号を非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void f(int, ...);&lt;/code&gt;はOK。&lt;code&gt;void f(int...);&lt;/code&gt;は非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字列エンコーディングを識別するライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/text_encoding.md.nolink&#34;&gt;&amp;lt;text_encoding&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;並行処理におけるデータの参照・更新を行うRCU (Read Copy Update) のライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/rcu.html&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;並行処理において参照中のデータが更新されないよう保護するハザードポインタのライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;データ並列ライブラリとして、&lt;code&gt;&lt;a href=&#34;../reference/simd.md.nolink&#34;&gt;&amp;lt;simd&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;デバッグサポートのライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/debugging.html&#34;&gt;&amp;lt;debugging&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;線形代数ライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/linalg.html&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;コンパイル時に容量を固定する可変長配列クラスのライブラリとして&lt;code&gt;&lt;a href=&#34;../reference/inplace_vector.md.nolink&#34;&gt;&amp;lt;inplace_vector&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;C23の互換ライブラリとして、ビット操作ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/stdbit.h.md.nolink&#34;&gt;&amp;lt;stdbit.h&amp;gt;&lt;/a&gt;&lt;/code&gt;と、検査付き整数演算ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/stdckdint.h.md.nolink&#34;&gt;&amp;lt;stdckdint.h&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加。&lt;code&gt;&amp;lt;cstd…&amp;gt;&lt;/code&gt;形式のライブラリは追加されない&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;全体&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;標準ライブラリに付加された、戻り値を無視した際に警告を出力する&lt;a href=&#34;cpp17/nodiscard.html&#34;&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt;属性&lt;/a&gt;を削除&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;から部分ビューを取り出す&lt;code&gt;&lt;a href=&#34;../reference/mdspan/submdspan.html&#34;&gt;std::submdspan()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;に対する&lt;code&gt;&lt;a href=&#34;../reference/mdspan/extents.html&#34;&gt;std::dextents&lt;/a&gt;&lt;/code&gt;指定の冗長さを解決する&lt;code&gt;&lt;a href=&#34;../reference/mdspan/extents.html&#34;&gt;std::dims&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;のレイアウトとして、&lt;code&gt;&lt;a href=&#34;../reference/mdspan/layout_left_padded.html&#34;&gt;std::layout_left_padded&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/mdspan/layout_right_padded.html&#34;&gt;std::layout_right_padded&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素アクセスにアライメント保証を与える&lt;code&gt;&lt;a href=&#34;../reference/mdspan/aligned_accessor.html&#34;&gt;std::aligned_accessor&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/span/span.html&#34;&gt;std::span&lt;/a&gt;&lt;/code&gt;に、以下を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;をとるコンストラクタ&lt;/li&gt;
&lt;li&gt;インデックスアクセスのための&lt;code&gt;&lt;a href=&#34;../reference/span/span/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;連想コンテナの以下のメンバ関数に、一時オブジェクトが生成されるコストを抑える拡張を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map.html&#34;&gt;std::map&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/op_at.html&#34;&gt;operator[]&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/try_emplace.html&#34;&gt;try_emplace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/map/map/insert_or_assign.html&#34;&gt;insert_or_assign()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/set/set.html&#34;&gt;std::set&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/set/set/insert.html&#34;&gt;insert()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map.html&#34;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/op_at.html&#34;&gt;operator[]&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/try_emplace.html&#34;&gt;try_emplace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/insert_or_assign.html&#34;&gt;insert_or_assign()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_multimap.html&#34;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_multimap/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set.html&#34;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set/insert.html&#34;&gt;insert()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_multiset.html&#34;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_multiset/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/span/span.html&#34;&gt;std::span&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;の推論補助を改善&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/concat_view.html&#34;&gt;std::views::concat&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ranges/cache_latest.md.nolink&#34;&gt;std::views::cache_latest&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のアルゴリズムを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/stable_sort.html&#34;&gt;std::stable_sort()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_stable_sort.html&#34;&gt;std::ranges::stable_sort()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/stable_partition.html&#34;&gt;std::stable_partition()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_stable_partition.html&#34;&gt;std::ranges::stable_partition()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/inplace_merge.html&#34;&gt;std::inplace_merge()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_inplace_merge.html&#34;&gt;std::ranges::inplace_merge()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のアルゴリズムを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_default_construct.html&#34;&gt;std::uninitialized_default_construct()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_default_construct.html&#34;&gt;std::ranges::uninitialized_default_construct()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_default_construct_n.html&#34;&gt;std::uninitialized_default_construct_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_default_construct_n.html&#34;&gt;std::ranges::uninitialized_default_construct_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_value_construct.html&#34;&gt;std::uninitialized_value_construct()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_value_construct.html&#34;&gt;std::ranges::uninitialized_value_construct()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_value_construct_n.html&#34;&gt;std::uninitialized_value_construct_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_value_construct_n.html&#34;&gt;std::ranges::uninitialized_value_construct_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_copy.html&#34;&gt;std::uninitialized_copy()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_copy.html&#34;&gt;std::ranges::uninitialized_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_copy_n.html&#34;&gt;std::uninitialized_copy_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_copy_n.html&#34;&gt;std::ranges::uninitialized_copy_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_move.html&#34;&gt;std::uninitialized_move()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_move.html&#34;&gt;std::ranges::uninitialized_move()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_move_n.html&#34;&gt;std::uninitialized_move_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_move_n.html&#34;&gt;std::ranges::uninitialized_move_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_fill.html&#34;&gt;std::uninitialized_fill()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_fill.html&#34;&gt;std::ranges::uninitialized_fill()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/uninitialized_fill_n.html&#34;&gt;std::uninitialized_fill_n()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;../reference/memory/ranges_uninitialized_fill_n.html&#34;&gt;std::ranges::uninitialized_fill_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rangeアルゴリズムが完全型を要求しないようにするため、&lt;code&gt;&lt;a href=&#34;../reference/iterator/projected.html&#34;&gt;std::projected&lt;/a&gt;&lt;/code&gt;の制約を緩和&lt;/li&gt;
&lt;li&gt;以下のアルゴリズムに、値を波カッコ初期化で渡せるよう制約を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::erase()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/deque/deque.html&#34;&gt;std::deque&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/deque/deque/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/forward_list/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/forward_list/forward_list/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/list/list.html&#34;&gt;std::list&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/list/list/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/vector/vector.html&#34;&gt;std::vector&lt;/a&gt;&lt;/code&gt;版&lt;code&gt;&lt;a href=&#34;../reference/vector/vector/erase_free.html&#34;&gt;std::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/find.html&#34;&gt;std::find()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_find.html&#34;&gt;std::ranges::find()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_find_last.html&#34;&gt;std::ranges::find_last()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/count.html&#34;&gt;std::count()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_count.html&#34;&gt;std::ranges::count()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/search_n.html&#34;&gt;std::search_n()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_search_n.html&#34;&gt;std::ranges::search_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace.html&#34;&gt;std::replace()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace.html&#34;&gt;std::ranges::replace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_if.html&#34;&gt;std::replace_if()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_if.html&#34;&gt;std::ranges::replace_if()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy.html&#34;&gt;std::ranges::replace_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy_if.html&#34;&gt;std::replace_copy_if()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/replace_copy_if.html&#34;&gt;std::ranges::replace_copy_if()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/fill.html&#34;&gt;std::fill()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fill.html&#34;&gt;std::ranges::fill()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/fill_n.html&#34;&gt;std::fill_n()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fill_n.html&#34;&gt;std::ranges::fill_n()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/remove.html&#34;&gt;std::remove()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_remove.html&#34;&gt;std::ranges::remove()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/remove_copy.html&#34;&gt;std::remove_copy()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_remove_copy.html&#34;&gt;std::ranges::remove_copy()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/lower_bound.html&#34;&gt;std::lower_bound()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_lower_bound.html&#34;&gt;std::ranges::lower_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/upper_bound.html&#34;&gt;std::upper_bound()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_upper_bound.html&#34;&gt;std::ranges::upper_bound()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/equal_range.html&#34;&gt;std::equal_range()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_equal_range.html&#34;&gt;std::ranges::equal_range()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/binary_search.html&#34;&gt;std::binary_search()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_binary_search.html&#34;&gt;std::ranges::binary_search()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fold_left.html&#34;&gt;std::ranges::fold_left()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_fold_right.html&#34;&gt;std::ranges::fold_right()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/algorithm/ranges_contains.html&#34;&gt;std::ranges::contains()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有権を保持しない&lt;code&gt;&lt;a href=&#34;../reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;として、&lt;code&gt;&lt;a href=&#34;../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/functional/function_ref.html&#34;&gt;std::function_ref&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/move_only_function.html&#34;&gt;std::move_only_function&lt;/a&gt;&lt;/code&gt;のコピー可能版として、&lt;code&gt;&lt;a href=&#34;../reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;../reference/functional/copyable_function.html&#34;&gt;std::copyable_function&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/functional/bind_back.html&#34;&gt;std::bind_back()&lt;/a&gt;&lt;/code&gt;に、非型テンプレート引数として関数を指定するオーバーロードを追加&lt;ul&gt;
&lt;li&gt;関連して、非型テンプレート引数の関数オブジェクトを反転させられるよう、&lt;code&gt;&lt;a href=&#34;../reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;に非型テンプレート引数版のオーバーロードを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;に、比較演算子&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper/op_equal.html&#34;&gt;==&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper/op_compare_3way.html&#34;&gt;&amp;lt;=&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/charconv.html&#34;&gt;&amp;lt;charconv&amp;gt;&lt;/a&gt;&lt;/code&gt;の変換結果&lt;code&gt;&lt;a href=&#34;../reference/charconv/to_chars_result.html&#34;&gt;std::to_chars_result&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/charconv/from_chars_result.html&#34;&gt;std::from_chars_result&lt;/a&gt;&lt;/code&gt;に、変換が正しく完了したかを判定する&lt;code&gt;operator bool&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/to_string.html&#34;&gt;std::to_string()&lt;/a&gt;&lt;/code&gt;の仕様が&lt;code&gt;std::sprintf()&lt;/code&gt;で説明されていたが、&lt;code&gt;&lt;a href=&#34;../reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;で定義するよう仕様を変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_istringstream.html&#34;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;および&lt;code&gt;&lt;a href=&#34;../reference/sstream/basic_ostringstream.html&#34;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;のコンストラクタおよび&lt;code&gt;str()&lt;/code&gt;メンバ関数に、&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を受け取るオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;に、以下の改善を導入&lt;ul&gt;
&lt;li&gt;ポインタ出力のサポートを追加&lt;/li&gt;
&lt;li&gt;幅と精度を動的に指定した場合でも型の検証がコンパイル時に行われるよう仕様を見直し&lt;/li&gt;
&lt;li&gt;コンパイル時の書式文字列だけでなく、実行時の書式文字列を渡せるよう仕様修正&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;として連結させる&lt;code&gt;operator+&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイル&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ファイルのネイティブハンドルを取得できるよう、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_filebuf.html&#34;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_ifstream.html&#34;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_ofstream.html&#34;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/fstream/basic_fstream.html&#34;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;クラスに、以下のメンバを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;native_handle_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native_handle()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/filesystem/path.html&#34;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt;に、文字列フォーマットのサポートを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/print.html&#34;&gt;std::print()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;に、ロックを取得せず高速に書き出す最適化を許可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;に、改行のみを出力するオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/print/print.html&#34;&gt;std::print()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/print/println.html&#34;&gt;std::println()&lt;/a&gt;&lt;/code&gt;をより高速にできる最適化が可能か判定する&lt;code&gt;&lt;a href=&#34;../reference/format/enable_nonlocking_formatter_optimization.html&#34;&gt;std::enable_nonlocking_formatter_optimization&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列・非同期処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;に汎用的な非同期実行を管理するフレームワークを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;オブジェクトに対する2つの値の最大値・最小値を取得する関数として、メンバ関数&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_max.html&#34;&gt;fetch_max()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic/fetch_min.html&#34;&gt;fetch_min()&lt;/a&gt;&lt;/code&gt;、非メンバ関数として&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_max.html&#34;&gt;std::atomic_fetch_max&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_max_explicit.html&#34;&gt;std::atomic_fetch_max_explicit&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_min.html&#34;&gt;std::atomic_fetch_min&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_fetch_min_explicit.html&#34;&gt;std::atomic_fetch_min_explicit&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;クラスに、参照するオブジェクトのアドレスを取得する&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref/address.html&#34;&gt;address()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;クラスのテンプレートパラメータとしてCV修飾された型を禁止&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic/atomic_ref.html&#34;&gt;std::atomic_ref&lt;/a&gt;&lt;/code&gt;クラスのテンプレートパラメータとして、CV修飾された型を受け取れるようにした (内部でCV修飾が外される)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/atomic.html&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/a&gt;&lt;/code&gt;ライブラリのアトミック操作を&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;を非順序連想コンテナのキーとして使用できるよう、&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に所有権ベースのハッシュ値を取得する関数オブジェクト&lt;code&gt;&lt;a href=&#34;../reference/memory/owner_hash.md.nolink&#34;&gt;std::owner_hash&lt;/a&gt;&lt;/code&gt;、および所有権ベースの等値比較を行う関数オブジェクト&lt;code&gt;&lt;a href=&#34;../reference/memory/owner_equal.md.nolink&#34;&gt;std::owner_equal&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;関連して、&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;../reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;クラスのメンバ関数として、&lt;code&gt;owner_hash()&lt;/code&gt;と&lt;code&gt;owner_equal()&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;日付・時間&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のクラスに、ハッシュ値サポートとして&lt;code&gt;&lt;a href=&#34;../reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;の特殊化を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/duration.html&#34;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/time_point.html&#34;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/day.html&#34;&gt;std::chrono::day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month.html&#34;&gt;std::chrono::month&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year.html&#34;&gt;std::chrono::year&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday.html&#34;&gt;std::chrono::weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday_indexed.html&#34;&gt;std::chrono::weekday_indexed&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/weekday_last.html&#34;&gt;std::chrono::weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_day.html&#34;&gt;std::chrono::month_day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_day_last.html&#34;&gt;std::chrono::month_day_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_weekday.html&#34;&gt;std::chrono::month_weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/month_weekday_last.html&#34;&gt;std::chrono::month_weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month.html&#34;&gt;std::chrono::year_month&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_day.html&#34;&gt;std::chrono::year_month_day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_day_last.html&#34;&gt;std::chrono::year_month_day_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_weekday.html&#34;&gt;std::chrono::year_month_weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/year_month_weekday_last.html&#34;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/zoned_time.html&#34;&gt;std::chrono::zoned_time&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/chrono/leap_second.html&#34;&gt;std::chrono::leap_second&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数値&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に、飽和演算 (Saturation Arithmetic) として、型の表現可能な範囲で演算を行う以下の関数を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/add_sat.html&#34;&gt;std::add_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/sub_sat.html&#34;&gt;std::sub_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/mul_sat.html&#34;&gt;std::mul_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/div_sat.html&#34;&gt;std::div_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/numeric/saturate_cast.html&#34;&gt;std::saturate_cast()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の関数を、&lt;code&gt;constexpr&lt;/code&gt;に対応 (特殊関数と、グローバルの丸めモードに依存する丸め関数以外の全て)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cos.html&#34;&gt;std::cos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sin.html&#34;&gt;std::sin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tan.html&#34;&gt;std::tan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cosh.html&#34;&gt;std::cosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sinh.html&#34;&gt;std::sinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tanh.html&#34;&gt;std::tanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/acos.html&#34;&gt;std::acos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/asin.html&#34;&gt;std::asin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atan.html&#34;&gt;std::atan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atan2.html&#34;&gt;std::atan2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/acosh.html&#34;&gt;std::acosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/asinh.html&#34;&gt;std::asinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/atanh.html&#34;&gt;std::atanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/exp.html&#34;&gt;std::exp()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/exp2.html&#34;&gt;std::exp2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/expm1.html&#34;&gt;std::expm1()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log.html&#34;&gt;std::log()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log10.html&#34;&gt;std::log10()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log1p.html&#34;&gt;std::log1p()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/log2.html&#34;&gt;std::log2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/pow.html&#34;&gt;std::pow()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/sqrt.html&#34;&gt;std::sqrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/cbrt.html&#34;&gt;std::cbrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/hypot.html&#34;&gt;std::hypot()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/erf.html&#34;&gt;std::erf()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/erfc.html&#34;&gt;std::erfc()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/lgamma.html&#34;&gt;std::lgamma()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cmath/tgamma.html&#34;&gt;std::tgamma()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex.html&#34;&gt;&amp;lt;complex&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の関数を、&lt;code&gt;constexpr&lt;/code&gt;に対応 (すべて)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/abs.html&#34;&gt;std::abs()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/arg.html&#34;&gt;std::arg()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/proj.html&#34;&gt;std::proj()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/polar.html&#34;&gt;std::polar()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/cos.html&#34;&gt;std::cos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sin.html&#34;&gt;std::sin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/tan.html&#34;&gt;std::tan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/cosh.html&#34;&gt;std::cosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sinh.html&#34;&gt;std::sinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/tanh.html&#34;&gt;std::tanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/acos.html&#34;&gt;std::acos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/asin.html&#34;&gt;std::asin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/atan.html&#34;&gt;std::atan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/acosh.html&#34;&gt;std::acosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/asinh.html&#34;&gt;std::asinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/atanh.html&#34;&gt;std::atanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/exp.html&#34;&gt;std::exp()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/log.html&#34;&gt;std::log()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/log10.html&#34;&gt;std::log10()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/pow.html&#34;&gt;std::pow()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/sqrt.html&#34;&gt;std::sqrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/norm.html&#34;&gt;std::norm()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/conj.html&#34;&gt;std::conj()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/imag_free.html&#34;&gt;std::imag()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex/real_free.html&#34;&gt;std::real()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;を構造化束縛や、将来のパターンマッチで使用できるようタプルインタフェースの特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;の範囲&lt;code&gt;[0, 1)&lt;/code&gt;の乱数を生成する&lt;code&gt;&lt;a href=&#34;../reference/random/generate_canonical.html&#34;&gt;std::generate_canonical()&lt;/a&gt;&lt;/code&gt;を、望ましい統計的性質を保証するようアルゴリズムと制約を変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に、乱数列を生成する&lt;code&gt;&lt;a href=&#34;../reference/random/generate_random.html&#34;&gt;std::ranges::generate_random()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に、乱数生成器は並列シミュレーションに効果的なカウンターベースのPhilox乱数生成器として、&lt;code&gt;&lt;a href=&#34;../reference/random/philox_engine.html&#34;&gt;std::philox_engine&lt;/a&gt;&lt;/code&gt;クラス、およびその別名である&lt;code&gt;&lt;a href=&#34;../reference/random/philox4x32.html&#34;&gt;std::philox4x32&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/random/philox4x64.html&#34;&gt;std::philox4x64&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/variant/variant.html&#34;&gt;std::variant&lt;/a&gt;&lt;/code&gt;クラスに、メンバ関数版の&lt;code&gt;&lt;a href=&#34;../reference/variant/variant/visit.md.nolink&#34;&gt;visit()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional.html&#34;&gt;std::optional&lt;/a&gt;&lt;/code&gt;クラスに、0もしくは1要素のRangeとして扱えるようにするための拡張として、イテレータインタフェースを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iterator&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_iterator&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional/begin.md.nolink&#34;&gt;begin()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/optional/optional/end.md.nolink&#34;&gt;end()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/tuple/ignore.html&#34;&gt;std::ignore&lt;/a&gt;&lt;/code&gt;をファーストクラス・オブジェクトとして型を詳細に定義&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/bitset/bitset.html&#34;&gt;std::bitset&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;../reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を受け取るコンストラクタを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio.html&#34;&gt;&amp;lt;ratio&amp;gt;&lt;/a&gt;&lt;/code&gt;に、新たなSI接頭辞として、以下を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;ronna&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;27&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;ronto&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;−27&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;quetta&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;30&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/ratio/si_prefix.html&#34;&gt;quecto&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;−30&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定数式での例外送出が許可されることにともない、以下を&lt;code&gt;constexpr&lt;/code&gt;化&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception.html&#34;&gt;&amp;lt;exception&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/exception.html&#34;&gt;std::exception&lt;/a&gt;&lt;/code&gt;クラスの全メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/nested_exception.html&#34;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;クラスの全メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/bad_exception.html&#34;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/uncaught_exceptions.html&#34;&gt;std::uncaught_exceptions()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/current_exception.html&#34;&gt;std::current_exception()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/rethrow_exception.html&#34;&gt;std::rethrow_exception()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/make_exception_ptr.html&#34;&gt;std::make_exception_ptr()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/throw_with_nested.html&#34;&gt;std::throw_with_nested()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/exception/rethrow_if_nested.html&#34;&gt;std::rethrow_if_nested()&lt;/a&gt;&lt;/code&gt;関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new.html&#34;&gt;&amp;lt;new&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new/bad_alloc.html&#34;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/new/bad_array_new_length.html&#34;&gt;std::bad_array_new_length&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo.html&#34;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの以下の機能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo/bad_cast.html&#34;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/typeinfo/bad_typeid.html&#34;&gt;std::bad_typeid&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;what()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、ポインタのアライメントを判定する&lt;code&gt;&lt;a href=&#34;../reference/memory/is_sufficiently_aligned.html&#34;&gt;std::is_sufficiently_aligned()&lt;/a&gt;&lt;/code&gt;関数を追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;デバッグ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/cassert/assert.html&#34;&gt;assert&lt;/a&gt;&lt;/code&gt;マクロの引数としてカンマを含む式を指定できるよう、可変引数化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、共用体のどのメンバがアクティブかを判定するための関数として&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_within_lifetime.md.nolink&#34;&gt;std::is_within_lifetime()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、仮想継承の関係を判定する&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_virtual_base_of.md.nolink&#34;&gt;std::is_virtual_base_of&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;制約&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;間接実行に関連する制約から、共通参照の要件を削除&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirectly_unary_invocable.html&#34;&gt;std::indirectly_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirectly_unary_invocable.html&#34;&gt;std::indirectly_regular_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_unary_predicate.html&#34;&gt;std::indirect_unary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_binary_predicate.html&#34;&gt;std::indirect_binary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_equivalence_relation.html&#34;&gt;std::indirect_equivalence_relation&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/iterator/indirect_strict_weak_order.html&#34;&gt;std::indirect_strict_weak_order&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;の&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivial.html&#34;&gt;std::is_trivial&lt;/a&gt;&lt;/code&gt;を非推奨化&lt;ul&gt;
&lt;li&gt;これは&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivially_copyable.html&#34;&gt;std::is_trivially_copyable&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/type_traits/is_trivially_default_constructible.html&#34;&gt;std::is_trivially_default_constructible&lt;/a&gt;&lt;/code&gt;の2つが合わさったものであるが、それらは異なる状況で必要になるものであった&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;非推奨の取り消し&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator.html&#34;&gt;std::polymorphic_allocator&lt;/a&gt;::&lt;a href=&#34;../reference/memory_resource/polymorphic_allocator/destroy.html&#34;&gt;destroy()&lt;/a&gt;&lt;/code&gt;の非推奨を取り消し&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++98から非推奨となっていた&lt;code&gt;&amp;lt;strstream&amp;gt;&lt;/code&gt;ライブラリを削除&lt;/li&gt;
&lt;li&gt;C++17から非推奨となっていたUnicode変換ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/codecvt.html&#34;&gt;&amp;lt;codecvt&amp;gt;&lt;/a&gt;&lt;/code&gt;と、&lt;code&gt;&lt;a href=&#34;../reference/locale/wstring_convert.html&#34;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/locale/wbuffer_convert.html&#34;&gt;std::wbuffer_convert&lt;/a&gt;&lt;/code&gt;クラスを削除&lt;/li&gt;
&lt;li&gt;C++20から非推奨となっていた、&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;../reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;のパラメータなしのオーバーロードを削除&lt;/li&gt;
&lt;li&gt;C++20から非推奨となっていた&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;に対する、以下の古いアトミック操作関数のオーバーロードを削除&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_is_lock_free.html&#34;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_load.html&#34;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_load_explicit.html&#34;&gt;std::atomic_load_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_store.html&#34;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_store_explicit.html&#34;&gt;std::atomic_store_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_exchange.html&#34;&gt;std::atomic_exchange&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_exchange_explicit.html&#34;&gt;std::atomic_exchange_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_weak.html&#34;&gt;std::atomic_compare_exchange_weak&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_strong.html&#34;&gt;std::atomic_compare_exchange_strong&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_weak_explicit.html&#34;&gt;std::atomic_compare_exchange_weak_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr/atomic_compare_exchange_strong_explicit.html&#34;&gt;std::atomic_compare_exchange_strong_explicit&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++23から非推奨となっていた、&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;のメンバ型&lt;code&gt;is_always_equal&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>リファレンス -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/reference.html"/>
      <id>8fba13b4661d7c43d75deee657c43799e40a73a2:reference.md</id>
      <updated>2025-01-30T20:30:43+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;リファレンス&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#language-support&#34;&gt;言語サポートライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#concepts&#34;&gt;コンセプトライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#diagnostics&#34;&gt;診断ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#general-utils&#34;&gt;汎用的なユーティリティライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#strings&#34;&gt;文字列ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#localization&#34;&gt;ローカライズライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#container&#34;&gt;コンテナライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#iterator&#34;&gt;イテレータライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ranges&#34;&gt;レンジライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#algorithm&#34;&gt;アルゴリズムライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#numerics&#34;&gt;数値ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#debug&#34;&gt;デバッグライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#io&#34;&gt;入出力ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#regular-expressions&#34;&gt;正規表現ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#atomic-operations&#34;&gt;アトミック操作ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#thread-support&#34;&gt;スレッドサポートライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#clib-facilities&#34;&gt;C言語互換ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exposition-only&#34;&gt;説明専用ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&#34;#language-support-library&#34; id=&#34;language-support&#34;&gt;言語サポートライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/limits.html&#34;&gt;&amp;lt;limits&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実装プロパティ&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/version.html&#34;&gt;&amp;lt;version&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実装依存のバージョン情報&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/stdfloat.html&#34;&gt;&amp;lt;stdfloat&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;拡張浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/new.html&#34;&gt;&amp;lt;new&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;動的メモリ管理&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/typeinfo.html&#34;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型情報&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/source_location.html&#34;&gt;&amp;lt;source_location&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ソースコード上の位置&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/exception.html&#34;&gt;&amp;lt;exception&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例外ハンドリング&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/initializer_list.html&#34;&gt;&amp;lt;initializer_list&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初期化子リスト&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;比較演算&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/coroutine.html&#34;&gt;&amp;lt;coroutine&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コルーチン&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#concepts&#34; id=&#34;concepts&#34;&gt;コンセプトライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/concepts.html&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;言語関係のコンセプト&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#diagnostics&#34; id=&#34;diagnostics&#34;&gt;診断ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/stdexcept.html&#34;&gt;&amp;lt;stdexcept&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;例外クラス&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/system_error.html&#34;&gt;&amp;lt;system_error&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;システムエラーサポート&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#general-utils&#34; id=&#34;general-utils&#34;&gt;汎用的なユーティリティライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ユーティリティコンポーネント&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/bitset.html&#34;&gt;&amp;lt;bitset&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ビットの固定サイズシーケンス&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/ratio.html&#34;&gt;&amp;lt;ratio&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時有理数&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/tuple.html&#34;&gt;&amp;lt;tuple&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;タプル&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/optional.html&#34;&gt;&amp;lt;optional&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意で値を持たせられるオブジェクト&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/variant.html&#34;&gt;&amp;lt;variant&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;候補の型を切り替えながら保持できる記憶域型&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/any.html&#34;&gt;&amp;lt;any&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;あらゆる型の値を保持できる記憶域型&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/expected.html&#34;&gt;&amp;lt;expected&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正常値かエラー値のどちらかを持たせられるオブジェクト&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型特性&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクト&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/scoped_allocator.html&#34;&gt;&amp;lt;scoped_allocator&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スコープ付きアロケータ&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/memory_resource.html&#34;&gt;&amp;lt;memory_resource&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多相アロケータ&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間ユーティリティ&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/typeindex.html&#34;&gt;&amp;lt;typeindex&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型のインデックス&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/execution.html&#34;&gt;&amp;lt;execution&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;実行ポリシー&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/charconv.html&#34;&gt;&amp;lt;charconv&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;高速な文字列 ⇔ 数値変換&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/format.html&#34;&gt;&amp;lt;format&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列フォーマット&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/stacktrace.html&#34;&gt;&amp;lt;stacktrace&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スタックトレース&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#strings&#34; id=&#34;strings&#34;&gt;文字列ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/string.html&#34;&gt;&amp;lt;string&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列クラスと、文字特性&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/string_view.html&#34;&gt;&amp;lt;string_view&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有権を持たず文字列を参照する文字列クラス&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#localization&#34; id=&#34;localization&#34;&gt;ローカライズライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/locale.html&#34;&gt;&amp;lt;locale&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ロケール&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/text_encoding.md.nolink&#34;&gt;&amp;lt;text_encoding&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列エンコーディングの識別&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/codecvt.html&#34;&gt;&amp;lt;codecvt&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コード変換ファセット&lt;/td&gt;
&lt;td&gt;C++11&lt;br /&gt; C++17から非推奨&lt;br /&gt; C++26で削除&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#container&#34; id=&#34;container&#34;&gt;コンテナライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/array.html&#34;&gt;&amp;lt;array&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;配列&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/deque.html&#34;&gt;&amp;lt;deque&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;両端キュー&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/forward_list.html&#34;&gt;&amp;lt;forward_list&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;単方向リスト&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/list.html&#34;&gt;&amp;lt;list&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双方向リスト&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/queue.html&#34;&gt;&amp;lt;queue&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;FIFOキュー&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/stack.html&#34;&gt;&amp;lt;stack&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;LIFOスタック&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/vector.html&#34;&gt;&amp;lt;vector&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変長配列&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/inplace_vector.md.nolink&#34;&gt;&amp;lt;inplace_vector&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;容量固定の可変長配列&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/map.html&#34;&gt;&amp;lt;map&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;順序付き連想配列&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/set.html&#34;&gt;&amp;lt;set&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;順序付き集合&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/flat_map.html&#34;&gt;&amp;lt;flat_map&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ソート済みキーによる順序付き連想配列&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/flat_set.md.nolink&#34;&gt;&amp;lt;flat_set&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ソート済みキーによる順序付き集合&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/unordered_map.html&#34;&gt;&amp;lt;unordered_map&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非順序連想配列&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/unordered_set.html&#34;&gt;&amp;lt;unordered_set&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非順序集合&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/span.html&#34;&gt;&amp;lt;span&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;部分シーケンスの参照&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多次元配列ビュー&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#iterator&#34; id=&#34;iterator&#34;&gt;イテレータライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの定義&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#ranges&#34; id=&#34;ranges&#34;&gt;レンジライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;レンジアルゴリズム&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/generator.html&#34;&gt;&amp;lt;generator&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コルーチンによるレンジ生成&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#algorithm&#34; id=&#34;algorithm&#34;&gt;アルゴリズムライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アルゴリズム&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#numerics&#34; id=&#34;numerics&#34;&gt;数値ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/complex.html&#34;&gt;&amp;lt;complex&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;複素数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/bit.html&#34;&gt;&amp;lt;bit&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ビット操作&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;乱数生成&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/valarray.html&#34;&gt;&amp;lt;valarray&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数値の配列&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一般的な数値操作&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/numbers.html&#34;&gt;&amp;lt;numbers&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数値&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/linalg.html&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;線形代数&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#debug&#34; id=&#34;debug&#34;&gt;デバッグライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/debugging.html&#34;&gt;&amp;lt;debugging&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デバッグサポート&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#io&#34; id=&#34;io&#34;&gt;入出力ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;iosfwd&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;先行宣言&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/iostream.html&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準&lt;code&gt;iostream&lt;/code&gt;オブジェクト&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/ios.html&#34;&gt;&amp;lt;ios&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;iostream&lt;/code&gt;基底クラス&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/streambuf.html&#34;&gt;&amp;lt;streambuf&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ストリームバッファ&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/istream.html&#34;&gt;&amp;lt;istream&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力ストリーム&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/ostream.html&#34;&gt;&amp;lt;ostream&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力ストリーム&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/iomanip.html&#34;&gt;&amp;lt;iomanip&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;フォーマットとマニピュレータ&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/sstream.html&#34;&gt;&amp;lt;sstream&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列ストリーム&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;strstream&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;古い文字列ストリーム&lt;/td&gt;
&lt;td&gt;C++98から非推奨&lt;br /&gt; C++26で削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/fstream.html&#34;&gt;&amp;lt;fstream&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ファイルストリーム&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/filesystem.html&#34;&gt;&amp;lt;filesystem&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ファイルシステム&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/syncstream.html&#34;&gt;&amp;lt;syncstream&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同期化出力ストリームラッパー&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/spanstream.md.nolink&#34;&gt;&amp;lt;spanstream&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリバッファの所有権をもたないストリーム&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/print.html&#34;&gt;&amp;lt;print&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;書式指定による出力&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#regular-expressions&#34; id=&#34;regular-expressions&#34;&gt;正規表現ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/regex.html&#34;&gt;&amp;lt;regex&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正規表現&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#atomic-operations&#34; id=&#34;atomic-operations&#34;&gt;アトミック操作ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/atomic.html&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アトミックアクセスのためのコンポーネント&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/stdatomic.h.html&#34;&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アトミック操作のC互換ライブラリ&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#thread-support&#34; id=&#34;thread-support&#34;&gt;スレッドサポートライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/stop_token.html&#34;&gt;&amp;lt;stop_token&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;停止状態&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/thread.html&#34;&gt;&amp;lt;thread&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スレッド&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/mutex.html&#34;&gt;&amp;lt;mutex&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ミューテックス&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/shared_mutex.html&#34;&gt;&amp;lt;shared_mutex&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;共有ミューテックス&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/condition_variable.html&#34;&gt;&amp;lt;condition_variable&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条件変数&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/semaphore.html&#34;&gt;&amp;lt;semaphore&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;セマフォ&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/latch.html&#34;&gt;&amp;lt;latch&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ラッチ同期&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/barrier.html&#34;&gt;&amp;lt;barrier&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;バリア同期&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/future.html&#34;&gt;&amp;lt;future&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Future&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/rcu.html&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;データの参照・更新&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ハザードポインタ&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/simd.md.nolink&#34;&gt;&amp;lt;simd&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;データ並列&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#clib-facilities&#34; id=&#34;clib-facilities&#34;&gt;C言語互換ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cassert.html&#34;&gt;&amp;lt;cassert&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アサート&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;複素数&lt;/td&gt;
&lt;td&gt;C++11 (C99)&lt;br /&gt; C++17で非推奨&lt;br /&gt; C++20で削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cctype.html&#34;&gt;&amp;lt;cctype&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字種別の判定と変換&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cerrno.html&#34;&gt;&amp;lt;cerrno&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;エラー番号&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cfenv.html&#34;&gt;&amp;lt;cfenv&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点環境へのアクセス&lt;/td&gt;
&lt;td&gt;C++11 (C99)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cfloat.html&#34;&gt;&amp;lt;cfloat&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点数の定数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cinttypes&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;固定精度整数のための書式指定マクロ&lt;/td&gt;
&lt;td&gt;C++11 (C99)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;に対する別名&lt;code&gt;and&lt;/code&gt;のような、各種演算子に対するマクロを定義する。&lt;br /&gt; ただしC++ではこれらの別名はキーワードとして定義されるため、このヘッダでは何も定義されない。&lt;/td&gt;
&lt;td&gt;C++20で削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/climits.html&#34;&gt;&amp;lt;climits&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;整数型の最小値、最大値を表すマクロ&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ロケール&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数学関数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;csetjmp&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ジャンプ処理&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;csignal&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;シグナル&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメント操作のマクロ&lt;/td&gt;
&lt;td&gt;C++17で非推奨&lt;br /&gt; C++20で削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cstdarg&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変引数操作&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/stdbit.h.md.nolink&#34;&gt;&amp;lt;stdbit.h&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ビット操作&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/stdckdint.h.md.nolink&#34;&gt;&amp;lt;stdckdint.h&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;検査付き整数演算&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真理値型の定義&lt;/td&gt;
&lt;td&gt;C++11 (C99)&lt;br /&gt; C++17で非推奨&lt;br /&gt; C++20で削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cstddef.html&#34;&gt;&amp;lt;cstddef&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基本的な型、値、マクロの定義&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cstdint.html&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;大きさが規定されている整数型&lt;/td&gt;
&lt;td&gt;C++11 (C99)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cstdio.html&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入出力&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cstdlib.html&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ユーティリティ関数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/cstring.html&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列操作&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックな数学関数&lt;/td&gt;
&lt;td&gt;C++11 (C99)&lt;br /&gt; C++17で非推奨&lt;br /&gt; C++20で削除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/ctime.html&#34;&gt;&amp;lt;ctime&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付・時間&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cuchar&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ユニコード文字型&lt;/td&gt;
&lt;td&gt;C++11 (C11)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cwchar&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ワイド文字型&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cwctype&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ワイド文字の種別と判定&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#exposition-only&#34; id=&#34;exposition-only&#34;&gt;説明専用ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ヘッダ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;reference/exposition-only.html&#34;&gt;exposition-only&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;説明のためのものを集めたページ (実際のライブラリではない)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2867r2.html&#34; target=&#34;_blank&#34;&gt;P2867R2 Remove Deprecated &lt;code&gt;strstream&lt;/code&gt;s From C++26&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rcu -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/reference/rcu.html"/>
      <id>8fba13b4661d7c43d75deee657c43799e40a73a2:reference/rcu.md</id>
      <updated>2025-01-30T20:30:43+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;rcu&lt;/span&gt;&lt;span class=&#34;cpp cpp26&#34; title=&#34;C++26で追加&#34;&gt;(C++26)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;rcu&amp;gt;&lt;/code&gt;ヘッダでは、並行なデータの参照・更新を実現する&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%BC%E3%83%89%E3%83%BB%E3%82%B3%E3%83%94%E3%83%BC%E3%83%BB%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88&#34; target=&#34;_blank&#34;&gt;Read-Copy Update(RCU)機構&lt;/a&gt;のための部品を定義する。&lt;/p&gt;
&lt;p&gt;RCU同期メカニズムは、複数スレッド間で共有されるデータが高頻度で参照され、稀に更新されるようなユースケースに適している。RCU機構はスレッド間の排他制御を行わず、更新操作により不要となった古いデータを安全に解放するタイミング制御を行う。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_obj_base.md.nolink&#34;&gt;rcu_obj_base&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCU対象オブジェクトの基底クラス(class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_domain.md.nolink&#34;&gt;rcu_domain&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCUドメイン(class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_default_domain.md.nolink&#34;&gt;rcu_default_domain&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトのRCUドメイン取得(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_synchronize.md.nolink&#34;&gt;rcu_synchronize&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RCUドメインのアンロック完了を待機(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_barrier.md.nolink&#34;&gt;rcu_barrier&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ解放操作完了を待機(function)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;rcu/rcu_barrier.md.nolink&#34;&gt;rcu_retire&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;メモリ解放操作をスケジュル(function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++26&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#icc&#34;&gt;ICC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: ??&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2545r4.pdf&#34; target=&#34;_blank&#34;&gt;P2545R4 Read-Copy Update(RCU)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_map -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;flat_map&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;flat_map&lt;/span&gt;&lt;span class=&#34;cpp cpp23&#34; title=&#34;C++23で追加&#34;&gt;(C++23)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;flat_map&amp;gt;&lt;/code&gt; ヘッダは、ソート済みキーによる順序付き連想配列を定義する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;a href=&#34;map/map.html&#34;&gt;std::map&lt;/a&gt;&lt;/code&gt;と違ってノードベースの実装ではなく、メモリ連続性のある平坦 (flat) な配列で扱われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;flat_map&amp;gt;&lt;/code&gt; ヘッダでは、キーの重複を許さない &lt;code&gt;std::&lt;a href=&#34;flat_map/flat_map.html&#34;&gt;flat_map&lt;/a&gt;&lt;/code&gt; クラステンプレート、およびキーの重複を許す &lt;code&gt;std::&lt;a href=&#34;flat_map/flat_multimap.html&#34;&gt;flat_multimap&lt;/a&gt;&lt;/code&gt; クラステンプレートを提供する。&lt;/p&gt;
&lt;p&gt;このヘッダでは、以下の標準ヘッダをインクルードする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;initializer_list.html&#34;&gt;&amp;lt;initializer_list&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;flat_map/flat_map.html&#34;&gt;flat_map&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;キーの重複を許さない平坦な順序付き連想コンテナ(class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;flat_map/flat_multimap.html&#34;&gt;flat_multimap&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;キーの重複を許す平坦な順序付き連想コンテナ(class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;flat_map/sorted_unique_t.html&#34;&gt;sorted_unique_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ソート済みかつ重複要素がないことを示すためのタグ型(class)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;flat_map/sorted_unique_t.html&#34;&gt;sorted_unique&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ソート済みかつ重複要素がないことを示すためのタグ値(variable)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;flat_map/sorted_equivalent_t.html&#34;&gt;sorted_equivalent_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ソート済みであること（重複はしてもよい）を示すためのタグ型(class)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;flat_map/sorted_equivalent_t.html&#34;&gt;sorted_equivalent&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ソート済みであること（重複はしてもよい）を示すためのタグ値(variable)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++23&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0429r3.pdf&#34; target=&#34;_blank&#34;&gt;P0429R3 A Standard &lt;code&gt;flat_map&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++23で&lt;code&gt;flat_map&lt;/code&gt;が導入された経緯・動機・設計について記載されている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf&#34; target=&#34;_blank&#34;&gt;P0429R9 A Standard &lt;code&gt;flat_map&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++23で導入された&lt;code&gt;flat_map&lt;/code&gt;の仕様&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/count.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_map/count.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/count.md b/reference/flat_map/flat_map/count.md
index 78d869efb..139090da5 100644
--- a/reference/flat_map/flat_map/count.md
+++ b/reference/flat_map/flat_map/count.md
@@ -30,16 +30,16 @@ size_type count(const K&amp;amp; x) const;        // (2) C++23
 
 ## 計算量
 ```
-log(b.size()) + b.count(k)
+log(size()) + count(x)
 ```
-* b.size()[link size.md]
+* size()[link size.md]
 
 
 ## 備考
 - (2) :
     - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
     - これらのオーバーロードは、`flat_map&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
-- [`std::flat_multimap`](/reference/flat_map/flat_multimap.md.nolink)クラスとの共通インタフェースを使用する必要がなければ、この関数の代わりに[`contains()`](contains.md)メンバ関数を使用することを推奨する
+- [`std::flat_multimap`](/reference/flat_map/flat_multimap.md)クラスとの共通インタフェースを使用する必要がなければ、この関数の代わりに[`contains()`](contains.md)メンバ関数を使用することを推奨する
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/insert.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_map/insert.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/insert.md b/reference/flat_map/flat_map/insert.md
index ad5258b08..a4ce80b3f 100644
--- a/reference/flat_map/flat_map/insert.md
+++ b/reference/flat_map/flat_map/insert.md
@@ -40,13 +40,13 @@ void insert(sorted_unique_t s,
 * sorted_unique_t[link /reference/flat_map/sorted_unique_t.md]
 
 ## 概要
-新しく一つの要素(引数 `x`, `y`を使う)または要素のシーケンス(入力イテレータまたは `initializer_list` を使う)を挿入し、コンテナを拡張する。
+新しく一つの要素(引数 `x` を使う)または要素のシーケンス(入力イテレータまたは `initializer_list` を使う)を挿入し、コンテナを拡張する。
 
 これは、挿入された要素の数だけコンテナの [`size()`](size.md) を増やす。
 
 `flat_map` コンテナは重複したキーを持つ要素を許さないため、挿入操作はそれぞれの要素が他のコンテナ内の既存要素と同じキーかどうかをチェックする。もし同じであれば要素は挿入されず、戻り値を持つ関数の場合はそれへのイテレータなどを返す。
 
-重複した値を許す、類似したコンテナについては `flat_multimap` を参照。
+重複した値を許す、類似したコンテナについては [`flat_multimap`](/reference/flat_map/flat_multimap.md) を参照。
 
 内部的に `flat_map` コンテナは、コンストラクト時に指定された比較オブジェクトによって要素を下位から上位へとソートして保持する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_range -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/insert_range.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_map/insert_range.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/insert_range.md b/reference/flat_map/flat_map/insert_range.md
index 5ad23d7f2..0f2bde947 100644
--- a/reference/flat_map/flat_map/insert_range.md
+++ b/reference/flat_map/flat_map/insert_range.md
@@ -18,7 +18,7 @@ Rangeを挿入し、コンテナを拡張する。
 
 `flat_map` コンテナは重複したキーを持つ要素を許さないため、挿入操作はそれぞれの要素が他のコンテナ内の既存要素と同じキーかどうかをチェックする。もし同じであれば要素は挿入されない。
 
-重複した値を許す、類似したコンテナについては `flat_multimap` を参照。
+重複した値を許す、類似したコンテナについては [`flat_multimap`](/reference/flat_map/flat_multimap.md) を参照。
 
 内部的に `flat_map` コンテナは、コンストラクト時に指定された比較オブジェクトによって要素を下位から上位へとソートして保持する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_multimap -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap.md b/reference/flat_map/flat_multimap.md
new file mode 100644
index 000000000..8a17b7973
--- /dev/null
+++ b/reference/flat_map/flat_multimap.md
@@ -0,0 +1,243 @@
+# flat_multimap
+* flat_map[meta header]
+* std[meta namespace]
+* class template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class Key,
+            class T,
+            class Compare = less&amp;lt;Key&amp;gt;,
+            class KeyContainer = vector&amp;lt;Key&amp;gt;,
+            class MappedContainer = vector&amp;lt;T&amp;gt;&amp;gt;
+  class flat_multimap;
+}
+```
+* less[link ../functional/less.md]
+* vector[link /reference/vector/vector.md]
+
+## 概要
+
+
+## メンバ関数
+### 構築・破棄
+
+| 名前 | 説明 | 対応バージョン |
+|---------------------------------|----------------|-------|
+| [`(constructor)`](flat_multimap/op_constructor.md) | コンストラクタ | C++23 |
+| [`(destructor)`](flat_multimap/op_destructor.md.nolink) | デストラクタ | C++23 |
+| [`operator=`](flat_multimap/op_assign.md) | 代入演算子 | C++23 |
+
+
+### イテレータ
+
+| 名前 | 説明 | 対応バージョン |
+|---------------------------------------|--------------------------------------------------|-------|
+| [`begin`](flat_multimap/begin.md)     | 先頭を指すイテレータを取得する                   | C++23 |
+| [`cbegin`](flat_multimap/cbegin.md)   | 先頭を指す読み取り専用イテレータを取得する       | C++23 |
+| [`end`](flat_multimap/end.md)         | 末尾の次を指すイテレータを取得する               | C++23 |
+| [`cend`](flat_multimap/cend.md)       | 末尾の次を指す読み取り専用イテレータを取得する   | C++23 |
+| [`rbegin`](flat_multimap/rbegin.md)   | 末尾を指す逆イテレータを取得する                 | C++23 |
+| [`crbegin`](flat_multimap/crbegin.md) | 末尾を指す読み取り専用逆イテレータを取得する     | C++23 |
+| [`rend`](flat_multimap/rend.md)       | 先頭の前を指す逆イテレータを取得する             | C++23 |
+| [`crend`](flat_multimap/crend.md)     | 先頭の前を指す読み取り専用逆イテレータを取得する | C++23 |
+
+
+### 領域
+
+| 名前 | 説明 | 対応バージョン |
+|-----------------------------------------|------------------------------------|-------|
+| [`empty`](flat_multimap/empty.md)       | コンテナが空であるかどうかを調べる | C++23 |
+| [`size`](flat_multimap/size.md)         | 要素数を取得する                   | C++23 |
+| [`max_size`](flat_multimap/max_size.md) | 格納可能な最大の要素数を取得する   | C++23 |
+
+
+### コンテナの変更
+
+| 名前                                            | 説明                                     | 対応バージョン |
+|-------------------------------------------------|------------------------------------------|----------------|
+| [`clear`](flat_multimap/clear.md)               | 全ての要素を削除する                     | C++23 |
+| [`insert`](flat_multimap/insert.md)             | 要素を挿入する                           | C++23 |
+| [`insert_range`](flat_multimap/insert_range.md) | Rangeを挿入する                          | C++23 |
+| [`emplace`](flat_multimap/emplace.md)           | 要素を直接構築する                       | C++23 |
+| [`emplace_hint`](flat_multimap/emplace_hint.md) | ヒントを使って要素を直接構築する         | C++23 |
+| [`erase`](flat_multimap/erase.md)               | 要素を削除する                           | C++23 |
+| [`swap`](flat_multimap/swap.md)                 | コンテンツを交換する                     | C++23 |
+| [`extract`](flat_multimap/extract.md)           | キーのコンテナ、値のコンテナを取得する   | C++23 |
+| [`replace`](flat_multimap/replace.md)           | キーのコンテナ、値のコンテナを置き換える | C++23 |
+
+
+### 要素アクセス
+
+| 名前 | 説明 | 対応バージョン |
+|-----------------------------------------------|--------------------------------------------------------------|-------|
+| [`count`](flat_multimap/count.md)             | 指定したキーにマッチする要素の数を取得する                   | C++23 |
+| [`find`](flat_multimap/find.md)               | 指定したキーで要素を探す                                     | C++23 |
+| [`contains`](flat_multimap/contains.md)       | 指定したキーの要素が含まれているかを判定する                 | C++23 |
+| [`equal_range`](flat_multimap/equal_range.md) | 指定したキーにマッチする要素範囲を取得する                   | C++23 |
+| [`lower_bound`](flat_multimap/lower_bound.md) | 与えられた値より小さくない最初の要素へのイテレータを取得する | C++23 |
+| [`upper_bound`](flat_multimap/upper_bound.md) | 特定の値よりも大きい最初の要素へのイテレータを取得する       | C++23 |
+
+### オブザーバー
+
+| 名前                                        | 説明                                   | 対応バージョン |
+|---------------------------------------------|----------------------------------------|----------------|
+| [`key_comp`](flat_multimap/key_comp.md)     | キー比較用の関数オブジェクトを取得する | C++23 |
+| [`value_comp`](flat_multimap/value_comp.md) | 要素比較用の関数オブジェクトを取得する | C++23 |
+| [`keys`](flat_multimap/keys.md)             | キーのコンテナを取得する               | C++23 |
+| [`values`](flat_multimap/values.md)         | 値のコンテナを取得する                 | C++23 |
+
+
+## メンバ型
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| `key_type` | キーの型。テンプレートパラメータ `Key`  |  C++23 |
+| `mapped_type` | 値の型。テンプレートパラメータ `T` | C++23 |
+| `value_type` | 要素の型。[`std::pair`](/reference/utility/pair.md)`&amp;lt;key_type, mapped_type&amp;gt;` | C++23 |
+| `key_compare` | キー値の大小関係を判定する二項述語の型。テンプレートパラメータ `Compare` | C++23 |
+| [`value_compare`](flat_multimap/value_compare.md) | 要素値のキー部分で大小関係を判定する二項述語の型。入れ子クラス | C++23 |
+| `reference` | 要素への参照型。[`std::pair`](/reference/utility/pair.md)`&amp;lt;const key_type&amp;amp;, mapped_type&amp;amp;&amp;gt;` | C++23 |
+| `const_reference` | 要素への`const`参照型。[`std::pair`](/reference/utility/pair.md)`&amp;lt;const key_type&amp;amp;, const mapped_type&amp;amp;&amp;gt;` | C++23 |
+| `size_type` | 要素数を表す符号なし整数型 [`size_t`](/reference/cstddef/size_t.md) | C++23 |
+| `difference_type` | 同一のコンテナを指す `iterator` の差を表す符号付き整数型 [`ptrdiff_t`](/reference/cstddef/ptrdiff_t.md) | C++23 |
+| `iterator` | ランダムアクセスイテレータ | C++23 |
+| `const_iterator` | 読み取り専用ランダムアクセスイテレータ | C++23 |
+| `reverse_iterator` | 逆順ランダムアクセスイテレータ。[`std::reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;iterator&amp;gt;` | C++23 |
+| `const_reverse_iterator` | 読み取り専用逆順ランダムアクセスイテレータ。[`std::reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;const_iterator&amp;gt;` | C++23 |
+| `key_container_type` | キーを格納するコンテナ型 `KeyContainer` | C++23 |
+| `mapped_container_type` | 値を格納するコンテナ型 `MappedContainer` | C++23 |
+| [`containers`](flat_multimap/containers.md) | キーのコンテナと値のコンテナを保持する型 | C++23 |
+| [`key_equiv`](flat_multimap/key_equiv.md) | 要素をとってキーの等価比較を行う説明専用の関数オブジェクト | C++23 |
+
+
+## 非メンバ関数
+### 要素削除
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`erase_if`](flat_multimap/erase_if_free.md) | 指定した条件に合致する要素とその分の領域を、コンテナから削除する | C++23 |
+
+
+## 非メンバ（*Hidden friends*）関数
+### 比較演算子
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`operator==`](flat_multimap/op_equal.md)                          | 左辺と右辺が等しいかの判定を行う                                  | C++23 |
+| `bool operator!=(const flat_multimap&amp;amp; x, const flat_multimap&amp;amp; y);` | 左辺と右辺が等しくないかの判定を行う (`==`により使用可能)         | C++23 |
+| [`operator&amp;lt;=&amp;gt;`](flat_multimap/op_compare_3way.md)                  | 三方比較を行う                                                    | C++23 |
+| `bool operator&amp;lt;(const flat_multimap&amp;amp; x, const flat_multimap&amp;amp; y);`  | 左辺が右辺より小さいかの判定を行う  (`&amp;lt;=&amp;gt;`により使用可能)         | C++23 |
+| `bool operator&amp;lt;=(const flat_multimap&amp;amp; x, const flat_multimap&amp;amp; y);` | 左辺が右辺より小さいか等しいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能)  | C++23 |
+| `bool operator&amp;gt;(const flat_multimap&amp;amp; x, const flat_multimap&amp;amp; y);`  | 左辺が右辺より大きいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能)          | C++23  |
+| `bool operator&amp;gt;=(const flat_multimap&amp;amp; x, const flat_multimap&amp;amp; y);` | 左辺が右辺より大きいか等しいかの判定を行う (`&amp;lt;=&amp;gt;`により使用可能)  | C++23 |
+
+
+### 入れ替え
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`swap`](flat_multimap/swap_free.md.nolink) | 2つの`flat_multimap`オブジェクトを入れ替える | C++23 |
+
+
+## 推論補助
+
+| 名前 | 説明 | 対応バージョン |
+|---------------------------------------------|------------------------------------|-------|
+| [`(deduction_guide)`](flat_multimap/op_deduction_guide.md.nolink) | クラステンプレートの推論補助 | C++23 |
+
+
+## その他
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`uses_allocator`](flat_multimap/uses_allocator.md) | `flat_multimap`による特殊化 | C++23 |
+
+
+
+## 例
+### 基本的な使い方
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  // intをキー、charを値、として扱う連想配列
+  // flat_mapとは異なり、キーが重複してもよい
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  // 全体を出力する
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+
+#### 出力
+```
+10 : A
+10 : a
+11 : B
+11 : b
+12 : C
+12 : c
+```
+
+
+
+### キーと要素以外のテンプレートを指定
+```cpp example
+#include &amp;lt;deque&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::deque&amp;lt;int&amp;gt; keys = {10, 10, 11, 11, 12, 12};
+  std::deque&amp;lt;char&amp;gt; values = {&amp;#39;A&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;c&amp;#39;};
+
+  // intをキー、charを値として扱う連想配列
+  // キーの順序はgreater、キーと値のコンテナはdequeで保持
+  std::flat_multimap&amp;lt;int,
+                     char,
+                     std::greater&amp;lt;int&amp;gt;,
+                     std::deque&amp;lt;int&amp;gt;,
+                     std::deque&amp;lt;char&amp;gt;&amp;gt; fm(keys, values);
+
+  // 全体を出力する
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+
+#### 出力
+```
+12 : C
+12 : c
+11 : B
+11 : b
+10 : A
+10 : a
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0429R3 A Standard `flat_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0429r3.pdf)
+    - C++23で`flat_map`が導入された経緯・動機・設計について記載されている
+- [P0429R9 A Standard `flat_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf)
+    - C++23で導入された`flat_map`の仕様
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>begin -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/begin.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/begin.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/begin.md b/reference/flat_map/flat_multimap/begin.md
new file mode 100644
index 000000000..5efeb7caf
--- /dev/null
+++ b/reference/flat_map/flat_multimap/begin.md
@@ -0,0 +1,79 @@
+# begin
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator begin() noexcept;
+const_iterator begin() const noexcept;
+```
+
+
+## 概要
+コンテナの先頭のキーと要素のpairを参照するイテレータを取得する。
+
+内部的に、コンテナは要素を下位から上位へと並べており、従って`begin()`はコンテナ内の最下位のキーにあたるpairへのイテレータを返す。
+
+
+## 戻り値
+コンテナの先頭要素へのイテレータ。
+`iterator` と `const_iterator` はともにメンバ型である。このクラステンプレートにおいて、これらはランダムアクセスイテレータである。
+
+
+## 計算量
+定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  for (auto i = fm.begin(); i != fm.end(); ++i) {
+      std::cout &amp;lt;&amp;lt; i-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  }
+}
+```
+* begin()[color ff0000]
+* fm.end()[link end.md]
+
+### 出力
+```
+10 A
+10 a
+11 B
+11 b
+12 C
+12 c
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|----------------------------------------|--------------------------------|
+| [`flat_multimap::end`](end.md)         | 末尾の次を指すイテレータを取得する |
+| [`flat_multimap::cbegin`](cbegin.md)   | 先頭を指すconstイテレータを取得する |
+| [`flat_multimap::cend`](cend.md)       | 末尾の次を指すconstイテレータを取得する |
+| [`flat_multimap::rbegin`](rbegin.md)   | 末尾を指す逆イテレータを取得する |
+| [`flat_multimap::rend`](rend.md)       | 先頭の前を指す逆イテレータを取得する |
+| [`flat_multimap::crbegin`](crbegin.md) | 末尾を指す逆constイテレータを取得する |
+| [`flat_multimap::crend`](crend.md)     | 先頭の前を指す逆constイテレータを取得する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cbegin -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/cbegin.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/cbegin.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/cbegin.md b/reference/flat_map/flat_multimap/cbegin.md
new file mode 100644
index 000000000..b30069266
--- /dev/null
+++ b/reference/flat_map/flat_multimap/cbegin.md
@@ -0,0 +1,76 @@
+# cbegin
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+const_iterator cbegin() const noexcept;
+```
+
+
+## 概要
+コンテナの先頭のキーと要素のpairを参照するイテレータを取得する。
+
+内部的に、このコンテナは要素を下位から上位へと並べており、従って `cbegin()` はコンテナ内の最下位のキーにあたるpairへのイテレータを返す。
+
+
+## 戻り値
+コンテナの先頭要素へのイテレータ。
+`const_iterator` はメンバ型である。このクラステンプレートにおいて、これらはランダムアクセスイテレータである。
+
+
+## 計算量
+定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  for (auto i = fm.cbegin(); i != fm.cend(); ++i) {
+      std::cout &amp;lt;&amp;lt; i-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  }
+}
+```
+* cbegin()[color ff0000]
+* fm.cend()[link cend.md]
+
+### 出力
+```
+10 A
+10 a
+11 B
+11 b
+12 C
+12 c
+```
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|----------------------------------------|--------------------------------|
+| [`flat_multimap::begin`](begin.md)     | 先頭を指すイテレータを取得する |
+| [`flat_multimap::end`](end.md)         | 末尾の次を指すイテレータを取得する |
+| [`flat_multimap::cend`](cend.md)       | 末尾の次を指すconstイテレータを取得する |
+| [`flat_multimap::rbegin`](rbegin.md)   | 末尾を指す逆イテレータを取得する |
+| [`flat_multimap::rend`](rend.md)       | 先頭の前を指す逆イテレータを取得する |
+| [`flat_multimap::crbegin`](crbegin.md) | 末尾を指す逆constイテレータを取得する |
+| [`flat_multimap::crend`](crend.md)     | 先頭の前を指す逆constイテレータを取得する |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cend -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/cend.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/cend.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/cend.md b/reference/flat_map/flat_multimap/cend.md
new file mode 100644
index 000000000..0936acea6
--- /dev/null
+++ b/reference/flat_map/flat_multimap/cend.md
@@ -0,0 +1,79 @@
+# cend
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+const_iterator cend() const noexcept;
+```
+
+## 概要
+コンテナの末尾の次を参照するイテレータを取得する。
+
+
+## 戻り値
+コンテナの末尾の次を参照するイテレータ。 
+`const_iterator` はいずれもメンバ型である。このクラステンプレートにおいて、これらはランダムアクセスイテレータである。
+
+
+## 計算量
+定数時間
+
+
+## 備考
+- この関数によって返されるイテレータは、`*this`が保持するいずれの要素も参照しない。その指す先は、不正な範囲となるだろう
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  for (auto i = fm.cbegin(); i != fm.cend(); ++i) {
+      std::cout &amp;lt;&amp;lt; i-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  }
+}
+```
+* cend()[color ff0000]
+* fm.cbegin()[link cbegin.md]
+
+### 出力
+```
+10 A
+10 a
+11 B
+11 b
+12 C
+12 c
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+## 関連項目
+
+| 名前 | 説明 |
+|----------------------------------------|-------------------------------------------|
+| [`flat_multimap::begin`](begin.md)     | 先頭を指すイテレータを取得する |
+| [`flat_multimap::end`](end.md)         | 末尾の次を指すイテレータを取得する |
+| [`flat_multimap::cbegin`](cbegin.md)   | 先頭を指すconstイテレータを取得する |
+| [`flat_multimap::rbegin`](rbegin.md)   | 末尾を指す逆イテレータを取得する |
+| [`flat_multimap::rend`](rend.md)       | 先頭の前を指す逆イテレータを取得する |
+| [`flat_multimap::crbegin`](crbegin.md) | 末尾を指す逆constイテレータを取得する |
+| [`flat_multimap::crend`](crend.md)     | 先頭の前を指す逆constイテレータを取得する |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>clear -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/clear.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/clear.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/clear.md b/reference/flat_map/flat_multimap/clear.md
new file mode 100644
index 000000000..9eabc6632
--- /dev/null
+++ b/reference/flat_map/flat_multimap/clear.md
@@ -0,0 +1,60 @@
+# clear
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+void clear() noexcept; // (1) C++23
+```
+
+## 概要
+コンテナ内の全ての要素を削除する。それぞれのデストラクタが呼ばれ、コンテナから削除される。[`size()`](size.md) は 0 になる。
+
+
+## 計算量
+線形時間
+
+
+## 例外
+投げない
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main ()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {3, &amp;#39;C&amp;#39;},
+    {4, &amp;#39;D&amp;#39;},
+    {1, &amp;#39;A&amp;#39;},
+    {2, &amp;#39;B&amp;#39;},
+  };
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.clear();
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+}
+```
+* clear()[color ff0000]
+* fm.size()[link size.md]
+
+### 出力
+```
+4
+0
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>containers -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/containers.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/containers.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/containers.md b/reference/flat_map/flat_multimap/containers.md
new file mode 100644
index 000000000..947dbe9d2
--- /dev/null
+++ b/reference/flat_map/flat_multimap/containers.md
@@ -0,0 +1,98 @@
+# containers
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* class[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class Key,
+            class T,
+            class Compare = less&amp;lt;Key&amp;gt;,
+            class KeyContainer = vector&amp;lt;Key&amp;gt;,
+            class MappedContainer = vector&amp;lt;T&amp;gt;&amp;gt;
+  class flat_multimap {
+  public:
+    using key_container_type = KeyContainer;
+    using mapped_container_type = MappedContainer;
+
+    struct containers {
+      key_container_type keys;
+      mapped_container_type values;
+    };
+  };
+}
+```
+* less[link /reference/functional/less.md]
+* vector[link /reference/vector/vector.md]
+
+## 概要
+`flat_multimap`クラス内部のデータ保持方法として、キーのコンテナと値のコンテナをもつ。
+
+この形式の内部表現は [`extract()`](extract.md) メンバ関数で取得でき、シリアライズなどの用途に使用できる。
+
+
+## 例
+### 基本的な使い方
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;char, std::string&amp;gt; fm = {
+    {&amp;#39;s&amp;#39;, &amp;#34;static&amp;#34;},
+    {&amp;#39;s&amp;#39;, &amp;#34;signed&amp;#34;},
+    {&amp;#39;s&amp;#39;, &amp;#34;struct&amp;#34;},
+    {&amp;#39;c&amp;#39;, &amp;#34;const&amp;#34;},
+    {&amp;#39;c&amp;#39;, &amp;#34;class&amp;#34;}
+  };
+
+  decltype(fm)::containers c = std::move(fm).extract();
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;keys:&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const auto&amp;amp; key : c.keys) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;  &amp;#39;&amp;#34; &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34;&amp;#39;&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;values:&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const auto&amp;amp; value : c.values) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;  \&amp;#34;&amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; &amp;#34;\&amp;#34;&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* containers[color ff0000]
+* extract()[link extract.md]
+
+#### 出力
+```
+keys:
+  &amp;#39;c&amp;#39;
+  &amp;#39;c&amp;#39;
+  &amp;#39;s&amp;#39;
+  &amp;#39;s&amp;#39;
+  &amp;#39;s&amp;#39;
+values:
+  &amp;#34;const&amp;#34;
+  &amp;#34;class&amp;#34;
+  &amp;#34;static&amp;#34;
+  &amp;#34;signed&amp;#34;
+  &amp;#34;struct&amp;#34;
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`extract`](extract.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/contains.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/contains.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/contains.md b/reference/flat_map/flat_multimap/contains.md
new file mode 100644
index 000000000..3f58809c4
--- /dev/null
+++ b/reference/flat_map/flat_multimap/contains.md
@@ -0,0 +1,84 @@
+# contains
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+bool contains(const key_type&amp;amp; x) const; // (1) C++23
+
+template &amp;lt;class K&amp;gt;
+bool contains(const K&amp;amp; x) const;        // (2) C++23
+```
+
+
+## 概要
+指定されたキー`x`に一致する要素がコンテナに含まれているかを判定する。
+
+- (1) : クラスのテンプレートパラメータ`key_type`型のキーを受け取る
+- (2) : `key_type`と比較可能な`K`型のキーを受け取る
+
+
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent`が妥当な式であること
+
+
+## 戻り値
+以下と等価：
+
+```cpp
+return find(x) != end();
+```
+* find[link find.md]
+* end()[link end.md]
+
+
+## 計算量
+対数時間
+
+
+## 備考
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`flat_multimap&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;char, int&amp;gt; fm = {
+    {&amp;#39;a&amp;#39;, 3},
+    {&amp;#39;b&amp;#39;, 1},
+    {&amp;#39;c&amp;#39;, 4}
+  };
+
+  // キー&amp;#39;b&amp;#39;の要素が含まれているか
+  if (fm.contains(&amp;#39;b&amp;#39;)) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;contain&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;doesn&amp;#39;t contain&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* contains[color ff0000]
+
+### 出力
+```
+contain
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/count.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/count.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/count.md b/reference/flat_map/flat_multimap/count.md
new file mode 100644
index 000000000..1e59465e3
--- /dev/null
+++ b/reference/flat_map/flat_multimap/count.md
@@ -0,0 +1,98 @@
+# count
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+size_type count(const key_type&amp;amp; x) const; // (1) C++23
+
+template &amp;lt;class K&amp;gt;
+size_type count(const K&amp;amp; x) const;        // (2) C++23
+```
+
+## 概要
+キー `x` を検索し、コンテナ内に見つかった要素の数を返す。
+
+- (1) : クラスのテンプレートパラメータ`key_type`型のキー `x` を受け取って、`x` と等価なキーを持つ要素の数を取得する。
+- (2) : `key_type`と比較可能な`K`型のキー `x` を受け取って、`x`と等価なキーを持つ要素の数を取得する。
+
+
+## テンプレートパラメータ制約
+- (2) : `key_compare::is_transparent`が妥当な式であること
+
+
+## 戻り値
+- (1) : `x`と等価なキーの要素数を返す。
+- (2) : `key_compare`型の関数オブジェクトを`c`、コンテナ内の各要素が持つキーを`k`として、キーが等価か判定する式`!c(k, x) &amp;amp;&amp;amp; !c(x, k)`が`true`となる要素の数を返す。
+
+
+## 計算量
+```
+log(size()) + count(x)
+```
+* size()[link size.md]
+
+
+## 備考
+- (2) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`flat_multimap&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  // (1)
+  {
+    std::flat_multimap&amp;lt;std::string, int&amp;gt; fm = {
+      {&amp;#34;Alice&amp;#34;, 3},
+      {&amp;#34;Bob&amp;#34;,   1},
+      {&amp;#34;Carol&amp;#34;, 4}
+    };
+
+    std::cout &amp;lt;&amp;lt; fm.count(&amp;#34;Bob&amp;#34;) &amp;lt;&amp;lt; std::endl;
+  }
+
+  // (2)
+  {
+    std::flat_multimap&amp;lt;std::string, int, std::less&amp;lt;&amp;gt;&amp;gt; fm = {
+      {&amp;#34;Alice&amp;#34;, 3},
+      {&amp;#34;Bob&amp;#34;,   1},
+      {&amp;#34;Carol&amp;#34;, 4}
+    };
+
+    // std::lessのvoidに対する特殊化を使用することで、
+    // 文字列リテラルをcount()関数の引数として渡した際に、
+    // std::string型の一時オブジェクトが生成されない。
+    std::cout &amp;lt;&amp;lt; fm.count(&amp;#34;Bob&amp;#34;) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* fm.count[color ff0000]
+* std::less[link /reference/functional/less.md]
+
+### 出力
+```
+1
+1
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`contains()`](contains.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>crbegin -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/crbegin.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/crbegin.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/crbegin.md b/reference/flat_map/flat_multimap/crbegin.md
new file mode 100644
index 000000000..f8d67ddb0
--- /dev/null
+++ b/reference/flat_map/flat_multimap/crbegin.md
@@ -0,0 +1,76 @@
+# crbegin
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+const_reverse_iterator crbegin() const noexcept;
+```
+
+## 概要
+コンテナ内の末尾を指す逆イテレータを取得する。 
+内部的に、このコンテナは各要素をキーの値に従って下位から上位へと並べており、従って `crbegin()` は最上位のキーにあたる値へのイテレータを返す。 
+`crbegin()` は [`end()`](end.md) と同じ要素を指すわけではなく、その前の要素を指すことに注意。
+
+
+## 戻り値
+反転したシーケンスの先頭を指す逆イテレータ。 
+`const_reverse_iterator` はメンバ型である。このクラステンプレートにおいて、これらは逆ランダムアクセスイテレータであり、`reverse_iterator&amp;lt;const_iterator&amp;gt;` と定義される。
+
+
+## 計算量
+定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  for (auto i = fm.crbegin(); i != fm.crend(); ++i) {
+      std::cout &amp;lt;&amp;lt; i-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  }
+}
+```
+* crbegin()[color ff0000]
+* fm.crend()[link crend.md]
+
+### 出力
+```
+12 c
+12 C
+11 b
+11 B
+10 a
+10 A
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+| 名前 | 説明 |
+|--------------------------------------|-------------------------------------------|
+| [`flat_multimap::begin`](begin.md)   | 先頭を指すイテレータを取得する |
+| [`flat_multimap::end`](end.md)       | 末尾の次を指すイテレータを取得する |
+| [`flat_multimap::cbegin`](cbegin.md) | 先頭を指すconstイテレータを取得する |
+| [`flat_multimap::cend`](cend.md)     | 末尾の次を指すconstイテレータを取得する |
+| [`flat_multimap::rbegin`](rbegin.md) | 末尾を指す逆イテレータを取得する |
+| [`flat_multimap::rend`](rend.md)     | 先頭の前を指す逆イテレータを取得する |
+| [`flat_multimap::crend`](crend.md)   | 先頭の前を指す逆constイテレータを取得する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>crend -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/crend.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/crend.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/crend.md b/reference/flat_map/flat_multimap/crend.md
new file mode 100644
index 000000000..2a42c358c
--- /dev/null
+++ b/reference/flat_map/flat_multimap/crend.md
@@ -0,0 +1,74 @@
+# crend
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+const_reverse_iterator crend() const noexcept;
+```
+
+
+## 概要
+コンテナの先頭要素の前（これは反転シーケンスの末尾にあたる）を指す逆イテレータを取得する。 
+`crend()` は [`begin()`](begin.md) と同じ要素を指すわけではなく、その前の要素を指すことに注意。
+
+
+## 戻り値
+反転シーケンスの終端を指す逆イテレータ。 
+`const_reverse_iterator` はメンバ型である。`flat_multimap` クラステンプレートにおいて、これらは逆ランダムアクセスイテレータであり、`reverse_iterator&amp;lt;const_iterator&amp;gt;` と定義される。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  for (auto i = fm.crbegin(); i != fm.crend(); ++i) {
+      std::cout &amp;lt;&amp;lt; i-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  }
+}
+```
+* crend()[color ff0000]
+* fm.crbegin()[link crbegin.md]
+
+### 出力
+```
+12 c
+12 C
+11 b
+11 B
+10 a
+10 A
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|----------------------------------------|-----------------------------------------|
+| [`flat_multimap::begin`](begin.md)     | 先頭を指すイテレータを取得する |
+| [`flat_multimap::end`](end.md)         | 末尾の次を指すイテレータを取得する |
+| [`flat_multimap::cbegin`](cbegin.md)   | 先頭を指すconstイテレータを取得する |
+| [`flat_multimap::cend`](cend.md)       | 末尾の次を指すconstイテレータを取得する |
+| [`flat_multimap::rbegin`](rbegin.md)   | 末尾を指す逆イテレータを取得する |
+| [`flat_multimap::rend`](rend.md)       | 先頭の前を指す逆イテレータを取得する |
+| [`flat_multimap::crbegin`](crbegin.md) | 末尾を指す逆constイテレータを取得する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/emplace.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/emplace.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/emplace.md b/reference/flat_map/flat_multimap/emplace.md
new file mode 100644
index 000000000..b82cd98d5
--- /dev/null
+++ b/reference/flat_map/flat_multimap/emplace.md
@@ -0,0 +1,75 @@
+# emplace
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+template &amp;lt;class... Args&amp;gt;
+iterator emplace(Args&amp;amp;&amp;amp;... args);
+```
+
+## 概要
+コンテナに新しい要素を挿入する。要素は直接構築される（コピーもムーブもされない）。要素のコンストラクタはこの関数に渡された引数を与えることによって呼ばれる。
+
+
+## パラメータ
+- `args...` : 要素のコンストラクタへ転送される引数パック。
+
+
+## テンプレートパラメータ制約
+- [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;`[`pair`](/reference/utility/pair.md)`&amp;lt;key_type, mapped_type&amp;gt;, Arg...&amp;gt;`が`true`であること
+
+
+## 戻り値
+挿入された要素へのイテレータを返す。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm;
+
+  // キーと値のpairを作ることなく挿入できる
+  fm.emplace(3, &amp;#39;A&amp;#39;);
+  fm.emplace(1, &amp;#39;B&amp;#39;);
+  fm.emplace(4, &amp;#39;C&amp;#39;);
+  fm.emplace(3, &amp;#39;D&amp;#39;);
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* emplace[color ff0000]
+
+#### 出力
+```
+1 : B
+3 : A
+3 : D
+4 : C
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+| 名前                                             | 説明                             |
+|--------------------------------------------------|----------------------------------|
+| [`flat_multimap::insert`](insert.md)             | 要素を挿入する                   |
+| [`flat_multimap::insert_range`](insert_range.md) | Rangeを挿入する                  |
+| [`flat_multimap::emplace_hint`](emplace_hint.md) | ヒントを使って要素を直接構築する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace_hint -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/emplace_hint.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/emplace_hint.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/emplace_hint.md b/reference/flat_map/flat_multimap/emplace_hint.md
new file mode 100644
index 000000000..8bc40631b
--- /dev/null
+++ b/reference/flat_map/flat_multimap/emplace_hint.md
@@ -0,0 +1,75 @@
+# emplace_hint
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+template &amp;lt;class... Args&amp;gt;
+iterator emplace_hint(const_iterator hint, Args&amp;amp;&amp;amp;... args);
+```
+
+## 概要
+要素が配置されるべき場所を示唆するパラメータ `hint` を使って、コンテナに新しい要素を挿入する。要素は直接構築される（コピーもムーブもされない）。要素のコンストラクタはこの関数に渡された引数と同じ引数で呼ばれる。
+
+
+## パラメータ
+- `hint` : 新しい要素をどこへ挿入するかを示唆するために使われるイテレータ
+- `args...` : 要素のコンストラクタへ転送される引数パック
+
+
+## 戻り値
+追加された要素を指すイテレータ。
+
+
+## 計算量
+一般にコンテナのサイズについて対数時間だが、新しい要素が `hint` の前に挿入された場合は償却定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm;
+
+  fm.emplace(1, &amp;#39;A&amp;#39;);
+
+  // キー2の要素が最後尾に追加されることが事前にわかっているので、fm.end()をヒントとして与える
+  fm.emplace_hint(fm.end(), 2, &amp;#39;B&amp;#39;);
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* emplace_hint[color ff0000]
+* fm.emplace[link emplace.md]
+* fm.end()[link end.md]
+
+### 出力
+```
+1 : A
+2 : B
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+| 名前                                             | 説明               |
+|--------------------------------------------------|--------------------|
+| [`flat_multimap::insert`](insert.md)             | 要素を挿入する     |
+| [`flat_multimap::insert_range`](insert_range.md) | Rangeを挿入する    |
+| [`flat_multimap::emplace`](emplace.md)           | 要素を直接構築する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>empty -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/empty.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/empty.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/empty.md b/reference/flat_map/flat_multimap/empty.md
new file mode 100644
index 000000000..8c8ca362a
--- /dev/null
+++ b/reference/flat_map/flat_multimap/empty.md
@@ -0,0 +1,60 @@
+# empty
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+[[nodiscard]] bool empty() const noexcept; // (1) C++23
+```
+
+## 概要
+コンテナが空かどうかをテストする。 
+コンテナが空（[`size()`](size.md) が 0）の場合に `true` を返す。 
+
+この関数はコンテナ内のコンテンツを変化させない。コンテンツをクリアするには [`clear()`](clear.md) メンバ関数を使用する。
+
+
+## 戻り値
+コンテナサイズが 0 のときに `true`, そうでないときに `false` を返す。
+
+
+## 計算量
+定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main ()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm;
+
+  std::cout &amp;lt;&amp;lt; fm.empty() &amp;lt;&amp;lt; std::endl;
+
+  fm.insert({42, &amp;#39;a&amp;#39;});
+
+  std::cout &amp;lt;&amp;lt; fm.empty() &amp;lt;&amp;lt; std::endl;
+}
+```
+* empty()[color ff0000]
+* fm.insert[link insert.md]
+
+### 出力
+```
+1
+0
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>end -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/end.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/end.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/end.md b/reference/flat_map/flat_multimap/end.md
new file mode 100644
index 000000000..b3df377d9
--- /dev/null
+++ b/reference/flat_map/flat_multimap/end.md
@@ -0,0 +1,82 @@
+# end
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator end() noexcept;
+const_iterator end() const noexcept;
+```
+
+## 概要
+コンテナの末尾の次を参照するイテレータを取得する。
+
+
+## 戻り値
+コンテナの最後の要素の次を参照するイテレータ。 
+`iterator` と `const_iterator` はいずれもメンバ型である。`flat_multimap` クラステンプレートにおいて、これらはランダムアクセスイテレータである。
+
+
+## 計算量
+定数時間
+
+
+## 備考
+- この関数によって返されるイテレータは、`*this`が保持するいずれの要素も参照しない。その指す先は、不正な範囲となるだろう
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  for (auto i = fm.begin(); i != fm.end(); ++i) {
+      std::cout &amp;lt;&amp;lt; i-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  }
+}
+```
+* end()[color ff0000]
+* fm.begin()[link begin.md]
+
+### 出力
+```
+1 A
+2 B
+3 C
+4 D
+5 E
+6 F
+7 G
+8 H
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|----------------------------------------|-------------------------------------------|
+| [`flat_multimap::begin`](begin.md)     | 先頭を指すイテレータを取得する |
+| [`flat_multimap::cbegin`](cbegin.md)   | 先頭を指すconstイテレータを取得する |
+| [`flat_multimap::cend`](cend.md)       | 末尾の次を指すconstイテレータを取得する |
+| [`flat_multimap::rbegin`](rbegin.md)   | 末尾の次を指す逆イテレータを取得する |
+| [`flat_multimap::rend`](rend.md)       | 先頭の前を指す逆イテレータを取得する |
+| [`flat_multimap::crbegin`](crbegin.md) | 末尾を指す逆constイテレータを取得する |
+| [`flat_multimap::crend`](crend.md)     | 先頭の前を指す逆constイテレータを取得する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/equal_range.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/equal_range.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/equal_range.md b/reference/flat_map/flat_multimap/equal_range.md
new file mode 100644
index 000000000..4d0d883f2
--- /dev/null
+++ b/reference/flat_map/flat_multimap/equal_range.md
@@ -0,0 +1,85 @@
+# equal_range
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+pair&amp;lt;iterator, iterator&amp;gt; equal_range(const key_type&amp;amp; x); // (1) C++23
+
+template &amp;lt;class K&amp;gt;
+pair&amp;lt;iterator, iterator&amp;gt; equal_range(const K&amp;amp; x);        // (2) C++23
+
+pair&amp;lt;const_iterator, const_iterator&amp;gt;
+  equal_range(const key_type&amp;amp; x) const;                  // (3) C++23
+
+template &amp;lt;class K&amp;gt;
+pair&amp;lt;const_iterator, const_iterator&amp;gt;
+  equal_range(const K&amp;amp; x) const;                         // (4) C++23
+```
+* pair[link /reference/utility/pair.md]
+
+## 概要
+コンテナ内の、`x` と等しいキー要素を全て含む範囲の境界を返す。 
+
+もし `x` がコンテナ内のどのキーともマッチしなかった場合、戻り値の範囲は長さ 0 になり、両方のイテレータは `x` より大きく最も近い値を指す。そうでない場合、`x` がコンテナ内の全ての要素よりも大きい場合は [`end()`](end.md) を指す。
+
+- (1) : `key_type`型のキーを受け取り、そのキーと等価なキー要素を全て含むイテレータ範囲を取得する。
+- (2) : `key_type`と比較可能な`K`型のキーを受け取り、そのキーと等価なキー要素を全て含むイテレータ範囲を取得する。
+- (3) : `const`な`*this`オブジェクトにおいて、`key_type`型のキーを受け取り、そのキーと等価なキー要素を全て含むイテレータ範囲を取得する。
+- (4) : `const`な`*this`オブジェクトにおいて、`key_type`と比較可能な`K`型のキーを受け取り、そのキーと等価なキー要素を全て含むイテレータ範囲を取得する。
+
+
+## 戻り値
+この関数は `pair` を返す。ここで `pair::first` は [`lower_bound()`](lower_bound.md)`(x)` が返すであろう値と同じ値で範囲の下境界にあたり、`pair::second` は [`upper_bound()`](upper_bound.md)`(x)` が返すであろう値と同じ値で範囲の上境界にあたる。
+
+
+## 計算量
+[`size()`](size.md) について対数時間。
+
+
+## 備考
+- (2), (4) : この関数がオーバーロード解決に参加する条件は、[`find()`](find.md)メンバ関数の備考欄を参照。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;std::string, int&amp;gt; fm = {
+    {&amp;#34;A&amp;#34;, 3},
+    {&amp;#34;B&amp;#34;, 1},
+    {&amp;#34;B&amp;#34;, 4},
+    {&amp;#34;C&amp;#34;, 5}
+  };
+
+  using iterator = decltype(fm)::iterator;
+  std::pair&amp;lt;iterator, iterator&amp;gt; ret = fm.equal_range(&amp;#34;B&amp;#34;);
+
+  for (iterator it = ret.first; it != ret.second; ++it) {
+    std::cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* equal_range[color ff0000]
+
+### 出力
+```
+B, 1
+B, 4
+```
+
+
+## 関連項目
+| 名前 | 説明 |
+|------------------------------------------------|----------------------------------------------------------|
+| [`flat_multimap::count`](count.md)             | 指定したキーにマッチする要素の数を返す                   |
+| [`flat_multimap::lower_bound`](lower_bound.md) | 与えられた値より小さくない最初の要素へのイテレータを返す |
+| [`flat_multimap::upper_bound`](upper_bound.md) | 特定の値よりも大きい最初の要素へのイテレータを返す       |
+| [`flat_multimap::find`](find.md)               | 指定したキーで要素を探す                                 |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/erase.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/erase.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/erase.md b/reference/flat_map/flat_multimap/erase.md
new file mode 100644
index 000000000..b40d20615
--- /dev/null
+++ b/reference/flat_map/flat_multimap/erase.md
@@ -0,0 +1,146 @@
+# erase
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator erase(iterator position);                         // (1) C++23
+
+iterator erase(const_iterator position);                   // (2) C++23
+
+size_type erase(const key_type&amp;amp; x);                        // (3) C++23
+
+template &amp;lt;class K&amp;gt;
+size_type erase(K&amp;amp;&amp;amp; x);                                    // (4) C++23
+
+iterator erase(const_iterator first, const_iterator last); // (5) C++23
+```
+
+## 概要
+単一要素またはイテレータ範囲`[first, last)`を コンテナから削除する。
+
+これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
+
+- (1) : 指定されたイテレータが指す要素を削除する
+- (2) : 指定された読み取り専用イテレータが指す要素を削除する
+- (3) : 指定されたキーをもつ要素を削除する
+- (4) : `key_type`と比較可能な`K`型のキーを受け取って要素を削除する
+- (5) : 指定されたイテレータ範囲の要素をすべて削除する
+
+
+## パラメータ
+- `position` : 削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
+- `x` : 削除する値のキー。`key_type` はメンバ型であり、コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素のキーの型である。
+- `first, last` : 削除するイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+
+
+## 戻り値
+- (1), (2), (5) : 削除された要素の次を指すイテレータを返す。そのような要素がない場合、[`end()`](end.md)を返す (要素を削除した結果としてコンテナが空になった場合)
+- (3), (4) : 削除された要素の数を返す。
+
+
+## 計算量
+- (1), (2) : 定数時間
+- (3), (4) : コンテナの [`size()`](size.md) について対数時間に加えて、`count(x)` について線形時間
+- (5) : コンテナの [`size()`](size.md) について対数時間、それに加えて `first` と `last` の間の距離に対する線形時間
+
+
+## 備考
+- (1), (2) : この関数に、範囲外のイテレータ (終端イテレータを含む) を指定した場合の動作は未定義
+
+
+## 例
+### 基本的な使い方 (C++23)
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {1, &amp;#39;A&amp;#39;},
+    {2, &amp;#39;B&amp;#39;},
+    {3, &amp;#39;C&amp;#39;}
+  };
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.erase(1);
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.erase(fm.begin(), fm.end());
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+}
+```
+* erase[color ff0000]
+* fm.size()[link size.md]
+* fm.begin()[link begin.md]
+* fm.end()[link end.md]
+
+#### 出力
+```
+3
+2
+0
+```
+
+### イテレート中に要素を削除する (C++23)
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {3, &amp;#39;a&amp;#39;},
+    {1, &amp;#39;b&amp;#39;},
+    {4, &amp;#39;c&amp;#39;}
+  };
+
+  // イテレート中に要素削除をするような場合には、
+  // 範囲for文は使用できない
+  for (auto it = fm.begin(); it != fm.end();) {
+    // 条件一致した要素を削除する
+    if (it-&amp;gt;first == 1) {
+      // 削除された要素の次を指すイテレータが返される。
+      it = fm.erase(it);
+    }
+    // 要素削除をしない場合に、イテレータを進める
+    else {
+      ++it;
+    }
+  }
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#39;:&amp;#39; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+
+#### 出力
+```
+3:a
+4:c
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|--------------------------------------|----------------------|
+| [`flat_multimap::clear`](clear.md)   | 全ての要素を削除する |
+| [`flat_multimap::insert`](insert.md) | 要素を挿入する |
+| [`flat_multimap::find`](find.md)     | 指定したキーで要素を探す |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase_if -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/erase_if_free.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/erase_if_free.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/erase_if_free.md b/reference/flat_map/flat_multimap/erase_if_free.md
new file mode 100644
index 000000000..4cc6051de
--- /dev/null
+++ b/reference/flat_map/flat_multimap/erase_if_free.md
@@ -0,0 +1,87 @@
+# erase_if
+* flat_map[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class Key,
+           class T,
+           class Compare,
+           class KeyContainer,
+           class MappedContainer,
+           class Predicate&amp;gt;
+  typename flat_multimap&amp;lt;Key, T, Compare, KeyContainer, MappedContainer&amp;gt;::size_type
+    erase_if(flat_multimap&amp;lt;Key, T, Compare, KeyContainer, MappedContainer&amp;gt;&amp;amp; c,
+             Predicate pred);
+}
+```
+
+## 概要
+指定した条件に合致する要素とその分の領域を、コンテナから削除する。
+
+述語関数オブジェクトには、キーではなく、要素全体 (キーと値の[`pair`](/reference/utility/pair.md)) が渡されるので注意。
+
+
+## 事前条件
+- `Key`と`T`がムーブ代入可能であること
+
+
+## 効果
+メンバ変数として保持しているコンテナ`c`の各要素`e`について、`bool(pred(pair&amp;lt;const Key&amp;amp;, const T&amp;amp;&amp;gt;(e)))`を`E`として、`E`が`true`であるすべての要素を削除する。
+
+
+## 戻り値
+削除した要素数を返す。
+
+
+## 計算量
+正確に[`size()`](size.md)回だけ述語適用する。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;std::string, int&amp;gt; fm = {
+    {&amp;#34;A&amp;#34;, 3},
+    {&amp;#34;B&amp;#34;, 1},
+    {&amp;#34;B&amp;#34;, 4},
+    {&amp;#34;C&amp;#34;, 5}
+  };
+
+  // コンテナfmから、キーが&amp;#34;B&amp;#34;の要素をすべて削除する
+  auto num = std::erase_if(fm, [](const auto&amp;amp; x) { return x.first == &amp;#34;B&amp;#34;; });
+
+  std::cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl
+            &amp;lt;&amp;lt; std::endl;
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::erase_if[color ff0000]
+
+### 出力
+```
+2
+
+A : 3
+C : 5
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>extract -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/extract.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/extract.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/extract.md b/reference/flat_map/flat_multimap/extract.md
new file mode 100644
index 000000000..2ca6df2a4
--- /dev/null
+++ b/reference/flat_map/flat_multimap/extract.md
@@ -0,0 +1,90 @@
+# extract
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+containers extract() &amp;amp;&amp;amp;;  // C++23
+```
+
+## 概要
+キーのコンテナ、値のコンテナを戻り値として返す。
+
+
+## 戻り値
+クラス内部のデータ保持形式である [`containers`](containers.md) オブジェクト。
+
+
+## 事後条件
+呼び出し側の `flat_multimap` は空になる（たとえ例外で関数が中断されたとしても）。
+
+
+## 計算量
+定数時間。
+
+
+## 備考
+本関数は右辺値修飾されているので、右辺値からのみ読み出し可能である。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;std::string, int&amp;gt; fm = {
+    {&amp;#34;Alice&amp;#34;, 3},
+    {&amp;#34;Bob&amp;#34;,   1},
+    {&amp;#34;Carol&amp;#34;, 4}
+  };
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  decltype(fm)::containers c = std::move(fm).extract();
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  auto k = c.keys.cbegin();
+  auto v = c.values.cbegin();
+  std::cout &amp;lt;&amp;lt; &amp;#34;{&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (; k != c.keys.cend() &amp;amp;&amp;amp; v != c.values.cend(); ++k, ++v) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;  &amp;#34; &amp;lt;&amp;lt; *k &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; *v &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  std::cout &amp;lt;&amp;lt; &amp;#34;}&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* extract()[color ff0000]
+* fm.size()[link size.md]
+
+### 出力
+```
+3
+0
+
+{
+  Alice: 3,
+  Bob: 1,
+  Carol: 4,
+}
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`containers`](containers.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/find.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/find.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/find.md b/reference/flat_map/flat_multimap/find.md
new file mode 100644
index 000000000..c5e14d6c5
--- /dev/null
+++ b/reference/flat_map/flat_multimap/find.md
@@ -0,0 +1,108 @@
+# find
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator find(const key_type&amp;amp; x);             // (1) C++23
+
+template &amp;lt;class K&amp;gt;
+iterator find(const K&amp;amp; x);                    // (2) C++23
+
+const_iterator find(const key_type&amp;amp; x) const; // (3) C++23
+
+template &amp;lt;class K&amp;gt;
+const_iterator find(const K&amp;amp; x) const;        // (4) C++23
+```
+
+## 概要
+`x`と等価なキーの要素を検索する。
+
+- (1), (3) : クラスのテンプレートパラメータ`key_type`型のキーを受け取って検索する。
+- (2), (4) : `key_type`と比較可能な`K`型のキーを受け取って検索する。
+
+
+## テンプレートパラメータ制約
+- (2), (4) : `key_compare::is_transparent`が妥当な式であること
+
+
+## 戻り値
+- (1), (3) : `x`と等価なキーの要素が見つかった場合は、見つかった要素へのイテレータを返す。そうでない場合は、 [`end()`](end.md) を返す。
+- (2), (4) : `key_compare`型の関数オブジェクトを`c`、コンテナ内の各要素が持つキーを`k`として、キーが等価か判定する式`!c(k, x) &amp;amp;&amp;amp; !c(x, k)`が`true`となる要素へのイテレータを返す。そのような要素がない場合は、[`end()`](end.md) を返す。
+等価となる要素が複数ある場合、そのうちのいずれかの要素へのイテレータを返す。
+
+
+## 計算量
+[`size()`](size.md) について対数時間。
+
+
+## 備考
+- (2), (4) :
+    - `is_transparent`は、標準ライブラリの[`std::less`](/reference/functional/less.md)、[`std::greater`](/reference/functional/greater.md)といった関数オブジェクトの、`void`に対する特殊化で定義される。それ以外のテンプレートパラメータで`is_transparent`が定義されないのは、互換性のためである。
+    - これらのオーバーロードは、`flat_multimap&amp;lt;string, int&amp;gt;`のようなコンテナに対し、検索操作で文字列リテラルを渡した際に、キー型の一時オブジェクトが生成されるコストを減らすためにある。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  // (1)
+  {
+    std::flat_multimap&amp;lt;std::string, int&amp;gt; fm = {
+      {&amp;#34;Alice&amp;#34;, 3},
+      {&amp;#34;Bob&amp;#34;,   1},
+      {&amp;#34;Carol&amp;#34;, 4}
+    };
+
+    decltype(fm)::iterator it = fm.find(&amp;#34;Bob&amp;#34;);
+    if (it != fm.end()) { // 見つかった
+      std::cout &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // (2)
+  {
+    std::flat_multimap&amp;lt;std::string, int, std::less&amp;lt;&amp;gt;&amp;gt; fm = {
+      {&amp;#34;Alice&amp;#34;, 3},
+      {&amp;#34;Bob&amp;#34;,   1},
+      {&amp;#34;Carol&amp;#34;, 4}
+    };
+
+    // std::lessのvoidに対する特殊化を使用することで、
+    // 文字列リテラルをfind()関数の引数として渡した際に、
+    // std::string型の一時オブジェクトが生成されない。
+    decltype(fm)::iterator it = fm.find(&amp;#34;Bob&amp;#34;);
+    if (it != fm.end()) { // 見つかった
+      std::cout &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
+    }
+  }
+}
+```
+* find[color ff0000]
+* std::less[link /reference/functional/less.md]
+
+### 出力
+```
+1
+1
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`contains()`](contains.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/insert.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/insert.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/insert.md b/reference/flat_map/flat_multimap/insert.md
new file mode 100644
index 000000000..08e944b5f
--- /dev/null
+++ b/reference/flat_map/flat_multimap/insert.md
@@ -0,0 +1,226 @@
+# insert
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator insert(const value_type&amp;amp; x);         // (1) C++23
+iterator insert(value_type&amp;amp;&amp;amp; x);              // (2) C++23
+
+iterator insert(const_iterator position,
+                const value_type&amp;amp; x);         // (3) C++23
+iterator insert(const_iterator position,
+                value_type&amp;amp;&amp;amp; x);              // (4) C++23
+
+template&amp;lt;class P&amp;gt;
+iterator insert(P&amp;amp;&amp;amp; x);                       // (5) C++23
+
+template&amp;lt;class P&amp;gt;
+iterator insert(const_iterator position,
+                P&amp;amp;&amp;amp;);                         // (6) C++23
+
+template&amp;lt;class InputIterator&amp;gt;
+void insert(InputIterator first,
+            InputIterator last);              // (7) C++23
+
+template&amp;lt;class InputIterator&amp;gt;
+void insert(sorted_equivalent_t,
+            InputIterator first,
+            InputIterator last);              // (8) C++23
+
+void insert(initializer_list&amp;lt;value_type&amp;gt; il); // (9) C++23
+
+void insert(sorted_equivalent_t,
+            initializer_list&amp;lt;value_type&amp;gt; il); // (10) C++23
+```
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* sorted_equivalent_t[link /reference/flat_map/sorted_equivalent_t.md]
+
+## 概要
+新しく一つの要素(引数 `x` を使う)または要素のシーケンス(入力イテレータまたは `initializer_list` を使う)を挿入し、コンテナを拡張する。
+
+これは、挿入された要素の数だけコンテナの [`size()`](size.md) を増やす。
+
+内部的に `flat_multimap` コンテナは、コンストラクト時に指定された比較オブジェクトによって要素を下位から上位へとソートして保持する。
+
+この操作は、適切な引数 `position` を提供することで効率を飛躍的に改善することができる。
+
+- (1) : 単一要素を挿入する
+- (2) : 単一要素の一時オブジェクトを挿入する
+- (3) : 指定された位置に、単一要素を挿入する
+- (4) : 指定された位置に、単一要素の一時オブジェクトを挿入する
+- (5) : 単一要素として要素型`value_type`のコンストラクタ引数を受け取って挿入する
+- (6) : 指定された位置に、要素型`value_type`のコンストラクタ引数を受け取って挿入する
+- (7) : イテレータ範囲`[first, last)`を挿入する
+- (8) : ソート済みのイテレータ範囲`[first, last)`を挿入する
+- (9) : 初期化子リストを挿入する
+- (10) : ソート済みの初期化子リストを挿入する
+
+
+## 要件
+- (5), (6) : [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;`[`pair`](/reference/utility/pair.md)`&amp;lt;key_type, mapped_type&amp;gt;, P&amp;gt;`が`true`であること
+
+
+## 効果
+- (1) :
+    ```cpp
+    return emplace(x);
+    ```
+    * emplace[link emplace.md]
+
+- (2) :
+    ```cpp
+    return emplace(std::move(x));
+    ```
+    * emplace[link emplace.md]
+    * move[link /reference/utility/move.md]
+
+- (3) :
+    ```cpp
+    return emplace_hint(position, x);
+    ```
+    * emplace_hint[link emplace_hint.md]
+
+- (4) :
+    ```cpp
+    return emplace_hint(position, std::move(x));
+    ```
+    * emplace_hint[link emplace_hint.md]
+    * move[link /reference/utility/move.md]
+
+- (5) : 以下と等価：
+    ```cpp
+    return emplace(std::forward&amp;lt;P&amp;gt;(x));
+    ```
+    * emplace[link emplace.md]
+    * forward[link /reference/utility/forward.md]
+
+- (6) : 以下と等価：
+    ```cpp
+    return emplace_hint(position, std::forward&amp;lt;P&amp;gt;(x));.
+    ```
+    * emplace_hint[link emplace_hint.md]
+    * forward[link /reference/utility/forward.md]
+
+- (7) : メンバ変数として保持しているコンテナ`c`に、以下のように挿入する：
+    ```cpp
+    for (; first != last; ++first) {
+        value_type value = *first;
+        c.keys.insert(c.keys.end(), std::move(value.first));
+        c.values.insert(c.values.end(), std::move(value.second));
+    }
+    ```
+    * c.keys[link containers.md]
+    * c.values[link containers.md]
+    * end()[link /reference/vector/vector/end.md]
+    * insert[link /reference/vector/vector/insert.md]
+    * std::move[link /reference/utility/move.md]
+    * first[link /reference/utility/pair.md]
+    * second[link /reference/utility/pair.md]
+
+    - 次に、新しく挿入された要素の範囲を`value_comp()`を基準にソートする
+    - 次に、ソートされた結果の範囲と、既存の要素のソートされた範囲をひとつのソートされた範囲にマージする
+
+- (8) : メンバ変数として保持しているコンテナ`c`に、以下のように挿入する：
+    ```cpp
+    for (; first != last; ++first) {
+        value_type value = *first;
+        c.keys.insert(c.keys.end(), std::move(value.first));
+        c.values.insert(c.values.end(), std::move(value.second));
+    }
+    ```
+    * c.keys[link containers.md]
+    * c.values[link containers.md]
+    * end()[link /reference/vector/vector/end.md]
+    * insert[link /reference/vector/vector/insert.md]
+    * std::move[link /reference/utility/move.md]
+    * first[link /reference/utility/pair.md]
+    * second[link /reference/utility/pair.md]
+
+    - 次に、ソートされた結果の範囲と、既存の要素のソートされた範囲をひとつのソートされた範囲にマージする
+
+- (9) :
+    ```cpp
+    insert(il.begin(), il.end());
+    ```
+
+- (10) :
+    ```cpp
+    insert(s, il.begin(), il.end());
+    ```
+
+
+## 戻り値
+- (1)-(6) : 挿入された要素へのイテレータ
+- (7)-(10) : なし
+
+
+## 計算量
+- (7) : Nをこの操作の前の[`size()`](size.md)、Mを[`distance`](/reference/iterator/distance.md)`(first, last)`として、N + MlogM
+- (8) : Nをこの操作のあとの[`size()`](size.md)として、Nに対して線形
+
+
+## 備考
+- (7), (8) : この操作はインプレース・マージを行うため、追加のメモリ確保を行う可能性がある
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm;
+
+  // 単一要素を挿入する
+  fm.insert(std::pair{3, &amp;#39;a&amp;#39;});
+  fm.insert({3, &amp;#39;a&amp;#39;});
+
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm2 = {
+    {5, &amp;#39;d&amp;#39;},
+    {15, &amp;#39;e&amp;#39;}
+  };
+
+  // シーケンスを挿入する
+  fm.insert(fm2.begin(), fm2.end());
+
+  // 挿入するシーケンスがソート済みであることがわかっている場合、
+  // 以下のように指定した方が高速になる
+  fm.insert(std::sorted_equivalent, fm2.begin(), fm2.end());
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* insert[color ff0000]
+* begin()[link begin.md]
+* end()[link end.md]
+* std::sorted_equivalent[link /reference/flat_map/sorted_equivalent_t.md]
+
+### 出力
+```
+3 : a
+3 : a
+5 : d
+5 : d
+15 : e
+15 : e
+```
+
+## バージョン
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+| 名前                                             | 説明                             |
+|--------------------------------------------------|----------------------------------|
+| [`flat_multimap::insert_range`](insert_range.md) | Rangeを挿入する                  |
+| [`flat_multimap::emplace`](emplace.md)           | 要素を直接構築する               |
+| [`flat_multimap::emplace_hint`](emplace_hint.md) | ヒントを使って要素を直接構築する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_range -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/insert_range.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/insert_range.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/insert_range.md b/reference/flat_map/flat_multimap/insert_range.md
new file mode 100644
index 000000000..154da00c0
--- /dev/null
+++ b/reference/flat_map/flat_multimap/insert_range.md
@@ -0,0 +1,99 @@
+# insert_range
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+template&amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+void insert_range(R&amp;amp;&amp;amp; rg);                        // (1) C++23
+```
+* container-compatible-range[link /reference/exposition-only/container-compatible-range.md]
+
+## 概要
+Rangeを挿入し、コンテナを拡張する。
+
+これは、挿入された要素の数だけコンテナの [`size()`](size.md) を増やす。
+
+内部的に `flat_multimap` コンテナは、コンストラクト時に指定された比較オブジェクトによって要素を下位から上位へとソートして保持する。
+
+
+## 効果
+- メンバ変数として保持しているコンテナ`c`に、以下のように挿入する：
+    ```cpp
+    for (const auto&amp;amp; e : rg) {
+      c.keys.insert(c.keys.end(), e.first);
+      c.values.insert(c.values.end(), e.second);
+    }
+    ```
+    * c.keys[link containers.md]
+    * c.values[link containers.md]
+    * end()[link /reference/vector/vector/end.md]
+    * insert[link /reference/vector/vector/insert.md]
+    * first[link /reference/utility/pair.md]
+    * second[link /reference/utility/pair.md]
+
+    - 次に、新しく挿入された要素の範囲を`value_comp()`を基準にソートする
+    - 次に、ソートされた結果の範囲と、既存の要素のソートされた範囲をひとつのソートされた範囲にマージする
+
+
+## 戻り値
+なし
+
+
+## 計算量
+- Nをこの操作の前の[`size()`](size.md)、Mを[`ranges::distance`](/reference/iterator/ranges_distance.md)`(rg)`として、N + MlogM
+
+
+## 備考
+- この操作はインプレース・マージを行うため、追加のメモリ確保を行う可能性がある
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {3, &amp;#39;a&amp;#39;}
+  };
+
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm2 = {
+    {5, &amp;#39;d&amp;#39;},
+    {15, &amp;#39;e&amp;#39;},
+    {3, &amp;#39;h&amp;#39;}
+  };
+
+  fm.insert_range(fm2);
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* insert_range[color ff0000]
+
+### 出力
+```
+3 : a
+3 : h
+5 : d
+15 : e
+```
+
+## バージョン
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+| 名前                                             | 説明                             |
+|--------------------------------------------------|----------------------------------|
+| [`flat_multimap::insert`](insert.md)             | 要素を挿入する                   |
+| [`flat_multimap::emplace`](emplace.md)           | 要素を直接構築する               |
+| [`flat_multimap::emplace_hint`](emplace_hint.md) | ヒントを使って要素を直接構築する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>key_comp -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/key_comp.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/key_comp.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/key_comp.md b/reference/flat_map/flat_multimap/key_comp.md
new file mode 100644
index 000000000..a2d1dec6a
--- /dev/null
+++ b/reference/flat_map/flat_multimap/key_comp.md
@@ -0,0 +1,65 @@
+# key_comp
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+key_compare key_comp() const; // C++23
+```
+
+
+## 概要
+コンテナに関連づけられたキー比較用の関数オブジェクトを返す。このオブジェクトはコンテナ内の二つの要素のキー値を比較するために利用できる。
+この比較オブジェクトはオブジェクトの構築時に与えられ、関数へのポインタでも関数オブジェクトでも良い。いずれの場合でも、これは同じ型の 2 つの引数をとり、[狭義の弱順序](/reference/algorithm.md#strict-weak-ordering)に従って一つ目の引数が二つ目の引数より前のときに `true` を返し、そうでないときに `false` を返す。
+
+
+## 戻り値
+比較オブジェクト。`key_compare` はメンバ型であり、テンプレートパラメータ `Compare` の別名として定義される。
+
+
+## 計算量
+定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; m;
+  std::flat_multimap&amp;lt;int, char&amp;gt;::key_compare comp = m.key_comp();
+
+  std::cout &amp;lt;&amp;lt; comp(1, 2) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; comp(3, 2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* key_comp()[color ff0000]
+
+### 出力
+```
+1
+0
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前                                | 説明                                                     |
+|-------------------------------------|----------------------------------------------------------|
+| [`value_comp`](value_comp.md)       | 要素比較用の関数オブジェクトを返す                       |
+| [`value_compare`](value_compare.md) | 要素値のキー部分で大小関係を判定する二項述語の型             |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>key_equiv -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/key_equiv.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/key_equiv.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/key_equiv.md b/reference/flat_map/flat_multimap/key_equiv.md
new file mode 100644
index 000000000..19e621bb0
--- /dev/null
+++ b/reference/flat_map/flat_multimap/key_equiv.md
@@ -0,0 +1,32 @@
+# key_equiv
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* class[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+struct key_equiv {
+  key_equiv(key_compare c) : comp(c) { }
+
+  bool operator()(const_reference x, const_reference y) const {
+    return !comp(x.first, y.first) &amp;amp;&amp;amp; !comp(y.first, x.first);
+  }
+
+  key_compare comp;
+};
+```
+
+## 概要
+要素をとってキーの等価比較を行う説明専用の関数オブジェクト。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>keys -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/keys.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/keys.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/keys.md b/reference/flat_map/flat_multimap/keys.md
new file mode 100644
index 000000000..5855b4c3d
--- /dev/null
+++ b/reference/flat_map/flat_multimap/keys.md
@@ -0,0 +1,70 @@
+# keys
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+const key_container_type&amp;amp; keys() const noexcept; // C++23
+```
+
+## 概要
+キーのコンテナを取得する。
+
+
+## 戻り値
+`flat_multimap` クラス内部で保持しているキーのコンテナ。
+
+
+## 計算量
+定数時間
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm;
+  fm.insert({3, &amp;#39;C&amp;#39;});
+  fm.insert({1, &amp;#39;A&amp;#39;});
+  fm.insert({2, &amp;#39;B&amp;#39;});
+  fm.insert({1, &amp;#39;a&amp;#39;});
+
+  static_assert(std::is_same_v&amp;lt;decltype(fm.keys()), const std::vector&amp;lt;int&amp;gt;&amp;amp;&amp;gt;);
+    
+  for (auto i : fm.keys()) {
+      std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* keys()[color ff0000]
+
+### 出力
+```
+1
+1
+2
+3
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|----------------------------------------|-------------------------------------------|
+| [`flat_multimap::values`](values.md)   | 値のコンテナを取得する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lower_bound -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/lower_bound.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/lower_bound.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/lower_bound.md b/reference/flat_map/flat_multimap/lower_bound.md
new file mode 100644
index 000000000..949d28419
--- /dev/null
+++ b/reference/flat_map/flat_multimap/lower_bound.md
@@ -0,0 +1,119 @@
+# lower_bound
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator lower_bound(const key_type&amp;amp; x);             // (1) C++23
+
+template &amp;lt;class K&amp;gt;
+iterator lower_bound(const K&amp;amp; x);                    // (2) C++23
+
+const_iterator lower_bound(const key_type&amp;amp; x) const; // (3) C++23
+
+template &amp;lt;class K&amp;gt;
+const_iterator lower_bound(const K&amp;amp; x) const;        // (4) C++23
+```
+
+## 概要
+`x` を右辺とする `&amp;lt;` 演算が成り立たない最初の要素を指すイテレータを返す（コンテナの比較オブジェクトが使われる）。すなわちこれは `&amp;gt;=` 演算にあたる。
+
+[`upper_bound()`](upper_bound.md) とは異なり、このメンバ関数は `x` より大きいだけでなく、`x` と等しい場合であってもその要素へのイテレータを返す。
+
+内部的には `flat_multimap` コンテナ内の全ての要素は常に比較オブジェクトが定義する基準に沿って並んでいるため、この関数が返すいずれかの後に続く全ての要素が `x` より大きいか等しいことに注意。
+
+- (1) : `key_type`型のキーを受け取り、そのキーより小さくない最初の要素へのイテレータを取得する。
+- (2) : `key_type`と比較可能な`K`型のキーを受け取り、そのキーより小さくない最初の要素へのイテレータを取得する。
+- (3) : `const`な`*this`オブジェクトにおいて、`key_type`型のキーを受け取り、そのキーより小さくない最初の要素へのイテレータを取得する。
+- (4) : `const`な`*this`オブジェクトにおいて、`key_type`と比較可能な`K`型のキーを受け取り、そのキーより小さくない最初の要素へのイテレータを取得する。
+
+
+## 戻り値
+- (1), (3) : コンテナ内で `x` を右辺とする `&amp;lt;` 演算が成り立たない最初の要素へのイテレータを返す。そのような要素がない場合は、[`end()`](end.md)を返す。
+- (2), (4) : `key_compare`型の関数オブジェクトを`c`、コンテナ内の各要素が持つキーを`k`として、キーが小さくないか判定する式`!c(k, x)`が`true`となる要素へのイテレータを返す。そのような要素がない場合は、[`end()`](end.md) を返す。
+
+
+## 計算量
+[`size()`](size.md) について対数時間。
+
+
+## 備考
+- (2), (4) : この関数がオーバーロード解決に参加する条件は、[`find()`](find.md)メンバ関数の備考欄を参照。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  // (1)
+  {
+    std::flat_multimap&amp;lt;std::string, int&amp;gt; fm = {
+      {&amp;#34;A&amp;#34;, 3},
+      {&amp;#34;B&amp;#34;, 1},
+      {&amp;#34;C&amp;#34;, 4},
+      {&amp;#34;D&amp;#34;, 5}
+    };
+
+    // B以上D以下の範囲を取得
+    decltype(fm)::iterator it = fm.lower_bound(&amp;#34;B&amp;#34;);
+    decltype(fm)::iterator last = fm.upper_bound(&amp;#34;D&amp;#34;);
+
+    while (it != last) {
+      std::cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
+      ++it;
+    }
+    std::cout &amp;lt;&amp;lt; std::endl;
+  }
+
+  // (2)
+  {
+    std::flat_multimap&amp;lt;std::string, int, std::less&amp;lt;&amp;gt;&amp;gt; fm = {
+      {&amp;#34;A&amp;#34;, 3},
+      {&amp;#34;B&amp;#34;, 1},
+      {&amp;#34;C&amp;#34;, 4},
+      {&amp;#34;D&amp;#34;, 5}
+    };
+
+    // std::lessのvoidに対する特殊化を使用することで、
+    // 文字列リテラルをlower_bound()関数の引数として渡した際に、
+    // std::string型の一時オブジェクトが生成されない。
+    decltype(fm)::iterator it = fm.lower_bound(&amp;#34;B&amp;#34;);
+    decltype(fm)::iterator last = fm.upper_bound(&amp;#34;D&amp;#34;);
+
+    while (it != last) {
+      std::cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
+      ++it;
+    }
+  }
+}
+```
+* lower_bound[color ff0000]
+* fm.upper_bound[link upper_bound.md]
+* std::less[link /reference/functional/less.md]
+
+### 出力
+```
+B,1
+C,4
+D,5
+
+B,1
+C,4
+D,5
+```
+
+## 関連項目
+
+| 名前 | 説明 |
+|-------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------|
+| [`upper_bound`](upper_bound.md) | 特定の値よりも大きい最初の要素へのイテレータを返す |
+| [`equal_range`](equal_range.md) | 指定したキーにマッチする要素範囲を返す |
+| [`find`](find.md) | 指定したキーで要素を探す |
+| [`count`](count.md) | 指定したキーにマッチする要素の数を返す |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max_size -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/max_size.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/max_size.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/max_size.md b/reference/flat_map/flat_multimap/max_size.md
new file mode 100644
index 000000000..28e28d83a
--- /dev/null
+++ b/reference/flat_map/flat_multimap/max_size.md
@@ -0,0 +1,57 @@
+# max_size
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+size_type max_size() const noexcept; // (1) C++23
+```
+
+## 概要
+コンテナが格納できる要素の最大数を返す。 
+これは、システムやライブラリ実装の制限のもとでコンテナが格納できる潜在的な最大サイズである。
+
+
+## 戻り値
+[`containers`](containers.md)型メンバ変数`c`があるとして、以下を返す。
+
+```cpp
+return min&amp;lt;size_type&amp;gt;(c.keys.max_size(), c.values.max_size());
+```
+* min[link /reference/algorithm/min.md]
+* max_size()[link /reference/vector/vector/max_size.md]
+
+
+## 計算量
+定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;char, int&amp;gt; fm;
+
+  std::cout &amp;lt;&amp;lt; fm.max_size() &amp;lt;&amp;lt; std::endl;
+}
+```
+* max_size()[color ff0000]
+
+### 出力例
+```
+178956970
+```
+
+## 言語バージョン
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/op_assign.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/op_assign.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/op_assign.md b/reference/flat_map/flat_multimap/op_assign.md
new file mode 100644
index 000000000..6d2075467
--- /dev/null
+++ b/reference/flat_map/flat_multimap/op_assign.md
@@ -0,0 +1,76 @@
+# operator=
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+flat_multimap&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // C++23
+```
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+
+
+## 概要
+初期化子リストの値を代入する。
+
+
+## 効果
+`*this`の全ての要素が解放され、`il`の全ての要素が`*this`にコピー代入される。
+
+
+## 戻り値
+`*this`
+
+
+## 備考
+- 引数の型が `const flat_multimap&amp;amp;` であるコピー代入演算子と、引数の型が `flat_multimap&amp;amp;&amp;amp;` であるムーブ代入演算子は、それぞれ自動生成される。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+void print(const std::flat_multimap&amp;lt;std::string, int&amp;gt;&amp;amp; fm)
+{
+  std::cout &amp;lt;&amp;lt; &amp;#34;{&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const auto&amp;amp; kv: fm) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;  &amp;#34; &amp;lt;&amp;lt; kv.first &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; kv.second &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  std::cout &amp;lt;&amp;lt; &amp;#34;}&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+int main()
+{
+  std::initializer_list&amp;lt;std::pair&amp;lt;std::string, int&amp;gt;&amp;gt; elems = {{&amp;#34;Alice&amp;#34;, 3}, {&amp;#34;Bob&amp;#34;, 1}, {&amp;#34;Carol&amp;#34;, 4}, {&amp;#34;Alice&amp;#34;, 1}};
+
+  std::flat_multimap&amp;lt;std::string, int&amp;gt; fm;
+  fm = elems;
+
+  print(fm);
+}
+```
+
+### 出力
+```
+{
+  Alice: 3,
+  Alice: 1,
+  Bob: 1,
+  Carol: 4,
+}
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;=&gt; -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/op_compare_3way.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/op_compare_3way.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/op_compare_3way.md b/reference/flat_map/flat_multimap/op_compare_3way.md
new file mode 100644
index 000000000..bc01674f6
--- /dev/null
+++ b/reference/flat_map/flat_multimap/op_compare_3way.md
@@ -0,0 +1,90 @@
+# operator&amp;lt;=&amp;gt;
+* flat_map[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* flat_multimap[meta class]
+* cpp23[meta cpp]
+
+```cpp
+synth-three-way-result&amp;lt;value_type&amp;gt;
+  operator&amp;lt;=&amp;gt;(const flat_multimap&amp;amp; x,
+              const flat_multimap&amp;amp; y); // (1) C++23
+```
+
+## 概要
+`flat_multimap`オブジェクトの三方比較を行う。
+
+
+## テンプレートパラメータ制約
+- 型 (`const`) `value_type` の値に対して`operator&amp;lt;=&amp;gt;`が定義されるか、型 (`const`) `value_type` の値に対して`operator&amp;lt;`が定義され全順序をもつこと
+
+
+## 効果
+```cpp
+return lexicographical_compare_three_way(
+    x.begin(), x.end(),
+    y.begin(), y.end(),
+    synth-three-way);
+```
+* lexicographical_compare_three_way[link /reference/algorithm/lexicographical_compare_three_way.md]
+* begin()[link begin.md]
+* end()[link end.md]
+
+
+## 計算量
+線形時間
+
+
+## 備考
+- この演算子により、以下の演算子が使用可能になる：
+    - `operator&amp;lt;`
+    - `operator&amp;lt;=`
+    - `operator&amp;gt;`
+    - `operator&amp;gt;=`
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm1 = {
+    {3, &amp;#39;a&amp;#39;},
+    {1, &amp;#39;b&amp;#39;},
+    {4, &amp;#39;c&amp;#39;}
+  };
+
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm2 = {
+    {3, &amp;#39;a&amp;#39;},
+    {1, &amp;#39;b&amp;#39;},
+  };
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; ((fm1 &amp;lt;=&amp;gt; fm1) == 0) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (fm1 &amp;lt; fm2) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (fm1 &amp;lt;= fm1) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (fm1 &amp;gt; fm2) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (fm2 &amp;gt;= fm1) &amp;lt;&amp;lt; std::endl;
+}
+```
+
+### 出力
+```
+true
+false
+true
+true
+false
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/op_constructor.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/op_constructor.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/op_constructor.md b/reference/flat_map/flat_multimap/op_constructor.md
new file mode 100644
index 000000000..dce58a13d
--- /dev/null
+++ b/reference/flat_map/flat_multimap/op_constructor.md
@@ -0,0 +1,271 @@
+# コンストラクタ
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+// ____要素数ゼロのflat_multimapを構築____
+
+flat_multimap() : flat_multimap(key_compare()) { } // (1) C++23
+
+explicit flat_multimap(const key_compare&amp;amp; comp) // (2) C++23
+  : c(), compare(comp) { }
+
+template&amp;lt;class Allocator&amp;gt;
+explicit flat_multimap(const Allocator&amp;amp; a); // (3) C++23
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(const key_compare&amp;amp; comp, const Allocator&amp;amp; a); // (4) C++23
+
+// ____アロケータを伴うコピー＆ムーブコンストラクタ____
+
+ template&amp;lt;class Allocator&amp;gt;
+ flat_multimap(const flat_multimap&amp;amp; x, const Allocator&amp;amp; a); // (5) C++26
+
+ template&amp;lt;class Allocator&amp;gt;
+ flat_multimap(flat_multimap&amp;amp;&amp;amp; x, const Allocator&amp;amp; a); // (6) C++26
+
+// ____key_container_typeとmapped_container_typeから構築____
+
+flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
+              const key_compare&amp;amp; comp = key_compare()); // (7) C++23
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(const key_container_type&amp;amp; key_cont, const mapped_container_type&amp;amp; mapped_cont,
+              const Allocator&amp;amp; a); // (8) C++23
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(const key_container_type&amp;amp; key_cont, const mapped_container_type&amp;amp; mapped_cont,
+              const key_compare&amp;amp; comp, const Allocator&amp;amp; a); // (9) C++23
+
+// ____key_container_typeとmapped_container_type（共にソート済み）から構築____
+
+flat_multimap(sorted_equivalent_t, key_container_type key_cont, mapped_container_type mapped_cont,
+              const key_compare&amp;amp; comp = key_compare()); // (10) C++23
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(sorted_equivalent_t, const key_container_type&amp;amp; key_cont,
+              const mapped_container_type&amp;amp; mapped_cont, const Allocator&amp;amp; a); // (11) C++23
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(sorted_equivalent_t, const key_container_type&amp;amp; key_cont,
+              const mapped_container_type&amp;amp; mapped_cont,
+              const key_compare&amp;amp; comp, const Allocator&amp;amp; a); // (12) C++23
+
+// ____イテレータから構築____
+
+template&amp;lt;class InputIterator&amp;gt;
+flat_multimap(InputIterator first, InputIterator last, const key_compare&amp;amp; comp = key_compare()) // (13) C++23
+  : c(), compare(comp) { insert(first, last); }
+
+template&amp;lt;class InputIterator, class Allocator&amp;gt;
+flat_multimap(InputIterator first, InputIterator last, const Allocator&amp;amp; a); // (14) C++23
+
+template&amp;lt;class InputIterator, class Allocator&amp;gt;
+flat_multimap(InputIterator first, InputIterator last,
+              const key_compare&amp;amp; comp, const Allocator&amp;amp; a); // (15) C++23
+
+// ____イテレータ（ソート済み）から構築____
+
+template&amp;lt;class InputIterator&amp;gt;
+flat_multimap(sorted_equivalent_t s, InputIterator first, InputIterator last,
+              const key_compare&amp;amp; comp = key_compare()) // (16) C++23
+  : c(), compare(comp) { insert(s, first, last); }
+
+template&amp;lt;class InputIterator, class Allocator&amp;gt;
+flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last, const Allocator&amp;amp; a); // (17) C++23
+
+template&amp;lt;class InputIterator, class Allocator&amp;gt;
+flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
+              const key_compare&amp;amp; comp, const Allocator&amp;amp; a); // (18) C++23
+
+// ____Rangeから構築____
+
+template&amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+flat_multimap(from_range_t fr, R&amp;amp;&amp;amp; rg) // (19) C++23
+  : flat_multimap(fr, forward&amp;lt;R&amp;gt;(rg), key_compare()) { }
+
+template&amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R&amp;gt;
+flat_multimap(from_range_t, R&amp;amp;&amp;amp; rg, const key_compare&amp;amp; comp) // (20) C++23
+  : flat_multimap(comp) { insert_range(forward&amp;lt;R&amp;gt;(rg)); }
+
+template&amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R, class Allocator&amp;gt;
+flat_multimap(from_range_t, R&amp;amp;&amp;amp; rg, const Allocator&amp;amp; a); // (21) C++23
+
+template&amp;lt;container-compatible-range&amp;lt;value_type&amp;gt; R, class Allocator&amp;gt;
+flat_multimap(from_range_t, R&amp;amp;&amp;amp; rg, const key_compare&amp;amp; comp, const Allocator&amp;amp; a); // (22) C++23
+
+// ____initializer_listから構築____
+
+flat_multimap(initializer_list&amp;lt;value_type&amp;gt; il, const key_compare&amp;amp; comp = key_compare()) // (23) C++23
+  : flat_multimap(il.begin(), il.end(), comp) { }
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(initializer_list&amp;lt;value_type&amp;gt; il, const Allocator&amp;amp; a); // (24) C++23
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(initializer_list&amp;lt;value_type&amp;gt; il, const key_compare&amp;amp; comp, const Allocator&amp;amp; a); // (25) C++23
+
+// ____initializer_list（ソート済み）から構築____
+
+flat_multimap(sorted_equivalent_t s, initializer_list&amp;lt;value_type&amp;gt; il,
+              const key_compare&amp;amp; comp = key_compare()) // (26) C++23
+  : flat_multimap(s, il.begin(), il.end(), comp) { }
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(sorted_equivalent_t, initializer_list&amp;lt;value_type&amp;gt; il, const Allocator&amp;amp; a); // (27) C++23
+
+template&amp;lt;class Allocator&amp;gt;
+flat_multimap(sorted_equivalent_t, initializer_list&amp;lt;value_type&amp;gt; il,
+              const key_compare&amp;amp; comp, const Allocator&amp;amp; a); // (28) C++23
+```
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* from_range_t[link ../../ranges/from_range_t.md]
+* sorted_equivalent_t[link ../sorted_equivalent_t.md]
+* forward[link ../../utility/forward.md]
+* insert[link insert.md]
+* insert_range[link insert_range.md]
+
+
+## 概要
+`flat_multimap`オブジェクトを次に示す通りの要素で初期化する。
+
+
+## 効果
+- (1) : デフォルトコンストラクタ。デフォルトの `key_compare` を作成し、要素を持たない空の `flat_multimap` オブジェクトを構築する。
+- (2) : `key_compare` を受け取り、要素を持たない空の `flat_multimap` オブジェクトを構築する。
+- (3) : アロケータを受け取り、要素を持たない空の `flat_multimap` オブジェクトを構築する。
+- (4) : `key_compare` とアロケータを受け取り、要素を持たない空の `flat_multimap` オブジェクトを構築する。
+- (5) : アロケータを受け取り、`flat_multimap` オブジェクトをコピー構築する。
+- (6) : アロケータを受け取り、`flat_multimap` オブジェクトをムーブ構築する。
+- (7) : `key_container_type` と `mapped_container_type` から `flat_multimap` オブジェクトを構築する。構築に際し、`value_compare` に基づきソートされる。
+- (8) : アロケータを受け取り、`key_container_type` と `mapped_container_type` から `flat_multimap` オブジェクトを構築する。構築に際し、`value_compare` に基づきソートされる。
+- (9) : `key_compare` とアロケータを受け取り、`key_container_type` と `mapped_container_type` から `flat_multimap` オブジェクトを構築する。構築に際し、`value_compare` に基づきソートされる。
+- (10) : `key_container_type` と `mapped_container_type`（共にソート済み）から `flat_multimap` オブジェクトを構築する。
+- (11) : アロケータを受け取り、`key_container_type` と `mapped_container_type`（共にソート済み）から `flat_multimap` オブジェクトを構築する。
+- (12) : `key_compare` とアロケータを受け取り、`key_container_type` と `mapped_container_type`（共にソート済み）から `flat_multimap` オブジェクトを構築する。
+- (13) : イテレータから `flat_multimap` オブジェクトを構築する。構築には [`insert()`](insert.md) が用いられる。
+- (14) : アロケータを受け取り、イテレータから `flat_multimap` オブジェクトを構築する。構築には [`insert()`](insert.md) が用いられる。
+- (15) : `key_compare` とアロケータを受け取り、イテレータから `flat_multimap` オブジェクトを構築する。構築には [`insert()`](insert.md) が用いられる。
+- (16) : イテレータ（ソート済み）から `flat_multimap` オブジェクトを構築する。
+- (17) : アロケータを受け取り、イテレータ（ソート済み）から `flat_multimap` オブジェクトを構築する。
+- (18) : `key_compare` とアロケータを受け取り、イテレータ（ソート済み）から `flat_multimap` オブジェクトを構築する。
+- (19) : Rangeから `flat_multimap` オブジェクトを構築する。構築には [`insert_range()`](insert_range.md) が用いられる。
+- (20) : `key_compare` を受け取り、Rangeから `flat_multimap` オブジェクトを構築する。構築には [`insert_range()`](insert_range.md) が用いられる。
+- (21) : アロケータを受け取り、Rangeから `flat_multimap` オブジェクトを構築する。構築には [`insert_range()`](insert_range.md) が用いられる。
+- (22) : `key_compare` とアロケータを受け取り、Rangeから `flat_multimap` オブジェクトを構築する。構築には [`insert_range()`](insert_range.md) が用いられる。
+- (23) : initializer_listから `flat_multimap` オブジェクトを構築する。構築には [`insert()`](insert.md) が用いられる。
+- (24) : アロケータを受け取り、initializer_listから `flat_multimap` オブジェクトを構築する。構築には [`insert()`](insert.md) が用いられる。
+- (25) : `key_compare` とアロケータを受け取り、initializer_listから `flat_multimap` オブジェクトを構築する。構築には [`insert()`](insert.md) が用いられる。
+- (26) : initializer_list（ソート済み）から `flat_multimap` オブジェクトを構築する。
+- (27) : アロケータを受け取り、initializer_list（ソート済み）から `flat_multimap` オブジェクトを構築する。
+- (28) : `key_compare` とアロケータを受け取り、initializer_list（ソート済み）から `flat_multimap` オブジェクトを構築する。
+
+
+## 計算量
+- (1)-(4) : 定数時間。
+- (5) : 引数 `x` のサイズに対して線形時間。
+- (6) : 引数 `x` の `containers` をムーブした計算量と同じ。
+- (7)-(9) : 引数 `key_cont` のサイズを `N` とすると、`key_cont` がソート済みなら `N` に対して線形時間。そうでなければ `N log(N)`。
+- (10)-(12) : 引数 `key_cont` および `mapped_cont` をムーブした計算量と同じ。
+- (13)-(15) : 引数 `first` と `last` の距離を `N` とすると、イテレータの値が `value_compare` に基づきソート済みなら `N` に対して線形時間。そうでなければ `N log(N)`。
+- (16)-(18) : 引数 `first` と `last` の距離を `N` とすると、`N` に対して線形時間。
+- (19)-(22) : [`ranges::distance`](../../iterator/ranges_distance.md)`(rg)` を `N` とすると、要素の値が `value_compare` に基づきソート済みなら `N` に対して線形時間。そうでなければ `N log(N)`。
+- (23)-(25) : 引数 `il` のサイズを `N` とすると、イテレータの値が `value_compare` に基づきソート済みなら `N` に対して線形時間。そうでなければ `N log(N)`。
+- (26)-(28) : 引数 `il` のサイズを `N` とすると、`N` に対して線形時間。
+
+
+## 備考
+- 通常の（アロケータを指定しない）コピーコンストラクタとムーブコンストラクタは自動生成される。
+- (7)-(12) において、引数の `key_cont` と `mapped_cont` のサイズが異なる場合の動作は定められていない。
+- (3)-(6), (8), (9), (11), (12), (14), (15), (17), (18), (21), (22), (24), (25), (27), (28) は引数としてアロケータを受け取るが、引数のアロケータに対して [`uses_allocator`](uses_allocator.md) が `false` であれば、この引数は無視される。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+void print(const std::flat_multimap&amp;lt;std::string, int&amp;gt;&amp;amp; fm)
+{
+  std::cout &amp;lt;&amp;lt; &amp;#34;{&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const auto&amp;amp; kv: fm) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;  &amp;#34; &amp;lt;&amp;lt; kv.first &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; kv.second &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  std::cout &amp;lt;&amp;lt; &amp;#34;}&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; &amp;#34;(1)&amp;#34; &amp;lt;&amp;lt; std::endl;
+  {
+    std::flat_multimap&amp;lt;std::string, int&amp;gt; fm;
+    print(fm);
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;(5)&amp;#34; &amp;lt;&amp;lt; std::endl;
+  {
+    std::vector&amp;lt;std::string&amp;gt; keys = {&amp;#34;Alice&amp;#34;, &amp;#34;Bob&amp;#34;, &amp;#34;Carol&amp;#34;, &amp;#34;Alice&amp;#34;};
+    std::vector&amp;lt;int&amp;gt; values = {3, 1, 4, 1};
+
+    std::flat_multimap&amp;lt;std::string, int&amp;gt; fm(keys, values);
+    print(fm);
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;(23)&amp;#34; &amp;lt;&amp;lt; std::endl;
+  {
+    std::initializer_list&amp;lt;std::pair&amp;lt;std::string, int&amp;gt;&amp;gt; elems = {{&amp;#34;Alice&amp;#34;, 3}, {&amp;#34;Bob&amp;#34;, 1}, {&amp;#34;Carol&amp;#34;, 4}, {&amp;#34;Alice&amp;#34;, 1}};
+
+    std::flat_multimap&amp;lt;std::string, int&amp;gt; fm(elems);
+    print(fm);
+  }
+  std::cout &amp;lt;&amp;lt; std::endl;
+}
+```
+
+### 出力
+```
+(1)
+{
+}
+
+(5)
+{
+  Alice: 3,
+  Alice: 1,
+  Bob: 1,
+  Carol: 4,
+}
+
+(23)
+{
+  Alice: 3,
+  Alice: 1,
+  Bob: 1,
+  Carol: 4,
+}
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|---------------------------------------|--------------------------------------------|
+| [`uses_allocator`](uses_allocator.md) | 指定されたアロケータと合致するかをチェックする |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/op_equal.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/op_equal.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/op_equal.md b/reference/flat_map/flat_multimap/op_equal.md
new file mode 100644
index 000000000..41266b52f
--- /dev/null
+++ b/reference/flat_map/flat_multimap/op_equal.md
@@ -0,0 +1,73 @@
+# operator==
+* flat_map[meta header]
+* std[meta namespace]
+* function template[meta id-type]
+* flat_multimap[meta class]
+
+```cpp
+friend bool operator==(const flat_multimap&amp;amp; x, const flat_multimap&amp;amp; y);
+```
+
+## 概要
+`x` が `y` と等しいかどうかの判定を行う。
+
+
+## 戻り値
+以下と等価：
+
+```cpp
+return equal(x.begin(), x.end(), y.begin(), y.end());
+```
+* equal[link /reference/algorithm/equal.md]
+* begin()[link begin.md]
+* end()[link end.md]
+
+
+## 計算量
+[`size()`](size.md) に対して線形時間。ただし、`x`と`y`のサイズが異なる場合は定数時間。
+
+
+## 備考
+- この演算子により、以下の演算子が使用可能になる：
+    - `operator!=`
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm1 = {
+    {3, &amp;#39;a&amp;#39;},
+    {1, &amp;#39;b&amp;#39;},
+    {4, &amp;#39;c&amp;#39;}
+  };
+
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm2 = {
+    {3, &amp;#39;a&amp;#39;},
+    {1, &amp;#39;b&amp;#39;},
+  };
+
+  std::cout &amp;lt;&amp;lt; std::boolalpha;
+  std::cout &amp;lt;&amp;lt; (fm1 == fm1) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (fm1 == fm2) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (fm1 != fm1) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; (fm1 != fm2) &amp;lt;&amp;lt; std::endl;
+}
+```
+
+### 出力
+```
+true
+false
+false
+true
+```
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rbegin -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/rbegin.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/rbegin.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/rbegin.md b/reference/flat_map/flat_multimap/rbegin.md
new file mode 100644
index 000000000..64d5f893b
--- /dev/null
+++ b/reference/flat_map/flat_multimap/rbegin.md
@@ -0,0 +1,80 @@
+# rbegin
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+reverse_iterator rbegin() noexcept;
+const_reverse_iterator rbegin() const noexcept;
+```
+
+## 概要
+コンテナ内の末尾を指す逆イテレータを取得する。
+
+内部的に、このコンテナは各要素をキーの値に従って下位から上位へと並べており、従って `rbegin()` は最上位のキーにあたる値を指すイテレータを返す。 
+`rbegin()` は [`end()`](end.md) と同じ要素を指すわけではなく、その前の要素を指すことに注意。
+
+
+## 戻り値
+反転したシーケンスの先頭を指す逆イテレータ。 
+`reverse_iterator` と `const_reverse_iterator` はともにメンバ型である。このクラステンプレートにおいて、これらは逆ランダムアクセスイテレータであり、それぞれ `reverse_iterator&amp;lt;iterator&amp;gt;`, `reverse_iterator&amp;lt;const_iterator&amp;gt;` と定義される。
+
+
+## 計算量
+定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  for (auto i = fm.rbegin(); i != fm.rend(); ++i) {
+      std::cout &amp;lt;&amp;lt; i-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  }
+}
+```
+* rbegin()[color ff0000]
+* fm.rend()[link rend.md]
+
+### 出力
+```
+12 c
+12 C
+11 b
+11 B
+10 a
+10 A
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|----------------------------------------|-----------------------------------------|
+| [`flat_multimap::begin`](begin.md)     | 先頭を指すイテレータを取得する |
+| [`flat_multimap::end`](end.md)         | 末尾の次を指すイテレータを取得する |
+| [`flat_multimap::cbegin`](cbegin.md)   | 先頭を指すconstイテレータを取得する |
+| [`flat_multimap::cend`](cend.md)       | 末尾の次を指すconstイテレータを取得する |
+| [`flat_multimap::rend`](rend.md)       | 先頭の前を指す逆イテレータを取得する |
+| [`flat_multimap::crbegin`](crbegin.md) | 末尾を指す逆constイテレータを取得する |
+| [`flat_multimap::crend`](crend.md)     | 先頭の前を指す逆constイテレータを取得する |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>rend -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/rend.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/rend.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/rend.md b/reference/flat_map/flat_multimap/rend.md
new file mode 100644
index 000000000..7a5034691
--- /dev/null
+++ b/reference/flat_map/flat_multimap/rend.md
@@ -0,0 +1,73 @@
+# rend
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+reverse_iterator rend() noexcept;
+const_reverse_iterator rend() const noexcept;
+```
+
+## 概要
+コンテナの先頭要素の前（これは反転シーケンスの末尾にあたる）を指す逆イテレータを取得する。 
+`rend()` は [`begin()`](begin.md) と同じ要素を指すわけではなく、その前の要素を指すことに注意。
+
+## 戻り値
+反転シーケンスの終端を指す逆イテレータ。 
+`reverse_iterator` と `const_reverse_iterator` はメンバ型である。このクラステンプレートにおいて、これらは逆ランダムアクセスイテレータであり、それぞれ `reverse_iterator&amp;lt;iterator&amp;gt;`, `reverse_iterator&amp;lt;const_iterator&amp;gt;` と定義される。
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {10, &amp;#39;A&amp;#39;}, {11, &amp;#39;B&amp;#39;}, {12, &amp;#39;C&amp;#39;},
+    {10, &amp;#39;a&amp;#39;}, {11, &amp;#39;b&amp;#39;}, {12, &amp;#39;c&amp;#39;},
+  };
+
+  for (auto i = fm.rbegin(); i != fm.rend(); ++i) {
+      std::cout &amp;lt;&amp;lt; i-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; i-&amp;gt;second &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
+  }
+}
+```
+* rend()[color ff0000]
+* fm.rbegin()[link rbegin.md]
+
+### 出力
+```
+12 c
+12 C
+11 b
+11 B
+10 a
+10 A
+```
+
+## バージョン
+### 言語
+- C++23
+
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明　|
+|----------------------------------------|--------------------------------------------|
+| [`flat_multimap::begin`](begin.md)     | 先頭を指すイテレータを取得する |
+| [`flat_multimap::end`](end.md)         | 末尾の次を指すイテレータを取得する |
+| [`flat_multimap::cbegin`](cbegin.md)   | 先頭を指すconstイテレータを取得する |
+| [`flat_multimap::cend`](cend.md)       | 末尾の次を指すconstイテレータを取得する |
+| [`flat_multimap::rbegin`](rbegin.md)   | 末尾を指す逆イテレータを取得する |
+| [`flat_multimap::crbegin`](crbegin.md) | 末尾を指す逆constイテレータを取得する |
+| [`flat_multimap::crend`](crend.md)     | 先頭の前を指す逆constイテレータを取得する |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/replace.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/replace.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/replace.md b/reference/flat_map/flat_multimap/replace.md
new file mode 100644
index 000000000..8f08b3f02
--- /dev/null
+++ b/reference/flat_map/flat_multimap/replace.md
@@ -0,0 +1,93 @@
+# replace
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+void replace(key_container_type&amp;amp;&amp;amp; key_cont, mapped_container_type&amp;amp;&amp;amp; mapped_cont);  // C++23
+```
+
+## 概要
+キーのコンテナ、値のコンテナをそれぞれ置き換える。
+
+
+## 効果
+`flat_multimap` クラスが内部で保持している [`containers`](containers.md) を `c` とすると、以下と等価。
+    ```cpp
+    c.keys = std::move(key_cont);
+    c.values = std::move(mapped_cont)
+    ```
+
+
+## 事前条件
+- `key_cont.size() == mapped_cont.size()` が真であること。
+- `key_cont` が `key_compare` に基づいてソートされていること。
+
+
+## 計算量
+`key_cont` および `mapped_cont` をムーブした計算量と同じ。
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;cassert&amp;gt;
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main()
+{
+  std::vector&amp;lt;std::string&amp;gt; keys = {&amp;#34;Alice&amp;#34;, &amp;#34;Bob&amp;#34;, &amp;#34;Carol&amp;#34;};
+  std::vector&amp;lt;int&amp;gt; values = {3, 1, 4};
+
+  // 事前条件の確認
+  assert(keys.size() == values.size());
+  assert(std::is_sorted(keys.begin(), keys.end()));
+  assert(std::adjacent_find(keys.begin(), keys.end()) == keys.end());
+
+  std::flat_multimap&amp;lt;std::string, int&amp;gt; fm;
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.replace(std::move(keys), std::move(values));
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;{&amp;#34; &amp;lt;&amp;lt; std::endl;
+  for (const auto&amp;amp; kv: fm) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;  &amp;#34; &amp;lt;&amp;lt; kv.first &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; kv.second &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  std::cout &amp;lt;&amp;lt; &amp;#34;}&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+```
+* replace[color ff0000]
+* fm.size()[link size.md]
+* std::is_sorted[link /reference/algorithm/is_sorted.md]
+* std::adjacent_find[link /reference/algorithm/adjacent_find.md]
+
+### 出力
+```
+0
+3
+
+{
+  Alice: 3,
+  Bob: 1,
+  Carol: 4,
+}
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>size -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/size.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/size.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/size.md b/reference/flat_map/flat_multimap/size.md
new file mode 100644
index 000000000..4c3e67b87
--- /dev/null
+++ b/reference/flat_map/flat_multimap/size.md
@@ -0,0 +1,69 @@
+# size
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+size_type size() const noexcept;
+```
+
+## 概要
+コンテナ内の要素の数を返す。
+
+
+## 戻り値
+[`containers`](containers.md)型メンバ変数`c`があるとして、以下を返す。
+
+```cpp
+return c.keys.size();
+```
+* size()[link /reference/vector/vector/size.md]
+
+
+## 計算量
+定数時間
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main ()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm;
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+
+  fm.insert({1, &amp;#39;a&amp;#39;});
+  fm.insert({2, &amp;#39;b&amp;#39;});
+  fm.insert({3, &amp;#39;c&amp;#39;});
+  fm.insert({1, &amp;#39;a&amp;#39;});
+
+  std::cout &amp;lt;&amp;lt; fm.size() &amp;lt;&amp;lt; std::endl;
+}
+```
+* size()[color ff0000]
+* fm.insert[link insert.md]
+
+### 出力
+```
+0
+4
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`empty()`](empty.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>swap -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/swap.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/swap.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/swap.md b/reference/flat_map/flat_multimap/swap.md
new file mode 100644
index 000000000..f985066b3
--- /dev/null
+++ b/reference/flat_map/flat_multimap/swap.md
@@ -0,0 +1,81 @@
+# swap
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+void swap(flat_multimap&amp;amp; y) noexcept; // (1) C++23
+```
+
+## 概要
+コンテナ内のコンテンツを、同じ型の要素を保持する他の `flat_multimap` オブジェクトである `y` 内のコンテンツと交換する。
+
+このメンバ関数の呼び出しの後、呼び出し前にコンテナ内にあった要素は `y` へ、`y` 内にあった要素は `*this` へ移る。
+
+
+## 計算量
+定数時間
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+template &amp;lt;class Map&amp;gt;
+void print(const char* name, const Map&amp;amp; m)
+{
+  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34; : {&amp;#34;;
+
+  bool first = true;
+
+  for (const auto&amp;amp; x : m) {
+    if (first) {
+      first = false;
+    }
+    else {
+      std::cout &amp;lt;&amp;lt; &amp;#34;, &amp;#34;;
+    }
+    std::cout &amp;lt;&amp;lt; &amp;#34;[&amp;#34; &amp;lt;&amp;lt; x.first &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; x.second &amp;lt;&amp;lt; &amp;#34;]&amp;#34;;
+  }
+  std::cout &amp;lt;&amp;lt; &amp;#34;}&amp;#34; &amp;lt;&amp;lt; std::endl;
+}
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm1 = {
+    {10, &amp;#39;a&amp;#39;},
+    {20, &amp;#39;b&amp;#39;},
+    {30, &amp;#39;c&amp;#39;}
+  };
+
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm2 = {
+    {5, &amp;#39;d&amp;#39;},
+    {15, &amp;#39;e&amp;#39;}
+  };
+
+  // fm1とfm2を入れ替える
+  fm1.swap(fm2);
+
+  print(&amp;#34;fm1&amp;#34;, fm1);
+  print(&amp;#34;fm2&amp;#34;, fm2);
+}
+```
+
+### 出力
+```
+fm1 : {[5,d], [15,e]}
+fm2 : {[10,a], [20,b], [30,c]}
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/upper_bound.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/upper_bound.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/upper_bound.md b/reference/flat_map/flat_multimap/upper_bound.md
new file mode 100644
index 000000000..025c1e0bb
--- /dev/null
+++ b/reference/flat_map/flat_multimap/upper_bound.md
@@ -0,0 +1,119 @@
+# upper_bound
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+iterator upper_bound(const key_type&amp;amp; x);             // (1) C++23
+
+template &amp;lt;class K&amp;gt;
+iterator upper_bound(const K&amp;amp; x);                    // (2) C++23
+
+const_iterator upper_bound(const key_type&amp;amp; x) const; // (3) C++23
+
+template &amp;lt;class K&amp;gt;
+const_iterator upper_bound(const K&amp;amp; x) const;        // (4) C++23
+```
+
+## 概要
+`x` より大きいキーを持つコンテナ内の最初の要素を指すイテレータを返す（コンテナの比較オブジェクトを使う）。
+
+[`lower_bound()`](lower_bound.md) と異なり、このメンバ関数は `x` と等しいときは要素へのイテレータを返さず、それは大きい場合にのみ要素へのイテレータを返す。
+
+内部的に、`flat_multimap` コンテナ内の全ての要素は常に比較オブジェクトで定義された基準に従って並ぶため、この関数が返す値に続く全ての要素は `x` より大きいことに注意。
+
+- (1) : `key_type`型のキーを受け取り、そのキーより大きい最初の要素へのイテレータを取得する。
+- (2) : `key_type`と比較可能な`K`型のキーを受け取り、そのキーより大きい最初の要素へのイテレータを取得する。
+- (3) : `const`な`*this`オブジェクトにおいて、`key_type`型のキーを受け取り、そのキーより大きい最初の要素へのイテレータを取得する。
+- (4) : `const`な`*this`オブジェクトにおいて、`key_type`と比較可能な`K`型のキーを受け取り、そのキーより大きい最初の要素へのイテレータを取得する。
+
+
+## 戻り値
+- (1), (3) : キー`x`より大きい最初の要素へのイテレータを返す。そのような要素がない場合は、[`end()`](end.md)を返す。
+- (2), (4) : `key_compare`型の関数オブジェクトを`c`、コンテナ内の各要素が持つキーを`k`として、キーが小さくないか判定する式`c(x, k)`が`true`となる要素へのイテレータを返す。そのような要素がない場合は、[`end()`](end.md) を返す。
+
+
+## 計算量
+[`size()`](size.md) について対数時間。
+
+
+## 備考
+- (2), (4) : この関数がオーバーロード解決に参加する条件は、[`find()`](find.md)メンバ関数の備考欄を参照。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+int main()
+{
+  // (1)
+  {
+    std::flat_multimap&amp;lt;std::string, int&amp;gt; fm = {
+      {&amp;#34;A&amp;#34;, 3},
+      {&amp;#34;B&amp;#34;, 1},
+      {&amp;#34;C&amp;#34;, 4},
+      {&amp;#34;D&amp;#34;, 5}
+    };
+
+    // B以上D以下の範囲を取得
+    decltype(fm)::iterator it = fm.lower_bound(&amp;#34;B&amp;#34;);
+    decltype(fm)::iterator last = fm.upper_bound(&amp;#34;D&amp;#34;);
+
+    while (it != last) {
+      std::cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
+      ++it;
+    }
+    std::cout &amp;lt;&amp;lt; std::endl;
+  }
+
+  // (2)
+  {
+    std::flat_multimap&amp;lt;std::string, int, std::less&amp;lt;&amp;gt;&amp;gt; fm = {
+      {&amp;#34;A&amp;#34;, 3},
+      {&amp;#34;B&amp;#34;, 1},
+      {&amp;#34;C&amp;#34;, 4},
+      {&amp;#34;D&amp;#34;, 5}
+    };
+
+    // std::lessのvoidに対する特殊化を使用することで、
+    // 文字列リテラルをlower_bound()関数の引数として渡した際に、
+    // std::string型の一時オブジェクトが生成されない。
+    decltype(fm)::iterator it = fm.lower_bound(&amp;#34;B&amp;#34;);
+    decltype(fm)::iterator last = fm.upper_bound(&amp;#34;D&amp;#34;);
+
+    while (it != last) {
+      std::cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
+      ++it;
+    }
+  }
+}
+```
+* upper_bound[color ff0000]
+* fm.lower_bound[link lower_bound.md]
+* std::less[link /reference/functional/less.md]
+
+### 出力
+```
+B,1
+C,4
+D,5
+
+B,1
+C,4
+D,5
+```
+
+## 関連項目
+
+| 名前 | 説明 |
+|-------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|
+| [`lower_bound`](lower_bound.md) | 与えられた値よりも小さくない最初の要素へのイテレータを返す |
+| [`equal_range`](equal_range.md) | 指定したキーにマッチする要素範囲を返す |
+| [`find`](find.md) | 指定したキーで要素を探す |
+| [`count`](count.md) | 指定したキーにマッチする要素の数を返す |
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uses_allocator -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/uses_allocator.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/uses_allocator.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/uses_allocator.md b/reference/flat_map/flat_multimap/uses_allocator.md
new file mode 100644
index 000000000..c67c80f8d
--- /dev/null
+++ b/reference/flat_map/flat_multimap/uses_allocator.md
@@ -0,0 +1,55 @@
+# uses_allocator
+* flat_map[meta header]
+* std[meta namespace]
+* class template[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class Key, class T, class Compare, class KeyContainer, class MappedContainer,
+            class Alloc&amp;gt;
+  struct uses_allocator&amp;lt;flat_multimap&amp;lt;Key, T, Compare, KeyContainer, MappedContainer&amp;gt;,
+                        Alloc&amp;gt;
+    : bool_constant&amp;lt;uses_allocator_v&amp;lt;KeyContainer, Alloc&amp;gt; &amp;amp;&amp;amp;
+                    uses_allocator_v&amp;lt;MappedContainer, Alloc&amp;gt;&amp;gt; { };
+}
+```
+* bool_constant[link /reference/type_traits/bool_constant.md]
+
+## 概要
+`uses_allocator`の、`flat_multimap`に対する特殊化。
+
+アロケータを指定する`flat_multimap`の[`コンストラクタ`](op_constructor.md)において、指定されたアロケータと、`KeyContainer`および`MappedContainer`のアロケータが合致するかをチェックするのに使われる。
+
+
+## 例
+```cpp
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  using fm_t = std::flat_multimap&amp;lt;int, int&amp;gt;;
+
+  std::cout &amp;lt;&amp;lt; std::uses_allocator&amp;lt;fm_t, std::allocator&amp;lt;int&amp;gt;&amp;gt;::value &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::uses_allocator[color ff0000]
+* std::allocator[link /reference/memory/allocator.md]
+
+### 出力
+```cpp
+1
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>value_comp -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/value_comp.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/value_comp.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/value_comp.md b/reference/flat_map/flat_multimap/value_comp.md
new file mode 100644
index 000000000..789490712
--- /dev/null
+++ b/reference/flat_map/flat_multimap/value_comp.md
@@ -0,0 +1,72 @@
+# value_comp
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+value_compare value_comp() const; // C++23
+```
+
+
+## 概要
+コンテナに関連づけられた要素比較用の関数オブジェクトを返す。これはコンテナ内の二つの要素のキー部分を比較するために利用できる。
+これは同じ型の 2 つの引数をとり、[狭義の弱順序](/reference/algorithm.md#strict-weak-ordering)に従って一つ目の引数が二つ目の引数の前になる場合に `true`、そうでない場合に `false` を返す。
+
+
+## 戻り値
+要素比較用の関数オブジェクト。
+[`value_compare`](value_compare.md) はメンバ型である。`key_compare` とは異なり、単なる型の別名ではなく入れ子クラスである。
+
+
+## 計算量
+定数時間。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; m;
+  std::flat_multimap&amp;lt;int, char&amp;gt;::value_compare comp = m.value_comp();
+
+  auto p1 = std::make_pair(1, &amp;#39;a&amp;#39;);
+  auto p2 = std::make_pair(2, &amp;#39;b&amp;#39;);
+  auto p3 = std::make_pair(3, &amp;#39;c&amp;#39;);
+
+  std::cout &amp;lt;&amp;lt; comp(p1, p2) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; comp(p3, p2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* value_comp()[color ff0000]
+* value_compare[link value_compare.md]
+
+### 出力
+```
+1
+0
+```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前                                | 説明                                                     |
+|-------------------------------------|----------------------------------------------------------|
+| [`key_comp`](key_comp.md)           | キー比較用の関数オブジェクトを取得する                      |
+| [`value_compare`](value_compare.md) | 要素値のキー部分で大小関係を判定する二項述語の型             |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>value_compare -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/value_compare.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/value_compare.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/value_compare.md b/reference/flat_map/flat_multimap/value_compare.md
new file mode 100644
index 000000000..abf5667bf
--- /dev/null
+++ b/reference/flat_map/flat_multimap/value_compare.md
@@ -0,0 +1,53 @@
+# value_compare
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* class[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  class flat_multimap::value_compare;
+}
+```
+
+## 概要
+`value_compare` は `flat_multimap` の入れ子クラスで、`flat_multimap::value_type` 型のオブジェクトを比較する関数オブジェクト型である。  
+比較の基準は `flat_multimap::key_compare` と同様であるが、`flat_multimap::key_compare` の関数呼び出し演算子の引数型が `flat_multimap::key_type` であるのに対して、本クラスの関数呼び出し演算子の比較型は `flat_multimap::value_type` である点が異なっている。
+なお、引数のうち [`flat_multimap`](../flat_multimap.md)`::mapped_type` にあたる [`pair`](../../utility/pair.md) の `second` 部については、比較時には無視される。
+
+
+## メンバ関数
+| 名前                                                      | 説明               | 対応バージョン |
+|-----------------------------------------------------------|--------------------|----------------|
+| [`operator()`](value_compare/op_call.md.nolink)           | 関数呼び出し演算子 |                |
+
+一般的な実装では、`key_compare` 型をメンバ変数で保持しており、その変数名を `comp` とすると、以下の動作となる。
+    ```cpp
+    bool operator()(const_reference x, const_reference y) const {
+      return comp(x.first, y.first);
+    }
+    ```
+
+
+## 例
+[`value_comp()`](value_comp.md) の例を参照。
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前                                | 説明                                                     |
+|-------------------------------------|----------------------------------------------------------|
+| [`key_comp`](key_comp.md)           | キー比較用の関数オブジェクトを取得する                      |
+| [`value_comp`](value_comp.md)       | 要素比較用の関数オブジェクトを返す                       |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>values -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/values.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/flat_multimap/values.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/values.md b/reference/flat_map/flat_multimap/values.md
new file mode 100644
index 000000000..bb7ee2669
--- /dev/null
+++ b/reference/flat_map/flat_multimap/values.md
@@ -0,0 +1,70 @@
+# values
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* function[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+const mapped_container_type&amp;amp; values() const noexcept; // C++23
+```
+
+## 概要
+値のコンテナを取得する。
+
+
+## 戻り値
+`flat_multimap` クラス内部で保持している値のコンテナ。
+
+
+## 計算量
+定数時間
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm;
+  fm.insert({3, &amp;#39;C&amp;#39;});
+  fm.insert({1, &amp;#39;A&amp;#39;});
+  fm.insert({2, &amp;#39;B&amp;#39;});
+  fm.insert({1, &amp;#39;a&amp;#39;});
+
+  static_assert(std::is_same_v&amp;lt;decltype(fm.values()), const std::vector&amp;lt;char&amp;gt;&amp;amp;&amp;gt;);
+    
+  for (auto i : fm.values()) {
+      std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* values()[color ff0000]
+
+### 出力
+```
+A
+a
+B
+C
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+
+| 名前 | 説明 |
+|-------------------------------|-------------------------------------------|
+| [`flat_multimap::keys`](keys.md)   | キーのコンテナを取得する |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sorted_equivalent_t -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/sorted_equivalent_t.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/flat_map/sorted_equivalent_t.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/sorted_equivalent_t.md b/reference/flat_map/sorted_equivalent_t.md
new file mode 100644
index 000000000..33ff9b30b
--- /dev/null
+++ b/reference/flat_map/sorted_equivalent_t.md
@@ -0,0 +1,66 @@
+# sorted_equivalent_t
+* flat_map[meta header]
+* std[meta namespace]
+* class[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  struct sorted_equivalent_t { explicit sorted_equivalent_t() = default; };
+  inline constexpr sorted_equivalent_t sorted_equivalent{};
+}
+```
+
+## 概要
+`sorted_equivalent_t`は、[`flat_multimap`](flat_multimap.md)コンテナに挿入するシーケンスがソート済みであること（重複は許可される）を示すためのタグ型および値である。
+
+このクラス自体は空であり、オーバーロード解決のためにのみ使用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;flat_map&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm = {
+    {3, &amp;#39;a&amp;#39;}
+  };
+
+  std::flat_multimap&amp;lt;int, char&amp;gt; fm2 = {
+    {5, &amp;#39;d&amp;#39;},
+    {15, &amp;#39;e&amp;#39;}
+  };
+
+  // 挿入するシーケンスがソート済みであることがわかっている場合、
+  // sorted_equivalentを指定した方が高速になる
+  fm.insert(std::sorted_equivalent, fm2.begin(), fm2.end());
+
+  for (const auto&amp;amp; [key, value] : fm) {
+    std::cout &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &amp;#34; : &amp;#34; &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::sorted_equivalent[color ff0000]
+* insert[link flat_multimap/insert.md]
+* begin()[link flat_multimap/begin.md]
+* end()[link flat_multimap/end.md]
+
+### 出力
+```
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`std::flat_multimap`](flat_multimap.md)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/map/map/count.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/map/map/count.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/count.md b/reference/map/map/count.md
index 491e70c98..5f58cc515 100644
--- a/reference/map/map/count.md
+++ b/reference/map/map/count.md
@@ -25,9 +25,9 @@ size_type count(const K&amp;amp; x) const;        // (2) C++14
 
 ## 計算量
 ```
-log(b.size()) + b.count(k)
+log(size()) + count(x)
 ```
-* b.size()[link size.md]
+* size()[link size.md]
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/map/map/insert.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/map/map/insert.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/insert.md b/reference/map/map/insert.md
index b8c44319b..79c361915 100644
--- a/reference/map/map/insert.md
+++ b/reference/map/map/insert.md
@@ -32,7 +32,7 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (10) C++17
 * initializer_list[link /reference/initializer_list/initializer_list.md]
 
 ## 概要
-新しく一つの要素(引数 `x`, `y`を使う)または要素のシーケンス(入力イテレータまたは `initializer_list` を使う)または[ノードハンドル](/reference/node_handle/node_handle.md)を挿入することにより、 `map` コンテナを拡張する。
+新しく一つの要素(引数 `x` を使う)または要素のシーケンス(入力イテレータまたは `initializer_list` を使う)または[ノードハンドル](/reference/node_handle/node_handle.md)を挿入することにより、 `map` コンテナを拡張する。
 
 これは、挿入された要素の数だけコンテナの [`size()`](size.md) を増やす。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/count.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/map/multimap/count.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/count.md b/reference/map/multimap/count.md
index 25455b731..89861b3fe 100644
--- a/reference/map/multimap/count.md
+++ b/reference/map/multimap/count.md
@@ -25,9 +25,9 @@ size_type count(const K&amp;amp; x) const;        // (2) C++14
 
 ## 計算量
 ```
-log(b.size()) + b.count(k)
+log(size()) + count(x)
 ```
-* b.size()[link size.md]
+* size()[link size.md]
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/count.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/set/multiset/count.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/count.md b/reference/set/multiset/count.md
index 8f801ed4b..7490ba274 100644
--- a/reference/set/multiset/count.md
+++ b/reference/set/multiset/count.md
@@ -25,9 +25,9 @@ size_type count(const K&amp;amp; x) const;        // (2) C++14
 
 ## 計算量
 ```
-log(b.size()) + b.count(k)
+log(size()) + count(x)
 ```
-* b.size()[link size.md]
+* size()[link size.md]
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- flat_map : add flat_multimap (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/set/set/count.html"/>
      <id>9ee90cb63f54d718f3347a3066a5d00d2a2ec84c:reference/set/set/count.md</id>
      <updated>2025-01-30T20:22:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/count.md b/reference/set/set/count.md
index 69e0cc700..f50307514 100644
--- a/reference/set/set/count.md
+++ b/reference/set/set/count.md
@@ -25,9 +25,9 @@ size_type count(const K&amp;amp; x) const;        // (2) C++14
 
 ## 計算量
 ```
-log(b.size()) + b.count(k)
+log(size()) + count(x)
 ```
-* b.size()[link size.md]
+* size()[link size.md]
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
</feed>