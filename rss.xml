<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="http://cpprefjp.github.io" />
  <updated>2015-12-15T16:45:19.472525</updated>
  <id>3eb22d18-1b51-4a87-9e12-8e845eac0242</id>

  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : クロージャ型とクロージャオブジェクトを分けた(#294)</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>44de47a026fd75a38c1ec37e0499da63afe5cac7:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-15 16:44:55 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトのキャプチャ方法はひとつしか指定できない。変数個別のキャプチャ方法は、カンマ区切りで複数指定できる。&lt;/p&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;構文&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;[キャプチャリスト](パラメータリスト) mutable 例外仕様 属性 -&amp;gt; 戻り値の型 { 関数の本体 }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このうち、以下は省略可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータがない場合は、パラメータリストおよびその丸カッコを省略できる&lt;/li&gt;
&lt;li&gt;キャプチャした変数を書き換える必要がない場合、&lt;code&gt;mutable&lt;/code&gt;を省略できる&lt;/li&gt;
&lt;li&gt;例外仕様を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;属性を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;戻り値の型を推論に任せる場合、&lt;code&gt;-&amp;gt;&lt;/code&gt;記号および戻り値の型を省略できる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっとも短いラムダ式は、以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;[]{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このラムダ式は、なにもキャプチャせず、パラメータを受け取らず、なにも処理せず、戻り値の型が&lt;code&gt;void&lt;/code&gt;である関数オブジェクトを定義する。&lt;/p&gt;
&lt;p&gt;ラムダ式の記述に関する制限として、「ラムダ式は、評価されないオペランドに現れてはならない」というものがある。そのため、&lt;code&gt;decltype&lt;/code&gt;、&lt;code&gt;sizeof&lt;/code&gt;、&lt;code&gt;noexcept&lt;/code&gt;のオペランドにはラムダ式を指定できない。&lt;/p&gt;
&lt;h2&gt;クロージャオブジェクト&lt;/h2&gt;
&lt;p&gt;ラムダ式は、その場に関数オブジェクトのクラスを定義し、その一時オブジェクトを生成する。関数オブジェクトのクラスを「クロージャ型(closure type)」、その一時オブジェクトを「クロージャオブジェクト(closure object)」という。これらには、以下の特徴がある：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ラムダ式ごとに、一意な名前の関数オブジェクトが定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;なコピーコンストラクタを持つ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;なムーブコンストラクタを持つ&lt;/li&gt;
&lt;li&gt;デフォルトコンストラクタを持たない&lt;/li&gt;
&lt;li&gt;コピー代入演算子は&lt;code&gt;delete&lt;/code&gt;定義される&lt;/li&gt;
&lt;li&gt;関数呼び出し演算子は、以下の特徴を持つ：&lt;ul&gt;
&lt;li&gt;ラムダ式を&lt;code&gt;mutable&lt;/code&gt;修飾しない限り、デフォルトで&lt;code&gt;const&lt;/code&gt;メンバ関数として定義される&lt;/li&gt;
&lt;li&gt;非&lt;code&gt;virtual&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非&lt;code&gt;volatile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;インライン関数&lt;/li&gt;
&lt;li&gt;ラムダ式と同じパラメータリストの型、および戻り値の型を持つ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;キャプチャをしないラムダ式の場合、ラムダ式と同じシグニチャを持つ関数ポインタへの変換演算子を持つ&lt;/li&gt;
&lt;li&gt;クロージャオブジェクトのサイズは未規定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : 評価されないオペランドに現れてはならない、という制限を記載(#294)</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>8d11ba1cd632d911f6f78ae86b027decd009d9c8:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-15 16:11:29 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトのキャプチャ方法はひとつしか指定できない。変数個別のキャプチャ方法は、カンマ区切りで複数指定できる。&lt;/p&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;構文&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;[キャプチャリスト](パラメータリスト) mutable 例外仕様 属性 -&amp;gt; 戻り値の型 { 関数の本体 }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このうち、以下は省略可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータがない場合は、パラメータリストおよびその丸カッコを省略できる&lt;/li&gt;
&lt;li&gt;キャプチャした変数を書き換える必要がない場合、&lt;code&gt;mutable&lt;/code&gt;を省略できる&lt;/li&gt;
&lt;li&gt;例外仕様を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;属性を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;戻り値の型を推論に任せる場合、&lt;code&gt;-&amp;gt;&lt;/code&gt;記号および戻り値の型を省略できる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっとも短いラムダ式は、以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;[]{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このラムダ式は、なにもキャプチャせず、パラメータを受け取らず、なにも処理せず、戻り値の型が&lt;code&gt;void&lt;/code&gt;である関数オブジェクトを定義する。&lt;/p&gt;
&lt;p&gt;ラムダ式の記述に関する制限として、「ラムダ式は、評価されないオペランドに現れてはならない」というものがある。そのため、&lt;code&gt;decltype&lt;/code&gt;、&lt;code&gt;sizeof&lt;/code&gt;、&lt;code&gt;noexcept&lt;/code&gt;のオペランドにはラムダ式を指定できない。&lt;/p&gt;
&lt;h2&gt;クロージャオブジェクト&lt;/h2&gt;
&lt;p&gt;ラムダ式によって定義される関数オブジェクトを、クロージャオブジェクト(closure object)という。これには、以下の特徴がある：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ラムダ式ごとに、一意な名前の関数オブジェクトが定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;なコピーコンストラクタを持つ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;なムーブコンストラクタを持つ&lt;/li&gt;
&lt;li&gt;デフォルトコンストラクタを持たない&lt;/li&gt;
&lt;li&gt;コピー代入演算子は&lt;code&gt;delete&lt;/code&gt;定義される&lt;/li&gt;
&lt;li&gt;関数呼び出し演算子は、以下の特徴を持つ：&lt;ul&gt;
&lt;li&gt;ラムダ式を&lt;code&gt;mutable&lt;/code&gt;修飾しない限り、デフォルトで&lt;code&gt;const&lt;/code&gt;メンバ関数として定義される&lt;/li&gt;
&lt;li&gt;非&lt;code&gt;virtual&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非&lt;code&gt;volatile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;インライン関数&lt;/li&gt;
&lt;li&gt;ラムダ式と同じパラメータリストの型、および戻り値の型を持つ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;キャプチャをしないラムダ式の場合、クロージャオブジェクトは、ラムダ式と同じシグニチャを持つ関数ポインタへの変換演算子を持つ&lt;/li&gt;
&lt;li&gt;クロージャオブジェクトのサイズは未規定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : クロージャオブジェクトの解説を追加(#294)</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>a53bfe90166f08f421e7091aecaef6ba5d253340:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-15 14:13:10 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトのキャプチャ方法はひとつしか指定できない。変数個別のキャプチャ方法は、カンマ区切りで複数指定できる。&lt;/p&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;構文&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;[キャプチャリスト](パラメータリスト) mutable 例外仕様 属性 -&amp;gt; 戻り値の型 { 関数の本体 }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このうち、以下は省略可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータがない場合は、パラメータリストおよびその丸カッコを省略できる&lt;/li&gt;
&lt;li&gt;キャプチャした変数を書き換える必要がない場合、&lt;code&gt;mutable&lt;/code&gt;を省略できる&lt;/li&gt;
&lt;li&gt;例外仕様を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;属性を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;戻り値の型を推論に任せる場合、&lt;code&gt;-&amp;gt;&lt;/code&gt;記号および戻り値の型を省略できる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっとも短いラムダ式は、以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;[]{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このラムダ式は、なにもキャプチャせず、パラメータを受け取らず、なにも処理せず、戻り値の型が&lt;code&gt;void&lt;/code&gt;である関数オブジェクトを定義する。&lt;/p&gt;
&lt;h2&gt;クロージャオブジェクト&lt;/h2&gt;
&lt;p&gt;ラムダ式によって定義される関数オブジェクトを、クロージャオブジェクト(closure object)という。これには、以下の特徴がある：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ラムダ式ごとに、一意な名前の関数オブジェクトが定義される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;なコピーコンストラクタを持つ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;なムーブコンストラクタを持つ&lt;/li&gt;
&lt;li&gt;デフォルトコンストラクタを持たない&lt;/li&gt;
&lt;li&gt;コピー代入演算子は&lt;code&gt;delete&lt;/code&gt;定義される&lt;/li&gt;
&lt;li&gt;関数呼び出し演算子は、以下の特徴を持つ：&lt;ul&gt;
&lt;li&gt;ラムダ式を&lt;code&gt;mutable&lt;/code&gt;修飾しない限り、デフォルトで&lt;code&gt;const&lt;/code&gt;メンバ関数として定義される&lt;/li&gt;
&lt;li&gt;非&lt;code&gt;virtual&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非&lt;code&gt;volatile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;インライン関数&lt;/li&gt;
&lt;li&gt;ラムダ式と同じパラメータリストの型、および戻り値の型を持つ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;キャプチャをしないラムダ式の場合、クロージャオブジェクトは、ラムダ式と同じシグニチャを持つ関数ポインタへの変換演算子を持つ&lt;/li&gt;
&lt;li&gt;クロージャオブジェクトのサイズは未規定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : 構文の解説を追加(#294)</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>28facc267fe41d8073154893f9fa0bbce52b0348:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-14 14:06:19 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトのキャプチャ方法はひとつしか指定できない。変数個別のキャプチャ方法は、カンマ区切りで複数指定できる。&lt;/p&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;h3&gt;構文&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;[キャプチャリスト](パラメータリスト) mutable 例外仕様 属性 -&amp;gt; 戻り値の型 { 関数の本体 }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このうち、以下は省略可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータがない場合は、パラメータリストおよびその丸カッコを省略できる&lt;/li&gt;
&lt;li&gt;キャプチャした変数を書き換える必要がない場合、&lt;code&gt;mutable&lt;/code&gt;を省略できる&lt;/li&gt;
&lt;li&gt;例外仕様を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;属性を指定しない場合、それを省略できる&lt;/li&gt;
&lt;li&gt;戻り値の型を推論に任せる場合、&lt;code&gt;-&amp;gt;&lt;/code&gt;記号および戻り値の型を省略できる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっとも短いラムダ式は、以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;[]{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このラムダ式は、なにもキャプチャせず、パラメータを受け取らず、なにも処理せず、戻り値の型が&lt;code&gt;void&lt;/code&gt;である関数オブジェクトを定義する。&lt;/p&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ラムダ式 -- C++11 ラムダ式 : 変数個別のキャプチャを、複数指定できることを明記</title>
      <link href="http://cpprefjp.github.io/lang/cpp11/lambda_expressions.html"/>
      <id>b28c5a845b45647d23604c0dd74498db537934b5:lang/cpp11/lambda_expressions.md</id>
      <updated>2015-12-11 14:31:07 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ラムダ式&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;ラムダ式(lambda expressions)は、簡易的な関数オブジェクトをその場で定義するための機能である。&lt;/p&gt;
&lt;p&gt;この機能によって、高階関数(関数を引数もしくは戻り値とする関数)をより使いやすくできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[](&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// result == 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;[](int a, int b) { return a + b; }&lt;/code&gt;というコードがラムダ式に当たる。このラムダ式は、「&lt;code&gt;int&lt;/code&gt;型のパラメータを2つとり、それらを足し合わせた&lt;code&gt;int&lt;/code&gt;型オブジェクトを返す関数オブジェクト」を定義している。ここでは戻り値の型を明記していないが、その場合はラムダ式のreturn文から、戻り値の型が推論される。&lt;/p&gt;
&lt;p&gt;このラムダ式によって、その場に以下のような関数オブジェクトが定義される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decltype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラムダ式によって自動的に定義される関数オブジェクトは、それぞれが一意な型名を持ち、その型名をユーザーが知る方法はない。そのため、ラムダ式によって定義された関数オブジェクトを変数に持つためには、&lt;code&gt;auto&lt;/code&gt;を使用して型推論するか、&lt;code&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスの変数に保持するかの、いずれかの方法をとることになる。&lt;/p&gt;
&lt;p&gt;ラムダ式からその外側の変数を使用するには、キャプチャ(capture)という機能を使用する。ラムダ式の先頭にある&lt;code&gt;[]&lt;/code&gt;はラムダ導入子(lambda-introducer)と呼ばれ、どの変数をどのようにキャプチャするかを、このラムダ導入子のなかで指定する。キャプチャの選択肢を、以下にまとめる：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キャプチャ記法&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで環境にある変数をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;を参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;変数&lt;code&gt;x&lt;/code&gt;をコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[&amp;amp;, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトで参照キャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[=, &amp;amp;x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトでコピーキャプチャ、変数&lt;code&gt;x&lt;/code&gt;のみ参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照して、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[this, x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*this&lt;/code&gt;のメンバを参照し、変数&lt;code&gt;x&lt;/code&gt;のみコピーして、ラムダ式のなかで使用する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトのキャプチャ方法はひとつしか指定できない。変数個別のキャプチャ方法は、カンマ区切りで複数指定できる。&lt;/p&gt;
&lt;p&gt;コピーキャプチャによる変数のコピーは、ラムダ式によって関数オブジェクトを定義した時点で行われる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;をキャプチャした場合、ラムダ式によって定義された関数オブジェクトは&lt;code&gt;this&lt;/code&gt;のクラスの&lt;code&gt;friend&lt;/code&gt;という扱いとなり、&lt;code&gt;private&lt;/code&gt;メンバにもアクセスできる。&lt;/p&gt;
&lt;p&gt;なお、静的な変数については、キャプチャする必要がない。&lt;/p&gt;
&lt;h2&gt;仕様&lt;/h2&gt;
&lt;p&gt;(執筆中)&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;出力&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf&#34; target=&#34;_blank&#34;&gt;N1958 A proposal to add lambda functions to the C++ standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&#34; target=&#34;_blank&#34;&gt;N1968 Lambda expressions and closures for C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2329.pdf&#34; target=&#34;_blank&#34;&gt;N2329 Lambda expressions and closures for C++ (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2413.pdf&#34; target=&#34;_blank&#34;&gt;N2413 Lambda Expressions and Closures: Wording for Monomorphic Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2487.pdf&#34; target=&#34;_blank&#34;&gt;N2487 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2510.pdf&#34; target=&#34;_blank&#34;&gt;N2510 BSI Position on Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2511.html&#34; target=&#34;_blank&#34;&gt;N2511 Named Lambdas and Local Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2529.pdf&#34; target=&#34;_blank&#34;&gt;N2529 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf&#34; target=&#34;_blank&#34;&gt;N2550 Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2651.pdf&#34; target=&#34;_blank&#34;&gt;N2651 Constness of Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf&#34; target=&#34;_blank&#34;&gt;N2658 Constness of Lambda Functions (Revision 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf&#34; target=&#34;_blank&#34;&gt;N2859 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2903.pdf&#34; target=&#34;_blank&#34;&gt;N2903 New wording for C++0x Lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&#34; target=&#34;_blank&#34;&gt;N2927 New wording for C++0x Lambdas (rev. 2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2957.html&#34; target=&#34;_blank&#34;&gt;N2957 Reaching Scope of Lambda Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3043.html&#34; target=&#34;_blank&#34;&gt;N3043 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html&#34; target=&#34;_blank&#34;&gt;N3052 Converting Lambdas to Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>