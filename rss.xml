<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-12-30T14:42:14.108941</updated>
  <id>bc60a34d-6b8a-42b5-ba75-353e8df5fe9b</id>

  
    <entry>
      <title>find_first_of -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>5da27f22d32b364123e51bf1fd0cec0a7a5e75a8:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2021-12-30T21:59:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index f6f9f3a71..328bf343a 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -18,7 +18,7 @@ namespace std::ranges {
 - input_iterator[link /reference/iterator/input_iterator.md]
 - forward_iterator[link /reference/iterator/forward_iterator.md]
 - sentinel_for[link /reference/iterator/sentinel_for.md]
-- ranges::equal_to[link /reference/algorithm/ranges_equal_to.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 - borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 - iterator_t[link /reference/ranges/iterator_t.md]
 - identity[link /reference/functional/identity.md]
@@ -94,7 +94,7 @@ inline constexpr find_first_of_impl find_first_of;
 - input_iterator[link /reference/iterator/input_iterator.md]
 - forward_iterator[link /reference/iterator/forward_iterator.md]
 - sentinel_for[link /reference/iterator/sentinel_for.md]
-- ranges::equal_to[link /reference/algorithm/ranges_equal_to.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 - borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 - iterator_t[link /reference/ranges/iterator_t.md]
 - identity[link /reference/functional/identity.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>4554454e93486c8b5d97d4a897b86861a6067bbe:reference/algorithm.md</id>
      <updated>2021-12-30T16:17:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 0c66010e4..e587845e4 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -127,15 +127,15 @@ ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 | [`ranges::find`](algorithm/ranges_find.md)                   | 指定された値を検索する                               | C++20 |
 | [`ranges::find_if`](algorithm/ranges_find_if.md)             | 条件を満たす最初の要素を検索する                     | C++20 |
 | [`ranges::find_if_not`](algorithm/ranges_find_if_not.md)     | 条件を満たしていない最初の要素を検索する             | C++20 |
-| [`ranges::find_end`](algorithm/ranges_find_end.md.nolink)           | 指定された最後のサブシーケンスを検索する             | C++20 |
-| [`ranges::find_first_of`](algorithm/ra.nolinknges_find_first_of.md.nolink) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
+| [`ranges::find_end`](algorithm/ranges_find_end.md)           | 指定された最後のサブシーケンスを検索する             | C++20 |
+| [`ranges::find_first_of`](algorithm/ranges_find_first_of.md) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
 | [`ranges::adjacent_find`](algorithm/ra.nolinknges_adjacent_find.md.nolink) | 隣接する要素で条件を満たしている最初の要素を検索する | C++20 |
 | [`ranges::count`](algorithm/ranges_count.md)                 | 指定された値である要素の数を数える                   | C++20 |
 | [`ranges::count_if`](algorithm/ranges_count_if.md)           | 条件を満たしている要素の数を数える                   | C++20 |
 | [`ranges::mismatch`](algorithm/ranges_mismatch.md.nolink)           | 2つの範囲が一致していない場所を検索する              | C++20 |
 | [`ranges::equal`](algorithm/ranges_equal.md.nolink)                 | 2つの範囲を等値比較する                              | C++20 |
-| [`ranges::search`](algorithm/ranges_search.md.nolink)               | 指定された最初のサブシーケンスを検索する             | C++20 |
-| [`ranges::search_n`](algorithm/ranges_search_n.md.nolink)           | 指定された最初のサブシーケンスを検索する             | C++20 |
+| [`ranges::search`](algorithm/ranges_search.md)               | 指定された最初のサブシーケンスを検索する             | C++20 |
+| [`ranges::search_n`](algorithm/ranges_search_n.md)           | 指定された最初のサブシーケンスを検索する             | C++20 |
 | [`ranges::starts_with`](algorithm/ranges_starts_with.md.nolink)     | 先頭が指定されたシーケンスと一致するかを調べる       | C++23 |
 | [`ranges::ends_with`](algorithm/ranges_ends_with.md.nolink)         | 末尾が指定されたシーケンスと一致するかを調べる       | C++23 |
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- ranges::find_first_of/find_end/search/search_nを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>1dc74c36e9f05e3f39d7f20f1ee1fd78014bdd1d:reference/algorithm/ranges_find_end.md</id>
      <updated>2021-12-30T15:58:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
new file mode 100644
index 000000000..ec3bc16d8
--- /dev/null
+++ b/reference/algorithm/ranges_find_end.md
@@ -0,0 +1,106 @@
+# find_end
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt; find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; find_end(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+}
+```
+
+## 概要
+範囲の中から、特定のサブシーケンスを検索する。
+
+
+## 戻り値
+- (1): `[first1,last1 - (last2 - first2))` 内のイテレータ `i` があるとき、0 以上 `last2 - first2` 未満の全ての整数 `n` について、それぞれ `*(i + n) == *(first2 + n)` もしくは `invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n)))) != false` であるようなサブシーケンスを探し、見つかった **最後の** サブシーケンス`{i, i + (i == last1 ? 0 : last2 - first2)}`を返す。そのようなイテレータが見つからない、もしくは `[first2,last2)` が空である場合は `{last1, last1}` を返す。
+- (2): `first1 = begin(r1)`, `last1 = end(r1)`, `first2 = begin(r2)`, `last2 = end(r2)`の下で(1)と等しい。
+
+## 計算量
+最大で `(last2 - first2) * (last1 - first1 - (last2 - first2) + 1)` 回の、対応する比較もしくは述語が適用される
+
+
+## 備考
+[`ranges::search()`](ranges_search.md) と `ranges::find_end()` は共にサブシーケンスを検索する関数だが、以下の点が異なる。
+
+* `ranges::search()` は見つかった最初のサブシーケンスを返すが `ranges::find_end()` は見つかった最後のサブシーケンスを返す
+* `[first2,last2)` が空であるときに `search()` は `{first1, first1}` を返すが、`ranges::find_end()` は `{last1, last1}` を返す
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;list&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 1,2,1,2,3 };
+  std::list&amp;lt;int&amp;gt; ls = { 1,2 };
+
+  // 1,2 と連続している最後のシーケンスを探す
+  subrange it = std::ranges::find_end(v, ls);
+  // v[2] の位置を指すイテレータが見つかる。
+  // v[0] の位置を指すイテレータではない。
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_end[color ff0000]
+
+### 出力
+```
+found: index==2
+```
+
+
+## 実装例
+```cpp
+struct find_end_impl {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    if (first2 == last2)
+      return last1;
+    I1 result = last1;
+    while ((first1 = search(first1, last1, first2, last2, ref(pred), ref(proj1), ref(proj2))) != last1) {
+      result = first1;
+      ++first1;
+    }
+    return result;
+  }
+
+  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
+
+inline constexpr find_end_impl find_end;
+```
+* search[link ranges_search.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- ranges::find_first_of/find_end/search/search_nを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>1dc74c36e9f05e3f39d7f20f1ee1fd78014bdd1d:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2021-12-30T15:58:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
new file mode 100644
index 000000000..f6f9f3a71
--- /dev/null
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -0,0 +1,121 @@
+# find_first_of
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; find_first_of(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+}
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/algorithm/ranges_equal_to.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- input_range[link /reference/ranges/input_range.md]
+- forward_range[link /reference/ranges/forward_range.md]
+
+## 概要
+ある集合の1つとマッチする最初の要素を検索する。
+
+
+## 戻り値
+`[first1,last1 - (last2 - first2))` 内のイテレータ `i` があるとき、`[first2,last2)` 内のイテレータ `j` について、どれかが [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj1, *i), `[`invoke`](/reference/functional/invoke.md)`(proj2, *j)) == true` であるような最初のイテレータを返す。
+
+そのようなイテレータが見つからない、もしくは `[first2,last2)` が空である場合は `last1` を返す。
+
+
+## 計算量
+最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;list&amp;gt;
+
+int main() {
+  std::vector v = { 1,3,7,4,2 };
+  std::list ls = { 2,4,6,8 };
+
+  // 2,4,6,8 のどれかと一致する最初の要素を返す
+  auto it = std::ranges::find_first_of(v, ls.begin(), ls.end());
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; &amp;#34;, value==&amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_first_of[color ff0000]
+* ls.begin()[link /reference/list/list/begin.md]
+* ls.end()[link /reference/list/list/end.md]
+
+### 出力
+```
+found: index==3, value==4
+```
+
+
+## 実装例
+```cpp
+struct find_first_of_impl {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    for ( ; first1 != last1; ++first1)
+      for (I2 it = first2; it != last2; ++it)
+        if (invoke(pred, invoke(proj1, *first1), invoke(proj2, *it))) return first1;
+    return last1;
+  }
+
+  template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; find_first_of(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
+
+inline constexpr find_first_of_impl find_first_of;
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/algorithm/ranges_equal_to.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- input_range[link /reference/ranges/input_range.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- ranges::find_first_of/find_end/search/search_nを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>1dc74c36e9f05e3f39d7f20f1ee1fd78014bdd1d:reference/algorithm/ranges_search.md</id>
      <updated>2021-12-30T15:58:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
new file mode 100644
index 000000000..28e53d54d
--- /dev/null
+++ b/reference/algorithm/ranges_search.md
@@ -0,0 +1,124 @@
+# search
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
+  sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt; search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; search(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});              // (2)
+}
+```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- subrange[link /reference/ranges/subrange.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+## 概要
+あるシーケンスの中から、特定のサブシーケンスを探す
+
+## 戻り値
+- (1) :
+    - `[first1,last1 - (last2 - first2))` 内のイテレータ `i` があるとき、0 以上 `last2 - first2` 未満の整数 `n` について、それぞれ [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj1, *(i + n)), `[`invoke`](/reference/functional/invoke.md)`(proj2, *(first2 + n)))` であるようなサブシーケンスを探し、見つかった最初のサブシーケンスを返す。
+    - そのようなイテレータが見つからない場合は `{last1, last1}` を返し、`[first2,last2)` が空である場合には `{first1, first1}` を返す。
+- (2): `first1 = begin(r1)`, `last1 = end(r1)`, `first2 = begin(r2)`, `last2 = end(r2)`の下で(1)と等しい。
+
+## 計算量
+最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;list&amp;gt;
+#include &amp;lt;ranges&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 1,2,1,2,3 };
+  std::list&amp;lt;int&amp;gt; ls = { 1,2 };
+
+  // 1,2 と連続している最初のシーケンスを探す
+  std::ranges::subrange sr = std::ranges::search(v, ls);
+  // v[0] の位置を指すイテレータが見つかる。
+  if (sr.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::search[color ff0000]
+
+#### 出力
+```
+found: index==0
+```
+
+
+## 実装例
+```cpp
+struct search_impl {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
+  sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt; search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    for ( ; first1 != last1; ++first1) {
+      I1 p1 = first1;
+      I2 p2 = first2;
+      while (true) {
+        if (p2 == last2) return {first1, p1};
+        if (p1 == last1) return {last1, last1};
+        if (!invoke(pred, invoke(proj1, *p1), invoke(proj2, *p2))) break;
+        ++p1, ++p2;
+      }
+    }
+  }
+
+  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; search(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
+
+inline constexpr search_impl search;
+```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- subrange[link /reference/ranges/subrange.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search_n -- ranges::find_first_of/find_end/search/search_nを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search_n.html"/>
      <id>1dc74c36e9f05e3f39d7f20f1ee1fd78014bdd1d:reference/algorithm/ranges_search_n.md</id>
      <updated>2021-12-30T15:58:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search_n.md b/reference/algorithm/ranges_search_n.md
new file mode 100644
index 000000000..72dd0b3e6
--- /dev/null
+++ b/reference/algorithm/ranges_search_n.md
@@ -0,0 +1,144 @@
+# search_n
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {]
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I, const T*, Pred, Proj&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; search_n(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T*, Pred, Proj&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; search_n(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {});
+}
+```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- iter_difference_t[link /reference/iterator/iter_difference_t.md]
+- subrange[link /reference/ranges/subrange.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+
+## 概要
+あるシーケンスの中から、指定の要素が連続するサブシーケンスを探す。
+
+## 戻り値
+`[first,last-count)` 内のイテレータ `i` があるとき、0 以上 `count` 未満の整数 `n` について、それぞれ [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *(i + n)), value)` であるようなサブシーケンスを探し、見つかった最初のサブシーケンスを返す。
+
+そのようなイテレータが見つからない場合は `{last, last}` を返す。
+
+
+## 計算量
+最大で `last - first` 回の対応する比較もしくは述語が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 1,2,3,2,1,3,3,2,3,3,1 };
+
+  // 3 が 2 つ連続している最初のシーケンスを探す
+  std::ranges::subrange sr1 = std::ranges::search_n(v, 2, 3);
+  // v[5] の位置を指すイテレータが見つかる。
+  if (sr1.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr1.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 3 未満が 2 つ連続している最初のシーケンスを探す
+  auto sr2 = std::ranges::search_n(v, 2, 3, [](int x, int y) { return x &amp;lt; y; });
+  // v[0] の位置を指すイテレータが見つかる。
+  if (sr2.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr2.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::search_n[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+### 出力
+```
+found: index==5
+found: index==0
+```
+
+
+## 実装例
+```cpp
+struct search_n_impl {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I, const T*, Pred, Proj&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; operator()(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) {
+    if (first == last || count &amp;lt;= 0)
+      return first;
+
+    while (first != last) {
+      if (*first == value) {
+        I it = first;
+        ++it;
+        iter_difference_t&amp;lt;I&amp;gt; i = 1;
+        for (; i &amp;lt; count &amp;amp;&amp;amp; it != last &amp;amp;&amp;amp; invoke(pred, invoke(proj, *it), value); ++i, ++it)
+          ;
+        if (i == count)
+          return {first, i};
+        else if (it == last)
+          return {last, last};
+        else
+          first = it;
+      }
+      ++first;
+    }
+  }
+
+  template&amp;lt;forward_range R, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T*, Pred, Proj&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) {
+    return (*this)(begin(r1), end(r1), count, value, ref(pred), ref(proj));
+  }
+};
+
+inline constexpr search_n_impl search_n;
+```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- iter_difference_t[link /reference/iterator/iter_difference_t.md]
+- subrange[link /reference/ranges/subrange.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>b792f48b9cc19c4cbe9725fc0f83c34ca795c424:reference/algorithm/ranges_count.md</id>
      <updated>2021-12-30T13:58:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index b0ff3b076..051f737c4 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -7,18 +7,20 @@
 ```cpp
 namespace std::ranges {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
   constexpr iter_difference_t&amp;lt;I&amp;gt; count(I first, S last, const T&amp;amp; value, Proj proj = {}); // (1)
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
   constexpr range_difference_t&amp;lt;R&amp;gt; count(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});          // (2)
 }
 ```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* input_range[link /reference/ranges/input_range.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
-* equal_to[link /reference/functional/equal_to.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 * projected[link /reference/iterator/projected.md]
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 * range_difference_t[link /reference/ranges/range_difference_t.md]
@@ -67,7 +69,7 @@ count of 1: 3
 ```cpp
 struct count_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
   constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
     iter_difference_t&amp;lt;I&amp;gt; count = 0;
     for ( ; first != last; ++first)
@@ -76,7 +78,7 @@ struct count_impl {
   }
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
   constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
     return (*this)(begin(r), end(r), value, ref(proj));
   }
@@ -84,10 +86,12 @@ struct count_impl {
 
 inline constexpr count_impl count;
 ```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* input_range[link /reference/ranges/input_range.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
-* equal_to[link /reference/functional/equal_to.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 * projected[link /reference/iterator/projected.md]
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 * range_difference_t[link /reference/ranges/range_difference_t.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>b792f48b9cc19c4cbe9725fc0f83c34ca795c424:reference/algorithm/ranges_count_if.md</id>
      <updated>2021-12-30T13:58:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 510639aec..b93b39613 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -13,6 +13,8 @@ namespace std::ranges {
   constexpr range_difference_t&amp;lt;R&amp;gt; count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});          // (2)
 }
 ```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* input_range[link /reference/ranges/input_range.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
@@ -83,6 +85,8 @@ struct count_if_impl {
 
 inline constexpr count_if_impl count_if;
 ```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* input_range[link /reference/ranges/input_range.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>b792f48b9cc19c4cbe9725fc0f83c34ca795c424:reference/algorithm/ranges_find.md</id>
      <updated>2021-12-30T13:58:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 1cf2408c7..0bf006583 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -7,11 +7,11 @@
 ```cpp
 namespace std::ranges {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
   constexpr I find(I first, S last, const T&amp;amp; value, Proj proj = {});
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
 }
 ```
@@ -21,7 +21,7 @@ namespace std::ranges {
 - iterator_t[link /reference/ranges/iterator_t.md]
 - identity[link /reference/functional/identity.md]
 - indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
-- equal_to[link /reference/functional/equal_to.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 - input_range[link /reference/ranges/input_range.md]
 - projected[link /reference/iterator/projected.md]
 
@@ -64,7 +64,7 @@ found: 1
 ```cpp
 struct find_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
   constexpr I operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
     for ( ; first != last; ++first)
       if (*first == value) return first;
@@ -72,7 +72,7 @@ struct find_impl {
   }
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
     return (*this)(begin(r), end(r), value, ref(proj));
   }
@@ -83,7 +83,7 @@ inline constexpr find_impl find;
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
-* equal_to[link /reference/functional/equal_to.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 * projected[link /reference/iterator/projected.md]
 * invoke[link /reference/functional/invoke.md]
 * begin[link /reference/ranges/begin.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>functional -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional.md b/reference/functional.md
index e3fd97465..8ac753e93 100644
--- a/reference/functional.md
+++ b/reference/functional.md
@@ -84,6 +84,12 @@ struct doubler {
 | [`less_equal`](functional/less_equal.md)       | 左辺が右辺以下かの比較(class template) | |
 | [`greater`](functional/greater.md)             | 左辺が右辺より大きいかの比較(class template) | |
 | [`greater_equal`](functional/greater_equal.md) | 左辺が右辺以上かの比較(class template) | |
+| [`ranges::equal_to`](functional/ranges_equal_to.md)           | 等値比較(class template)                     | C++20 |
+| [`ranges::not_equal_to`](functional/ranges_not_equal_to.md)   | 非等値比較(class template)                   | C++20 |
+| [`ranges::less`](functional/ranges_less.md)                   | 左辺が右辺より小さいかの比較(class template) | C++20 |
+| [`ranges::less_equal`](functional/ranges_less_equal.md)       | 左辺が右辺以下かの比較(class template)       | C++20 |
+| [`ranges::greater`](functional/ranges_greater.md)             | 左辺が右辺より大きいかの比較(class template) | C++20 |
+| [`ranges::greater_equal`](functional/ranges_greater_equal.md) | 左辺が右辺以上かの比較(class template)       | C++20 |
 
 
 ## 論理演算関数オブジェクト
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_to -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_equal_to.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_equal_to.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_equal_to.md b/reference/functional/ranges_equal_to.md
new file mode 100644
index 000000000..fba4e4737
--- /dev/null
+++ b/reference/functional/ranges_equal_to.md
@@ -0,0 +1,65 @@
+# equal_to
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct equal_to {
+    template&amp;lt;class T, class U&amp;gt;
+      requires equality_comparable_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
+
+## 概要
+`equal_to`クラスは、等値比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` が `==` および `!=` で同値比較可能、もしくは `declval&amp;lt;T&amp;gt;() == declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着すること。
+
+## 事前条件
+`declval&amp;lt;T&amp;gt;() == declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する場合、`T`および`U`からポインタへの変換は等しさを保持すること(equality-preserving)。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `x == y` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::equal_to&amp;lt;int&amp;gt;()(3, 3) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::equal_to[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>greater -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_greater.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_greater.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_greater.md b/reference/functional/ranges_greater.md
new file mode 100644
index 000000000..6abf76d46
--- /dev/null
+++ b/reference/functional/ranges_greater.md
@@ -0,0 +1,63 @@
+# greater
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct greater {
+    template&amp;lt;class T, class U&amp;gt;
+      requires totally_ordered_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* totally_ordered_with[link /reference/concepts/totally_ordered.md]
+
+## 概要
+`greater`クラスは、左辺が右辺より大きいかの比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` の間で`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`の演算子による比較が可能であり、その順序付けが全順序の要件を満たしている。
+* もしくは、 `declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | [`ranges::less`](ranges_less.md)`{}(std::forward&amp;lt;U&amp;gt;(u), std::forward&amp;lt;T&amp;gt;(t));` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 | C++20 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::greater&amp;lt;int&amp;gt;()(3, 2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::greater[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>greater_equal -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_greater_equal.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_greater_equal.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_greater_equal.md b/reference/functional/ranges_greater_equal.md
new file mode 100644
index 000000000..0a47d6eb4
--- /dev/null
+++ b/reference/functional/ranges_greater_equal.md
@@ -0,0 +1,63 @@
+# greater_equal
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct greater_equal {
+    template&amp;lt;class T, class U&amp;gt;
+      requires totally_ordered_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* totally_ordered_with[link /reference/concepts/totally_ordered.md]
+
+## 概要
+`greater_equal`クラスは、左辺が右辺以上かの比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` の間で`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`の演算子による比較が可能であり、その順序付けが全順序の要件を満たしている。
+* もしくは、 `declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `!`[`ranges::less`](ranges_less.md)`{}(std::forward&amp;lt;T&amp;gt;(t), std::forward&amp;lt;U&amp;gt;(u));` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 | C++20 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::greater_equal&amp;lt;int&amp;gt;()(3, 2) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::greater_equal[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>less -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_less.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_less.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_less.md b/reference/functional/ranges_less.md
new file mode 100644
index 000000000..7e3f6323f
--- /dev/null
+++ b/reference/functional/ranges_less.md
@@ -0,0 +1,66 @@
+# less
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct less {
+    template&amp;lt;class T, class U&amp;gt;
+      requires totally_ordered_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* totally_ordered_with[link /reference/concepts/totally_ordered.md]
+
+## 概要
+`less`クラスは、左辺が右辺より小さいかの比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` の間で`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`の演算子による比較が可能であり、その順序付けが全順序の要件を満たしている。
+* もしくは、 `declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する。
+
+## 事前条件
+`declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する場合、`T`および`U`からポインタへの変換は等しさを保持すること(equality-preserving)。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `&amp;lt;` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::less&amp;lt;int&amp;gt;()(2, 3) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::less[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>less_equal -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_less_equal.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_less_equal.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_less_equal.md b/reference/functional/ranges_less_equal.md
new file mode 100644
index 000000000..580cf3084
--- /dev/null
+++ b/reference/functional/ranges_less_equal.md
@@ -0,0 +1,63 @@
+# less_equal
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct less_equal {
+    template&amp;lt;class T, class U&amp;gt;
+      requires totally_ordered_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* totally_ordered_with[link /reference/concepts/totally_ordered.md]
+
+## 概要
+`less_equal`クラスは、左辺が右辺以下かの比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` の間で`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`の演算子による比較が可能であり、その順序付けが全順序の要件を満たしている。
+* もしくは、 `declval&amp;lt;T&amp;gt;() &amp;lt; declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着する。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `!`[`ranges::less`](ranges_less.md)`{}(std::forward&amp;lt;U&amp;gt;(u), std::forward&amp;lt;T&amp;gt;(t));` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::less_equal&amp;lt;int&amp;gt;()(2, 3) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::less_equal[color ff0000]
+
+### 出力
+```
+true
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>not_equal_to -- Concept-constrained comparisonsを追加</title>
      <link href="https://cpprefjp.github.io/reference/functional/ranges_not_equal_to.html"/>
      <id>89ee117c2d933a42699c0deb4ab3f7bf9cb5d77d:reference/functional/ranges_not_equal_to.md</id>
      <updated>2021-12-30T13:53:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/ranges_not_equal_to.md b/reference/functional/ranges_not_equal_to.md
new file mode 100644
index 000000000..b9ce3e099
--- /dev/null
+++ b/reference/functional/ranges_not_equal_to.md
@@ -0,0 +1,62 @@
+# not_equal_to
+* functional[meta header]
+* std::ranges[meta namespace]
+* class template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  struct not_equal_to {
+    template&amp;lt;class T, class U&amp;gt;
+      requires equality_comparable_with&amp;lt;T, U&amp;gt;
+    constexpr bool operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
+
+    using is_transparent = unspecified;
+  };
+}
+```
+* unspecified[italic]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
+
+## 概要
+`not_equal_to`クラスは、非等値比較を行う関数オブジェクトである。
+
+この関数オブジェクトは一切のメンバ変数を持たず、状態を保持しない。
+
+## テンプレートパラメータ制約
+* `T` と `U` が `==` および `!=` で同値比較可能、もしくは `declval&amp;lt;T&amp;gt;() == declval&amp;lt;U&amp;gt;()` がポインタ同士を比較する組み込みの演算に帰着すること。
+
+## メンバ関数
+
+| 名前 | 説明 |
+|---------------|-----------------|
+| `operator ()` | `!`[`ranges::equal_to`](ranges_equal_to.md)`{}(std::forward&amp;lt;T&amp;gt;(t), std::forward&amp;lt;U&amp;gt;(u));` と等価 |
+
+
+## メンバ型
+
+| 名前 | 説明 |
+|------------------------|-------------------------------|
+| `is_transparent`       | `operator()` が関数テンプレートである事を示すタグ型。&amp;lt;br/&amp;gt;実装依存の型であるがあくまでタグ型であり、型そのものには意味はない。 |
+
+
+## 例
+
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;functional&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; std::ranges::not_equal_to&amp;lt;int&amp;gt;()(3, 3) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::ranges::not_equal_to[color ff0000]
+
+### 出力
+```
+false
+```
+
+## 参照
+- [N4821 20.14.8 Concept-constrained comparisons](https://timsong-cpp.github.io/cppwp/n4861/range.cmp)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>