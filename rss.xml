<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-05-27T08:11:57.136195</updated>
  <id>c8595c11-94a9-4bcb-a257-00060664dd68</id>

  
    <entry>
      <title>find -- ranges::find : 射影変換の例を追加</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>0dfcb84d27bb4a6a4eed9c75a13522415335c80a:reference/algorithm/ranges_find.md</id>
      <updated>2025-05-27T17:08:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 7f76d5976..41dfe9d96 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -102,6 +102,62 @@ int main() {
 found: 1
 ```
 
+### 射影変換を使用した例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;string&amp;gt;
+
+struct Item {
+  int id;
+  std::string name;
+};
+
+int main() {
+  std::vector&amp;lt;Item&amp;gt; v = {
+    {1, &amp;#34;aaa&amp;#34;},
+	{3, &amp;#34;bbb&amp;#34;},
+	{5, &amp;#34;ccc&amp;#34;}
+  };
+
+  // メンバ変数ポインタを使って特定のメンバ変数で検索
+  {
+    auto it = std::ranges::find(
+      v,
+      std::string(&amp;#34;bbb&amp;#34;),
+      &amp;amp;Item::name
+    );
+    if (it == v.end()) {
+      std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+    } else {
+      std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; it-&amp;gt;name &amp;lt;&amp;lt; std::endl;
+    }
+  }
+
+  // ラムダ式で特定のメンバ変数を検索
+  {
+    auto it = std::ranges::find(
+      v,
+      std::string(&amp;#34;bbb&amp;#34;),
+      [](const Item&amp;amp; x) { return x.name; }
+    );
+    if (it == v.end()) {
+      std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+    } else {
+      std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;id &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; it-&amp;gt;name &amp;lt;&amp;lt; std::endl;
+    }
+  } 
+}
+```
+* std::ranges::find[color ff0000]
+
+#### 出力
+```
+found: 3,bbb
+found: 3,bbb
+```
+
 ### 波カッコ初期化を入力として使用する (C++26)
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>contains -- find_last, contains : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_contains.html"/>
      <id>1350ce71a23944efb2f73e7eabded20f52930d17:reference/algorithm/ranges_contains.md</id>
      <updated>2025-05-27T16:52:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_contains.md b/reference/algorithm/ranges_contains.md
index be782ad08..2f3e2ded3 100644
--- a/reference/algorithm/ranges_contains.md
+++ b/reference/algorithm/ranges_contains.md
@@ -6,16 +6,59 @@
 
 ```cpp
 namespace ranges {
-  // (1)
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
-    constexpr bool contains(I first, S last, const T&amp;amp; value, Proj proj = {});
-
-  // (2)
-  template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires
-      indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
-    constexpr bool contains(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(I first,
+             S last,
+             const T&amp;amp; value,
+             Proj proj = {}); // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T,
+            class Proj = identity&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (2) C++23
+  template &amp;lt;input_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr bool
+    contains(R&amp;amp;&amp;amp; r,
+             const T&amp;amp; value,
+             Proj proj = {}); // (2) C++26
 }
 ```
 
@@ -25,25 +68,72 @@ namespace ranges {
 - (1): イテレータ範囲を指定する
 - (2): Rangeを直接指定する
 
+
 ## 戻り値
 ```cpp
 ranges::find(std::move(first), last, value, proj) != last
 ```
 * ranges::find[link ranges_find.md]
 
+
 ## 計算量
 最大で `last - first` 回比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::ranges::contains(r, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;print&amp;gt;
 #include &amp;lt;array&amp;gt;
 
 int main() {
-  constexpr std::array v = { 3, 1, 4 };
-  if (std::ranges::contains(v, 1)) {
+  constexpr std::array ar = { 3, 1, 4 };
+  if (std::ranges::contains(ar, 1)) {
+    std::println(&amp;#34;found&amp;#34;);
+  } else {
+    std::println(&amp;#34;not found&amp;#34;);
+  }
+}
+```
+* std::ranges::contains[color ff0000]
+
+#### 出力
+```
+found
+```
+
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+	{1, 2},
+	{3, 4},
+	{5, 6}
+  };
+
+  bool found = std::ranges::contains(v, {3, 4});
+  if (found) {
     std::println(&amp;#34;found&amp;#34;);
   } else {
     std::println(&amp;#34;not found&amp;#34;);
@@ -52,7 +142,7 @@ int main() {
 ```
 * std::ranges::contains[color ff0000]
 
-### 出力
+#### 出力
 ```
 found
 ```
@@ -90,3 +180,5 @@ inline constexpr contains_impl contains;
 
 ## 参照
 - [N4950 27 Algorithms library](https://timsong-cpp.github.io/cppwp/n4950/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_last -- find_last, contains : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_last.html"/>
      <id>1350ce71a23944efb2f73e7eabded20f52930d17:reference/algorithm/ranges_find_last.md</id>
      <updated>2025-05-27T16:52:49+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_last.md b/reference/algorithm/ranges_find_last.md
index 47afea8da..a2c7878bc 100644
--- a/reference/algorithm/ranges_find_last.md
+++ b/reference/algorithm/ranges_find_last.md
@@ -10,21 +10,55 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr ranges::subrange&amp;lt;I&amp;gt;
     find_last(I first,
               S last,
               const T&amp;amp; value,
               Proj proj = {}); // (1) C++23
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;I, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr ranges::subrange&amp;lt;I&amp;gt;
+    find_last(I first,
+              S last,
+              const T&amp;amp; value,
+              Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
             class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
   constexpr ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
     find_last(R&amp;amp;&amp;amp; r,
               const T&amp;amp; value,
               Proj proj = {}); // (2) C++23
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt;
+    requires indirect_binary_predicate&amp;lt;
+               ranges::equal_to,
+               projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+               const T*
+             &amp;gt;
+  constexpr ranges::borrowed_subrange_t&amp;lt;R&amp;gt;
+    find_last(R&amp;amp;&amp;amp; r,
+              const T&amp;amp; value,
+              Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -50,31 +84,82 @@ namespace std::ranges {
 最大で `last - first` 回比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::ranges::find_last(r, {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;algorithm&amp;gt;
 #include &amp;lt;array&amp;gt;
 #include &amp;lt;iostream&amp;gt;
 
 int main() {
-  constexpr std::array v = { 3, 1, 4, 1, 5 };
-  const auto result = std::ranges::find_last(v, 1);
-  if (result.begin() == v.end()) {
+  constexpr std::array ar = { 3, 1, 4, 1, 5 };
+  const std::ranges::subrange result = std::ranges::find_last(ar, 1);
+  if (result.begin() == ar.end()) {
     std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
   } else {
     std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
-    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(ar.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
   }
 }
 ```
 * std::ranges::find_last[color ff0000]
 
-### 出力
+#### 出力
 ```
 found: 1
   pos: 3
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+};
+
+std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, const Point&amp;amp; p) {
+  return os &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#39;,&amp;#39; &amp;lt;&amp;lt; p.y;
+}
+
+int main() {
+  constexpr std::array&amp;lt;Point, 3&amp;gt; ar = {{
+    {1, 2},
+	{3, 4},
+	{5, 6}
+  }};
+
+  const std::ranges::subrange result = std::ranges::find_last(ar, {3, 4});
+  if (result.begin() == ar.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: &amp;#34; &amp;lt;&amp;lt; *result.begin() &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; &amp;#34;  pos: &amp;#34; &amp;lt;&amp;lt; std::distance(ar.begin(), result.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_last[color ff0000]
+
+#### 出力
+```
+found: 3,4
+  pos: 1
+```
+
 
 ## バージョン
 ### 言語
@@ -87,4 +172,8 @@ found: 1
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 ## 参照
-- [P1223R5 find_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P1223R5 `find_last`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1223r5.pdf)
+- [P3217R0 Adjoints to &amp;#34;Enabling list-initialization for algorithms&amp;#34;: `find_last`](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3217r0.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
+    - 関連文書：
+        - [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_left.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left.md b/reference/algorithm/ranges_fold_left.md
index 3477c8c6d..8c7651f38 100644
--- a/reference/algorithm/ranges_fold_left.md
+++ b/reference/algorithm/ranges_fold_left.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_left(I first, S last, T init, F f);       // (1)
-
-  template&amp;lt;input_range R, class T, 
-           indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_left(R&amp;amp;&amp;amp; r, T init, F f);                 // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(I first,
+              S last,
+              T init,
+              F f);   // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(I first,
+              S last,
+              T init,
+              F f);   // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T, 
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(R&amp;amp;&amp;amp; r,
+              T init,
+              F f);   // (2) C++23
+  template &amp;lt;input_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;, 
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left(R&amp;amp;&amp;amp; r,
+              T init,
+              F f);   // (2) C++26
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -116,19 +142,22 @@ concept indirectly-binary-left-foldable =
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
-
-この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
-
-```cpp
-using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, T, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
-```
-* decay_t[link /reference/type_traits/decay.md]
-* invoke_result_t[link /reference/type_traits/invoke_result.md]
-* iter_reference_t[link /reference/iterator/iter_reference_t.md]
-
-すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
-
-また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
+    ```cpp
+    using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, T, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
+    ```
+    * decay_t[link /reference/type_traits/decay.md]
+    * invoke_result_t[link /reference/type_traits/invoke_result.md]
+    * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+
+    - すなわち、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
+    - また、この型`U`は`fold_left`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        T sum = std::ranges::fold_left(v, {a, b}, op);
+        ```
 
 ## 例
 
@@ -172,7 +201,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 55
 1.125
@@ -217,12 +246,36 @@ int main() {
 * println[link /reference/print/println.md]
 * fold_right[link ranges_fold_right.md]
 
-### 出力
+#### 出力
 ```
 init -&amp;gt; a -&amp;gt; b -&amp;gt; c -&amp;gt; d -&amp;gt; e -&amp;gt; f
 init -&amp;gt; f -&amp;gt; e -&amp;gt; d -&amp;gt; c -&amp;gt; b -&amp;gt; a
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  int sum = std::ranges::fold_left(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{}&amp;#34;, sum);
+}
+```
+* std::ranges::fold_left[color ff0000]
+
+#### 出力
+```
+6
+```
+
 ## 実装例
 
 ```cpp
@@ -273,3 +326,5 @@ constexpr auto fold_left(I first, S last, T init, F f) {
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
 - [プログラミングHaskellのfoldr, foldlの説明が秀逸だった件 - あと味](https://taiju.hatenablog.com/entry/20130202/1359773888)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left_with_iter -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_with_iter.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_left_with_iter.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left_with_iter.md b/reference/algorithm/ranges_fold_left_with_iter.md
index a1e264bbc..1646732ec 100644
--- a/reference/algorithm/ranges_fold_left_with_iter.md
+++ b/reference/algorithm/ranges_fold_left_with_iter.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_left_with_iter(I first, S last, T init, F f); // (1)
-
-  template&amp;lt;input_range R, class T,
-           indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_left_with_iter(R&amp;amp;&amp;amp; r, T init, F f);           // (2)
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(I first,
+                        S last,
+                        T init,
+                        F f); // (1) C++23
+  template &amp;lt;input_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(I first,
+                        S last,
+                        T init,
+                        F f); // (1) C++26
+
+  template &amp;lt;input_range R,
+            class T,
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(R&amp;amp;&amp;amp; r,
+                        T init,
+                        F f); // (2) C++23
+  template &amp;lt;input_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;,
+            indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_left_with_iter(R&amp;amp;&amp;amp; r,
+                        T init,
+                        F f); // (2) C++26
 }
 ```
 * input_iterator[link /reference/iterator/input_iterator.md]
@@ -96,10 +122,15 @@ constexpr fold_left_with_iter_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, U&amp;gt;
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
+- 戻り値の項で使用している`U`は、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型であり、`fold_left_with_iter()`の処理内部で積算値の型として使用されるものでもある。
+- `fold_left`同様に、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto [end, sum] = std::ranges::fold_left_with_iter(v, {a, b}, op);
+        ```
 
-戻り値の項で使用している`U`は、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型であり、`fold_left_with_iter()`の処理内部で積算値の型として使用されるものでもある。
-
-`fold_left`同様に、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
 
 ## 例
 
@@ -141,7 +172,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 { true, 55 }
 { true, 1.125 }
@@ -178,7 +209,7 @@ int main() {
 * println[link /reference/print/println.md]
 * value_or[link /reference/optional/optional/value_or.md]
 
-### 出力
+#### 出力
 ```
 -1
 -1
@@ -222,13 +253,37 @@ int main() {
 * subrange[link /reference/ranges/subrange.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 
 ```
 sum = 36
 mul = 36288, 36288
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  auto [end, sum] = std::ranges::fold_left_with_iter(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{} {}&amp;#34;, end == v.end(), sum);
+}
+```
+* std::ranges::fold_left_with_iter[color ff0000]
+
+#### 出力
+```
+true 6
+```
+
 ## 実装例
 
 ```cpp
@@ -282,3 +337,5 @@ constexpr auto fold_left_with_iter(I first, S last, T init, F f) -&amp;gt; fold_left_wi
 ## 参照
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_right -- fold関係 : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.html"/>
      <id>18c5fd30b91a20479cf45076a4b48e3b59b7fd6e:reference/algorithm/ranges_fold_right.md</id>
      <updated>2025-05-27T16:36:03+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_right.md b/reference/algorithm/ranges_fold_right.md
index 96a13edc2..2c418690b 100644
--- a/reference/algorithm/ranges_fold_right.md
+++ b/reference/algorithm/ranges_fold_right.md
@@ -6,13 +6,39 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;bidirectional_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
-           indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
-  constexpr auto fold_right(I first, S last, T init, F f);       // (1)
-
-  template&amp;lt;bidirectional_range R, class T,
-           indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
-  constexpr auto fold_right(R&amp;amp;&amp;amp; r, T init, F f);                 // (2)
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(I first,
+               S last,
+               T init,
+               F f);    // (1) C++23
+  template &amp;lt;bidirectional_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T = iter_value_t&amp;lt;I&amp;gt;,
+            indirectly-binary-right-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(I first,
+               S last,
+               T init,
+               F f);    // (1) C++23
+
+  template &amp;lt;bidirectional_range R,
+            class T,
+            indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(R&amp;amp;&amp;amp; r,
+               T init,
+               F f);    // (2) C++23
+  template &amp;lt;bidirectional_range R,
+            class T = range_value_t&amp;lt;R&amp;gt;,
+            indirectly-binary-right-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto
+    fold_right(R&amp;amp;&amp;amp; r,
+               T init,
+               F f);    // (2) C++26
 }
 ```
 * bidirectional_iterator[link /reference/iterator/bidirectional_iterator.md]
@@ -113,19 +139,23 @@ return accum;
 入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
 
 ## 備考
+- この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
+    ```cpp
+    using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, iter_reference_t&amp;lt;I&amp;gt;, T&amp;gt;&amp;gt;;
+    ```
+    * decay_t[link /reference/type_traits/decay.md]
+    * invoke_result_t[link /reference/type_traits/invoke_result.md]
+    * iter_reference_t[link /reference/iterator/iter_reference_t.md]
+
+    - すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
+    - また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        T sum = std::ranges::fold_right(v, {a, b}, op);
+        ```
 
-この関数の戻り値型は、入力の型`F, T, I`から次のような`U`として取得される
-
-```cpp
-using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, iter_reference_t&amp;lt;I&amp;gt;, T&amp;gt;&amp;gt;;
-```
-* decay_t[link /reference/type_traits/decay.md]
-* invoke_result_t[link /reference/type_traits/invoke_result.md]
-* iter_reference_t[link /reference/iterator/iter_reference_t.md]
-
-すなわち、指定した二項演算をイテレータと初期値によって`f(*first, std::move(init))`のように呼び出した時の戻り値型がこの関数の戻り値型となる。
-
-また、この型`U`は`fold_right`の処理内部で積算値の型として使用されるものでもあり、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数にイテレータの間接参照結果が直接渡され、第二引数に初期値もしくは積算値が渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
 
 ## 例
 
@@ -170,7 +200,7 @@ int main() {
 * plus[link /reference/functional/plus.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 55
 1.125
@@ -217,7 +247,7 @@ int main() {
 * println[link /reference/print/println.md]
 * fold_left[link /reference/algorithm/ranges_fold_left.md]
 
-### 出力
+#### 出力
 ```
 init -&amp;gt; a -&amp;gt; b -&amp;gt; c -&amp;gt; d -&amp;gt; e -&amp;gt; f
 init -&amp;gt; f -&amp;gt; e -&amp;gt; d -&amp;gt; c -&amp;gt; b -&amp;gt; a
@@ -255,11 +285,35 @@ int main() {
 * iota[link /reference/ranges/iota_view.md]
 * println[link /reference/print/println.md]
 
-### 出力
+#### 出力
 ```
 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = {1, 2, 3};
+
+  int sum = std::ranges::fold_right(
+    v,
+    {},
+    [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b) { return a + b; }
+  );
+  std::println(&amp;#34;{}&amp;#34;, sum);
+}
+```
+* std::ranges::fold_right[color ff0000]
+
+#### 出力
+```
+6
+```
+
 ## 実装例
 
 ```cpp
@@ -309,3 +363,5 @@ constexpr auto fold_right(I first, S last, T init, F f) {
 
 - [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
 - [プログラミングHaskellのfoldr, foldlの説明が秀逸だった件 - あと味](https://taiju.hatenablog.com/entry/20130202/1359773888)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- binary_search : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/binary_search.html"/>
      <id>93b8c47923f9c1090573b00a071cad863607d0a1:reference/algorithm/binary_search.md</id>
      <updated>2025-05-27T15:06:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/binary_search.md b/reference/algorithm/binary_search.md
index 342f67c3d..a1c10635e 100644
--- a/reference/algorithm/binary_search.md
+++ b/reference/algorithm/binary_search.md
@@ -5,27 +5,35 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
-  bool binary_search(ForwardIterator first,
-                     ForwardIterator last,
-                     const T&amp;amp; value);                 // (1) C++03
-
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
-  constexpr bool binary_search(ForwardIterator first,
-                               ForwardIterator last,
-                               const T&amp;amp; value);       // (1) C++20
-
-  template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
-  bool binary_search(ForwardIterator first,
-                     ForwardIterator last,
-                     const T&amp;amp; value,
-                     Compare comp);                   // (2) C++03
-
-  template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
-  constexpr bool binary_search(ForwardIterator first,
-                               ForwardIterator last,
-                               const T&amp;amp; value,
-                               Compare comp);         // (2) C++20
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
+  bool
+    binary_search(ForwardIterator first,
+                  ForwardIterator last,
+                  const T&amp;amp; value);       // (1) C++03
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
+  constexpr bool
+    binary_search(ForwardIterator first,
+                  ForwardIterator last,
+                  const T&amp;amp; value);       // (1) C++20
+
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
+  bool
+    binary_search(ForwardIterator first,
+                  ForwardIterator last,
+                  const T&amp;amp; value,
+                  Compare comp);         // (2) C++03
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
+  constexpr bool
+    binary_search(ForwardIterator first,
+                  ForwardIterator last,
+                  const T&amp;amp; value,
+                  Compare comp);         // (2) C++20
 }
 ```
 
@@ -49,9 +57,16 @@ namespace std {
 
 ## 備考
 - `comp` は 2 引数の関数オブジェクトで、1 番目の引数が 2 番目の引数「より小さい」場合に `true` を、そうでない場合に `false` を返すものとして扱われる。
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::binary_search(v.begin(), v.end(), {a, b});
+        ```
 
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -74,6 +89,44 @@ int main()
 ```
 * std::binary_search[color ff0000]
 
+#### 出力
+```
+found
+```
+
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}を二分検索
+  bool found = std::binary_search(v.begin(), v.end(), {3, 4});
+  if (found) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::binary_search[color ff0000]
+
 ### 出力
 ```
 found
@@ -114,3 +167,5 @@ bool binary_search(ForwardIterator first, ForwardIterator last,
 - [LWG Issue 787. complexity of `binary_search`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787)
     - C++03までの計算量が間違っていたので、C++11で修正。
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- binary_search : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_binary_search.html"/>
      <id>93b8c47923f9c1090573b00a071cad863607d0a1:reference/algorithm/ranges_binary_search.md</id>
      <updated>2025-05-27T15:06:45+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_binary_search.md b/reference/algorithm/ranges_binary_search.md
index 54df91313..7c950f41a 100644
--- a/reference/algorithm/ranges_binary_search.md
+++ b/reference/algorithm/ranges_binary_search.md
@@ -10,13 +10,30 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr bool
     binary_search(I first,
                   S last,
                   const T&amp;amp; value,
                   Comp comp = {},
                   Proj proj = {}); // (1) C++20
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    binary_search(I first,
+                  S last,
+                  const T&amp;amp; value,
+                  Comp comp = {},
+                  Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
@@ -30,6 +47,18 @@ namespace std::ranges {
                   const T&amp;amp; value,
                   Comp comp = {},
                   Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    binary_search(R&amp;amp;&amp;amp; r,
+                  const T&amp;amp; value,
+                  Comp comp = {},
+                  Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -65,9 +94,15 @@ namespace std::ranges {
 
 ## 備考
 - `comp` は 2 引数の関数オブジェクトで、1 番目の引数が 2 番目の引数「より小さい」場合に `true` を、そうでない場合に `false` を返すものとして扱われる。
-
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        bool found = std::ranges::binary_search(v, {a, b});
+        ```
 
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -90,6 +125,44 @@ int main()
 ```
 * std::ranges::binary_search[color ff0000]
 
+#### 出力
+```
+found
+```
+
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}を二分検索
+  bool found = std::ranges::binary_search(v, {3, 4});
+  if (found) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+  else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::binary_search[color ff0000]
+
 ### 出力
 ```
 found
@@ -107,3 +180,5 @@ found
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- equal_range : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/equal_range.html"/>
      <id>1a1278ca88432498e33f6f87618e96f03a99c948:reference/algorithm/equal_range.md</id>
      <updated>2025-05-27T14:53:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/equal_range.md b/reference/algorithm/equal_range.md
index 9e1add89e..63b841b0f 100644
--- a/reference/algorithm/equal_range.md
+++ b/reference/algorithm/equal_range.md
@@ -5,31 +5,49 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
     equal_range(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);      // (1) C++03
-
-  template &amp;lt;class ForwardIterator, class T&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T&amp;gt;
   constexpr pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
     equal_range(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value);      // (1) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type&amp;gt;
+  constexpr pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
+    equal_range(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value);      // (1) C++26
 
-  template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
     equal_range(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);        // (2) C++03
-
-  template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt;
+  template &amp;lt;class ForwardIterator,
+            class T,
+            class Compare&amp;gt;
   constexpr pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
     equal_range(ForwardIterator first,
                 ForwardIterator last,
                 const T&amp;amp; value,
                 Compare comp);        // (2) C++20
+  template &amp;lt;class ForwardIterator,
+            class T = typename iterator_traits&amp;lt;ForwardIterator&amp;gt;::value_type,
+            class Compare&amp;gt;
+  constexpr pair&amp;lt;ForwardIterator, ForwardIterator&amp;gt;
+    equal_range(ForwardIterator first,
+                ForwardIterator last,
+                const T&amp;amp; value,
+                Compare comp);        // (2) C++26
 }
 ```
 * pair[link /reference/utility/pair.md]
@@ -54,7 +72,17 @@ namespace std {
 最大で 2 * log2(`last - first`) + O(1) 回の比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto result = std::equal_range(v.begin(), v.end(), {a, b});
+        ```
+
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -75,13 +103,53 @@ int main()
 ```
 * equal_range[color ff0000]
 
-### 出力
+#### 出力
 ```
 3
 4
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}が見つかる範囲を取得
+  auto result = std::equal_range(v.begin(), v.end(), {3, 4});
+
+  while (result.first != result.second) {
+    std::cout &amp;lt;&amp;lt; result.first-&amp;gt;x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; result.first-&amp;gt;y &amp;lt;&amp;lt; std::endl;
+    ++result.first;
+  }
+}
+```
+* std::equal_range[color ff0000]
+
+#### 出力
+```
+3,4
+3,4
+```
 
 ## 参照
 - [LWG Issue 384. `equal_range` has unimplementable runtime complexity](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384)
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal_range -- equal_range : C++26波カッコ初期化に対応 #1311</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal_range.html"/>
      <id>1a1278ca88432498e33f6f87618e96f03a99c948:reference/algorithm/ranges_equal_range.md</id>
      <updated>2025-05-27T14:53:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal_range.md b/reference/algorithm/ranges_equal_range.md
index a580318ff..225f563da 100644
--- a/reference/algorithm/ranges_equal_range.md
+++ b/reference/algorithm/ranges_equal_range.md
@@ -10,23 +10,55 @@ namespace std::ranges {
             sentinel_for&amp;lt;I&amp;gt; S,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr subrange&amp;lt;I&amp;gt;
     equal_range(I first,
                 S last,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (1) C++20
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;I, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;I, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt;
+    equal_range(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++26
 
   template &amp;lt;forward_range R,
             class T,
             class Proj = identity,
-            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
   constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
     equal_range(R&amp;amp;&amp;amp; r,
                 const T&amp;amp; value,
                 Comp comp = {},
                 Proj proj = {}); // (2) C++20
+  template &amp;lt;forward_range R,
+            class Proj = identity,
+            class T = projected_value_t&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt;
+    equal_range(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++26
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -57,11 +89,21 @@ namespace std::ranges {
 ## 戻り値
 `{`[`ranges::lower_bound`](ranges_lower_bound.md)`(first, last, value, comp, proj), `[`ranges::upper_bound`](ranges_upper_bound.md)`(first, last, value, comp, proj)}`
 
+
 ## 計算量
 最大で 2 * log2(`last - first`) + O(1) 回の比較を行う
 
 
+## 備考
+- (1), (2) :
+    - C++26 : 引数として波カッコ初期化`{}`を受け付ける
+        ```cpp
+        std::vector&amp;lt;T&amp;gt; v;
+        auto result = std::ranges::equal_range(v, {a, b});
+        ```
+
 ## 例
+### 基本的な使い方
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;vector&amp;gt;
@@ -93,7 +135,7 @@ int main()
 * std::ranges::sort[link ranges_sort.md]
 * std::ranges::equal_range[color ff0000]
 
-### 出力
+#### 出力
 ```
 size: 2
 3
@@ -102,6 +144,44 @@ size: 2
 size: 0
 ```
 
+### 波カッコ初期化を入力として使用する (C++26)
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+struct Point {
+  int x;
+  int y;
+
+  bool operator==(const Point&amp;amp; other) const = default;
+  auto operator&amp;lt;=&amp;gt;(const Point&amp;amp; other) const = default;
+};
+
+int main() {
+  std::vector&amp;lt;Point&amp;gt; v = {
+    {1, 2},
+    {3, 4},
+    {3, 4},
+    {5, 6},
+  };
+
+  // 値{3, 4}が見つかる範囲を取得
+  auto result = std::ranges::equal_range(v, {3, 4});
+
+  for (const Point&amp;amp; p : result) {
+    std::cout &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; p.y &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::equal_range[color ff0000]
+
+#### 出力
+```
+3,4
+3,4
+```
+
 ## バージョン
 ### 言語
 - C++20
@@ -114,3 +194,5 @@ size: 0
 
 ## 参照
 - [N4861 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
+- [P2248R8 Enabling list-initialization for algorithms](https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2248r8.html)
+    - C++26で波カッコ初期化 (リスト初期化) に対応した
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>