<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2024-02-06T07:27:22.777927</updated>
  <id>6c23fc2a-24c8-457e-8fba-f62807e5e4f4</id>

  
    <entry>
      <title>fold_left_with_iter -- タイトル修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_with_iter.html"/>
      <id>e49fbcde3004f58406691422d24faca22abad380:reference/algorithm/ranges_fold_left_with_iter.md</id>
      <updated>2024-02-06T16:23:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left_with_iter.md b/reference/algorithm/ranges_fold_left_with_iter.md
index f12e692ac..8ad351294 100644
--- a/reference/algorithm/ranges_fold_left_with_iter.md
+++ b/reference/algorithm/ranges_fold_left_with_iter.md
@@ -1,4 +1,4 @@
-# fold_left_first
+# fold_left_with_iter
 * algorithm[meta header]
 * function template[meta id-type]
 * std::ranges[meta namespace]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left_first -- コード修飾の修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_with_iter.html"/>
      <id>379e1b05ec7f555ea67fc7e36918b526f295f11f:reference/algorithm/ranges_fold_left_with_iter.md</id>
      <updated>2024-02-06T16:18:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left_with_iter.md b/reference/algorithm/ranges_fold_left_with_iter.md
index f582a3bf1..f12e692ac 100644
--- a/reference/algorithm/ranges_fold_left_with_iter.md
+++ b/reference/algorithm/ranges_fold_left_with_iter.md
@@ -63,10 +63,6 @@ for (++first; first != last; ++first)
   accum = invoke(f, std::move(accum), *first);
 return {std::move(first), std::move(accum)};
 ```
-* decay_t[link /reference/type_traits/decay.md]
-* invoke_result_t[link /reference/type_traits/invoke_result.md]
-* iter_reference_t[link /reference/iterator/iter_reference_t.md]
-* next[link /reference/iterator/ranges_next.md]
 * invoke[link /reference/functional/invoke.md]
 
 空の入力範囲に対しては初期値`init`を返す。入力範囲によらず、戻り値の1つ目の値（イテレータ値）は渡した範囲の終端イテレータ（`last`/`ranges::end(r)`）と同じ位置を指すイテレータとなる（必ずしも同じ型もしくは同じイテレータにならない）。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++23 -- fold_left_with_iter追加 #1088</title>
      <link href="https://cpprefjp.github.io/lang/cpp23.html"/>
      <id>f222955da68c8794948d82cf78c3e78d006359f2:lang/cpp23.md</id>
      <updated>2024-02-06T16:15:39+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++23&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++23とは、2023年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中のためC++2bと呼ばれることがある。「(C++20である2020年の次の) 202b年にリリースされる」という伏せ字として「b」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/literal_suffix_for_signed_size_t.html&#34;&gt;(符号付き)&lt;code&gt;size_t&lt;/code&gt;リテラルのためのサフィックス&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;42z&lt;/code&gt;/&lt;code&gt;42Z&lt;/code&gt;とすることで&lt;code&gt;size_t&lt;/code&gt;に対応する符号付き整数型のリテラルとする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/simpler_implicit_move.md.nolink&#34;&gt;暗黙的なムーブを簡略化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;参照を返す関数の&lt;code&gt;return&lt;/code&gt;文で暗黙的にムーブされない問題を修正&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;これらに加えて、ライブラリ機能として拡張浮動小数点数型が定義された。&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdfloat.html&#34;&gt;&amp;lt;stdfloat&amp;gt;&lt;/a&gt;&lt;/code&gt;を参照。&lt;/p&gt;
&lt;h3&gt;関数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/declarations_and_where_to_find_them.md.nolink&#34;&gt;スコープと名前ルックアップの仕様整理&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;複雑で不完全になっているスコープと名前ルックアップの仕様を整理し、一部の問題を解決する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/meaningful_exports.md.nolink&#34;&gt;無意味なexport宣言を禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;制御構文&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/extend_init_statement_to_allow_alias_declaration.html&#34;&gt;初期化文での型の別名宣言を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;for (using T = int; T e : v) {}&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/lifetime_extension_in_range_based_for_loop.html&#34;&gt;範囲for文が範囲初期化子内で生じた一時オブジェクトを延命することを規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;範囲初期化子内で生じた一時オブジェクトは範囲for文の終わりまで延命される&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/labels_at_the_end_of_compound_statements.html&#34;&gt;複合文の末尾へのラベルを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C互換のため、複合文の末尾でのgoto文のラベルを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/deducing_this.md.nolink&#34;&gt;自身のオブジェクトを明示的にパラメータとして指定する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ関数が&lt;code&gt;*this&lt;/code&gt;の型・オブジェクトをパラメータとしてとり、&lt;code&gt;*this&lt;/code&gt;オブジェクトがconst/非const、左辺値/右辺値であるかをメンバ関数内で識別できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/make_declaration_order_layout_mandated.html&#34;&gt;アクセス制御の異なるメンバ変数のレイアウトを宣言順に規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;アクセス制御の異なるメンバ変数のレイアウトは並び替えを許可されていたが宣言順に規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/multidimensional_subscript_operator.nd.nolink&#34;&gt;添字演算子の多次元サポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator[](int x, int y, int z)&lt;/code&gt;のように添字演算子のオーバーロードで複数のパラメータをとることを許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/static_operator.html&#34;&gt;&lt;code&gt;this&lt;/code&gt;ポインタをもつ必要のない演算子を&lt;code&gt;static&lt;/code&gt;として宣言できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;状態をもたないいくつかの演算子を&lt;code&gt;static&lt;/code&gt;として宣言できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/mixed_string_literal_concatenation.html&#34;&gt;異なる文字エンコーディングをもつ文字列リテラルの連結を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto a = u8&#34;&#34; L&#34;&#34;;&lt;/code&gt;のような異なる文字エンコーディング同士での文字列リテラルを連結を禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/delimited_escape_sequences.html&#34;&gt;エスケープシーケンスの区切り&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エスケープシーケンスの範囲を明確にする構文を追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/numeric_and_universal_character_escapes_in_character_and_string_literals.md.nolink&#34;&gt;文字・文字列リテラル中の数値・ユニバーサルキャラクタのエスケープに関する問題解決&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/remove_non_encodable_wide_character_literals_and_multicharacter_wide_character_literals.html&#34;&gt;1ワイド文字に収まらないワイド文字リテラルを禁止する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;エンコード結果として&lt;code&gt;wchar_t&lt;/code&gt;の大きさに収まらないワイド文字リテラルを禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/named_universal_character_escapes.html&#34;&gt;名前付きユニバーサルキャラクタ名&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;16進数のユニバーサルキャラクタだけでなく、その文字の名前を入力できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/generalized_wording_for_partial_specializations.md.nolink&#34;&gt;部分特殊化の汎用化仕様&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数テンプレートの部分特殊化を許可するために部分特殊化の仕様を汎用化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/class_template_argument_deduction_from_inherited.md.nolink&#34;&gt;継承コンストラクタからのクラステンプレート引数の推論&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/if_consteval.md.nolink&#34;&gt;if consteval&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時の文脈かどうかで分岐させる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/narrowing_contextual_conversions_to_bool.md.nolink&#34;&gt;定数式の文脈での&lt;code&gt;bool&lt;/code&gt;への縮小変換を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if constexpr(flags &amp;amp; Flags::Exec)&lt;/code&gt;や&lt;code&gt;static_assert(N);&lt;/code&gt;を許可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/non_literal_variables_in_constexpr_functions.html&#34;&gt;定数式内での非リテラル変数、静的変数・スレッドローカル変数およびgotoとラベルの存在を許可する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に評価されない限り、定数式内に静的変数・スレッドローカル変数およびgoto文とラベルを含むことを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/character_encoding_of_diagnostic_text.html&#34;&gt;静的な診断メッセージの文字エンコーディング&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static_assert&lt;/code&gt;や&lt;code&gt;[[deprecated]]&lt;/code&gt;などの診断メッセージの文字集合に関する要件をなくす&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/relaxing_some_constexpr_restrictions.html&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;関数が定数実行できない場合でも適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定数式実行できない関数であっても、実際にコンパイル時に評価されない限り&lt;code&gt;constexpr&lt;/code&gt;指定することを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/permitting_static_constexpr_variables_in_constexpr_functions.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;関数内での&lt;code&gt;static constexpr&lt;/code&gt;変数を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/consteval_needs_to_propagate_up.md.nolink&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt;関数内で&lt;code&gt;consteval&lt;/code&gt;関数を呼び出せない問題を緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ラムダ式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/down_with_lambda_parens.html&#34;&gt;ラムダ式で&lt;code&gt;()&lt;/code&gt;を省略できる条件を緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;修飾や戻り値型をともなってもパラメータリストが空であれば&lt;code&gt;()&lt;/code&gt;を省略できる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/attributes_on_lambda_expressions.html&#34;&gt;ラムダ式に対する属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式のいくつかの箇所に属性を記述できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;属性&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/portable_assumptions.html&#34;&gt;コード内容の仮定をコンパイラに伝えるassume属性&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;最適化のために、コードの仮定をコンパイラに伝える属性を標準化する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;プリプロセッサ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/consistent_character_literal_encoding.html&#34;&gt;文字リテラルエンコーディングを一貫させる&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;プリプロセッサの条件式での文字リテラルの扱いをC++式と同様にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/add_support_for_preprocessing_directives_elifdef_and_elifndef.md.nolink&#34;&gt;&lt;code&gt;elif&lt;/code&gt;/&lt;code&gt;elifdef&lt;/code&gt;/&lt;code&gt;elifndef&lt;/code&gt;のサポートを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;#if&lt;/code&gt;/&lt;code&gt;#ifdef&lt;/code&gt;/&lt;code&gt;#ifndef&lt;/code&gt;に対応する複数条件命令のサポートを追加する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/warning.html&#34;&gt;&lt;code&gt;#warning&lt;/code&gt;のサポートを追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;多くのC++コンパイラが実装していたプリプロセス時の警告&lt;code&gt;#warning message&lt;/code&gt;を正式サポート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/support_for_utf8_as_a_portable_source_file_encoding.md.nolink&#34;&gt;汎用的なソースコードのエンコーディングとしてUTF-8をサポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/update_normative_reference_to_posix.html&#34;&gt;参照するPOSIX規格を更新&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;新しいPOSIX規格の機能を標準C++が参照していたため、参照するPOSIX規格のバージョンを更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/trimming_whitespaces_before_line_splicing.md.nolink&#34;&gt;行末スペースを無視するよう規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;行末が「&lt;code&gt;\ &lt;/code&gt;」でおわっていた場合にMSVCは行の継続をしない実装になっていたため動作を共通化するため仕様を規定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++標準ライブラリ全体のモジュールとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/module/std.html&#34;&gt;std&lt;/a&gt;&lt;/code&gt;、C互換ライブラリ全体のモジュールとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/module/std.compat.html&#34;&gt;std.compat&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スタックトレースを取得するためのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stacktrace.html&#34;&gt;&amp;lt;stacktrace&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;CとC++の間でのアトミック操作の相互運用のため、C互換ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdatomic.h.html&#34;&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;外部から提供されるメモリバッファでストリーム処理を行うライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/spanstream.md.nolink&#34;&gt;&amp;lt;spanstream&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;正常値とエラー値のどちらかを持つクラスおよびライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/expected.html&#34;&gt;&amp;lt;expected&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;多次元配列ビューのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan.html&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ノードベースではないソート済みキーによる順序付き連想コンテナのライブラリとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/flat_map.html&#34;&gt;&amp;lt;flat_map&amp;gt;&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/flat_set.md.nolink&#34;&gt;&amp;lt;flat_set&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;書式指定で出力するライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/print.html&#34;&gt;&amp;lt;print&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;コルーチンによるRangeの生成をサポートする&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/generator.html&#34;&gt;&amp;lt;generator&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;拡張浮動小数点数のライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdfloat.html&#34;&gt;&amp;lt;stdfloat&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stack/stack.html&#34;&gt;std::stack&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/queue/queue.html&#34;&gt;std::queue&lt;/a&gt;&lt;/code&gt;に、イテレータのペアをとるコンストラクタを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto v = std::vector(v, alloc);&lt;/code&gt;のようなアロケータ引数をともなう場合のクラステンプレートのテンプレート引数推論が動作しなかったため、各コンテナクラスのコンストラクタにおけるアロケータパラメータの型を&lt;code&gt;const Allocator&amp;amp;&lt;/code&gt;から&lt;code&gt;const &lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/type_identity.html&#34;&gt;std::type_identity_t&lt;/a&gt;&amp;lt;Allocator&amp;gt;&amp;amp;&lt;/code&gt;に修正&lt;/li&gt;
&lt;li&gt;N要素のメモリアロケート時にアロケータが実際にどれくらいのメモリを確保したかを得られるインタフェースとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;クラスに、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator/allocate_at_least.md.nolink&#34;&gt;allocate_at_least()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;の転送コンストラクタにデフォルトテンプレート引数を追加することで、&lt;code&gt;{}&lt;/code&gt;のような型推論ができない引数を渡した場合でも完全転送が行われるよう修正&lt;/li&gt;
&lt;li&gt;順序付き連想コンテナの要素削除の処理について、一時オブジェクトのコストを抑える拡張が行われた&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/erase.html&#34;&gt;std::map::erase()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/extract.html&#34;&gt;std::map::extract()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、複数の範囲を綴じ合わせる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/zip_view.md.nolink&#34;&gt;std::views::zip&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、複数の範囲の直積をとる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/cartesian_product_view.md.nolink&#34;&gt;std::views::cartesian_product&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;Rangeから任意のコンテナに変換するRangeアダプタ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/to.md.nolink&#34;&gt;std::ranges::to()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;Rangeから任意のコンテナに変換するために、可変長のコンテナ (&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;以外) に、以下の機能を追加：&lt;ul&gt;
&lt;li&gt;Rangeから変換するコンストラクタ&lt;/li&gt;
&lt;li&gt;Rangeを挿入する&lt;code&gt;insert_range()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;Rangeを先頭に追加する&lt;code&gt;prepend_range()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;Rangeを末尾に追加する&lt;code&gt;append_range()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;li&gt;Rangeを代入する&lt;code&gt;assign_range()&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ユーザー定義のRangeアダプタがパイプライン演算子 &lt;code&gt;|&lt;/code&gt; をサポートしやすくするために、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/range_adaptor_closure.md.nolink&#34;&gt;std::ranges::range_adaptor_closure&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Rangeを連結させる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/join_with.md.nolink&#34;&gt;join_with&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;Rangeを指定の大きさで分割する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/chunk_view.md.nolink&#34;&gt;std::views::chunk&lt;/a&gt;&lt;/code&gt;と、Rangeを指定の大きさの隣接要素で分割する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/slide_view.md.nolink&#34;&gt;std::views::slide&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;Rangeを条件一致する間の要素で分割する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/chunk_by_view.md.nolink&#34;&gt;std::views::chunk_by&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Rangeを等間隔からなるRangeに変換する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/stride_view.md.nolink&#34;&gt;std::views::stride&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Rangeをムーブするための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/as_rvalue.md.nolink&#34;&gt;std::views::as_rvalue&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、指定した値をN回繰り返すRangeを生成する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/repeat.md.nolink&#34;&gt;std::views::repeat&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;に、Rangeをインデックス付きでループさせる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges/enumerate.md.nolink&#34;&gt;std::views::enumerate&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、範囲の先頭が指定した範囲と合致するかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/starts_with.md.nolink&#34;&gt;std::starts_with()&lt;/a&gt;&lt;/code&gt;、範囲の末尾が指定した範囲と合致するかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ends_with.md.nolink&#34;&gt;std::ends_with()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、要素を左シフトさせるRangeアルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_shift_left.html&#34;&gt;std::ranges::shift_left()&lt;/a&gt;&lt;/code&gt;、要素を右シフトさせるRangeアルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_shift_right.html&#34;&gt;std::ranges::shift_right()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、範囲の末尾から要素を検索する以下のアルゴリズムを追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_find_last.md.nolink&#34;&gt;std::ranges::find_last()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/find_last_if.md.nolink&#34;&gt;std::ranges::find_last_if()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/find_last_if_not.md.nolink&#34;&gt;std::ranges::find_last_if_not()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、範囲に特定の値が含まれているかを判定する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_contains.md.nolink&#34;&gt;std::ranges::contains()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_contains_subrange.md.nolink&#34;&gt;std::ranges::contains_subrange&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;に、数値に限定しない汎用的な畳み込みアルゴリズムとして、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.html&#34;&gt;std::ranges::fold_left()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_first.html&#34;&gt;std::ranges::fold_left_first()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.html&#34;&gt;std::ranges::fold_right()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_right_last.html&#34;&gt;std::ranges::fold_right_last()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_with_iter.html&#34;&gt;std::ranges::fold_left_with_iter()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_first_with_iter.md.nolink&#34;&gt;std::ranges::fold_left_first_with_iter()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に、連番を生成するRangeアルゴリズム&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/ranges_iota.html&#34;&gt;std::ranges::iota()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;クラスに、文字列内に指定した文字・文字列が含まれているかを判定するメンバ関数&lt;code&gt;contains()&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;のコンストラクタに、範囲をとるオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::string s = nullptr;&lt;/code&gt;のような文字列オブジェクトに&lt;code&gt;nullptr&lt;/code&gt;を代入するようなコードはバグの元であるため、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/nullptr_t.html&#34;&gt;nullptr_t&lt;/a&gt;&lt;/code&gt;をとるコンストラクタをdelete定義として追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスに、resize時に任意の初期化を行う&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/resize_and_overwrite.md.nolink&#34;&gt;resize_and_overwrite()&lt;/a&gt;&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;クラスのコンストラクタと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/substr.html&#34;&gt;substr()&lt;/a&gt;&lt;/code&gt;メンバ関数に一時オブジェクトのオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;関数でRange・コンテナ、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;を出力できるよう、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/formatter.html&#34;&gt;std::formatter&lt;/a&gt;&lt;/code&gt;に特殊化を追加&lt;ul&gt;
&lt;li&gt;Range・シーケンスコンテナは&lt;code&gt;[1, 2, 3]&lt;/code&gt;、&lt;code&gt;[&#34;hello&#34;, &#34;world&#34;]&lt;/code&gt;、&lt;code&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&lt;/code&gt;のように出力される&lt;/li&gt;
&lt;li&gt;連想コンテナの場合、&lt;code&gt;std::map&amp;lt;int, int&amp;gt;{{1, 2}, {3, 4}}&lt;/code&gt;は&lt;code&gt;{1: 2, 3: 4}&lt;/code&gt;のように出力され、&lt;code&gt;std::set&amp;lt;int&amp;gt;{1, 2, 3}&lt;/code&gt;は&lt;code&gt;{1, 2, 3}&lt;/code&gt;のように出力される&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;は&lt;code&gt;(1, 2)&lt;/code&gt;のように出力される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;関数のフォーマット指定子としてデバッグ指定「&lt;code&gt;&#34;?&#34;&lt;/code&gt;」を追加。これは文字・文字列を引用符で囲み、エスケープシーケンスをエスケープする&lt;ul&gt;
&lt;li&gt;ただし、Range・コンテナ中の文字・文字列はデフォルトでエスケープされる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;format(&#34;{:?}&#34;, &#34;h\tello&#34;)&lt;/code&gt;は&lt;code&gt;&#34;h\tello&#34;&lt;/code&gt;のように出力される&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream/basic_ostream.html&#34;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ostream/basic_ostream/op_ostream.html&#34;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;const volatile void*&lt;/code&gt;をとるオーバーロードを追加&lt;/li&gt;
&lt;li&gt;ファイルを開く際のオプションとして、排他モードを表す&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ios/ios_base/type-openmode.html&#34;&gt;noreplace&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;std::invoke()&lt;/a&gt;&lt;/code&gt;の戻り値型を指定するバージョンである&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke_r.html&#34;&gt;std::invoke_r()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;クラスと等価な機能をもつ、ムーブのみ可能な&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/move_only_function.html&#34;&gt;std::move_only_function&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;ユーザー定義のRangeアダプタがパイプライン演算子 &lt;code&gt;|&lt;/code&gt; をサポートしやすくするために、末尾から引数を束縛する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind_back.md.nolink&#34;&gt;std::bind_back()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、レガシーC関数からスマートポインタへの直接出力をサポートする、スマートポインタアダプタ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/out_ptr.html&#34;&gt;std::out_ptr&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/inout_ptr.html&#34;&gt;std::inout_ptr&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/unique_ptr.html&#34;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;クラスを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に、オブジェクトの生存期間を開始することを明示する関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/start_lifetime_as.md.nolink&#34;&gt;std::start_lifetime_as()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/start_lifetime_as_array.md.nolink&#34;&gt;std::start_lifetime_as_array()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit.html&#34;&gt;&amp;lt;bit&amp;gt;&lt;/a&gt;&lt;/code&gt;に、値のバイト入れ替え (エンディアン変換) を行う&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bit/byteswap.html&#34;&gt;std::byteswap()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/visit.html&#34;&gt;std::visit()&lt;/a&gt;&lt;/code&gt;に指定できるバリアントオブジェクトを、直接的な「&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant.html&#34;&gt;std::variant&lt;/a&gt;&lt;/code&gt;型の特殊化であること」という制約を緩和し、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant.html&#34;&gt;std::variant&lt;/a&gt;&lt;/code&gt;から派生した型も許可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、列挙値を基底型に変換する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/to_underlying.html&#34;&gt;std::to_underlying()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に、 (主に) メンバ変数を転送するため、指定された型の&lt;code&gt;const&lt;/code&gt;性と参照修飾で引数を転送する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/forward_like.html&#34;&gt;std::forward_like()&lt;/a&gt;&lt;/code&gt;関数を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/optional/optional.html&#34;&gt;std::optional&lt;/a&gt;&lt;/code&gt;クラスにモナド操作としてメンバ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/optional/optional/and_then.html&#34;&gt;and_then()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/optional/optional/transform.html&#34;&gt;transform()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/optional/optional/or_else.html&#34;&gt;or_else()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;到達しないパスであることを表明する関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility/unreachable.html&#34;&gt;std::unreachable()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bitset/bitset.html&#34;&gt;std::bitset&lt;/a&gt;&lt;/code&gt;クラスをさらに&lt;code&gt;constexpr&lt;/code&gt;対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型情報&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/typeinfo/type_info.html&#34;&gt;std::type_info&lt;/a&gt;&lt;/code&gt;クラスの&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/typeinfo/type_info/op_equal.html&#34;&gt;operator==&lt;/a&gt;&lt;/code&gt;を&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、スコープ付き列挙型かを判定する型特性&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_scoped_enum.html&#34;&gt;std::is_scoped_enum&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、第1テンプレート引数についている型修飾を外す型特性として、以下を追加：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、一時オブジェクトの参照への束縛を検出するための型特性として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/reference_constructs_from_temporary.html&#34;&gt;std::reference_constructs_from_temporary&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/reference_converts_from_temporary.html&#34;&gt;std::reference_converts_from_temporary&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C互換ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cstdlib.html&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;ヘッダの多くの関数を&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;std::aligned_storage&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;std::aligned_union&lt;/a&gt;&lt;/code&gt;を非推奨化。これらの機能は未定義動作を引き起こし、間違った保証が行われ、よくないAPI設計が行われていたため、非推奨とする&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;std::aligned_storage&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;alignas(T) &lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;[sizeof(T)];&lt;/code&gt;を使用することを推奨する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;std::aligned_union&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;alignas(Ts...) &lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;[&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/max.html&#34;&gt;std::max&lt;/a&gt;({sizeof(Ts)...})];&lt;/code&gt;を使用することを推奨する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;のメンバ型&lt;code&gt;is_always_equal&lt;/code&gt;を非推奨化。これはアロケータが状態をもたないことを表す型でありデフォルトでは&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/true_type.html&#34;&gt;true_type&lt;/a&gt;&lt;/code&gt;となっている。状態をもつユーザー定義のアロケータ型でこのメンバ型の上書きを忘れることでバグが埋め込まれてしまっていたため誤用防止のために非推奨とする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/limits.html&#34;&gt;&amp;lt;limits&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の非正規化数に関する機能を非推奨化。これらの機能は必ずしもコンパイル時に決まらない可能性のある値であり有用でないため、非推奨とする&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/limits/numeric_limits.html&#34;&gt;std::numeric_limits&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/limits/numeric_limits/has_denorm.html&#34;&gt;has_denorm&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/limits/numeric_limits.html&#34;&gt;std::numeric_limits&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/limits/numeric_limits/has_denorm_loss.html&#34;&gt;has_denorm_loss&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/limits/float_denorm_style.html&#34;&gt;std::float_denorm_style&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ガベージコレクションの実装にうまく役立てられなかった、ガベージコレクション実装のサポートをする以下の機能を削除する：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/declare_reachable.html&#34;&gt;std::declare_reachable()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/undeclare_reachable.html&#34;&gt;std::undeclare_reachable()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/declare_no_pointers.html&#34;&gt;std::declare_no_pointers()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/undeclare_no_pointers.html&#34;&gt;std::undeclare_no_pointers()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/get_pointer_safety.html&#34;&gt;std::get_pointer_safety()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/pointer_safety.html&#34;&gt;std::pointer_safety&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp11/predefined_macros.html&#34;&gt;&lt;code&gt;__STDCPP_STRICT_POINTER_SAFETY__&lt;/code&gt;マクロ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;取り決め&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以下のヘッダの一部機能をフリースタンディングライブラリとして追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/tuple.html&#34;&gt;&amp;lt;tuple&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ratio.html&#34;&gt;&amp;lt;ratio&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator.html&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ranges.html&#34;&gt;&amp;lt;ranges&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- fold_left_with_iter追加 #1088</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>f222955da68c8794948d82cf78c3e78d006359f2:reference/algorithm.md</id>
      <updated>2024-02-06T16:15:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 5b6e8b5b7..0f7085280 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -430,7 +430,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::fold_right`](algorithm/ranges_fold_right.md)| 範囲の右（終端）からの`fold` | C++23 |
 | [`ranges::fold_left_first`](algorithm/ranges_fold_left_first.md)| 範囲の左（先頭）からの`fold`、初期値を省略する | C++23 |
 | [`ranges::fold_right_last`](algorithm/ranges_fold_right_last.md)| 範囲の右（終端）からの`fold`、初期値を省略する | C++23 |
-| [`ranges::fold_left_with_iter`](algorithm/ranges_fold_left_with_iter.md.nolink)  | 範囲の左（先頭）からの`fold`、終端イテレータを返す      | C++23 |
+| [`ranges::fold_left_with_iter`](algorithm/ranges_fold_left_with_iter.md)  | 範囲の左（先頭）からの`fold`、終端イテレータを返す      | C++23 |
 | [`ranges::fold_left_first_with_iter`](algorithm/ranges_fold_left_first_with_iter.md.nolink)  | 範囲の左（先頭）からの`fold`、初期値を省略し終端イテレータを返す      | C++23 |
 
 ### 戻り値
@@ -446,6 +446,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::in_out_out_result`](algorithm/ranges_in_out_out_result.md) | 3つのイテレータを格納する型              | C++20          |
 | [`ranges::min_max_result`](algorithm/ranges_min_max_result.md)       | 2つの値または参照を格納する型            | C++20          |
 | [`ranges::in_found_result`](algorithm/ranges_in_found_result.md)     | イテレータとbool値を格納する型           | C++20          |
+| [`ranges::in_value_result`](algorithm/ranges_in_value_result.md)     | イテレータと値を格納する型               | C++23          |
 | [`ranges::out_value_result`](algorithm/ranges_out_value_result.md)   | イテレータと値を格納する型               | C++23          |
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left -- fold_left_with_iter追加 #1088</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left.html"/>
      <id>f222955da68c8794948d82cf78c3e78d006359f2:reference/algorithm/ranges_fold_left.md</id>
      <updated>2024-02-06T16:15:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left.md b/reference/algorithm/ranges_fold_left.md
index 9a540b2b8..f5b4fcee4 100644
--- a/reference/algorithm/ranges_fold_left.md
+++ b/reference/algorithm/ranges_fold_left.md
@@ -100,7 +100,7 @@ concept indirectly-binary-left-foldable =
     ```cpp
     return ranges::fold_left_with_iter(std::move(first), last, std::move(init), f).value;
     ```
-    * fold_left_with_iter[link /reference/algorithm/ranges_fold_left_with_iter.md.nolink]
+    * fold_left_with_iter[link /reference/algorithm/ranges_fold_left_with_iter.md]
 
 - (2) : `r`からイテレータを取得して(1)に委譲
     ```cpp
@@ -264,7 +264,7 @@ constexpr auto fold_left(I first, S last, T init, F f) {
     - 範囲の最初の要素を初期値として`fold_left`
 - [`ranges::fold_right_last`](ranges_fold_right_last.md)
     - 範囲の最後の要素を初期値として`fold_right`
-- [`ranges::fold_left_with_iter`](ranges_fold_left_with_iter.md.nolink)
+- [`ranges::fold_left_with_iter`](ranges_fold_left_with_iter.md)
     - `fold_left`の結果と共に、計算した終端イテレータも返す
 - [`ranges::fold_left_first_with_iter`](ranges_fold_left_first_with_iter.md.nolink)
     - `fold_left_first`の結果と共に、計算した終端イテレータも返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left_first -- fold_left_with_iter追加 #1088</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_first.html"/>
      <id>f222955da68c8794948d82cf78c3e78d006359f2:reference/algorithm/ranges_fold_left_first.md</id>
      <updated>2024-02-06T16:15:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left_first.md b/reference/algorithm/ranges_fold_left_first.md
index 9bac033d2..71307ad82 100644
--- a/reference/algorithm/ranges_fold_left_first.md
+++ b/reference/algorithm/ranges_fold_left_first.md
@@ -150,7 +150,7 @@ int main() {
 }
 ```
 * fold_left_first[color ff0000]
-* fold_left[link ranges_fold_right.md]
+* fold_left[link ranges_fold_left.md]
 * println[link /reference/print/println.md]
 * value_or[link /reference/optional/optional/value_or.md]
 
@@ -202,7 +202,7 @@ constexpr auto fold_left_first(I first, S last, F f) {
     - 範囲の右からの`fold`
 - [`ranges::fold_right_last`](ranges_fold_right_last.md)
     - 範囲の最後の要素を初期値として`fold_right`
-- [`ranges::fold_left_with_iter`](ranges_fold_left_with_iter.md.nolink)
+- [`ranges::fold_left_with_iter`](ranges_fold_left_with_iter.md)
     - `fold_left`の結果と共に、計算した終端イテレータも返す
 - [`ranges::fold_left_first_with_iter`](ranges_fold_left_first_with_iter.md.nolink)
     - `fold_left_first`の結果と共に、計算した終端イテレータも返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_left_first -- fold_left_with_iter追加 #1088</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_left_with_iter.html"/>
      <id>f222955da68c8794948d82cf78c3e78d006359f2:reference/algorithm/ranges_fold_left_with_iter.md</id>
      <updated>2024-02-06T16:15:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_left_with_iter.md b/reference/algorithm/ranges_fold_left_with_iter.md
new file mode 100644
index 000000000..f582a3bf1
--- /dev/null
+++ b/reference/algorithm/ranges_fold_left_with_iter.md
@@ -0,0 +1,234 @@
+# fold_left_first
+* algorithm[meta header]
+* function template[meta id-type]
+* std::ranges[meta namespace]
+* cpp23[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
+           indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+  constexpr auto fold_left_with_iter(I first, S last, T init, F f); // (1)
+
+  template&amp;lt;input_range R, class T,
+           indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+  constexpr auto fold_left_with_iter(R&amp;amp;&amp;amp; r, T init, F f);           // (2)
+}
+```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* sentinel_for[link /reference/iterator/sentinel_for.md]
+* indirectly-binary-left-foldable[link ./ranges_fold_left.md]
+* input_range[link /reference/ranges/input_range.md]
+* iterator_t[link /reference/ranges/iterator_t.md]
+
+## 概要
+
+処理の過程で得られた終端位置を指すイテレータを同時に返す[`fold_left`](./ranges_fold_left.md)。戻り値はイテレータと処理結果のペアとなる。
+
+- (1) : 入力としてイテレータ範囲をとるオーバーロード
+- (2) : 入力として範囲を直接とるオーバーロード
+
+## 引数
+
+- `first` -- 入力範囲の先頭イテレータ
+- `last` -- 入力範囲の番兵（終端イテレータ）
+- `r` -- 入力範囲のオブジェクト
+- `init` -- 初期値
+- `f` -- 適用する二項演算
+    - `f(std::move(init), *first)`のような呼び出しが可能であり、その戻り値型のオブジェクトを`acc`とすると
+    - `acc = f(std::move(acc), *first)`のような呼び出しも可能である必要がある
+
+## テンプレートパラメータ制約
+
+二項演算（`F`）は初期値・積算値と入力範囲の参照型に対して[`invocable`](/reference/concepts/invocable.md)であることしか求められていない（`regular_invocable`ではない）ため、適用する二項演算は任意の副作用を伴っていても良い。
+
+## 戻り値
+
+型`U`を次のように取得して
+
+```cpp
+using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, T, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
+```
+* decay_t[link /reference/type_traits/decay.md]
+* invoke_result_t[link /reference/type_traits/invoke_result.md]
+* iter_reference_t[link /reference/iterator/iter_reference_t.md]
+
+(1)(2)ともに、以下と等価
+
+```cpp
+if (first == last)
+  return {std::move(first), U(std::move(init))};
+U accum = invoke(f, std::move(init), *first);
+for (++first; first != last; ++first)
+  accum = invoke(f, std::move(accum), *first);
+return {std::move(first), std::move(accum)};
+```
+* decay_t[link /reference/type_traits/decay.md]
+* invoke_result_t[link /reference/type_traits/invoke_result.md]
+* iter_reference_t[link /reference/iterator/iter_reference_t.md]
+* next[link /reference/iterator/ranges_next.md]
+* invoke[link /reference/functional/invoke.md]
+
+空の入力範囲に対しては初期値`init`を返す。入力範囲によらず、戻り値の1つ目の値（イテレータ値）は渡した範囲の終端イテレータ（`last`/`ranges::end(r)`）と同じ位置を指すイテレータとなる（必ずしも同じ型もしくは同じイテレータにならない）。
+
+戻り値型はそれぞれ、`U`を次の様に[`fold_left_with_iter_result`](/reference/algorithm/ranges_in_value_result.md)の2つ目の引数に当てはめた型となる
+
+```cpp
+template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
+         indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+constexpr fold_left_with_iter_result&amp;lt;I, U&amp;gt;
+  fold_left_with_iter(I first, S last, T init, F f); 
+
+template&amp;lt;input_range R, class T,
+         indirectly-binary-left-foldable&amp;lt;T, iterator_t&amp;lt;R&amp;gt;&amp;gt; F&amp;gt;
+constexpr fold_left_with_iter_result&amp;lt;borrowed_iterator_t&amp;lt;R&amp;gt;, U&amp;gt;
+  fold_left_with_iter(R&amp;amp;&amp;amp; r, T init, F f);
+```
+* fold_left_with_iter_result[link /reference/algorithm/ranges_in_value_result.md]
+* borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+
+1つ目の引数には入力のイテレータ型が当てられる。
+
+## 計算量
+
+入力範囲`r`（`[first, last)`）の要素数を`N`とすると、正確に`N`回の`f`の適用が行われる。
+
+## 備考
+
+戻り値の項で使用している`U`は、指定した二項演算を初期値とイテレータによって`f(std::move(init), *first)`のように呼び出した時の戻り値型であり、`fold_left_with_iter()`の処理内部で積算値の型として使用されるものでもある。
+
+`fold_left`同様に、`f`は`init`の代わりに`U`の右辺値も受け取れる必要がある。二項演算の呼び出しにおいては、第一引数に初期値もしくは積算値が渡され、第二引数にイテレータの間接参照結果が直接渡される。そして、二項演算の適用結果は積算値を保存する変数に直接代入される（つまり、結果を次のステップに引き継ぎたい場合は積算処理も二項演算内で行う必要がある）。詳細は下の実装例を参照。
+
+## 例
+
+### 基本的な数値集計処理の例
+
+```cpp example
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+using namespace std::ranges;
+
+int main() {
+  // 入力
+  range auto rng = views::iota(1, 11);
+  // 初期値
+  const int init = 0;
+  // 二項演算
+  auto op = std::plus&amp;lt;&amp;gt;{};
+  
+  auto [end1, resl] = fold_left_with_iter(rng, init, op);
+
+  std::println(&amp;#34;{{ {:s}, {:d} }}&amp;#34;, end1 == end(rng), resl);
+
+
+  // 入力範囲はfloatのvector
+  std::vector&amp;lt;float&amp;gt; rngf = { 0.125f, 0.25f, 0.75f };
+  
+  // 計算結果はfloat
+  auto [end2, reslf] = fold_left_with_iter(rngf, init, op);
+
+  std::println(&amp;#34;{{ {:s}, {:g} }}&amp;#34;, end2 == end(rngf), reslf);
+}
+```
+* fold_left_with_iter[color ff0000]
+* iota[link /reference/ranges/iota_view.md]
+* plus[link /reference/functional/plus.md]
+* println[link /reference/print/println.md]
+
+### 出力
+```
+{ true, 55 }
+{ true, 1.125 }
+```
+
+### 空の入力範囲に対する動作の例
+
+```cpp example
+#include &amp;lt;ranges&amp;gt;
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+using namespace std::ranges;
+
+int main() {
+  range auto rng = views::empty&amp;lt;int&amp;gt;;
+  const int init = -1;
+  auto op = std::plus&amp;lt;&amp;gt;{};
+
+  auto res1 = fold_left(rng, init, op);
+  auto res2 = fold_left_first(rng, op);
+  auto [_, res3] = fold_left_with_iter(rng, init, op);
+
+  std::println(&amp;#34;{:d}&amp;#34;, res1);
+  std::println(&amp;#34;{:d}&amp;#34;, res2.value_or(-1));
+  std::println(&amp;#34;{:d}&amp;#34;, res3);
+}
+```
+* fold_left_with_iter[color ff0000]
+* fold_left[link ranges_fold_left.md]
+* fold_left_first[link ranges_fold_left_first.md]
+* println[link /reference/print/println.md]
+* value_or[link /reference/optional/optional/value_or.md]
+
+### 出力
+```
+-1
+-1
+-1
+```
+
+## 実装例
+
+```cpp
+template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T,
+         indirectly-binary-left-foldable&amp;lt;T, I&amp;gt; F&amp;gt;
+constexpr auto fold_left_with_iter(I first, S last, F f) -&amp;gt; fold_left_with_iter_result&amp;lt;I, U&amp;gt; {
+  using U = decay_t&amp;lt;invoke_result_t&amp;lt;F&amp;amp;, T, iter_reference_t&amp;lt;I&amp;gt;&amp;gt;&amp;gt;;
+
+  if (first == last) {
+    return {std::move(first), U(std::move(init))};
+  }
+
+  U accum = invoke(f, std::move(init), *first);
+
+  ++first;
+
+  for (; first != last; ++first) {
+    accum = invoke(f, std::move(accum), *first);
+  }
+
+  return {std::move(first), std::move(accum)};
+}
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 13.1
+- [Visual C++](/implementation.md#visual_cpp): 2022 Update 5
+
+## 関連項目
+
+- [`ranges::fold_left`](ranges_fold_left.md)
+    - 範囲の左からの`fold`
+- [`ranges::fold_right`](ranges_fold_right.md)
+    - 範囲の右からの`fold`
+- [`ranges::fold_left_first`](ranges_fold_left_first.md)
+    - 範囲の最初の要素を初期値として`fold_left`
+- [`ranges::fold_right_last`](ranges_fold_right_last.md)
+    - 範囲の最後の要素を初期値として`fold_right`
+- [`ranges::fold_left_first_with_iter`](ranges_fold_left_first_with_iter.md.nolink)
+    - `fold_left_first`の結果と共に、計算した終端イテレータも返す
+
+## 参照
+
+- [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_right -- fold_left_with_iter追加 #1088</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_right.html"/>
      <id>f222955da68c8794948d82cf78c3e78d006359f2:reference/algorithm/ranges_fold_right.md</id>
      <updated>2024-02-06T16:15:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_right.md b/reference/algorithm/ranges_fold_right.md
index b6bd5625e..933c27286 100644
--- a/reference/algorithm/ranges_fold_right.md
+++ b/reference/algorithm/ranges_fold_right.md
@@ -300,7 +300,7 @@ constexpr auto fold_right(I first, S last, T init, F f) {
     - 範囲の最初の要素を初期値として`fold_left`
 - [`ranges::fold_right_last`](ranges_fold_right_last.md)
     - 範囲の最後の要素を初期値として`fold_right`
-- [`ranges::fold_left_with_iter`](ranges_fold_left_with_iter.md.nolink)
+- [`ranges::fold_left_with_iter`](ranges_fold_left_with_iter.md)
     - `fold_left`の結果と共に、計算した終端イテレータも返す
 - [`ranges::fold_left_first_with_iter`](ranges_fold_left_first_with_iter.md.nolink)
     - `fold_left_first`の結果と共に、計算した終端イテレータも返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fold_right_last -- fold_left_with_iter追加 #1088</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_fold_right_last.html"/>
      <id>f222955da68c8794948d82cf78c3e78d006359f2:reference/algorithm/ranges_fold_right_last.md</id>
      <updated>2024-02-06T16:15:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_fold_right_last.md b/reference/algorithm/ranges_fold_right_last.md
index 6491ba9fc..30d0b7f6d 100644
--- a/reference/algorithm/ranges_fold_right_last.md
+++ b/reference/algorithm/ranges_fold_right_last.md
@@ -215,7 +215,7 @@ constexpr auto fold_right_last(I first, S last, F f) {
     - 範囲の右からの`fold`
 - [`ranges::fold_left_first`](ranges_fold_left_first.md)
     - 範囲の最初の要素を初期値として`fold_left`
-- [`ranges::fold_left_with_iter`](ranges_fold_left_with_iter.md.nolink)
+- [`ranges::fold_left_with_iter`](ranges_fold_left_with_iter.md)
     - `fold_left`の結果と共に、計算した終端イテレータも返す
 - [`ranges::fold_left_first_with_iter`](ranges_fold_left_first_with_iter.md.nolink)
     - `fold_left_first`の結果と共に、計算した終端イテレータも返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>in_value_result -- fold_left_with_iter追加 #1088</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_in_value_result.html"/>
      <id>f222955da68c8794948d82cf78c3e78d006359f2:reference/algorithm/ranges_in_value_result.md</id>
      <updated>2024-02-06T16:15:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_in_value_result.md b/reference/algorithm/ranges_in_value_result.md
new file mode 100644
index 000000000..1cc5d9677
--- /dev/null
+++ b/reference/algorithm/ranges_in_value_result.md
@@ -0,0 +1,87 @@
+# in_value_result
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* class[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std::ranges {
+  // (1)
+  template&amp;lt;class I, class T&amp;gt;
+  struct in_value_result {
+    [[no_unique_address]] I in;
+    [[no_unique_address]] T value;
+
+    template&amp;lt;class I2, class T2&amp;gt;
+      requires convertible_to&amp;lt;const I&amp;amp;, I2&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;const T&amp;amp;, T2&amp;gt;
+    constexpr operator in_value_result&amp;lt;I2, T2&amp;gt;() const &amp;amp; {
+      return {in, value};
+    }
+
+    template&amp;lt;class I2, class T2&amp;gt;
+      requires convertible_to&amp;lt;I, I2&amp;gt; &amp;amp;&amp;amp;
+               convertible_to&amp;lt;T, T2&amp;gt;
+    constexpr operator in_value_result&amp;lt;I2, T2&amp;gt;() &amp;amp;&amp;amp; {
+      return {std::move(in), std::move(value)};
+    }
+  };
+
+  // (2)
+  template&amp;lt;class I, class T&amp;gt;
+  using fold_left_with_iter_result = in_value_result&amp;lt;I, T&amp;gt;;
+
+  // (3)
+  template&amp;lt;class I, class T&amp;gt;
+  using fold_left_first_with_iter_result = in_value_result&amp;lt;I, T&amp;gt;;   
+}
+```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* std::move[link /reference/utility/move.md]
+
+## 概要
+
+* (1): イテレータと値を格納する型
+* (2): [`ranges::fold_left_with_iter`](/reference/algorithm/ranges_fold_left_with_iter.md)で使用するエイリアス
+* (3): [`ranges::fold_left_first_with_iter`](/reference/algorithm/ranges_fold_left_first_with_iter.md.nolink)で使用するエイリアス
+
+この型は、関数が入力用に範囲を受け取る場合に、処理した範囲の末尾と、それとは別の出力を返すために使用される。
+
+標準アルゴリズム関数ではこの型を直接返す代わりに、関数毎にエイリアスを定義している。
+
+
+## メンバ変数
+
+| 名前                             | 説明                 | 対応バージョン |
+| ------------------------------- | -------------------- | -------------- |
+| `[[no_unique_address]] I in`    | 読み込んだ範囲の終端位置   | C++23          |
+| `[[no_unique_address]] T value` | イテレータとは別の値 | C++23          |
+
+
+## メンバ関数
+
+| 名前                                | 説明       | 対応バージョン |
+| ----------------------------------- | ---------- | -------------- |
+| `operator in_value_result&amp;lt;I2, T2&amp;gt;` | 変換演算子 | C++23          |
+
+変換演算子は、各テンプレートパラメーターが変換できる場合のみオーバーロード解決に参加する。
+
+## 例
+(執筆中)
+
+### 出力
+(執筆中)
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 13.1
+- [Visual C++](/implementation.md#visual_cpp): 2022 Update 5
+
+## 参照
+
+- [P2322R6 `ranges::fold`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2322r6.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>de-ice -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/de-ice.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/de-ice.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/de-ice.md b/reference/mdspan/de-ice.md
new file mode 100644
index 000000000..b2f611d27
--- /dev/null
+++ b/reference/mdspan/de-ice.md
@@ -0,0 +1,25 @@
+# de-ice
+* mdspan[meta header]
+* function template[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class T&amp;gt;
+constexpr T de-ice(T val) { return val; }
+
+template&amp;lt;integral-constant-like T&amp;gt;
+constexpr auto de-ice(T) { return T::value; }
+```
+* integral-constant-like[link integral-constant-like.md]
+
+## 概要
+`de-ice`は[`submdspan`](submdspan.md)動作説明用の関数テンプレートである。
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>first_ -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/first_.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/first_.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/first_.md b/reference/mdspan/first_.md
new file mode 100644
index 000000000..0a5dc8dd1
--- /dev/null
+++ b/reference/mdspan/first_.md
@@ -0,0 +1,40 @@
+# first_
+* mdspan[meta header]
+* function template[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class IndexType, size_t k, class ... SliceSpecifiers&amp;gt;
+constexpr IndexType first_(SliceSpecifiers... slices);
+```
+
+## 概要
+`first_`は[`submdspan`](submdspan.md)動作説明用の関数テンプレートである。
+
+`S_k`を`SliceSpecifiers`の`k`番目の型、`s_k`を`slices`の`k`番目の値としたとき、説明用の`P_k`の値を次のように定義する。
+
+- 型`S_k`が[`convertible_to`](/reference/concepts/convertible_to.md)`&amp;lt;index_type&amp;gt;`のモデルのとき`s_k`、そうでなければ
+- 型`S_k`が[`index-pair-like`](index-pair-like.md)`&amp;lt;index_type&amp;gt;`のモデルのとき`get&amp;lt;0&amp;gt;(s_k)`、そうでなければ
+- 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化のとき[`de-ice`](de-ice.md)`(s_k.offset)`、そうでなければ
+- 値`0`
+
+
+## 適格要件
+`IndexType`は符号付き整数型または符号無し整数型であること。
+
+
+## 事前条件
+`P_k`が`IndexType`型で表現可能な値であること。
+
+
+## 戻り値
+[`extents`](extents.md)`&amp;lt;IndexType&amp;gt;::`[`index-cast`](extents/index-cast.md)`(P_k)`
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>full_extent_t -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/full_extent_t.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/full_extent_t.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/full_extent_t.md b/reference/mdspan/full_extent_t.md
index 49c7336d4..78bf97479 100644
--- a/reference/mdspan/full_extent_t.md
+++ b/reference/mdspan/full_extent_t.md
@@ -26,9 +26,10 @@ namespace std {
 int main()
 {
   int arr[] = {1, 2, 3, 4, 5, 6};
+
+  // 2x3要素の2次元配列ビュー
   using Ext2x3 = std::extents&amp;lt;size_t, 2, 3&amp;gt;;
   std::mdspan&amp;lt;int, Ext2x3&amp;gt; mat{arr};
-  // 2x3要素の2次元配列ビュー
   // i/j -&amp;gt;
   // |  1 2 3
   // V  4 5 6
@@ -51,6 +52,8 @@ int main()
 * std::full_extent[color ff0000]
 * std::submdspan[link submdspan.md]
 * extent[link mdspan/extent.md]
+* std::print[link /reference/print/print.md]
+* std::println[link /reference/print/println.md]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>index-pair-like -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/index-pair-like.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/index-pair-like.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/index-pair-like.md b/reference/mdspan/index-pair-like.md
new file mode 100644
index 000000000..e4a34b71a
--- /dev/null
+++ b/reference/mdspan/index-pair-like.md
@@ -0,0 +1,26 @@
+# index-pair-like
+* mdspan[meta header]
+* concept[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class T, class IndexType&amp;gt;
+concept index-pair-like =                        // exposition only
+  pair-like&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
+  convertible_to&amp;lt;tuple_element_t&amp;lt;0,T&amp;gt;, IndexType&amp;gt; &amp;amp;&amp;amp;
+  convertible_to&amp;lt;tuple_element_t&amp;lt;1,T&amp;gt;, IndexType&amp;gt;;
+```
+* pair-like[link /reference/tuple/pair-like.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+
+## 概要
+`index-pair-like`は、インデクス値ペアと互換があることを表す説明専用コンセプトである。
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>integral-constant-like -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/integral-constant-like.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/integral-constant-like.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/integral-constant-like.md b/reference/mdspan/integral-constant-like.md
new file mode 100644
index 000000000..d45e5abaf
--- /dev/null
+++ b/reference/mdspan/integral-constant-like.md
@@ -0,0 +1,33 @@
+# integral-constant-like
+* mdspan[meta header]
+* concept[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class T&amp;gt;
+concept integral-constant-like =  // exposition only
+  is_integral_v&amp;lt;decltype(T::value)&amp;gt; &amp;amp;&amp;amp;
+  !is_same_v&amp;lt;bool, remove_const_t&amp;lt;decltype(T::value)&amp;gt;&amp;gt; &amp;amp;&amp;amp;
+  convertible_to&amp;lt;T, decltype(T::value)&amp;gt; &amp;amp;&amp;amp;
+  equality_comparable_with&amp;lt;T, decltype(T::value)&amp;gt; &amp;amp;&amp;amp;
+  bool_constant&amp;lt;T() == T::value&amp;gt;::value &amp;amp;&amp;amp;
+  bool_constant&amp;lt;static_cast&amp;lt;decltype(T::value)&amp;gt;(T()) == T::value&amp;gt;::value;
+```
+* is_integral_v[link /reference/type_traits/is_integral.md]
+* is_same_v[link /reference/type_traits/is_same.md]
+* remove_const_t[link /reference/type_traits/remove_const.md]
+* bool_constant[link /reference/type_traits/bool_constant.md]
+* convertible_to[link /reference/concepts/convertible_to.md]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
+
+## 概要
+`integral-constant-like`は、型`T`が整数定数と互換があることを表す説明専用コンセプトである。
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>last_ -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/last_.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/last_.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/last_.md b/reference/mdspan/last_.md
new file mode 100644
index 000000000..f552e9b46
--- /dev/null
+++ b/reference/mdspan/last_.md
@@ -0,0 +1,41 @@
+# last_
+* mdspan[meta header]
+* function template[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;size_t k, class Extents, class ... SliceSpecifiers&amp;gt;
+constexpr auto last_(const Extents&amp;amp; src, SliceSpecifiers... slices);
+```
+* Extents[link extents.md]
+
+## 概要
+`last_`は[`submdspan`](submdspan.md)動作説明用の関数テンプレートである。
+
+`index_type`を`Extents::index_type`型、`S_k`を`SliceSpecifiers`の`k`番目の型、`s_k`を`slices`の`k`番目の値としたとき、説明用の`L_k`の値を次のように定義する。
+
+- 型`S_k`が[`convertible_to`](/reference/concepts/convertible_to.md)`&amp;lt;index_type&amp;gt;`のモデルのとき[`de-ice`](de-ice.md)`(s_k) + 1`、そうでなければ
+- 型`S_k`が[`index-pair-like`](index-pair-like.md)`&amp;lt;index_type&amp;gt;`のモデルのとき`get&amp;lt;1&amp;gt;(s_k)`、そうでなければ
+- 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化のとき[`de-ice`](de-ice.md)`(s_k.offset) +` [`de-ice`](de-ice.md)`(s_k.extent)`、そうでなければ
+- `src.`[`extent`](extents/extent.md)`(k)`
+
+
+## 適格要件
+`Extents`が[`extents`](extents.md)の特殊化であること。
+
+
+## 事前条件
+`L_k`が`index_type`型で表現可能な値であること。
+
+
+## 戻り値
+[`extents`](extents.md)`&amp;lt;IndexType&amp;gt;::`[`index-cast`](extents/index-cast.md)`(L_k)`
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>src-indices -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/src-indices.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/src-indices.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/src-indices.md b/reference/mdspan/src-indices.md
new file mode 100644
index 000000000..f93730159
--- /dev/null
+++ b/reference/mdspan/src-indices.md
@@ -0,0 +1,40 @@
+# src-indices
+* mdspan[meta header]
+* function template[meta id-type]
+* cpp26[meta cpp]
+
+```cpp
+template&amp;lt;class IndexType, size_t N, class ... SliceSpecifiers&amp;gt;
+constexpr array&amp;lt;IndexType, sizeof...(SliceSpecifiers)&amp;gt;
+  src-indices(const array&amp;lt;IndexType, N&amp;gt;&amp;amp; indices, SliceSpecifiers ... slices);
+```
+* array[link /reference/array/array.md]
+
+## 概要
+`src-indices`は[`submdspan`](submdspan.md)動作説明用の関数テンプレートである。
+
+説明のため`rank`を`slices`の要素数、`S_k`を`SliceSpecifiers`の`k`番目の型とする
+[`array`](/reference/array/array.md)`&amp;lt;size_t, rank&amp;gt;`型の配列`map-rank`を導入し、その要素`map-rank[k]`を下記の通り定義する。
+
+- 型`S_k`が[`convertible_to`](/reference/concepts/convertible_to.md)`&amp;lt;IndexType&amp;gt;`のモデルのとき[`dynamic_extent`](/reference/span/dynamic_extent.md)、そうでなければ
+- `j &amp;lt; k`において型`S_j`が[`convertible_to`](/reference/concepts/convertible_to.md)`&amp;lt;IndexType&amp;gt;`のモデルではない個数
+
+
+## 適格要件
+`IndexType`は符号付き整数型または符号無し整数型であること。
+
+
+## 戻り値
+半開区間`[0, rank)`の`k`に対して、`k`番目の要素が下記の値を持つ配列を返す。
+
+- `map-rank[k]`が[`dynamic_extent`](/reference/span/dynamic_extent.md)に等しいとき、[`first_`](first_.md)`&amp;lt;IndexType, k&amp;gt;(slices...)`
+- そうでなければ、[`first_`](first_.md)`&amp;lt;IndexType, k&amp;gt;(slices...) + indices[map-rank[k]]`
+
+
+## バージョン
+### 言語
+- C++26
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>strided_slice -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/strided_slice.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/strided_slice.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/strided_slice.md b/reference/mdspan/strided_slice.md
index 6ab21722b..b7003c043 100644
--- a/reference/mdspan/strided_slice.md
+++ b/reference/mdspan/strided_slice.md
@@ -18,6 +18,7 @@ namespace std {
   };
 }
 ```
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
 
 ## 概要
 `strided_slice`は、多次元配列の特定次元に対してストライド幅を指定した要素取り出しを指示する集成体クラステンプレートである。
@@ -35,7 +36,7 @@ std::strided_slice{.offset=1, .extent=10, .stride=3}
 
 
 ## 適格要件
-`OffsetType`, `ExtentType`, `StrideType`は符号付き整数型または符号無し整数型、もしくは[`integral-constant-like`](integral-constant-like.md.nolink)のモデルであること。
+`OffsetType`, `ExtentType`, `StrideType`は符号付き整数型または符号無し整数型、もしくは[`integral-constant-like`](integral-constant-like.md)のモデルであること。
 
 
 ## メンバ型
@@ -63,7 +64,7 @@ int main()
   // オフセット位置1から10要素の範囲よりストライド幅3で要素抽出
   auto vec1 = std::submdspan(vec0, std::strided_slice{1, 10, 3});
   // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
-  //    ^  .  .  ^  .  .  ^   .  .  ^
+  //    ^  .  .  ^  .  .  ^  .  .   ^
   std::println(&amp;#34;vec1:&amp;#34;);
   for (size_t i = 0; i &amp;lt; vec1.extent(0); i++) {
     std::print(&amp;#34; {}&amp;#34;, vec1[i]);
@@ -81,9 +82,10 @@ int main()
 }
 ```
 * std::strided_slice[color ff0000]
-* std::ranges::iota[link /reference/numeric/ranges_iota.md]
 * std::submdspan[link submdspan.md]
-* extent[link mdspan/extent.md]
+* std::print[link /reference/print/print.md]
+* std::println[link /reference/print/println.md]
+* std::ranges::iota[link /reference/numeric/ranges_iota.md]
 
 ### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>submdspan -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/submdspan.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/submdspan.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/submdspan.md b/reference/mdspan/submdspan.md
index db055f288..6ca3ad68f 100644
--- a/reference/mdspan/submdspan.md
+++ b/reference/mdspan/submdspan.md
@@ -31,7 +31,7 @@ namespace std {
 スライス指定子リスト`slices...`にインデクス値指定が含まれる場合、戻り値の次元数(rank)は元の多次元配列ビューに対してインデクス値指定した次元数だけ削減される。
 
 - インデクス値指定 : 整数値。指定次元に対する多次元インデクス値を固定する。
-- インデクス範囲指定 : [インデクス・ペア互換型](index-pair-like.md.nolink)の値。開始位置(begin)と終了位置(end)で表現される半開区間から要素群を取り出す。
+- インデクス範囲指定 : [インデクス・ペア互換型](index-pair-like.md)の値。開始位置(begin)と終了位置(end)で表現される半開区間から要素群を取り出す。
 - ストライド・スライス指定 : [`std::strided_slice`](strided_slice.md)の値。オフセット(offset)と要素数(extent)とストライド幅(stride)で指定される要素群を取り出す。
 - 全要素指定 : [`std::full_extent`](full_extent_t.md)。指定次元の全要素を取り出す。
 
@@ -48,7 +48,7 @@ namespace std {
 - [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;decltype(`[`sub_map_offset.mapping`](submdspan_mapping_result.md)`.extents())&amp;gt;, decltype(`[`submdspan_extents`](submdspan_extents.md.nolink)`(`[`src.mapping()`](mdspan/mapping.md)`, slices...))&amp;gt;`が`true`、かつ
 - [`src.extents()`](mdspan/extents.md)の各次元インデクス`k`において、`S_k`を`SliceSpecifiers`の`k`番目の型としたき、下記いずれかの1つのみを満たすこと。
     - 型`S_k`が[`convertible_to`](/reference/concepts/convertible_to.md)`&amp;lt;index_type&amp;gt;`のモデル
-    - 型`S_k`が[`index-pair-like`](index-pair-like.md.nolink)`&amp;lt;index_type&amp;gt;`のモデル
+    - 型`S_k`が[`index-pair-like`](index-pair-like.md)`&amp;lt;index_type&amp;gt;`のモデル
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;S_k,` [`full_extent_t`](full_extent_t.md)`&amp;gt;`が`true`
     - 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化
 
@@ -58,9 +58,9 @@ namespace std {
     - 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化のとき
         - `s_k.extent == 0`、または
         - `s_k.stride &amp;gt; 0`
-    - `0` ≤ [`first_&amp;lt;index_type, k&amp;gt;`](first_.md.nolink)`(slices...)` ≤ [`last_&amp;lt;k&amp;gt;`](last_.md.nolink)`(`[`src.extents()`](mdspan/extents.md)`, slices...)` ≤ [`src.extent(k)`](mdspan/extent.md)
+    - `0` ≤ [`first_&amp;lt;index_type, k&amp;gt;`](first_.md)`(slices...)` ≤ [`last_&amp;lt;k&amp;gt;`](last_.md)`(`[`src.extents()`](mdspan/extents.md)`, slices...)` ≤ [`src.extent(k)`](mdspan/extent.md)
 - [`sub_map_offset.mapping`](submdspan_mapping_result.md)`.extents() ==` [`submdspan_extents`](submdspan_extents.md.nolink)`(`[`src.mapping()`](mdspan/mapping.md)`, slices...)`が`true`、かつ
-- [`sub_map_offset.mapping`](submdspan_mapping_result.md)`.extents()`の多次元インデクス値を表す任意の整数パック`I`に対して、`sub_map_offset.mapping(I...) +` [`sub_map_offset.offset`](submdspan_mapping_result.md) `==` [`src.mapping()`](mdspan/mapping.md)`(`[`src-indices`](src-indices.md.nolink)`(`[`array`](/reference/array/array.md)`{I...}, slices...))`が`true`であること。
+- [`sub_map_offset.mapping`](submdspan_mapping_result.md)`.extents()`の多次元インデクス値を表す任意の整数パック`I`に対して、`sub_map_offset.mapping(I...) +` [`sub_map_offset.offset`](submdspan_mapping_result.md) `==` [`src.mapping()`](mdspan/mapping.md)`(`[`src-indices`](src-indices.md)`(`[`array`](/reference/array/array.md)`{I...}, slices...))`が`true`であること。
 
 
 ## 効果
@@ -145,9 +145,11 @@ int main()
 }
 ```
 * std::submdspan[color ff0000]
-* std::ranges::iota[link /reference/numeric/ranges_iota.md]
 * std::full_extent[link full_extent_t.md]
 * std::strided_slice[link strided_slice.md]
+* std::print[link /reference/print/print.md]
+* std::println[link /reference/print/println.md]
+* std::ranges::iota[link /reference/numeric/ranges_iota.md]
 
 #### 出力
 ```
@@ -202,13 +204,14 @@ int main()
     std::strided_slice{.offset=0, .extent=Int&amp;lt;5&amp;gt;, .stride=Int&amp;lt;2&amp;gt;});
   // (strided_slice::offset は戻り値型に影響を与えない)
   static_assert(std::same_as&amp;lt;decltype(submat_2x3)::extents_type, std::extents&amp;lt;size_t, 2, 3&amp;gt;&amp;gt;);
-  std::println(&amp;#34;submat_2x3 {}x{}&amp;#34;, submat_dyn.extent(0), submat_dyn.extent(1));
+  std::println(&amp;#34;submat_2x3 {}x{}&amp;#34;, submat_2x3.extent(0), submat_2x3.extent(1));
 }
 ```
 * std::submdspan[color ff0000]
+* std::strided_slice[link strided_slice.md]
 * std::integral_constant[link /reference/type_traits/integral_constant.md]
 * std::ranges::iota[link /reference/numeric/ranges_iota.md]
-* std::strided_slice[link strided_slice.md]
+* std::println[link /reference/print/println.md]
 
 #### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>submdspan_mapping_result -- mdspan: submdspan説明用エンティティ(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/submdspan_mapping_result.html"/>
      <id>7c5eb19185319d7cb2dbdee3058460d954e0d2ae:reference/mdspan/submdspan_mapping_result.md</id>
      <updated>2024-02-04T21:44:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/submdspan_mapping_result.md b/reference/mdspan/submdspan_mapping_result.md
index 667a180e8..78ec62a1c 100644
--- a/reference/mdspan/submdspan_mapping_result.md
+++ b/reference/mdspan/submdspan_mapping_result.md
@@ -14,6 +14,7 @@ namespace std {
 }
 ```
 * LayoutMapping[link LayoutMapping.md]
+* no_unique_address[link /lang/cpp20/language_support_for_empty_objects.md]
 
 ## 概要
 `submdspan_mapping_result`は、多次元配列ビュー[mdspan](mdspan.md)からの部分ビュー[`submdspan`](submdspan.md)取り出しサポートのために定義するカスタマイズポイント`submdspan_mapping`の戻り値型である。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++26 -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/lang/cpp26.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:lang/cpp26.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++26&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++26とは、2026年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中のためC++2cと呼ばれることがある。「(2020年代の3つ目のバージョンが) 202c年にリリースされる」という伏せ字として「c」が使われているが、3年周期に次のバージョンが策定されることが決まっているため、伏せ字になっている年数がずれることはない。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;変数&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/static_storage_for_braced_initializers.md.nolink&#34;&gt;&lt;code&gt;std::initializer_list&lt;/code&gt;の配列を静的ストレージに配置する&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::vector v = {1, 2, 3};&lt;/code&gt;のような初期化で初期化子リストを静的ストレージに配置することで無駄なコピーをなくす&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/nice_placeholder_with_no_name.md.nolink&#34;&gt;宣言のみで使用しない変数の名前として&lt;code&gt;_&lt;/code&gt;をサポート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;変数名&lt;code&gt;_&lt;/code&gt;は暗黙で&lt;code&gt;[[maybe_unused]]&lt;/code&gt;が指定される&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/remove_deprecated_arithmetic_conversion_on_enumerations.md.nolink&#34;&gt;非推奨となっていた列挙値から算術型への暗黙変換を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++20から非推奨となっていた列挙値への算術演算で算術型に暗黙変換される仕様を削除&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/making_non-encodable_string_literals_ill-formed.md.nolink&#34;&gt;文字列リテラルの文字エンコーディング失敗を不適格とする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルのエンコーディング時に文字表現が失われる場合にコンパイルエラーにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/unevaluated_strings.md.nolink&#34;&gt;コンパイル時にのみ使用される文字列の扱いを明確化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static_assert&lt;/code&gt;や&lt;code&gt;[[deprecated]]&lt;/code&gt;などで使用されるコンパイル時の文字列について、文字コードの指定を禁止し、実行時エンコーディングが行われないことを規定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;属性&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/on_the_ignorability_of_standard_attributes.md.nolink&#34;&gt;属性の無視性を見直し&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;構文として適格な属性のみを無視できるようにし、そうでない属性の使用を&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;とする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/pack_indexing.md.nolink&#34;&gt;パラメータパックへのインデックスアクセスを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;可変引数テンプレートのパラメータパックに添字アクセスできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定数式&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/constexpr_cast_from_voidptr.md.nolink&#34;&gt;定数式での&lt;code&gt;void*&lt;/code&gt;からポインタ型へのキャストを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型消去のために&lt;code&gt;void*&lt;/code&gt;からポインタ型へのキャストを許可する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/user-generated_static_assert_messages.md.nolink&#34;&gt;&lt;code&gt;static_assert&lt;/code&gt;の診断メッセージにユーザーが生成した文字列の指定を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;constexpr&lt;/code&gt;な&lt;code&gt;S.size()&lt;/code&gt;と&lt;code&gt;S.data()&lt;/code&gt;メンバ関数をもつオブジェクトをコンパイル時文字列として指定できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;ソースコード&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp26/add_atsign_dollar_graveaccent_to_the_basic_character_set.md.nolink&#34;&gt;基本文字集合に@、$、`を追加&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C言語との互換性のためにこれらの文字を基本文字集合に追加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字列エンコーディングを識別するライブラリとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/text_encoding.md.nolink&#34;&gt;&amp;lt;text_encoding&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;並行処理におけるデータの参照・更新を行うRCU (Read Copy Update) のライブラリとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/rcu.md.nolink&#34;&gt;&amp;lt;rcu&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;並行処理において参照中のデータが更新されないよう保護するハザードポインタのライブラリとして、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/hazard_pointer.md.nolink&#34;&gt;&amp;lt;hazard_pointer&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;デバッグサポートのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/debugging.md.nolink&#34;&gt;&amp;lt;debugging&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;線形代数ライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/linalg.md.nolink&#34;&gt;&amp;lt;linalg&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/mdspan.html&#34;&gt;std::mdspan&lt;/a&gt;&lt;/code&gt;から部分ビューを取り出す&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/submdspan.html&#34;&gt;std::submdspan()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/span/span.html&#34;&gt;std::span&lt;/a&gt;&lt;/code&gt;に、以下を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;をとるコンストラクタ&lt;/li&gt;
&lt;li&gt;インデックスアクセスのための&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/span/span/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;メンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;連想コンテナの以下のメンバ関数に、一時オブジェクトが生成されるコストを抑える拡張を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map.html&#34;&gt;std::map&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/op_at.html&#34;&gt;operator[]&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/try_emplace.html&#34;&gt;try_emplace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/map/map/insert_or_assign.html&#34;&gt;insert_or_assign()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/set/set.html&#34;&gt;std::set&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/set/set/insert.html&#34;&gt;insert()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_map.html&#34;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_at.html&#34;&gt;operator[]&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_map/at.html&#34;&gt;at()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_map/try_emplace.html&#34;&gt;try_emplace()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_map/insert_or_assign.html&#34;&gt;insert_or_assign()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_map/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_multimap.html&#34;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_set/unordered_set.html&#34;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html&#34;&gt;insert()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_set/unordered_set/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_set/unordered_multiset.html&#34;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/bucket.html&#34;&gt;bucket()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以下のアルゴリズムを&lt;code&gt;constexpr&lt;/code&gt;に対応&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/stable_sort.html&#34;&gt;std::stable_sort()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_stable_sort.html&#34;&gt;std::ranges::stable_sort()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/stable_partition.html&#34;&gt;std::stable_partition()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_stable_partition.html&#34;&gt;std::ranges::stable_partition()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/inplace_merge.html&#34;&gt;std::inplace_merge()&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/ranges_inplace_merge.html&#34;&gt;std::ranges::stable_partition()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rangeアルゴリズムが完全型を要求しないようにするため、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/projected.html&#34;&gt;std::projected&lt;/a&gt;&lt;/code&gt;の制約を緩和&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有権を保持しない&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function_ref.html&#34;&gt;std::function_ref&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/move_only_function.html&#34;&gt;std::move_only_function&lt;/a&gt;&lt;/code&gt;のコピー可能版として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional.html&#34;&gt;&amp;lt;functional&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/copyable_function.html&#34;&gt;std::copyable_function&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind_front.html&#34;&gt;std::bind_front()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind_back.md.nolink&#34;&gt;std::bind_back()&lt;/a&gt;&lt;/code&gt;に、非型テンプレート引数として関数を指定するオーバーロードを追加&lt;ul&gt;
&lt;li&gt;関連して、非型テンプレート引数の関数オブジェクトを反転させられるよう、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn()&lt;/a&gt;&lt;/code&gt;に非型テンプレート引数版のオーバーロードを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/charconv.html&#34;&gt;&amp;lt;charconv&amp;gt;&lt;/a&gt;&lt;/code&gt;の変換結果&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/charconv/to_chars_result.html&#34;&gt;std::to_chars_result&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/charconv/from_chars_result.html&#34;&gt;std::from_chars_result&lt;/a&gt;&lt;/code&gt;に、変換が正しく完了したかを判定する&lt;code&gt;operator bool&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/to_string.html&#34;&gt;std::to_string()&lt;/a&gt;&lt;/code&gt;の仕様が&lt;code&gt;std::sprintf()&lt;/code&gt;で説明されていたが、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;で定義するよう仕様を変更&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/sstream/basic_istringstream.html&#34;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;および&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/sstream/basic_ostringstream.html&#34;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;のコンストラクタおよび&lt;code&gt;str()&lt;/code&gt;メンバ関数に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を受け取るオーバーロードを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;std::format()&lt;/a&gt;&lt;/code&gt;に、以下の改善を導入&lt;ul&gt;
&lt;li&gt;ポインタ出力のサポートを追加&lt;/li&gt;
&lt;li&gt;幅と精度を動的に指定した場合でも型の検証がコンパイル時に行われるよう仕様を見直し&lt;/li&gt;
&lt;li&gt;コンパイル時の書式文字列だけでなく、実行時の書式文字列を渡せるよう仕様修正&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ファイル&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ファイルのネイティブハンドルを取得できるよう、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/fstream/basic_filebuf.html&#34;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/fstream/basic_ifstream.html&#34;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/fstream/basic_ofstream.html&#34;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/fstream/basic_fstream.html&#34;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;クラスに、以下のメンバを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;native_handle_type&lt;/code&gt;型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native_handle()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行・並列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic.html&#34;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;オブジェクトに対する2つの値の最大値・最小値を取得する関数として、メンバ関数&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/fetch_max.md.nolink&#34;&gt;fetch_max()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic/fetch_min.md.nolink&#34;&gt;fetch_min()&lt;/a&gt;&lt;/code&gt;、非メンバ関数として&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_fetch_max.md.nolink&#34;&gt;std::atomic_fetch_max&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_fetch_max_explicit.md.nolink&#34;&gt;std::atomic_fetch_max_explicit&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_fetch_min.md.nolink&#34;&gt;std::atomic_fetch_min&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/atomic/atomic_fetch_min_explicit.md.nolink&#34;&gt;std::atomic_fetch_min_explicit&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;を非順序連想コンテナのキーとして使用できるよう、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に所有権ベースのハッシュ値を取得する関数オブジェクト&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/owner_hash.md.nolink&#34;&gt;std::owner_hash&lt;/a&gt;&lt;/code&gt;、および所有権ベースの等値比較を行う関数オブジェクト&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/owner_equal.md.nolink&#34;&gt;std::owner_equal&lt;/a&gt;&lt;/code&gt;を追加&lt;ul&gt;
&lt;li&gt;関連して、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;クラスと&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;クラスのメンバ関数として、&lt;code&gt;owner_hash()&lt;/code&gt;と&lt;code&gt;owner_equal()&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;日付・時間&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下のクラスに&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;のサポートを追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/duration.html&#34;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/time_point.html&#34;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/day.html&#34;&gt;std::chrono::day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/month.html&#34;&gt;std::chrono::month&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/year.html&#34;&gt;std::chrono::year&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/weekday.html&#34;&gt;std::chrono::weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/weekday_indexed.html&#34;&gt;std::chrono::weekday_indexed&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/weekday_last.html&#34;&gt;std::chrono::weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/month_day.html&#34;&gt;std::chrono::month_day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/month_day_last.html&#34;&gt;std::chrono::month_day_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/month_weekday.html&#34;&gt;std::chrono::month_weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/month_weekday_last.html&#34;&gt;std::chrono::month_weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/year_month.html&#34;&gt;std::chrono::year_month&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/year_month_day.html&#34;&gt;std::chrono::year_month_day&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/year_month_day_last.html&#34;&gt;std::chrono::year_month_day_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/year_month_weekday.html&#34;&gt;std::chrono::year_month_weekday&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/year_month_weekday_last.html&#34;&gt;std::chrono::year_month_weekday_last&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/zoned_time.html&#34;&gt;std::chrono::zoned_time&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/chrono/leap_second.html&#34;&gt;std::chrono::leap_second&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数値&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric.html&#34;&gt;&amp;lt;numeric&amp;gt;&lt;/a&gt;&lt;/code&gt;に、飽和演算 (Saturation Arithmetic) として、型の表現可能な範囲で演算を行う以下の関数を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/add_sat.md.nolink&#34;&gt;std::add_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/sub_sat.md.nolink&#34;&gt;std::sub_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/mul_sat.md.nolink&#34;&gt;std::mul_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/div_sat.md.nolink&#34;&gt;std::div_sat()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/numeric/saturation_cast.md.nolink&#34;&gt;std::saturation_cast()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の関数を、&lt;code&gt;constexpr&lt;/code&gt;に対応 (特殊関数と、グローバルの丸めモードに依存する丸め関数以外の全て)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/cos.html&#34;&gt;std::cos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/sin.html&#34;&gt;std::sin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/tan.html&#34;&gt;std::tan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/cosh.html&#34;&gt;std::cosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/sinh.html&#34;&gt;std::sinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/tanh.html&#34;&gt;std::tanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/acos.html&#34;&gt;std::acos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/asin.html&#34;&gt;std::asin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/atan.html&#34;&gt;std::atan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/atan2.html&#34;&gt;std::atan2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/acosh.html&#34;&gt;std::acosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/asinh.html&#34;&gt;std::asinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/atanh.html&#34;&gt;std::atanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/exp.html&#34;&gt;std::exp()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/exp2.html&#34;&gt;std::exp2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/expm1.html&#34;&gt;std::expm1()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/log.html&#34;&gt;std::log()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/log10.html&#34;&gt;std::log10()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/log1p.html&#34;&gt;std::log1p()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/log2.html&#34;&gt;std::log2()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/pow.html&#34;&gt;std::pow()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/sqrt.html&#34;&gt;std::sqrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/cbrt.html&#34;&gt;std::cbrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/hypot.html&#34;&gt;std::hypot()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/erf.html&#34;&gt;std::erf()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/erfc.html&#34;&gt;std::erfc()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/lgamma.html&#34;&gt;std::lgamma()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cmath/tgamma.html&#34;&gt;std::tgamma()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex.html&#34;&gt;&amp;lt;complex&amp;gt;&lt;/a&gt;&lt;/code&gt;の以下の関数を、&lt;code&gt;constexpr&lt;/code&gt;に対応 (すべて)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/abs.html&#34;&gt;std::abs()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/arg.html&#34;&gt;std::arg()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/proj.html&#34;&gt;std::proj()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/polar.html&#34;&gt;std::polar()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/cos.html&#34;&gt;std::cos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/sin.html&#34;&gt;std::sin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/tan.html&#34;&gt;std::tan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/cosh.html&#34;&gt;std::cosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/sinh.html&#34;&gt;std::sinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/tanh.html&#34;&gt;std::tanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/acos.html&#34;&gt;std::acos()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/asin.html&#34;&gt;std::asin()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/atan.html&#34;&gt;std::atan()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/acosh.html&#34;&gt;std::acosh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/asinh.html&#34;&gt;std::asinh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/atanh.html&#34;&gt;std::atanh()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/exp.html&#34;&gt;std::exp()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/log.html&#34;&gt;std::log()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/log10.html&#34;&gt;std::log10()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/pow.html&#34;&gt;std::pow()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/sqrt.html&#34;&gt;std::sqrt()&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/norm.html&#34;&gt;std::norm()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/conj.html&#34;&gt;std::conj()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/imag_free.html&#34;&gt;std::imag()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex/real_free.html&#34;&gt;std::real()&lt;/a&gt;&lt;/code&gt; (算術型オーバーロード)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/complex/complex.html&#34;&gt;std::complex&lt;/a&gt;&lt;/code&gt;を構造化束縛や、将来のパターンマッチで使用できるようタプルインタフェースの特殊化を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;の範囲&lt;code&gt;[0, 1)&lt;/code&gt;の乱数を生成する&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/random/generate_canonical.html&#34;&gt;std::generate_canonical()&lt;/a&gt;&lt;/code&gt;を、望ましい統計的性質を保証するようアルゴリズムと制約を変更&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant.html&#34;&gt;std::variant&lt;/a&gt;&lt;/code&gt;クラスに、メンバ関数版の&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/variant/variant/visit.md.nolink&#34;&gt;visit()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ratio.html&#34;&gt;&amp;lt;ratio&amp;gt;&lt;/a&gt;&lt;/code&gt;に、新たなSI接頭辞として、以下を追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ratio/si_prefix.html&#34;&gt;ronna&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;27&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ratio/si_prefix.html&#34;&gt;ronto&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;−27&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ratio/si_prefix.html&#34;&gt;quetta&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;30&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/ratio/si_prefix.html&#34;&gt;quecto&lt;/a&gt;&lt;/code&gt; (10&lt;sup&gt;−30&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;デバッグ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/cassert/assert.html&#34;&gt;assert&lt;/a&gt;&lt;/code&gt;マクロの引数としてカンマを含む式を指定できるよう、可変引数化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;共用体のどのメンバがアクティブかを判定するための関数として、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_within_lifetime.md.nolink&#34;&gt;std::is_within_lifetime()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/bitset/bitset.html&#34;&gt;std::bitset&lt;/a&gt;&lt;/code&gt;に、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string_view/basic_string_view.html&#34;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;を受け取るコンストラクタを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の削除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++20から非推奨となっていた、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string.html&#34;&gt;std::basic_string&lt;/a&gt;::&lt;a href=&#34;https://cpprefjp.github.io/reference/string/basic_string/reserve.html&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;のパラメータなしのオーバーロードを削除&lt;/li&gt;
&lt;li&gt;C++23から非推奨となっていた、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/allocator.html&#34;&gt;std::allocator&lt;/a&gt;&lt;/code&gt;のメンバ型&lt;code&gt;is_always_equal&lt;/code&gt;を削除&lt;/li&gt;
&lt;li&gt;C++17から非推奨となっていたUnicode変換ライブラリ&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/codecvt.html&#34;&gt;&amp;lt;codecvt&amp;gt;&lt;/a&gt;&lt;/code&gt;を削除&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mdspan -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:reference/mdspan.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;mdspan&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;mdspan&lt;/span&gt;&lt;span class=&#34;cpp cpp23&#34; title=&#34;C++23で追加&#34;&gt;(C++23)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;mdspan&amp;gt;&lt;/code&gt;ヘッダでは、任意のメモリブロックに対して多次元配列のようにアクセスする機能を定義する。&lt;/p&gt;
&lt;h2&gt;多次元配列サイズ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/extents.html&#34;&gt;extents&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多次元配列のサイズを表す値 (class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/extents.html&#34;&gt;dextents&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全次元が動的な多次元配列のサイズを表す値 (alias template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;レイアウトマッピング&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/layout_left.html&#34;&gt;layout_left&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列優先(Fortran/Matlabスタイル)レイアウトマッピングポリシー (class)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/layout_right.html&#34;&gt;layout_right&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行優先(C/C++スタイル)レイアウトマッピングポリシー (class)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/layout_stride.html&#34;&gt;layout_stride&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ストライド幅指定レイアウトマッピングポリシー (class)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;要素アクセサ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/default_accessor.html&#34;&gt;default_accessor&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルト要素アクセサ (class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;多次元配列ビュー&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/mdspan.html&#34;&gt;mdspan&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多次元配列ビュー (class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;多次元配列部分ビュー&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/strided_slice.html&#34;&gt;strided_slice&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定次元のストライド指定要素取り出しを指示する集成体クラステンプレート (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/full_extent_t.html&#34;&gt;full_extent_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定次元の全要素取り出しを指示するタグ型 (class)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/full_extent_t.html&#34;&gt;full_extent&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定次元の全要素取り出しを指示するタグ値 (variable)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/submdspan_mapping_result.html&#34;&gt;submdspan_mapping_result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多次元配列部分ビューのレイアウトマッピング情報 (class template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/submdspan_extents.md.nolink&#34;&gt;submdspan_extents&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多次元配列部分ビューの多次元配列サイズを計算する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mdspan/submdspan.html&#34;&gt;submdspan&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多次元配列部分ビューを取得する (function template)&lt;/td&gt;
&lt;td&gt;C++26&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++23&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++20 &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/span.html&#34;&gt;&amp;lt;span&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r18.html&#34; target=&#34;_blank&#34;&gt;P0009R18 MDSPAN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html&#34; target=&#34;_blank&#34;&gt;P2630R4 Submdspan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>full_extent_t -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/full_extent_t.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:reference/mdspan/full_extent_t.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/full_extent_t.md b/reference/mdspan/full_extent_t.md
new file mode 100644
index 000000000..49c7336d4
--- /dev/null
+++ b/reference/mdspan/full_extent_t.md
@@ -0,0 +1,80 @@
+# full_extent_t
+* mdspan[meta header]
+* class[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  struct full_extent_t { explicit full_extent_t() = default; };
+
+  inline constexpr full_extent_t full_extent{};
+}
+```
+
+## 概要
+`full_extent_t`は、多次元配列の特定次元に対して全要素取り出しを指示するためのタグ型である。
+
+`full_extent_t`型の定数`full_extent`が提供される。
+
+
+## 例
+```cpp example
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;print&amp;gt;
+
+int main()
+{
+  int arr[] = {1, 2, 3, 4, 5, 6};
+  using Ext2x3 = std::extents&amp;lt;size_t, 2, 3&amp;gt;;
+  std::mdspan&amp;lt;int, Ext2x3&amp;gt; mat{arr};
+  // 2x3要素の2次元配列ビュー
+  // i/j -&amp;gt;
+  // |  1 2 3
+  // V  4 5 6
+
+  // i=1行を3要素の1次元ビューとして抽出
+  auto row1 = std::submdspan(mat, 1, std::full_extent);
+  std::println(&amp;#34;row[1]:&amp;#34;);
+  for (size_t i = 0; i &amp;lt; row1.extent(0); i++) {
+    std::print(&amp;#34; {}&amp;#34;, row1[i]);
+  }
+
+  // j=1列を2要素の1次元ビューとして抽出
+  auto col1 = std::submdspan(mat, std::full_extent, 1);
+  std::println(&amp;#34;\ncol[1]:&amp;#34;);
+  for (size_t i = 0; i &amp;lt; col1.extent(0); i++) {
+    std::print(&amp;#34; {}&amp;#34;, col1[i]);
+  }
+}
+```
+* std::full_extent[color ff0000]
+* std::submdspan[link submdspan.md]
+* extent[link mdspan/extent.md]
+
+### 出力
+```
+row[1]:
+ 4 5 6
+col[1]:
+ 2 5
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`submdspan`](submdspan.md)
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mapping -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/layout_left/mapping.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:reference/mdspan/layout_left/mapping.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/layout_left/mapping.md b/reference/mdspan/layout_left/mapping.md
index 82c48be20..352ea08d4 100644
--- a/reference/mdspan/layout_left/mapping.md
+++ b/reference/mdspan/layout_left/mapping.md
@@ -72,6 +72,12 @@ namespace std {
 | `layout_type` | [`layout_left`](../layout_left.md) | C++23 |
 
 
+## 非メンバ（*Hidden friends*）関数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`submdspan_mapping`](mapping/submdspan_mapping.md.nolink) | [`submdspan`](../submdspan.md)サポート | C++26 |
+
 ### 比較演算子
 
 | 名前 | 説明 | 対応バージョン |
@@ -124,7 +130,9 @@ int main()
 
 ## 関連項目
 - [`mdspan`](../mdspan.md)
+- [`submdspan`](../submdspan.md)
 
 
 ## 参照
 - [P0009R18 MDSPAN](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r18.html)
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mapping -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/layout_right/mapping.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:reference/mdspan/layout_right/mapping.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/layout_right/mapping.md b/reference/mdspan/layout_right/mapping.md
index 891bd98a8..9106e58bf 100644
--- a/reference/mdspan/layout_right/mapping.md
+++ b/reference/mdspan/layout_right/mapping.md
@@ -72,6 +72,12 @@ namespace std {
 | `layout_type` | [`layout_right`](../layout_right.md) | C++23 |
 
 
+## 非メンバ（*Hidden friends*）関数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`submdspan_mapping`](mapping/submdspan_mapping.md.nolink) | [`submdspan`](../submdspan.md)サポート | C++26 |
+
 ### 比較演算子
 
 | 名前 | 説明 | 対応バージョン |
@@ -124,7 +130,9 @@ int main()
 
 ## 関連項目
 - [`mdspan`](../mdspan.md)
+- [`submdspan`](../submdspan.md)
 
 
 ## 参照
 - [P0009R18 MDSPAN](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r18.html)
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mapping -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/layout_stride/mapping.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:reference/mdspan/layout_stride/mapping.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/layout_stride/mapping.md b/reference/mdspan/layout_stride/mapping.md
index ee1d46372..5907bf367 100644
--- a/reference/mdspan/layout_stride/mapping.md
+++ b/reference/mdspan/layout_stride/mapping.md
@@ -74,6 +74,12 @@ namespace std {
 | `layout_type` | [`layout_stride`](../layout_stride.md) | C++23 |
 
 
+## 非メンバ（*Hidden friends*）関数
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|----------------|
+| [`submdspan_mapping`](mapping/submdspan_mapping.md.nolink) | [`submdspan`](../submdspan.md)サポート | C++26 |
+
 ### 比較演算子
 
 | 名前 | 説明 | 対応バージョン |
@@ -128,7 +134,9 @@ int main()
 
 ## 関連項目
 - [`mdspan`](../mdspan.md)
+- [`submdspan`](../submdspan.md)
 
 
 ## 参照
 - [P0009R18 MDSPAN](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r18.html)
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>strided_slice -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/strided_slice.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:reference/mdspan/strided_slice.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/strided_slice.md b/reference/mdspan/strided_slice.md
new file mode 100644
index 000000000..6ab21722b
--- /dev/null
+++ b/reference/mdspan/strided_slice.md
@@ -0,0 +1,115 @@
+# strided_slice
+* mdspan[meta header]
+* class template[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class OffsetType, class ExtentType, class StrideType&amp;gt;
+  struct strided_slice {
+    using offset_type = OffsetType;
+    using extent_type = ExtentType;
+    using stride_type = StrideType;
+
+    [[no_unique_address]] offset_type offset{};
+    [[no_unique_address]] extent_type extent{};
+    [[no_unique_address]] stride_type stride{};
+  };
+}
+```
+
+## 概要
+`strided_slice`は、多次元配列の特定次元に対してストライド幅を指定した要素取り出しを指示する集成体クラステンプレートである。
+
+初期化時にメンバ変数名を明記する[指示付き初期化](/lang/cpp20/designated_initialization.md)をサポートし、テンプレートパラメータは[テンプレート引数推論](/lang/cpp20/class_template_argument_deduction_for_aggregates.md)の利用を想定した設計となっている。
+
+- `offset` : 元の多次元配列におけるオフセット
+- `extent` : 元の多次元配列における要素数
+- `stride` : 要素取り出しストライド幅
+
+```cpp
+// オフセット=1, 要素数=10, ストライド幅=3
+std::strided_slice{.offset=1, .extent=10, .stride=3}
+```
+
+
+## 適格要件
+`OffsetType`, `ExtentType`, `StrideType`は符号付き整数型または符号無し整数型、もしくは[`integral-constant-like`](integral-constant-like.md.nolink)のモデルであること。
+
+
+## メンバ型
+
+| 名前 | 説明 | 対応バージョン |
+|------|------|-------|
+| `offset_type` | `offset`の型 | C++26 |
+| `extent_type` | `extent`の型 | C++26 |
+| `stride_type` | `stride`の型 | C++26 |
+
+
+## 例
+```cpp example
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;numeric&amp;gt;
+
+int main()
+{
+  // 12要素の1次元配列ビュー
+  int arr[12];
+  std::ranges::iota(arr, 0);
+  std::mdspan vec0{arr};
+
+  // オフセット位置1から10要素の範囲よりストライド幅3で要素抽出
+  auto vec1 = std::submdspan(vec0, std::strided_slice{1, 10, 3});
+  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
+  //    ^  .  .  ^  .  .  ^   .  .  ^
+  std::println(&amp;#34;vec1:&amp;#34;);
+  for (size_t i = 0; i &amp;lt; vec1.extent(0); i++) {
+    std::print(&amp;#34; {}&amp;#34;, vec1[i]);
+  }
+
+  // オフセット位置0から12要素の範囲よりストライド幅4で要素抽出（指示付き初期化を利用）
+  auto vec2 = std::submdspan(vec0,
+    std::strided_slice{.offset=0, .extent=12, .stride=4});
+  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
+  // ^  .  .  .  ^  .  .  .  ^  .   .   .
+  std::println(&amp;#34;\nvec2:&amp;#34;);
+  for (size_t i = 0; i &amp;lt; vec2.extent(0); i++) {
+    std::print(&amp;#34; {}&amp;#34;, vec2[i]);
+  }
+}
+```
+* std::strided_slice[color ff0000]
+* std::ranges::iota[link /reference/numeric/ranges_iota.md]
+* std::submdspan[link submdspan.md]
+* extent[link mdspan/extent.md]
+
+### 出力
+```
+vec1:
+ 1 4 7 10
+vec2:
+ 0 4 8
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`submdspan`](submdspan.md)
+- [C++20 指示付き初期化](/lang/cpp20/designated_initialization.md)
+- [C++20 集成体クラステンプレートのテンプレート引数推論](/lang/cpp20/class_template_argument_deduction_for_aggregates.md)
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>submdspan -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/submdspan.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:reference/mdspan/submdspan.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/submdspan.md b/reference/mdspan/submdspan.md
new file mode 100644
index 000000000..db055f288
--- /dev/null
+++ b/reference/mdspan/submdspan.md
@@ -0,0 +1,284 @@
+# submdspan
+* mdspan[meta header]
+* function template[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;
+    class ElementType,
+    class Extents,
+    class LayoutPolicy,
+    class AccessorPolicy,
+    class... SliceSpecifiers&amp;gt;
+  constexpr auto submdspan(
+    const mdspan&amp;lt;ElementType, Extents, LayoutPolicy, AccessorPolicy&amp;gt;&amp;amp; src,
+    SliceSpecifiers... slices) -&amp;gt; see below;
+}
+```
+* Extents[link extents.md]
+* LayoutPolicy[link LayoutMappingPolicy.md]
+* AccessorPolicy[link AccessorPolicy.md]
+* mdspan[link mdspan.md]
+* see below[italic]
+
+## 概要
+多次元配列ビュー[`mdspan`](mdspan.md)と各次元からの要素取り出し（スライス）方式を指定して、メモリブロックに対する新しい多次元配列ビュー[`mdspan`](mdspan.md)を取得する。
+
+### スライス指定
+各次元からの要素取り出し方式は、下記の4種類をサポートする。
+スライス指定子リスト`slices...`にインデクス値指定が含まれる場合、戻り値の次元数(rank)は元の多次元配列ビューに対してインデクス値指定した次元数だけ削減される。
+
+- インデクス値指定 : 整数値。指定次元に対する多次元インデクス値を固定する。
+- インデクス範囲指定 : [インデクス・ペア互換型](index-pair-like.md.nolink)の値。開始位置(begin)と終了位置(end)で表現される半開区間から要素群を取り出す。
+- ストライド・スライス指定 : [`std::strided_slice`](strided_slice.md)の値。オフセット(offset)と要素数(extent)とストライド幅(stride)で指定される要素群を取り出す。
+- 全要素指定 : [`std::full_extent`](full_extent_t.md)。指定次元の全要素を取り出す。
+
+
+## テンプレートパラメータ制約
+- `sizeof...(slices)`が[`Extents::rank()`](extents/rank.md)と等しく、かつ
+- 評価されない文脈において式`submdspan_mapping(`[`src.mapping()`](mdspan/mapping.md)`, slices...)`が妥当な式であること。
+
+
+## 適格要件
+説明用の型`index_type`を[`Extents::index_type`](extents.md)、変数`sub_map_offset`を`submdspan_mapping(`[`src.mapping()`](mdspan/mapping.md)`, slices...)`の結果としたとき、
+
+- 型`decltype(submdspan_mapping(`[`src.mapping()`](mdspan/mapping.md)`, slices...))`が[`submdspan_mapping_result`](submdspan_mapping_result.md)の特殊化であり、
+- [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;decltype(`[`sub_map_offset.mapping`](submdspan_mapping_result.md)`.extents())&amp;gt;, decltype(`[`submdspan_extents`](submdspan_extents.md.nolink)`(`[`src.mapping()`](mdspan/mapping.md)`, slices...))&amp;gt;`が`true`、かつ
+- [`src.extents()`](mdspan/extents.md)の各次元インデクス`k`において、`S_k`を`SliceSpecifiers`の`k`番目の型としたき、下記いずれかの1つのみを満たすこと。
+    - 型`S_k`が[`convertible_to`](/reference/concepts/convertible_to.md)`&amp;lt;index_type&amp;gt;`のモデル
+    - 型`S_k`が[`index-pair-like`](index-pair-like.md.nolink)`&amp;lt;index_type&amp;gt;`のモデル
+    - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;S_k,` [`full_extent_t`](full_extent_t.md)`&amp;gt;`が`true`
+    - 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化
+
+
+## 事前条件
+- [`src.extents()`](mdspan/extents.md)の各次元インデクス`k`において、`S_k`を`SliceSpecifiers`の`k`番目の型、`s_k`を`slices`の`k`番目の値としたとき、下記を全て満たすこと。
+    - 型`S_k`が[`strided_slice`](strided_slice.md)の特殊化のとき
+        - `s_k.extent == 0`、または
+        - `s_k.stride &amp;gt; 0`
+    - `0` ≤ [`first_&amp;lt;index_type, k&amp;gt;`](first_.md.nolink)`(slices...)` ≤ [`last_&amp;lt;k&amp;gt;`](last_.md.nolink)`(`[`src.extents()`](mdspan/extents.md)`, slices...)` ≤ [`src.extent(k)`](mdspan/extent.md)
+- [`sub_map_offset.mapping`](submdspan_mapping_result.md)`.extents() ==` [`submdspan_extents`](submdspan_extents.md.nolink)`(`[`src.mapping()`](mdspan/mapping.md)`, slices...)`が`true`、かつ
+- [`sub_map_offset.mapping`](submdspan_mapping_result.md)`.extents()`の多次元インデクス値を表す任意の整数パック`I`に対して、`sub_map_offset.mapping(I...) +` [`sub_map_offset.offset`](submdspan_mapping_result.md) `==` [`src.mapping()`](mdspan/mapping.md)`(`[`src-indices`](src-indices.md.nolink)`(`[`array`](/reference/array/array.md)`{I...}, slices...))`が`true`であること。
+
+
+## 効果
+以下と等価
+
+```cpp
+auto sub_map_offset = submdspan_mapping(src.mapping(), slices...);
+return mdspan(src.accessor().offset(src.data(), sub_map_offset.offset),
+              sub_map_offset.mapping,
+              AccessorPolicy::offset_policy(src.accessor()));
+```
+* mdspan[link mdspan.md]
+* sub_map_offset[link submdspan_mapping_result.md]
+* src.mapping()[link mdspan/mapping.md]
+* src.accessor()[link mdspan/accessor.md]
+* AccessorPolicy::offset_policy[link AccessorPolicy.md]
+
+
+## 例
+### 基本的な使い方
+```cpp example
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;numeric&amp;gt;
+#include &amp;lt;print&amp;gt;
+#include &amp;lt;string_view&amp;gt;
+
+// 2次元配列ビュー(Matrix)の要素表示
+template &amp;lt;class T, class E, class L, class A&amp;gt;
+void print_mat(std::string_view name, const std::mdspan&amp;lt;T, E, L, A&amp;gt;&amp;amp; mat)
+{
+  static_assert(mat.rank() == 2);
+  std::println(&amp;#34;{}:&amp;#34;, name);
+  for (size_t i = 0; i &amp;lt; mat.extent(0); ++i) {
+    for (size_t j = 0; j &amp;lt; mat.extent(1); ++j) {
+      std::print(&amp;#34; {:2}&amp;#34;, mat[i, j]);
+    }
+    std::println(&amp;#34;&amp;#34;);
+  }
+}
+
+// 1次元配列ビュー(Vector)の要素表示
+template &amp;lt;class T, class E, class L, class A&amp;gt;
+void print_vec(std::string_view name, const std::mdspan&amp;lt;T, E, L, A&amp;gt;&amp;amp; mat)
+{
+  static_assert(mat.rank() == 1);
+  std::println(&amp;#34;{}:&amp;#34;, name);
+  for (size_t i = 0; i &amp;lt; mat.extent(0); ++i) {
+    std::print(&amp;#34; {:2}&amp;#34;, mat[i]);
+  }
+  std::println(&amp;#34;&amp;#34;);
+}
+
+int main()
+{
+  int arr[20];
+  std::ranges::iota(arr, 1);
+
+  // 4x5要素の2次元配列ビュー
+  using Ext2D = std::dextents&amp;lt;size_t, 2&amp;gt;;
+  std::mdspan mat{arr, Ext2D{4, 5}};
+  print_mat(&amp;#34;mat&amp;#34;, mat);
+
+  // インデクス値指定＋全要素指定（2次元→1次元）
+  auto row1 = std::submdspan(mat, 1, std::full_extent);
+  print_vec(&amp;#34;mat[1,M]&amp;#34;, row1);
+  auto col2 = std::submdspan(mat, std::full_extent, 2);
+  print_vec(&amp;#34;mat[N,2]&amp;#34;, col2);
+
+  // 単一要素の取り出し（2次元→0次元）
+  auto elem = std::submdspan(mat, 1, 2);
+  std::println(&amp;#34;mat[1,2]:\n {:2}&amp;#34;, elem[]);
+
+  // インデクス範囲指定
+  auto submat = std::submdspan(mat, std::pair{1,3}, std::pair{1,4});
+  print_mat(&amp;#34;submat&amp;#34;, submat);
+
+  // ストライド・スライス指定
+  auto strided = std::submdspan(mat,
+    std::strided_slice{.offset=1, .extent=3, .stride=2}, 
+    std::strided_slice{.offset=0, .extent=5, .stride=2});
+  print_mat(&amp;#34;strided&amp;#34;, strided);
+}
+```
+* std::submdspan[color ff0000]
+* std::ranges::iota[link /reference/numeric/ranges_iota.md]
+* std::full_extent[link full_extent_t.md]
+* std::strided_slice[link strided_slice.md]
+
+#### 出力
+```
+mat:
+  1  2  3  4  5
+  6  7  8  9 10
+ 11 12 13 14 15
+ 16 17 18 19 20
+mat[1,M]:
+  6  7  8  9 10
+mat[N,2]:
+  3  8 13 18
+mat[1,2]:
+  8
+submat:
+  7  8  9
+ 12 13 14
+strided:
+  6  8 10
+ 16 18 20
+```
+
+### 静的要素数mdspanの生成
+```cpp example
+#include &amp;lt;concepts&amp;gt;
+#include &amp;lt;mdspan&amp;gt;
+#include &amp;lt;numeric&amp;gt;
+#include &amp;lt;print&amp;gt;
+
+// 整数定数型
+template &amp;lt;int N&amp;gt;
+constexpr auto Int = std::integral_constant&amp;lt;int, N&amp;gt;{};
+
+int main()
+{
+  int arr[20];
+  std::ranges::iota(arr, 1);
+
+  // 静的要素数 4x5 の2次元配列ビュー
+  std::mdspan mat{arr, std::extents&amp;lt;size_t, 4, 5&amp;gt;{}};
+
+  // 動的要素数 2x3 の2次元配列部分ビューを取り出し
+  auto submat_dyn = std::submdspan(mat,
+    std::pair{1, 3},
+    std::strided_slice{.offset=0, .extent=5, .stride=2});
+  static_assert(std::same_as&amp;lt;decltype(submat_dyn)::extents_type, std::dextents&amp;lt;size_t, 2&amp;gt;&amp;gt;);
+  std::println(&amp;#34;submat_dyn {}x{}&amp;#34;, submat_dyn.extent(0), submat_dyn.extent(1));
+
+  // 静的要素数 2x3 の2次元配列部分ビューを取り出し
+  auto submat_2x3 = std::submdspan(mat,
+    std::pair{Int&amp;lt;1&amp;gt;, Int&amp;lt;3&amp;gt;},
+    std::strided_slice{.offset=0, .extent=Int&amp;lt;5&amp;gt;, .stride=Int&amp;lt;2&amp;gt;});
+  // (strided_slice::offset は戻り値型に影響を与えない)
+  static_assert(std::same_as&amp;lt;decltype(submat_2x3)::extents_type, std::extents&amp;lt;size_t, 2, 3&amp;gt;&amp;gt;);
+  std::println(&amp;#34;submat_2x3 {}x{}&amp;#34;, submat_dyn.extent(0), submat_dyn.extent(1));
+}
+```
+* std::submdspan[color ff0000]
+* std::integral_constant[link /reference/type_traits/integral_constant.md]
+* std::ranges::iota[link /reference/numeric/ranges_iota.md]
+* std::strided_slice[link strided_slice.md]
+
+#### 出力
+```
+submat_dyn 2x3
+submat_2x3 2x3
+```
+
+### レイアウトマッピング互換性
+```cpp example
+#include &amp;lt;mdspan&amp;gt;
+
+int main()
+{
+  int arr[6] = {1, 2, 3, 4, 5, 6};
+
+  // 3x2要素の2次元配列ビュー（行優先レイアウト）
+  std::mdspan mat{arr, std::extents&amp;lt;size_t, 3, 2&amp;gt;{}};
+  static_assert(std::same_as&amp;lt;decltype(mat)::layout_type, std::layout_right&amp;gt;);
+  // 1 2
+  // 3 4
+  // 5 6
+
+  // 行優先レイアウト std::layout_right　を維持
+  auto row0 = std::submdspan(mat, 0, std::full_extent);
+  // 1 2
+  auto row12 = std::submdspan(mat, std::pair{1,3}, std::full_extent);
+  // 3 4
+  // 5 6
+  static_assert(std::same_as&amp;lt;decltype(row0)::layout_type, std::layout_right&amp;gt;);
+  static_assert(std::same_as&amp;lt;decltype(row12)::layout_type, std::layout_right&amp;gt;);
+
+  // 汎用ストライド指定レイアウト std::layout_stride に変換
+  auto col1 = std::submdspan(mat, std::full_extent, 1);
+  // 2 4 6
+  auto row02 = std::submdspan(mat,
+    std::strided_slice{.offset=0, .extent=3, .stride=2},
+    std::full_extent);
+  // 1 2
+  // 5 6
+  static_assert(std::same_as&amp;lt;decltype(col1)::layout_type, std::layout_stride&amp;gt;);
+  static_assert(std::same_as&amp;lt;decltype(row02)::layout_type, std::layout_stride&amp;gt;);
+}
+```
+* std::submdspan[color ff0000]
+* std::full_extent[link full_extent_t.md]
+* std::strided_slice[link strided_slice.md]
+* std::layout_right[link layout_right.md]
+* std::layout_stride[link layout_stride.md]
+
+#### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`mdspan`](mdspan.md)
+- [`full_extent`](full_extent_t.md)
+- [`strided_slice`](strided_slice.md)
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>submdspan_mapping_result -- mdspan: submdspan概要(#1201)</title>
      <link href="https://cpprefjp.github.io/reference/mdspan/submdspan_mapping_result.html"/>
      <id>5d7347170fc0f7d3edc39aca553bb9c5d2373fd5:reference/mdspan/submdspan_mapping_result.md</id>
      <updated>2024-02-04T17:48:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/mdspan/submdspan_mapping_result.md b/reference/mdspan/submdspan_mapping_result.md
new file mode 100644
index 000000000..667a180e8
--- /dev/null
+++ b/reference/mdspan/submdspan_mapping_result.md
@@ -0,0 +1,45 @@
+# submdspan_mapping_result
+* mdspan[meta header]
+* class template[meta id-type]
+* std[meta namespace]
+* cpp26[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;class LayoutMapping&amp;gt;
+  struct submdspan_mapping_result {
+    [[no_unique_address]] LayoutMapping mapping = LayoutMapping();
+    size_t offset{};
+  };
+}
+```
+* LayoutMapping[link LayoutMapping.md]
+
+## 概要
+`submdspan_mapping_result`は、多次元配列ビュー[mdspan](mdspan.md)からの部分ビュー[`submdspan`](submdspan.md)取り出しサポートのために定義するカスタマイズポイント`submdspan_mapping`の戻り値型である。
+
+- `mapping` : 多次元配列部分ビューの[レイアウトマッピング](LayoutMapping.md)
+- `offset` : 多次元配列部分ビューの要素オフセット位置
+
+
+## 適格要件
+`LayoutMapping`は[レイアウトマッピング要件](LayoutMapping.md)を満たすこと。
+
+
+## バージョン
+### 言語
+- C++26
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`submdspan`](submdspan.md)
+
+
+## 参照
+- [P2630R4 Submdspan](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2630r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>