<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-03-25T08:30:13.667272</updated>
  <id>38c9bb66-78ac-48bc-a2bb-a1c484651c39</id>

  
    <entry>
      <title>C++23 -- C++23 : s/定義/追加/</title>
      <link href="https://cpprefjp.github.io/lang/cpp23.html"/>
      <id>d0b75459aca53c40a9cbdbf99848f77f0750bfef:lang/cpp23.md</id>
      <updated>2020-03-25T17:26:28+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++23&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++23とは、2023年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/contract-based_programming.html&#34;&gt;契約に基づくプログラミング&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;事前条件、事後条件、表明を宣言する新たな属性構文を追加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;契約違反のハンドリングをするためのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/contract.html&#34;&gt;&amp;lt;contract&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/owner_hash.md.nolink&#34;&gt;std::owner_hash&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/owner_equal.md.nolink&#34;&gt;std::owner_equal&lt;/a&gt;&lt;/code&gt;が追加され、非順序連想コンテナのキーとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;を使用できるようになった&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、第1テンプレート引数についている型修飾を第2テンプレート引数の型に付加する型特性として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_const.md.nolink&#34;&gt;std::copy_const&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_volatile.md.nolink&#34;&gt;std::copy_volatile&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_cv.md.nolink&#34;&gt;std::copy_cv&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_reference.md.nolink&#34;&gt;std::copy_reference&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_extent.md.nolink&#34;&gt;std::copy_extent&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_all_extents.md.nolink&#34;&gt;std::copy_all_extents&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_pointer.md.nolink&#34;&gt;std::copy_pointer&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_all_pointers.md.nolink&#34;&gt;std::copy_all_pointers&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_cvref.md.nolink&#34;&gt;std::copy_cvref&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、第1テンプレート引数についている型修飾を外す型特性として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_all_pointers.md.nolink&#34;&gt;std::remove_all_pointers&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;std::algined_storage&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;std::aligned_union&lt;/a&gt;&lt;/code&gt;を非推奨化。これらの機能は未定義動作を引き起こし、間違った保証が行われ、よくないAPI設計が行われていたため、非推奨となる。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;std::algined_storage&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;alignas(T) &lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;[sizeof(T)];&lt;/code&gt;を使用することを推奨する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;std::aligned_union&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;alignas(Ts...) &lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;[&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/max.html&#34;&gt;std::max&lt;/a&gt;({sizeof(Ts)...})];&lt;/code&gt;を使用することを推奨する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>aligned_storage -- aligned_storage, aligned_union : C++23での非推奨化に対応</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/aligned_storage.html"/>
      <id>335b2476d07cb9b89a8bfaabc538147aafba953d:reference/type_traits/aligned_storage.md</id>
      <updated>2020-03-25T17:10:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/aligned_storage.md b/reference/type_traits/aligned_storage.md
index 550a7c960..d3e5b24b5 100644
--- a/reference/type_traits/aligned_storage.md
+++ b/reference/type_traits/aligned_storage.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * class template[meta id-type]
 * cpp11[meta cpp]
+* cpp23deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -10,15 +11,18 @@ namespace std {
             std::size_t Align = default-alignment&amp;gt;
   struct aligned_storage {
     using type = …;
-  };
+  };                                                                   // (1) C++11
 
   template &amp;lt;std::size_t Len,
             std::size_t Align = default-alignment&amp;gt;
-  using aligned_storage_t = typename aligned_storage&amp;lt;Len,Align&amp;gt;::type; // C++14
+  using aligned_storage_t = typename aligned_storage&amp;lt;Len,Align&amp;gt;::type; // (2) C++14
 }
 ```
 * default-alignment[italic]
 
+この機能はC++23で非推奨となった。代わりに`alignas(T)` [`std::byte`](/reference/cstddef/byte.md)`[sizeof(T)];`を使用することを推奨する。
+
+
 ## 概要
 アライメント調整された領域を作る。
 
@@ -34,6 +38,39 @@ namespace std {
 `Align`のデフォルト値は、`Len`よりも大きくない、最も厳格なアライメント要件を持つ、C++の何らかのオブジェクト型のアラインメント値。
 
 
+## 非推奨の詳細 (C++23)
+この機能は、いくつかの点で高いレベルの有害になりえる：
+
+- この機能を呼び出すことで未定義動作を引き起こす (この型はストレージを提供するわけではない)
+- 保証が正しくない (標準では、型が少なくとも要求された以上の大きさであることのみを要件としているだけで、上限サイズを要求できない)
+- APIが多くの理由で間違っている。そのためにこのAPIを使うために繰り返し同じ事前作業が必要になる。API設計が間違っている理由は以下：
+    - `::type`の値にアクセスするために`reinterpret_cast`が必要となってしまう。これによって`constexpr`で使用できず、未定義動作を引き起こせてしまう
+    - C++14で導入された`aligned_storage_t`ではなく誤って`aligned_storage`を使用してしまい、その違いに気づきにくい (`aligned_storage`は`::type`を指定しなければならない)
+    - 少なくともNバイト以上という指定はできるが、実際のサイズ (上限サイズ) を指定できないため、必要以上のメモリが使用される可能性がある
+
+これらの問題は[`aligned_union`](aligned_union.md)も同様だが、とくに`aligned_storage`では以下のような問題がある：
+
+- テンプレートパラメータとして型をとらず、サイズをとってしまっている
+    - この機能は非常に稀な状況を除いて、`Align`パラメータは`Len`パラメータに対して決まった指定の仕方をする。第1テンプレート引数として`sizeof(T)`を指定するのであれば、第2テンプレート引数には`alignof(T)`を指定しなければならない。`typename aligned_storage&amp;lt;sizeof(T), alignof(T)&amp;gt;::type`
+- 第2テンプレートパラメータにデフォルト引数が設定されている
+    - このテンプレートパラメータは本来必要ないだけでなく、デフォルト引数が付けられてしまっている。コンパイラが`aligned_storage_t&amp;lt;sizeof(T)&amp;gt;`という使い方をやめさせる方法はない。第2テンプレートパラメータは実装定義のデフォルト値をもつが、`T`に対して十分な場合とそうでない場合がある。そのため、暗黙に不正確になることを許可してしまっている
+
+Facebookの`folly::aligned_storage_for_t`はこれらの問題を解決している。
+
+この機能を以下のように置き換えることを推奨する：
+
+```diff
+template &amp;lt;typename T&amp;gt;
+class MyContainer {
+  // [...]
+private:
+- std::aligned_storage_t&amp;lt;sizeof(T), alignof(T)&amp;gt; t_buff;
++ alignas(T) std::byte t_buff[sizeof(T)];
+  // [...]
+};
+```
+
+
 ## 例
 ### スタック領域を使用するコンテナ実装の例 (C++11)
 ```cpp example
@@ -168,4 +205,6 @@ int main()
 ## 参照
 - [N3546 TransformationTraits Redux](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3546.pdf)
 - [N3655 TransformationTraits Redux, v2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf)
-
+    - C++14で`aligned_storage_t`が定義された
+- [P1413R2 Deprecate `std::aligned_storage` and `std::aligned_union`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1413r2.pdf)
+    - C++23でこの機能が非推奨となった
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>aligned_union -- aligned_storage, aligned_union : C++23での非推奨化に対応</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/aligned_union.html"/>
      <id>335b2476d07cb9b89a8bfaabc538147aafba953d:reference/type_traits/aligned_union.md</id>
      <updated>2020-03-25T17:10:17+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/aligned_union.md b/reference/type_traits/aligned_union.md
index c8f94ee03..17110c845 100644
--- a/reference/type_traits/aligned_union.md
+++ b/reference/type_traits/aligned_union.md
@@ -3,6 +3,7 @@
 * std[meta namespace]
 * class template[meta id-type]
 * cpp11[meta cpp]
+* cpp23deprecated[meta cpp]
 
 ```cpp
 namespace std {
@@ -11,13 +12,16 @@ namespace std {
   struct aligned_union {
     using type = …;
     static constexpr std::size_t alignment_value = …;
-  };
+  };                                                                  // (1) C++11
 
   template &amp;lt;std::size_t Len, class... Types&amp;gt;
-  using aligned_union_t = typename aligned_union&amp;lt;Len,Types...&amp;gt;::type; // C++14
+  using aligned_union_t = typename aligned_union&amp;lt;Len,Types...&amp;gt;::type; // (2) C++14
 }
 ```
 
+この機能はC++23で非推奨となった。代わりに`alignas(Ts...)` [`std::byte`](/reference/cstddef/byte.md)`[`[`std::max`](/reference/algorithm/max.md)`({sizeof(Ts)...})];`を使用することを推奨する。
+
+
 ## 概要
 アライメント調整された共用体領域を作る。
 
@@ -32,6 +36,26 @@ namespace std {
 
 また、`Types...`全ての厳格なアライメント値を、[`std::size_t`](/reference/cstddef/size_t.md)型の静的メンバ定数`alignment_value`として定義する。
 
+
+## 非推奨の詳細 (C++23)
+この機能は、いくつかの点で高いレベルの有害になりえる：
+
+- この機能を呼び出すことで未定義動作を引き起こす (この型はストレージを提供するわけではない)
+- 保証が正しくない (標準では、型が少なくとも要求された以上の大きさであることのみを要件としているだけで、上限サイズを要求できない)
+- APIが多くの理由で間違っている。そのためにこのAPIを使うために繰り返し同じ事前作業が必要になる。API設計が間違っている理由は以下：
+    - `::type`の値にアクセスするために`reinterpret_cast`が必要となってしまう。これによって`constexpr`で使用できず、未定義動作を引き起こせてしまう
+    - C++14で導入された`aligned_union_t`ではなく誤って`aligned_union`を使用してしまい、その違いに気づきにくい (`aligned_union`は`::type`を指定しなければならない)
+    - 少なくともNバイト以上という指定はできるが、実際のサイズ (上限サイズ) を指定できないため、必要以上のメモリが使用される可能性がある
+
+これらの問題は[`aligned_storage`](aligned_storage.md)も同様である。`aligned_union`固有の問題はそれほどひどくないが、それでも望ましくない以下のような問題がある：
+
+- 第1テンプレートパラメータが無意味
+    - この機能は、可変個のすべての型のサイズとアライメントを推論し、それらの最大値を実際のストレージとして使用する。先頭のテンプレートパラメータはストレージの最小サイズである。すべての型がそれより小さい場合でも、ストレージは第1テンプレートパラメータより小さくならない
+    - 最小サイズを必要とすることはめずらしいことであり、ほとんどの場合は`aligned_union_t&amp;lt;0、Ts...&amp;gt;`のように使用する。この引数`0`は機能に精通していなければ理解しにくい
+- サイズとアライメントの推論が[`aligned_storage`](aligned_storage.md)と一貫していない
+    - 一貫した仕様であるならば、`aligned_union_t&amp;lt;0、T&amp;gt;`のような型をひとつだけ指定する用途につながるが、現在の仕様は何を意図していたのか不明である
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -83,4 +107,7 @@ hello
 - [N1877 Adding Alignment Support to the C++ Programming Language](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1877.pdf)
 - [N3546 TransformationTraits Redux](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3546.pdf)
 - [N3655 TransformationTraits Redux, v2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf)
+    - C++14で`aligned_union_t`が定義された
 - [LWG Issue 2979. `aligned_union` should require complete object types](https://wg21.cmeerw.net/lwg/issue2979)
+- [P1413R2 Deprecate `std::aligned_storage` and `std::aligned_union`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1413r2.pdf)
+    - C++23でこの機能が非推奨となった
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++23 -- C++23 : いくつかの導入が決まった変更を追加 #742</title>
      <link href="https://cpprefjp.github.io/lang/cpp23.html"/>
      <id>0b34bbd122fbcc61640d3df7360fdacaa9049f01:lang/cpp23.md</id>
      <updated>2020-03-25T17:09:26+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++23&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++23とは、2023年中に改訂される予定の、C++バージョンの通称である。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://cpprefjp.github.io/lang/cpp23/contract-based_programming.html&#34;&gt;契約に基づくプログラミング&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;事前条件、事後条件、表明を宣言する新たな属性構文を追加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;新ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;契約違反のハンドリングをするためのライブラリとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/contract.html&#34;&gt;&amp;lt;contract&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;スマートポインタ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory.html&#34;&gt;&amp;lt;memory&amp;gt;&lt;/a&gt;&lt;/code&gt;に&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/owner_hash.md.nolink&#34;&gt;std::owner_hash&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/owner_equal.md.nolink&#34;&gt;std::owner_equal&lt;/a&gt;&lt;/code&gt;が定義され、非順序連想コンテナのキーとして&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/memory/weak_ptr.html&#34;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;を使用できるようになった&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;型特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、第1テンプレート引数についている型修飾を第2テンプレート引数の型に付加する型特性として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_const.md.nolink&#34;&gt;std::copy_const&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_volatile.md.nolink&#34;&gt;std::copy_volatile&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_cv.md.nolink&#34;&gt;std::copy_cv&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_reference.md.nolink&#34;&gt;std::copy_reference&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_extent.md.nolink&#34;&gt;std::copy_extent&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_all_extents.md.nolink&#34;&gt;std::copy_all_extents&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_pointer.md.nolink&#34;&gt;std::copy_pointer&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_all_pointers.md.nolink&#34;&gt;std::copy_all_pointers&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/copy_cvref.md.nolink&#34;&gt;std::copy_cvref&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;に、第1テンプレート引数についている型修飾を外す型特性として、以下を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_all_pointers.md.nolink&#34;&gt;std::remove_all_pointers&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;機能の非推奨化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;std::algined_storage&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;std::aligned_union&lt;/a&gt;&lt;/code&gt;を非推奨化。これらの機能は未定義動作を引き起こし、間違った保証が行われ、よくないAPI設計が行われていたため、非推奨となる。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_storage.html&#34;&gt;std::algined_storage&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;alignas(T) &lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;[sizeof(T)];&lt;/code&gt;を使用することを推奨する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/aligned_union.html&#34;&gt;std::aligned_union&lt;/a&gt;&lt;/code&gt;の代わりに&lt;code&gt;alignas(Ts...) &lt;a href=&#34;https://cpprefjp.github.io/reference/cstddef/byte.html&#34;&gt;std::byte&lt;/a&gt;[&lt;a href=&#34;https://cpprefjp.github.io/reference/algorithm/max.html&#34;&gt;std::max&lt;/a&gt;({sizeof(Ts)...})];&lt;/code&gt;を使用することを推奨する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copyable -- copyable : 表記の一貫性の改善</title>
      <link href="https://cpprefjp.github.io/reference/concepts/copyable.html"/>
      <id>b91f2e7e85f22f9cdcd922e3a39ebf18366f3a84:reference/concepts/copyable.md</id>
      <updated>2020-03-25T16:42:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/copyable.md b/reference/concepts/copyable.md
index 674594a70..2d6aa4e4a 100644
--- a/reference/concepts/copyable.md
+++ b/reference/concepts/copyable.md
@@ -7,8 +7,12 @@
 ```cpp
 namespace std {
   template&amp;lt;class T&amp;gt;
-  concept copyable = copy_constructible&amp;lt;T&amp;gt; &amp;amp;&amp;amp; movable&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
-                     assignable_from&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt; &amp;amp;&amp;amp; assignable_from&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt; &amp;amp;&amp;amp; assignable_from&amp;lt;T&amp;amp;, const T&amp;gt;;
+  concept copyable =
+    copy_constructible&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
+    movable&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
+    assignable_from&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+    assignable_from&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt; &amp;amp;&amp;amp;
+    assignable_from&amp;lt;T&amp;amp;, const T&amp;gt;;
 }
 ```
 * assignable_from[link /reference/concepts/assignable_from.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>concepts -- &lt;concepts&gt;関連の追加文書やIssueの対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts.html"/>
      <id>6764512d3955dbaa3a1d009af10f8d7f48415019:reference/concepts.md</id>
      <updated>2020-03-25T16:25:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts.md b/reference/concepts.md
index e08ab7905..9c0cb8245 100644
--- a/reference/concepts.md
+++ b/reference/concepts.md
@@ -10,7 +10,7 @@
 
 ### 等しさの保持（*equality preservation*）
 
-ある式への等しい入力によって等しい出力が得られる時、その式は __等しさを保持__ している。この入力とは具体的な値ではなくその式の入力となり得る引数（オペランド）の集合であり、出力とはその式の結果およびその式によって変更された全ての引数（オペランド）のこと。
+ある式への等しい入力によって等しい出力が得られる時、その式は __等しさを保持__ している。入力とはその式に与えられた全ての引数（オペランド）であり、出力とはその式の結果およびその式によって変更された全ての引数のこと。
 
 また、必ずしも入力の個別の値が全てその式にとって有効である必要はない。例えば、整数に対する`a / b`という式は等しさを保持するが、`b = 0`の時この式は有効ではない。しかし、このことは式`a / b`が等しさを保持することを妨げない。  
 式への入力のうちこのような有効ではない値を除いたものをその式の __定義域（*domain*）__ と呼ぶ。
@@ -38,6 +38,8 @@ concept C2 = requires(const T a) {
 };
 ```
 
+これによって各制約式では、型パラメータがCV修飾されない非配列のオブジェクト型であると仮定することで、それぞれの引数の値カテゴリとCV修飾を確定することができる。
+
 ### 暗黙的な式のバリエーション（*implicit expression variations*）
 
 `requires`式において定数左辺値としてローカルパラメータを宣言する場合、それぞれの制約式にはそのパラメータを受け取る位置に非定数左辺値や（定数）右辺値を受け入れる暗黙的な式のバリエーションが要求される。ただし、このような暗黙的な式のバリエーション（のいずれか）が異なる意味論を持ち、明示的に記述される場合を除く。
@@ -166,3 +168,5 @@ concept C =
 - [C++標準コンセプトの名前付けガイドライン - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20190826/p1)
 - [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
 - [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [P2101R0 “Models” subsumes “satisfies” (Wording for US298 and US300)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2101r0.html)
+- [P2102R0 Make “implicit expression variations” more explicit (Wording for US185)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2102r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>boolean -- &lt;concepts&gt;関連の追加文書やIssueの対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts/boolean.html"/>
      <id>6764512d3955dbaa3a1d009af10f8d7f48415019:reference/concepts/boolean.md</id>
      <updated>2020-03-25T16:25:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/boolean.md b/reference/concepts/boolean.md
index 4c6f00cf1..09809a0fc 100644
--- a/reference/concepts/boolean.md
+++ b/reference/concepts/boolean.md
@@ -121,3 +121,5 @@ std::optional&amp;lt;int&amp;gt; is not boolean
 
 - [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
 - [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [LWG Issue 3208. Boolean&amp;#39;s expression requirements are ordered inconsistently](https://wg21.cmeerw.net/lwg/issue3208)
+- [P1964R2 Wording for `boolean-testable`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1964r2.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_reference_with -- &lt;concepts&gt;関連の追加文書やIssueの対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts/common_reference_with.html"/>
      <id>6764512d3955dbaa3a1d009af10f8d7f48415019:reference/concepts/common_reference_with.md</id>
      <updated>2020-03-25T16:25:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/common_reference_with.md b/reference/concepts/common_reference_with.md
index 320e09a72..54445f7f4 100644
--- a/reference/concepts/common_reference_with.md
+++ b/reference/concepts/common_reference_with.md
@@ -97,3 +97,4 @@ T, U share a common reference type
 
 - [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
 - [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [LWG Issue 3154. `Common` and `CommonReference` have a common defect](https://wg21.cmeerw.net/lwg/issue3154)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>common_with -- &lt;concepts&gt;関連の追加文書やIssueの対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts/common_with.html"/>
      <id>6764512d3955dbaa3a1d009af10f8d7f48415019:reference/concepts/common_with.md</id>
      <updated>2020-03-25T16:25:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/common_with.md b/reference/concepts/common_with.md
index ae7bdd4e6..7c24628cf 100644
--- a/reference/concepts/common_with.md
+++ b/reference/concepts/common_with.md
@@ -102,3 +102,5 @@ T, U share a common type
 
 - [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
 - [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [LWG Issue 3153. `Common` and `common_type` have too little in common](https://wg21.cmeerw.net/lwg/issue3153)
+- [LWG Issue 3154. `Common` and `CommonReference` have a common defect](https://wg21.cmeerw.net/lwg/issue3154)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copyable -- &lt;concepts&gt;関連の追加文書やIssueの対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts/copyable.html"/>
      <id>6764512d3955dbaa3a1d009af10f8d7f48415019:reference/concepts/copyable.md</id>
      <updated>2020-03-25T16:25:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/copyable.md b/reference/concepts/copyable.md
index 862b7cd61..674594a70 100644
--- a/reference/concepts/copyable.md
+++ b/reference/concepts/copyable.md
@@ -7,9 +7,8 @@
 ```cpp
 namespace std {
   template&amp;lt;class T&amp;gt;
-  concept copyable = copy_constructible&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
-                     movable&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
-                     assignable_from&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;;
+  concept copyable = copy_constructible&amp;lt;T&amp;gt; &amp;amp;&amp;amp; movable&amp;lt;T&amp;gt; &amp;amp;&amp;amp;
+                     assignable_from&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt; &amp;amp;&amp;amp; assignable_from&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt; &amp;amp;&amp;amp; assignable_from&amp;lt;T&amp;amp;, const T&amp;gt;;
 }
 ```
 * assignable_from[link /reference/concepts/assignable_from.md]
@@ -101,3 +100,4 @@ not_copyable2 is not copyable
 
 - [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
 - [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [P2102R0 Make “implicit expression variations” more explicit (Wording for US185)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2102r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>relation -- &lt;concepts&gt;関連の追加文書やIssueの対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts/relation.html"/>
      <id>6764512d3955dbaa3a1d009af10f8d7f48415019:reference/concepts/relation.md</id>
      <updated>2020-03-25T16:25:39+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/concepts/relation.md b/reference/concepts/relation.md
index 8def5a9a9..eb903f601 100644
--- a/reference/concepts/relation.md
+++ b/reference/concepts/relation.md
@@ -107,4 +107,5 @@ not_relation_s1s2 is not relation between S1 and S2
 
 - [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
 - [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [P1248R1 Remove `CommonReference` requirement from `StrictWeakOrdering` (a.k.a Fixing Relations)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1248r1.html)
 - [二項関係 - wikipedia](https://ja.wikipedia.org/wiki/二項関係)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>