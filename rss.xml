<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-02-12T14:42:23.838709</updated>
  <id>be5cbcad-87f4-48d3-a2cf-8c47da35319e</id>

  
    <entry>
      <title>flat_multiset -- add op_deduction_guide to flat_set. (#1079)</title>
      <link href="https://cpprefjp.github.io/reference/flat_set/flat_multiset.html"/>
      <id>f7e7a97f12518a9c88ecb00272734282b6c09772:reference/flat_set/flat_multiset.md</id>
      <updated>2025-02-11T09:56:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_set/flat_multiset.md b/reference/flat_set/flat_multiset.md
index e6e3bd6ad..60d49067e 100644
--- a/reference/flat_set/flat_multiset.md
+++ b/reference/flat_set/flat_multiset.md
@@ -136,7 +136,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------|------------------------------------|-------|
-| [`(deduction_guide)`](flat_multiset/op_deduction_guide.md.nolink) | クラステンプレートの推論補助 | C++23 |
+| [`(deduction_guide)`](flat_multiset/op_deduction_guide.md) | クラステンプレートの推論補助 | C++23 |
 
 
 ## その他
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- add op_deduction_guide to flat_set. (#1079)</title>
      <link href="https://cpprefjp.github.io/reference/flat_set/flat_multiset/op_deduction_guide.html"/>
      <id>f7e7a97f12518a9c88ecb00272734282b6c09772:reference/flat_set/flat_multiset/op_deduction_guide.md</id>
      <updated>2025-02-11T09:56:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_set/flat_multiset/op_deduction_guide.md b/reference/flat_set/flat_multiset/op_deduction_guide.md
new file mode 100644
index 000000000..2b1a907c9
--- /dev/null
+++ b/reference/flat_set/flat_multiset/op_deduction_guide.md
@@ -0,0 +1,106 @@
+# 推論補助
+* flat_set[meta header]
+* std[meta namespace]
+* flat_multiset[meta class]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  // 説明用の型
+  template &amp;lt;class InputIterator&amp;gt;
+  using iter_val_t = typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type;
+  template&amp;lt;class Allocator, class T&amp;gt;
+  using alloc_rebind = typename allocator_traits&amp;lt;Allocator&amp;gt;::template rebind_alloc&amp;lt;T&amp;gt;;
+
+  template&amp;lt;class KeyContainer, class Compare = less&amp;lt;typename KeyContainer::value_type&amp;gt;&amp;gt;
+  flat_multiset(KeyContainer, Compare = Compare())
+    -&amp;gt; flat_multiset&amp;lt;typename KeyContainer::value_type, Compare, KeyContainer&amp;gt;;         // (1)
+
+  template&amp;lt;class KeyContainer, class Allocator&amp;gt;
+  flat_multiset(KeyContainer, Allocator)
+    -&amp;gt; flat_multiset&amp;lt;typename KeyContainer::value_type,
+                less&amp;lt;typename KeyContainer::value_type&amp;gt;, KeyContainer&amp;gt;;                 // (2)
+
+  template&amp;lt;class KeyContainer, class Compare, class Allocator&amp;gt;
+  flat_multiset(KeyContainer, Compare, Allocator)
+    -&amp;gt; flat_multiset&amp;lt;typename KeyContainer::value_type, Compare, KeyContainer&amp;gt;;         // (3)
+
+  template&amp;lt;class KeyContainer, class Compare = less&amp;lt;typename KeyContainer::value_type&amp;gt;&amp;gt;
+  flat_multiset(sorted_equivalent_t, KeyContainer, Compare = Compare())
+    -&amp;gt; flat_multiset&amp;lt;typename KeyContainer::value_type, Compare, KeyContainer&amp;gt;;         // (4)
+
+  template&amp;lt;class KeyContainer, class Allocator&amp;gt;
+  flat_multiset(sorted_equivalent_t, KeyContainer, Allocator)
+    -&amp;gt; flat_multiset&amp;lt;typename KeyContainer::value_type,
+                less&amp;lt;typename KeyContainer::value_type&amp;gt;, KeyContainer&amp;gt;;                 // (5)
+
+  template&amp;lt;class KeyContainer, class Compare, class Allocator&amp;gt;
+  flat_multiset(sorted_equivalent_t, KeyContainer, Compare, Allocator)
+    -&amp;gt; flat_multiset&amp;lt;typename KeyContainer::value_type, Compare, KeyContainer&amp;gt;;         // (6)
+
+  template&amp;lt;class InputIterator, class Compare = less&amp;lt;iter_val_t&amp;lt;InputIterator&amp;gt;&amp;gt;&amp;gt;
+  flat_multiset(InputIterator, InputIterator, Compare = Compare())
+    -&amp;gt; flat_multiset&amp;lt;iter_val_t&amp;lt;InputIterator&amp;gt;, Compare&amp;gt;;                               // (7)
+
+  template&amp;lt;class InputIterator, class Compare = less&amp;lt;iter_val_t&amp;lt;InputIterator&amp;gt;&amp;gt;&amp;gt;
+  flat_multiset(sorted_equivalent_t, InputIterator, InputIterator, Compare = Compare())
+    -&amp;gt; flat_multiset&amp;lt;iter_val_t&amp;lt;InputIterator&amp;gt;, Compare&amp;gt;;                               // (8)
+
+  template&amp;lt;ranges::input_range R, class Compare = less&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;,
+           class Allocator = allocator&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;
+  flat_multiset(from_range_t, R&amp;amp;&amp;amp;, Compare = Compare(), Allocator = Allocator())
+    -&amp;gt; flat_multiset&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;, Compare,
+                vector&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;,
+                alloc_rebind&amp;lt;Allocator, ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;&amp;gt;;                    // (9)
+
+  template&amp;lt;ranges::input_range R, class Allocator&amp;gt;
+  flat_multiset(from_range_t, R&amp;amp;&amp;amp;, Allocator)
+    -&amp;gt; flat_multiset&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;, less&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;,
+                vector&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;,
+                alloc_rebind&amp;lt;Allocator, ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;&amp;gt;;                    // (10)
+
+  template&amp;lt;class Key, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
+  flat_multiset(initializer_list&amp;lt;Key&amp;gt;, Compare = Compare())
+    -&amp;gt; flat_multiset&amp;lt;Key, Compare&amp;gt;;                                                     // (11)
+
+  template&amp;lt;class Key, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
+  flat_multiset(sorted_equivalent_t, initializer_list&amp;lt;Key&amp;gt;, Compare = Compare())
+    -&amp;gt; flat_multiset&amp;lt;Key, Compare&amp;gt;;                                                     // (12)
+```
+* vector[link /reference/vector/vector.md]
+* from_range_t[link ../../ranges/from_range_t.md]
+* sorted_equivalent_t[link ../sorted_equivalent_t.md]
+* iterator_traits[link /reference/iterator/iterator_traits.md]
+* less[link /reference/functional/less.md]
+* allocator[link /reference/memory/allocator.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* ranges::input_range[link /reference/ranges/input_range.md]
+* ranges::range_value_t[link /reference/ranges/range_value_t.md]
+* allocator_traits[link /reference/memory/allocator_traits.md]
+
+
+## 概要
+`std::flat_multiset`クラステンプレートの型推論補助。
+
+- (1) : キーのコンテナ、比較関数からの推論
+- (2) : キーのコンテナ、アロケータからの推論
+- (3) : キーのコンテナ、比較関数、アロケータからの推論
+- (4) : キーのコンテナ、比較関数からの推論
+- (5) : キーのコンテナ、アロケータからの推論
+- (6) : キーのコンテナ、比較関数、アロケータからの推論
+- (7) : イテレータ範囲、比較関数からの推論
+- (8) : イテレータ範囲、比較関数からの推論
+- (9) : Range、比較関数、アロケータからの推論
+- (10) : Range、アロケータからの推論
+- (11) : 初期化子リスト、比較関数からの推論
+- (12) : 初期化子リスト、比較関数からの推論
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_set -- add op_deduction_guide to flat_set. (#1079)</title>
      <link href="https://cpprefjp.github.io/reference/flat_set/flat_set.html"/>
      <id>f7e7a97f12518a9c88ecb00272734282b6c09772:reference/flat_set/flat_set.md</id>
      <updated>2025-02-11T09:56:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_set/flat_set.md b/reference/flat_set/flat_set.md
index c4715fbc2..ece18174a 100644
--- a/reference/flat_set/flat_set.md
+++ b/reference/flat_set/flat_set.md
@@ -136,7 +136,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------|------------------------------------|-------|
-| [`(deduction_guide)`](flat_set/op_deduction_guide.md.nolink) | クラステンプレートの推論補助 | C++23 |
+| [`(deduction_guide)`](flat_set/op_deduction_guide.md) | クラステンプレートの推論補助 | C++23 |
 
 
 ## その他
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- add op_deduction_guide to flat_set. (#1079)</title>
      <link href="https://cpprefjp.github.io/reference/flat_set/flat_set/op_deduction_guide.html"/>
      <id>f7e7a97f12518a9c88ecb00272734282b6c09772:reference/flat_set/flat_set/op_deduction_guide.md</id>
      <updated>2025-02-11T09:56:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_set/flat_set/op_deduction_guide.md b/reference/flat_set/flat_set/op_deduction_guide.md
new file mode 100644
index 000000000..cadaca6b2
--- /dev/null
+++ b/reference/flat_set/flat_set/op_deduction_guide.md
@@ -0,0 +1,106 @@
+# 推論補助
+* flat_set[meta header]
+* std[meta namespace]
+* flat_set[meta class]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  // 説明用の型
+  template &amp;lt;class InputIterator&amp;gt;
+  using iter_val_t = typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type;
+  template&amp;lt;class Allocator, class T&amp;gt;
+  using alloc_rebind = typename allocator_traits&amp;lt;Allocator&amp;gt;::template rebind_alloc&amp;lt;T&amp;gt;;
+
+  template&amp;lt;class KeyContainer, class Compare = less&amp;lt;typename KeyContainer::value_type&amp;gt;&amp;gt;
+  flat_set(KeyContainer, Compare = Compare())
+    -&amp;gt; flat_set&amp;lt;typename KeyContainer::value_type, Compare, KeyContainer&amp;gt;;              // (1)
+
+  template&amp;lt;class KeyContainer, class Allocator&amp;gt;
+  flat_set(KeyContainer, Allocator)
+    -&amp;gt; flat_set&amp;lt;typename KeyContainer::value_type,
+                less&amp;lt;typename KeyContainer::value_type&amp;gt;, KeyContainer&amp;gt;;                 // (2)
+
+  template&amp;lt;class KeyContainer, class Compare, class Allocator&amp;gt;
+  flat_set(KeyContainer, Compare, Allocator)
+    -&amp;gt; flat_set&amp;lt;typename KeyContainer::value_type, Compare, KeyContainer&amp;gt;;              // (3)
+
+  template&amp;lt;class KeyContainer, class Compare = less&amp;lt;typename KeyContainer::value_type&amp;gt;&amp;gt;
+  flat_set(sorted_unique_t, KeyContainer, Compare = Compare())
+    -&amp;gt; flat_set&amp;lt;typename KeyContainer::value_type, Compare, KeyContainer&amp;gt;;              // (4)
+
+  template&amp;lt;class KeyContainer, class Allocator&amp;gt;
+  flat_set(sorted_unique_t, KeyContainer, Allocator)
+    -&amp;gt; flat_set&amp;lt;typename KeyContainer::value_type,
+                less&amp;lt;typename KeyContainer::value_type&amp;gt;, KeyContainer&amp;gt;;                 // (5)
+
+  template&amp;lt;class KeyContainer, class Compare, class Allocator&amp;gt;
+  flat_set(sorted_unique_t, KeyContainer, Compare, Allocator)
+    -&amp;gt; flat_set&amp;lt;typename KeyContainer::value_type, Compare, KeyContainer&amp;gt;;              // (6)
+
+  template&amp;lt;class InputIterator, class Compare = less&amp;lt;iter_val_t&amp;lt;InputIterator&amp;gt;&amp;gt;&amp;gt;
+  flat_set(InputIterator, InputIterator, Compare = Compare())
+    -&amp;gt; flat_set&amp;lt;iter_val_t&amp;lt;InputIterator&amp;gt;, Compare&amp;gt;;                                    // (7)
+
+  template&amp;lt;class InputIterator, class Compare = less&amp;lt;iter_val_t&amp;lt;InputIterator&amp;gt;&amp;gt;&amp;gt;
+  flat_set(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
+    -&amp;gt; flat_set&amp;lt;iter_val_t&amp;lt;InputIterator&amp;gt;, Compare&amp;gt;;                                    // (8)
+
+  template&amp;lt;ranges::input_range R, class Compare = less&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;,
+           class Allocator = allocator&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;
+  flat_set(from_range_t, R&amp;amp;&amp;amp;, Compare = Compare(), Allocator = Allocator())
+    -&amp;gt; flat_set&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;, Compare,
+                vector&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;,
+                alloc_rebind&amp;lt;Allocator, ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;&amp;gt;;                    // (9)
+
+  template&amp;lt;ranges::input_range R, class Allocator&amp;gt;
+  flat_set(from_range_t, R&amp;amp;&amp;amp;, Allocator)
+    -&amp;gt; flat_set&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;, less&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;,
+                vector&amp;lt;ranges::range_value_t&amp;lt;R&amp;gt;,
+                alloc_rebind&amp;lt;Allocator, ranges::range_value_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;&amp;gt;;                    // (10)
+
+  template&amp;lt;class Key, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
+  flat_set(initializer_list&amp;lt;Key&amp;gt;, Compare = Compare())
+    -&amp;gt; flat_set&amp;lt;Key, Compare&amp;gt;;                                                          // (11)
+
+  template&amp;lt;class Key, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
+  flat_set(sorted_unique_t, initializer_list&amp;lt;Key&amp;gt;, Compare = Compare())
+    -&amp;gt; flat_set&amp;lt;Key, Compare&amp;gt;;                                                          // (12)
+```
+* vector[link /reference/vector/vector.md]
+* from_range_t[link ../../ranges/from_range_t.md]
+* sorted_unique_t[link ../sorted_unique_t.md]
+* iterator_traits[link /reference/iterator/iterator_traits.md]
+* less[link /reference/functional/less.md]
+* allocator[link /reference/memory/allocator.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* ranges::input_range[link /reference/ranges/input_range.md]
+* ranges::range_value_t[link /reference/ranges/range_value_t.md]
+* allocator_traits[link /reference/memory/allocator_traits.md]
+
+
+## 概要
+`std::flat_set`クラステンプレートの型推論補助。
+
+- (1) : キーのコンテナ、比較関数からの推論
+- (2) : キーのコンテナ、アロケータからの推論
+- (3) : キーのコンテナ、比較関数、アロケータからの推論
+- (4) : キーのコンテナ、比較関数からの推論
+- (5) : キーのコンテナ、アロケータからの推論
+- (6) : キーのコンテナ、比較関数、アロケータからの推論
+- (7) : イテレータ範囲、比較関数からの推論
+- (8) : イテレータ範囲、比較関数からの推論
+- (9) : Range、比較関数、アロケータからの推論
+- (10) : Range、アロケータからの推論
+- (11) : 初期化子リスト、比較関数からの推論
+- (12) : 初期化子リスト、比較関数からの推論
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_map -- add op_deduction_guide to flat_map. (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map.html"/>
      <id>c55d9f2489cf0f0a96a65a511e8862953667746d:reference/flat_map/flat_map.md</id>
      <updated>2025-02-11T09:56:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map.md b/reference/flat_map/flat_map.md
index 47eb5dfba..584048a91 100644
--- a/reference/flat_map/flat_map.md
+++ b/reference/flat_map/flat_map.md
@@ -149,7 +149,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------|------------------------------------|-------|
-| [`(deduction_guide)`](flat_map/op_deduction_guide.md.nolink) | クラステンプレートの推論補助 | C++23 |
+| [`(deduction_guide)`](flat_map/op_deduction_guide.md) | クラステンプレートの推論補助 | C++23 |
 
 
 ## その他
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- add op_deduction_guide to flat_map. (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_map/op_deduction_guide.html"/>
      <id>c55d9f2489cf0f0a96a65a511e8862953667746d:reference/flat_map/flat_map/op_deduction_guide.md</id>
      <updated>2025-02-11T09:56:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_map/op_deduction_guide.md b/reference/flat_map/flat_map/op_deduction_guide.md
new file mode 100644
index 000000000..3bb63d4d8
--- /dev/null
+++ b/reference/flat_map/flat_map/op_deduction_guide.md
@@ -0,0 +1,132 @@
+# 推論補助
+* flat_map[meta header]
+* std[meta namespace]
+* flat_map[meta class]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  // 説明用の型
+  template &amp;lt;class InputIterator&amp;gt;
+  using iter_key_t = remove_const_t&amp;lt;typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type::first_type&amp;gt;;
+  template &amp;lt;class InputIterator&amp;gt;
+  using iter_val_t = typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type::second_type;
+  template&amp;lt;ranges::input_range Range&amp;gt;
+  using range_key_t = remove_const_t&amp;lt;typename ranges::range_value_t&amp;lt;Range&amp;gt;::first_type&amp;gt;;
+  template&amp;lt;ranges::input_range Range&amp;gt;
+  using range_val_t = typename ranges::range_value_t&amp;lt;Range&amp;gt;::second_type;
+  template&amp;lt;class Allocator, class T&amp;gt;
+  using alloc_rebind = typename allocator_traits&amp;lt;Allocator&amp;gt;::template rebind_alloc&amp;lt;T&amp;gt;;
+
+  template&amp;lt;class KeyContainer, class MappedContainer,
+           class Compare = less&amp;lt;typename KeyContainer::value_type&amp;gt;&amp;gt;
+  flat_map(KeyContainer, MappedContainer, Compare = Compare())
+    -&amp;gt; flat_map&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                Compare, KeyContainer, MappedContainer&amp;gt;;                                 // (1)
+
+  template&amp;lt;class KeyContainer, class MappedContainer, class Allocator&amp;gt;
+  flat_map(KeyContainer, MappedContainer, Allocator)
+    -&amp;gt; flat_map&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                less&amp;lt;typename KeyContainer::value_type&amp;gt;, KeyContainer, MappedContainer&amp;gt;; // (2)
+
+  template&amp;lt;class KeyContainer, class MappedContainer, class Compare, class Allocator&amp;gt;
+  flat_map(KeyContainer, MappedContainer, Compare, Allocator)
+    -&amp;gt; flat_map&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                Compare, KeyContainer, MappedContainer&amp;gt;;                                 // (3)
+
+  template&amp;lt;class KeyContainer, class MappedContainer,
+           class Compare = less&amp;lt;typename KeyContainer::value_type&amp;gt;&amp;gt;
+  flat_map(sorted_unique_t, KeyContainer, MappedContainer, Compare = Compare())
+    -&amp;gt; flat_map&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                Compare, KeyContainer, MappedContainer&amp;gt;;                                 // (4)
+
+  template&amp;lt;class KeyContainer, class MappedContainer, class Allocator&amp;gt;
+  flat_map(sorted_unique_t, KeyContainer, MappedContainer, Allocator)
+    -&amp;gt; flat_map&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                less&amp;lt;typename KeyContainer::value_type&amp;gt;, KeyContainer, MappedContainer&amp;gt;; // (5)
+
+  template&amp;lt;class KeyContainer, class MappedContainer, class Compare, class Allocator&amp;gt;
+  flat_map(sorted_unique_t, KeyContainer, MappedContainer, Compare, Allocator)
+    -&amp;gt; flat_map&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                Compare, KeyContainer, MappedContainer&amp;gt;;                                 // (6)
+
+  template&amp;lt;class InputIterator, class Compare = less&amp;lt;iter_key_t&amp;lt;InputIterator&amp;gt;&amp;gt;&amp;gt;
+  flat_map(InputIterator, InputIterator, Compare = Compare())
+    -&amp;gt; flat_map&amp;lt;iter_key_t&amp;lt;InputIterator&amp;gt;, iter_val_t&amp;lt;InputIterator&amp;gt;, Compare&amp;gt;;          // (7)
+
+  template&amp;lt;class InputIterator, class Compare = less&amp;lt;iter_key_t&amp;lt;InputIterator&amp;gt;&amp;gt;&amp;gt;
+  flat_map(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
+    -&amp;gt; flat_map&amp;lt;iter_key_t&amp;lt;InputIterator&amp;gt;, iter_val_t&amp;lt;InputIterator&amp;gt;, Compare&amp;gt;;          // (8)
+
+  template&amp;lt;ranges::input_range R, class Compare = less&amp;lt;range_key_t&amp;lt;R&amp;gt;&amp;gt;,
+           class Allocator = allocator&amp;lt;byte&amp;gt;&amp;gt;
+  flat_map(from_range_t, R&amp;amp;&amp;amp;, Compare = Compare(), Allocator = Allocator())
+    -&amp;gt; flat_map&amp;lt;range_key_t&amp;lt;R&amp;gt;, range_val_t&amp;lt;R&amp;gt;, Compare,
+                vector&amp;lt;range_key_t&amp;lt;R&amp;gt;, alloc_rebind&amp;lt;Allocator, range_key_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;,
+                vector&amp;lt;range_val_t&amp;lt;R&amp;gt;, alloc_rebind&amp;lt;Allocator, range_val_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;&amp;gt;;        // (9)
+
+  template&amp;lt;ranges::input_range R, class Allocator&amp;gt;
+  flat_map(from_range_t, R&amp;amp;&amp;amp;, Allocator)
+    -&amp;gt; flat_map&amp;lt;range_key_t&amp;lt;R&amp;gt;, range_val_t&amp;lt;R&amp;gt;, less&amp;lt;range_key_t&amp;lt;R&amp;gt;&amp;gt;,
+                vector&amp;lt;range_key_t&amp;lt;R&amp;gt;, alloc_rebind&amp;lt;Allocator, range_key_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;,
+                vector&amp;lt;range_val_t&amp;lt;R&amp;gt;, alloc_rebind&amp;lt;Allocator, range_val_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;&amp;gt;;        // (10)
+
+  template&amp;lt;class Key, class T, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
+  flat_map(initializer_list&amp;lt;pair&amp;lt;Key, T&amp;gt;&amp;gt;, Compare = Compare())
+    -&amp;gt; flat_map&amp;lt;Key, T, Compare&amp;gt;;                                                        // (11)
+
+  template&amp;lt;class Key, class T, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
+  flat_map(sorted_unique_t, initializer_list&amp;lt;pair&amp;lt;Key, T&amp;gt;&amp;gt;, Compare = Compare())
+    -&amp;gt; flat_map&amp;lt;Key, T, Compare&amp;gt;;                                                        // (12)
+```
+* vector[link /reference/vector/vector.md]
+* from_range_t[link ../../ranges/from_range_t.md]
+* sorted_unique_t[link ../sorted_unique_t.md]
+* remove_const_t[link /reference/type_traits/remove_const.md]
+* pair[link /reference/utility/pair.md]
+* iterator_traits[link /reference/iterator/iterator_traits.md]
+* less[link /reference/functional/less.md]
+* allocator[link /reference/memory/allocator.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* ranges::input_range[link /reference/ranges/input_range.md]
+* allocator_traits[link /reference/memory/allocator_traits.md]
+* byte[link /reference/cstddef/byte.md]
+
+
+## 概要
+`std::flat_map`クラステンプレートの型推論補助。
+
+- (1) : キーのコンテナ、値のコンテナ、比較関数からの推論
+- (2) : キーのコンテナ、値のコンテナ、アロケータからの推論
+- (3) : キーのコンテナ、値のコンテナ、比較関数、アロケータからの推論
+- (4) : キーのコンテナ、値のコンテナ、比較関数からの推論
+- (5) : キーのコンテナ、値のコンテナ、アロケータからの推論
+- (6) : キーのコンテナ、値のコンテナ、比較関数、アロケータからの推論
+- (7) : イテレータ範囲、比較関数からの推論
+- (8) : イテレータ範囲、比較関数からの推論
+- (9) : Range、比較関数、アロケータからの推論
+- (10) : Range、アロケータからの推論
+- (11) : 初期化子リスト、比較関数からの推論
+- (12) : 初期化子リスト、比較関数からの推論
+
+
+## 備考
+- C++23時点において、`flat_map`の推論補助は使いにくい。これはイテレータ範囲や組でのキーの型が`const Key`となっているためだ。この使いにくさは、将来の言語拡張で改良される可能性がある。
+    ```cpp
+    flat_map m = {{1, 1}, {2, 2}, {3, 3}}; // コンパイルエラー！ 初期化子リストからconst Keyを導出できない
+    flat_map m2 = initializer_list&amp;lt;pair&amp;lt;const int, int&amp;gt;&amp;gt;({{1, 1}, {2, 2}, {3, 3}}); // OK
+    ```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [LWG Issue 3025. Map-like container deduction guides should use `pair&amp;lt;Key, T&amp;gt;`, not `pair&amp;lt;const Key, T&amp;gt;`](https://wg21.cmeerw.net/lwg/issue3025)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>flat_multimap -- add op_deduction_guide to flat_map. (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap.html"/>
      <id>c55d9f2489cf0f0a96a65a511e8862953667746d:reference/flat_map/flat_multimap.md</id>
      <updated>2025-02-11T09:56:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap.md b/reference/flat_map/flat_multimap.md
index 414944d1a..cc49593b5 100644
--- a/reference/flat_map/flat_multimap.md
+++ b/reference/flat_map/flat_multimap.md
@@ -145,7 +145,7 @@ namespace std {
 
 | 名前 | 説明 | 対応バージョン |
 |---------------------------------------------|------------------------------------|-------|
-| [`(deduction_guide)`](flat_multimap/op_deduction_guide.md.nolink) | クラステンプレートの推論補助 | C++23 |
+| [`(deduction_guide)`](flat_multimap/op_deduction_guide.md) | クラステンプレートの推論補助 | C++23 |
 
 
 ## その他
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>推論補助 -- add op_deduction_guide to flat_map. (#1078)</title>
      <link href="https://cpprefjp.github.io/reference/flat_map/flat_multimap/op_deduction_guide.html"/>
      <id>c55d9f2489cf0f0a96a65a511e8862953667746d:reference/flat_map/flat_multimap/op_deduction_guide.md</id>
      <updated>2025-02-11T09:56:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/flat_map/flat_multimap/op_deduction_guide.md b/reference/flat_map/flat_multimap/op_deduction_guide.md
new file mode 100644
index 000000000..811665f2a
--- /dev/null
+++ b/reference/flat_map/flat_multimap/op_deduction_guide.md
@@ -0,0 +1,132 @@
+# 推論補助
+* flat_map[meta header]
+* std[meta namespace]
+* flat_multimap[meta class]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  // 説明用の型
+  template &amp;lt;class InputIterator&amp;gt;
+  using iter_key_t = remove_const_t&amp;lt;typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type::first_type&amp;gt;;
+  template &amp;lt;class InputIterator&amp;gt;
+  using iter_val_t = typename iterator_traits&amp;lt;InputIterator&amp;gt;::value_type::second_type;
+  template&amp;lt;ranges::input_range Range&amp;gt;
+  using range_key_t = remove_const_t&amp;lt;typename ranges::range_value_t&amp;lt;Range&amp;gt;::first_type&amp;gt;;
+  template&amp;lt;ranges::input_range Range&amp;gt;
+  using range_val_t = typename ranges::range_value_t&amp;lt;Range&amp;gt;::second_type;
+  template&amp;lt;class Allocator, class T&amp;gt;
+  using alloc_rebind = typename allocator_traits&amp;lt;Allocator&amp;gt;::template rebind_alloc&amp;lt;T&amp;gt;;
+
+  template&amp;lt;class KeyContainer, class MappedContainer,
+           class Compare = less&amp;lt;typename KeyContainer::value_type&amp;gt;&amp;gt;
+  flat_multimap(KeyContainer, MappedContainer, Compare = Compare())
+    -&amp;gt; flat_multimap&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                Compare, KeyContainer, MappedContainer&amp;gt;;                                      // (1)
+
+  template&amp;lt;class KeyContainer, class MappedContainer, class Allocator&amp;gt;
+  flat_multimap(KeyContainer, MappedContainer, Allocator)
+    -&amp;gt; flat_multimap&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                less&amp;lt;typename KeyContainer::value_type&amp;gt;, KeyContainer, MappedContainer&amp;gt;;      // (2)
+
+  template&amp;lt;class KeyContainer, class MappedContainer, class Compare, class Allocator&amp;gt;
+  flat_multimap(KeyContainer, MappedContainer, Compare, Allocator)
+    -&amp;gt; flat_multimap&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                Compare, KeyContainer, MappedContainer&amp;gt;;                                      // (3)
+
+  template&amp;lt;class KeyContainer, class MappedContainer,
+           class Compare = less&amp;lt;typename KeyContainer::value_type&amp;gt;&amp;gt;
+  flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Compare = Compare())
+    -&amp;gt; flat_multimap&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                Compare, KeyContainer, MappedContainer&amp;gt;;                                      // (4)
+
+  template&amp;lt;class KeyContainer, class MappedContainer, class Allocator&amp;gt;
+  flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Allocator)
+    -&amp;gt; flat_multimap&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                less&amp;lt;typename KeyContainer::value_type&amp;gt;, KeyContainer, MappedContainer&amp;gt;;      // (5)
+
+  template&amp;lt;class KeyContainer, class MappedContainer, class Compare, class Allocator&amp;gt;
+  flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Compare, Allocator)
+    -&amp;gt; flat_multimap&amp;lt;typename KeyContainer::value_type, typename MappedContainer::value_type,
+                Compare, KeyContainer, MappedContainer&amp;gt;;                                      // (6)
+
+  template&amp;lt;class InputIterator, class Compare = less&amp;lt;iter_key_t&amp;lt;InputIterator&amp;gt;&amp;gt;&amp;gt;
+  flat_multimap(InputIterator, InputIterator, Compare = Compare())
+    -&amp;gt; flat_multimap&amp;lt;iter_key_t&amp;lt;InputIterator&amp;gt;, iter_val_t&amp;lt;InputIterator&amp;gt;, Compare&amp;gt;;          // (7)
+
+  template&amp;lt;class InputIterator, class Compare = less&amp;lt;iter_key_t&amp;lt;InputIterator&amp;gt;&amp;gt;&amp;gt;
+  flat_multimap(sorted_equivalent_t, InputIterator, InputIterator, Compare = Compare())
+    -&amp;gt; flat_multimap&amp;lt;iter_key_t&amp;lt;InputIterator&amp;gt;, iter_val_t&amp;lt;InputIterator&amp;gt;, Compare&amp;gt;;          // (8)
+
+  template&amp;lt;ranges::input_range R, class Compare = less&amp;lt;range_key_t&amp;lt;R&amp;gt;&amp;gt;,
+           class Allocator = allocator&amp;lt;byte&amp;gt;&amp;gt;
+  flat_multimap(from_range_t, R&amp;amp;&amp;amp;, Compare = Compare(), Allocator = Allocator())
+    -&amp;gt; flat_multimap&amp;lt;range_key_t&amp;lt;R&amp;gt;, range_val_t&amp;lt;R&amp;gt;, Compare,
+                vector&amp;lt;range_key_t&amp;lt;R&amp;gt;, alloc_rebind&amp;lt;Allocator, range_key_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;,
+                vector&amp;lt;range_val_t&amp;lt;R&amp;gt;, alloc_rebind&amp;lt;Allocator, range_val_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;&amp;gt;;             // (9)
+
+  template&amp;lt;ranges::input_range R, class Allocator&amp;gt;
+  flat_multimap(from_range_t, R&amp;amp;&amp;amp;, Allocator)
+    -&amp;gt; flat_multimap&amp;lt;range_key_t&amp;lt;R&amp;gt;, range_val_t&amp;lt;R&amp;gt;, less&amp;lt;range_key_t&amp;lt;R&amp;gt;&amp;gt;,
+                vector&amp;lt;range_key_t&amp;lt;R&amp;gt;, alloc_rebind&amp;lt;Allocator, range_key_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;,
+                vector&amp;lt;range_val_t&amp;lt;R&amp;gt;, alloc_rebind&amp;lt;Allocator, range_val_t&amp;lt;R&amp;gt;&amp;gt;&amp;gt;&amp;gt;;             // (10)
+
+  template&amp;lt;class Key, class T, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
+  flat_multimap(initializer_list&amp;lt;pair&amp;lt;Key, T&amp;gt;&amp;gt;, Compare = Compare())
+    -&amp;gt; flat_multimap&amp;lt;Key, T, Compare&amp;gt;;                                                        // (11)
+
+  template&amp;lt;class Key, class T, class Compare = less&amp;lt;Key&amp;gt;&amp;gt;
+  flat_multimap(sorted_equivalent_t, initializer_list&amp;lt;pair&amp;lt;Key, T&amp;gt;&amp;gt;, Compare = Compare())
+    -&amp;gt; flat_multimap&amp;lt;Key, T, Compare&amp;gt;;                                                        // (12)
+```
+* vector[link /reference/vector/vector.md]
+* from_range_t[link ../../ranges/from_range_t.md]
+* sorted_equivalent_t[link ../sorted_equivalent_t.md]
+* remove_const_t[link /reference/type_traits/remove_const.md]
+* pair[link /reference/utility/pair.md]
+* iterator_traits[link /reference/iterator/iterator_traits.md]
+* less[link /reference/functional/less.md]
+* allocator[link /reference/memory/allocator.md]
+* initializer_list[link /reference/initializer_list/initializer_list.md]
+* ranges::input_range[link /reference/ranges/input_range.md]
+* allocator_traits[link /reference/memory/allocator_traits.md]
+* byte[link /reference/cstddef/byte.md]
+
+
+## 概要
+`std::flat_multimap`クラステンプレートの型推論補助。
+
+- (1) : キーのコンテナ、値のコンテナ、比較関数からの推論
+- (2) : キーのコンテナ、値のコンテナ、アロケータからの推論
+- (3) : キーのコンテナ、値のコンテナ、比較関数、アロケータからの推論
+- (4) : キーのコンテナ、値のコンテナ、比較関数からの推論
+- (5) : キーのコンテナ、値のコンテナ、アロケータからの推論
+- (6) : キーのコンテナ、値のコンテナ、比較関数、アロケータからの推論
+- (7) : イテレータ範囲、比較関数からの推論
+- (8) : イテレータ範囲、比較関数からの推論
+- (9) : Range、比較関数、アロケータからの推論
+- (10) : Range、アロケータからの推論
+- (11) : 初期化子リスト、比較関数からの推論
+- (12) : 初期化子リスト、比較関数からの推論
+
+
+## 備考
+- C++23時点において、`flat_multimap`の推論補助は使いにくい。これはイテレータ範囲や組でのキーの型が`const Key`となっているためだ。この使いにくさは、将来の言語拡張で改良される可能性がある。
+    ```cpp
+    flat_multimap m = {{1, 1}, {2, 2}, {3, 3}}; // コンパイルエラー！ 初期化子リストからconst Keyを導出できない
+    flat_multimap m2 = initializer_list&amp;lt;pair&amp;lt;const int, int&amp;gt;&amp;gt;({{1, 1}, {2, 2}, {3, 3}}); // OK
+    ```
+
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [LWG Issue 3025. Map-like container deduction guides should use `pair&amp;lt;Key, T&amp;gt;`, not `pair&amp;lt;const Key, T&amp;gt;`](https://wg21.cmeerw.net/lwg/issue3025)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>suomesta</name>
        <email>shawn316michaels@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assoc_legendre -- Merge pull request #1407 from akinomyoga/math-functions</title>
      <link href="https://cpprefjp.github.io/reference/cmath/assoc_legendre.html"/>
      <id>90d18978aa30dee75c8dd471283a7ba1c961f9e8:reference/cmath/assoc_legendre.md</id>
      <updated>2025-02-09T21:40:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/assoc_legendre.md b/reference/cmath/assoc_legendre.md
index dc96d1b09..41ec51eb7 100644
--- a/reference/cmath/assoc_legendre.md
+++ b/reference/cmath/assoc_legendre.md
@@ -59,6 +59,30 @@ $$
 - `l &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
+### 負の m の対応
+この標準関数は $m$ が正の場合にしか対応していない。
+一方でルジャンドル陪関数はロドリゲスの公式を用いて負の $m$ に対して自然に拡張され、
+このことは球面調和関数を定義する上でも使われる。
+負の $m$ に対してもルジャンドル陪関数を計算する必要がある場合は、関係式
+$$ P_l^{-m}(x) = (-1)^m \frac{(l-m)!}{(l+m)!} P_l^m(x) $$
+を用いる必要がある。
+
+```cpp
+#include &amp;lt;cmath&amp;gt;
+
+// 負の m にも対応した実装例
+double assoc_legendre(unsigned l, int m, double x) {
+  if (m &amp;gt;= 0)
+    return std::assoc_legendre(l, (unsigned) m, x);
+  else
+    return std::pow(-1.0, m) * (std::tgamma(1.0 + l + m) / std::tgamma(1.0 + l - m)) * std::assoc_legendre(l, (unsigned) -m, x);
+}
+```
+* std::assoc_legendre[color ff0000]
+* std::tgamma[link tgamma.md]
+
+上記の例では簡単のために階乗をガンマ関数 $n! = \Gamma(n + 1)$ ([`tgamma`](tgamma.md)) で計算しているが、
+計算効率やオーバーフローなどを考えると、直接 $(l + |m|)\cdots(l - |m| + 1)$ で割り算したり、係数を事前計算しておくなど工夫すると良い。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>legendre -- Merge pull request #1407 from akinomyoga/math-functions</title>
      <link href="https://cpprefjp.github.io/reference/cmath/legendre.html"/>
      <id>90d18978aa30dee75c8dd471283a7ba1c961f9e8:reference/cmath/legendre.md</id>
      <updated>2025-02-09T21:40:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/legendre.md b/reference/cmath/legendre.md
index 5e35b3d88..9c9e54241 100644
--- a/reference/cmath/legendre.md
+++ b/reference/cmath/legendre.md
@@ -103,6 +103,9 @@ legendre(3, 1) = 1
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+### 備考
+- GCC 7, 8 には $x$ として [-1.0, 1.0] の範囲外の値を渡した時に、[`std::domain_error`](/reference/stdexcept.md) を投げるバグがあった (GCC 7.5, 8.2, 8.4 [mark verified])。
+  GCC 9 以降では直っている (GCC 9.3, 10.5, 11.4, 12.3, 13.2, 15.0 [mark verified])。
 
 ## 実装例
 ### 閉形式
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lgamma -- Merge pull request #1407 from akinomyoga/math-functions</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lgamma.html"/>
      <id>90d18978aa30dee75c8dd471283a7ba1c961f9e8:reference/cmath/lgamma.md</id>
      <updated>2025-02-09T21:40:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lgamma.md b/reference/cmath/lgamma.md
index bcb8dd552..03027e27d 100644
--- a/reference/cmath/lgamma.md
+++ b/reference/cmath/lgamma.md
@@ -35,7 +35,7 @@ namespace std {
 * Integral[italic]
 
 ## 概要
-ガンマ関数の絶対値の自然対数を求める。
+ガンマ関数 $\Gamma(x)$ ([`tgamma`](tgamma.md)) の絶対値の自然対数を求める。
 
 - (1) : `float`に対するオーバーロード
 - (2) : `double`に対するオーバーロード
@@ -60,7 +60,8 @@ namespace std {
     - `x = -∞` の場合、戻り値は `+∞` となる。
     - `x = +∞` の場合、戻り値は `+∞` となる。
 - C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
-
+- この関数はガンマ関数 ([`tgamma`](tgamma.md)) がオーバーフローするような場合に使う。
+  具体例については[ガンマ関数の備考](tgamma.md#remarks-lgamma)を参照のこと。
 
 ## 例
 ```cpp example
@@ -107,6 +108,8 @@ lgamma(+∞)  = inf
 
 - GCC 4.6.1 以上
 
+## 関連項目
+- ガンマ関数 [`tgamma`](tgamma.md)
 
 ## 参照
 - [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sph_legendre -- Merge pull request #1407 from akinomyoga/math-functions</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sph_legendre.html"/>
      <id>90d18978aa30dee75c8dd471283a7ba1c961f9e8:reference/cmath/sph_legendre.md</id>
      <updated>2025-02-09T21:40:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sph_legendre.md b/reference/cmath/sph_legendre.md
index 1f32cba3d..daa2b669b 100644
--- a/reference/cmath/sph_legendre.md
+++ b/reference/cmath/sph_legendre.md
@@ -47,7 +47,7 @@ namespace std {
 
 
 ## 戻り値
-引数 `l`, `m`, `theta` について $Y_l^m(\theta, 0)$ を返す。
+引数 `l`, `m`, `theta` について $Y_l^m(\theta, 0)$ (ただし $0 \le m \le l$) を返す。
 $Y_l^m(\theta, \phi)$ は球面調和関数
 $$
 Y_l^m(\theta, \phi) = (-1)^m \sqrt{\frac{2l + 1}{4\pi} \frac{(l - m)!}{(l + m)!}} P_l^m(\cos \theta) \exp(i m \phi)
@@ -56,23 +56,85 @@ $$
 である。
 $P_l^m$ はルジャンドル陪関数 ([`assoc_legendre`](assoc_legendre.md)) である。
 
-
 ## 備考
 - `l &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
+### 球面調和関数
+球面調和関数として使う場合には $\phi$ 依存性は自分で与える必要がある。
+また、この標準関数は $m\ge0$ にしか対応していないので、$m &amp;lt; 0$ の時の球面調和関数を計算したければ自分で $Y_l^{|m|}(\theta,0)$ の値を調節して使う必要がある。
+ルジャンドル陪関数の性質 $P_l^{-m}(x) = (-1)^m [(l - m)!/(l + m)!] P_l^m(x)$ より、一般の $m$ の球面調和関数は
+$$
+\begin{align*}
+Y_l^m(\theta, \phi)
+  &amp;amp;= (-1)^{(m+|m|)/2} \sqrt{\frac{2l + 1}{4\pi} \frac{(l - |m|)!}{(l + |m|)!}} P_l^{|m|}(\cos \theta) e^{i m \phi} \\
+  &amp;amp;= \begin{cases}
+    Y_l^{m}(\theta, 0) e^{im\phi}, &amp;amp; (0 \le m \le l), \\
+    (-1)^{|m|} Y_l^{|m|}(\theta, 0) e^{im\phi}, &amp;amp; (-l \le m &amp;lt; 0).
+  \end{cases}
+\end{align*}
+$$
+で与えられる。
+
+```cpp
+#include &amp;lt;cmath&amp;gt;
+#include &amp;lt;complex&amp;gt;
+#include &amp;lt;numbers&amp;gt;
+
+// 球面調和関数の実装例
+std::complex&amp;lt;double&amp;gt; sph_harmonics(unsigned l, int m, double theta, double phi) {
+  if (m &amp;gt;= 0)
+    return std::sph_legendre(l, (unsigned) m, theta) * std::polar(1.0, m * phi);
+  else
+    return std::sph_legendre(l, (unsigned) -m, theta) * std::polar(1.0, m * (phi - std::numbers::pi));
+}
+```
+* std::sph_legendre[color ff0000]
+* std::polar[link /reference/complex/complex/polar.md]
+* std::numbers::pi[link /reference/numbers/pi.md]
+
+また線形結合を取り直して実数にした、実数球面調和関数 $Y_{lm}(\theta,\phi)$ を計算することもできる。
+
+$$
+Y_{lm}(\theta,\phi)
+= \begin{cases}
+  \frac{(-1)^m Y_l^{|m|}(\theta,\phi) - Y_l^{-|m|}(\theta,\phi)}{\sqrt{2} i} = \sqrt{2} (-1)^{|m|} Y_l^{|m|}(\theta, 0) \sin(|m|\phi), &amp;amp; (-l \le m &amp;lt; 0), \\
+  Y_l^0 = Y_l^0(\theta, 0), &amp;amp; (m = 0), \\
+  \frac{(-1)^m Y_l^{|m|}(\theta,\phi) + Y_l^{-|m|}(\theta,\phi)}{\sqrt{2}} = \sqrt{2} (-1)^{|m|} Y_l^{|m|}(\theta, 0) \cos(|m|\phi), &amp;amp; (0 &amp;lt; m \le l).
+\end{cases}
+$$
+
+```cpp
+#include &amp;lt;cmath&amp;gt;
+#include &amp;lt;numbers&amp;gt;
+
+// 実数球面調和関数の実装例
+double real_sph_harmonics(unsigned l, int m, double theta, double phi) {
+  if (m == 0)
+    return std::sph_legendre(l, 0u, theta);
+  else if (m &amp;gt; 0)
+    return std::numbers::sqrt2 * std::sph_legendre(l, (unsigned) m, theta) * std::cos(m * (phi - std::numbers::pi));
+  else
+    return std::numbers::sqrt2 * std::sph_legendre(l, (unsigned) -m, theta) * std::sin(-m * (phi - std::numbers::pi));
+}
+```
+* std::sph_legendre[color ff0000]
+* std::numbers::pi[link /reference/numbers/pi.md]
+* std::numbers::sqrt2[link /reference/numbers/sqrt2.md]
 
 ## 例
 ```cpp example
 #include &amp;lt;cmath&amp;gt;
 #include &amp;lt;complex&amp;gt;
+#include &amp;lt;numbers&amp;gt;
 #include &amp;lt;iostream&amp;gt;
 
-constexpr double pi = 3.141592653589793;
-
 // 球面調和関数
-std::complex&amp;lt;double&amp;gt; sph_harmonics(unsigned l, unsigned m, double theta, double phi) {
-  return std::sph_legendre(l, m, theta) * std::polar(1.0, m * phi);
+std::complex&amp;lt;double&amp;gt; sph_harmonics(unsigned l, int m, double theta, double phi) {
+  if (m &amp;gt;= 0)
+    return std::sph_legendre(l, (unsigned) m, theta) * std::polar(1.0, m * phi);
+  else
+    return std::sph_legendre(l, (unsigned) -m, theta) * std::polar(1.0, m * (phi - std::numbers::pi));
 }
 
 int main() {
@@ -82,9 +144,9 @@ int main() {
 
   std::cout &amp;lt;&amp;lt; &amp;#34;#θ / π\tφ / π\tY_&amp;#34; &amp;lt;&amp;lt; l &amp;lt;&amp;lt; &amp;#34;^&amp;#34; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;#34;(θ, φ)\n&amp;#34;;
   for (double t : {0., 0.25, 0.5, 0.75, 1.}) {
-    double theta = t * pi;
+    double theta = t * std::numbers::pi;
     for (double p : {0., 0.25, 0.5, 0.75, 1., 1.25, 1.5, 1.75, 2.}) {
-      double phi = p * pi / 4;
+      double phi = p * std::numbers::pi / 4;
       std::cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &amp;#34;\t&amp;#34; &amp;lt;&amp;lt; p &amp;lt;&amp;lt; &amp;#34;\t&amp;#34; &amp;lt;&amp;lt; sph_harmonics(l, m, theta, phi) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;
       if (t == 0 || t == 1) break;
     }
@@ -93,6 +155,7 @@ int main() {
 ```
 * std::sph_legendre[color ff0000]
 * std::polar[link /reference/complex/complex/polar.md]
+* std::numbers::pi[link /reference/numbers/pi.md]
 
 ### 出力例
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tgamma -- Merge pull request #1407 from akinomyoga/math-functions</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tgamma.html"/>
      <id>90d18978aa30dee75c8dd471283a7ba1c961f9e8:reference/cmath/tgamma.md</id>
      <updated>2025-02-09T21:40:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tgamma.md b/reference/cmath/tgamma.md
index 4f3e397eb..615ff7717 100644
--- a/reference/cmath/tgamma.md
+++ b/reference/cmath/tgamma.md
@@ -47,12 +47,12 @@ namespace std {
 
 
 ## 戻り値
-引数 `x` のガンマ関数を返す。
+引数 `x` のガンマ関数 $\Gamma(x)$ を返す。
 
+$$ \Gamma (x) = \int_0^\infty t^{x-1} e^{-t} dt $$
 
 ## 備考
-- $$ f(x) = \Gamma (x) $$
-- ガンマ関数は階乗の一般化である。
+- ガンマ関数は階乗の一般化である。階乗はガンマ関数を用いて $n! = \Gamma(n + 1)$ で計算できる。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = ±0` の場合、戻り値は `±∞` となり、
     [`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
@@ -64,6 +64,32 @@ namespace std {
 - `gamma` という関数は既にあったが処理系によって定義が違ったため、本当の (true) ガンマ関数 `tgamma` と名付けられた。
 - C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
+### &amp;lt;a id=&amp;#34;remarks-lgamma&amp;#34; href=&amp;#34;#remarks-lgamma&amp;#34;&amp;gt;lgamma との使い分け&amp;lt;/a&amp;gt;
+ガンマ関数は急激に増加し容易にオーバーフローするので、代わりにガンマ関数の結果を自然対数で返す関数 [`lgamma`](lgamma.md) を用いた方が良いことが多くある。
+例えばガンマ関数の比を計算する場合には、 ガンマ関数の対数の差を取ってから指数関数 [`std::exp`](exp.md) を適用するのが賢明である。
+
+$$ \frac{\Gamma(2026)}{\Gamma(2025)} = \exp[\ln\Gamma(2026) - \ln\Gamma(2025)] $$
+
+```cpp example
+#include &amp;lt;cmath&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+int main() {
+  std::cout &amp;lt;&amp;lt; std::tgamma(2026.0) / std::tgamma(2025.0) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::exp(std::lgamma(2026.0) - std::lgamma(2025.0)) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::tgamma[color ff0000]
+* std::lgamma[color 0000ff][link lgamma.md]
+
+出力例
+```
+-nan
+2025
+```
+
+上の結果では、直接ガンマ関数を計算した場合はオーバーフローによって inf / inf となり最終結果が -nan になっているが、`lgamma` を使った場合には正しい値が計算できている。
+ただし、`lgamma` は飽くまでガンマ関数の「絶対値」の対数であることに注意する。
+ガンマ関数の引数が負になる場合はガンマ関数が負の値を取りうるので符号は別に求める必要がある。
 
 ## 例
 ```cpp example
@@ -110,6 +136,8 @@ tgamma(+∞)  = inf
 
 - GCC 4.6.1 以上
 
+## 関連項目
+- ガンマ関数の絶対値の自然対数 [`lgamma`](lgamma.md)
 
 ## 参照
 - [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lgamma -- cmath (tgamma): lgamma を使うべき場合について記述</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lgamma.html"/>
      <id>932634a1150d4190d7060f9810f699e98061f462:reference/cmath/lgamma.md</id>
      <updated>2025-02-09T16:31:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lgamma.md b/reference/cmath/lgamma.md
index 60de4faba..03027e27d 100644
--- a/reference/cmath/lgamma.md
+++ b/reference/cmath/lgamma.md
@@ -60,7 +60,8 @@ namespace std {
     - `x = -∞` の場合、戻り値は `+∞` となる。
     - `x = +∞` の場合、戻り値は `+∞` となる。
 - C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
-
+- この関数はガンマ関数 ([`tgamma`](tgamma.md)) がオーバーフローするような場合に使う。
+  具体例については[ガンマ関数の備考](tgamma.md#remarks-lgamma)を参照のこと。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tgamma -- cmath (tgamma): lgamma を使うべき場合について記述</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tgamma.html"/>
      <id>932634a1150d4190d7060f9810f699e98061f462:reference/cmath/tgamma.md</id>
      <updated>2025-02-09T16:31:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tgamma.md b/reference/cmath/tgamma.md
index 4dcbd333a..615ff7717 100644
--- a/reference/cmath/tgamma.md
+++ b/reference/cmath/tgamma.md
@@ -64,6 +64,32 @@ $$ \Gamma (x) = \int_0^\infty t^{x-1} e^{-t} dt $$
 - `gamma` という関数は既にあったが処理系によって定義が違ったため、本当の (true) ガンマ関数 `tgamma` と名付けられた。
 - C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
+### &amp;lt;a id=&amp;#34;remarks-lgamma&amp;#34; href=&amp;#34;#remarks-lgamma&amp;#34;&amp;gt;lgamma との使い分け&amp;lt;/a&amp;gt;
+ガンマ関数は急激に増加し容易にオーバーフローするので、代わりにガンマ関数の結果を自然対数で返す関数 [`lgamma`](lgamma.md) を用いた方が良いことが多くある。
+例えばガンマ関数の比を計算する場合には、 ガンマ関数の対数の差を取ってから指数関数 [`std::exp`](exp.md) を適用するのが賢明である。
+
+$$ \frac{\Gamma(2026)}{\Gamma(2025)} = \exp[\ln\Gamma(2026) - \ln\Gamma(2025)] $$
+
+```cpp example
+#include &amp;lt;cmath&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+int main() {
+  std::cout &amp;lt;&amp;lt; std::tgamma(2026.0) / std::tgamma(2025.0) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; std::exp(std::lgamma(2026.0) - std::lgamma(2025.0)) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::tgamma[color ff0000]
+* std::lgamma[color 0000ff][link lgamma.md]
+
+出力例
+```
+-nan
+2025
+```
+
+上の結果では、直接ガンマ関数を計算した場合はオーバーフローによって inf / inf となり最終結果が -nan になっているが、`lgamma` を使った場合には正しい値が計算できている。
+ただし、`lgamma` は飽くまでガンマ関数の「絶対値」の対数であることに注意する。
+ガンマ関数の引数が負になる場合はガンマ関数が負の値を取りうるので符号は別に求める必要がある。
 
 ## 例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tgamma -- cmath (tgamma): 階乗とガンマ関数の関係を式で明記</title>
      <link href="https://cpprefjp.github.io/reference/cmath/tgamma.html"/>
      <id>7f763a43bee58a71fe22578c894c2074ee42af2d:reference/cmath/tgamma.md</id>
      <updated>2025-02-09T16:19:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/tgamma.md b/reference/cmath/tgamma.md
index 1a77226d8..4dcbd333a 100644
--- a/reference/cmath/tgamma.md
+++ b/reference/cmath/tgamma.md
@@ -52,7 +52,7 @@ namespace std {
 $$ \Gamma (x) = \int_0^\infty t^{x-1} e^{-t} dt $$
 
 ## 備考
-- ガンマ関数は階乗の一般化である。
+- ガンマ関数は階乗の一般化である。階乗はガンマ関数を用いて $n! = \Gamma(n + 1)$ で計算できる。
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - `x = ±0` の場合、戻り値は `±∞` となり、
     [`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
</feed>