<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-06-17T09:56:47.147461</updated>
  <id>c436a169-efdd-48ff-b039-cb4651b38d41</id>

  
    <entry>
      <title># arrive_and_drop -- barrier: arrive_and_wait例 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/arrive_and_drop.html"/>
      <id>85705d8aae51cc19644e750a326273937daf80fd:reference/barrier/barrier/arrive_and_drop.md</id>
      <updated>2020-06-17T18:51:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/arrive_and_drop.md b/reference/barrier/barrier/arrive_and_drop.md
index 16d9d395f..d5411214d 100644
--- a/reference/barrier/barrier/arrive_and_drop.md
+++ b/reference/barrier/barrier/arrive_and_drop.md
@@ -39,6 +39,7 @@ void arrive_and_drop();
 
 
 ## 例
+```cpp example
 #include &amp;lt;barrier&amp;gt;
 #include &amp;lt;chrono&amp;gt;
 #include &amp;lt;iostream&amp;gt;
@@ -90,6 +91,7 @@ int main()
   t1.join();
   t2.join();
 }
+```
 * arrive_and_drop[color ff0000]
 * arrive_and_wait[link arrive_and_wait.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>arrive_and_wait -- barrier: arrive_and_wait例 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/arrive_and_wait.html"/>
      <id>85705d8aae51cc19644e750a326273937daf80fd:reference/barrier/barrier/arrive_and_wait.md</id>
      <updated>2020-06-17T18:51:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/arrive_and_wait.md b/reference/barrier/barrier/arrive_and_wait.md
index 424ea7987..da0306bde 100644
--- a/reference/barrier/barrier/arrive_and_wait.md
+++ b/reference/barrier/barrier/arrive_and_wait.md
@@ -31,11 +31,59 @@ void arrive_and_wait();
 
 ## 例
 ```cpp example
+#include &amp;lt;barrier&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+// (ダミーの)タスク処理関数
+void do_task(const char* msg)
+{
+  static std::mutex cout_mtx;
+
+  std::this_thread::sleep_for(std::chrono::seconds(1));
+  {
+    std::lock_guard lk{cout_mtx};
+    std::cout &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; std::endl;
+  }
+}
+
+int main()
+{
+  std::barrier&amp;lt;&amp;gt; sync{2};
+
+  // ワーカスレッド起動
+  std::thread t1([&amp;amp;]{
+    do_task(&amp;#34;sub:  phase-1&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;sub:  phase-2&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;sub:  phase-3&amp;#34;);
+  });
+
+  // メインスレッド処理
+  {
+    do_task(&amp;#34;main: phase-1&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;main: phase-2&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;main: phase-3&amp;#34;);
+  }
+
+  t.join();
+}
 ```
 * arrive_and_wait[color ff0000]
 
-### 出力
+### 出力例
 ```
+sub:  phase-1
+main: phase-1
+main: phase-2
+sub:  phase-2
+sub:  phase-3
+main: phase-3
 ```
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>barrier -- barrier: fix links</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier.html"/>
      <id>c47669588c19bbf9365723819871f0cc77c392aa:reference/barrier/barrier.md</id>
      <updated>2020-06-17T18:40:29+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier.md b/reference/barrier/barrier.md
index 2b08e932b..de9ecb7e6 100644
--- a/reference/barrier/barrier.md
+++ b/reference/barrier/barrier.md
@@ -17,9 +17,9 @@ namespace std {
 複数スレッドがバリアオブジェクト上で待ち合わせ（合流）を行うさまから、ランデブーポイント(Rendezvous Point)とも呼ばれる。
 
 バリア同期を用いると[Fork-Joinモデル](https://en.wikipedia.org/wiki/Fork%E2%80%93join_model)に基づくタスク並行構造を容易に実装できる。
-- [コンストラクタ](op_constructor.md)にてバリア同期に参加するスレッド数を設定する。
-- [`arrive_and_wait()`](arrive_and_wait.md)により自スレッドの現行フェーズ完了を通知し、他スレッド群の現行フェーズ完了を待機する。バリア同期参加中のスレッドが合流し終えると、各スレッドのブロックが解除されて次フェーズを開始する。
-- [`arrive_and_drop()`](arrive_and_drop.md)により自スレッドの現行フェーズ完了を通知し、次フェーズからはバリア同期に参加しない（参加スレッド数を1つ減らす）。バリア同期参加中のスレッドが合流し終えると、自スレッド以外のブロックが解除されて次フェーズを開始する。
+- [コンストラクタ](barrier/op_constructor.md)にてバリア同期に参加するスレッド数を設定する。
+- [`arrive_and_wait()`](barrier/arrive_and_wait.md)により自スレッドの現行フェーズ完了を通知し、他スレッド群の現行フェーズ完了を待機する。バリア同期参加中のスレッドが合流し終えると、各スレッドのブロックが解除されて次フェーズを開始する。
+- [`arrive_and_drop()`](barrier/arrive_and_drop.md)により自スレッドの現行フェーズ完了を通知し、次フェーズからはバリア同期に参加しない（参加スレッド数を1つ減らす）。バリア同期参加中のスレッドが合流し終えると、自スレッド以外のブロックが解除されて次フェーズを開始する。
 
 バリアオブジェクトは複数スレッド間の合流制御を繰り返して行えるが、1回のみの制御で十分ならばラッチ[`latch`](/reference/latch/latch.md)も利用候補となりえる。
 
@@ -129,7 +129,7 @@ int main()
 }
 ```
 * std::barrier[color ff0000]
-* arrive_and_wait()[link arrive_and_wait.md]
+* arrive_and_wait()[link barrier/arrive_and_wait.md]
 
 ### 出力例
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>barrier -- barrier: 全メンバ関数 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier.html"/>
      <id>acde49ec24e52212a081e452960fc2becb42362e:reference/barrier/barrier.md</id>
      <updated>2020-06-17T18:35:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier.md b/reference/barrier/barrier.md
index 708dcb662..2b08e932b 100644
--- a/reference/barrier/barrier.md
+++ b/reference/barrier/barrier.md
@@ -16,20 +16,25 @@ namespace std {
 [バリア](https://en.wikipedia.org/wiki/Barrier_(computer_science))の存続期間はバリアフェーズの列からなり、各フェーズでは予定スレッド数がバリアに到達するまで先行到達スレッドの実行をブロックできる。
 複数スレッドがバリアオブジェクト上で待ち合わせ（合流）を行うさまから、ランデブーポイント(Rendezvous Point)とも呼ばれる。
 
-バリアオブジェクトは複数スレッド間の合流制御を繰り返し行えるが、1回のみの制御で十分ならばラッチ[`latch`](/reference/latch/latch.md)を利用する。
+バリア同期を用いると[Fork-Joinモデル](https://en.wikipedia.org/wiki/Fork%E2%80%93join_model)に基づくタスク並行構造を容易に実装できる。
+- [コンストラクタ](op_constructor.md)にてバリア同期に参加するスレッド数を設定する。
+- [`arrive_and_wait()`](arrive_and_wait.md)により自スレッドの現行フェーズ完了を通知し、他スレッド群の現行フェーズ完了を待機する。バリア同期参加中のスレッドが合流し終えると、各スレッドのブロックが解除されて次フェーズを開始する。
+- [`arrive_and_drop()`](arrive_and_drop.md)により自スレッドの現行フェーズ完了を通知し、次フェーズからはバリア同期に参加しない（参加スレッド数を1つ減らす）。バリア同期参加中のスレッドが合流し終えると、自スレッド以外のブロックが解除されて次フェーズを開始する。
+
+バリアオブジェクトは複数スレッド間の合流制御を繰り返して行えるが、1回のみの制御で十分ならばラッチ[`latch`](/reference/latch/latch.md)も利用候補となりえる。
 
 ### 詳細説明
 説明のため、ここではバリアオブジェクトが保持する`CompletionFunction`型のデータメンバを`completion`と表記する。
-同データメンバ`completion`は、[コンストラクタ](barrier/op_constructor.md.nolink)にて設定される。
+同データメンバ`completion`は、[コンストラクタ](barrier/op_constructor.md)にて設定される。
 
 各バリアフェーズ(barrier phase)は下記のステップで構成される：
 
-- [`arrive()`](barrier/arrive.md.nolink)または[`arrive_and_drop`](barrier/arrive_and_drop.md.nolink)呼び出しによって、予定カウントを減算する。
-- 予定カウントが`0`に到達したら、完了ステップを実行する。テンプレートパラメータ`CompletionFunction`のデフォルト値に対する特殊化では、完了ステップは予定カウントを`0`とした[`arrive()`](barrier/arrive.md.nolink)または[`arrive_and_drop`](barrier/arrive_and_drop.md.nolink)呼び出しの一部として実行される。それ以外の特殊化では、完了ステップはそのフェーズ内でバリア到達したスレッドのいずれか1つの上で実行される。
-- 完了ステップが終了したのち、予定カウントをコンストラクタ実引数`expected`でリセットし、[`arrive_and_drop`](barrier/arrive_and_drop.md.nolink)呼び出しの場合は調整を行って、次のフェーズを開始する。
+- [`arrive()`](barrier/arrive.md)または[`arrive_and_drop`](barrier/arrive_and_drop.md)呼び出しによって、予定カウントを減算する。
+- 予定カウントが`0`に到達したら、完了ステップを実行する。テンプレートパラメータ`CompletionFunction`のデフォルト値に対する特殊化では、完了ステップは予定カウントを`0`とした[`arrive()`](barrier/arrive.md)または[`arrive_and_drop`](barrier/arrive_and_drop.md)呼び出しの一部として実行される。それ以外の特殊化では、完了ステップはそのフェーズ内でバリア到達したスレッドのいずれか1つの上で実行される。
+- 完了ステップが終了したのち、予定カウントをコンストラクタ実引数`expected`でリセットし、[`arrive_and_drop`](barrier/arrive_and_drop.md)呼び出しの場合は調整を行って、次のフェーズを開始する。
 
 各フェーズは、フェーズ同期ポイント(phase synchronization point)を定義する。
-フェーズ内でバリアに到達したスレッドは、[`wait()`](barrier/wait.md.nolink)呼び出しによりフェーズ同期ポイント上でブロックされ、フェーズ完了ステップが実行されるまでブロック状態は継続する。
+フェーズ内でバリアに到達したスレッドは、[`wait()`](barrier/wait.md)呼び出しによりフェーズ同期ポイント上でブロックされ、フェーズ完了ステップが実行されるまでブロック状態は継続する。
 
 フェーズ完了ステップ(phase completion step)は各フェーズ終了時に実行され、下記の効果を持つ：
 
@@ -37,7 +42,7 @@ namespace std {
 - フェーズ同期ポイント上でブロックされている全スレッドのブロックを解除する。
 
 完了ステップの終了は、完了ステップによりブロック解除される全ての関数呼び出しからの復帰よりも、確実に前に発生(strongly happens before)する。
-テンプレートパラメータ`CompletionFunction`のデフォルト値以外の特殊化においては、完了ステップの進行中にバリアオブジェクトの[`wait()`](barrier/wait.md.nolink)を除くメンバ関数が呼び出されると、その動作は未定義となる。
+テンプレートパラメータ`CompletionFunction`のデフォルト値以外の特殊化においては、完了ステップの進行中にバリアオブジェクトの[`wait()`](barrier/wait.md)を除くメンバ関数が呼び出されると、その動作は未定義となる。
 
 テンプレートパラメータ`CompletionFunction`のデフォルト値は、追加で Cpp17DefaultConstructible 要件を満たす未規定の型であり、式`completion()`は何の副作用も生じない。
 つまりテンプレートパラメータを省略した`barrier&amp;lt;&amp;gt;`オブジェクトでは、各フェーズ完了時に追加的な処理を行わない。
@@ -55,19 +60,19 @@ namespace std {
 
 | 名前            | 説明           | 対応バージョン |
 |-----------------|----------------|----------------|
-| [`(constructor)`](barrier/op_constructor.md.nolink) | コンストラクタ | C++20 |
+| [`(constructor)`](barrier/op_constructor.md) | コンストラクタ | C++20 |
 | `(destructor)`  | デストラクタ   | C++20 |
 | `operator=(const barrier&amp;amp;) = delete;` | 代入演算子 | C++20 |
-| [`arrive`](barrier/arrive.md.nolink) | 到達通知 | C++20 |
-| [`wait`](barrier/wait.md.nolink) | 待機処理 | C++20 |
-| [`arrive_and_wait`](barrier/arrive_and_wait.md.nolink) | 到達通知と待機処理 | C++20 |
-| [`arrive_and_drop`](barrier/arrive_and_drop.md.nolink) | 到達通知後に離脱 | C++20 |
+| [`arrive`](barrier/arrive.md) | 到達通知 | C++20 |
+| [`wait`](barrier/wait.md) | 待機処理 | C++20 |
+| [`arrive_and_wait`](barrier/arrive_and_wait.md) | 到達通知と待機処理 | C++20 |
+| [`arrive_and_drop`](barrier/arrive_and_drop.md) | 到達通知後に離脱 | C++20 |
 
 ## 静的メンバ関数
 
 | 名前            | 説明           | 対応バージョン |
 |-----------------|----------------|----------------|
-| [`max`](barrier/max.md.nolink) | 処理系がサポートする予定カウントの最大値 | C++20 |
+| [`max`](barrier/max.md) | 処理系がサポートする予定カウントの最大値 | C++20 |
 
 ## メンバ型
 
@@ -124,7 +129,7 @@ int main()
 }
 ```
 * std::barrier[color ff0000]
-* arrive_and_wait()[link arrive_and_wait.md.nolink]
+* arrive_and_wait()[link arrive_and_wait.md]
 
 ### 出力例
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>arrive -- barrier: 全メンバ関数 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/arrive.html"/>
      <id>acde49ec24e52212a081e452960fc2becb42362e:reference/barrier/barrier/arrive.md</id>
      <updated>2020-06-17T18:35:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/arrive.md b/reference/barrier/barrier/arrive.md
new file mode 100644
index 000000000..c31a99f17
--- /dev/null
+++ b/reference/barrier/barrier/arrive.md
@@ -0,0 +1,122 @@
+# arrive
+* barrier[meta header]
+* std[meta namespace]
+* barrier[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+[[nodiscard]] arrival_token arrive(ptrdiff_t update = 1);
+```
+* ptrdiff_t[link /reference/cstddef/ptrdiff_t.md]
+
+## 概要
+バリアのフェーズ同期ポイントへの到達通知を行い、待機処理用の到達トークンを発行する。
+設定されていれば、次フェーズへの移行前に完了関数を呼び出す。
+
+
+## 事前条件
+`updte &amp;gt; 0` かつ `update` が現行バリアフェーズの予定カウントに等しいかそれより小さいこと。
+
+
+## 効果
+現行フェーズのフェーズ同期ポイントに関連付けされた`arrival_token`型オブジェクトを構築する。
+その後に、予定カウントを`update`だけ減算する。
+
+
+## 戻り値
+構築された`arrival_token`オブジェクトを返す。
+
+
+## 例外
+この関数は、以下のerror conditionを持つ[`system_error`](/reference/system_error/system_error.md)例外オブジェクトを送出する可能性がある：
+
+- [`resource_unavailable_try_again`](/reference/system_error/errc.md) : 操作対象のネイティブハンドル型が無効
+- [`operation_not_permitted`](/reference/system_error/errc.md) : スレッドにこの操作を行う権限がない
+- [`invalid_argument`](/reference/system_error/errc.md) : 実引数が無効
+
+
+## 備考
+このメンバ関数呼び出しは、現行フェーズの完了ステップを開始する可能性がある。
+
+
+## 例
+```cpp example
+#include &amp;lt;barrier&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+// (ダミーの)タスク処理関数
+void do_task(const char* msg)
+{
+  static std::mutex cout_mtx;
+
+  std::this_thread::sleep_for(std::chrono::seconds(1));
+  {
+    std::lock_guard lk{cout_mtx};
+    std::cout &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; std::endl;
+  }
+}
+
+int main()
+{
+  std::barrier&amp;lt;&amp;gt; sync{2};
+
+  // ワーカスレッド起動
+  std::thread t([&amp;amp;]{
+    do_task(&amp;#34;sub:  phase-1&amp;#34;);
+
+    // 自スレッドはブロックせずに第2フェーズに移行し、
+    // 第1フェーズ同期ポイント待機用トークンを発行する。
+    auto token = sync.arrive();
+    do_task(&amp;#34;sub:  phase-2(a)&amp;#34;);
+
+    // 第1のフェーズ同期ポイントで待機する。
+    sync.wait(std::move(token));
+    do_task(&amp;#34;sub:  phase-2(b)&amp;#34;);
+  });
+
+  // メインスレッド処理
+  {
+    do_task(&amp;#34;main: phase-1(a)&amp;#34;);
+    do_task(&amp;#34;main: phase-1(b)&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;main: phase-2&amp;#34;);
+  }
+
+  t.join();
+}
+```
+* arrive[color ff0000]
+* wait[link wait.md]
+* arrive_and_wait[link arrive_and_wait.md]
+* std::move[link /reference/utility/move.md]
+
+### 出力例
+```
+main: phase-1(a)
+sub:  phase-1
+main: phase-1(b)
+sub:  phase-2(a)
+sub:  phase-2(b)
+main: phase-2
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 11.0
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`wait()`](wait.md)
+- [`arrive_and_wait()`](arrive_and_wait.md)
+- [`arrive_and_drop()`](arrive_and_drop.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title># arrive_and_drop -- barrier: 全メンバ関数 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/arrive_and_drop.html"/>
      <id>acde49ec24e52212a081e452960fc2becb42362e:reference/barrier/barrier/arrive_and_drop.md</id>
      <updated>2020-06-17T18:35:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/arrive_and_drop.md b/reference/barrier/barrier/arrive_and_drop.md
new file mode 100644
index 000000000..16d9d395f
--- /dev/null
+++ b/reference/barrier/barrier/arrive_and_drop.md
@@ -0,0 +1,120 @@
+## arrive_and_drop
+* barrier[meta header]
+* std[meta namespace]
+* barrier[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+void arrive_and_drop();
+```
+
+## 概要
+バリアのフェーズ同期ポイントへの到達通知を行い、自スレッドは次フェーズ以降のバリア同期から離脱する。
+設定されていれば、次フェーズへの移行前に完了関数を呼び出す。
+
+
+## 事前条件
+現行バリアフェーズの予定カウントが、`0`より大きいこと。
+
+
+## 効果
+全ての後続フェーズの初期予定カウントを`1`だけ減算する。
+その後に、現行フェーズの予定カウントを`1`だけ減算する。
+
+
+## 戻り値
+なし
+
+
+## 例外
+この関数は、以下のerror conditionを持つ[`system_error`](/reference/system_error/system_error.md)例外オブジェクトを送出する可能性がある：
+
+- [`resource_unavailable_try_again`](/reference/system_error/errc.md) : 操作対象のネイティブハンドル型が無効
+- [`operation_not_permitted`](/reference/system_error/errc.md) : スレッドにこの操作を行う権限がない
+
+
+## 備考
+このメンバ関数呼び出しは、現行フェーズの完了ステップを開始する可能性がある。
+
+
+## 例
+#include &amp;lt;barrier&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+// (ダミーの)タスク処理関数
+void do_task(const char* msg)
+{
+  static std::mutex cout_mtx;
+
+  std::this_thread::sleep_for(std::chrono::seconds(1));
+  {
+    std::lock_guard lk{cout_mtx};
+    std::cout &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; std::endl;
+  }
+}
+
+int main()
+{
+  std::barrier&amp;lt;&amp;gt; sync{3};
+
+  // ワーカスレッド#1起動
+  std::thread t1([&amp;amp;]{
+    do_task(&amp;#34;sub1: phase-1&amp;#34;);
+    sync.arrive_and_drop();
+    // フェーズ#2以降は離脱
+  });
+
+  // ワーカスレッド#2起動
+  std::thread t2([&amp;amp;]{
+    do_task(&amp;#34;sub2: phase-1&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;sub2: phase-2&amp;#34;);
+    sync.arrive_and_drop();
+    // フェーズ#3以降は離脱
+  });
+
+  // メインスレッド処理
+  {
+    do_task(&amp;#34;main: phase-1&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;main: phase-2&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;main: phase-3&amp;#34;);
+    sync.arrive_and_wait();
+  }
+
+  t1.join();
+  t2.join();
+}
+* arrive_and_drop[color ff0000]
+* arrive_and_wait[link arrive_and_wait.md]
+
+### 出力例
+```
+sub2: phase-1
+main: phase-1
+sub1: phase-1
+sub2: phase-2
+main: phase-2
+main: phase-3
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 11.0
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`arrive()`](arrive.md)
+- [`arrive_and_wait()`](arrive_and_wait.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>arrive_and_wait -- barrier: 全メンバ関数 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/arrive_and_wait.html"/>
      <id>acde49ec24e52212a081e452960fc2becb42362e:reference/barrier/barrier/arrive_and_wait.md</id>
      <updated>2020-06-17T18:35:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/arrive_and_wait.md b/reference/barrier/barrier/arrive_and_wait.md
new file mode 100644
index 000000000..424ea7987
--- /dev/null
+++ b/reference/barrier/barrier/arrive_and_wait.md
@@ -0,0 +1,56 @@
+# arrive_and_wait
+* barrier[meta header]
+* std[meta namespace]
+* barrier[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+void arrive_and_wait();
+```
+
+## 概要
+バリアのフェーズ同期ポイント上での待ち合わせ（到達通知と待機処理）を行う。
+設定されていれば、次フェーズへの移行前に完了関数を呼び出す。
+
+
+## 効果
+[`wait`](wait.md)`(`[`arrive()`](arrive.md)`)` と等価。
+
+
+## 戻り値
+なし
+
+
+## 例外
+この関数は、以下のerror conditionを持つ[`system_error`](/reference/system_error/system_error.md)例外オブジェクトを送出する可能性がある：
+
+- [`resource_unavailable_try_again`](/reference/system_error/errc.md) : 操作対象のネイティブハンドル型が無効
+- [`operation_not_permitted`](/reference/system_error/errc.md) : スレッドにこの操作を行う権限がない
+
+
+## 例
+```cpp example
+```
+* arrive_and_wait[color ff0000]
+
+### 出力
+```
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 11.0
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`arrive()`](arrive.md)
+- [`wait()`](wait.md)
+- [`arrive_and_drop()`](arrive_and_drop.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>max -- barrier: 全メンバ関数 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/max.html"/>
      <id>acde49ec24e52212a081e452960fc2becb42362e:reference/barrier/barrier/max.md</id>
      <updated>2020-06-17T18:35:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/max.md b/reference/barrier/barrier/max.md
new file mode 100644
index 000000000..cf958d6f0
--- /dev/null
+++ b/reference/barrier/barrier/max.md
@@ -0,0 +1,51 @@
+# max
+* barrier[meta header]
+* std[meta namespace]
+* barrier[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+static constexpr ptrdiff_t max() noexcept;
+```
+* ptrdiff_t[link /reference/cstddef/ptrdiff_t.md]
+
+## 概要
+処理系がサポートする予定カウントの最大値
+
+
+## 戻り値
+処理系がサポートする予定カウントの最大値を返す。
+
+
+## 例外
+投げない
+
+
+## 例
+```cpp example
+#include &amp;lt;barrier&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; std::barrier&amp;lt;&amp;gt;::max() &amp;lt;&amp;lt; std::endl;
+}
+```
+* max()[color ff0000]
+
+### 出力例
+```
+9223372036854775807
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 11.0
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- barrier: 全メンバ関数 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/op_constructor.html"/>
      <id>acde49ec24e52212a081e452960fc2becb42362e:reference/barrier/barrier/op_constructor.md</id>
      <updated>2020-06-17T18:35:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/op_constructor.md b/reference/barrier/barrier/op_constructor.md
new file mode 100644
index 000000000..577a2320b
--- /dev/null
+++ b/reference/barrier/barrier/op_constructor.md
@@ -0,0 +1,109 @@
+# コンストラクタ
+* barrier[meta header]
+* std[meta namespace]
+* barrier[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+constexpr explicit
+barrier(ptrdiff_t expected,
+        CompletionFunction f = CompletionFunction()); // (1)
+
+barrier(const barrier&amp;amp;) = delete;                     // (2)
+```
+* ptrdiff_t[link /reference/cstddef/ptrdiff_t.md]
+
+## barrierオブジェクトの構築
+- (1) : `barrier`オブジェクトの初期化を行う。
+- (2) : コピーコンストラクタ。コピー不可。
+
+説明のため、ここではバリアオブジェクトが保持する`CompletionFunction`型のデータメンバを`completion`と表記する。
+
+
+## 事前条件
+`expected &amp;gt;= 0` かつ `expected &amp;lt;=` [`max()`](max.md)
+
+
+## 効果
+各バリアフェーズの初期予定カウントと、初回フェーズにおける現行予定カウントの両方に`expected`を設定する。
+`completion`を[`std::move`](/reference/utility/move.md)`(f)`で初期化する。
+初回フェーズを開始する。
+
+
+## 例外
+`CompletionFunction`型のムーブコンストラクタが投げた例外
+
+
+## 備考
+`expected`を`0`として初期化したバリアオブジェクトでは、破棄以外の操作を行えない。
+
+
+## 例
+```cpp example
+#include &amp;lt;barrier&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;mutex&amp;gt;
+
+// 行単位cout出力用ロックを返す（対応コンパイラ登場までの暫定措置）
+// C++20で追加されたstd::osyncstreamの方が好ましい。
+//   std::osyncstream(std::cout) &amp;lt;&amp;lt; ...;
+auto lk() {
+  static std::mutex cout_mtx;
+  return std::unique_lock{cout_mtx};
+}
+
+int main() {
+  // （完了関数なし）バリアを定義
+  std::barrier&amp;lt;&amp;gt; sync1{2};
+
+  // 完了関数付きのバリアを定義
+  std::barrier sync2{2, []{
+    // 完了関数はバリアに関与するいずれか一つのスレッド上でのみ実行されること保証される
+    std::cout &amp;lt;&amp;lt; &amp;#34;finished @&amp;#34; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; std::endl;
+  }};
+
+  // 並行実行されるタスクを定義
+  auto task = [&amp;amp;]{
+    lk(), std::cout &amp;lt;&amp;lt; &amp;#34;phase-1  @&amp;#34; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; std::endl;
+    sync2.arrive_and_wait();
+    lk(), std::cout &amp;lt;&amp;lt; &amp;#34;phase-2  @&amp;#34; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; std::endl;
+    sync2.arrive_and_wait();
+    lk(), std::cout &amp;lt;&amp;lt; &amp;#34;phase-3  @&amp;#34; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; std::endl;
+    sync1.arrive_and_wait();
+  };
+
+  // タスクを2並行実行
+  std::thread t{task};
+  task();
+  t.join();
+}
+```
+* std::barrier[color ff0000]
+* arrive_and_wait()[link arrive_and_wait.md]
+* std::osyncstream[link /reference/syncstream/basic_osyncstream.md]
+* std::this_thread::get_id()[link /reference/thread/this_thread/get_id.md]
+
+### 出力例
+```
+phase-1  @140171090683648
+phase-1  @140171067340544
+finished @140171067340544
+phase-2  @140171067340544
+phase-2  @140171090683648
+finished @140171090683648
+phase-3  @140171090683648
+phase-3  @140171067340544
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 11.0
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>wait -- barrier: 全メンバ関数 (#684)</title>
      <link href="https://cpprefjp.github.io/reference/barrier/barrier/wait.html"/>
      <id>acde49ec24e52212a081e452960fc2becb42362e:reference/barrier/barrier/wait.md</id>
      <updated>2020-06-17T18:35:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/barrier/barrier/wait.md b/reference/barrier/barrier/wait.md
new file mode 100644
index 000000000..8971a60dd
--- /dev/null
+++ b/reference/barrier/barrier/wait.md
@@ -0,0 +1,114 @@
+# wait
+* barrier[meta header]
+* std[meta namespace]
+* barrier[meta class]
+* function[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+void wait(arrival_token&amp;amp;&amp;amp; arrival) const;
+```
+
+## 概要
+バリアのフェーズ同期ポイント上での待機処理のみ行う。
+
+
+## 事前条件
+`arrival`が、現行フェーズまたは同じバリアオブジェクトの直前フェーズのフェーズ同期ポイントに関連付けされていること。
+
+
+## 効果
+[`std::move`](/reference/utility/move.md)`(arrival)`に関連付けされた同期ポイントにおいて、該当同期ポイントのフェーズにおけるフェーズ完了ステップが実行されるまで、呼び出しスレッドをブロックする。
+
+
+## 戻り値
+なし
+
+
+## 例外
+この関数は、以下のerror conditionを持つ[`system_error`](/reference/system_error/system_error.md)例外オブジェクトを送出する可能性がある：
+
+- [`resource_unavailable_try_again`](/reference/system_error/errc.md) : 操作対象のネイティブハンドル型が無効
+- [`operation_not_permitted`](/reference/system_error/errc.md) : スレッドにこの操作を行う権限がない
+- [`invalid_argument`](/reference/system_error/errc.md) : 実引数が無効
+
+
+## 例
+```cpp example
+#include &amp;lt;barrier&amp;gt;
+#include &amp;lt;chrono&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;thread&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+// (ダミーの)タスク処理関数
+void do_task(const char* msg)
+{
+  static std::mutex cout_mtx;
+
+  std::this_thread::sleep_for(std::chrono::seconds(1));
+  {
+    std::lock_guard lk{cout_mtx};
+    std::cout &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; std::endl;
+  }
+}
+
+int main()
+{
+  std::barrier&amp;lt;&amp;gt; sync{2};
+
+  // ワーカスレッド起動
+  std::thread t([&amp;amp;]{
+    do_task(&amp;#34;sub:  phase-1&amp;#34;);
+
+    // 自スレッドはブロックせずに第2フェーズに移行し、
+    // 第1フェーズ同期ポイント待機用トークンを発行する。
+    auto token = sync.arrive();
+    do_task(&amp;#34;sub:  phase-2(a)&amp;#34;);
+
+    // 第1のフェーズ同期ポイントで待機する。
+    sync.wait(std::move(token));
+    do_task(&amp;#34;sub:  phase-2(b)&amp;#34;);
+  });
+
+  // メインスレッド処理
+  {
+    do_task(&amp;#34;main: phase-1(a)&amp;#34;);
+    do_task(&amp;#34;main: phase-1(b)&amp;#34;);
+    sync.arrive_and_wait();
+    do_task(&amp;#34;main: phase-2&amp;#34;);
+  }
+
+  t.join();
+}
+```
+* wait[color ff0000]
+* arrive[link wait.md]
+* arrive_and_wait[link arrive_and_wait.md]
+* std::move[link /reference/utility/move.md]
+
+### 出力例
+```
+main: phase-1(a)
+sub:  phase-1
+main: phase-1(b)
+sub:  phase-2(a)
+sub:  phase-2(b)
+main: phase-2
+```
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): 11.0
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`arrive()`](arrive.md)
+- [`arrive_and_wait()`](arrive_and_wait.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>一貫比較 -- C++20一貫比較 : P2085R0対応</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html"/>
      <id>918dd2bf794db3662e01818e3878f96cbbb3cc6b:lang/cpp20/consistent_comparison.md</id>
      <updated>2020-06-17T14:13:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/consistent_comparison.md b/lang/cpp20/consistent_comparison.md
index d291c10ce..b5ec41b3a 100644
--- a/lang/cpp20/consistent_comparison.md
+++ b/lang/cpp20/consistent_comparison.md
@@ -298,16 +298,28 @@ bool eq2 = a == category::C;  //ok
 
 ```cpp
 struct C {
-  //有効な&amp;lt;=&amp;gt;のdefault宣言（3つのうちいずれか）
+  //有効な&amp;lt;=&amp;gt;のdefault宣言例
   auto operator&amp;lt;=&amp;gt;(const C&amp;amp;) const = default;
   friend auto operator&amp;lt;=&amp;gt;(const C&amp;amp;, const C&amp;amp;) = default;
   friend auto operator&amp;lt;=&amp;gt;(C, C) = default;
 
-  //有効な==のdefault宣言（3つのうちいずれか）
+  //有効な==のdefault宣言例
   bool operator==(const C&amp;amp;) const = default;
   friend bool operator==(const C&amp;amp;, const C&amp;amp;) = default;
   friend bool operator==(C, C) = default;
+
+  //クラス外で定義することもできる
+  auto operator&amp;lt;=&amp;gt;(const C&amp;amp;) const;
+  bool operator== (const C&amp;amp;) const;
+  friend auto operator&amp;lt;=&amp;gt;(const C&amp;amp;, const C&amp;amp;);
+  friend bool operator== (const C&amp;amp;, const C&amp;amp;);
 };
+
+//クラス外定義は別の翻訳単位にあってもok
+auto C::operator&amp;lt;=&amp;gt;(const C&amp;amp;) const = default;
+bool C::operator== (const C&amp;amp;) const = default;
+inline auto operator&amp;lt;=&amp;gt;(const C&amp;amp;, const C&amp;amp;) = default;
+inline bool operator== (const C&amp;amp;, const C&amp;amp;) = default;
 ```
 
 `&amp;lt;=&amp;gt;`をdefault宣言した場合、対応する`==`が暗黙的にdefault宣言される。そのアクセス指定は同一であり、`friend`であるかも`&amp;lt;=&amp;gt;`に従う。  
@@ -783,6 +795,8 @@ struct has_vector {
         - 不要になった`_equality`な比較カテゴリ型の削除
     10. [P1946R0 Allow defaulting comparisons by value](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1946r0.html)
         - `&amp;lt;=&amp;gt; ==`の`friend`な`default`宣言の調整
+    11. [P2085R0 Consistent defaulted comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2085r0.html)
+        - `&amp;lt;=&amp;gt; ==`の`default`宣言をクラス外でも行えるようにする
 - 以前に検討されていた提案文書
     - [N3950 Defaulted comparison operators](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3950.html)
     - [N4114 Defaulted comparison operators](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4114.htm)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>indirectly_writable -- indirectly_writable : リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirectly_writable.html"/>
      <id>11f9c2620c5c74087d5deb0a80421b4a31c0d7bd:reference/iterator/indirectly_writable.md</id>
      <updated>2020-06-17T12:12:54+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirectly_writable.md b/reference/iterator/indirectly_writable.md
index 1eded4a77..2cd6e95fe 100644
--- a/reference/iterator/indirectly_writable.md
+++ b/reference/iterator/indirectly_writable.md
@@ -41,7 +41,7 @@ namespace std {
 indirectly_readable&amp;lt;Out&amp;gt; &amp;amp;&amp;amp; same_as&amp;lt;iter_value_t&amp;lt;Out&amp;gt;, decay_t&amp;lt;T&amp;gt;&amp;gt;
 ```
 * indirectly_readable[link indirectly_readablemd]
-* same_as[link /reference/concpets/same_as.md]
+* same_as[link /reference/concepts/same_as.md]
 * iter_value_t[link /reference/iterator/iter_value_t.md]
 * decay_t[link /reference/type_traits/decay.md]
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>