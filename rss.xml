<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-14T11:50:58.816065</updated>
  <id>3c83e0de-957a-4c42-a87c-ba169062c064</id>

  
    <entry>
      <title>編集方針 -- CONTRIBUTINGとstart_editingが重複していたので整理</title>
      <link href="https://cpprefjp.github.io/edit_policy.html"/>
      <id>3918a5059050dd68afaf130f76fb2f345105f576:edit_policy.md</id>
      <updated>2023-01-14T20:46:28+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;編集方針&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ここでは、本サイトを編集するにあたっての方針をまとめます。&lt;/p&gt;
&lt;h2&gt;できる限り全てのコンテンツにひとつ以上のサンプルコードを付ける&lt;/h2&gt;
&lt;p&gt;本サイトが提供するコンテンツは、全ての関数、全てのクラスにひとつ以上のサンプルコードを提供することを目標としています。これによって、ユーザーがその機能をどのように使えばよいのかの道を示せるようにし、その機能をどのような用途で使えるかを示せるようにします。&lt;/p&gt;
&lt;h2&gt;正確なものに不要な情報はない&lt;/h2&gt;
&lt;p&gt;本サイトが提供するコンテンツは、編集者間での合意がとれるものである限りにおいて、「提供しなくてよい情報」というものはないと考えています。情報を書きすぎてはいけないということはありませんので、情報不足と思われる場所を見つけたら、現在の本サイトのスコープに収まる限りは追記していただいてかまいません。&lt;/p&gt;
&lt;p&gt;スコープを超えるコンテンツを提供したい場合には、pull requestかissueを発行して、合意をとってください。&lt;/p&gt;
&lt;h2&gt;本サイトは翻訳サイトではない&lt;/h2&gt;
&lt;p&gt;本サイトは、C++の規格書や他のリファレンスサイトの翻訳を提供するサイトではありません。本サイトのコンテンツは、仕様を理解した編集者が自分たちなりの言葉でC++機能の解説を書き、提供します。&lt;/p&gt;
&lt;h2&gt;ほかの人が書いたコンテンツの編集方法&lt;/h2&gt;
&lt;p&gt;本サイトには、多くの方がコンテンツを提供しています。そのため、ほかの人が書いたコンテンツを編集することも少なくありません。編集者間での考え方の違いによるトラブルを防止するために、ほかの人が書いたコンテンツを編集する際は、以下のフローで修正の仕方を検討していただければと思います：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修正方針がわからない・複数考えられるが決めかねるようならissueを作って確認をとる&lt;/li&gt;
&lt;li&gt;修正はできるが、修正内容について修正者以外の合意・確認が必要そうならpull requestを作る&lt;/li&gt;
&lt;li&gt;元の記事を書いた人に伝えておきたいだけなら、事前にコメントを飛ばしたうえで直接修正する&lt;/li&gt;
&lt;li&gt;1.〜3.のようなことが何もなければ直接修正してかまわない。ただし、修正の理由や根拠は、修正内容かコミットメッセージのどちらかでフォローしておいたほうがよい&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;なお、「ほかの人が書いたコンテンツ」には、本サイトの方針も含まれます。方針の改訂を提案する場合にも、上記フローでお願いします。&lt;/p&gt;
&lt;h2&gt;本サイトのスコープを超えるコンテンツを書くには&lt;/h2&gt;
&lt;p&gt;本サイトでは多くのコンテンツを提供していますが、考えられる限り全ての情報を記載しているわけではありません。現在の本サイトが提供している範囲を超えるコンテンツを提供したい場合には、issueもしくはpull requestを作って合意をとってください。&lt;/p&gt;
&lt;h2&gt;困ったことがあったらissueで相談&lt;/h2&gt;
&lt;p&gt;本サイトの編集にあたって、編集者間の相談にはissueを使用してください。編集者間で直接やりとりしていただいてもかまいませんが、本サイトの記録として残したほうがよいやりとりであると判断した場合には、そのやりとりを本リポジトリのissueに貼り付けたり、リンクを貼ったりしていただければと思います。&lt;/p&gt;
&lt;p&gt;ただし、編集者間の合意が必要あるものは、編集者間の直接のやりとりではなく、必ず本リポジトリのissueかpull requestで相談してください。オープンに議論できるものについては、管理者も同様です。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cpprefjpを編集するには -- CONTRIBUTINGとstart_editingが重複していたので整理</title>
      <link href="https://cpprefjp.github.io/start_editing.html"/>
      <id>3918a5059050dd68afaf130f76fb2f345105f576:start_editing.md</id>
      <updated>2023-01-14T20:46:28+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;cpprefjpを編集するには&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本cpprefjpサイトは、GitHub Pagesのサービス上に構築されていますが、編集自体はGitHubリポジトリにあるMarkdown形式のプレーンテキストで行います。&lt;/p&gt;
&lt;p&gt;cpprefjpサイトのGitHubリポジトリは、以下になります：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cpprefjp/site&#34; target=&#34;_blank&#34;&gt;https://github.com/cpprefjp/site&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、cpprefjpサイト上に掲載する画像ファイルのようなリソースも、GitHubリポジトリで管理しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cpprefjp/image&#34; target=&#34;_blank&#34;&gt;画像ファイルリポジトリ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;GitHubからcpprefjpサイトへの自動反映&lt;/h2&gt;
&lt;p&gt;GitHub上で記述したMarkdown(.md)形式のリファレンスは、GitHub Actionsによって自動的にHTMLに変換されて、cpprefjpサイトに反映されます。&lt;/p&gt;
&lt;h3&gt;反映間隔&lt;/h3&gt;
&lt;p&gt;cpprefjp/site へ push すると、すぐに反映されます。&lt;/p&gt;
&lt;p&gt;毎日深夜0時ころに全ページの変換を行います。ページを追加したときのサイドバーの更新や、&lt;code&gt;GLOBAL_QUALIFY_LIST.txt&lt;/code&gt;を編集した場合の適用は、そのときの変換で全ページに変更が適用されます。&lt;/p&gt;
&lt;p&gt;日次の変換中にコミットした変更は、日次の変換がおわったあと (だいたい1時間30分〜2時間くらい) に自動で変換・反映されます。&lt;/p&gt;
&lt;h3&gt;変換エラーの検出&lt;/h3&gt;
&lt;p&gt;変換時になんらかのエラーが発生した場合には、GitHub Actionsが失敗します。その場合、手元で修正して再度git pushを行うことになります&lt;/p&gt;
&lt;p&gt;変換エラーではなく、GitHub Pagesリポジトリへのgit pushに失敗した場合 (buildアクションの実行中に新たなコミットがgit pushされた場合など) には、そのbuildアクションに対してRe-run jobを実行し、再度変換を行ってください&lt;/p&gt;
&lt;h3&gt;自動反映ツール&lt;/h3&gt;
&lt;p&gt;自動反映ツールも、GitHub上で開発が進められています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cpprefjp/site_generator&#34; target=&#34;_blank&#34;&gt;site_generator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;機能要望やpull request等がありましたら、こちらにお願いします。&lt;/p&gt;
&lt;h2&gt;編集権限を得るには&lt;/h2&gt;
&lt;p&gt;push権限を持っていない方は、pull requestで何らかの編集を行うところからはじめてください。タスクを引き取っていただける場合には、タスクのissueに「やります」とコメントを書いていただければ、担当をお渡しします。&lt;/p&gt;
&lt;p&gt;本サイトに対してpull requestを提出していただければ、取り込んだあとに管理者から編集権限をお渡しします。&lt;/p&gt;
&lt;p&gt;pull requestに慣れていない場合には、issueでの相談からはじめていただければと思います。&lt;/p&gt;
&lt;p&gt;管理者からpush権限をお渡しする申請が届いた場合には、引き受けていただけると幸いです。&lt;/p&gt;
&lt;h2&gt;Markdown形式による編集方法&lt;/h2&gt;
&lt;p&gt;cpprefjpサイトは、Markdown(.md)形式でリファレンスを記述します。&lt;/p&gt;
&lt;p&gt;Markdownは、GitHubサービス上でドキュメントを記述するフォーマットとして広く使用されている形式です。&lt;/p&gt;
&lt;p&gt;Markdownの記述方法をわかりやすく解説してくれているWebサイトは、すでに数多く存在しますので、詳細はそちらを参照してください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/Qiita/items/c686397e4a0f4f11683d&#34; target=&#34;_blank&#34;&gt;Markdown記法 チートシート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kojika17.com/2013/01/starting-markdown.html&#34; target=&#34;_blank&#34;&gt;文章作成やメモ書きにも便利、Markdown記法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ただし、cpprefjp特有の拡張構文もあります。
以下のページにまとめてあるので、そちらを参照して下さい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/start_editing/specialized.html&#34;&gt;cpprefjp特有の拡張構文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Markdown形式では、HTMLのタグも併用できますが、cpprefjpサイトでは積極的にはHTMLタグを使用しない方針です。できるだけ、Markdown形式でできる範囲内で解決するようにしてください。&lt;/p&gt;
&lt;p&gt;ただし、注釈・出典を貼るためにHTMLタグを利用します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/start_editing/cite_note_ref.html&#34;&gt;cpprefjpにおける注釈・出典の貼り方&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それ以外に本サイト内で使用しているHTMLタグは以下です：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アンカーを貼るために、&lt;code&gt;&amp;lt;a id=&#34;アンカー名&#34;&amp;gt;対象文字列&amp;lt;/a&amp;gt;&lt;/code&gt;のようなHTML5に基づく記法を利用している&lt;/li&gt;
&lt;li&gt;表内での改行のために、&lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt;タグを利用している&lt;/li&gt;
&lt;li&gt;値の大きさを表現するために、上付き文字を表す&lt;code&gt;&amp;lt;sup&amp;gt;&lt;/code&gt;タグを利用している&lt;/li&gt;
&lt;li&gt;添字を表現するために、下付き文字を表す&lt;code&gt;&amp;lt;sub&amp;gt;&lt;/code&gt;タグを利用している&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、Markdownパーサーの制限を回避し、表内で &lt;code&gt;|&lt;/code&gt; (縦線、vertical line) を使用するために、文字参照 &lt;code&gt;&amp;#x7C;&lt;/code&gt; を使用してます。&lt;/p&gt;
&lt;p&gt;新規リファレンスを書くにあたって、雛形ページを用意していますので、そちらをベースにして編集作業を行ってください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/start_editing/header_template_page.html&#34;&gt;ヘッダファイルトップページの雛形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/start_editing/function_template_page.html&#34;&gt;関数の雛形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/start_editing/class_template_page.html&#34;&gt;クラスの雛形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/start_editing/type-type_template_page.html&#34;&gt;型の別名の雛形&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、リポジトリのトップディレクトリに&lt;code&gt;GLOBAL_QUALIFY_LIST.txt&lt;/code&gt;というファイルがあります。サイト全体のコードブロックに対して適用したい識別子の修飾があれば、ここに列挙していきます。書き方は各雛形ページに書いてあるコードブロックの修飾と同じです。&lt;/p&gt;
&lt;h2&gt;初めての人は見ておいたほうがよいページ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html&#34;&gt;処理系&lt;/a&gt; 処理系の正式な定義があります&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cpprefjp/site/wiki/progress&#34; target=&#34;_blank&#34;&gt;進行状況&lt;/a&gt; リファレンス作成の進行状況が確認できます&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/working_style.html&#34;&gt;スタイル&lt;/a&gt; 作業を行う上でのスタイルの定義と、訳語があります&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;その他、cpprefjpを編集するにあたってのドキュメント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/start_editing/page_names.html&#34;&gt;ページファイル名の付け方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/start_editing/random_figure.html&#34;&gt;乱数分布の図を作る方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;次期C++バージョンへの対応方針と作業方法&lt;/h2&gt;
&lt;p&gt;C++の次のバージョンで入ることが決まった機能については、以下の方針で対応を行います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;次のバージョンの言語機能・ライブラリ機能の解説は、随時許可する&lt;/li&gt;
&lt;li&gt;ただし、Working Draftに採択された機能のみを対象とする。まだ提案中の機能は、本サイトでの解説の対象外とする&lt;ul&gt;
&lt;li&gt;例外は、機能テストマクロのようなコンパイラへの推奨機能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;採択された機能は、&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/&#34; target=&#34;_blank&#34;&gt;C++ Standards Committee Papers&lt;/a&gt;のEditor&#39;s Reportで確認できる&lt;/li&gt;
&lt;li&gt;次のC++バージョンに採択された機能は、本リポジトリのWikiページに随時記載しているので、対応状況を含めてそちらを確認すること&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;本サイトのタスクを確認するには&lt;/h2&gt;
&lt;p&gt;本サイトで書くことが決まっているタスクを確認するには、issueを参照してください。「TASK」ラベルが付いているもので、担当者がついていないものがあれば、ぜひとも引き取ってください。&lt;/p&gt;
&lt;h2&gt;Pull Requestのレビューとマージ&lt;/h2&gt;
&lt;p&gt;push権限を持っている方は、Pull Requestのレビューとマージもぜひお願いします。&lt;/p&gt;
&lt;p&gt;Pull Requestを送っていただいた方には、管理者から後ほどpush権限をお渡しします。権限の譲渡は管理者がする必要がありますが、レビューとマージは、ほかのpush権限保持者がしていただいてかまいません。&lt;/p&gt;
&lt;p&gt;Pull Requestのレビューが滞っていた場合、Pull Requestの提出者の方は、cpprefjpのpush権限保持者に対して、個人的にレビューを依頼してもかまいません。push権限保持者がだれかは、以下のページから確認できます：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/orgs/cpprefjp/people&#34; target=&#34;_blank&#34;&gt;cpprefjp people&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;権限保持者の確認に使用できます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cpprefjp/site/graphs/contributors&#34; target=&#34;_blank&#34;&gt;cpprefjp contributors&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;各人が本サイトにどれくらいコントリビュートしているかを確認できます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ただし可能な限り、レビュアーとの技術的な議論はPull Request上で行っていただけると助かります。これは、議論を記録として残すことが目的です。&lt;/p&gt;
&lt;h2&gt;Git関係のルール&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;コミットメッセージに厳密な書式は設けない&lt;ul&gt;
&lt;li&gt;人によっては「〜を修正」のように書き、またある人は「fix ...」のように書きます。コミットメッセージは修正内容がわかることが大事で、書式はそれほど重要ではないという考えです&lt;/li&gt;
&lt;li&gt;また、本リポジトリが、英語の情報を元に日本語情報を提供する、という特性上、コミットメッセージが日本語と英語どちらであっても編集者が困ることはないはずですので、日本語か英語であれば、どちらで書いてもよいものとします&lt;/li&gt;
&lt;li&gt;コミットメッセージの内容としては、とくに自分以外の人が書いた文章を編集する際には、コミットメッセージに「なぜそのように編集したのか」をできるだけ書いたほうがよいです。これは、経緯を振り返りやすくすることが目的です&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;強制プッシュ&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git push -f&lt;/code&gt;や&lt;code&gt;git push --force&lt;/code&gt;といったコマンドは、リポジトリの設定で、masterブランチに対してはできないようにしてあります。これは、masterブランチは壊してはならないという理由によるものです&lt;/li&gt;
&lt;li&gt;masterブランチ以外には強制プッシュできますので、Pull Request用のトピックブランチのコミットを整理する、といった目的などで使用していただいて大丈夫です&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ranges -- &lt;ranges&gt; C++23対応(ヘッダーページのみ)</title>
      <link href="https://cpprefjp.github.io/reference/ranges.html"/>
      <id>5b0dfcbb75706d0b4219676187e0851178825d0d:reference/ranges.md</id>
      <updated>2023-01-14T04:32:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges.md b/reference/ranges.md
index 347c3dc20..855273b0f 100644
--- a/reference/ranges.md
+++ b/reference/ranges.md
@@ -209,6 +209,13 @@ range | adaptor(args...)
 | [`views::all`](ranges/all.md)           | Rangeへの参照として振る舞うビューを生成する (customization point object) | C++20          |
 | [`views::all_t`](ranges/all.md)         | `all`の戻り値型 (alias template)                                         | C++20          |
 
+### as rvalue view
+
+| 名前                                           | 説明                                                         | 対応バージョン |
+|------------------------------------------------|--------------------------------------------------------------|----------------|
+| [`as_rvalue_view`](ranges/as_rvalue_view.md.nolink)   | 各要素をrvalueにするビュー (class template)                  | C++23          |
+| [`views::as_rvalue`](ranges/as_rvalue.md.nolink)      | `as_rvalue_view`を生成する (customization point object)      | C++23          |
+
 ### filter view
 
 | 名前                                          | 説明                                                        | 対応バージョン |
@@ -257,15 +264,25 @@ range | adaptor(args...)
 |-----------------------------------------------------|---------------------------------------------------------------------------------------------------|----------------|
 | [`join_view`](ranges/join_view.md)                  | ネストされたRangeを平坦にするビュー (class template)                                              | C++20          |
 | [`views::join`](ranges/join_view.md)                | ネストされたRangeを平坦にするビューを生成する (customization point object)                        | C++20          |
+
+### join with view
+
+| 名前                                                | 説明                                                                                              | 対応バージョン |
+|-----------------------------------------------------|---------------------------------------------------------------------------------------------------|----------------|
 | [`join_with_view`](ranges/join_with_view.md.nolink)        | ネストされたRangeをデリミタで区切りながら平坦にするビュー (class template)                        | C++23          |
 | [`views::join_with`](ranges/join_with_view.md.nolink)      | ネストされたRangeをデリミタで区切りながら平坦にするビューを生成する (customization point object)  | C++23          |
 
-### split view
+### lazy split view
 
 | 名前                                                  | 説明                                                         | 対応バージョン |
 |-------------------------------------------------------|--------------------------------------------------------------|----------------|
 | [`lazy_split_view`](ranges/lazy_split_view.md)        | Rangeを指定したデリミタで分割するビュー (class template)     | C++20          |
 | [`views::lazy_split`](ranges/lazy_split_view.md)      | `lazy_split_view`を生成する (customization point object)     | C++20          |
+
+### split view
+
+| 名前                                                  | 説明                                                         | 対応バージョン |
+|-------------------------------------------------------|--------------------------------------------------------------|----------------|
 | [`split_view`](ranges/split_view.md)                  | 文字列分割に特化した`lazy_split_view` (class template)       | C++20          |
 | [`views::split`](ranges/split_view.md)                | `split_view`を生成する (customization point object)          | C++20          |
 
@@ -289,6 +306,13 @@ range | adaptor(args...)
 | [`reverse_view`](ranges/reverse_view.md)        | 逆順のビュー (class template)                        | C++20          |
 | [`views::reverse`](ranges/reverse_view.md)      | 逆順のビューを生成する (customization point object)  | C++20          |
 
+### as const view
+
+| 名前                                          | 説明                                                         | 対応バージョン |
+|-----------------------------------------------|--------------------------------------------------------------|----------------|
+| [`as_const_view`](ranges/as_const_view.md.nolink)    | 各要素をconstにするビュー (class template)                   | C++23          |
+| [`views::as_const`](ranges/as_const.md.nolink)       | `as_const_view`を生成する (customization point object)       | C++23          |
+
 ### elements view
 
 | 名前                                              | 説明                                                   | 対応バージョン |
@@ -306,6 +330,11 @@ range | adaptor(args...)
 |--------------------------------------------------------|-------------------------------------------------------------------------------------|----------------|
 | [`zip_view`](ranges/zip_view.md.nolink)                       | 2つのシーケンスから値を1つずつ取り出した`tuple`のビュー (class template)            | C++23          |
 | [`views::zip`](ranges/zip_view.md.nolink)                     | `zip_view`を生成する (customization point object)                                   | C++23          |
+
+### zip transform view
+
+| 名前                                                   | 説明                                                                                | 対応バージョン |
+|--------------------------------------------------------|-------------------------------------------------------------------------------------|----------------|
 | [`zip_transform_view`](ranges/zip_transform_view.md.nolink)   | 2つのシーケンスから値を1つずつ取り出し、関数を適用した結果のビュー (class template) | C++23          |
 | [`views::zip_transform`](ranges/zip_transform_view.md.nolink) | `zip_transform_view`を生成する (customization point object)                         | C++23          |
 
@@ -315,6 +344,11 @@ range | adaptor(args...)
 |------------------------------------------------------------------|------------------------------------------------------------------------------------|----------------|
 | [`adjacent_view`](ranges/adjacent_view.md.nolink)                       | 各要素とそれに隣接する要素を指定個数ずつ取り出した`tuple`のビュー (class template) | C++23          |
 | [`views::adjacent`](ranges/adjacent_view.md.nolink)                     | `adjacent_view`を生成する (customization point object)                             | C++23          |
+
+### adjacent transform view
+
+| 名前                                                             | 説明                                                                               | 対応バージョン |
+|------------------------------------------------------------------|------------------------------------------------------------------------------------|----------------|
 | [`adjacent_transform_view`](ranges/adjacent_transform_view.md.nolink)   | `adjacent_view`と同様に取り出し、関数を適用した結果のビュー (class template)       | C++23          |
 | [`views::adjacent_transform`](ranges/adjacent_transform_view.md.nolink) | `adjacent_transform_view`を生成する (customization point object)                   | C++23          |
 
@@ -324,6 +358,11 @@ range | adaptor(args...)
 |---------------------------------------------|--------------------------------------------------------------------|----------------|
 | [`chunk_view`](ranges/chunk_view.md.nolink)         | シーケンスを指定個数で区切った`view`のシーケンス (class template)  | C++23          |
 | [`views::chunk`](ranges/chunk_view.md.nolink)       | `chunk_view`を生成する (customization point object)                | C++23          |
+
+### chunk by view
+
+| 名前                                        | 説明                                                               | 対応バージョン |
+|---------------------------------------------|--------------------------------------------------------------------|----------------|
 | [`chunk_by_view`](ranges/chunk_by_view.md.nolink)   | 2項述語が偽となる部分で区切った`view`のシーケンス (class template) | C++23          |
 | [`views::chunk_by`](ranges/chunk_by_view.md.nolink) | `chunk_by_view`を生成する (customization point object)             | C++23          |
 
@@ -334,6 +373,20 @@ range | adaptor(args...)
 | [`slide_view`](ranges/slide_view.md.nolink)   | 各要素とそれに隣接する要素を指定個数ずつ見る`view`のシーケンス (class template) | C++23          |
 | [`views::slide`](ranges/slide_view.md.nolink) | `slide_view`を生成する (customization point object)                             | C++23          |
 
+### stride view
+
+| 名前                                     | 説明                                                  | 対応バージョン |
+|------------------------------------------|-------------------------------------------------------|----------------|
+| [`stride_view`](ranges/stride_view.md.nolink)   | 要素を指定個数飛ばしに見るビュー (class template)     | C++23          |
+| [`views::stride`](ranges/stride_view.md.nolink) | `stride_view`を生成する (customization point object)  | C++23          |
+
+### cartesian product view
+
+| 名前                                                          | 説明                                                             | 対応バージョン |
+|---------------------------------------------------------------|------------------------------------------------------------------|----------------|
+| [`cartesian_product_view`](ranges/cartesian_product_view.md.nolink)  | シーケンスの直積集合のビュー (class template)                    | C++23          |
+| [`views::cartesian_product`](ranges/cartesian_product.md.nolink)     | `cartesian_product_view`を生成する (customization point object)  | C++23          |
+
 
 ## Range変換
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>INVOKE -- C++20 : P0777R1対応</title>
      <link href="https://cpprefjp.github.io/reference/concepts/Invoke.html"/>
      <id>df3cf1576616ea59ff5b6f2e46c42aad9b88d734:reference/concepts/Invoke.md</id>
      <updated>2023-01-13T18:13:13+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;named requirement&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace &#34;&gt;::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;INVOKE&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;C++における関数呼び出しという性質を抽象化しまとめた、仮想操作 &lt;em&gt;INVOKE&lt;/em&gt; を定義する。&lt;/p&gt;
&lt;p&gt;C++17からは、本仮想操作を実体化した&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/invoke.html&#34;&gt;invoke&lt;/a&gt;&lt;/code&gt;関数テンプレートが提供される。&lt;/p&gt;
&lt;h2&gt;用語定義&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;call-signature&lt;/em&gt; とは、戻り値型に続けて丸括弧の中に0個以上の引数型を並べたものである。 &lt;em&gt;cf.&lt;/em&gt; &lt;code&gt;int ( std::string, int )&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-type&lt;/em&gt; とは、関数呼び出し演算子を適用できる型 ( 関数、関数への参照、関数へのポインタ、&lt;code&gt;operator ()&lt;/code&gt; をオーバーロードした型もしくはそれを(直接または間接的に) &lt;code&gt;public&lt;/code&gt; 継承した型 ) もしくはメンバへのポインタ型を指す。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;callable-object&lt;/em&gt; は、 &lt;em&gt;callable-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper-type&lt;/em&gt; は、 &lt;em&gt;callable-object&lt;/em&gt; を保持し、自身に対する関数呼び出し操作が行われたとき、保持しているオブジェクトに委譲する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; は、 &lt;em&gt;call-wrapper-type&lt;/em&gt; 型のオブジェクトである。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;target-object&lt;/em&gt; とは、 &lt;em&gt;callable-object&lt;/em&gt; に保持されているオブジェクトのことである。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;要件（C++14まで）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が T 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; 型のオブジェクトあるいは &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型への参照であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN, R)&lt;/code&gt; を、 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること、と定義する。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;call-wrapper&lt;/em&gt; が &lt;em&gt;weak-result-type&lt;/em&gt; を用意している場合、メンバ型 &lt;code&gt;result_type&lt;/code&gt; は&lt;em&gt;target-object&lt;/em&gt; の型 &lt;code&gt;T&lt;/code&gt; に応じて次のように定義される。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; がメンバ関数へのポインタ型であるとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の戻り値型と等しい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;result_type&lt;/code&gt; という名前のメンバ型を持つとき、 &lt;code&gt;result_type&lt;/code&gt; は &lt;code&gt;T::result_type&lt;/code&gt; と等しい。&lt;/li&gt;
&lt;li&gt;どの条件にも当てはまらない場合、 &lt;code&gt;result_type&lt;/code&gt; は定義されない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveAssignable&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++17）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/decay.html&#34;&gt;decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;MoveConstructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;要件（C++20）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;仮想操作 &lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバ関数へのポインタであり、 &lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、&lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/is_base_of.html&#34;&gt;is_baseof_v&lt;/a&gt;&amp;lt;T,&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt; == true&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; または &lt;code&gt;T&lt;/code&gt; を継承した型のオブジェクト/参照）であるとき、 &lt;code&gt;t1.*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/remove_cvref.html&#34;&gt;remove_cvref_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;（&lt;code&gt;t1&lt;/code&gt;が&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;の特殊化）であるとき、 &lt;code&gt;t1.get().*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N == 1&lt;/code&gt; で、&lt;code&gt;f&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバオブジェクトへのポインタであり、&lt;code&gt;t1&lt;/code&gt; が上記の条件に当てはまらない場合（例えば、t1が&lt;code&gt;T&lt;/code&gt;のポインタ）、 &lt;code&gt;(*t1).*f&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;li&gt;上記の条件のどれにも当てはまらない場合、 &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; と同じ効果を持つ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)&lt;/code&gt; を次のように定義する。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;void&lt;/code&gt;かそのcv修飾の場合は、&lt;code&gt;static_cast&amp;lt;void&amp;gt;(&lt;/code&gt;&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、&lt;em&gt;INVOKE&lt;/em&gt;&lt;code&gt;(f, t1, t2, ..., tN)&lt;/code&gt; の実行結果の戻り値が型 &lt;code&gt;R&lt;/code&gt; に暗黙的に変換されること。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;すべての &lt;em&gt;call-wrapper&lt;/em&gt; は、&lt;em&gt;Cpp17MoveConstructible&lt;/em&gt; かつ &lt;em&gt;Cpp17Destructible&lt;/em&gt; でなければならない。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/Cryolite/status/216814363221303296&#34; target=&#34;_blank&#34;&gt;第1引数がメンバ関数へのポインタの場合でも非静的メンバデータへのポインタの場合でも，第2引数がクラスオブジェクトへの参照の場合でもポインタの場合でもポインタっぽいものの場合でも，なんか知らんけどそれっぽく上手くいく&lt;/a&gt; ように取り計らった操作のことである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/function.html&#34;&gt;function&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/reference_wrapper.html&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/bind.html&#34;&gt;bind&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/functional/not_fn.html&#34;&gt;not_fn&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/thread/thread.html&#34;&gt;thread&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/async.html&#34;&gt;async&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/future/packaged_task.html&#34;&gt;packaged_task&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/mutex/call_once.html&#34;&gt;call_once&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf&#34; target=&#34;_blank&#34;&gt;P0777R1 Treating Unnecessary &lt;code&gt;decay&lt;/code&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;C++20から&lt;code&gt;decay_t&lt;/code&gt;を&lt;code&gt;remove_cvref_t&lt;/code&gt;へ変更。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- C++20 : P0777R1対応</title>
      <link href="https://cpprefjp.github.io/reference/optional/optional/op_constructor.html"/>
      <id>df3cf1576616ea59ff5b6f2e46c42aad9b88d734:reference/optional/optional/op_constructor.md</id>
      <updated>2023-01-13T18:13:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/optional/optional/op_constructor.md b/reference/optional/optional/op_constructor.md
index 3046ccd0e..d584fdc65 100644
--- a/reference/optional/optional/op_constructor.md
+++ b/reference/optional/optional/op_constructor.md
@@ -221,6 +221,7 @@ int main()
 - [LWG Issue 2842. `in_place_t` check for `optional::optional(U&amp;amp;&amp;amp;)` should decay `U`](https://wg21.cmeerw.net/lwg/issue2842)
     - 説明の簡略化のため、このオーバーロードで`in_place_t`への言及は現在していない
 - [LWG Issue 2900. The copy and move constructors of `optional` are not `constexpr`](https://wg21.cmeerw.net/lwg/issue2900)
+- [P0777R1 Treating Unnecessary `decay`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf)
 - [P0892R2 `explicit(bool)`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0892r2.html)
     - C++20での`explicit(bool)`構文への対応
-- [P0602R4 `variant` and `optional` should propagate copy/move triviality](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0602r4.html)
\ No newline at end of file
+- [P0602R4 `variant` and `optional` should propagate copy/move triviality](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0602r4.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>apply -- C++20 : P0777R1対応</title>
      <link href="https://cpprefjp.github.io/reference/tuple/apply.html"/>
      <id>df3cf1576616ea59ff5b6f2e46c42aad9b88d734:reference/tuple/apply.md</id>
      <updated>2023-01-13T18:13:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/apply.md b/reference/tuple/apply.md
index 77d6e1845..ff0343f51 100644
--- a/reference/tuple/apply.md
+++ b/reference/tuple/apply.md
@@ -38,8 +38,17 @@ constexpr decltype(auto) apply-impl(F&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; t, std::index_sequence&amp;lt;I...&amp;gt;)
 * std::invoke[link /reference/functional/invoke.md]
 * std::forward[link /reference/utility/forward.md]
 
-次と等価である。
+C++17 : 次と等価である。
+```cpp
+return apply-impl(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Tuple&amp;gt;(t),
+                  std::make_index_sequence&amp;lt;std::tuple_size_v&amp;lt;std::decay_t&amp;lt;Tuple&amp;gt;&amp;gt;&amp;gt;{});
+```
+* std::tuple_size_v[link tuple_size.md]
+* std::make_index_sequence[link /reference/utility/make_index_sequence.md]
+* std::forward[link /reference/utility/forward.md]
+* std::decay_t[link /reference/type_traits/decay.md]
 
+C++20 : 次と等価である。
 ```cpp
 return apply-impl(std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;Tuple&amp;gt;(t),
                   std::make_index_sequence&amp;lt;std::tuple_size_v&amp;lt;std::remove_reference_t&amp;lt;Tuple&amp;gt;&amp;gt;&amp;gt;{});
@@ -110,5 +119,7 @@ hello
 - [P0220R0 Adopt Library Fundamentals TS for C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r0.html)
 - [P0220R1 Adopt Library Fundamentals V1 TS Components for C++17 (R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html)
 - [C++1z タプルを展開して関数呼び出しするapply関数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/08/18/184315)
+- [P0777R1 Treating Unnecessary `decay`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf)
+    - C++20から効果説明の`decay_t`を`remove_cvref_t`へ変更。
 - [P2517R1 Add a conditional `noexcept` specification to `std::apply`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2517r1.html)
     - C++23から条件付きで`noexcept`例外指定が行われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- C++20 : P0777R1対応</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant/op_constructor.html"/>
      <id>df3cf1576616ea59ff5b6f2e46c42aad9b88d734:reference/variant/variant/op_constructor.md</id>
      <updated>2023-01-13T18:13:13+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant/op_constructor.md b/reference/variant/variant/op_constructor.md
index a578926e8..38d1724d0 100644
--- a/reference/variant/variant/op_constructor.md
+++ b/reference/variant/variant/op_constructor.md
@@ -60,9 +60,10 @@ constexpr explicit variant(in_place_index_t&amp;lt;I&amp;gt;,
 - (4) :
     - C++17 : ここで説明用に、`*this`が保持している型`Tj`と、そのインデックス値`j`を定義する。`Types...`の各型`Ti`に対して擬似的な関数`FUN(Ti)`を定義したとして、`FUN(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(t))`呼び出しによって選択されたオーバーロードされた関数のパラメータ型を、構築してその後含まれる値の型を`Tj`とする
     - C++20 : ここで説明用に、`*this`が保持している型`Tj`と、そのインデックス値`j`を定義する。`Types...`の各型`Ti`を、縮小変換を受け付けない型であり (`Ti x[] = {`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(t)};`)、CV修飾付き`bool`の場合にCV修飾を外した`bool`型になるとして、その型に対して擬似的な関数`FUN(Ti)`を定義したとして、`FUN(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(t))`呼び出しによって選択されたオーバーロードされた関数のパラメータ型を、構築してその後含まれる値の型を`Tj`とする
-    - [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;, variant&amp;gt;`が`false`であること
-    - 型[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;`が[`in_place_type_t`](/reference/utility/in_place_type_t.md)および[`in_place_index_t`](/reference/utility/in_place_index_t.md)の特殊化ではないこと
-    - [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;Tj, T&amp;gt;`が`true`であること
+    - C++17 : [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;, variant&amp;gt;`が`false`であること
+    - C++20 : [`is_same_v`](/reference/type_traits/is_same.md)`&amp;lt;`[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;T&amp;gt;, variant&amp;gt;`が`false`であること
+    - C++17 : 型[`decay_t`](/reference/type_traits/decay.md)`&amp;lt;T&amp;gt;`が[`in_place_type_t`](/reference/utility/in_place_type_t.md)および[`in_place_index_t`](/reference/utility/in_place_index_t.md)の特殊化ではないこと
+    - C++20 : 型[`remove_cvref_t`](/reference/type_traits/remove_cvref.md)`&amp;lt;T&amp;gt;`が[`in_place_type_t`](/reference/utility/in_place_type_t.md)および[`in_place_index_t`](/reference/utility/in_place_index_t.md)の特殊化ではないこと    - [`is_constructible_v`](/reference/type_traits/is_constructible.md)`&amp;lt;Tj, T&amp;gt;`が`true`であること
     - 式`FUN(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;T&amp;gt;(x))`が適格であること
 - (5) :
     - `Types...`内に`T`が一度だけ現れること
@@ -364,3 +365,5 @@ int main()
 - [LWG Issue 2901 Variants cannot properly support allocators](https://cplusplus.github.io/LWG/issue2901)
 - [P0608R3 A sane variant converting constructor](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0608r3.html)
 - [P0602R4 `variant` and `optional` should propagate copy/move triviality](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0602r4.html)
+- [P0777R1 Treating Unnecessary `decay`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0777r1.pdf)
+    - C++20からテンプレートパラメータ制約の`decay_t`を`remove_cvref_t`へ変更。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exchange -- utility/exchange: fix markup</title>
      <link href="https://cpprefjp.github.io/reference/utility/exchange.html"/>
      <id>b40b1a83eab6a27b8ed6b09af38212277074c214:reference/utility/exchange.md</id>
      <updated>2023-01-13T17:22:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/exchange.md b/reference/utility/exchange.md
index 2a4a0f2ba..9c103e5ed 100644
--- a/reference/utility/exchange.md
+++ b/reference/utility/exchange.md
@@ -41,7 +41,7 @@ return old_val;
 
 
 ## 例外
-C++23から : 例外指定の式は次と等価 : [`is_nothrow_move_constructible_v](/reference/type_traits/is_nothrow_move_constructible.md)`&amp;lt;T&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_assignable_v`](/reference/type_traits/is_nothrow_assignable.md)`&amp;lt;T&amp;amp;, U&amp;gt;`
+C++23から : 例外指定の式は次と等価 : [`is_nothrow_move_constructible_v`](/reference/type_traits/is_nothrow_move_constructible.md)`&amp;lt;T&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_assignable_v`](/reference/type_traits/is_nothrow_assignable.md)`&amp;lt;T&amp;amp;, U&amp;gt;`
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exchange -- utility/exchange: P2401R0対応(#1065)</title>
      <link href="https://cpprefjp.github.io/reference/utility/exchange.html"/>
      <id>a01dfab45ae2c0c89c3462ab6ebbccfaa25e2fdd:reference/utility/exchange.md</id>
      <updated>2023-01-13T17:14:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/utility/exchange.md b/reference/utility/exchange.md
index 23e6c4cc9..2a4a0f2ba 100644
--- a/reference/utility/exchange.md
+++ b/reference/utility/exchange.md
@@ -7,10 +7,14 @@
 ```cpp
 namespace std {
   template &amp;lt;class T, class U=T&amp;gt;
-  T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val);           // C++14
+  T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val);           // (1) C++14
 
   template &amp;lt;class T, class U=T&amp;gt;
-  constexpr T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val); // C++20
+  constexpr T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val); // (1) C++20
+
+  template &amp;lt;class T, class U=T&amp;gt;
+  constexpr T exchange(T&amp;amp; obj, U&amp;amp;&amp;amp; new_val)
+    noexcept(see below);                     // (1) C++23
 }
 ```
 
@@ -36,6 +40,10 @@ return old_val;
 この関数を呼び出す前の、第1パラメータ`obj`の状態を返す。
 
 
+## 例外
+C++23から : 例外指定の式は次と等価 : [`is_nothrow_move_constructible_v](/reference/type_traits/is_nothrow_move_constructible.md)`&amp;lt;T&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_assignable_v`](/reference/type_traits/is_nothrow_assignable.md)`&amp;lt;T&amp;amp;, U&amp;gt;`
+
+
 ## 備考
 この関数は、[`std::atomic_exchange()`](/reference/atomic/atomic_exchange.md)関数の経験から導入された。
 
@@ -206,3 +214,4 @@ Hello 0x7ffc560ca4cc
 - [P0202R3 Add Constexpr Modifiers to Functions in `&amp;lt;algorithm&amp;gt;` and `&amp;lt;utility&amp;gt;` Headers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0202r3.html)
 - [`std::exchange` Patterns: Fast, Safe, Expressive, and Probably Underused](https://www.fluentcpp.com/2020/09/25/stdexchange-patterns-fast-safe-expressive-and-probably-underused/)
 - [`std::exchange`によるmoveしてリセットするイディオムの御紹介](https://onihusube.hatenablog.com/entry/2020/10/31/163244)
+- [P2401R0 Add a conditional noexcept specification to std::exchange](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2401r0.html)
\ No newline at end of file
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>