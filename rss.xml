<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-04-06T09:02:17.302620</updated>
  <id>7ddc8c26-1c62-46ff-8438-1370fd119b02</id>

  
    <entry>
      <title>variant -- variant : voidを入れ込みたい場合について追記</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant.html"/>
      <id>a002f35eccbbb8ef3b7e634c0221e8b531724054:reference/variant/variant.md</id>
      <updated>2022-04-06T17:57:05+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant.md b/reference/variant/variant.md
index 851df0eb2..2bcff796b 100644
--- a/reference/variant/variant.md
+++ b/reference/variant/variant.md
@@ -56,6 +56,7 @@ std::visit([](auto&amp;amp; x) {
 
 ## テンプレートパラメータ制約
 - `Types...`の全ての型が、[`std::destructible`](/reference/concepts/destructible.md)要件を満たすこと
+    - 例えば`void`はこれを満たさない。空、あるいは無効な型を入れ込みたい場合には[`std::monostate`](/reference/variant/monostate.md)が使用できる
 - コンストラクタや代入の制約として、`variant&amp;lt;`[`std::string`](/reference/string/basic_string.md)`,` [`std::string`](/reference/string/basic_string.md)`&amp;gt;`のように、`Types...`内に同じ型が複数回現れる指定をする場合は、型のインデックスを指定する形式の機能のみ使用できる
     - こういった指定は、正常データかエラーデータどちらかが代入されるオブジェクトを用意する状況で、正常データとエラーデータがどちらも文字列、という場合に必要になる
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナのconstexpr化 -- 可変サイズをもつコンテナのconstexpr化 : ページタイトルは修飾しない</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>d12de9fcaa4a549e3acca46f2052254404f80dd1:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2022-04-04T14:58:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 322d24c35..d5473f1cb 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -1,4 +1,4 @@
-# 可変サイズをもつコンテナの`constexpr`化
+# 可変サイズをもつコンテナのconstexpr化
 * cpp20[meta cpp]
 
 ## 概要
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- 可変サイズをもつコンテナのconstexpr化 : s/end_with/ends_with/</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>3e897bf2f7f1638923d84336fb57605a5efab976:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2022-04-04T14:57:50+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 6a42b658e..322d24c35 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -19,12 +19,13 @@ constexpr int test_vector() {
 }
 
 constexpr bool check_cpp_file(const std::string&amp;amp; filename) {
-  return filename.end_with(&amp;#34;.cpp&amp;#34;) || filename.end_with(&amp;#34;.hpp&amp;#34;);
+  return filename.ends_with(&amp;#34;.cpp&amp;#34;) || filename.ends_with(&amp;#34;.hpp&amp;#34;);
 }
 
 static_assert(test_vector() == 35);         // OK
 static_assert(check_cpp_file(&amp;#34;main.cpp&amp;#34;));  // OK
 ```
+* ends_with[link /reference/string/basic_string/ends_with.md]
 
 これは主に以下の変更によって達成されている。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/ranges/iota_view/op_constructor.html"/>
      <id>20104fbc06f4689aa768800b6e023604cdceabbc:reference/ranges/iota_view/op_constructor.md</id>
      <updated>2022-04-03T11:36:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/iota_view/op_constructor.md b/reference/ranges/iota_view/op_constructor.md
index 8c49f35cc..b8327a6eb 100644
--- a/reference/ranges/iota_view/op_constructor.md
+++ b/reference/ranges/iota_view/op_constructor.md
@@ -25,16 +25,18 @@ constexpr iota_view(iterator first, sentinel last);
 
 ## 概要
 - (1) : `[W(), Bound())` を範囲とする`iota_view`を構築する
-- (2) : `Bound`が`unreachable_sentinel_t`のとき、`value`から始まる無限長の`iota_view`を構築する。それ以外のとき、`[value, Bound())` を範囲とする`iota_view`を構築する
+- (2) : `[value, Bound())` を範囲とする`iota_view`を構築する
 - (3) : `[value, bound)` を範囲とする`iota_view`を構築する
 - (4) : イテレータ `[first, last)` が指す値を範囲とする`iota_view`を構築する((3)に委譲)
 
+`Bound`が[`unreachable_sentinel_t`](/reference/iterator/unreachable_sentinel_t.md)のとき、無限長の`iota_view`となる。
+
 ## 事前条件
 
 `e`が`b`から到達できるとは、`b`をn回インクリメントしたとき、`e == b`が真となるようなnが存在することをいう。
 
 - (2): `Bound`は[`unreachable_sentinel_t`](/reference/iterator/unreachable_sentinel_t.md)である。または、`Bound()`は`value`から到達できる
-- (3): `Bound`は[`unreachable_sentinel_t`](/reference/iterator/unreachable_sentinel_t.md)である。または、`Bound()`は`value`から到達できる。[`totally_ordered_with`](/reference/concepts/totally_ordered.md)`&amp;lt;W, Bound&amp;gt;`ならば、`bool(value &amp;lt;= bound)`が`true`である
+- (3): `Bound`は[`unreachable_sentinel_t`](/reference/iterator/unreachable_sentinel_t.md)である。または、`bound`は`value`から到達できる。[`totally_ordered_with`](/reference/concepts/totally_ordered.md)`&amp;lt;W, Bound&amp;gt;`ならば、`bool(value &amp;lt;= bound)`が`true`である
 
 ## 効果
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-integer-like -- 実装例を追加</title>
      <link href="https://cpprefjp.github.io/reference/iterator/is_integer_like.html"/>
      <id>ad2cae7774836306ef2a4931f4ed0cd52a3e3b58:reference/iterator/is_integer_like.md</id>
      <updated>2022-04-03T00:03:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/is_integer_like.md b/reference/iterator/is_integer_like.md
index d67494342..69505c1dc 100644
--- a/reference/iterator/is_integer_like.md
+++ b/reference/iterator/is_integer_like.md
@@ -53,6 +53,28 @@ namespace std {
 - [`numeric_limits&amp;lt;I&amp;gt;::digits10`](/reference/limits/numeric_limits/digits10.md)は`static_cast&amp;lt;int&amp;gt;(digits * log10(2))`と等しい
 - [`numeric_limits&amp;lt;I&amp;gt;::min()`](/reference/limits/numeric_limits/min.md)と[`numeric_limits&amp;lt;I&amp;gt;::max()`](/reference/limits/numeric_limits/max.md)はそれぞれ、`I`の表現可能な値の最小値と最大値を返す。[`numeric_limits&amp;lt;I&amp;gt;::lowest()`](/reference/limits/numeric_limits/lowest.md)は`numeric_limits&amp;lt;I&amp;gt;::max()`を返す。
 
+## 実装例 (MSVC)
+
+```cpp
+inline constexpr bool _Is_nonbool_integral = is_integral_v&amp;lt;_Ty&amp;gt; &amp;amp;&amp;amp; !is_same_v&amp;lt;remove_cv_t&amp;lt;_Ty&amp;gt;, bool&amp;gt;;
+
+template &amp;lt;class _Ty&amp;gt;
+inline constexpr bool _Integer_class = requires {
+  typename _Ty::_Signed_type;
+  typename _Ty::_Unsigned_type;
+};
+
+template &amp;lt;class _Ty&amp;gt;
+concept _Integer_like = _Is_nonbool_integral&amp;lt;remove_cv_t&amp;lt;_Ty&amp;gt;&amp;gt; || _Integer_class&amp;lt;_Ty&amp;gt;;
+
+template &amp;lt;class _Ty&amp;gt;
+concept _Signed_integer_like = _Integer_like&amp;lt;_Ty&amp;gt; &amp;amp;&amp;amp; static_cast&amp;lt;_Ty&amp;gt;(-1) &amp;lt; static_cast&amp;lt;_Ty&amp;gt;(0);
+```
+* is_integral_v[like /reference/type_traits/is_integral.md]
+* is_same_v[like /reference/type_traits/is_same.md]
+* remove_cv_t[like /reference/type_traits/remove_cv.md]
+
+上記の説明のうち構文的な要件を素直に実装している。MSVCでは、128ビット整数が*integer-class*型である。
 
 ## バージョン
 ### 言語
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>