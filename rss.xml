<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-03-11T14:46:17.837967</updated>
  <id>f937066c-c0b9-4bf9-9419-b3d0acf203d1</id>

  
    <entry>
      <title>uniform_random_bit_generator -- uniform_random_bit_generator : リンク追加</title>
      <link href="https://cpprefjp.github.io/reference/random/uniform_random_bit_generator.html"/>
      <id>e07e2878b3df6bd691e853b802c68102dbd2f98c:reference/random/uniform_random_bit_generator.md</id>
      <updated>2021-03-07T18:38:08+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/random/uniform_random_bit_generator.md b/reference/random/uniform_random_bit_generator.md
index 31ce03450..d1403fac8 100644
--- a/reference/random/uniform_random_bit_generator.md
+++ b/reference/random/uniform_random_bit_generator.md
@@ -94,3 +94,4 @@ std::exponential_distribution&amp;lt;&amp;gt; is not uniform random bit generator
 
 - [P0898R3 Standard Library Concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0898r3.pdf)
 - [P1754R1 Rename concepts to standard_case for C++20, while we still can](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1754r1.pdf)
+- [制約式`std::bool_constant&amp;lt;cond&amp;gt;::value` - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20210307/p1)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>indirectly_writable -- indirectly_writable : 説明と参考リンクの追記</title>
      <link href="https://cpprefjp.github.io/reference/iterator/indirectly_writable.html"/>
      <id>588ade16a1c373a33676656fc305a6af7f82d984:reference/iterator/indirectly_writable.md</id>
      <updated>2021-03-05T18:03:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/indirectly_writable.md b/reference/iterator/indirectly_writable.md
index 513fc6590..1f770f0fe 100644
--- a/reference/iterator/indirectly_writable.md
+++ b/reference/iterator/indirectly_writable.md
@@ -29,7 +29,7 @@ namespace std {
 
 このコンセプトを構成する4つの制約式は全て、[等しさを保持](/reference/concepts.md)することを要求しない。
 
-`const_cast`を用いる制約式は、右辺値の代入は可能だが`const`な右辺値の代入ができないような*prvalue*の非プロキシイテレータを弾くために存在している。これによって、間接参照が*prvalue*（`T`そのもの、例えば`std::string`）を返すようなイテレータ型は`indirectly_writable`のモデルとならない。
+`const_cast`を用いる制約式は、右辺値に対しても代入できるが`const`な右辺値では代入できなくなる非プロキシイテレータの*prvalue*（例えば`std::string`そのものなど）を返すイテレータを弾くためにある。これによって、間接参照が*prvalue*を返すようなイテレータ型は`indirectly_writable`のモデルとならないが、出力可能なプロキシオブジェクトを返すイテレータは`indirectly_writable`のモデルとなる事ができる。
 
 ## モデル
 
@@ -126,3 +126,5 @@ not_writable is not indirectly writable int
 ## 参照
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [P2214R0 A Plan for C++23 Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2214r0.html#a-tuple-that-is-writable)
+    - `const_cast`を用いる制約式についての説明がなされている
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>生文字列リテラル -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/raw_string_literals.html"/>
      <id>b701f446eda041b6949771c59e20f69a6b3ce871:lang/cpp11/raw_string_literals.md</id>
      <updated>2021-03-03T16:00:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/raw_string_literals.md b/lang/cpp11/raw_string_literals.md
index fa377752d..c2e97999b 100644
--- a/lang/cpp11/raw_string_literals.md
+++ b/lang/cpp11/raw_string_literals.md
@@ -100,7 +100,7 @@ int main()
 
 // 文字列のフォーマット関数
 // not thread-safe, スレッドセーフな実装ではないので注意
-// Boost.Formatやcppformatを使用することを推奨
+// Boost.Format, fmtlibやstd::format(C++20)の使用を推奨
 template &amp;lt;class... Args&amp;gt;
 std::string format(const char* fmt, Args&amp;amp;&amp;amp;... args)
 {
@@ -133,7 +133,8 @@ int main()
 * str()[link /reference/sstream/basic_stringstream/str.md.nolink]
 * std::fprintf[link /reference/cstdio/fprintf.md.nolink]
 * Boost.Format[link http://www.boost.org/libs/format]
-* cppformat[link https://github.com/cppformat/cppformat]
+* fmtlib[link https://github.com/fmtlib/fmt]
+* std::format[link /reference/format/format.md]
 
 #### 出力
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>モジュール -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/modules.html"/>
      <id>b701f446eda041b6949771c59e20f69a6b3ce871:lang/cpp20/modules.md</id>
      <updated>2021-03-03T16:00:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/modules.md b/lang/cpp20/modules.md
index 96e267a80..aa8b95f6f 100644
--- a/lang/cpp20/modules.md
+++ b/lang/cpp20/modules.md
@@ -42,26 +42,85 @@ C++20では標準ライブラリはモジュール化されないが、その中
 
 ## 仕様
 
+### 翻訳単位の分類
+
+C++20では翻訳単位がその役割によって細かく分類される。
+
+まず、モジュールを構成する翻訳単位(モジュールユニット)とそれ以外(従来の翻訳単位すべて)の区別がある。
+
+モジュールユニットはさらにインターフェースと実装に分けられる。
+
+* モジュールインターフェースユニット  
+    従来のヘッダーファイルに相当する翻訳単位(`#include`のようにソースファイルに展開されることはなく、単独で翻訳単位になる)。外部(別のモジュール)に公開したい宣言や定義を書く。
+* モジュール実装ユニット  
+    従来のソースファイルに相当する翻訳単位。公開しない宣言や定義を書く。
+
+また、それぞれにモジュール本体とパーティションという区別がある。
+
+パーティションは、モジュールを構成するファイルをさらに分割するために使うもので、内部的には別モジュールのように見えるが、外部からは見えないファイルである。
+
+まとめると、以下のようになる。
+
+* 翻訳単位
+    * モジュールユニット
+        * モジュールインターフェースユニット
+            * プライマリーモジュールインターフェース
+            * モジュールインターフェースパーティション
+        * モジュール実装ユニット
+            * モジュール本体の実装ユニット(特別な名称無し)
+            * モジュール実装パーティション
+    * モジュールユニット以外(特別な名称無し)
+
 ### モジュール宣言
 
 モジュール宣言の構文は以下のようになる：
 
 ```
-export(opt) module モジュール名 属性(opt);
+export(opt) module モジュール名 :パーティション名(opt) 属性(opt);
 ```
 
-- モジュール宣言は翻訳単位あたり1回だけ、原則として翻訳単位の先頭に記述する。
-- モジュール宣言を含む翻訳単位をモジュールユニットという。
-    - `export`がある場合をモジュールインターフェースユニット、ない場合をモジュール実装ユニットと呼ぶ。
-    - あるモジュールについて、モジュールインターフェースユニットがただ1つ存在しなければならない。モジュールの実装は好きなだけ存在できる。
-    - モジュール実装ユニットはモジュールインターフェースユニットを暗黙的にインポートする。
+- モジュール宣言は翻訳単位あたり1回だけ、原則として翻訳単位の先頭に記述する。モジュール宣言を含む翻訳単位をモジュールユニットという。
+- `export`がある場合はモジュールインターフェースユニット、ない場合はモジュール実装ユニットになる。
+- パーティション名がある場合はそれぞれモジュールインターフェースパーティション、モジュール実装パーティションになる。
+
+どのモジュールも、必ずただ1つのプライマリーモジュールインターフェースユニットを持たなければならない。
+それ以外のモジュールユニットの個数は任意である。ただし、パーティション名はモジュール内で重複してはならない。
+
 
 ```cpp
 export module foo;                // fooのモジュールインターフェースユニット
 module foo;                       // fooのモジュール実装ユニット
 module foo.bar;                   // foo.barのモジュール実装ユニット
 export module bar [[deprecated]]; // 属性
+export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
+module lib:internal; // libモジュールのモジュール実装パーティションinternal
+```
+
+次のモジュールAは4つの翻訳単位からなる。
+
+```cpp
+// P1103R3より引用
+// 翻訳単位1 プライマリーモジュールインターフェースユニット
+export module A;
+export import :Foo;
+export int baz();
+
+// 翻訳単位2 モジュールインターフェースパーティション
+export module A:Foo;
+import :Internals;
+export int foo() { return 2 * (bar() + 1); }
+
+// 翻訳単位3 モジュール実装パーティション
+module A:Internals;
+int bar();
+
+// 翻訳単位4 モジュール実装ユニット
+module A;
+import :Internals;
+int bar() { return baz() - 10; }
+int baz() { return 30; }
 ```
+* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]
 
 #### モジュール名の詳細
 
@@ -194,6 +253,8 @@ import lib; // libのインポート
 
 モジュールインポート宣言は、モジュールのインターフェースユニットをインポートする。
 
+- モジュール実装ユニットはモジュールインターフェースユニットを暗黙的にインポートする。ソースファイルと同名のヘッダーファイルをインクルードすることは多いが、これを自動化したものである。
+
 インポートされた翻訳単位でエクスポートされている名前は、インポート宣言を記述した翻訳単位において**可視**(visible)となる。
 名前が可視であるとき、かつそのときに限り、名前は名前探索の候補となる。
 
@@ -210,6 +271,23 @@ export import lib; // libの再エクスポート
 
 モジュールをインポートすると、そのモジュールが再エクスポートしているモジュールも同時にインポートする。
 
+#### パーティションのインポート
+
+パーティションは内部的には別のモジュールのように振る舞うので、パーティション内の宣言などを利用するにはインポートが必要である。
+
+パーティションは主となるモジュールが異なる場合はインポートできないので、間違いのないように、インポート宣言にはモジュールパーティション名だけを書く。
+
+```cpp
+export module datetime;
+export import :date; // インターフェースパーティション date をインポート
+export import :time; // インターフェースパーティション time をインポート
+```
+
+モジュールインターフェースパーティションはモジュールインターフェースを分割するものなので、内部の宣言を外へ公開しなければ意味がない。そのため、モジュールインターフェースパーティションのインポート宣言は必ず再エクスポートしなければならない。
+
+* パーティション内の宣言はエクスポートしていなくても見える
+* ただし、再エクスポートされるのはパーティションがエクスポートしている宣言のみ
+
 #### インターフェース依存
 
 翻訳単位がモジュールユニットUに**インターフェース依存**(interface dependency)を持つとは、次のことをいう：
@@ -245,69 +323,6 @@ C++20までは到達可能という用語はなかったが、前者の条件を
 
 エクスポートの有無とは関係なく、モジュールをインポートしただけでインターフェース依存が発生し、そのモジュールインターフェースユニットおよびその中の宣言へ到達可能となる。
 
-### モジュールパーティション
-
-モジュールは分割することができる。分割したモジュールをモジュールパーティションという。
-
-モジュールパーティションを宣言する構文は以下のようになる：
-
-```
-export(opt) module モジュール名:モジュールパーティション名 属性(opt);
-```
-
-- モジュールパーティション名の書式は、モジュール名と同じである。
-- `export` がある場合をモジュールインターフェースパーティション、ない場合をモジュール実装パーティションという。
-
-```cpp
-export module lib:part; // libモジュールのモジュールインターフェースパーティションpart
-```
-
-```cpp
-module lib:internal; // libモジュールのモジュール実装パーティションinternal
-```
-
-モジュールパーティションは基本的に別のモジュールと考えてよいが、以下の点で異なる：
-
-- 主となるモジュールが異なる場合はインポートできない。
-    - 外部へ公開するには、モジュールインターフェースから再エクスポートする。
-    - モジュールの利用者にパーティションの存在を意識させてはいけない。
-- インポート宣言にはモジュールパーティション名だけを書く。
-- インポートするとエクスポートしていない宣言も見えるようになる。
-    - ただし、再エクスポートはできない。
-
-主となるモジュールのインターフェースとパーティションを区別する場合は、プライマリーモジュールインターフェースユニットという事がある。
-
-```cpp
-// P1103R3より引用
-// 翻訳単位1
-export module A;
-export import :Foo;
-export int baz();
-
-// 翻訳単位2
-export module A:Foo;
-import :Internals;
-export int foo() { return 2 * (bar() + 1); }
-
-// 翻訳単位3
-module A:Internals;
-int bar();
-
-// 翻訳単位4
-module A;
-import :Internals;
-int bar() { return baz() - 10; }
-int baz() { return 30; }
-```
-* P1103R3[link http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf]
-
-このモジュールAは4つの翻訳単位からなる。上から順に、
-
-1. (プライマリー)モジュールインターフェースユニット
-2. モジュールインターフェースパーティション `:Foo`
-3. モジュール実装パーティション `:Internals`
-4. モジュール実装ユニット
-
 ### モジュールにおけるODR
 
 同じトークン列であれば再定義しても良いというODRの例外は、その定義が名前のあるモジュールに属する場合は適用されない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shared_mutex -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/reference/shared_mutex/shared_mutex.html"/>
      <id>b701f446eda041b6949771c59e20f69a6b3ce871:reference/shared_mutex/shared_mutex.md</id>
      <updated>2021-03-03T16:00:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/shared_mutex/shared_mutex.md b/reference/shared_mutex/shared_mutex.md
index 18529dd8e..5c124a611 100644
--- a/reference/shared_mutex/shared_mutex.md
+++ b/reference/shared_mutex/shared_mutex.md
@@ -88,8 +88,12 @@ public:
   // 読み込み側：カウンタの値を読む
   void reader()
   {
-    std::shared_lock&amp;lt;std::shared_mutex&amp;gt; lock(mtx_);
-    print_value(count_);
+    int local_count;
+    {
+      std::shared_lock&amp;lt;std::shared_mutex&amp;gt; lock(mtx_);
+      local_count = count_;
+    } // 共有ロックをここで手放す
+    print_value(local_count);
   }
 };
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>shared_timed_mutex -- Merge branch &#39;master&#39; of https://github.com/cpprefjp/site</title>
      <link href="https://cpprefjp.github.io/reference/shared_mutex/shared_timed_mutex.html"/>
      <id>b701f446eda041b6949771c59e20f69a6b3ce871:reference/shared_mutex/shared_timed_mutex.md</id>
      <updated>2021-03-03T16:00:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/shared_mutex/shared_timed_mutex.md b/reference/shared_mutex/shared_timed_mutex.md
index ef5f52bbf..64940c2d7 100644
--- a/reference/shared_mutex/shared_timed_mutex.md
+++ b/reference/shared_mutex/shared_timed_mutex.md
@@ -94,8 +94,12 @@ public:
   // 読み込み側：カウンタの値を読む
   void reader()
   {
-    std::shared_lock&amp;lt;std::shared_timed_mutex&amp;gt; lock(mtx_);
-    print_value(count_);
+    int local_count;
+    {
+      std::shared_lock&amp;lt;std::shared_mutex&amp;gt; lock(mtx_);
+      local_count = count_;
+    } // 共有ロックをここで手放す
+    print_value(local_count);
   }
 };
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- LWG Issue 3435対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/move_iterator/op_assign.html"/>
      <id>4fe591a778fc040b4f63eb39d66437c80caac7f3:reference/iterator/move_iterator/op_assign.md</id>
      <updated>2021-03-03T16:00:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/move_iterator/op_assign.md b/reference/iterator/move_iterator/op_assign.md
index 9d6fababc..f80469dab 100644
--- a/reference/iterator/move_iterator/op_assign.md
+++ b/reference/iterator/move_iterator/op_assign.md
@@ -21,9 +21,15 @@ constexpr move_iterator&amp;amp; operator=(move_iterator&amp;amp;&amp;amp;) = default;      // (3) C++17
 ## 概要
 - (1) : `u.base()`をメンバ変数に保持する。
 
+## テンプレートパラメータ制約
 
-## 要件
-- (1) : `U`が`Iterator`に変換可能であること
+- C++17まで
+  - (1) : `U`が`Iterator`に変換可能であること
+- C++20
+  - (1) : 次の両方を満たす
+    - `is_same_v&amp;lt;U, Iterator&amp;gt; == false`であること。
+    - `const U&amp;amp;`が[`convertible_to&amp;lt;Iterator&amp;gt;`](/reference/concepts/convertible_to.md)のモデルとなること。
+    - `Iterator&amp;amp;, const U&amp;amp;`が[`assignable_from&amp;lt;Iterator&amp;amp;, const U&amp;amp;&amp;gt;`](/reference/concepts/assignable_from.md)のモデルとなること。
 
 
 ## 例
@@ -68,3 +74,4 @@ int main()
 
 ## 参照
 - [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [LWG Issue 3435. `three_way_comparable_with&amp;lt;reverse_iterator&amp;lt;int*&amp;gt;, reverse_iterator&amp;lt;const int*&amp;gt;&amp;gt;`](https://cplusplus.github.io/LWG/issue3435)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- LWG Issue 3435対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/move_iterator/op_constructor.html"/>
      <id>4fe591a778fc040b4f63eb39d66437c80caac7f3:reference/iterator/move_iterator/op_constructor.md</id>
      <updated>2021-03-03T16:00:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/move_iterator/op_constructor.md b/reference/iterator/move_iterator/op_constructor.md
index da4d60be8..8dfe741fc 100644
--- a/reference/iterator/move_iterator/op_constructor.md
+++ b/reference/iterator/move_iterator/op_constructor.md
@@ -24,14 +24,18 @@ constexpr move_iterator(move_iterator&amp;amp;&amp;amp;) noexcept = default; // (4) C++17
 ## 概要
 `move_iterator`オブジェクトを構築する。
 
-- (1) : デフォルトコンストラクタ。内容する元となるイテレータの値を、`Iterator`の初期化された値を使用して初期化する。
-- (2) : 元となるイテレータを受け取り、メンバ変数に保持する。
+- (1) : デフォルトコンストラクタ。内包する元となるイテレータを値初期化する。
+- (2) : 元となるイテレータ`i`をメンバ変数にムーブして保持する。
 - (3) : `u.base()`をメンバ変数に保持する。
 
+## テンプレートパラメータ制約
 
-## 要件
-- (3) : `U`が`Iterator`に変換可能であること
-
+- C++17まで
+  - (3) : `U`が`Iterator`に変換可能であること
+- C++20
+  - (3) : 次の全てを満たす
+    - `is_same_v&amp;lt;U, Iterator&amp;gt; == false`であること。
+    - `const U&amp;amp;, Iterator`が[`convertible_to&amp;lt;Iterator&amp;gt;`](/reference/concepts/convertible_to.md)のモデルとなること。
 
 ## 例
 ```cpp example
@@ -83,3 +87,4 @@ int main()
 
 ## 参照
 - [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [LWG Issue 3435. `three_way_comparable_with&amp;lt;reverse_iterator&amp;lt;int*&amp;gt;, reverse_iterator&amp;lt;const int*&amp;gt;&amp;gt;`](https://cplusplus.github.io/LWG/issue3435)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- LWG Issue 3435対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/reverse_iterator/op_assign.html"/>
      <id>4fe591a778fc040b4f63eb39d66437c80caac7f3:reference/iterator/reverse_iterator/op_assign.md</id>
      <updated>2021-03-03T16:00:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/reverse_iterator/op_assign.md b/reference/iterator/reverse_iterator/op_assign.md
index 8dedff4ae..2f35f6909 100644
--- a/reference/iterator/reverse_iterator/op_assign.md
+++ b/reference/iterator/reverse_iterator/op_assign.md
@@ -17,9 +17,15 @@ constexpr reverse_iterator&amp;amp; operator=(const reverse_iterator&amp;lt;U&amp;gt;&amp;amp; u);        // (
 ## 概要
 - (2) : `u.base()`をメンバ変数`current`に保持する。
 
+## テンプレートパラメータ制約
 
-## 要件
-- (2) : `U`が`Iterator`に変換可能であること
+- C++17まで
+  - (2) : `U`が`Iterator`に変換可能であること
+- C++20
+  - (2) : 次の両方を満たす
+    - `is_same_v&amp;lt;U, Iterator&amp;gt; == false`であること。
+    - `const U&amp;amp;, Iterator`が[`convertible_to&amp;lt;Iterator&amp;gt;`](/reference/concepts/convertible_to.md)のモデルとなること。
+    - `Iterator&amp;amp;, const U&amp;amp;`が[`assignable_from&amp;lt;Iterator&amp;amp;, const U&amp;amp;&amp;gt;`](/reference/concepts/assignable_from.md)のモデルとなること。
 
 
 ## 戻り値
@@ -65,3 +71,4 @@ int main()
 
 ## 参照
 - [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [LWG Issue 3435. `three_way_comparable_with&amp;lt;reverse_iterator&amp;lt;int*&amp;gt;, reverse_iterator&amp;lt;const int*&amp;gt;&amp;gt;`](https://cplusplus.github.io/LWG/issue3435)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- LWG Issue 3435対応</title>
      <link href="https://cpprefjp.github.io/reference/iterator/reverse_iterator/op_constructor.html"/>
      <id>4fe591a778fc040b4f63eb39d66437c80caac7f3:reference/iterator/reverse_iterator/op_constructor.md</id>
      <updated>2021-03-03T16:00:32+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/reverse_iterator/op_constructor.md b/reference/iterator/reverse_iterator/op_constructor.md
index 52f002e00..6f1dcadc6 100644
--- a/reference/iterator/reverse_iterator/op_constructor.md
+++ b/reference/iterator/reverse_iterator/op_constructor.md
@@ -25,6 +25,14 @@ constexpr reverse_iterator(const reverse_iterator&amp;lt;U&amp;gt;&amp;amp; u); // (3) C++17
 - (2) : 元となるイテレータ`x`を受け取り、メンバ変数`current`に保持する。
 - (3) : `u.current`をメンバ変数`current`に保持する。
 
+## テンプレートパラメータ制約
+
+- C++17まで
+  - (3) : `U`が`Iterator`に変換可能であること
+- C++20
+  - (3) : 次の両方を満たす
+    - `is_same_v&amp;lt;U, Iterator&amp;gt; == false`であること。
+    - `const U&amp;amp;, Iterator`が[`convertible_to&amp;lt;Iterator&amp;gt;`](/reference/concepts/convertible_to.md)のモデルとなること。
 
 ## 要件
 - (3) : `U`が`Iterator`に変換可能であること
@@ -59,3 +67,4 @@ int main()
 
 ## 参照
 - [P0031R0 A Proposal to Add Constexpr Modifiers to `reverse_iterator`, `move_iterator`, `array` and Range Access](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html)
+- [LWG Issue 3435. `three_way_comparable_with&amp;lt;reverse_iterator&amp;lt;int*&amp;gt;, reverse_iterator&amp;lt;const int*&amp;gt;&amp;gt;`](https://cplusplus.github.io/LWG/issue3435)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>random_access_iterator -- LWG Issue 3277リンク追加</title>
      <link href="https://cpprefjp.github.io/reference/iterator/random_access_iterator.html"/>
      <id>9d4b5fd05ad1308489c6a02d084157d21fcfeba5:reference/iterator/random_access_iterator.md</id>
      <updated>2021-03-03T15:40:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/random_access_iterator.md b/reference/iterator/random_access_iterator.md
index 79e13dbdc..f182706fd 100644
--- a/reference/iterator/random_access_iterator.md
+++ b/reference/iterator/random_access_iterator.md
@@ -151,3 +151,4 @@ std::ostream_iterator&amp;lt;double&amp;gt; is not random_access_iterator
 ## 参照
 
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
+- [LWG Issue 3277. Pre-increment on prvalues is not a requirement of `weakly_incrementable`](https://wg21.cmeerw.net/lwg/issue3277)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>