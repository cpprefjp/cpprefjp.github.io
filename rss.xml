<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-16T08:59:19.874647</updated>
  <id>ebe00de4-7d4a-49fe-80c2-6268e24a2dae</id>

  
    <entry>
      <title>cmath -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index c16eeaa1a..d444ed428 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -255,13 +255,13 @@ C++03 までの場合、[`errno`](cerrno/errno.md) でしか通知されない
 
 | 名前 | 説明 | 対応バージョン |
 |-----------|----------------------------------|-------|
-| [`ldexp`](cmath/ldexp.md)    | 2 の累乗との乗算                 | |
-| [`frexp`](cmath/frexp.md)    | 仮数部と 2 の累乗への分解        | |
-| [`ilogb`](cmath/ilogb.md)    | 指数部を符号付き整数値として抽出 | C++11 |
-| [`logb`](cmath/logb.md)      | 指数部を浮動小数点数値として抽出 | C++11 |
-| [`modf`](cmath/modf.md)      | 整数部と小数部への分解           | |
-| [`scalbn`](cmath/scalbn.md)  | 内部表現の基数 (`FLT_RADIX`) の累乗との乗算 | C++11 |
-| [`scalbln`](cmath/scalbn.md) | 内部表現の基数 (`FLT_RADIX`) の累乗との乗算 | C++11 |
+| [`ldexp`](cmath/ldexp.md)     | 2 の累乗との乗算                 | |
+| [`frexp`](cmath/frexp.md)     | 仮数部と 2 の累乗への分解        | |
+| [`ilogb`](cmath/ilogb.md)     | 指数部を符号付き整数値として抽出 | C++11 |
+| [`logb`](cmath/logb.md)       | 指数部を浮動小数点数値として抽出 | C++11 |
+| [`modf`](cmath/modf.md)       | 整数部と小数部への分解           | |
+| [`scalbn`](cmath/scalbn.md)   | 内部表現の基数 (`FLT_RADIX`) の累乗との乗算 | C++11 |
+| [`scalbln`](cmath/scalbln.md) | 内部表現の基数 (`FLT_RADIX`) の累乗との乗算。乗数として`long`をとる | C++11 |
 
 
 ## &amp;lt;a id=&amp;#34;power-and-absolute-value-functions&amp;#34; href=&amp;#34;#power-and-absolute-value-functions&amp;#34;&amp;gt;累乗・冪根と絶対値&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>abs -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/abs.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/abs.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/abs.md b/reference/cmath/abs.md
index 1505b65f0..2fd23a231 100644
--- a/reference/cmath/abs.md
+++ b/reference/cmath/abs.md
@@ -75,7 +75,7 @@ abs(-1.5) = 1.500000
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ceil -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ceil.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/ceil.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ceil.md b/reference/cmath/ceil.md
index d2f6c3cf1..dd4d662f7 100644
--- a/reference/cmath/ceil.md
+++ b/reference/cmath/ceil.md
@@ -5,14 +5,27 @@
 
 ```cpp
 namespace std {
-  float ceil(float x);
-  double ceil(double x);
-  long double ceil(long double x);
-
-  double ceil(Integral x);          // C++11 から
-
-  float ceilf(float x);             // C++17 から
-  long double ceill(long double x); // C++17 から
+  float ceil(float x);              // (1) C++03からC++20まで
+  double ceil(double x);            // (2) C++03からC++20まで
+  long double ceil(long double x);  // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+   ceil(floating-point-type x);     // (4) C++23
+
+  double
+    ceil(Integral x);               // (5) C++11
+  constexpr double
+    ceil(Integral x);               // (5) C++23
+
+  float
+    ceilf(float x);                 // (6) C++17
+  constexpr float
+    ceilf(float x);                 // (6) C++17
+
+  long double
+    ceill(long double x);           // (7) C++17
+  constexpr long double
+    ceill(long double x);           // (7) C++17
 }
 ```
 * Integral[italic]
@@ -20,6 +33,14 @@ namespace std {
 ## 概要
 引数 `x` 以上で最小の整数値を得る。（天井関数）
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` 以上で最小の整数値
@@ -35,6 +56,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_UPWARD`](/reference/cfenv/fe_upward.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -97,3 +119,10 @@ FE_INEXACT = true
 ```
 
 引数と結果が異なる場合に例外 `FE_INEXACT` が発生するか否かは実装によって異なる。
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copysign -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/copysign.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/copysign.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/copysign.md b/reference/cmath/copysign.md
index edb18a5f7..22f5656c6 100644
--- a/reference/cmath/copysign.md
+++ b/reference/cmath/copysign.md
@@ -6,14 +6,40 @@
 
 ```cpp
 namespace std {
-  double copysign(double x, double y);
-  float copysign(float x, float y);
-  long double copysign(long double x, long double y);
-
-  Integral copysign(Integral x, Integral y);
-
-  float copysignf(float x, float y);                   // C++17 から
-  long double copysignl(long double x, long double y); // C++17 から
+  float
+    copysign(float x,
+             float y);               // (1) C++11からC++20まで
+  double
+    copysign(double x,
+             double y);              // (2) C++11からC++20まで
+  long double
+    copysign(long double x,
+             long double y);         // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    copysign(floating-point-type x,
+             floating-point-type y); // (4) C++23
+
+  Integral
+    copysign(Integral x
+             Integral y);            // (5) C++11
+  constexpr Integral
+    copysign(Integral x
+             Integral y);            // (5) C++23
+
+  float
+    copysignf(float x,
+              float y);              // (6) C++17
+  constexpr float
+    copysignf(float x,
+              float y);              // (6) C++23
+
+  long double
+    copysignl(long double x,
+              long double y);        // (7) C++17
+  constexpr long double
+    copysignl(long double x,
+              long double y);        // (7) C++23
 }
 ```
 * Integral[italic]
@@ -21,6 +47,14 @@ namespace std {
 ## 概要
 `x`の絶対値に`y`の符号が付いた値を生成する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `x`の絶対値に`y`の符号が付いた値を返す。
@@ -29,7 +63,8 @@ namespace std {
 
 
 ## 備考
-符号付きゼロを表現するが負のゼロを取り扱わない実装では、この関数はゼロを正と見なす。
+- 符号付きゼロを表現するが負のゼロを取り扱わない実装では、この関数はゼロを正と見なす。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -55,7 +90,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -102,3 +137,10 @@ namespace std {
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fabs -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fabs.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fabs.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fabs.md b/reference/cmath/fabs.md
index 3fb04cb1e..dff3100ed 100644
--- a/reference/cmath/fabs.md
+++ b/reference/cmath/fabs.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float fabs(float x);
-  double fabs(double x);
-  long double fabs(long double x);
-
-  double fabs(Integral x);          // C++11 から
-
-  float fabsf(float x);             // C++17 から
-  long double fabsl(long double x); // C++17 から
+  float fabs(float x);              // (1) C++03からC++20まで
+  double fabs(double x);            // (2) C++03からC++20まで
+  long double fabs(long double x);  // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    fabs(floating-point-type x);    // (4) C++23
+
+  double
+    fabs(Integral x);               // (5) C++11
+  constexpr double
+    fabs(Integral x);               // (5) C++23
+
+  float
+    fabsf(float x);                 // (6) C++17
+  constexpr float
+    fabsf(float x);                 // (6) C++23
+
+  long double
+    fabsl(long double x);           // (7) C++17
+  constexpr long double
+    fabsl(long double x);           // (7) C++17
 }
 ```
 * Integral[italic]
@@ -21,6 +34,14 @@ namespace std {
 ## 概要
 算術型の絶対値を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` の絶対値を返す。
@@ -34,6 +55,7 @@ namespace std {
 - `value = ±0` の場合、戻り値は `+0` となる。
 - `value = ±∞` の場合、戻り値は `+∞` となる。
 - 戻り値は正確で、現在の丸め方式には依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -77,7 +99,7 @@ fabs(-∞)   = inf
 - [Visual C++](/implementation.md#visual_cpp): 2003, 2005, 2008, 2010
 
 #### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -108,3 +130,9 @@ namespace std {
 * signbit[link signbit.md]
 * is_integral[link ../type_traits/is_integral.md]
 * enable_if[link ../type_traits/enable_if.md]
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fdim -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fdim.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fdim.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fdim.md b/reference/cmath/fdim.md
index 10fbfd994..34f6d84bd 100644
--- a/reference/cmath/fdim.md
+++ b/reference/cmath/fdim.md
@@ -6,14 +6,30 @@
 
 ```cpp
 namespace std {
-  float fdim(float x, float y);
-  double fdim(double x, double y);
-  long double fdim(long double x, long double y);
+  float fdim(float x, float y);                   // (1) C++11からC++20まで
+  double fdim(double x, double y);                // (2) C++11からC++20まで
+  long double fdim(long double x, long double y); // (3) C++11からC++20まで
 
-  Promoted fdim(Arithmetic1 x, Arithmetic2 y);
+  constexpr floating-point-type
+    fdim(floating-point-type x,
+         floating-point-type y);                  // (4) C++23
 
-  float fdimf(float x, float y);                   // C++17 から
-  long double fdiml(long double x, long double y); // C++17 から
+  Promoted
+    fdim(Arithmetic1 x,
+         Arithmetic2 y);                          // (5) C++11
+  constexpr Promoted
+    fdim(Arithmetic1 x,
+         Arithmetic2 y);                          // (5) C++23
+
+  float
+    fdimf(float x, float y);                      // (6) C++17
+  constexpr float
+    fdimf(float x, float y);                      // (6) C++23
+
+  long double
+    fdiml(long double x, long double y);          // (7) C++17
+  constexpr long double
+    fdiml(long double x, long double y);          // (7) C++23
 }
 ```
 * Promoted[italic]
@@ -23,11 +39,25 @@ namespace std {
 ## 概要
 算術型の正の差を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
+
 ## 戻り値
 引数の正の差を返す。
 
 `x - y &amp;gt; 0` の場合は `x - y` を、それ以外の場合は `+0` を返す。
 
+
+## 備考
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;cmath&amp;gt;
@@ -61,6 +91,13 @@ fdim(+1.0, 0.0) = +1
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 #### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>floor -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/floor.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/floor.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/floor.md b/reference/cmath/floor.md
index 8c3c77693..b3bb3b5b9 100644
--- a/reference/cmath/floor.md
+++ b/reference/cmath/floor.md
@@ -5,14 +5,27 @@
 
 ```cpp
 namespace std {
-  float floor(float x);
-  double floor(double x);
-  long double floor(long double x);
-
-  double floor(Integral x);          // C++11 から
-
-  float floorf(float x);             // C++17 から
-  long double floorl(long double x); // C++17 から
+  float floor(float x);             // (1) C++03からC++20まで
+  double floor(double x);           // (2) C++03からC++20まで
+  long double floor(long double x); // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    floor(floating-point-type x);   // (4) C++23
+
+  double
+    floor(Integral x);              // (5) C++11
+  constexpr double
+    floor(Integral x);              // (5) C++23
+
+  float
+    floorf(float x);                // (6) C++17
+  constexpr float
+    floorf(float x);                // (6) C++23
+
+  long double
+    floorl(long double x);          // (7) C++17
+  constexpr long double
+    floorl(long double x);          // (7) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +33,14 @@ namespace std {
 ## 概要
 引数 `x` 以下で最大の整数値を得る。（床関数）
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` 以下で最大の整数値
@@ -35,6 +56,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_DOWNWARD`](/reference/cfenv/fe_downward.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -97,3 +119,10 @@ FE_INEXACT = true
 ```
 
 引数と結果が異なる場合に例外 `FE_INEXACT` が発生するか否かは実装によって異なる。
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fma -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fma.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fma.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fma.md b/reference/cmath/fma.md
index 77924d164..7e633925f 100644
--- a/reference/cmath/fma.md
+++ b/reference/cmath/fma.md
@@ -6,14 +6,50 @@
 
 ```cpp
 namespace std {
-  float fma(float x, float y, float z);
-  double fma(double x, double y, double z);
-  long double fma(long double x, long double y, long double z);
-
-  Promoted fma(Arithmetic1 x, Arithmetic2 y, Arithmetic3 z);
-
-  float fmaf(float x, float y, float z);                         // C++17 から
-  long double fmal(long double x, long double y, long double z); // C++17 から
+  float
+    fma(float x,
+        float y,
+        float z);                 // (1) C++11からC++20まで
+  double
+    fma(double x,
+        double y,
+        double z);                // (2) C++11からC++20まで
+  long double
+    fma(long double x,
+        long double y,
+        long double z);           // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    fma(floating-point-type x,
+        floating-point-type y,
+        floating-point-type z);   // (4) C++23
+
+  Promoted
+    fma(Arithmetic1 x,
+        Arithmetic2 y,
+        Arithmetic3 z);           // (5) C++11
+  constexpr Promoted
+    fma(Arithmetic1 x,
+        Arithmetic2 y,
+        Arithmetic3 z);           // (5) C++23
+
+  float
+    fmaf(float x,
+         float y,
+         float z);                // (6) C++17
+  constexpr float
+    fmaf(float x,
+         float y,
+         float z);                // (6) C++23
+
+  long double
+    fmal(long double x,
+         long double y,
+         long double z);          // (7) C++17
+  constexpr long double
+    fmal(long double x,
+         long double y,
+         long double z);          // (7) C++23
 }
 ```
 * Promoted[italic]
@@ -29,6 +65,14 @@ namespace std {
 
 `fma` は fused multiply-add の略。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `x * y + z` を無限精度で計算した後、現在の丸めモードで丸めた結果
@@ -46,6 +90,7 @@ namespace std {
 
 - 本関数が単純に `x * y + z` を計算するのと等価か、より速い場合には、引数の型に応じて [`FP_FAST_FMA`](fp_fast_fma.md)（`double` の場合）、[`FP_FAST_FMAF`](fp_fast_fmaf.md)（`float` の場合）、[`FP_FAST_FMAL`](fp_fast_fmal.md)（`long double` の場合）と言ったマクロが定義される。  
 	これらのマクロは、一般的に本関数がハードウェアによる積和演算命令を使用している場合にのみ定義される。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -162,3 +207,9 @@ FE_INVALID
 inf * 1.0 + -inf = -nan
 
 ```
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmax -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmax.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fmax.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmax.md b/reference/cmath/fmax.md
index 9bc851fe1..897dc964c 100644
--- a/reference/cmath/fmax.md
+++ b/reference/cmath/fmax.md
@@ -6,14 +6,31 @@
 
 ```cpp
 namespace std {
-  float fmax(float x, float y);
-  double fmax(double x, double y);
-  long double fmax(long double x, long double y);
-
-  Promoted fmax(Arithmetic1 x, Arithmetic2 y);
-
-  float fmaxf(float x, float y);                   // C++17 から
-  long double fmaxl(long double x, long double y); // C++17 から
+  float fmax(float x, float y);          // (1) C++11からC++20まで
+  double fmax(double x, double y);       // (2) C++11からC++20まで
+  long double
+    fmax(long double x, long double y);  // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    fmax(floating-point-type x,
+         floating-point-type y);         // (4) C++23
+
+  Promoted
+    fmax(Arithmetic1 x,
+         Arithmetic2 y);                 // (5) C++11
+  constexpr Promoted
+    fmax(Arithmetic1 x,
+         Arithmetic2 y);                 // (5) C++23
+
+  float
+    fmaxf(float x, float y);             // (6) C++17
+  constexpr float
+    fmaxf(float x, float y);             // (6) C++23
+
+  long double
+    fmaxl(long double x, long double y); // (7) C++17
+  constexpr long double
+    fmaxl(long double x, long double y); // (7) C++17
 }
 ```
 * Promoted[italic]
@@ -23,6 +40,15 @@ namespace std {
 ## 概要
 算術型の最大値を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
+
 ## 戻り値
 引数の最大値を返す。
 
@@ -32,6 +58,8 @@ namespace std {
     - 引数の1つが NaN の場合 NaN でない方を返す。
     - 引数が2つとも NaN の場合 NaN を返す。
 - 理想的には `fmax(-0.0, +0.0)` は `+0` を返す。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
 
 ## 例
 ```cpp example
@@ -71,7 +99,7 @@ fmax( nan, nan)  = +nan
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 #### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -105,3 +133,10 @@ namespace std {
 * std::enable_if[link ../type_traits/enable_if.md]
 * std::is_arithmetic[link ../type_traits/is_arithmetic.md]
 * std::common_type[link ../type_traits/common_type.md]
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmin -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmin.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fmin.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmin.md b/reference/cmath/fmin.md
index ad1d547ab..d342f48a4 100644
--- a/reference/cmath/fmin.md
+++ b/reference/cmath/fmin.md
@@ -6,14 +6,31 @@
 
 ```cpp
 namespace std {
-  float fmin(float x, float y);
-  double fmin(double x, double y);
-  long double fmin(long double x, long double y);
-
-  Promoted fmin(Arithmetic1 x, Arithmetic2 y);
-
-  float fminf(float x, float y);                   // C++17 から
-  long double fminl(long double x, long double y); // C++17 から
+  float fmin(float x, float y);          // (1) C++11からC++20まで
+  double fmin(double x, double y);       // (2) C++11からC++20まで
+  long double
+    fmin(long double x, long double y);  // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    fmin(floating-point-type x,
+         floating-point-type y);         // (4) C++23
+
+  Promoted
+    fmin(Arithmetic1 x,
+         Arithmetic2 y);                 // (5) C++11
+  constexpr Promoted
+    fmin(Arithmetic1 x,
+         Arithmetic2 y);                 // (5) C++23
+
+  float
+    fminf(float x, float y);             // (6) C++17
+  constexpr float
+    fminf(float x, float y);             // (6) C++17
+
+  long double
+    fminl(long double x, long double y); // (7) C++17
+  constexpr long double
+    fminl(long double x, long double y); // (7) C++17
 }
 ```
 * Promoted[italic]
@@ -23,15 +40,27 @@ namespace std {
 ## 概要
 算術型の最小値を求める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
+
 ## 戻り値
 引数の最小値を返す。
 
+
 ## 備考
 - 戻り値は正確で、現在の丸めモードに依存しない。
 - 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。
     - 引数の1つが NaN の場合 NaN でない方を返す。
     - 引数が2つとも NaN の場合 NaN を返す。
 - 理想的には `fmin(-0.0, +0.0)` は `-0` を返す。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
 
 ## 例
 ```cpp example
@@ -71,7 +100,7 @@ fmin( nan, nan)  = +nan
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 #### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -105,3 +134,10 @@ namespace std {
 * std::enable_if[link ../type_traits/enable_if.md]
 * std::is_arithmetic[link ../type_traits/is_arithmetic.md]
 * std::common_type[link ../type_traits/common_type.md]
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmod -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmod.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fmod.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmod.md b/reference/cmath/fmod.md
index 1666e7831..b74689fa3 100644
--- a/reference/cmath/fmod.md
+++ b/reference/cmath/fmod.md
@@ -5,14 +5,31 @@
 
 ```cpp
 namespace std {
-  double fmod(double x, double y);
-  float fmod(float x, float y);
-  long double fmod(long double x, long double y);
-
-  Integral fmod(Integral x, Integral y);           // C++11 から
-
-  float fmodf(float x, float y);                   // C++17 から
-  long double fmodl(long double x, long double y); // C++17 から
+  float fmod(float x, float y);    // (1) C++03からC++20まで
+  double fmod(double x, double y); // (2) C++03からC++20まで
+  long double fmod(long double x,
+                   long double y); // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    fmod(floating-point-type x,
+         floating-point-type y);   // (4) C++23
+
+  Integral
+    fmod(Integral x, Integral y);  // (5) C++11
+  constexpr Integral
+    fmod(Integral x, Integral y);  // (5) C++23
+
+  float
+    fmodf(float x, float y);       // (6) C++17
+  constexpr float
+    fmodf(float x, float y);       // (6) C++23
+
+  long double
+    fmodl(long double x,
+          long double y);          // (7) C++17
+  constexpr long double
+    fmodl(long double x,
+          long double y);          // (8) C++17
 }
 ```
 * Integral[italic]
@@ -22,6 +39,14 @@ namespace std {
 
 整数に対する剰余は`%`演算子で求められるが、浮動小数点数に対しては本関数を使用する必要がある。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `x / y`の余りを返す。
@@ -97,3 +122,8 @@ fmod(6.3, 3.15) = 0
 fmod(6, 2) = 0
 ```
 
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fpclassify -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fpclassify.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/fpclassify.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fpclassify.md b/reference/cmath/fpclassify.md
index f855a47ac..16242d32d 100644
--- a/reference/cmath/fpclassify.md
+++ b/reference/cmath/fpclassify.md
@@ -6,13 +6,17 @@
 
 ```cpp
 namespace std {
-  int fpclassify(float x);
+  int fpclassify(float x);             // (1) C++11からC++20まで
+  int fpclassify(double x);            // (2) C++11からC++20まで
+  int fpclassify(long double x);       // (3) C++11からC++20まで
 
-  int fpclassify(double x);
+  constexpr int
+    fpclassify(floating-point-type x); // (4) C++23
 
-  int fpclassify(long double x);
-
-  int fpclassify(Integral x);
+  int
+    fpclassify(Integral x);            // (5) C++11
+  constexpr int
+    fpclassify(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -21,6 +25,12 @@ namespace std {
 ## 概要
 指定された値の数値分類を返す。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 引数 `x` で指定された値の数値分類を表すマクロの整数値を返す。
@@ -37,7 +47,8 @@ namespace std {
 
 
 ## 備考
-本関数は、C 言語の `fpclassify` マクロと等価の機能を持つ。
+- C標準ライブラリでは`fpclassify`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -74,3 +85,10 @@ true
 true
 true
 ```
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isfinite -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isfinite.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isfinite.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isfinite.md b/reference/cmath/isfinite.md
index 12e54f7c8..395305d82 100644
--- a/reference/cmath/isfinite.md
+++ b/reference/cmath/isfinite.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool isfinite(float x);
-  bool isfinite(double x);
-  bool isfinite(long double x);
+  bool isfinite(float x);            // (1) C++11からC++20まで
+  bool isfinite(double x);           // (2) C++11からC++20まで
+  bool isfinite(long double x);      // (3) C++11からC++20まで
 
-  bool isfinite(Integral x);
+  constexpr bool
+    isfinite(floating-point-type x); // (4) C++23
+
+  bool
+    isfinite(Integral x);            // (5) C++11
+  constexpr bool
+    isfinite(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,13 +24,20 @@ namespace std {
 ## 概要
 数値が有限(finite value)であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`がゼロ、非正規化数、正規化数のいずれかであり、無限大とNaNのいずれでもない場合に有限値であると見なし、`true`を返す。そうでない場合、`false`を返す。
 
 
 ## 備考
-C標準ライブラリでは`isfinite`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`isfinite`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -73,7 +86,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -87,3 +100,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isgreater -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isgreater.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isgreater.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isgreater.md b/reference/cmath/isgreater.md
index 7b7cd8a32..37537ccee 100644
--- a/reference/cmath/isgreater.md
+++ b/reference/cmath/isgreater.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool isgreater(double x, double y);
-
-  bool isgreater(float x, float y);
-
-  bool isgreater(long double x, long double y);
-
-  bool isgreater(Integral x, Integral y);
+  bool isgreater(float x, float y);             // (1) C++11からC++20まで
+  bool isgreater(double x, double y);           // (2) C++11からC++20まで
+  bool isgreater(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    isgreater(floating-point-type x,
+              floating-point-type y);           // (4) C++23
+
+  bool
+    isgreater(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    isgreater(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,11 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺より大きいかを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
 
 
 ## 戻り値
@@ -29,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -92,3 +103,10 @@ isgreater(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isgreaterequal -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isgreaterequal.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isgreaterequal.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isgreaterequal.md b/reference/cmath/isgreaterequal.md
index 465af642e..c8c03b169 100644
--- a/reference/cmath/isgreaterequal.md
+++ b/reference/cmath/isgreaterequal.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool isgreaterequal(double x, double y);
-
-  bool isgreaterequal(float x, float y);
-
-  bool isgreaterequal(long double x, long double y);
-
-  bool isgreaterequal(Integral x, Integral y);
+  bool isgreaterequal(float x, float y);             // (1) C++11からC++20まで
+  bool isgreaterequal(double x, double y);           // (2) C++11からC++20まで
+  bool isgreaterequal(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    isgreaterequal(floating-point-type x,
+                   floating-point-type y);           // (4) C++23
+
+  bool
+    isgreaterequal(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    isgreaterequal(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,11 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺以上かを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
 
 
 ## 戻り値
@@ -29,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -92,3 +103,10 @@ isgreaterequal(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isinf -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isinf.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isinf.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isinf.md b/reference/cmath/isinf.md
index dfcc50590..2dfd8e152 100644
--- a/reference/cmath/isinf.md
+++ b/reference/cmath/isinf.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool isinf(float x);
-  bool isinf(double x);
-  bool isinf(long double x);
+  bool isinf(float x);            // (1) C++11からC++20まで
+  bool isinf(double x);           // (2) C++11からC++20まで
+  bool isinf(long double x);      // (3) C++11からC++20まで
 
-  bool isinf(Integral x);
+  constexpr bool
+    isinf(floating-point-type x); // (4) C++23
+
+  bool
+    isinf(Integral x);            // (5) C++11
+  constexpr bool
+    isinf(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,13 +24,20 @@ namespace std {
 ## 概要
 数値が無限大(infinity)であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`が(正もしくは負の)無限大である場合、`true`を返す。そうでない場合、`false`を返す。
 
 
 ## 備考
-C標準ライブラリでは`isinf`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`isinf`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -47,7 +60,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -61,3 +74,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isless -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isless.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isless.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isless.md b/reference/cmath/isless.md
index 4234fd8d4..30e5078f2 100644
--- a/reference/cmath/isless.md
+++ b/reference/cmath/isless.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool isless(double x, double y);
-
-  bool isless(float x, float y);
-
-  bool isless(long double x, long double y);
-
-  bool isless(Integral x, Integral y);
+  bool isless(float x, float y);             // (1) C++11からC++20まで
+  bool isless(double x, double y);           // (2) C++11からC++20まで
+  bool isless(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    isless(floating-point-type x,
+           floating-point-type y);           // (4) C++23
+
+  bool
+    isless(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    isless(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,11 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺より小さいかを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
 
 
 ## 戻り値
@@ -29,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -92,3 +103,10 @@ isless(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>islessequal -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/islessequal.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/islessequal.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/islessequal.md b/reference/cmath/islessequal.md
index cc8e05921..ffe0a4dd7 100644
--- a/reference/cmath/islessequal.md
+++ b/reference/cmath/islessequal.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool islessequal(double x, double y);
-
-  bool islessequal(float x, float y);
-
-  bool islessequal(long double x, long double y);
-
-  bool islessequal(Integral x, Integral y);
+  bool islessequal(float x, float y);             // (1) C++11からC++20まで
+  bool islessequal(double x, double y);           // (2) C++11からC++20まで
+  bool islessequal(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    islessequal(floating-point-type x,
+                floating-point-type y);           // (4) C++23
+
+  bool
+    islessequal(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    islessequal(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,12 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺以下かを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 `x &amp;lt;= y`と等価の演算によって、`x`が`y`以下であれば`true`、そうでなければ`false`を返す。
@@ -28,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -91,3 +103,10 @@ islessequal(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>islessgreater -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/islessgreater.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/islessgreater.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/islessgreater.md b/reference/cmath/islessgreater.md
index 00c796d2a..a31690fff 100644
--- a/reference/cmath/islessgreater.md
+++ b/reference/cmath/islessgreater.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool islessgreater(double x, double y);
-
-  bool islessgreater(float x, float y);
-
-  bool islessgreater(long double x, long double y);
-
-  bool islessgreater(Integral x, Integral y);
+  bool islessgreater(float x, float y);             // (1) C++11からC++20まで
+  bool islessgreater(double x, double y);           // (2) C++11からC++20まで
+  bool islessgreater(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    islessgreater(floating-point-type x,
+                  floating-point-type y);           // (4) C++23
+
+  bool
+    islessgreater(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    islessgreater(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +25,12 @@ namespace std {
 ## 概要
 浮動小数点数について、左辺が右辺より小さい、もしくは左辺が右辺より大きい、のいずれかに該当するかを判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 `x &amp;lt; y || x &amp;gt; y`と等価の演算によって、`x`が`y`より小さい、もしくは`x`が`y`より大きければ`true`、そうでなければ`false`を返す。
@@ -28,8 +39,9 @@ namespace std {
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -91,3 +103,10 @@ islessgreater(nan, nan) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isnan -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isnan.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isnan.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isnan.md b/reference/cmath/isnan.md
index 1c41a90d5..d9ef05266 100644
--- a/reference/cmath/isnan.md
+++ b/reference/cmath/isnan.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool isnan(float x);
-  bool isnan(double x);
-  bool isnan(long double x);
+  bool isnan(float x);            // (1) C++11からC++20まで
+  bool isnan(double x);           // (2) C++11からC++20まで
+  bool isnan(long double x);      // (3) C++11からC++20まで
 
-  bool isnan(Integral x);
+  constexpr bool
+    isnan(floating-point-type x); // (4) C++23
+
+  bool
+    isnan(Integral x);            // (5) C++11
+  constexpr bool
+    isnan(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,13 +24,20 @@ namespace std {
 ## 概要
 数値が NaN であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`がNaNである場合、`true`を返す。そうでない場合、`false`を返す。
 
 
 ## 備考
-C標準ライブラリでは`isnan`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`isnan`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -51,7 +64,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -65,3 +78,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isnormal -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isnormal.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isnormal.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isnormal.md b/reference/cmath/isnormal.md
index 3e9aa6c8c..108f92a63 100644
--- a/reference/cmath/isnormal.md
+++ b/reference/cmath/isnormal.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool isnormal(float x);
-  bool isnormal(double x);
-  bool isnormal(long double x);
+  bool isnormal(float x);            // (1) C++11からC++20まで
+  bool isnormal(double x);           // (2) C++11からC++20まで
+  bool isnormal(long double x);      // (3) C++11からC++20まで
 
-  bool isnormal(Integral x);
+  constexpr bool
+    isnormal(floating-point-type x); // (4) C++23
+
+  bool
+    isnormal(Integral x);            // (5) C++11
+  constexpr bool
+    isnormal(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,13 +24,20 @@ namespace std {
 ## 概要
 数値が正規化数(normalized value)であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`がゼロ、非正規化数、無限大、NaNのいずれでもない場合に正規化数であると見なし、`true`を返す。そうでない場合、`false`を返す。
 
 
 ## 備考
-C標準ライブラリでは`isnormal`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`isnormal`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -73,7 +86,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -87,3 +100,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>isunordered -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/isunordered.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/isunordered.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/isunordered.md b/reference/cmath/isunordered.md
index dd88c6441..3c29cc16a 100644
--- a/reference/cmath/isunordered.md
+++ b/reference/cmath/isunordered.md
@@ -6,13 +6,18 @@
 
 ```cpp
 namespace std {
-  bool isunordered(double x, double y);
-
-  bool isunordered(float x, float y);
-
-  bool isunordered(long double x, long double y);
-
-  bool isunordered(Integral x, Integral y);
+  bool isunordered(float x, float y);             // (1) C++11からC++20まで
+  bool isunordered(double x, double y);           // (2) C++11からC++20まで
+  bool isunordered(long double x, long double y); // (3) C++11からC++20まで
+
+  constexpr bool
+    isunordered(floating-point-type x,
+              floating-point-type y);           // (4) C++23
+
+  bool
+    isunordered(Integral x, Integral y);          // (5) C++11
+  constexpr bool
+    isunordered(Integral x, Integral y);          // (5) C++23
 }
 ```
 * Integral[italic]
@@ -22,6 +27,11 @@ namespace std {
 
 NaNに対する順序付けはされないため、`x`と`y`のいずれかがNaNである場合、この関数は`true`を返す。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
 
 
 ## 戻り値
@@ -29,8 +39,9 @@ NaNに対する順序付けはされないため、`x`と`y`のいずれかがNa
 
 
 ## 備考
-- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
-- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする。
+- C標準ライブラリでは本関数は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C標準ライブラリでは本関数は`int`型を戻り値とするが、C++標準ライブラリでは`bool`型を戻り値とする
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -75,3 +86,10 @@ isunordered(1, inf) = false
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ldexp -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/ldexp.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/ldexp.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/ldexp.md b/reference/cmath/ldexp.md
index c8e973c15..00ca44339 100644
--- a/reference/cmath/ldexp.md
+++ b/reference/cmath/ldexp.md
@@ -86,7 +86,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>llround -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/llround.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/llround.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/llround.md b/reference/cmath/llround.md
index 5bc0ff98f..fe26bc96e 100644
--- a/reference/cmath/llround.md
+++ b/reference/cmath/llround.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  long long llround(float x);
-  long long llround(double x);
-  long long llround(long double x);
-
-  long long llround(Integral x);
-
-  long long int llroundf(float x);       // C++17 から
-  long long int llroundl(long double x); // C++17 から
+  long long llround(float x);       // (1) C++11からC++20まで
+  long long llround(double x);      // (2) C++11からC++20まで
+  long long llround(long double x); // (3) C++11からC++20まで
+
+  constexpr long long
+    llround(floating-point-type x); // (4) C++23
+
+  long long
+    llround(Integral x);            // (5) C++11
+  constexpr long long
+    llround(Integral x);            // (5) C++23
+
+  long long
+    llroundf(float x);              // (6) C++17
+  constexpr long long
+    llroundf(float x);              // (6) C++23
+
+  long long
+    llroundl(long double x);        // (7) C++17
+  constexpr long long
+    llroundl(long double x);        // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +36,14 @@ namespace std {
 ここで引数 `x` の四捨五入とは、`x` を最も近い整数に丸めるが、`x` の小数部分が `0.5` の場合には、`x` の符号が正負のいずれであってもゼロから遠い方向に丸めることを指す。  
 具体例は下記の出力例を参照。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を四捨五入により丸めた整数値を、[`long long`型](/lang/cpp11/long_long_type.md)型の範囲に収めて返す。
@@ -33,6 +54,7 @@ namespace std {
 - [`round`](round.md)関数と違い、本関数において戻り値が非整数型引数 `x` と異なる場合に、例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) を発生させる必要はない。
 - 戻り値が[`long long`型](/lang/cpp11/long_long_type.md)型の範囲を超えた場合、定義域エラーが起こる可能性がある。その際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -82,3 +104,9 @@ llround(-2.9) = -3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>logb -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/logb.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/logb.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/logb.md b/reference/cmath/logb.md
index 9224c4552..465951a6b 100644
--- a/reference/cmath/logb.md
+++ b/reference/cmath/logb.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float logb(float x);
-  double logb(double x);
-  long double logb(long double x);
-
-  double logb(Integral);
-
-  float logbf(float x);             // C++17 から
-  long double logbl(long double x); // C++17 から
+  float logb(float x);              // (1) C++11からC++20まで
+  double logb(double x);            // (2) C++11からC++20まで
+  long double logb(long double x);  // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    logb(floating-point-type x);    // (4) C++23
+
+  double
+    logb(Integral);                 // (5) C++11
+  constexpr double
+    logb(Integral);                 // (5) C++23
+
+  float
+    logbf(float x);                 // (6) C++17
+  constexpr float
+    logbf(float x);                 // (6) C++23
+
+  long double
+    logbl(long double x);           // (7) C++17
+  constexpr long double
+    logbl(long double x);           // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +36,14 @@ namespace std {
 
 `log` が名前に入っているが、通常の対数関数と異なり、引数の符号は無視されることに注意。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 `|x| *` [`FLT_RADIX`](/reference/cfloat/flt_radix.md)&amp;lt;code&amp;gt;&amp;lt;sup&amp;gt;-logb(x)&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt; が範囲 `[1,` [`FLT_RADIX`](/reference/cfloat/flt_radix.md)`)` に収まるように指数を求めて返す。（非正規化数の場合でも正しい値が返る）
@@ -36,6 +57,7 @@ namespace std {
 	- `x = ±0` の場合、戻り値は `-∞` となり、[`FE_DIVBYZERO`](../cfenv/fe_divbyzero.md)（ゼロ除算浮動小数点例外）が発生する。
 	- `x = ±∞` の場合、戻り値は `+∞` となる。
 	- 戻り値は正確で、現在の丸め方式に依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -76,3 +98,9 @@ logb(1e-309) = -1027
 - [GCC](/implementation.md#gcc): 4.3.6
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lround -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/lround.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/lround.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/lround.md b/reference/cmath/lround.md
index 705fe24d0..788e89eaf 100644
--- a/reference/cmath/lround.md
+++ b/reference/cmath/lround.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  long lround(float x);
-  long lround(double x);
-  long lround(long double x);
-
-  long lround(Integral x);
-
-  long int lroundf(float x);       // C++17 から
-  long int lroundl(long double x); // C++17 から
+  long lround(float x);            // (1) C++11からC++20まで
+  long lround(double x);           // (2) C++11からC++20まで
+  long lround(long double x);      // (3) C++11からC++20まで
+
+  constexpr long
+    lround(floating-point-type x); // (4) C++23
+
+  long
+    lround(Integral x);            // (5) C++11
+  constexpr long
+    lround(Integral x);            // (5) C++23
+
+  long int
+    lroundf(float x);              // (6) C++17
+  constexpr long int
+    lroundf(float x);              // (6) C++23
+
+  long int
+    lroundl(long double x);        // (7) C++17
+  constexpr long int
+    lroundl(long double x);        // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +36,14 @@ namespace std {
 ここで引数 `x` の四捨五入とは、`x` を最も近い整数に丸めるが、`x` の小数部分が `0.5` の場合には、`x` の符号が正負のいずれであってもゼロから遠い方向に丸めることを指す。  
 具体例は下記の出力例を参照。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を四捨五入により丸めた整数値を、`long`型の範囲に収めて返す。
@@ -33,6 +54,7 @@ namespace std {
 - [`round`](round.md)関数と違い、本関数において戻り値が非整数型引数 `x` と異なる場合に、例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) を発生させる必要はない。
 - 戻り値が`long`型の範囲を超えた場合、定義域エラーが起こる可能性がある。その際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 - なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -82,3 +104,9 @@ lround(-2.9) = -3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>modf -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/modf.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/modf.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/modf.md b/reference/cmath/modf.md
index b20911a3a..b0f620b46 100644
--- a/reference/cmath/modf.md
+++ b/reference/cmath/modf.md
@@ -5,14 +5,34 @@
 
 ```cpp
 namespace std {
-  double modf(double value, double* iptr);
-  float modf(float value, float* iptr);
-  long double modf(long double value, long double* iptr);
-
-  double modf(Integral value, double* iptr);                // C++11 から
-
-  float modff(float value, float* iptr);                    // C++17 から
-  long double modfl(long double value, long double* iptr);  // C++17 から
+  float
+    modf(float value, float* iptr);     // (1) C++03からC++20まで
+  double
+    modf(double value, double* iptr);   // (2) C++03からC++20まで
+  long double
+    modf(long double value,
+         long double* iptr);            // (3) C++03からC++20まで
+
+  constexpr floating-point-type
+    modf(floating-point-type value,
+         floating-point-type* iptr);    // (4) C++23
+
+  double
+    modf(Integral value, double* iptr); // (5) C++11
+  constexpr double
+    modf(Integral value, double* iptr); // (5) C++23
+
+  float
+    modff(float value, float* iptr);    // (6) C++17
+  constexpr float
+    modff(float value, float* iptr);    // (6) C++23
+
+  long double
+    modfl(long double value,
+          long double* iptr);           // (7) C++17
+  constexpr long double
+    modfl(long double value,
+          long double* iptr);           // (7) C++23
 }
 ```
 * Integral[italic]
@@ -20,6 +40,14 @@ namespace std {
 ## 概要
 浮動小数点数を、整数部と小数部に分解する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数`value`の小数部を符号付きとして返す。また、引数`value`の整数部を`*iptr`に書き込む。
@@ -29,12 +57,13 @@ namespace std {
 
 ## 備考
 - C++11 以降では、処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
-	- `value = ±∞` の場合、戻り値は `±0` となり、`*exp` には `±∞` が設定される。
-	- `value` が NaN の場合、戻り値は NaN となり、`*exp` には NaN が設定される。
-	- 戻り値は正確で、現在の丸め方式には依存しない。
+    - `value = ±∞` の場合、戻り値は `±0` となり、`*exp` には `±∞` が設定される。
+    - `value` が NaN の場合、戻り値は NaN となり、`*exp` には NaN が設定される。
+    - 戻り値は正確で、現在の丸め方式には依存しない。
 
 - C++11 で `value` が整数型のオーバーロードが追加されているが、`iptr` の型によって呼び出されるオーバーロードが一意に決まるため、存在意義は無いものと思われる。  
     （`value` に整数型、`iptr` に `nullptr` を渡した場合のみ当該オーバーロードによって呼び出しが曖昧ではなくなるが、その場合は未定義動作となってしまうため、本オーバーロードの存在はむしろ有害）
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -78,9 +107,9 @@ int main()
 ```
 
 ### 備考
-- 特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
-	- GCC 4.6.1 以上
-- GCC、Clang では、C++11 で追加されたオーバーロードは存在しない。
+- 特定の環境では、早期に `constexpr` 対応されている場合がある：
+    - GCC 4.6.1 以上
+- GCC、Clang では、C++11 で追加された整数型オーバーロードは存在しない。
 
 
 ## 実装例
@@ -143,3 +172,10 @@ namespace std {
 * FE_TOWARDZERO[link ../cfenv/fe_towardzero.md]
 * enable_if[link ../type_traits/enable_if.md]
 * is_integral[link ../type_traits/is_integral.md]
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nextafter -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/nextafter.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/nextafter.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/nextafter.md b/reference/cmath/nextafter.md
index 46184131b..abecec649 100644
--- a/reference/cmath/nextafter.md
+++ b/reference/cmath/nextafter.md
@@ -6,14 +6,40 @@
 
 ```cpp
 namespace std {
-  float nextafter(float x, float y);
-  double nextafter(double x, double y);
-  long double nextafter(long double x, long double y);
-
-  Promoted nextafter(Arithmetic1 x, Arithmetic2 y);
-
-  float nextafterf(float x, float y);                   // C++17 から
-  long double nextafterl(long double x, long double y); // C++17 から
+  float
+    nextafter(float x,
+              float y);               // (1) C++11からC++20まで
+  double
+    nextafter(double x,
+              double y);              // (2) C++11からC++20まで
+  long double
+    nextafter(long double x,
+              long double y);         // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    nextafter(floating-point-type x,
+              floating-point-type y); // (4) C++23
+
+  Promoted
+    nextafter(Arithmetic1 x,
+              Arithmetic2 y);         // (5) C++11
+  constexpr Promoted
+    nextafter(Arithmetic1 x,
+              Arithmetic2 y);         // (5) C++23
+
+  float
+    nextafterf(float x,
+               float y);              // (6) C++17
+  constexpr float
+    nextafterf(float x,
+               float y);              // (6) C++23
+
+  long double
+    nextafterl(long double x,
+               long double y);        // (7) C++17
+  constexpr long double
+    nextafterl(long double x,
+               long double y);        // (7) C++23
 }
 ```
 * Arithmetic1[italic]
@@ -25,6 +51,14 @@ namespace std {
 
 この関数は、パラメータ`x`の値をパラメータ`y`の値の方向に対して、その環境で表現可能な最小の値だけ進める。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 パラメータ`x`の値をパラメータ`x`の方向に、表現可能な最小の値だけ進めた値を返す。
@@ -34,6 +68,10 @@ namespace std {
 進めた結果が無限大、もしくは表現できない場合、値域エラーとなる。
 
 
+## 備考
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -57,7 +95,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -71,3 +109,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>nexttoward -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/nexttoward.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/nexttoward.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/nexttoward.md b/reference/cmath/nexttoward.md
index ac63ae810..2ede9b204 100644
--- a/reference/cmath/nexttoward.md
+++ b/reference/cmath/nexttoward.md
@@ -6,14 +6,40 @@
 
 ```cpp
 namespace std {
-  float nexttoward(float x, long double y);
-  double nexttoward(double x, long double y);
-  long double nexttoward(long double x, long double y);
-
-  Promoted nexttoward(Integral x, long double y);
-
-  float nexttowardf(float x, long double y);             // C++17 から
-  long double nexttowardl(long double x, long double y); // C++17 から
+  float
+    nexttoward(float x,
+               long double y);         // (1) C++11からC++20まで
+  double
+    nexttoward(double x,
+               long double y);         // (2) C++11からC++20まで
+  long double
+    nexttoward(long double x,
+               long double y);         // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    nexttoward(floating-point-type x,
+               floating-point-type y); // (4) C++23
+
+  Promoted
+    nexttoward(Integral x,
+               long double y);         // (5) C++11
+  constexpr Promoted
+    nexttoward(Integral x,
+               floating-point-type y); // (5) C++23
+
+  float
+    nexttowardf(float x,
+                long double y);        // (6) C++17
+  constexpr float
+    nexttowardf(float x,
+                long double y);        // (6) C++23
+
+  long double
+    nexttowardl(long double x,
+                long double y);        // (7) C++17
+  constexpr long double
+    nexttowardl(long double x,
+                long double y);        // (7) C++23
 }
 ```
 * Integral[italic]
@@ -24,7 +50,15 @@ namespace std {
 
 この関数は、パラメータ`x`の値をパラメータ`y`の値の方向に対して、その環境で表現可能な最小の値だけ進める。
 
-この関数はパラメータ`y`の型が`long double`固定であることを除いて、[`std::nextafter()`](nextafter.md)関数と等価である。
+この関数はパラメータ`y`の型が`long double`固定であることを除いて、[`std::nextafter()`](nextafter.md)関数と等価である (C++23以降では精度規定の関数を除いて`y`は`long double`ではなく任意の浮動小数点数型であるため、[`std::nextafter()`](nextafter.md)関数と等価である)。
+
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 算術型に対するオーバーロード (大きい精度にキャストして計算される。整数は`double`で計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
 
 
 ## 戻り値
@@ -35,6 +69,10 @@ namespace std {
 進めた結果が無限大、もしくは表現できない場合、値域エラーとなる。
 
 
+## 備考
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -58,7 +96,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -72,3 +110,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remainder -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/remainder.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/remainder.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/remainder.md b/reference/cmath/remainder.md
index 435d83f58..54d5b3a54 100644
--- a/reference/cmath/remainder.md
+++ b/reference/cmath/remainder.md
@@ -6,14 +6,31 @@
 
 ```cpp
 namespace std {
-  double remainder(double x, double y);
-  float remainder(float x, float y);
-  long double remainder(long double x, long double y);
-
-  Integral remainder(Integral x, Integral y);
-
-  float remainderf(float x, float y);                   // C++17 から
-  long double remainderl(long double x, long double y); // C++17 から
+  float remainder(float x, float y);    // (1) C++11からC++20まで
+  double remainder(double x, double y); // (2) C++11からC++20まで
+  long double remainder(long double x,
+                        long double y); // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    remainder(floating-point-type x,
+              floating-point-type y);   // (4) C++23
+
+  Integral
+    remainder(Integral x, Integral y);  // (5) C++11
+  constexpr Integral
+    remainder(Integral x, Integral y);  // (5) C++23
+
+  float
+    remainderf(float x, float y);       // (6) C++17
+  constexpr float
+    remainderf(float x, float y);       // (6) C++23
+
+  long double
+    remainderl(long double x,
+               long double y);          // (7) C++17
+  constexpr long double
+    remainderl(long double x,
+               long double y);          // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +40,14 @@ namespace std {
 
 整数に対する剰余は`%`演算子で求められるが、浮動小数点数に対しては本関数を使用する必要がある。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 IEC 60559で要求された`x REM y`を計算して返す。
@@ -34,6 +59,7 @@ IEC 60559で要求された`x REM y`を計算して返す。
 - 本関数は、C99 の規格にある `remainder`（より正確には `math.h` ヘッダの `remainder`、`remainderf`、`remainderl` の 3 つ。それぞれ C++ の `double`、`float`、`long double` バージョンに相当）と等価である。
 - IEC 60559で要求された`x REM y`の計算とは以下のようなものであり、全ての実装に適用できる。
     - 「y≠0である場合、剰余r = x REM yは、丸めモードに関係なく数学的な関係r = x - nyによって定義される。ここで、nはx/yの正確な値に最も近い整数である。| n - x/y | = 1/2ならば、nは常に偶数である。したがって、剰余は常に正確である。r = 0の場合、その符号はxの符号とする」
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -81,3 +107,10 @@ remainder(6, 2) = 0
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remquo -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/remquo.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/remquo.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/remquo.md b/reference/cmath/remquo.md
index d7b448b3c..1dd97d8b8 100644
--- a/reference/cmath/remquo.md
+++ b/reference/cmath/remquo.md
@@ -6,14 +6,50 @@
 
 ```cpp
 namespace std {
-  double remquo(double x, double y, int* quo);
-  float remquo(float x, float y, int* quo);
-  long double remquo(long double x, long double y, int* quo);
+  float
+    remquo(float x,
+           float y,
+           int* quo);             // (1) C++11からC++20まで
+  double
+    remquo(double x,
+           double y,
+           int* quo);             // (2) C++11からC++20まで
+  long double
+    remquo(long double x,
+           long double y,
+           int* quo);             // (3) C++11からC++20まで
 
-  Integral remquo(Integral x, Integral y, int* quo);
+  constexpr floating-point-type
+    remquo(floating-point-type x,
+           floating-point-type y,
+           int* quo);             // (4) C++23
 
-  float remquof(float x, float y, int* quo);                   // C++17 から
-  long double remquol(long double x, long double y, int* quo); // C++17 から
+  Integral
+    remquo(Integral x,
+           Integral y,
+           int* quo);             // (5) C++11
+  constexpr Integral
+    remquo(Integral x,
+           Integral y,
+           int* quo);             // (5) C++23
+
+  float
+    remquof(float x,
+            float y,
+            int* quo);            // (6) C++17
+  constexpr float
+    remquof(float x,
+            float y,
+            int* quo);            // (6) C++23
+
+  long double
+    remquol(long double x,
+            long double y,
+            int* quo);            // (7) C++17
+  constexpr long double
+    remquol(long double x,
+            long double y,
+            int* quo);            // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +59,14 @@ namespace std {
 
 この関数は、浮動小数点数に対して除算を行い、除算の結果(商)と、その余り(剰余)を同時に求める。戻り値として剰余が返され、ポインタ引数`quo`に商の値が書き込まれる。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 - [`remainder()`](remainder.md)関数と同じ方法で剰余を求めて、戻り値として返す。
@@ -31,6 +75,10 @@ namespace std {
 `y`がゼロである場合、`quo`が指す値は未規定となる。またその際、定義域エラーを発生させるかゼロを返すかは、実装定義となる。定義域エラーが発生した際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 
 
+## 備考
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
 ## 例
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -80,3 +128,10 @@ remquo(6, 2) = quotient:3 remainder:0
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>round -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/round.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/round.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/round.md b/reference/cmath/round.md
index 7eed527ee..0eb888f83 100644
--- a/reference/cmath/round.md
+++ b/reference/cmath/round.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float round(float x);
-  double round(double x);
-  long double round(long double x);
-
-  double round(Integral x);
-
-  float roundf(float x);             // C++17 から
-  long double roundl(long double x); // C++17 から
+  float round(float x);             // (1) C++11からC++20まで
+  double round(double x);           // (2) C++11からC++20まで
+  long double round(long double x); // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    round(floating-point-type x);   // (4) C++23
+
+  double
+    round(Integral x);              // (5) C++11
+  constexpr double
+    round(Integral x);              // (5) C++23
+
+  float
+    roundf(float x);                // (6) C++17
+  constexpr float
+    roundf(float x);                // (6) C++17
+
+  long double
+    roundl(long double x);          // (7) C++17
+  constexpr long double
+    roundl(long double x);          // (7) C++23
 }
 ```
 * Integral[italic]
@@ -23,6 +36,14 @@ namespace std {
 ここで引数 `x` の四捨五入とは、`x` を最も近い整数に丸めるが、`x` の小数部分が `0.5` の場合には、`x` の符号が正負のいずれであってもゼロから遠い方向に丸めることを指す。  
 具体例は下記の出力例を参照。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` を四捨五入により丸めた整数値
@@ -64,6 +85,7 @@ namespace std {
 
 	ただし、本関数において戻り値が引数 `x` と異なる場合に、上記の実装のように例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -126,3 +148,10 @@ FE_INEXACT = false
 ```
 
 引数と結果が異なる場合に例外 `FE_INEXACT` が発生するか否かは実装によって異なる。
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scalbln -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/scalbln.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/scalbln.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/scalbln.md b/reference/cmath/scalbln.md
new file mode 100644
index 000000000..41caa90a4
--- /dev/null
+++ b/reference/cmath/scalbln.md
@@ -0,0 +1,110 @@
+# scalbln
+* cmath[meta header]
+* std[meta namespace]
+* function[meta id-type]
+* cpp11[meta cpp]
+
+```cpp
+namespace std {
+  float scalbln(float x, long int n);             // (1) C++11からC++20まで
+  double scalbln(double x, long int n);           // (2) C++11からC++20まで
+  long double scalbln(long double x, long int n); // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    scalbln(floating-point-type x, long int n);   // (4) C++23
+
+  double
+    scalbln(Integral x, long int n);              // (5) C++11
+  constexpr double
+    scalbln(Integral x, long int n);              // (5) C++23
+
+  float
+    scalblnf(float x, long int n);                // (6) C++17
+  constexpr float
+    scalblnf(float x, long int n);                // (6) C++23
+
+  long double
+    scalblnl(long double x, long int n);          // (7) C++17
+  constexpr long double
+    scalblnl(long double x, long int n);          // (7) C++23
+}
+```
+* Integral[italic]
+
+## 概要
+[`scalbn()`](scalbn.md)の、乗数として`int`の代わりに`long int`をとるバージョン。
+
+`x` に、浮動小数点数の内部表現の基数 [`FLT_RADIX`](/reference/cfloat/flt_radix.md) の `n` 乗を掛けた値を効率的に（通常は [`FLT_RADIX`](/reference/cfloat/flt_radix.md)&amp;lt;sup&amp;gt;n&amp;lt;/sup&amp;gt; を明示的には計算せずに）計算する。scalbは「scale binary」を意味する。
+
+この関数は、[`FLT_RADIX`](/reference/cfloat/flt_radix.md) が `2` であるシステム上では、[`ldexp()`](ldexp.md) 関数と等価である。
+
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
+
+## 戻り値
+&amp;lt;code&amp;gt;x * [FLT_RADIX](/reference/cfloat/flt_radix.md)&amp;lt;sup&amp;gt;n&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt;
+
+オーバーフローエラー、アンダーフローエラーが発生する可能性がある。
+
+
+## 備考
+- この関数は元々 `scalb()` という名前で提案されていたが、非標準の同名関数が広く実装されていた。そのため、`new` の意味を持つ `n` を関数名の末尾に付けて `scalbn()` 関数として標準ライブラリに定義された。
+- オーバーフローエラー、アンダーフローエラーが発生した場合の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
+- 処理系が IEC 60559 に準拠している場合（[`std::numeric_limits`](../limits/numeric_limits.md)`&amp;lt;T&amp;gt;::`[`is_iec559`](../limits/numeric_limits/is_iec559.md)`() != false`）、以下の規定が追加される。（複号同順）
+	- `x = ±0` の場合、戻り値は `±0` となる。
+	- `n = 0` の場合、戻り値は `x` となる。
+	- `x = ±∞` の場合、戻り値は `±∞` となる。
+	- もしオーバーフローエラーやアンダーフローエラーを起こさなければ、結果は正確で現在の丸め方式には依存しない。
+
+- `scalbln()` 関数は、パラメータ `n` の型が `long int` であることを除いて、`scalbn()` 関数と等価である。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;cmath&amp;gt;
+
+int main()
+{
+  // 3.0 * (FLT_RADIX^4)
+  double result = std::scalbln(3.0, 4);
+  std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::scalbln[color ff0000]
+
+### 出力例
+```
+48
+```
+
+### 備考
+特定の環境では、早期に `constexpr` 対応されている場合がある：
+
+- GCC 4.6.1 以上
+
+
+## バージョン
+### 言語
+- C++11
+
+### 処理系
+- [Clang](/implementation.md#clang): 3.0
+- [GCC](/implementation.md#gcc): 4.3.6
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [WG14 N657 Floating-Point and Complex Arithmetic Enhancements](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n657.ps)
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>scalbn -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/scalbn.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/scalbn.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/scalbn.md b/reference/cmath/scalbn.md
index 893959dc6..8ff816b4f 100644
--- a/reference/cmath/scalbn.md
+++ b/reference/cmath/scalbn.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float scalbn(float x, int n);
-  double scalbn(double x, int n);
-  long double scalbn(long double x, int n);
+  float scalbn(float x, int n);             // (1) C++11からC++20まで
+  double scalbn(double x, int n);           // (2) C++11からC++20まで
+  long double scalbn(long double x, int n); // (3) C++11からC++20まで
 
-  double scalbn(Integral x, int n);
+  constexpr floating-point-type
+    scalbn(floating-point-type x, int n);   // (4) C++23
 
-  float scalbnf(float x, int n);                // C++17 から
-  long double scalbnl(long double x, int n);    // C++17 から
+  double
+    scalbn(Integral x, int n);              // (5) C++11
+  constexpr double
+    scalbn(Integral x, int n);              // (5) C++23
+
+  float
+    scalbnf(float x, int n);                // (6) C++17
+  constexpr float
+    scalbnf(float x, int n);                // (6) C++23
+
+  long double
+    scalbnl(long double x, int n);          // (7) C++17
+  constexpr long double
+    scalbnl(long double x, int n);          // (7) C++23
 
   // 乗数としてlong int型を受け取るバージョン
   float scalbln(float x, long int n);
@@ -33,6 +46,14 @@ namespace std {
 
 この関数は、[`FLT_RADIX`](/reference/cfloat/flt_radix.md) が `2` であるシステム上では、[`ldexp()`](ldexp.md) 関数と等価である。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 &amp;lt;code&amp;gt;x * [FLT_RADIX](/reference/cfloat/flt_radix.md)&amp;lt;sup&amp;gt;n&amp;lt;/sup&amp;gt;&amp;lt;/code&amp;gt;
@@ -50,6 +71,7 @@ namespace std {
 	- もしオーバーフローエラーやアンダーフローエラーを起こさなければ、結果は正確で現在の丸め方式には依存しない。
 
 - `scalbln()` 関数は、パラメータ `n` の型が `long int` であることを除いて、`scalbn()` 関数と等価である。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -72,7 +94,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -112,4 +134,7 @@ namespace std {
 
 ## 参照
 - [WG14 N657 Floating-Point and Complex Arithmetic Enhancements](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n657.ps)
-
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>signbit -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/signbit.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/signbit.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/signbit.md b/reference/cmath/signbit.md
index 6d7ec3a65..9f39e4a2a 100644
--- a/reference/cmath/signbit.md
+++ b/reference/cmath/signbit.md
@@ -6,11 +6,17 @@
 
 ```cpp
 namespace std {
-  bool signbit(float x);
-  bool signbit(double x);
-  bool signbit(long double x);
+  bool signbit(float x);            // (1) C++11からC++20まで
+  bool signbit(double x);           // (2) C++11からC++20まで
+  bool signbit(long double x);      // (3) C++11からC++20まで
 
-  bool signbit(Integral x);
+  constexpr bool
+    signbit(floating-point-type x); // (4) C++23
+
+  bool
+    signbit(Integral x);            // (5) C++11
+  constexpr bool
+    signbit(Integral x);            // (5) C++23
 }
 ```
 * Integral[italic]
@@ -18,6 +24,12 @@ namespace std {
 ## 概要
 数値の符号が負であるか判定する。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+
 
 ## 戻り値
 パラメータ`x`が負数である場合、`true`を返す。そうでない場合、`false`を返す。
@@ -27,7 +39,8 @@ namespace std {
 
 
 ## 備考
-C標準ライブラリでは`signbit`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される。
+- C標準ライブラリでは`signbit`は関数マクロとして定義されるが、C++標準ライブラリでは関数として定義される
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -42,7 +55,7 @@ int main()
 
   assert(!std::signbit(1.0f));
   assert(!std::signbit(0.0f));
-  
+
   constexpr float nan = std::numeric_limits&amp;lt;float&amp;gt;::quiet_NaN();
   assert(!std::signbit(nan));
   assert(std::signbit(-nan));
@@ -55,7 +68,7 @@ int main()
 ```
 
 ### 備考
-特定の環境で `constexpr` 指定されている場合がある。（独自拡張）
+特定の環境では、早期に `constexpr` 対応されている場合がある：
 
 - GCC 4.6.1 以上
 
@@ -69,3 +82,10 @@ int main()
 - [GCC](/implementation.md#gcc): 4.3
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>trunc -- &lt;cmath&gt; : 残りのconstexpr対応 #1067</title>
      <link href="https://cpprefjp.github.io/reference/cmath/trunc.html"/>
      <id>be98598467b9fc65906070c8edfd69ea1f243601:reference/cmath/trunc.md</id>
      <updated>2023-02-16T17:55:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/trunc.md b/reference/cmath/trunc.md
index 69f44cb47..d81a623db 100644
--- a/reference/cmath/trunc.md
+++ b/reference/cmath/trunc.md
@@ -6,14 +6,27 @@
 
 ```cpp
 namespace std {
-  float trunc(float x);
-  double trunc(double x);
-  long double trunc(long double x);
-
-  double trunc(Integral x);
-
-  float truncf(float x);             // C++17 から
-  long double truncl(long double x); // C++17 から
+  float trunc(float x);             // (1) C++11からC++20まで
+  double trunc(double x);           // (2) C++11からC++20まで
+  long double trunc(long double x); // (3) C++11からC++20まで
+
+  constexpr floating-point-type
+    trunc(floating-point-type x);   // (4) C++23
+
+  double
+    trunc(Integral x);              // (5) C++11
+  constexpr double
+    trunc(Integral x);              // (5) C++23
+
+  float
+    truncf(float x);                // (6) C++17
+  constexpr float
+    truncf(float x);                // (6) C++23
+
+  long double
+    truncl(long double x);          // (7) C++17
+  constexpr long double
+    truncl(long double x);          // (7) C++23
 }
 ```
 * Integral[italic]
@@ -22,6 +35,14 @@ namespace std {
 引数 `x` をゼロ方向に丸めた整数値を得る。  
 ゼロ方向への丸めた整数値とは、絶対値が引数 `x` の絶対値以下で、かつ、引数 `x` に最も近い整数値である。
 
+- (1) : `float`に対するオーバーロード
+- (2) : `double`に対するオーバーロード
+- (3) : `long double`に対するオーバーロード
+- (4) : 浮動小数点数型に対するオーバーロード
+- (5) : 整数型に対するオーバーロード (`double`にキャストして計算される)
+- (6) : `float`型規定
+- (7) : `long double`型規定
+
 
 ## 戻り値
 引数 `x` をゼロ方向に丸めた整数値
@@ -37,6 +58,7 @@ namespace std {
 	また、本関数の挙動は、丸めモードが [`FE_TOWARDZERO`](/reference/cfenv/fe_towardzero.md) に設定されている時の [`rint`](rint.md)、あるいは [`nearbyint`](nearbyint.md) のいずれかと等価である。  
 	したがって、本関数において戻り値が引数 `x` と異なる場合に例外 [`FE_INEXACT`](/reference/cfenv/fe_inexact.md) が発生するか否かは実装依存である。  
 	なお、本関数の挙動は、現在の丸めモードには依存しない。
+- C++23では、(1)、(2)、(3)が(4)に統合され、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
 ## 例
@@ -99,3 +121,10 @@ FE_INEXACT = false
 ```
 
 引数と結果が異なる場合に例外 `FE_INEXACT` が発生するか否かは実装によって異なる。
+
+
+## 参照
+- [P0533R9 constexpr for `&amp;lt;cmath&amp;gt;` and `&amp;lt;cstdlib&amp;gt;`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf)
+    - C++23での、一部関数の`constexpr`対応
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+    - C++23で導入された拡張浮動小数点数型への対応として、`float`、`double`、`long double`のオーバーロードを`floating-point-type`のオーバーロードに統合し、拡張浮動小数点数型も扱えるようにした
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : constexpr対応の説明見直し</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>019f15edfc2908d7d6678f7199696635dc2a7e92:reference/cmath.md</id>
      <updated>2023-02-16T15:03:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index e493b5cc3..c16eeaa1a 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -87,7 +87,7 @@
 
 ### &amp;lt;a id=&amp;#34;cpp23&amp;#34; href=&amp;#34;#cpp23&amp;#34;&amp;gt;C++23での差異&amp;lt;/a&amp;gt;
 #### constexpr対応
-C++23では、多くの数学関数が`constexpr`に対応し、定数式内で使用できるようになった。C++23時点では、コンパイラベンダの負担が低い機能を`constexpr`対応した。
+C++23では、多くの数学関数が`constexpr`に対応し、定数式内で使用できるようになった。C++23時点では、コンパイラベンダの負担が少ない機能を`constexpr`対応した。
 
 C++23で`constexpr`対応する関数の条件は以下：
 
@@ -98,6 +98,8 @@ C++23で`constexpr`対応する関数の条件は以下：
 
 [`nearbyint`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
+ただし、コンパイラが先行して`constexpr`非対応の関数も対応している可能性がある。
+
 なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである ([`errno`](cerrno/errno.md)や浮動小数点例外のようなグローバル状態を使用しない)。
 
 #### 拡張浮動小数点数型への対応
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : バージョン差異にページ内リンクをつけた</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>182e098dccc8482b0d0965ebd32f76dd01406bdb:reference/cmath.md</id>
      <updated>2023-02-16T13:21:37+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index 484776a1d..e493b5cc3 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -30,14 +30,14 @@
 ## &amp;lt;a id=&amp;#34;difference-from-c&amp;#34; href=&amp;#34;#difference-from-c&amp;#34;&amp;gt;標準Cライブラリとの差異&amp;lt;/a&amp;gt;
 `&amp;lt;cmath&amp;gt;`は基本的には、標準 C ライブラリの `&amp;lt;math.h&amp;gt;` に準拠しているが、いくつかの変更点がある。
 
-### C++03のC90との差異
+### &amp;lt;a id=&amp;#34;cpp03&amp;#34; href=&amp;#34;#cpp03&amp;#34;&amp;gt;C++03のC90との差異&amp;lt;/a&amp;gt;
 - 各関数は std 名前空間に定義されている。
 - `fabs` と等価の関数 `abs` を追加している。
 - `pow` の第 2 引数が `int` のオーバーロードを追加している。
 - 各関数（上記 2 関数を含む）に対して、引数および戻り値の `double` に対応する箇所が `float` および `long double` になっているオーバーロードバージョンを追加している。
 
 
-### C++11のC99との差異
+### &amp;lt;a id=&amp;#34;cpp11&amp;#34; href=&amp;#34;#cpp11&amp;#34;&amp;gt;C++11のC99との差異&amp;lt;/a&amp;gt;
 - 各関数は std 名前空間に定義されている。
 - `fabs` と等価の関数 `abs` を追加している。
 - 引数に `double` を含む各関数（上記 `abs` を含む）に対して、引数および戻り値の `double` に対応する箇所が `float` と `long double` のオーバーロードバージョンを追加している。  
@@ -85,7 +85,7 @@
     * Promoted[italic]
 
 
-### C++23での差異
+### &amp;lt;a id=&amp;#34;cpp23&amp;#34; href=&amp;#34;#cpp23&amp;#34;&amp;gt;C++23での差異&amp;lt;/a&amp;gt;
 #### constexpr対応
 C++23では、多くの数学関数が`constexpr`に対応し、定数式内で使用できるようになった。C++23時点では、コンパイラベンダの負担が低い機能を`constexpr`対応した。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- Merge pull request #1124 from cpprefjp/refine-algorithm</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>d158adbce888acbace8d1313edfef82eabebf32a:reference/algorithm.md</id>
      <updated>2023-02-16T13:11:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 041e10d61..fb2fcc564 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -4,10 +4,14 @@
 
 全てのアルゴリズムはデータ構造の実装の詳細から切り離されていて、イテレータによってパラメータ化されている。これはアルゴリズムの要件を満たすイテレータを提供しているなら、どのようなデータ構造であっても動作するということを示している。
 
-関数オブジェクトを使用するアルゴリズムでは、`for_each`と`for_each_n`以外、引数として渡されたオブジェクトを書き換えてはならない。
+このヘッダでは、以下の標準ヘッダをインクルードする：
+
+- [`&amp;lt;initializer_list&amp;gt;`](initializer_list.md) (C++11)
+
 
-ここでは、各アルゴリズムのテンプレートパラメータ名を、型の要件を表すために使っている。アルゴリズムを正しく利用するためには、テンプレートパラメータ名に応じたこれらの要件を満たしている必要がある。以下の通りである。
+### テンプレートパラメータ名とイテレータ要件
 
+`&amp;lt;algorithm&amp;gt;`ヘッダでは、各アルゴリズムのテンプレートパラメータ名を、型の要件を表すために使っている。アルゴリズムを正しく利用するためには、テンプレートパラメータ名に応じたこれらの要件を満たしている必要がある。以下の通りである。
 
 | テンプレートパラメータ名 | 要件 |
 |-------------------------------------------------------------------------|------------------------|
@@ -20,8 +24,6 @@
 もし「効果」のセクションで、イテレータの値を書き換えるという旨の文章が書かれている場合、その引数の型は mutable iterator の要件を満たしていなければならないという追加の要件がある。
 もちろん、output iterator は常に書き換え可能であるため、この追加の要件は無意味である。
 
-いくつかのアルゴリズムは `_copy` というサフィックスが付いている。これは `_copy` サフィックスの付いていないアルゴリズムと違い、処理の結果を別のイテレータへ出力するアルゴリズムである。コピーバージョンを含めるかどうかの判断は、通常バージョンの計算量を考慮する。操作を行うコストがコピーのコストを大きく上回る場合、コピーバージョンは含めないようになっている。例えば `sort_copy` は存在しない。なぜなら、ソートのコストは大きいし、そのような場合、ユーザは `copy` してから `sort` するからだ。
-
 テンプレートパラメータ名が `Predicate` となっている場合、`Predicate` の値 `pred` と、引数として渡すイテレータ `i` について以下の要件を満たす必要がある
 
 - `pred(*i)` が `bool` として評価できなければならない。
@@ -32,8 +34,20 @@
 - `binary_pred(*i1, *i2)` が `bool` として評価できなければならない。
 - `binary_pred(*i1, *i2)` 内で `*i1` や `*i2` を書き変えてはならない。
 
-関数オブジェクトを引数に取る `for_each` 以外のアルゴリズムは、その関数オブジェクトを自由にコピーしても構わない。そのため、アルゴリズムの利用者はそのことに注意する必要がある。コピーされてしまうことが問題である場合、`reference_wrapper&amp;lt;T&amp;gt;` や同様の解決手段を使ってオブジェクトの中身をコピーしないようなラッパークラスを使うといった対策を行う必要がある。
+### 要素の書き換え操作
+関数オブジェクトを使用するアルゴリズムでは、`for_each`と`for_each_n`以外、プログラム定義の関数に引数として渡された要素を書き換えてはならない。
+
+### 関数オブジェクトの取り扱い
+関数オブジェクトを引数に取る `for_each`, `for_each_n` 以外のアルゴリズムは、内部処理においてその関数オブジェクトをコピーする可能性がある。
+
+そのため、アルゴリズムの利用者はそのことに注意する必要がある。コピーされてしまうことが問題である場合、`reference_wrapper&amp;lt;T&amp;gt;` や同様の解決手段を使ってオブジェクトの中身をコピーしないようなラッパークラスを使うといった対策を行う必要がある。
+
+### `_copy`サフィックス付きアルゴリズム
+いくつかのアルゴリズムは `_copy` というサフィックスが付いている。これは `_copy` サフィックスの付いていないアルゴリズムと違い、処理の結果を別のイテレータへ出力するアルゴリズムである。
 
+コピーバージョンを含めるかどうかの判断は、通常バージョンの計算量を考慮する。操作を行うコストがコピーのコストを大きく上回る場合、コピーバージョンは含めないようになっている。例えば `sort_copy` は存在しない。なぜなら、ソートのコストは大きいし、そのような場合、ユーザは `copy` してから `sort` するからだ。
+
+### イテレータ操作に関する補足
 アルゴリズムの説明で `+` や `-` を使っているが、random-access iterator 以外のイテレータはそれを定義していない。そういった場合、 `a+n` というのは
 
 ```cpp
@@ -41,21 +55,18 @@ X tmp = a;
 advance(tmp, n);
 return tmp;
 ```
+* advance[link /reference/iterator/advance.md]
 
 を意味する。また、`b-a` は
 
 ```cpp
 return distance(a, b);
 ```
+* distance[link /reference/iterator/distance.md]
 
 を意味する。
 
-このヘッダでは、以下の標準ヘッダをインクルードする：
-
-- [`&amp;lt;initializer_list&amp;gt;`](initializer_list.md) (C++11)
-
-### 射影とRangeサポート
-
+### 射影とRangeサポート（C++20）
 C++20ではアルゴリズム関数の新しいバージョンが`std::ranges`名前空間に追加された。従来の関数と比べて以下の点が異なる：
 
 * テンプレート引数がコンセプトによって制約される
@@ -73,6 +84,8 @@ ranges::sort(v);
 // イテレータ対も渡せる
 ranges::sort(v.begin(), v.end());
 ```
+* sort[link algorithm/sort.md]
+* ranges::sort[link algorithm/ranges_sort.md]
 
 射影は、述語とは別に渡すことができる関数オブジェクトで、特定のメンバだけを対象にアルゴリズムを実行するために用いる。
 
@@ -88,19 +101,23 @@ vector&amp;lt;Person&amp;gt; pv = { … };
 
 sort(pv.begin(), pv.end(), [](auto&amp;amp;&amp;amp; a, auto&amp;amp;&amp;amp; b){ return a.name &amp;lt; b.name; });
 ```
+* sort[link algorithm/sort.md]
 
 これは、述語がメンバの選択と比較という2つの仕事をしてしまっている点でよくない。この責務を分割し、メンバの選択だけを行うようにしたものが射影である。
 
 ```cpp
-// デフォルトの述語({})で、nameでソート
+// デフォルトの述語(ranges::less{})で、nameでソート
 ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 // std::invokeで呼び出されるため、メンバ変数ポインタでもよい
 ranges::sort(pv, {}, &amp;amp;Parson::name);
 ```
+* ranges::sort[link algorithm/ranges_sort.md]
+* ranges::less[link /reference/functional/ranges_less.md]
 * std::invoke[link /reference/functional/invoke.md]
 
 なお、各関数の説明においては、射影の影響は無視していることがある。
 
+
 ## シーケンスを変更しない操作
 
 | 名前 | 説明 | 対応バージョン |
@@ -418,6 +435,7 @@ ranges::sort(pv, {}, &amp;amp;Parson::name);
 | [`ranges::in_found_result`](algorithm/ranges_in_found_result.md)     | イテレータとbool値を格納する型           | C++20          |
 | [`ranges::out_value_result`](algorithm/ranges_out_value_result.md)   | イテレータと値を格納する型               | C++23          |
 
+
 ## 関連項目
 - [`&amp;lt;numeric&amp;gt;`](/reference/numeric.md)
     - 数値計算のアルゴリズム
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cmath -- &lt;cmath&gt; : lerpの説明を補足</title>
      <link href="https://cpprefjp.github.io/reference/cmath.html"/>
      <id>eaf722b020984fde1abdb2b50c1f39d8863ecb1b:reference/cmath.md</id>
      <updated>2023-02-16T13:04:27+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath.md b/reference/cmath.md
index 3ac2fc19f..484776a1d 100644
--- a/reference/cmath.md
+++ b/reference/cmath.md
@@ -98,7 +98,7 @@ C++23で`constexpr`対応する関数の条件は以下：
 
 [`nearbyint`](cmath/nearbyint.md)は2. の条件を満たさないため、C++23では`constexpr`に対応しない。
 
-なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである。
+なお、C++20では[`lerp()`](cmath/lerp.md)のみ`constexpr`に対応している。これはC標準ライブラリからの移植ではなく、C++で標準化された関数だからである ([`errno`](cerrno/errno.md)や浮動小数点例外のようなグローバル状態を使用しない)。
 
 #### 拡張浮動小数点数型への対応
 C++23では[`&amp;lt;stdfloat&amp;gt;`](stdfloat.md.nolink)に拡張浮動小数点数型が追加された。その対応として、以下のような`float`、`double`、`long double`に対するオーバーロードは、
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>