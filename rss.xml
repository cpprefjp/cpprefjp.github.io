<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-12-31T02:21:15.485230</updated>
  <id>9f5bd647-36fd-493d-8352-d117160c7466</id>

  
    <entry>
      <title>adjacent_find -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_adjacent_find.html"/>
      <id>ea1d62c0424efc7db66028efacdf8c9b67fb59d9:reference/algorithm/ranges_adjacent_find.md</id>
      <updated>2021-12-31T11:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_adjacent_find.md b/reference/algorithm/ranges_adjacent_find.md
new file mode 100644
index 000000000..75d6bcd9f
--- /dev/null
+++ b/reference/algorithm/ranges_adjacent_find.md
@@ -0,0 +1,103 @@
+# adjacent_find
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr I adjacent_find(I first, S last, Pred pred = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class Proj = identity, indirect_binary_predicate&amp;lt;projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Pred = ranges::equal_to&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; adjacent_find(R&amp;amp;&amp;amp; r, Pred pred = {}, Proj proj = {});
+}
+```
+
+## 概要
+隣接する要素で条件を満たしている最初の要素を検索する。
+
+
+## 戻り値
+`[first,last)` 内にあるイテレータ i について、`*i == *(i + 1)` もしくは `pred(*i, *(i + 1)) != false` であるような最初のイテレータを返す。
+
+もしそのようなイテレータが見つからなかった場合は `last` を返す。
+
+
+## 計算量
+- (1), (2) : 与えられたシーケンスが空でない場合、正確に [`min`](/reference/algorithm/min.md)`((i - first) + 1, (last - first) - 1)` 回（`i` は `adjacent_find` の戻り値）の比較または述語が適用される
+- (3), (4) : O`(last - first)`の計算量の回数だけ比較または述語が適用される
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 1,4,3,3,1,2,2 };
+
+  // 同じ値が連続している最初の要素を検索する
+  auto it = std::adjacent_find(v.begin(), v.end());
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; std::endl;
+    std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; &amp;#34;*it == *(it+1): &amp;#34; &amp;lt;&amp;lt; (*it == *(it+1)) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* adjacent_find[color ff0000]
+
+### 出力
+```
+found: index==2
+*it == *(it+1): true
+```
+
+## 実装例
+```cpp
+template &amp;lt;class ForwardIterator&amp;gt;
+ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last)
+{
+  if (first == last)
+    return last;
+
+  ForwardIterator next = first;
+  ++next;
+  for ( ; next != last; ++next, ++first)
+    if (*first == *next)
+      return first;
+  return last;
+}
+
+template &amp;lt;class ForwardIterator, class BinaryPredicate&amp;gt;
+ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred)
+{
+  if (first == last)
+    return last;
+
+  ForwardIterator next = first;
+  ++next;
+
+  for ( ; next != last; ++next, ++first)
+    if (pred(*first, *next))
+      return first;
+  return last;
+}
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>equal -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_equal.html"/>
      <id>ea1d62c0424efc7db66028efacdf8c9b67fb59d9:reference/algorithm/ranges_equal.md</id>
      <updated>2021-12-31T11:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_equal.md b/reference/algorithm/ranges_equal.md
new file mode 100644
index 000000000..b69439f59
--- /dev/null
+++ b/reference/algorithm/ranges_equal.md
@@ -0,0 +1,152 @@
+# equal
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr bool equal(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});}
+```
+
+## 概要
+2つの範囲を等値比較する。
+
+- (1) : 範囲`[first1, last1)`と範囲`[first2, first2 + (last1 - first1))`が等値かを判定する
+- (2) : (1)の等値比較を任意の2引数関数オブジェクトで行う
+- (3) : 範囲`[first1, last1)`と範囲`[first2, last2)`が等値かを判定する
+- (4) : (3)の等値比較を任意の2引数関数オブジェクトで行う
+
+2つの範囲が異なる要素数であった場合、`false`を返す。
+
+2つの範囲が要素数および各要素が等値であった場合、`true`を返す。
+
+
+## 戻り値
+`last2` が与えられている形式の場合、もし `last1 - first1 != last2 - first2` であれば、`false` を返す。  
+そうでない場合、`[first1,last1)` 内のイテレータ `i` について、`*i == *(first2 + (i - first1))` もしくは `pred(*i, *(first2 + (i - first1))) != false` が全てのイテレータ `i` について満たされているのであれば `true` を返す。  
+そうでない場合は `false` を返す。
+
+
+## 計算量
+`last2` が与えられていない形式では、`last2 = first2 + (last1 - first1)`であるとして説明する。
+
+- (1), (2), (3), (4) : `InputIterator1` と `InputIterator2` が共にランダムアクセスイテレータの要件を満たす場合で、かつ、`last1 - first1 != last2 - first2` の場合、1 度も比較または述語は適用されない。そうでない場合、最大で `min(last1 - first1, last2 - first2)` 回の比較または述語が適用される。
+- (5), (6), (7), (8) : `ForwardIterator1` と `ForwardIterator2` が共にランダムアクセスイテレータの要件を満たす場合で、かつ、`last1 - first1 != last2 - first2` の場合、1 度も比較または述語は適用されない。そうでない場合、O(`min(last1 - first1, last2 - first2)`) の計算量で比較または述語が適用される。
+
+
+## 備考
+- ランダムアクセスイテレータの範囲を使用する場合、状況によっては(1) (2)のバージョンよりも、(3) (4)を使用する方が効率がよくなることが期待できる。ランダムアクセスイテレータはイテレータ同士の差を定数時間で求められるため、イテレーションを行うことなく2つの範囲の要素数が異なることを検出できるためである
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt;   v  = { 1,2,3,4,3,2 };
+  std::array&amp;lt;int, 6&amp;gt; v2 = { 1,2,3,4,2,1 };
+
+  // コンテナの中身が同じかどうか調べる
+  bool result = std::equal(std::begin(v), std::end(v), std::begin(v2), std::end(v2));
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
+
+  // x±1 の誤差を許すようにする
+  bool result2 = std::equal(std::begin(v), std::end(v), std::begin(v2), std::end(v2),
+                            [](int x, int y) { return x - 1 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt;= x + 1; });
+  std::cout &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; result2 &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::equal[color ff0000]
+
+### 出力
+```
+false
+true
+```
+
+
+## 実装例
+```cpp
+template&amp;lt;class InputIterator1, class InputIterator2&amp;gt;
+bool equal(InputIterator1 first1, InputIterator1 last1,
+           InputIterator2 first2) {
+  for ( ; first1 != last1; ++first1, ++first2)
+    if (!bool(*first1 == *first2))
+      return false;
+  return true;
+}
+
+template&amp;lt;class InputIterator1, class InputIterator2, class BinaryPredicate&amp;gt;
+bool equal(InputIterator1 first1, InputIterator1 last1,
+           InputIterator2 first2, BinaryPredicate pred) {
+  for ( ; first1 != last1; ++first1, ++first2)
+    if (!bool(pred(*first1, *first2)))
+      return false;
+  return true;
+}
+
+# if __cplusplus &amp;gt;= 201402L
+
+template&amp;lt;class RandomAccessIterator1, class RandomAccessIterator2, class BinaryPredicate&amp;gt;
+inline bool equal_impl(RandomAccessIterator1 first1, RandomAccessIterator1 last1,
+                       RandomAccessIterator2 first2, RandomAccessIterator2 last2,
+                       BinaryPredicate pred,
+                       random_access_iterator_tag, random_access_iterator_tag) {
+  if (last1 - first1 != last2 - first2)
+    return false;
+  return std::equal(first1, last1, first2, pred);
+}
+
+template&amp;lt;class InputIterator1, class InputIterator2, class BinaryPredicate&amp;gt;
+bool equal_impl(InputIterator1 first1, InputIterator1 last1,
+                InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred,
+                input_iterator_tag, input_iterator_tag) {
+  for ( ; first1 != last1 &amp;amp;&amp;amp; first2 != last2; ++first1, ++first2)
+    if (!bool(pred(*first1, *first2)))
+      return false;
+  return first1 == last1 &amp;amp;&amp;amp; first2 == last2;
+}
+
+template&amp;lt;class InputIterator1, class InputIterator2, class BinaryPredicate&amp;gt;
+inline bool equal(InputIterator1 first1, InputIterator1 last1,
+                  InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred) {
+  return equal_impl(first1, last1, first2, last2, pred,
+                    typename iterator_traits&amp;lt;InputIterator1&amp;gt;::iterator_category(),
+                    typename iterator_traits&amp;lt;InputIterator2&amp;gt;::iterator_category());
+}
+
+template&amp;lt;class InputIterator1, class InputIterator2&amp;gt;
+inline bool equal(InputIterator1 first1, InputIterator1 last1,
+                  InputIterator2 first2, InputIterator2 last2) {
+  return std::equal(first1, last1, first2, last2, equal_to&amp;lt;&amp;gt;());
+}
+
+# endif
+```
+* ranges::equal_to[link ../functional/ranges_equal_to.md]
+* iterator_traits[link ../iterator/iterator_traits.md]
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>ea1d62c0424efc7db66028efacdf8c9b67fb59d9:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2021-12-31T11:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index 328bf343a..3c3f0c838 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -75,7 +75,7 @@ found: index==3, value==4
 struct find_first_of_impl {
   template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr I1 operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
     for ( ; first1 != last1; ++first1)
       for (I2 it = first2; it != last2; ++it)
         if (invoke(pred, invoke(proj1, *first1), invoke(proj2, *it))) return first1;
@@ -84,7 +84,7 @@ struct find_first_of_impl {
 
   template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; find_first_of(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if.html"/>
      <id>ea1d62c0424efc7db66028efacdf8c9b67fb59d9:reference/algorithm/ranges_find_if.md</id>
      <updated>2021-12-31T11:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if.md b/reference/algorithm/ranges_find_if.md
index 152fce3e4..d66779145 100644
--- a/reference/algorithm/ranges_find_if.md
+++ b/reference/algorithm/ranges_find_if.md
@@ -63,7 +63,7 @@ found: 1
 ```cpp
 struct find_if_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I perator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) {
     for ( ; first != last; ++first)
       if (invoke(pred, invoke(proj, *first)))
         return first;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_if_not -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_if_not.html"/>
      <id>ea1d62c0424efc7db66028efacdf8c9b67fb59d9:reference/algorithm/ranges_find_if_not.md</id>
      <updated>2021-12-31T11:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_if_not.md b/reference/algorithm/ranges_find_if_not.md
index 32d9b47ea..5b3b75fd3 100644
--- a/reference/algorithm/ranges_find_if_not.md
+++ b/reference/algorithm/ranges_find_if_not.md
@@ -63,7 +63,7 @@ found: 1
 ```cpp
 struct find_if_not_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class Proj = identity, indirect_unary_predicate&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Pred&amp;gt;
-  constexpr I perator()(I first, S last, Pred pred, Proj proj = {}) {
+  constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) {
     for ( ; first != last; ++first)
       if (!invoke(pred, invoke(proj, *first)))
         return first;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>for_each_n -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_for_each_n.html"/>
      <id>ea1d62c0424efc7db66028efacdf8c9b67fb59d9:reference/algorithm/ranges_for_each_n.md</id>
      <updated>2021-12-31T11:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_for_each_n.md b/reference/algorithm/ranges_for_each_n.md
index 83b3c0cd7..5b0c2b90a 100644
--- a/reference/algorithm/ranges_for_each_n.md
+++ b/reference/algorithm/ranges_for_each_n.md
@@ -91,7 +91,7 @@ int main()
 struct for_each_n_impl {
   template&amp;lt;input_iterator I, class Proj = identity, indirectly_unary_invocable&amp;lt;projected&amp;lt;I, Proj&amp;gt;&amp;gt; Fun&amp;gt;
     requires copy_constructible&amp;lt;Fun&amp;gt;
-  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; for_each_n(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {}) {
+  constexpr for_each_n_result&amp;lt;I, Fun&amp;gt; operator()(I first, iter_difference_t&amp;lt;I&amp;gt; n, Fun f, Proj proj = {}) {
     for (iter_difference_t&amp;lt;I&amp;gt; i = 0; i &amp;lt; n; ++i) {
       invoke(f, invoke(proj, *first));
       ++first;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mismatch -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_mismatch.html"/>
      <id>ea1d62c0424efc7db66028efacdf8c9b67fb59d9:reference/algorithm/ranges_mismatch.md</id>
      <updated>2021-12-31T11:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_mismatch.md b/reference/algorithm/ranges_mismatch.md
new file mode 100644
index 000000000..a87cd7439
--- /dev/null
+++ b/reference/algorithm/ranges_mismatch.md
@@ -0,0 +1,123 @@
+# mismatch
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, input_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr ranges::mismatch_result&amp;lt;I1, I2&amp;gt; mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  template&amp;lt;input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr mismatch_result&amp;lt;borrowed_iterator_t&amp;lt;R1&amp;gt;, borrowed_iterator_t&amp;lt;R2&amp;gt;&amp;gt; mismatch(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+}
+```
+* pair[link /reference/utility/pair.md]
+
+
+## 概要
+2つのシーケンスが一致していない場所を検索する。
+
+
+## 戻り値
+`last2`が渡されなかった場合は、`last2 = first2 + (last1 - first1)`とする。
+
+`[first1,last1)` 内にあるイテレータ `i` と、`j == first2 + (i - first1)` であるイテレータ `j` について、
+
+- `j`が範囲`[first2, last2)`に含まれており、
+- `!(*i == *j)` もしくは
+- `pred(*i, *j) == false` であるような、最初のイテレータのペアを返す。
+
+そのようなイテレータが見つからなかった場合は `last1` と `first2 + (last1 - first1)` のペアを返す。
+
+
+## 計算量
+最大で `last1 - first1` 回の対応する比較もしくは述語が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;array&amp;gt;
+#include &amp;lt;list&amp;gt;
+#include &amp;lt;iterator&amp;gt; // for begin, end
+#include &amp;lt;string&amp;gt;   // for to_string
+
+// mismatch の結果で得られた pair に対する情報を出力する
+template &amp;lt;class Range1, class Range2, class Pair&amp;gt;
+void print_mismatch_value(const Range1&amp;amp; r1, const Range2&amp;amp; r2, const Pair&amp;amp; p) {
+  std::cout &amp;lt;&amp;lt; &amp;#34;mismatch index: &amp;#34; &amp;lt;&amp;lt; std::distance(std::begin(r1), p.first) &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;mismatch value: (&amp;#34; &amp;lt;&amp;lt; (std::end(r1) == p.first  ? &amp;#34;end&amp;#34; : std::to_string(*p.first)) &amp;lt;&amp;lt; &amp;#34;,&amp;#34;
+                                   &amp;lt;&amp;lt; (std::end(r2) == p.second ? &amp;#34;end&amp;#34; : std::to_string(*p.second)) &amp;lt;&amp;lt; &amp;#34;)&amp;#34;
+            &amp;lt;&amp;lt; std::endl;
+}
+
+int main() {
+  const std::vector&amp;lt;int&amp;gt;   v  = { 1,2,3,4,3,2 };
+  const std::array&amp;lt;int, 6&amp;gt; v2 = { 1,2,4,3,2,1 };
+  const std::list&amp;lt;int&amp;gt;     v3 = { 1,2,3,4,3, };
+
+  // v と v2 で異なる場所を探す
+  auto pair = std::mismatch(v.begin(), v.end(), v2.begin());
+  print_mismatch_value(v, v2, pair);
+
+  std::cout &amp;lt;&amp;lt; std::endl;
+
+  // v と v3 で異なる場所を探す。
+  // v.size() &amp;gt; v3.size() なので mismatch(v.begin(), v.end(), v3.begin()) とやってはいけない。
+  auto pair2 = std::mismatch(v3.begin(), v3.end(), v.begin());
+  print_mismatch_value(v3, v, pair2);
+}
+```
+* std::mismatch[color ff0000]
+* std::to_string[link /reference/string/to_string.md]
+
+### 出力
+```
+mismatch index: 2
+mismatch value: (3,4)
+
+mismatch index: 5
+mismatch value: (end,2)
+```
+
+
+## 実装例
+```cpp
+template &amp;lt;class InputIterator1, class InputIterator2&amp;gt;
+std::pair&amp;lt;InputIterator1, InputIterator2&amp;gt; mismatch(
+  InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) {
+  for ( ; first1 != last1; ++first1, ++first2)
+    if (!bool(*first1 == *first2))
+      return std::make_pair(first1, first2);
+  return std::make_pair(first1, first2);
+}
+
+template &amp;lt;class InputIterator1, class InputIterator2, class BinaryPredicate&amp;gt;
+std::pair&amp;lt;InputIterator1, InputIterator2&amp;gt; mismatch(
+  InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred) {
+  for ( ; first1 != last1; ++first1, ++first2)
+    if (!bool(pred(*first1, *first2)))
+      return std::make_pair(first1, first2);
+  return std::make_pair(first1, first2);
+}
+```
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- 実装例を修正 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>ea1d62c0424efc7db66028efacdf8c9b67fb59d9:reference/algorithm/ranges_search.md</id>
      <updated>2021-12-31T11:15:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
index 28e53d54d..05d51acd9 100644
--- a/reference/algorithm/ranges_search.md
+++ b/reference/algorithm/ranges_search.md
@@ -74,7 +74,7 @@ struct search_impl {
   template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
   sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
-  constexpr subrange&amp;lt;I1&amp;gt; search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
     for ( ; first1 != last1; ++first1) {
       I1 p1 = first1;
       I2 p2 = first2;
@@ -89,7 +89,7 @@ struct search_impl {
 
   template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
     requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
-  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; search(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
     return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
   }
 };
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>5da27f22d32b364123e51bf1fd0cec0a7a5e75a8:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2021-12-30T21:59:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
index f6f9f3a71..328bf343a 100644
--- a/reference/algorithm/ranges_find_first_of.md
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -18,7 +18,7 @@ namespace std::ranges {
 - input_iterator[link /reference/iterator/input_iterator.md]
 - forward_iterator[link /reference/iterator/forward_iterator.md]
 - sentinel_for[link /reference/iterator/sentinel_for.md]
-- ranges::equal_to[link /reference/algorithm/ranges_equal_to.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 - borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 - iterator_t[link /reference/ranges/iterator_t.md]
 - identity[link /reference/functional/identity.md]
@@ -94,7 +94,7 @@ inline constexpr find_first_of_impl find_first_of;
 - input_iterator[link /reference/iterator/input_iterator.md]
 - forward_iterator[link /reference/iterator/forward_iterator.md]
 - sentinel_for[link /reference/iterator/sentinel_for.md]
-- ranges::equal_to[link /reference/algorithm/ranges_equal_to.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 - borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 - iterator_t[link /reference/ranges/iterator_t.md]
 - identity[link /reference/functional/identity.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>algorithm -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm.html"/>
      <id>4554454e93486c8b5d97d4a897b86861a6067bbe:reference/algorithm.md</id>
      <updated>2021-12-30T16:17:42+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm.md b/reference/algorithm.md
index 0c66010e4..e587845e4 100644
--- a/reference/algorithm.md
+++ b/reference/algorithm.md
@@ -127,15 +127,15 @@ ranges::sort(pv, {}, [](auto&amp;amp;&amp;amp; a){ return a.name; });
 | [`ranges::find`](algorithm/ranges_find.md)                   | 指定された値を検索する                               | C++20 |
 | [`ranges::find_if`](algorithm/ranges_find_if.md)             | 条件を満たす最初の要素を検索する                     | C++20 |
 | [`ranges::find_if_not`](algorithm/ranges_find_if_not.md)     | 条件を満たしていない最初の要素を検索する             | C++20 |
-| [`ranges::find_end`](algorithm/ranges_find_end.md.nolink)           | 指定された最後のサブシーケンスを検索する             | C++20 |
-| [`ranges::find_first_of`](algorithm/ra.nolinknges_find_first_of.md.nolink) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
+| [`ranges::find_end`](algorithm/ranges_find_end.md)           | 指定された最後のサブシーケンスを検索する             | C++20 |
+| [`ranges::find_first_of`](algorithm/ranges_find_first_of.md) | ある集合の1つとマッチする最初の要素を検索する        | C++20 |
 | [`ranges::adjacent_find`](algorithm/ra.nolinknges_adjacent_find.md.nolink) | 隣接する要素で条件を満たしている最初の要素を検索する | C++20 |
 | [`ranges::count`](algorithm/ranges_count.md)                 | 指定された値である要素の数を数える                   | C++20 |
 | [`ranges::count_if`](algorithm/ranges_count_if.md)           | 条件を満たしている要素の数を数える                   | C++20 |
 | [`ranges::mismatch`](algorithm/ranges_mismatch.md.nolink)           | 2つの範囲が一致していない場所を検索する              | C++20 |
 | [`ranges::equal`](algorithm/ranges_equal.md.nolink)                 | 2つの範囲を等値比較する                              | C++20 |
-| [`ranges::search`](algorithm/ranges_search.md.nolink)               | 指定された最初のサブシーケンスを検索する             | C++20 |
-| [`ranges::search_n`](algorithm/ranges_search_n.md.nolink)           | 指定された最初のサブシーケンスを検索する             | C++20 |
+| [`ranges::search`](algorithm/ranges_search.md)               | 指定された最初のサブシーケンスを検索する             | C++20 |
+| [`ranges::search_n`](algorithm/ranges_search_n.md)           | 指定された最初のサブシーケンスを検索する             | C++20 |
 | [`ranges::starts_with`](algorithm/ranges_starts_with.md.nolink)     | 先頭が指定されたシーケンスと一致するかを調べる       | C++23 |
 | [`ranges::ends_with`](algorithm/ranges_ends_with.md.nolink)         | 末尾が指定されたシーケンスと一致するかを調べる       | C++23 |
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_end -- ranges::find_first_of/find_end/search/search_nを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_end.html"/>
      <id>1dc74c36e9f05e3f39d7f20f1ee1fd78014bdd1d:reference/algorithm/ranges_find_end.md</id>
      <updated>2021-12-30T15:58:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_end.md b/reference/algorithm/ranges_find_end.md
new file mode 100644
index 000000000..ec3bc16d8
--- /dev/null
+++ b/reference/algorithm/ranges_find_end.md
@@ -0,0 +1,106 @@
+# find_end
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt; find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; find_end(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+}
+```
+
+## 概要
+範囲の中から、特定のサブシーケンスを検索する。
+
+
+## 戻り値
+- (1): `[first1,last1 - (last2 - first2))` 内のイテレータ `i` があるとき、0 以上 `last2 - first2` 未満の全ての整数 `n` について、それぞれ `*(i + n) == *(first2 + n)` もしくは `invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n)))) != false` であるようなサブシーケンスを探し、見つかった **最後の** サブシーケンス`{i, i + (i == last1 ? 0 : last2 - first2)}`を返す。そのようなイテレータが見つからない、もしくは `[first2,last2)` が空である場合は `{last1, last1}` を返す。
+- (2): `first1 = begin(r1)`, `last1 = end(r1)`, `first2 = begin(r2)`, `last2 = end(r2)`の下で(1)と等しい。
+
+## 計算量
+最大で `(last2 - first2) * (last1 - first1 - (last2 - first2) + 1)` 回の、対応する比較もしくは述語が適用される
+
+
+## 備考
+[`ranges::search()`](ranges_search.md) と `ranges::find_end()` は共にサブシーケンスを検索する関数だが、以下の点が異なる。
+
+* `ranges::search()` は見つかった最初のサブシーケンスを返すが `ranges::find_end()` は見つかった最後のサブシーケンスを返す
+* `[first2,last2)` が空であるときに `search()` は `{first1, first1}` を返すが、`ranges::find_end()` は `{last1, last1}` を返す
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;list&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 1,2,1,2,3 };
+  std::list&amp;lt;int&amp;gt; ls = { 1,2 };
+
+  // 1,2 と連続している最後のシーケンスを探す
+  subrange it = std::ranges::find_end(v, ls);
+  // v[2] の位置を指すイテレータが見つかる。
+  // v[0] の位置を指すイテレータではない。
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_end[color ff0000]
+
+### 出力
+```
+found: index==2
+```
+
+
+## 実装例
+```cpp
+struct find_end_impl {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt; operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    if (first2 == last2)
+      return last1;
+    I1 result = last1;
+    while ((first1 = search(first1, last1, first2, last2, ref(pred), ref(proj1), ref(proj2))) != last1) {
+      result = first1;
+      ++first1;
+    }
+    return result;
+  }
+
+  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; operator()(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
+
+inline constexpr find_end_impl find_end;
+```
+* search[link ranges_search.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- ranges::find_first_of/find_end/search/search_nを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find_first_of.html"/>
      <id>1dc74c36e9f05e3f39d7f20f1ee1fd78014bdd1d:reference/algorithm/ranges_find_first_of.md</id>
      <updated>2021-12-30T15:58:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find_first_of.md b/reference/algorithm/ranges_find_first_of.md
new file mode 100644
index 000000000..f6f9f3a71
--- /dev/null
+++ b/reference/algorithm/ranges_find_first_of.md
@@ -0,0 +1,121 @@
+# find_first_of
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+
+  template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; find_first_of(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+}
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/algorithm/ranges_equal_to.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- input_range[link /reference/ranges/input_range.md]
+- forward_range[link /reference/ranges/forward_range.md]
+
+## 概要
+ある集合の1つとマッチする最初の要素を検索する。
+
+
+## 戻り値
+`[first1,last1 - (last2 - first2))` 内のイテレータ `i` があるとき、`[first2,last2)` 内のイテレータ `j` について、どれかが [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj1, *i), `[`invoke`](/reference/functional/invoke.md)`(proj2, *j)) == true` であるような最初のイテレータを返す。
+
+そのようなイテレータが見つからない、もしくは `[first2,last2)` が空である場合は `last1` を返す。
+
+
+## 計算量
+最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;list&amp;gt;
+
+int main() {
+  std::vector v = { 1,3,7,4,2 };
+  std::list ls = { 2,4,6,8 };
+
+  // 2,4,6,8 のどれかと一致する最初の要素を返す
+  auto it = std::ranges::find_first_of(v, ls.begin(), ls.end());
+  if (it == v.end()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), it) &amp;lt;&amp;lt; &amp;#34;, value==&amp;#34; &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::ranges::find_first_of[color ff0000]
+* ls.begin()[link /reference/list/list/begin.md]
+* ls.end()[link /reference/list/list/end.md]
+
+### 出力
+```
+found: index==3, value==4
+```
+
+
+## 実装例
+```cpp
+struct find_first_of_impl {
+  template&amp;lt;input_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2, sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    for ( ; first1 != last1; ++first1)
+      for (I2 it = first2; it != last2; ++it)
+        if (invoke(pred, invoke(proj1, *first1), invoke(proj2, *it))) return first1;
+    return last1;
+  }
+
+  template&amp;lt;input_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R1&amp;gt; find_first_of(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
+
+inline constexpr find_first_of_impl find_first_of;
+```
+- input_iterator[link /reference/iterator/input_iterator.md]
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/algorithm/ranges_equal_to.md]
+- borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- input_range[link /reference/ranges/input_range.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search -- ranges::find_first_of/find_end/search/search_nを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search.html"/>
      <id>1dc74c36e9f05e3f39d7f20f1ee1fd78014bdd1d:reference/algorithm/ranges_search.md</id>
      <updated>2021-12-30T15:58:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search.md b/reference/algorithm/ranges_search.md
new file mode 100644
index 000000000..28e53d54d
--- /dev/null
+++ b/reference/algorithm/ranges_search.md
@@ -0,0 +1,124 @@
+# search
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
+  sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt; search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // (1)
+
+  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; search(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});              // (2)
+}
+```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- subrange[link /reference/ranges/subrange.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+## 概要
+あるシーケンスの中から、特定のサブシーケンスを探す
+
+## 戻り値
+- (1) :
+    - `[first1,last1 - (last2 - first2))` 内のイテレータ `i` があるとき、0 以上 `last2 - first2` 未満の整数 `n` について、それぞれ [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj1, *(i + n)), `[`invoke`](/reference/functional/invoke.md)`(proj2, *(first2 + n)))` であるようなサブシーケンスを探し、見つかった最初のサブシーケンスを返す。
+    - そのようなイテレータが見つからない場合は `{last1, last1}` を返し、`[first2,last2)` が空である場合には `{first1, first1}` を返す。
+- (2): `first1 = begin(r1)`, `last1 = end(r1)`, `first2 = begin(r2)`, `last2 = end(r2)`の下で(1)と等しい。
+
+## 計算量
+最大で `(last1 - first1) * (last2 - first2)` 回の、対応する比較もしくは述語が適用される
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+#include &amp;lt;list&amp;gt;
+#include &amp;lt;ranges&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 1,2,1,2,3 };
+  std::list&amp;lt;int&amp;gt; ls = { 1,2 };
+
+  // 1,2 と連続している最初のシーケンスを探す
+  std::ranges::subrange sr = std::ranges::search(v, ls);
+  // v[0] の位置を指すイテレータが見つかる。
+  if (sr.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::search[color ff0000]
+
+#### 出力
+```
+found: index==0
+```
+
+
+## 実装例
+```cpp
+struct search_impl {
+  template&amp;lt;forward_iterator I1, sentinel_for&amp;lt;I1&amp;gt; S1, forward_iterator I2,
+  sentinel_for&amp;lt;I2&amp;gt; S2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I1, I2, Pred, Proj1, Proj2&amp;gt;
+  constexpr subrange&amp;lt;I1&amp;gt; search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    for ( ; first1 != last1; ++first1) {
+      I1 p1 = first1;
+      I2 p2 = first2;
+      while (true) {
+        if (p2 == last2) return {first1, p1};
+        if (p1 == last1) return {last1, last1};
+        if (!invoke(pred, invoke(proj1, *p1), invoke(proj2, *p2))) break;
+        ++p1, ++p2;
+      }
+    }
+  }
+
+  template&amp;lt;forward_range R1, forward_range R2, class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R1&amp;gt;, iterator_t&amp;lt;R2&amp;gt;, Pred, Proj1, Proj2&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R1&amp;gt; search(R1&amp;amp;&amp;amp; r1, R2&amp;amp;&amp;amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) {
+    return (*this)(begin(r1), end(r1), begin(r2), end(r2), ref(pred), ref(proj1), ref(proj2));
+  }
+};
+
+inline constexpr search_impl search;
+```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- subrange[link /reference/ranges/subrange.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>search_n -- ranges::find_first_of/find_end/search/search_nを追加 #919</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_search_n.html"/>
      <id>1dc74c36e9f05e3f39d7f20f1ee1fd78014bdd1d:reference/algorithm/ranges_search_n.md</id>
      <updated>2021-12-30T15:58:31+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_search_n.md b/reference/algorithm/ranges_search_n.md
new file mode 100644
index 000000000..72dd0b3e6
--- /dev/null
+++ b/reference/algorithm/ranges_search_n.md
@@ -0,0 +1,144 @@
+# search_n
+* algorithm[meta header]
+* std::ranges[meta namespace]
+* function template[meta id-type]
+* cpp20[meta cpp]
+
+```cpp
+namespace std::ranges {]
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I, const T*, Pred, Proj&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; search_n(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {});
+
+  template&amp;lt;forward_range R, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T*, Pred, Proj&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; search_n(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {});
+}
+```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- iter_difference_t[link /reference/iterator/iter_difference_t.md]
+- subrange[link /reference/ranges/subrange.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+
+
+## 概要
+あるシーケンスの中から、指定の要素が連続するサブシーケンスを探す。
+
+## 戻り値
+`[first,last-count)` 内のイテレータ `i` があるとき、0 以上 `count` 未満の整数 `n` について、それぞれ [`invoke`](/reference/functional/invoke.md)`(pred, `[`invoke`](/reference/functional/invoke.md)`(proj, *(i + n)), value)` であるようなサブシーケンスを探し、見つかった最初のサブシーケンスを返す。
+
+そのようなイテレータが見つからない場合は `{last, last}` を返す。
+
+
+## 計算量
+最大で `last - first` 回の対応する比較もしくは述語が適用される。
+
+
+## 例
+```cpp example
+#include &amp;lt;algorithm&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+int main() {
+  std::vector&amp;lt;int&amp;gt; v = { 1,2,3,2,1,3,3,2,3,3,1 };
+
+  // 3 が 2 つ連続している最初のシーケンスを探す
+  std::ranges::subrange sr1 = std::ranges::search_n(v, 2, 3);
+  // v[5] の位置を指すイテレータが見つかる。
+  if (sr1.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr1.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+
+  // 3 未満が 2 つ連続している最初のシーケンスを探す
+  auto sr2 = std::ranges::search_n(v, 2, 3, [](int x, int y) { return x &amp;lt; y; });
+  // v[0] の位置を指すイテレータが見つかる。
+  if (sr2.empty()) {
+    std::cout &amp;lt;&amp;lt; &amp;#34;not found&amp;#34; &amp;lt;&amp;lt; std::endl;
+  } else {
+    std::cout &amp;lt;&amp;lt; &amp;#34;found: index==&amp;#34; &amp;lt;&amp;lt; std::distance(v.begin(), sr2.begin()) &amp;lt;&amp;lt; std::endl;
+  }
+}
+```
+* std::search_n[color ff0000]
+* v.begin()[link /reference/vector/vector/begin.md]
+
+### 出力
+```
+found: index==5
+found: index==0
+```
+
+
+## 実装例
+```cpp
+struct search_n_impl {
+  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;I, const T*, Pred, Proj&amp;gt;
+  constexpr subrange&amp;lt;I&amp;gt; operator()(I first, S last, iter_difference_t&amp;lt;I&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) {
+    if (first == last || count &amp;lt;= 0)
+      return first;
+
+    while (first != last) {
+      if (*first == value) {
+        I it = first;
+        ++it;
+        iter_difference_t&amp;lt;I&amp;gt; i = 1;
+        for (; i &amp;lt; count &amp;amp;&amp;amp; it != last &amp;amp;&amp;amp; invoke(pred, invoke(proj, *it), value); ++i, ++it)
+          ;
+        if (i == count)
+          return {first, i};
+        else if (it == last)
+          return {last, last};
+        else
+          first = it;
+      }
+      ++first;
+    }
+  }
+
+  template&amp;lt;forward_range R, class T, class Pred = ranges::equal_to, class Proj = identity&amp;gt;
+    requires indirectly_comparable&amp;lt;iterator_t&amp;lt;R&amp;gt;, const T*, Pred, Proj&amp;gt;
+  constexpr borrowed_subrange_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, range_difference_t&amp;lt;R&amp;gt; count, const T&amp;amp; value, Pred pred = {}, Proj proj = {}) {
+    return (*this)(begin(r1), end(r1), count, value, ref(pred), ref(proj));
+  }
+};
+
+inline constexpr search_n_impl search_n;
+```
+- forward_iterator[link /reference/iterator/forward_iterator.md]
+- sentinel_for[link /reference/iterator/sentinel_for.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
+- identity[link /reference/functional/identity.md]
+- indirectly_comparable[link /reference/iterator/indirectly_comparable.md]
+- iter_difference_t[link /reference/iterator/iter_difference_t.md]
+- subrange[link /reference/ranges/subrange.md]
+- forward_range[link /reference/ranges/forward_range.md]
+- iterator_t[link /reference/ranges/iterator_t.md]
+- borrowed_subrange_t[link /reference/ranges/borrowed_subrange_t.md]
+- invoke[link /reference/functional/invoke.md]
+- begin[link /reference/ranges/begin.md]
+- end[link /reference/ranges/end.md]
+- ref[link /reference/functional/ref.md]
+
+
+## バージョン
+### 言語
+- C++20
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 10.1.0
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): 2019 Update 10
+
+## 参照
+- [N4821 25 Algorithms library](https://timsong-cpp.github.io/cppwp/n4861/algorithms)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count.html"/>
      <id>b792f48b9cc19c4cbe9725fc0f83c34ca795c424:reference/algorithm/ranges_count.md</id>
      <updated>2021-12-30T13:58:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count.md b/reference/algorithm/ranges_count.md
index b0ff3b076..051f737c4 100644
--- a/reference/algorithm/ranges_count.md
+++ b/reference/algorithm/ranges_count.md
@@ -7,18 +7,20 @@
 ```cpp
 namespace std::ranges {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
   constexpr iter_difference_t&amp;lt;I&amp;gt; count(I first, S last, const T&amp;amp; value, Proj proj = {}); // (1)
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
   constexpr range_difference_t&amp;lt;R&amp;gt; count(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});          // (2)
 }
 ```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* input_range[link /reference/ranges/input_range.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
-* equal_to[link /reference/functional/equal_to.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 * projected[link /reference/iterator/projected.md]
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 * range_difference_t[link /reference/ranges/range_difference_t.md]
@@ -67,7 +69,7 @@ count of 1: 3
 ```cpp
 struct count_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
   constexpr iter_difference_t&amp;lt;I&amp;gt; operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
     iter_difference_t&amp;lt;I&amp;gt; count = 0;
     for ( ; first != last; ++first)
@@ -76,7 +78,7 @@ struct count_impl {
   }
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
   constexpr range_difference_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
     return (*this)(begin(r), end(r), value, ref(proj));
   }
@@ -84,10 +86,12 @@ struct count_impl {
 
 inline constexpr count_impl count;
 ```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* input_range[link /reference/ranges/input_range.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
-* equal_to[link /reference/functional/equal_to.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 * projected[link /reference/iterator/projected.md]
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 * range_difference_t[link /reference/ranges/range_difference_t.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_count_if.html"/>
      <id>b792f48b9cc19c4cbe9725fc0f83c34ca795c424:reference/algorithm/ranges_count_if.md</id>
      <updated>2021-12-30T13:58:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_count_if.md b/reference/algorithm/ranges_count_if.md
index 510639aec..b93b39613 100644
--- a/reference/algorithm/ranges_count_if.md
+++ b/reference/algorithm/ranges_count_if.md
@@ -13,6 +13,8 @@ namespace std::ranges {
   constexpr range_difference_t&amp;lt;R&amp;gt; count_if(R&amp;amp;&amp;amp; r, Pred pred, Proj proj = {});          // (2)
 }
 ```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* input_range[link /reference/ranges/input_range.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
@@ -83,6 +85,8 @@ struct count_if_impl {
 
 inline constexpr count_if_impl count_if;
 ```
+* input_iterator[link /reference/iterator/input_iterator.md]
+* input_range[link /reference/ranges/input_range.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_unary_predicate[link /reference/iterator/indirect_unary_predicate.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_find.html"/>
      <id>b792f48b9cc19c4cbe9725fc0f83c34ca795c424:reference/algorithm/ranges_find.md</id>
      <updated>2021-12-30T13:58:35+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_find.md b/reference/algorithm/ranges_find.md
index 1cf2408c7..0bf006583 100644
--- a/reference/algorithm/ranges_find.md
+++ b/reference/algorithm/ranges_find.md
@@ -7,11 +7,11 @@
 ```cpp
 namespace std::ranges {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
   constexpr I find(I first, S last, const T&amp;amp; value, Proj proj = {});
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; find(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {});
 }
 ```
@@ -21,7 +21,7 @@ namespace std::ranges {
 - iterator_t[link /reference/ranges/iterator_t.md]
 - identity[link /reference/functional/identity.md]
 - indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
-- equal_to[link /reference/functional/equal_to.md]
+- ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 - input_range[link /reference/ranges/input_range.md]
 - projected[link /reference/iterator/projected.md]
 
@@ -64,7 +64,7 @@ found: 1
 ```cpp
 struct find_impl {
   template&amp;lt;input_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;I, Proj&amp;gt;, const T*&amp;gt;
   constexpr I operator()(I first, S last, const T&amp;amp; value, Proj proj = {}) {
     for ( ; first != last; ++first)
       if (*first == value) return first;
@@ -72,7 +72,7 @@ struct find_impl {
   }
 
   template&amp;lt;input_range R, class T, class Proj = identity&amp;gt;
-    requires indirect_binary_predicate&amp;lt;equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
+    requires indirect_binary_predicate&amp;lt;ranges::equal_to, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;, const T*&amp;gt;
   constexpr borrowed_iterator_t&amp;lt;R&amp;gt; operator()(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Proj proj = {}) {
     return (*this)(begin(r), end(r), value, ref(proj));
   }
@@ -83,7 +83,7 @@ inline constexpr find_impl find;
 * sentinel_for[link /reference/iterator/sentinel_for.md]
 * identity[link /reference/functional/identity.md]
 * indirect_binary_predicate[link /reference/iterator/indirect_binary_predicate.md]
-* equal_to[link /reference/functional/equal_to.md]
+* ranges::equal_to[link /reference/functional/ranges_equal_to.md]
 * projected[link /reference/iterator/projected.md]
 * invoke[link /reference/functional/invoke.md]
 * begin[link /reference/ranges/begin.md]
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>