<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-01-24T10:13:06.812544</updated>
  <id>f9c8e890-9e25-45eb-8eca-9d0531748d71</id>

  
    <entry>
      <title>format -- &lt;format&gt; : range_formatterクラスページを追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format.html"/>
      <id>f3d46e161ef521b57aeb7cc2b254859daedae89f:reference/format.md</id>
      <updated>2023-01-24T19:08:33+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;format&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;format&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;ヘッダでは、書式文字列を使って引数をフォーマットする、いわゆる&lt;code&gt;printf&lt;/code&gt;スタイルのフォーマット関数を提供する。
このフォーマット関数は型安全であり、ユーザー定義型への拡張も可能である。&lt;/p&gt;
&lt;p&gt;書式文字列については&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;format&lt;/a&gt;&lt;/code&gt;を参照。&lt;/p&gt;
&lt;h2&gt;フォーマット関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;format&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;書式文字列を使って引数をフォーマットした文字列を返す (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format_to.html&#34;&gt;format_to&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;書式文字列を使って引数をフォーマットし、出力イテレータに出力する (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format_to_n.html&#34;&gt;format_to_n&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;書式文字列を使って引数をフォーマットし、指定した文字数を超えないように出力イテレータに出力する (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format_to_n_result.html&#34;&gt;format_to_n_result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;format_to_n&lt;/code&gt;の結果を表す (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/formatted_size.html&#34;&gt;formatted_size&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;書式文字列を使って引数をフォーマットした文字列を保存するのに必要な文字数を返す (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/vformat.html&#34;&gt;vformat&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format.html&#34;&gt;format&lt;/a&gt;&lt;/code&gt;の非テンプレート版 (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/vformat_to.html&#34;&gt;vformat_to&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format_to.html&#34;&gt;format_to&lt;/a&gt;&lt;/code&gt;の非テンプレート版 (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;フォーマッター&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/formattable.html&#34;&gt;formattable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列フォーマット可能 (concept)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/formatter.html&#34;&gt;formatter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;引数の型に対応する書式文字列の解析、値のフォーマットを担う (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_parse_context.html&#34;&gt;basic_format_parse_context&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;書式文字列の解析のコンテキスト (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_parse_context.html&#34;&gt;format_parse_context&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basic_format_parse_context&lt;/code&gt;のマルチバイト文字列版 (type-alias)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_parse_context.html&#34;&gt;wformat_parse_context&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basic_format_parse_context&lt;/code&gt;のワイド文字列版 (type-alias)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_context.html&#34;&gt;basic_format_context&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;引数のフォーマットのコンテキスト (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_context.html&#34;&gt;format_context&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basic_format_context&lt;/code&gt;のマルチバイト文字列版 (type-alias)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_context.html&#34;&gt;wformat_context&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basic_format_context&lt;/code&gt;のワイド文字列版 (type-alias)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/range_format.html&#34;&gt;range_format&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rangeの書式種別 (enum)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format_kind.html&#34;&gt;format_kind&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定したRangeの書式種別を取得する (variable)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/range_formatter.html&#34;&gt;range_formatter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rangeに対する書式文字列の解析、値のフォーマットを行う (class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/range-default-formatter.md.nolink&#34;&gt;range-default-formatter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rangeに対する共通の書式文字列の解析、値のフォーマットを行う説明専用クラス (class template)&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;引数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_arg.html&#34;&gt;basic_format_arg&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;引数1つへのアクセスを提供する (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/visit_format_arg.html&#34;&gt;visit_format_arg&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basic_format_arg&lt;/code&gt;オブジェクトが現在保持している型に対応する関数を呼び出す (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/make_format_args.html&#34;&gt;make_format_args&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変長引数から&lt;code&gt;basic_format_arg&lt;/code&gt;の列を構築する (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/make_format_args.html&#34;&gt;make_wformat_args&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make_wformat_args&lt;/code&gt;のワイド文字列版 (function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_args.html&#34;&gt;basic_format_args&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;引数列へのアクセスを提供する (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_args.html&#34;&gt;format_args&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basic_format_args&lt;/code&gt;のマルチバイト文字列版 (type-alias)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/basic_format_args.html&#34;&gt;wformat_args&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basic_format_args&lt;/code&gt;のワイド文字列版 (type-alias)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;例外&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/format/format_error.html&#34;&gt;format_error&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;フォーマットの失敗を表す例外クラス (class)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++20&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#icc&#34;&gt;ICC&lt;/a&gt;: ??&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cpprefjp.github.io/implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: ??&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://timsong-cpp.github.io/cppwp/format&#34; target=&#34;_blank&#34;&gt;Working Draft, Standard for Programming Language C++ [format]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0645r10.html&#34; target=&#34;_blank&#34;&gt;P0645R10 Text Formatting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>range_formatter -- &lt;format&gt; : range_formatterクラスページを追加 #1085</title>
      <link href="https://cpprefjp.github.io/reference/format/range_formatter.html"/>
      <id>f3d46e161ef521b57aeb7cc2b254859daedae89f:reference/format/range_formatter.md</id>
      <updated>2023-01-24T19:08:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/range_formatter.md b/reference/format/range_formatter.md
new file mode 100644
index 000000000..5bd98668a
--- /dev/null
+++ b/reference/format/range_formatter.md
@@ -0,0 +1,127 @@
+# range_formatter
+* format[meta header]
+* class template[meta id-type]
+* std[meta namespace]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+  template &amp;lt;class T, class charT = char&amp;gt;
+    requires same_as&amp;lt;remove_cvref_t&amp;lt;T&amp;gt;, T&amp;gt; &amp;amp;&amp;amp; formattable&amp;lt;T, charT&amp;gt;
+  class range_formatter;
+}
+```
+* formattable[link formattable.md]
+
+## 概要
+`range_formatter`は、Range・コンテナに対する[`formatter`](formatter.md)クラスの特殊化を実装するためのユーティリティクラスである。
+
+ユーザー定義のコンテナ・RangeをRange書式に対応する場合は、以下のようにする：
+
+- オリジナル書式を定義しないのであれば、このクラスではなく、[`format_kind`](format_kind.md)を特殊化する
+- オリジナル書式を定義するのであれば、このクラスおよび[`format_kind`](format_kind.md)を特殊化して[`parse()`](range_formatter/parse.md.nolink)メンバ関数と[`format()`](range_formatter/format.md.nolink)メンバ関数を実装する
+
+
+## メンバ関数
+
+| メンバ関数 | 説明 | 対応バージョン |
+|------------|------|----------------|
+| [`set_separator`](range_formatter/set_separator.md.nolink) | 要素の区切り文字を設定する | C++23 |
+| [`set_brackets`](range_formatter/set_brackets.md.nolink)   | 全体の囲み文字を設定する | C++23 |
+| [`underlying`](range_formatter/underlying.md.nolink)       | 要素型の`formatter`を取得する | C++23 |
+| [`parse`](range_formatter/parse.md.nolink)                 | 書式の解析を行う | C++23 |
+| [`format`](range_formatter/format.md.nolink)               | 書式化を行う | C++23 |
+
+
+## 例
+### オリジナル書式を定義する例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;format&amp;gt;
+#include &amp;lt;vector&amp;gt;
+
+template &amp;lt;class T&amp;gt;
+class std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; : public std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt; {
+  bool is_colon = false;
+  using base_type = std::range_formatter&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt;;
+public:
+
+  // コンパイル時の書式文字列の解析があるため、
+  // constexprにする必要がある。
+  // この関数に渡されるパラメータは、{:%j}の%以降。
+  // 解析がおわった場所を指すイテレータを返す。
+  constexpr auto parse(std::format_parse_context&amp;amp; ctx) {
+    auto it = ctx.begin();
+    if (*it == &amp;#39;c&amp;#39;) {
+      is_colon = true;
+      ++it;
+    }
+    ctx.advance_to(it);
+    return base_type::parse(ctx);
+  }
+
+  // format()関数は書式の情報をもたない。
+  // parse()関数で解析した書式をメンバ変数で保持しておいて、
+  // それをもとに書式化する
+  auto format(const std::vector&amp;lt;T&amp;gt;&amp;amp; v, std::format_context&amp;amp; ctx) const {
+    if (is_colon) {
+      auto out = ctx.out();
+      bool is_first = true;
+      for (const T&amp;amp; x : v) {
+        if (is_first) {
+          is_first = false;
+        }
+        else {
+          *out = &amp;#39;:&amp;#39;;
+          ++out;
+        }
+        ctx.advance_to(out);
+        out = underlying().format(x, ctx);
+      }
+      return out;
+    }
+    return base_type::format(v, ctx);
+  }
+};
+
+int main()
+{
+  std::vector&amp;lt;std::uint8_t&amp;gt; v = {0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
+  std::cout &amp;lt;&amp;lt; std::format(&amp;#34;{:c:02x}&amp;#34;, v) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::format_parse_context[link basic_format_parse_context.md]
+* ctx.begin()[link basic_format_parse_context/begin.md]
+* std::format_context[link basic_format_context.md]
+* ctx.out()[link basic_format_context/out.md]
+* std::format_to[link format_to.md]
+* std::format[link format.md]
+* underlying()[link range_formatter/underlying.md.nolink]
+
+
+#### 出力
+```
+aa:bb:cc:dd:ee:ff
+```
+
+(動作確認はできていない)
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): ??
+- [ICC](/implementation.md#icc): ??
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+## 関連項目
+- [`range-default-formatter`](range-default-formatter.md.nolink)
+- [`formatter`](formatter.md)
+
+
+## 参照
+- [P2286R8 Formatting Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html)
+- [P2585R1 Improve default container formatting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2585r1.html)
+    - C++23から、Range・コンテナ、`pair`、`tuple`のフォーマット出力、および文字・文字列のデバッグ指定 (`&amp;#34;?&amp;#34;`) が追加された
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- move_only_function/op_constructor: fix markup</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function/op_constructor.html"/>
      <id>01eb3487685c392456dcec2c6bc85b06fcc5b8bf:reference/functional/move_only_function/op_constructor.md</id>
      <updated>2023-01-24T17:52:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function/op_constructor.md b/reference/functional/move_only_function/op_constructor.md
index 5a13d4bcd..1635fa0f5 100644
--- a/reference/functional/move_only_function/op_constructor.md
+++ b/reference/functional/move_only_function/op_constructor.md
@@ -25,6 +25,7 @@ explicit move_only_function(in_place_type_t&amp;lt;T&amp;gt;, initializer_list&amp;lt;U&amp;gt;, Args&amp;amp;&amp;amp;...);
 
 
 `move_only_function`クラステンプレートパラメータのnoexcept例外指定 *noex* 特殊化に応じて、説明用の`bool`型テンプレート定数`is-callable-from&amp;lt;VT&amp;gt;`を下記のように定義する :
+
 - *noex* が`true`のとき : [`is_nothrow_invocable_r_v`](/reference/type_traits/is_nothrow_invocable_r.md)`&amp;lt;R, VT /*cv*/ /*ref*/, ArgTypes...&amp;gt; &amp;amp;&amp;amp;` [`is_nothrow_invocable_r_v`](/reference/type_traits/is_nothrow_invocable_r.md)`&amp;lt;R, VT /*inv-quals*/, ArgTypes...&amp;gt;`
 - *noex* が`false`のとき : [`is_invocable_r_v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, VT /*cv*/ /*ref*/, ArgTypes...&amp;gt; &amp;amp;&amp;amp;` [`is_invocable_r_v`](/reference/type_traits/is_invocable_r.md)`&amp;lt;R, VT /*inv-quals*/, ArgTypes...&amp;gt;`
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>span -- span,basic_string_view: P2251対応(#1062)</title>
      <link href="https://cpprefjp.github.io/reference/span/span.html"/>
      <id>020145072fe3f0b3552760fd3de229fc084fe5dc:reference/span/span.md</id>
      <updated>2023-01-24T17:41:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span.md b/reference/span/span.md
index f65f8daf0..c4fe25ad3 100644
--- a/reference/span/span.md
+++ b/reference/span/span.md
@@ -31,6 +31,8 @@ namespace std {
 
 文字列操作に特化したクラスとして[`std::basic_string_view`](/reference/string_view/basic_string_view.md)が定義されているが、こちらはメモリ連続性をもつあらゆるコンテナに適用できる。
 
+このクラスは、[トリビアルコピー可能](/reference/type_traits/is_trivially_copyable.md)である（C++23）
+
 
 ### メモリ連続性
 このクラスの対象は、メモリの連続性を持つシーケンスである。例として、以下は対象のシーケンスである：
@@ -276,3 +278,5 @@ int main()
 - [P2116R0 Remove tuple-like protocol support from fixed-extent `span`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2116r0.html)
 - [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
 - [P2325R3 Views should not be required to be default constructible](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html)
+- [Require `span` &amp;amp; `basic_string_view` to be Trivially Copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf)
+    - C++23から、トリビアルコピー可能が保証される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_string_view -- span,basic_string_view: P2251対応(#1062)</title>
      <link href="https://cpprefjp.github.io/reference/string_view/basic_string_view.html"/>
      <id>020145072fe3f0b3552760fd3de229fc084fe5dc:reference/string_view/basic_string_view.md</id>
      <updated>2023-01-24T17:41:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string_view/basic_string_view.md b/reference/string_view/basic_string_view.md
index 5e7bc85b2..2c3484d7f 100644
--- a/reference/string_view/basic_string_view.md
+++ b/reference/string_view/basic_string_view.md
@@ -31,6 +31,8 @@ string_view hello = sv.substr(0, 5); // 先頭5文字を抽出する
 
 このクラスの実装としては、文字配列の参照する先頭文字へのポインタと、文字数の2つをメンバ変数として持つ。これらの変数を変動させることによって、部分文字列の抽出や、限定された範囲内での検索といったことを実現する。
 
+このクラスは、[トリビアルコピー可能](/reference/type_traits/is_trivially_copyable.md)である（C++23）
+
 
 ## メンバ関数
 ### 構築・破棄
@@ -321,3 +323,5 @@ C
 - [P0254R2 Integrating `std::string_view` and `std::string`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0254r2.pdf)
 - [P0403R0 Literal suffixes for `basic_string_view`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0403r0.html)
 - [String literals make bad ranges - Andrzej&amp;#39;s C++ blog](https://akrzemi1.wordpress.com/2019/09/25/string-literals-make-bad-ranges/)
+- [Require `span` &amp;amp; `basic_string_view` to be Trivially Copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf)
+    - C++23から、トリビアルコピー可能が保証される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_only_function -- move_only_funciton : std::functionとの違いについて追記</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function.html"/>
      <id>6e6d1c530a1e90c052394a44d9e1e4a64a6c419b:reference/functional/move_only_function.md</id>
      <updated>2023-01-24T17:29:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function.md b/reference/functional/move_only_function.md
index 3e189c013..448d26961 100644
--- a/reference/functional/move_only_function.md
+++ b/reference/functional/move_only_function.md
@@ -29,7 +29,9 @@ namespace std {
 - const性を正しく伝搬する。
 - 関数型のCV修飾／参照修飾／noexcept例外指定をサポートする。
 - [`target_type`](function/target_type.md)型と[`target()`](function/target.md)を提供しない。
-- [関数呼び出し](move_only_function/op_call.md)は強い前提条件を持つ。
+    - 実行時型情報（RTTI）非依存
+- [関数呼び出し](move_only_function/op_call.md)は強い事前条件を持つ。
+    - 関数呼び出し時のnullチェックが要求されない
 
 
 ## メンバ関数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>move_only_function -- move_only_function: 従来functionと対比した例示コードを拡充(#1056)</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function.html"/>
      <id>f85391077c46ea79afc2a1a5792bf3d7ac44b4e6:reference/functional/move_only_function.md</id>
      <updated>2023-01-24T15:06:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function.md b/reference/functional/move_only_function.md
index ebd0db201..3e189c013 100644
--- a/reference/functional/move_only_function.md
+++ b/reference/functional/move_only_function.md
@@ -16,12 +16,21 @@ namespace std {
 ## 概要
 `move_only_function`クラステンプレートは、パラメータの型リスト`ArgTypes...`、戻り値の型`R`に合致する、あらゆる関数ポインタ、関数オブジェクト、メンバ関数ポインタ、メンバ変数ポインタを保持できるクラスである。
 
-下記全ての組み合わせ（12種類）についてクラステンプレートの部分特殊化が提供される。
+下記全ての組み合わせ（12種類）に対して、クラステンプレートの部分特殊化が提供される。
 
 - CV修飾子 *cv* : `const`, CV修飾無し
 - 参照修飾子 *ref* : `&amp;amp;`, `&amp;amp;&amp;amp;`, 参照修飾無し
 - noexcept例外指定 *noex* : `true`, `false`
 
+### `function`との比較
+[`std::function`](function.md)と比べて、`std::move_only_function`は下記の特徴をもつ。
+
+- ムーブのみ対応。コピー不可。
+- const性を正しく伝搬する。
+- 関数型のCV修飾／参照修飾／noexcept例外指定をサポートする。
+- [`target_type`](function/target_type.md)型と[`target()`](function/target.md)を提供しない。
+- [関数呼び出し](move_only_function/op_call.md)は強い前提条件を持つ。
+
 
 ## メンバ関数
 ### 構築・破棄
@@ -52,9 +61,10 @@ namespace std {
 
 
 ## 例
+### 例1: 基本の使い方
 ```cpp example
-#include &amp;lt;iostream&amp;gt;
 #include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
 
 int add(int x) { return x + 1; }
 
@@ -74,9 +84,139 @@ int main()
 * std::move_only_function[color ff0000]
 * f(1)[link move_only_function/op_call.md]
 
-### 出力
+#### 出力
+```
+2
+```
+
+### 例2: const性の伝搬
+```cpp
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+struct Functor {
+  std::string operator()() {
+    return &amp;#34;non-const&amp;#34;;
+  }
+  std::string operator()() const {
+    return &amp;#34;const&amp;#34;;
+  }
+};
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; &amp;#34;-- move_only_function&amp;#34; &amp;lt;&amp;lt; std::endl;
+        std::move_only_function&amp;lt;std::string(void)&amp;gt;       mof1 = Functor{};
+  const std::move_only_function&amp;lt;std::string(void)&amp;gt;       mof2 = Functor{}; // (呼び出し時に不適格)
+        std::move_only_function&amp;lt;std::string(void) const&amp;gt; mof3 = Functor{};
+  const std::move_only_function&amp;lt;std::string(void) const&amp;gt; mof4 = Functor{};
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof1: &amp;#34; &amp;lt;&amp;lt; mof1() &amp;lt;&amp;lt; std::endl;
+//std::cout &amp;lt;&amp;lt; &amp;#34;mof2: &amp;#34; &amp;lt;&amp;lt; mof2() &amp;lt;&amp;lt; std::endl; // 不適格
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof3: &amp;#34; &amp;lt;&amp;lt; mof3() &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof4: &amp;#34; &amp;lt;&amp;lt; mof4() &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;-- function&amp;#34; &amp;lt;&amp;lt; std::endl;
+        std::function&amp;lt;std::string(void)&amp;gt;       fn1 = Functor{};
+  const std::function&amp;lt;std::string(void)&amp;gt;       fn2 = Functor{};
+//      std::function&amp;lt;std::string(void) const&amp;gt; fn3 = Functor{}; // 不適格
+//const std::function&amp;lt;std::string(void) const&amp;gt; fn4 = Functor{}; // 不適格
+  std::cout &amp;lt;&amp;lt; &amp;#34;fn1: &amp;#34; &amp;lt;&amp;lt; fn1() &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;fn2: &amp;#34; &amp;lt;&amp;lt; fn2() &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::move_only_function[color ff0000]
+* std::function[link function.md]
+
+#### 出力
+```
+-- move_only_function
+mof1: non-const
+mof3: const
+mof4: const
+-- function
+fn1: non-const
+fn2: non-const
+```
+
+### 例3: 左辺値/右辺値の伝搬
+```cpp example
+#include &amp;lt;functional&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;utility&amp;gt;
+
+struct Functor {
+  std::string operator()() &amp;amp; {
+    return &amp;#34;L-val&amp;#34;;
+  }
+  std::string operator()() &amp;amp;&amp;amp; {
+    return &amp;#34;R-val&amp;#34;;
+  }
+};
+
+int main()
+{
+  std::cout &amp;lt;&amp;lt; &amp;#34;-- move_only_function&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::move_only_function&amp;lt;std::string(void)&amp;gt;    mof1 = Functor{};
+  std::move_only_function&amp;lt;std::string(void) &amp;amp;&amp;amp;&amp;gt; mof2 = Functor{};
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof1/L-val: &amp;#34; &amp;lt;&amp;lt; mof1()            &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof1/R-val: &amp;#34; &amp;lt;&amp;lt; std::move(mof1)() &amp;lt;&amp;lt; std::endl;
+//std::cout &amp;lt;&amp;lt; &amp;#34;mof2/L-val: &amp;#34; &amp;lt;&amp;lt; mof2()            &amp;lt;&amp;lt; std::endl; // 不適格
+  std::cout &amp;lt;&amp;lt; &amp;#34;mof2/R-val: &amp;#34; &amp;lt;&amp;lt; std::move(mof2)() &amp;lt;&amp;lt; std::endl;
+
+  std::cout &amp;lt;&amp;lt; &amp;#34;-- function&amp;#34; &amp;lt;&amp;lt; std::endl;
+  std::function&amp;lt;std::string(void)&amp;gt;    fn1 = Functor{};
+//std::function&amp;lt;std::string(void) &amp;amp;&amp;amp;&amp;gt; fn2 = Functor{}; // 不適格
+  std::cout &amp;lt;&amp;lt; &amp;#34;fn1/L-val: &amp;#34; &amp;lt;&amp;lt; fn1()            &amp;lt;&amp;lt; std::endl;
+  std::cout &amp;lt;&amp;lt; &amp;#34;fn1/R-val: &amp;#34; &amp;lt;&amp;lt; std::move(fn1)() &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::move_only_function[color ff0000]
+* std::function[link function.md]
+
+#### 出力
+```
+-- move_only_function
+mof1/L-val: L-val
+mof1/R-val: L-val
+mof2/R-val: R-val
+-- function
+fn1/L-val: L-val
+fn1/R-val: L-val
+```
+
+### 例4: noexcept指定の伝搬
+```cpp example
+#include &amp;lt;functional&amp;gt;
+
+void func() {}
+void func_noex() noexcept {}
+
+int main()
+{
+  std::move_only_function&amp;lt;void(void)&amp;gt;          mof1 = func;
+  std::move_only_function&amp;lt;void(void)&amp;gt;          mof2 = func_noex;
+//std::move_only_function&amp;lt;void(void) noexcept&amp;gt; mof3 = func; // 不適格
+  std::move_only_function&amp;lt;void(void) noexcept&amp;gt; mof4 = func_noex;
+  static_assert(not noexcept(mof1()));
+  static_assert(not noexcept(mof2()));
+  static_assert(    noexcept(mof4()));
+
+  std::function&amp;lt;void(void)&amp;gt;          fn1 = func;
+  std::function&amp;lt;void(void)&amp;gt;          fn2 = func_noex;
+//std::function&amp;lt;void(void) noexcept&amp;gt; fn3 = func;      // 不適格
+//std::function&amp;lt;void(void) noexcept&amp;gt; fn4 = func_noex; // 不適格
+  static_assert(not noexcept(fn1()));
+  static_assert(not noexcept(fn2()));
+}
+```
+* std::move_only_function[color ff0000]
+* std::function[link function.md]
+
+#### 出力
 ```
-1
 ```
 
 
@@ -86,7 +226,7 @@ int main()
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): ??
+- [GCC](/implementation.md#gcc): 12.1
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
@@ -97,3 +237,5 @@ int main()
 
 ## 参照
 - [P0288R9 move_only_function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0288r9.html)
+- [N4348 Making `std::function` safe for concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4348.html)
+    - `std::function`のconst性伝搬に関して、スレッドセーフ保証の観点からの問題指摘。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- move_only_function: 従来functionと対比した例示コードを拡充(#1056)</title>
      <link href="https://cpprefjp.github.io/reference/functional/move_only_function/op_call.html"/>
      <id>f85391077c46ea79afc2a1a5792bf3d7ac44b4e6:reference/functional/move_only_function/op_call.md</id>
      <updated>2023-01-24T15:06:24+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/move_only_function/op_call.md b/reference/functional/move_only_function/op_call.md
index e72ca0069..fcc09a5ff 100644
--- a/reference/functional/move_only_function/op_call.md
+++ b/reference/functional/move_only_function/op_call.md
@@ -12,7 +12,12 @@ R operator()(ArgTypes... args) /*cv*/ /*ref*/ noexcept(/*noex*/);
 ## 概要
 関数を呼び出す。
 
-CV修飾子 *cv*, 参照修飾子 *ref*, noexcept例外指定 *noex* は[`move_only_function`](../move_only_function.md)に指定するテンプレートパラメータ`R(ArgTypes...)`部と等しい。
+`operator()`のCV修飾子 *cv*, 参照修飾子 *ref*, noexcept例外指定 *noex* は、[`move_only_function`](../move_only_function.md)に指定するテンプレートパラメータ`R(ArgTypes...)`部のものと等しい。
+
+説明用のプレースホルダ *inv-quals* を次のように定義する :
+
+- *ref* が空（参照修飾無し）ならば、*cv*`&amp;amp;`
+- そうでなければ、*cv* *ref*
 
 
 ## 事前条件
@@ -20,7 +25,7 @@ CV修飾子 *cv*, 参照修飾子 *ref*, noexcept例外指定 *noex* は[`move_o
 
 
 ## 効果
-`*this`が保持している`F`型の関数ポインタまたは関数オブジェクト`f`に対して、[`INVOKE&amp;lt;R&amp;gt;`](/reference/concepts/Invoke.md)`(static_cast&amp;lt;F inv-quals&amp;gt;(f),` [`std::forward`](/reference/utility/forward.md)`&amp;lt;ArgTypes&amp;gt;(args)...)`を行う。
+`*this`が保持している`F`型の関数ポインタまたは関数オブジェクト`f`に対して、[`INVOKE&amp;lt;R&amp;gt;`](/reference/concepts/Invoke.md)`(static_cast&amp;lt;F /*inv-quals*/&amp;gt;(f),` [`std::forward`](/reference/utility/forward.md)`&amp;lt;ArgTypes&amp;gt;(args)...)`を行う。
 
 
 ## 戻り値
@@ -58,7 +63,7 @@ int main()
 
 ### 処理系
 - [Clang](/implementation.md#clang): ??
-- [GCC](/implementation.md#gcc): ??
+- [GCC](/implementation.md#gcc): 12.1
 - [ICC](/implementation.md#icc): ??
 - [Visual C++](/implementation.md#visual_cpp): ??
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
</feed>