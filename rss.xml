<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2021-05-23T14:42:56.750665</updated>
  <id>5443174b-b130-4ab9-86ec-803a2e161997</id>

  
    <entry>
      <title>iリテラル -- iリテラルの引数名を明記</title>
      <link href="https://cpprefjp.github.io/reference/complex/complex/op_i.html"/>
      <id>bb064cc055dbd658437963cfa115b0c14b0ac16b:reference/complex/complex/op_i.md</id>
      <updated>2021-05-22T15:11:44+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/complex/complex/op_i.md b/reference/complex/complex/op_i.md
index b9bd97317..cc4da8f72 100644
--- a/reference/complex/complex/op_i.md
+++ b/reference/complex/complex/op_i.md
@@ -8,9 +8,9 @@
 namespace std {
 inline namespace literals {
 inline namespace complex_literals {
-  constexpr complex&amp;lt;double&amp;gt; operator&amp;#34;&amp;#34;i(long double);
+  constexpr complex&amp;lt;double&amp;gt; operator&amp;#34;&amp;#34;i(long double d);
 
-  constexpr complex&amp;lt;double&amp;gt; operator&amp;#34;&amp;#34;i(unsigned long long);
+  constexpr complex&amp;lt;double&amp;gt; operator&amp;#34;&amp;#34;i(unsigned long long d);
 }}}
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Toshinori Tsuboi</name>
        <email>ikamat.kmr@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>polymorphic_allocator -- fix typo</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/polymorphic_allocator.html"/>
      <id>df189fefabbf261cdb312b8f2ec0f575d2611b57:reference/memory_resource/polymorphic_allocator.md</id>
      <updated>2021-05-22T03:28:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/polymorphic_allocator.md b/reference/memory_resource/polymorphic_allocator.md
index b1a2e7c4d..bdaa26a6c 100644
--- a/reference/memory_resource/polymorphic_allocator.md
+++ b/reference/memory_resource/polymorphic_allocator.md
@@ -86,7 +86,7 @@ C++20にてC++プログラミングにおいての基礎部品となる型（*vo
 ## 参照
 - [C++1z 多相アロケータとメモリプール - Faith and Brave - C++で遊ぼう ](https://faithandbrave.hateblo.jp/entry/2016/08/08/170454)
 - [memory_resourceについて - 本の虫](https://cpplover.blogspot.com/2015/09/memoryresource.html)
-- [Polymorphic Allocator in C++17 - Qita](https://qiita.com/MitsutakaTakeda/items/48980faa9498c46b15b2)
+- [Polymorphic Allocator in C++17 - Qiita](https://qiita.com/MitsutakaTakeda/items/48980faa9498c46b15b2)
 - [P0220R1 Adopt Library Fundamentals V1 TS Components for C++17 (R1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html)
 - [P0337r0 | Delete operator= for polymorphic_allocator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0337r0.html)
 - [Working Draft, C++ Extensions for Library Fundamentals, Version 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html#memory.resource.synop)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Kisaragi</name>
        <email>48310258+KisaragiEffective@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- 可変サイズをもつコンテナのconstexpr化、サンプル修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>349a94b27c91229137e409b6cc122621c3c13b2e:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-21T15:38:22+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 9755d4ba8..7facfa381 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -78,22 +78,18 @@ C++17までは、クラス型のリテラル型はトリビアルデストラク
 struct S {
   int n = 10;
   
-  constexpr void* operator new(std::size_t n) {
-    return ::operator new(n); // 定数式で実行可能ではない
-  }
-  
-  constexpr void operator delete(void* p) noexcept {
-    ::operator delete(p); // 定数式で実行可能ではない
-  }
+  // 仮に定数式で実行可能なように定義されていたとしても
+  constexpr void* operator new(std::size_t n);
+  constexpr void operator delete(void* p) noexcept;
 };
 
 constexpr int f() {
-  S* s = new S{}; // NG
+  S* s = new S{}; // NG、ユーザー定義operator newの呼び出し
 
   s-&amp;gt;n = 20;
   int n = s-&amp;gt;n;
 
-  delete s; // NG
+  delete s;
 
   return n;
 }
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- constexpr new/delete式追記 #688</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>f6ff668687cac2a08f3dd158745b476c9f6bfee7:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-21T15:16:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 9f26787c9..9755d4ba8 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -67,7 +67,74 @@ C++17までは、クラス型のリテラル型はトリビアルデストラク
 なお、クラスが仮想基底クラスを持つ時、デストラクタもコンストラクタも`constexpr`指定することはできない。
 
 ### `new/delete`式
-(執筆中)
+
+定数式では未定義動作を可能な限り検出しコンパイルエラーとしなければならない。`operator new/operator delete`や`malloc/free`はその実行に伴ってポインタの再解釈（`void*`への/からのキャスト）が必要となるが、ポインタの再解釈は検出しづらい未定義動作に繋がりうるため定数式では禁止されている。
+
+そのため、そのようなポインタの再解釈が発生しない動的メモリ確保機能である`new/delete`式がコンパイル時の動的メモリ確保・解放の方法として許可される。`new/delete`式は`operator new/operator delete`とは異なり、メモリの確保・解放とその領域のオブジェクト構築・破棄を一挙に行う言語機能である。
+
+ただし、コンパイル時に実行される`new`式はグローバルのオーバーロード可能な[`operator new`](/reference/new/op_new.md)を呼び出すものでなくてはならない。そうではない`new`式の定数式における評価はコンパイルエラーとなる。
+
+```cpp
+struct S {
+  int n = 10;
+  
+  constexpr void* operator new(std::size_t n) {
+    return ::operator new(n); // 定数式で実行可能ではない
+  }
+  
+  constexpr void operator delete(void* p) noexcept {
+    ::operator delete(p); // 定数式で実行可能ではない
+  }
+};
+
+constexpr int f() {
+  S* s = new S{}; // NG
+
+  s-&amp;gt;n = 20;
+  int n = s-&amp;gt;n;
+
+  delete s; // NG
+
+  return n;
+}
+```
+
+そして、コンパイル時に`new`式で確保されたメモリ領域は、コンパイル時に`delete`式によって解放されなければならない。その対応が取れていない`new/delete`式の呼び出しは、どちらもコンパイルエラーとなる。
+
+```cpp
+constexpr int f() {
+  int* d = new int;
+
+  *d = 20;
+  int n = *d;
+
+  // 忘れる
+  //delete d;
+
+  return n;
+}
+
+int main () {
+  constexpr int n = f();  // NG、コンパイルエラー
+}
+```
+
+したがって、C++20のコンパイル時動的メモリ確保の仕様では、コンパイル時に確保したメモリ領域を実行時へ持ち越すことはできない。
+
+実際には、これらの定数式中の`new`式の評価は常に省略されている。この省略はC++14より許可されている最適化の一環として行われ、スタック領域などのストレージを別途割り当てることで動的メモリ確保を避けるものである。対応する`delete`式の呼び出しも同様に省略され、定数式においてはメモリの確保と解放が一貫していることのマーカーとしての役割しか持たない。
+
+```cpp
+constexpr void f() {
+  // このコードは定数式中で
+  int* d = new int{2};
+  delete d;
+
+  // 次のようなコードと等価になる
+  int d{2};
+}
+```
+
+実際にはどこのストレージが提供されるかは規定されていない。ただ、定数式が実行される環境はC++コンパイラの内蔵する`constexpr`インタプリタ上であり、その環境のメモリ領域とはコンパイラ実行環境のヒープ領域が対応する。
 
 ### `std::allocator/std::allocator_traits`
 (執筆中)
@@ -103,4 +170,5 @@ std::vector&amp;lt;std::metainfo&amp;gt; args = std::meta::get_template_args(reflexpr(T));
 - [P0784R5 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r5.html)
 - [P0784R6 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r6.html)
 - [P0784R7 More constexpr containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html)
+- [動的メモリー確保 - 江添亮の入門C++](https://ezoeryou.github.io/cpp-intro/#動的メモリー確保)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナの`constexpr`化 -- 可変サイズをもつコンテナの`constexpr`化  デストラクタ追記</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>9600f8da3d111dc8649d1c91fd406d35ffb832ea:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2021-05-20T16:56:33+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 89873fc8d..9f26787c9 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -26,14 +26,51 @@ static_assert(test_vector() == 35);         // OK
 static_assert(check_cpp_file(&amp;#34;main.cpp&amp;#34;));  // OK
 ```
 
+これは主に以下の変更によって達成されている。
+
+- デストラクタの`constexpr`対応
+- `new/delete`式の`constexpr`対応
+- `std::allocator/std::allocator_traits`の`constexpr`対応
+
 ## 仕様
-(執筆中)
 
 ### `constexpr`デストラクタ
 
+デストラクタに`constexpr`を付加し、デストラクタを定数式で実行する事が可能となる。これはユーザー定義のデストラクタでも同様。
+
+そのような`constexpr`デストラクタの本体、およびそのクラスの基底クラスと非静的メンバ変数の全てのデストラクタは定数式で実行可能でなくてはならない。
+
+```cpp
+struct C : base {
+
+  // constexprデフォルトデストラクタ
+  constexpr ~C() = default;
+
+  // あるいは定義しても良い
+  constexpr ~C() {
+    // 何か定数式で可能な処理
+    // ...
+  }
+
+  // 全ての基底クラスおよび非静的メンバ変数もまた定数式でデストラクト可能でなければならない
+  int n;
+  std::string str; 
+};
+```
+
+`default`指定した時の振る舞いは、`constexpr`コンストラクタに`default`指定した時の振る舞いに準ずる。例えば、`default`デストラクタ（特に、トリビアルデストラクタ）はその処理が全て定数式で実行可能であるならば、暗黙的に`constexpr`である。
+
+これに伴って、クラス型のリテラル型は`constexpr`デストラクタを持つ事が追加で要求されるようになる。そして、クラス型の`constexpr`変数は、その型がリテラル型で初期化が定数式で可能であり、かつデストラクタが定数式で実行可能でなくてはならなくなる。
+
+C++17までは、クラス型のリテラル型はトリビアルデストラクタを要求されており、その`constexpr`オブジェクトは初期化が定数式で実行可能であることだけが要求されていた。そのため、C++17までのリテラル型はC++20においてもリテラル型であり、定数式での扱いは変わらない。
+
+なお、クラスが仮想基底クラスを持つ時、デストラクタもコンストラクタも`constexpr`指定することはできない。
+
 ### `new/delete`式
+(執筆中)
 
 ### `std::allocator/std::allocator_traits`
+(執筆中)
 
 
 ## この機能が必要になった背景・経緯
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>