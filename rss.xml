<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-08-02T14:34:17.489454</updated>
  <id>4500f7f9-fb52-4b0c-aeea-c91dfbe59af4</id>

  
    <entry>
      <title>一貫比較 -- C++20 一貫比較 : 全体調整とリンク追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html"/>
      <id>a4fdb82c2e62c61d25680c47d73a76d158bcf146:lang/cpp20/consistent_comparison.md</id>
      <updated>2020-08-01T17:27:56+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/consistent_comparison.md b/lang/cpp20/consistent_comparison.md
index 2cafc0d75..cb87b8c85 100644
--- a/lang/cpp20/consistent_comparison.md
+++ b/lang/cpp20/consistent_comparison.md
@@ -68,7 +68,7 @@ if (comp &amp;lt; 0) {
 
 この場合の結果は`a &amp;lt; b`が出力される。
 
-戻り値の値は左辺に対する右辺の関係を表すので、引数順を入れ替えると順序の方向も逆転する。（上記の例の場合、`comp = b &amp;lt;=&amp;gt; a`とすると`comp &amp;lt; 0 == false, 0 &amp;lt; comp == true`となり、`a &amp;gt; b`が出力される）
+戻り値の値は左辺に対する右辺の関係を表すので、引数順を入れ替えると順序の方向も逆転する（上記の例の場合、`comp = b &amp;lt;=&amp;gt; a`とすると`comp &amp;lt; 0 == false, 0 &amp;lt; comp == true`となり、`a &amp;gt; b`が出力される）。これは、数値型の場合は`左辺-右辺`の結果が`0`より大きいか？によって比較結果を表現していると見ることができる。
 
 なお、三方比較演算子の戻り値の`0`リテラル以外との比較は未定義動作とされる。`1`だったり`0.0`であってはならない。
 
@@ -86,7 +86,7 @@ bool is_equal = comp == 0.0;
 
 ### 比較カテゴリ型（Comparison category type）
 三方比較演算子の戻り値型は`int`などの整数型ではなく、比較カテゴリ型と呼ばれる専用の型である。  
-これは、比較対象となる型の満たしている同値や順序の関係についてを専用の型によって表明し、コンセプト等の機構によってその性質に応じた適切な処理へのディスパッチを行うことを出来るようにするためである（例えば、以下で述べる比較カテゴリ型によって導出する演算子を変化させるのに利用されている）。
+これは、比較対象となる型の満たしている同値や順序の関係についてを専用の型によって表明し、コンセプト等の機構によってその性質に応じた適切な処理へのディスパッチを行うことを出来るようにするためである（例えば、後で説明する`&amp;lt;=&amp;gt;`演算子の合成の際に利用されている。）。
 
 以下の3つの比較カテゴリ型が提供される。
 
@@ -110,16 +110,13 @@ bool is_equal = comp == 0.0;
 ![]( https://raw.githubusercontent.com/cpprefjp/image/master/lang/cpp20/consistent_comparison_01.png)  
 図1 比較カテゴリ間の変換関係（[P0515R3](http://wg21.link/p0515)より引用； 最終的なC++20仕様では`weak_equality`/`strong_equality`は[削除されている](http://wg21.link/p1959)）
 
-
-これはつまり、各比較カテゴリ間の順序関係を示している。この順序は半順序となる。
-
 クラス型に対するdefaultな三方比較演算子の様に複数の型が参加する三方比較の結果の比較カテゴリは、比較に参加するすべての型の`&amp;lt;=&amp;gt;`による比較の結果となるカテゴリ型から共通して変換できる最も強い型となる。そのような型を共通比較カテゴリ型（common comparison category type）と呼ぶ。
 
 比較に参加するすべての型の`&amp;lt;=&amp;gt;`による比較カテゴリ型をそれぞれ`Ti (0 &amp;lt;= i &amp;lt; N)`として、共通比較カテゴリ型`U`は以下のように決定される。
 
 1. `Ti`の中に1つでも`partial_ordering`がある場合、`U = partial_ordering`
-2. `Ti`の中に1つでも`weak_ordering`がある場合、`U = weak_ordering`
-3. それ以外の場合、`U = strong_ordering`（`N == 0`の場合）
+2. そうではなく、`Ti`の中に1つでも`weak_ordering`がある場合、`U = weak_ordering`
+3. それ以外の場合、`U = strong_ordering`（`N == 0`の場合など）
 
 この共通比較カテゴリ型を求めるのは場合によっては困難なので、それを求めるために`&amp;lt;compare&amp;gt;`ヘッダにて[`common_comparison_category&amp;lt;Ts...&amp;gt;`](/reference/compare/common_comparison_category.md)というメタ関数が提供される。
 
@@ -195,25 +192,7 @@ struct eq_comparable {
 }
 ```
 
-このような仕様になっているのは、`&amp;lt;=&amp;gt;`を用いた同値比較において発生しうるオーバーヘッドを回避するためである（詳細は後述の「検討された他の選択肢」を参照）。
-
-なお、`&amp;lt;=&amp;gt;`がdelete宣言されている場合でも`==`は暗黙的にdefault宣言されている。また、`&amp;lt;=&amp;gt;`を宣言せずに`==`だけをdefault指定で宣言することもでき、その場合でも`== !=`の2つの同値比較が可能である。
-
-```cpp
-struct C {
-  auto operator&amp;lt;=&amp;gt;(const C&amp;amp;) = delete;
-};
-
-int main() {
-  C c1{}, c2{};
-
-  //共にok
-  bool eq = c1 == c2;
-  bool ne = c1 != c2;
-}
-```
-
-ただし、`default`な`&amp;lt;=&amp;gt;`を宣言したうえで異種型間比較のために`==`を定義してしまうと、暗黙に宣言されていた`default`の`==`は宣言されなくなってしまうので注意が必要である。
+また、`default`な`&amp;lt;=&amp;gt;`を宣言したうえで異種型間比較のために`==`を定義してしまうと、暗黙に宣言されていた`default`の`==`は宣言されなくなってしまうので注意が必要である。
 
 ```cpp
 enum class category {
@@ -250,10 +229,10 @@ bool eq2 = a == category::C;  //ok
 
 この場合でも、`default`の`==`を明示的に宣言することで利用可能となる。
 
+このような仕様になっているのは、`&amp;lt;=&amp;gt;`を用いた同値比較において発生しうるオーバーヘッドを回避するためである（詳細は後述の「検討された他の選択肢」を参照）。
 
 ### 演算子の導出とオーバーロード候補
-`&amp;lt;=&amp;gt;`及び`==`から導出される演算子は暗黙的に宣言され実装されているわけではなく、それらの演算子を呼び出した際のオーバーロード候補に、`&amp;lt;=&amp;gt; ==`を利用して生成した候補を入れることによって導出される。  
-このために、導出された比較演算子のアドレスを取ることは出来ない。
+`&amp;lt;=&amp;gt;`及び`==`から導出される演算子は暗黙的に宣言され実装されているわけではなく、それらの演算子を呼び出した際のオーバーロード候補に、`&amp;lt;=&amp;gt; ==`を利用して生成した候補を入れることによって導出される。このため、導出された比較演算子のアドレスを取ることは出来ない。
 
 詳細な手順は以下のようになる。
 
@@ -321,17 +300,17 @@ inline auto operator&amp;lt;=&amp;gt;(const C&amp;amp;, const C&amp;amp;) = default;
 inline bool operator== (const C&amp;amp;, const C&amp;amp;) = default;
 ```
 
-このような`default`宣言はその定義が`constexpr`関数の要件を満たしていれば暗黙的に`constexpr`指定され、呼び出す演算子が全て`noexcept`であるならば暗黙的に`noexcept`である。これらの指定（および`virtual`）は明示的に指定しておくこともできるが、明示的に`constexpr(consteval)`指定する場合は本体が`constexpr`関数の要件を満たしていなければコンパイルエラーとなる。また、あるクラスに対する最初の`default`宣言がクラス内部で行われている場合は暗黙的に`inline`指定される。
+このような`default`宣言はその定義が`constexpr`関数の要件を満たしていれば暗黙的に`constexpr`指定され、呼び出す演算子が全て`noexcept`であるならば暗黙的に`noexcept`である。これらの指定（および`virtual, consteval`）は明示的に指定しておくこともできるが、明示的に`constexpr(consteval)`指定する場合は本体が`constexpr`関数の要件を満たしていなければコンパイルエラーとなる。また、あるクラスに対する最初の`default`宣言がクラス内部で行われている場合は暗黙的に`inline`指定される。
 
-`default`指定された三方比較演算子の戻り値型は基底クラス及び全メンバの`&amp;lt;=&amp;gt;`の結果型の共通比較カテゴリ型となるが、その型が`void`である場合は暗黙的に`delete`される。
+`default`指定された三方比較演算子の戻り値型は基底クラス及び全メンバの`&amp;lt;=&amp;gt;`の結果型の共通比較カテゴリ型となるが、その中に比較カテゴリ型を返さない`&amp;lt;=&amp;gt;`による比較がある場合は暗黙的に`delete`される。
 
 `delete`されていない全ての`default`比較演算子は、通常の特殊メンバ関数と同様にODR使用された時あるいは定数式で評価された時に、最初の`default`宣言の位置で暗黙的に定義される（詳細は「評価されない文脈で`constexpr`関数が定数式評価されることを規定」を参照）。
 
 #### operator==の暗黙宣言
 
-上記のように`&amp;lt;=&amp;gt;`が`default`宣言されていて`==`メンバ/`friend`関数が一つも宣言されていない場合、その`&amp;lt;=&amp;gt;`に対応する`==`の`default`宣言が暗黙的に行われる。
+上記のように`&amp;lt;=&amp;gt;`が`default`宣言されていて`operator==`メンバ/`friend`関数が一つも宣言されていない場合、その`&amp;lt;=&amp;gt;`に対応する`==`の`default`宣言が暗黙的に行われる。
 
-そのような暗黙宣言は対応する`&amp;lt;=&amp;gt;`の直後で、対応する`&amp;lt;=&amp;gt;`の宣言の戻り値型を`bool`、名前を`operator==`に置き換えたように宣言される。すなわち、対応する`&amp;lt;=&amp;gt;`に指定されているあらゆるプロパティを全て継承する。ただし、結果的な例外指定だけは異なる可能性がある。
+そのような暗黙宣言は対応する`&amp;lt;=&amp;gt;`の直後で、その`&amp;lt;=&amp;gt;`宣言の戻り値型を`bool`、名前を`operator==`に置き換えたように宣言される。すなわち、対応する`&amp;lt;=&amp;gt;`に指定されているあらゆるプロパティを全て継承する。ただし、結果的な例外指定だけは異なる可能性がある。
 
 `&amp;lt;=&amp;gt;`の`default`宣言に伴う暗黙の`==`宣言の例。
 
@@ -348,15 +327,14 @@ struct X {
 };
 ```
 
-このような`==`の暗黙宣言は、対応する`&amp;lt;=&amp;gt;`が暗黙的あるいは明示的に`delete`されている場合でも宣言される。
+このような`==`の暗黙宣言は、対応する`&amp;lt;=&amp;gt;`が暗黙的に`delete`されている場合でも宣言される。
 
 #### default実装
 default宣言された`&amp;lt;=&amp;gt; ==`演算子はその基底クラスと非静的メンバを宣言順に比較していくことで実装される。
 
-その手順は以下のようになる（演算子`@`は`&amp;lt;=&amp;gt; ==`のどちらかとする）。
+その手順は以下のようになる（演算子`@`は`&amp;lt;=&amp;gt; ==`のどちらか）。
 
 1. 基底クラスの`@`を呼び出して比較を行う。その順番は継承順（`:`の後ろに書いてある型を左から右）、深さ優先で比較される。
-    - この時、仮想基底クラスが複数回比較されるかは未規定。
 2. 宣言された順番（上から下）で非静的メンバを`@`によって比較する。
     - この時、配列は要素ごとに比較する。
 3. これらの比較の際、結果が`0`（`==`なら`true`）とならない時点でその結果を返して終了する。
@@ -485,7 +463,7 @@ struct newer {
 `&amp;lt;=&amp;gt; ==`だけでなく、残りの比較演算子もdefault指定で宣言することができる。その有効な宣言は`==`に従う。  
 そのようなdefault実装はオーバーロード解決時に生成される式と同様の式を使って`&amp;lt;=&amp;gt; ==`から実装される。
 
-ただし次のいずれかの場合、演算子`@`の`default`宣言は暗黙的に`delete`される（オーバーロード候補生成時はコンパイルエラーとなる場合でも単に`delete`される）。
+ただし次のいずれかの場合、演算子`@`（`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;= !=`のいずれか）の`default`宣言は暗黙的に`delete`される（オーバーロード候補生成時はコンパイルエラーとなる場合でも単に`delete`される）。
 
 - `x @ y`のオーバーロード解決の結果、使用可能な候補が見つからない
     - `@`の生成に使用する`&amp;lt;=&amp;gt; ==`演算子が使用可能ではない
@@ -835,6 +813,8 @@ struct has_vector {
         - `&amp;lt;=&amp;gt; ==`の`friend`な`default`宣言の調整
     11. [P2085R0 Consistent defaulted comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2085r0.html)
         - `&amp;lt;=&amp;gt; ==`の`default`宣言をクラス外でも行えるようにする
+    12. [P2002R1 Defaulted comparison specification cleanups](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2002r1.html)
+        - デフォルト比較についての仕様のクリーンアップ、暗黙`delete`されるときを明確にしたり仕様の空白を埋めるなどの調整
 - 以前に検討されていた提案文書
     - [N3950 Defaulted comparison operators](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3950.html)
     - [N4114 Defaulted comparison operators](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4114.htm)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>一貫比較 -- 一貫比較 : p2002r1の内容追記 #786</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html"/>
      <id>78ba670f2005a7a220d2819d454c89fd01d8b2ac:lang/cpp20/consistent_comparison.md</id>
      <updated>2020-07-31T22:57:34+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/consistent_comparison.md b/lang/cpp20/consistent_comparison.md
index 51bb41858..2cafc0d75 100644
--- a/lang/cpp20/consistent_comparison.md
+++ b/lang/cpp20/consistent_comparison.md
@@ -117,10 +117,9 @@ bool is_equal = comp == 0.0;
 
 比較に参加するすべての型の`&amp;lt;=&amp;gt;`による比較カテゴリ型をそれぞれ`Ti (0 &amp;lt;= i &amp;lt; N)`として、共通比較カテゴリ型`U`は以下のように決定される。
 
-1. `Ti`の中に一つでも比較カテゴリ型でない型がある場合、`U = void`
-2. `Ti`の中に1つでも`partial_ordering`がある場合、`U = partial_ordering`
-3. `Ti`の中に1つでも`weak_ordering`がある場合、`U = weak_ordering`
-4. それ以外の場合、`U = strong_ordering`（`N == 0`の場合）
+1. `Ti`の中に1つでも`partial_ordering`がある場合、`U = partial_ordering`
+2. `Ti`の中に1つでも`weak_ordering`がある場合、`U = weak_ordering`
+3. それ以外の場合、`U = strong_ordering`（`N == 0`の場合）
 
 この共通比較カテゴリ型を求めるのは場合によっては困難なので、それを求めるために`&amp;lt;compare&amp;gt;`ヘッダにて[`common_comparison_category&amp;lt;Ts...&amp;gt;`](/reference/compare/common_comparison_category.md)というメタ関数が提供される。
 
@@ -332,7 +331,7 @@ inline bool operator== (const C&amp;amp;, const C&amp;amp;) = default;
 
 上記のように`&amp;lt;=&amp;gt;`が`default`宣言されていて`==`メンバ/`friend`関数が一つも宣言されていない場合、その`&amp;lt;=&amp;gt;`に対応する`==`の`default`宣言が暗黙的に行われる。
 
-そのような暗黙宣言は対応する`&amp;lt;=&amp;gt;`の直後で、対応する`&amp;lt;=&amp;gt;`の宣言の戻り値型を`bool`、名前を`operator==`に置き換えた形で宣言される。すなわち、対応する`&amp;lt;=&amp;gt;`に指定されているあらゆるプロパティを全て継承する。ただし、結果的な例外指定だけは異なる可能性がある。
+そのような暗黙宣言は対応する`&amp;lt;=&amp;gt;`の直後で、対応する`&amp;lt;=&amp;gt;`の宣言の戻り値型を`bool`、名前を`operator==`に置き換えたように宣言される。すなわち、対応する`&amp;lt;=&amp;gt;`に指定されているあらゆるプロパティを全て継承する。ただし、結果的な例外指定だけは異なる可能性がある。
 
 `&amp;lt;=&amp;gt;`の`default`宣言に伴う暗黙の`==`宣言の例。
 
@@ -340,11 +339,11 @@ inline bool operator== (const C&amp;amp;, const C&amp;amp;) = default;
 template&amp;lt;typename T&amp;gt;
 struct X {
   friend constexpr std::partial_ordering operator&amp;lt;=&amp;gt;(X, X) requires (sizeof(T) != 1) = default;
-  //暗黙宣言は次のようになる
+  //対応する==の暗黙宣言は次のようになる
   //friend constexpr bool operator==(X, X) requires (sizeof(T) != 1) = default;
 
   [[nodiscard]] virtual std::strong_ordering operator&amp;lt;=&amp;gt;(const X&amp;amp;) const = default;
-  //暗黙宣言は次のようになる
+  //対応する==の暗黙宣言は次のようになる
   //[[nodiscard]] virtual bool operator==(const X&amp;amp;) const = default;
 };
 ```
@@ -399,7 +398,18 @@ public:
 };
 ```
 
-この時、使用可能な`&amp;lt;=&amp;gt; ==`演算子が見つからない場合、およびメンバに参照型を持つか1つ以上のメンバ変数を持つ匿名共用体を含む、もしくはその型が1つ以上のメンバ変数を持つ共用体である場合は宣言された全ての比較演算子の`default`宣言は暗黙的に`delete`される（下記のその他演算子の`default`宣言も含む）。
+ただし、次のいずれかに該当する場合には`&amp;lt;=&amp;gt; ==`の`default`宣言は暗黙的に`delete`される
+
+- `&amp;lt;=&amp;gt;`は`delete`される
+    - 使用可能な`&amp;lt;=&amp;gt;`演算子が見つからないペアがある
+    - `&amp;lt;=&amp;gt;`による比較が比較カテゴリ型を返さないペアがある
+- `==`は`delete`される
+    - 使用可能な`==`演算子が見つからないペアがある
+    - `==`による比較が`bool`に変換可能な型を返さないペアがある
+- 両方とも`delete`される
+    - 参照型メンバを持つ
+    - 1つ以上のメンバ変数を持つ匿名共用体をメンバに含む
+    - その型が1つ以上のメンバ変数を持つ共用体である
 
 #### default実装における&amp;lt;=&amp;gt;の合成
 
@@ -434,18 +444,17 @@ auto comp = n1 &amp;lt;=&amp;gt; n2;  //ok
 bool eq   = n1 ==  n2;  //ok
 ```
 
-指定された戻り値型を`R`、比較しようとしている`T`の値を`a, b`として、それらの満たす条件によって以下のように`&amp;lt;=&amp;gt;`は合成される。
+`&amp;lt;=&amp;gt;`の`default`宣言に指定された戻り値型を`R`、比較しようとしている対応するメンバの値を`a, b`として、それらの満たす条件によって以下のように`&amp;lt;=&amp;gt;`は合成される。
 
 |条件|合成された`&amp;lt;=&amp;gt;`の式|
 |:-------------|:-------------|
-|`a &amp;lt;=&amp;gt; b`のオーバーロード解決で使用可能な`&amp;lt;=&amp;gt;`が見つかる|`static_cast&amp;lt;R&amp;gt;(a &amp;lt;=&amp;gt; b);`|
-|`R`は`std::strong_ordering`|`a == b ? std::strong_ordering::equal :`&amp;lt;br/&amp;gt;`a &amp;lt; b  ? std::strong_ordering::less :`&amp;lt;br/&amp;gt;`std::strong_ordering::greater;`|
-|`R`は`std::weak_ordering`|`a == b ? std::weak_ordering::equivalent :`&amp;lt;br/&amp;gt;`a &amp;lt; b  ? std::weak_ordering::less :`&amp;lt;br/&amp;gt;`std::weak_ordering::greater;`|
-|`R`は`std::partial_ordering`|`a == b ? std::partial_ordering::equivalent :`&amp;lt;br/&amp;gt;`a &amp;lt; b  ? std::partial_ordering::less :`&amp;lt;br/&amp;gt;`b &amp;lt; a  ? std::partial_ordering::greater;`&amp;lt;br/&amp;gt;`std::partial_ordering::unordered`|
+|`a &amp;lt;=&amp;gt; b`が使用可能|`static_cast&amp;lt;R&amp;gt;(a &amp;lt;=&amp;gt; b);`|
+|`R`は`std::strong_ordering`であり、`a == b, a &amp;lt; b`がいずれも使用可能|`a == b ? std::strong_ordering::equal :`&amp;lt;br/&amp;gt;`a &amp;lt; b  ? std::strong_ordering::less :`&amp;lt;br/&amp;gt;`std::strong_ordering::greater;`|
+|`R`は`std::weak_ordering`であり、`a == b, a &amp;lt; b`がいずれも使用可能|`a == b ? std::weak_ordering::equivalent :`&amp;lt;br/&amp;gt;`a &amp;lt; b  ? std::weak_ordering::less :`&amp;lt;br/&amp;gt;`std::weak_ordering::greater;`|
+|`R`は`std::partial_ordering`であり、`a == b, a &amp;lt; b`がいずれも使用可能|`a == b ? std::partial_ordering::equivalent :`&amp;lt;br/&amp;gt;`a &amp;lt; b  ? std::partial_ordering::less :`&amp;lt;br/&amp;gt;`b &amp;lt; a  ? std::partial_ordering::greater;`&amp;lt;br/&amp;gt;`std::partial_ordering::unordered`|
 |どれにも当てはまらない|定義されない|
 
-戻り値型に`auto`を指定した際は、共通比較カテゴリ型を`R`として1つ目（1番上）のように`&amp;lt;=&amp;gt;`が合成されている。  
-また、1つ目の条件により合成される際は`a &amp;lt;=&amp;gt; b`の戻り値型が`R`に変換できない場合はコンパイルエラーとなる。
+この合成された式を用いて`&amp;lt;=&amp;gt;`の`default`実装を行う時、合成された式が定義されない（上記条件に当てはまらない）ペアがある場合はその`&amp;lt;=&amp;gt;`の`default`宣言は暗黙的に`delete`される。
 
 先ほどの`newer`に対して明示的に書くと以下のようになる。
 ```cpp
@@ -469,26 +478,33 @@ struct newer {
 };
 ```
 
-この合成において使用される`&amp;lt; ==`演算子の戻り値型の妥当性はチェックされない。仮に`bool`ではなかったとしても、合成された式においてコンパイルエラーが発生しなければ`&amp;lt;=&amp;gt;`の合成はつつがなく行われる。  
-また、合成された`&amp;lt;=&amp;gt;`が定義されない（上記条件のいずれも当てはまらない）場合はdefault指定の`&amp;lt;=&amp;gt;`は暗黙にdeleteされる。
+この合成において使用される`&amp;lt; ==`演算子の戻り値型の妥当性はチェックされない。仮に`bool`ではなかったとしても、合成された式においてコンパイルエラーが発生しなければ`&amp;lt;=&amp;gt;`の合成はつつがなく行われる。逆に言うと、合成された式がコンパイルエラーを起こす場合はハードエラーとなる。
 
 #### その他の比較演算子のdefault宣言
-`&amp;lt;=&amp;gt; ==`だけでなく、残りの比較演算子もdefault指定で宣言することができる。その有効な宣言は`&amp;lt;=&amp;gt; ==`に従う。
 
+`&amp;lt;=&amp;gt; ==`だけでなく、残りの比較演算子もdefault指定で宣言することができる。その有効な宣言は`==`に従う。  
 そのようなdefault実装はオーバーロード解決時に生成される式と同様の式を使って`&amp;lt;=&amp;gt; ==`から実装される。
 
-`&amp;lt;=&amp;gt; ==`演算子が使用可能ではない場合や`&amp;lt;=&amp;gt;`の戻り値型が対象の演算子を生成できない場合、`==`の戻り値型が`bool`ではない場合はそのdefault宣言は暗黙的に`delete`される（オーバーロード候補生成時はコンパイルエラーとなる場合でも単にdeleteされる）。
+ただし次のいずれかの場合、演算子`@`の`default`宣言は暗黙的に`delete`される（オーバーロード候補生成時はコンパイルエラーとなる場合でも単に`delete`される）。
+
+- `x @ y`のオーバーロード解決の結果、使用可能な候補が見つからない
+    - `@`の生成に使用する`&amp;lt;=&amp;gt; ==`演算子が使用可能ではない
+    - `@`の生成に使用する`&amp;lt;=&amp;gt;`の戻り値型が比較カテゴリ型ではない
+    - `@`（`!=`）の生成に使用する`==`の戻り値型が`bool`ではない
+- `x @ y`のオーバーロード解決の結果、生成された式ではない演算子が見つかった
+    - `operator@`がすでに定義されている
 
 ```cpp
 struct C {
-
+  // 戻り値型のおかしい&amp;lt;=&amp;gt;
   bool operator&amp;lt;=&amp;gt;(const C&amp;amp;) const { return true; }
+  // 正常な==
+  bool operator==(const C&amp;amp;) const = default;
 
   bool operator&amp;lt;(const C&amp;amp;) const = default;  //ok、暗黙的にdeleteされる
 
-  bool operator!=(const C&amp;amp;) const = default;  //ok、使用可能
+  bool operator!=(const C&amp;amp;) const = default;  //ok、使用可能（ただし、==が明示的に宣言されている必要がある）
 };
-
 ```
 
 これは、比較演算子のアドレスを取りたいときに使用する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>mona-@live.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>一貫比較 -- 一貫比較 : p2002r1の内容追記（途中） #786</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/consistent_comparison.html"/>
      <id>8701b6e6f65860994b98cf7e0a023e2d2b9020bf:lang/cpp20/consistent_comparison.md</id>
      <updated>2020-07-31T18:36:16+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/consistent_comparison.md b/lang/cpp20/consistent_comparison.md
index 1dab324d4..51bb41858 100644
--- a/lang/cpp20/consistent_comparison.md
+++ b/lang/cpp20/consistent_comparison.md
@@ -293,7 +293,7 @@ bool eq2 = a == category::C;  //ok
 ここまでにも説明せずに登場していたが、あるクラス型に対する`&amp;lt;=&amp;gt;`および`==`演算子は`default`指定することができる。  
 そうした場合、コンパイラによってそのクラスの基底及び全メンバの宣言順の辞書式比較を行う実装が暗黙に定義される。
 
-あるクラス`C`に対する`&amp;lt;=&amp;gt; ==`の`default`指定できる宣言は、`C`の関数テンプレートでないメンバとして宣言されていて、かつ`const C&amp;amp;`型の1つの引数をもつ非静的constメンバ関数であるか、`const C&amp;amp;`型か`C`型の2つの引数を持つ`C`の`friend`関数、である必要がある。  
+あるクラス`C`に対する`&amp;lt;=&amp;gt; ==`の`default`指定できる宣言は、`C`の関数テンプレートでないメンバとして宣言されていて、かつ`const C&amp;amp;`型の1つの引数をもつ非静的`const`メンバ関数（`volatile`および参照修飾は許可されない）であるか、`const C&amp;amp;`型か`C`型の2つの引数を持つ`C`の`friend`関数、である必要がある。  
 つまり以下の様な宣言が有効である。
 
 ```cpp
@@ -322,12 +322,34 @@ inline auto operator&amp;lt;=&amp;gt;(const C&amp;amp;, const C&amp;amp;) = default;
 inline bool operator== (const C&amp;amp;, const C&amp;amp;) = default;
 ```
 
-`&amp;lt;=&amp;gt;`をdefault宣言した場合、対応する`==`が暗黙的にdefault宣言される。そのアクセス指定は同一であり、`friend`であるかも`&amp;lt;=&amp;gt;`に従う。  
-そして、このようなdefault宣言はその定義が`constexpr`関数の要件を満たしていれば暗黙的に`constexpr`指定され、呼び出す演算子が全て`noexcept`であるならば暗黙的に`noexcept`である（これらの指定は明示的に指定しておくこともできる）。
+このような`default`宣言はその定義が`constexpr`関数の要件を満たしていれば暗黙的に`constexpr`指定され、呼び出す演算子が全て`noexcept`であるならば暗黙的に`noexcept`である。これらの指定（および`virtual`）は明示的に指定しておくこともできるが、明示的に`constexpr(consteval)`指定する場合は本体が`constexpr`関数の要件を満たしていなければコンパイルエラーとなる。また、あるクラスに対する最初の`default`宣言がクラス内部で行われている場合は暗黙的に`inline`指定される。
 
-`default`指定された三方比較演算子の戻り値型は基底クラス及び全メンバの`&amp;lt;=&amp;gt;`の結果型の共通比較カテゴリ型となるが、その型が`void`である場合は暗黙的に`delete`される。  
-その際、暗黙宣言される`==`演算子は定義可能（比較に参加するすべての型について`==`の呼び出しが適格）ならば`default`で宣言される。
+`default`指定された三方比較演算子の戻り値型は基底クラス及び全メンバの`&amp;lt;=&amp;gt;`の結果型の共通比較カテゴリ型となるが、その型が`void`である場合は暗黙的に`delete`される。
 
+`delete`されていない全ての`default`比較演算子は、通常の特殊メンバ関数と同様にODR使用された時あるいは定数式で評価された時に、最初の`default`宣言の位置で暗黙的に定義される（詳細は「評価されない文脈で`constexpr`関数が定数式評価されることを規定」を参照）。
+
+#### operator==の暗黙宣言
+
+上記のように`&amp;lt;=&amp;gt;`が`default`宣言されていて`==`メンバ/`friend`関数が一つも宣言されていない場合、その`&amp;lt;=&amp;gt;`に対応する`==`の`default`宣言が暗黙的に行われる。
+
+そのような暗黙宣言は対応する`&amp;lt;=&amp;gt;`の直後で、対応する`&amp;lt;=&amp;gt;`の宣言の戻り値型を`bool`、名前を`operator==`に置き換えた形で宣言される。すなわち、対応する`&amp;lt;=&amp;gt;`に指定されているあらゆるプロパティを全て継承する。ただし、結果的な例外指定だけは異なる可能性がある。
+
+`&amp;lt;=&amp;gt;`の`default`宣言に伴う暗黙の`==`宣言の例。
+
+```cpp
+template&amp;lt;typename T&amp;gt;
+struct X {
+  friend constexpr std::partial_ordering operator&amp;lt;=&amp;gt;(X, X) requires (sizeof(T) != 1) = default;
+  //暗黙宣言は次のようになる
+  //friend constexpr bool operator==(X, X) requires (sizeof(T) != 1) = default;
+
+  [[nodiscard]] virtual std::strong_ordering operator&amp;lt;=&amp;gt;(const X&amp;amp;) const = default;
+  //暗黙宣言は次のようになる
+  //[[nodiscard]] virtual bool operator==(const X&amp;amp;) const = default;
+};
+```
+
+このような`==`の暗黙宣言は、対応する`&amp;lt;=&amp;gt;`が暗黙的あるいは明示的に`delete`されている場合でも宣言される。
 
 #### default実装
 default宣言された`&amp;lt;=&amp;gt; ==`演算子はその基底クラスと非静的メンバを宣言順に比較していくことで実装される。
@@ -377,7 +399,7 @@ public:
 };
 ```
 
-この時、使用可能な`&amp;lt;=&amp;gt; ==`演算子が見つからない場合、およびメンバに参照型を持つか匿名共用体を含む、もしくはその型が共用体である場合は宣言された全ての比較演算子のdefault宣言は暗黙的にdeleteされる（下記のその他演算子のdefault宣言も含む）。
+この時、使用可能な`&amp;lt;=&amp;gt; ==`演算子が見つからない場合、およびメンバに参照型を持つか1つ以上のメンバ変数を持つ匿名共用体を含む、もしくはその型が1つ以上のメンバ変数を持つ共用体である場合は宣言された全ての比較演算子の`default`宣言は暗黙的に`delete`される（下記のその他演算子の`default`宣言も含む）。
 
 #### default実装における&amp;lt;=&amp;gt;の合成
 
@@ -481,7 +503,7 @@ struct C {
 |`bool`|`std::strong_ordering`|`bool`同士でしか比較不可|
 |[`整数型`](/reference/type_traits/is_integral.md)|`std::strong_ordering`|縮小変換が行われる場合は比較不可|
 |[`浮動小数点型`](/reference/type_traits/is_floating_point.md)|`std::partial_ordering`|縮小変換が行われる場合は比較不可&amp;lt;br/&amp;gt;`NaN`や`±0.0`の存在のため半順序|
-|オブジェクトポインタ|`std::strong_ordering`|あらゆるポインタ変換が施された後、同じポインタ型にならなければ比較不可&amp;lt;br/&amp;gt;配列と配列は比較不可|
+|オブジェクトポインタ|`std::strong_ordering`|あらゆるポインタ変換が施された後、同じポインタ型にならなければ比較不可&amp;lt;br/&amp;gt;配列と配列は比較不可&amp;lt;br/&amp;gt;どちらかの引数が整数型やヌルポインタ定数である場合も比較不可|
 |列挙型|`std::strong_ordering`|スコープ有無に関わらず同じ列挙型同士でしか比較不可|
 
 なお、参照型に対する`&amp;lt;=&amp;gt;`による比較は参照先の型による比較になる。
@@ -497,7 +519,7 @@ struct C {
 |列挙型と算術型|〇&amp;lt;br/&amp;gt;例えば、列挙型と浮動小数点型の比較が可能|△&amp;lt;br/&amp;gt;スコープ無し列挙型と整数型のみ可能|△&amp;lt;br/&amp;gt;列挙型と浮動小数点型間比較は不可&amp;lt;br/&amp;gt;それ以外は従来通り|
 |異なる列挙型間|〇|×|×|
 |配列同士|△&amp;lt;br/&amp;gt;先頭要素へのポインタの比較になる|×|×|
-|ヌルポインタ定数とポインタ|△&amp;lt;br/&amp;gt;同値比較のみ可能|〇&amp;lt;br/&amp;gt;ただし、ポインタ側がヌルでない場合の結果は未規定|△（従来通り）|
+|ヌルポインタ定数とポインタ|△&amp;lt;br/&amp;gt;同値比較のみ可能|×|△（従来通り）|
 
 ## C++17までの比較演算子実装の一例
 ```cpp example
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>type_identity -- type_identity: 例示コード追加</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/type_identity.html"/>
      <id>ab0ee1006c7bed864342e0b8c2d8a9d58c937f9a:reference/type_traits/type_identity.md</id>
      <updated>2020-07-31T13:39:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/type_identity.md b/reference/type_traits/type_identity.md
index deee65442..568e40024 100644
--- a/reference/type_traits/type_identity.md
+++ b/reference/type_traits/type_identity.md
@@ -54,7 +54,7 @@ int main()
 ```
 ```
 
-### 型推論の無効化
+### 型推論の無効化(1)
 ```cpp example
 #include &amp;lt;type_traits&amp;gt;
 
@@ -77,6 +77,43 @@ int main()
 ```
 * std::type_identity_t[color ff0000]
 
+### 型推論の無効化(2)
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+
+template &amp;lt;typename T&amp;gt;
+void h1(T a, T b)
+{
+  std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl;
+}
+
+template &amp;lt;typename T&amp;gt;
+void h2(T a, std::type_identity_t&amp;lt;T&amp;gt; b)
+{
+  std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl;
+}
+
+int main()
+{
+#if 0
+  // Tの型推論がintとdoubleで曖昧となるためコンパイルエラー
+  h1(100, 3.14);
+#endif
+    
+  // 第1引数(int)からのみTの型推論を行う
+  // 第2引数はdouble→intに変換される(3.14→3)
+  h2(100, 3.14);
+}
+```
+* std::type_identity_t[color ff0000]
+
+#### 出力
+```
+100 3
+```
+
+
 ## バージョン
 ### 言語
 - C++20
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>丸カッコの値リストからの集成体初期化を許可 -- 経緯の説明を拡充 #781</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.html"/>
      <id>8d2ac510c93c1215f4e220a507b95665e6fa13b5:lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md</id>
      <updated>2020-07-26T05:01:28+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
index 29079e510..eaac54322 100644
--- a/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
+++ b/lang/cpp20/allow_initializing_aggregates_from_a_parenthesized_list_of_values.md
@@ -84,7 +84,19 @@ int main()
 
 [一様初期化](/lang/cpp11/uniform_initialization.md)によって波カッコは集成体初期化にもコンストラクタ呼び出しにも使えるようになった。一方、丸カッコで集成体初期化をすることはできなかったので、波カッコと丸カッコでできることが異なってしまっていた。
 
-当初は誰もが波カッコで初期化をするようになるから問題がないと考えられていたが、実際にはそうはならず、丸カッコで初期化するためだけにコンストラクターを書くことが続いていた。
+当初は誰もが波カッコで初期化をするようになるから問題がないと考えられていたが、実際にはそうはなっていない。
+
+データメンバを順番通りに引数で受け取り、初期化するだけのコンストラクタを考える。
+
+```cpp
+struct A {
+  int x,y;
+  constexpr A(int x, int y) noexcept : x{x}, y{y} {}
+};
+```
+
+このクラスの場合はコンストラクタを定義せずとも波カッコによる集成体初期化が可能であるから、波カッコで初期化するのであればコンストラクタを定義する必要はない。
+しかし、現実には丸カッコで初期化をしたいためにこのようなコンストラクタを書いてしまうことが多かった。
 
 丸カッコで集成体初期化を可能にすることで両者の差はより少なくなり、コンストラクタを書かなければいけない場面もより少なくなる。
 集成体初期化なのかコンストラクタ呼び出しなのかを意識せずに済むよう、丸カッコによる集成体初期化は丸カッコによるコンストラクタ呼び出しに近い意味論になっている。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Tetsuro Matsumura</name>
        <email>matsumura.t.lab@gmail.com</email>
      </author>
    </entry>
  
</feed>