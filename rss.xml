<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2020-11-25T14:35:20.883653</updated>
  <id>29030fc6-1a82-4ebc-9c10-9cb0b077050d</id>

  
    <entry>
      <title>variant_alternative -- variant_size, variant_alternative : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant_alternative.html"/>
      <id>fb2a6a91cfbb622788c45e2c8d02c89022045145:reference/variant/variant_alternative.md</id>
      <updated>2020-11-25T18:14:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant_alternative.md b/reference/variant/variant_alternative.md
index 7c38bb42a..5d3e11d5d 100644
--- a/reference/variant/variant_alternative.md
+++ b/reference/variant/variant_alternative.md
@@ -7,23 +7,25 @@
 ```cpp
 namespace std {
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative;                       // (1) 先行宣言
+  struct variant_alternative;                       // (1) C++17 先行宣言
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, const T&amp;gt;;           // (2)
+  struct variant_alternative&amp;lt;I, const T&amp;gt;;           // (2) C++17
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, volatile T&amp;gt;;        // (3)
+  struct variant_alternative&amp;lt;I, volatile T&amp;gt;;        // (3) C++17
+                                                    // C++20で非推奨
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  struct variant_alternative&amp;lt;I, const volatile T&amp;gt;;  // (4)
+  struct variant_alternative&amp;lt;I, const volatile T&amp;gt;;  // (4) C++17
+                                                    // C++20で非推奨
 
   template &amp;lt;std::size_t I, class T&amp;gt;
   using variant_alternative_t =
-    typename variant_alternative&amp;lt;I, T&amp;gt;::type;       // (5)
+    typename variant_alternative&amp;lt;I, T&amp;gt;::type;       // (5) C++17
 
   template &amp;lt;std::size_t I, class... Types&amp;gt;
-  struct variant_alternative&amp;lt;I, variant&amp;lt;Types...&amp;gt;&amp;gt;; // (6)
+  struct variant_alternative&amp;lt;I, variant&amp;lt;Types...&amp;gt;&amp;gt;; // (6) C++17
 }
 ```
 * variant[link variant.md]
@@ -50,6 +52,10 @@ namespace std {
 - (6) : `std::variant&amp;lt;Types...&amp;gt;`の`Types...`のうち、`I`番目の型`T`を取得し、その型をメンバ型`type`とする
 
 
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
+
+
 ## 例
 ```cpp example
 #include &amp;lt;variant&amp;gt;
@@ -120,3 +126,11 @@ int main()
 - [Clang](/implementation.md#clang): 4.0
 - [GCC](/implementation.md#gcc): 7.3
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>variant_size -- variant_size, variant_alternative : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/variant/variant_size.html"/>
      <id>fb2a6a91cfbb622788c45e2c8d02c89022045145:reference/variant/variant_size.md</id>
      <updated>2020-11-25T18:14:19+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/variant/variant_size.md b/reference/variant/variant_size.md
index d21b0cb71..47ffda0ab 100644
--- a/reference/variant/variant_size.md
+++ b/reference/variant/variant_size.md
@@ -6,19 +6,27 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class T&amp;gt; struct variant_size;                   // (1) 先行宣言
+  template &amp;lt;class T&amp;gt;
+  struct variant_size;                   // (1) C++17 先行宣言
 
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;const T&amp;gt;;          // (2)
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;volatile T&amp;gt;;       // (3)
-  template &amp;lt;class T&amp;gt; struct variant_size&amp;lt;const volatile T&amp;gt;; // (4)
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;const T&amp;gt;;          // (2) C++17
+
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;volatile T&amp;gt;;       // (3) C++17
+                                         // C++20で非推奨
+
+  template &amp;lt;class T&amp;gt;
+  struct variant_size&amp;lt;const volatile T&amp;gt;; // (4) C++17
+                                         // C++20で非推奨
 
   template &amp;lt;class T&amp;gt;
   inline constexpr size_t variant_size_v
-    = variant_size&amp;lt;T&amp;gt;::value;                               // (5)
+    = variant_size&amp;lt;T&amp;gt;::value;            // (5) C++17
 
   template&amp;lt;class... Types&amp;gt;
   struct variant_size&amp;lt;variant&amp;lt;Types...&amp;gt;&amp;gt;
-    : integral_constant&amp;lt;std::size_t, sizeof...(Types)&amp;gt; {};  // (6)
+    : integral_constant&amp;lt;std::size_t, sizeof...(Types)&amp;gt; {}; // (6) C++17
 }
 ```
 * variant[link variant.md]
@@ -38,6 +46,10 @@ namespace std {
 - (6) : 修飾なしの[`std::variant`](variant.md)型の、候補型の数を取得する
 
 
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
+
+
 ## 例
 ```cpp example
 #include &amp;lt;variant&amp;gt;
@@ -55,16 +67,6 @@ int main()
     const std::variant&amp;lt;int, std::string, double&amp;gt;
   &amp;gt;::value == 3);
 
-  // (3) volatile修飾付きのstd::variant型の、候補型の数を取得する
-  static_assert(std::variant_size&amp;lt;
-    volatile std::variant&amp;lt;int, std::string, double&amp;gt;
-  &amp;gt;::value == 3);
-
-  // (4) const volatile修飾付きのstd::variant型の、候補型の数を取得する
-  static_assert(std::variant_size&amp;lt;
-    const volatile std::variant&amp;lt;int, std::string, double&amp;gt;
-  &amp;gt;::value == 3);
-
   // (5) 変数テンプレート版
   static_assert(std::variant_size_v&amp;lt;
     std::variant&amp;lt;int, std::string, double&amp;gt;
@@ -87,3 +89,11 @@ int main()
 - [Clang](/implementation.md#clang): 4.0
 - [GCC](/implementation.md#gcc): 7.3
 - [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
+## 参照
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_element -- tuple_element, tuple_size : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_element.html"/>
      <id>01bd2a73ba54793a4e96fef216dfa05a7e255b56:reference/tuple/tuple_element.md</id>
      <updated>2020-11-25T18:07:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_element.md b/reference/tuple/tuple_element.md
index 65f5e96e1..030778847 100644
--- a/reference/tuple/tuple_element.md
+++ b/reference/tuple/tuple_element.md
@@ -6,20 +6,29 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element; // 宣言のみで定義なし
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element;                        // (1) C++11 宣言のみで定義なし
 
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const T&amp;gt;;
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, volatile T&amp;gt;;
-  template &amp;lt;std::size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const volatile T&amp;gt;;
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, const T&amp;gt;;            // (2) C++11
+
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, volatile T&amp;gt;;         // (3) C++11
+                                              // C++20で非推奨
+
+  template &amp;lt;std::size_t I, class T&amp;gt;
+  class tuple_element&amp;lt;I, const volatile T&amp;gt;;   // (4) C++11
+                                              // C++20で非推奨
 
   template &amp;lt;std::size_t I, class... Types&amp;gt;
-  class tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt; {
+  class tuple_element&amp;lt;I, tuple&amp;lt;Types...&amp;gt;&amp;gt; {   // (5) C++11
   public:
     using type = TI;
   };
 
   template &amp;lt;std::size_t I, class T&amp;gt;
-  using tuple_element_t = typename tuple_element&amp;lt;I, T&amp;gt;::type; // C++14
+  using tuple_element_t =
+    typename tuple_element&amp;lt;I, T&amp;gt;::type;       // (6) C++14
 }
 ```
 * tuple[link tuple.md]
@@ -29,19 +38,16 @@ namespace std {
 
 `tuple_element`の第1テンプレート引数に要素番号、第2引数のタプルの型を指定し、ネスト型である`type`型を取り出すことで要素型を得ることができる。
 
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element;`
-
-    特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素型を取得しようとする段階でコンパイルエラーとなる。
-
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const T&amp;gt;;`
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, volatile T&amp;gt;;`
-- `template &amp;lt;size_t I, class T&amp;gt; class tuple_element&amp;lt;I, const volatile T&amp;gt;;`
-
-    CV修飾された型からも要素型を取得できるようにするための部分特殊化。
+- (1) : 特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素型を取得しようとする段階でコンパイルエラーとなる
+- (2) : `const`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (3) : `volatile`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (4) : `const volatile`修飾された型からも要素型を取得できるようにするための部分特殊化
+- (5) : `std::tuple`から要素型を取得できるようにするための部分特殊化
+- (6) : エイリアステンプレート版
 
-- `template &amp;lt;size_t I, class... Types&amp;gt; class tuple_element&amp;lt;I,` [`tuple`](tuple.md)`&amp;lt;Tuples...&amp;gt;&amp;gt;;`
 
-    `std::tuple`から要素型を取得できるようにするための部分特殊化。
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
 
 
 ## 例
@@ -71,18 +77,6 @@ int main()
                   std::tuple_element&amp;lt;0, const std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
                   const int
                 &amp;gt;::value, &amp;#34;&amp;#34;);
-
-  // volatile修飾
-  static_assert(std::is_same&amp;lt;
-                  std::tuple_element&amp;lt;0, volatile std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
-                  volatile int
-                &amp;gt;::value, &amp;#34;&amp;#34;);
-
-  // const, volatile修飾
-  static_assert(std::is_same&amp;lt;
-                  std::tuple_element&amp;lt;0, const volatile std::tuple&amp;lt;int, char, double&amp;gt;&amp;gt;::type,
-                  const volatile int
-                &amp;gt;::value, &amp;#34;&amp;#34;);
 }
 ```
 * std::tuple_element[color ff0000]
@@ -103,6 +97,10 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [N3887 Consistent Metafunction Aliases](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3887.pdf)
-
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tuple_size -- tuple_element, tuple_size : volatile版を非推奨化</title>
      <link href="https://cpprefjp.github.io/reference/tuple/tuple_size.html"/>
      <id>01bd2a73ba54793a4e96fef216dfa05a7e255b56:reference/tuple/tuple_size.md</id>
      <updated>2020-11-25T18:07:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/tuple/tuple_size.md b/reference/tuple/tuple_size.md
index a5bec3081..a4c220aee 100644
--- a/reference/tuple/tuple_size.md
+++ b/reference/tuple/tuple_size.md
@@ -6,18 +6,27 @@
 
 ```cpp
 namespace std {
-  template &amp;lt;class T&amp;gt; class tuple_size; // 宣言のみで定義なし
+  template &amp;lt;class T&amp;gt;
+  class tuple_size;                   // (1) C++11 宣言のみで定義なし
 
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const T&amp;gt;;
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;volatile T&amp;gt;;
-  template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const volatile T&amp;gt;;
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;const T&amp;gt;;          // (2) C++11
+
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;volatile T&amp;gt;;       // (3) C++11
+                                      // C++20で非推奨
+
+  template &amp;lt;class T&amp;gt;
+  class tuple_size&amp;lt;const volatile T&amp;gt;; // (4) C++11
+                                      // C++20で非推奨
 
   template &amp;lt;class... Types&amp;gt;
   class tuple_size&amp;lt;tuple&amp;lt;Types...&amp;gt;&amp;gt;
-    : public integral_constant&amp;lt;size_t, sizeof...(Types)&amp;gt; {};
+    : public integral_constant&amp;lt;size_t, sizeof...(Types)&amp;gt; {}; // (5) C++11
 
   template &amp;lt;class T&amp;gt;
-  inline constexpr size_t tuple_size_v = tuple_size&amp;lt;T&amp;gt;::value; // C++17
+  inline constexpr size_t tuple_size_v =
+    tuple_size&amp;lt;T&amp;gt;::value;                                    // (6) C++17
 }
 ```
 * tuple[link tuple.md]
@@ -28,23 +37,22 @@ namespace std {
 
 要素数は、[`integral_constant`](/reference/type_traits/integral_constant.md)の機能を利用してコンパイル時の定数値として取得できる。
 
-- `template &amp;lt;class T&amp;gt; class tuple_size;`
-
-    特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素数を取得しようとする段階でコンパイルエラーとなる。
+- (1) : 特殊化のための先行宣言。特殊化されていない型の場合、定義が行われないため要素数を取得しようとする段階でコンパイルエラーとなる
+- (2) : `const`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (3) : `volatile`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (4) : `const volatile`修飾された型からも要素数を取得できるようにするための部分特殊化
+- (5) : `std::tuple`の要素数を取得できるようにするための部分特殊化
+- (6) : 変数テンプレート版
 
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const T&amp;gt;;`
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;volatile T&amp;gt;;`
-- `template &amp;lt;class T&amp;gt; class tuple_size&amp;lt;const volatile T&amp;gt;;`
 
-    CV修飾された型からも要素数を取得できるようにするための部分特殊化。
+型`T`がタプルと見なせない型であった場合、
 
-- `template &amp;lt;class... Types&amp;gt; class tuple_size&amp;lt;tuple&amp;lt;Types...&amp;gt;&amp;gt;;`
+- C++11 : 仕様で明確に規定されてはいないが、直接的にコンパイルエラーとなる
+- C++17 : メンバ`value`が定義されない (SFINAEと組み合わせて扱える)
 
-    `std::tuple`の要素数を取得できるようにするための部分特殊化。
 
-- 型`T`がタプルと見なせない型であった場合、
-    - C++11 : 仕様で明確に規定されてはいないが、直接的にコンパイルエラーとなる
-    - C++17 : メンバ`value`が定義されない (SFINAEと組み合わせて扱える)
+## 非推奨の詳細
+- (3), (4) : これらの部分特殊化は、型の`volatile`修飾を部分的に非推奨にすることにともなって、非推奨化される
 
 
 ## 例
@@ -54,10 +62,8 @@ namespace std {
 
 int main()
 {
-  static_assert(std::tuple_size&amp;lt;               std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;const          std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;volatile       std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
-  static_assert(std::tuple_size&amp;lt;const volatile std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
+  static_assert(std::tuple_size&amp;lt;      std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
+  static_assert(std::tuple_size&amp;lt;const std::tuple&amp;lt;int, int, int&amp;gt;&amp;gt;::value == 3, &amp;#34;&amp;#34;);
 }
 ```
 * std::tuple_size[color ff0000]
@@ -78,7 +84,12 @@ int main()
 - [Visual C++](/implementation.md#visual_cpp): ??
 
 
+## 関連項目
+- [C++20 ほとんどの`volatile`を非推奨化](/lang/cpp20/cpp20/deprecating_volatile.md.nolink)
+
+
 ## 参照
 - [LWG Issue 2770. `tuple_size&amp;lt;const T&amp;gt;` specialization is not SFINAE compatible and breaks decomposition declarations](https://wg21.cmeerw.net/lwg/issue2770)
     - C++17で[構造化束縛](/lang/cpp17/structured_bindings.md)機能が導入されたことに合わせて、`tuple_size`がSFINAEと組み合わせて使用できるようになった
 - [P0006R0 Adopt Type Traits Variable Templates from Library Fundamentals TS for C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0006r0.html)
+- [P1831R1 Deprecating `volatile`: library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1831r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- リンク再修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/common_iterator/op_equal.html"/>
      <id>6f54156cc0c6fb3bca0d599991ac82eabf84ff92:reference/iterator/common_iterator/op_equal.md</id>
      <updated>2020-11-25T15:41:26+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/common_iterator/op_equal.md b/reference/iterator/common_iterator/op_equal.md
index 0b35e9b51..3b44f3c51 100644
--- a/reference/iterator/common_iterator/op_equal.md
+++ b/reference/iterator/common_iterator/op_equal.md
@@ -22,7 +22,7 @@ namespace std {
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
-* equality_comparable_with[link /reference/concepts/equality_comparable_with.md]
+* equality_comparable_with[link /reference/concepts/equality_comparable.md]
 
 ## 概要
 2つの`common_iterator`オブジェクトが同じ要素を指しているかを判定する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- リンク修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator/common_iterator/op_equal.html"/>
      <id>d5c5a53c42f80bbf0db2677142fccbfd0f6cecfe:reference/iterator/common_iterator/op_equal.md</id>
      <updated>2020-11-25T15:38:48+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/common_iterator/op_equal.md b/reference/iterator/common_iterator/op_equal.md
index 40b39dc1b..0b35e9b51 100644
--- a/reference/iterator/common_iterator/op_equal.md
+++ b/reference/iterator/common_iterator/op_equal.md
@@ -22,7 +22,7 @@ namespace std {
 ```
 * input_or_output_iterator[link /reference/iterator/input_or_output_iterator.md]
 * sentinel_for[link /reference/iterator/sentinel_for.md]
-* equality_comparable_with[link /reference/iterator/equality_comparable_with.md]
+* equality_comparable_with[link /reference/concepts/equality_comparable_with.md]
 
 ## 概要
 2つの`common_iterator`オブジェクトが同じ要素を指しているかを判定する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- thread / packaged_task : 不要なdecayを削除</title>
      <link href="https://cpprefjp.github.io/reference/future/packaged_task/op_constructor.html"/>
      <id>a6d5a15cc5bf6f31df45dcccceb70f2fa71d1926:reference/future/packaged_task/op_constructor.md</id>
      <updated>2020-11-25T15:35:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/packaged_task/op_constructor.md b/reference/future/packaged_task/op_constructor.md
index ed3462d73..f70521e25 100644
--- a/reference/future/packaged_task/op_constructor.md
+++ b/reference/future/packaged_task/op_constructor.md
@@ -48,7 +48,7 @@ packaged_task(packaged_task&amp;amp;&amp;amp; rhs) noexcept;       // (5)
 
 ## 備考
 - (2), (3) :
-    - C++14 : [`std::decay`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;::type`が`std::packaged_task&amp;lt;R(ArgTypes...)&amp;gt;`型である場合、この関数はオーバーロード解決に参加しない。
+    - C++14 : [`std::remove_cvref`](/reference/type_traits/remove_cvref.md)`&amp;lt;F&amp;gt;::type`が`std::packaged_task&amp;lt;R(ArgTypes...)&amp;gt;`型である場合、この関数はオーバーロード解決に参加しない。
 
 
 ## 例
@@ -116,3 +116,4 @@ int main()
 - [LWG Issue 2097. `packaged_task` constructors should be constrained](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2097)
 - [LWG Issue 2921. `packaged_task` and type-erased allocators](https://wg21.cmeerw.net/lwg/issue2921)
     - [`std::function`のコンストラクタ](/reference/functional/function/op_constructor.md)と同様の理由により、アロケータを受け取るコンストラクタを削除
+- [LWG Issue 3039. Unnecessary `decay` in `thread` and `packaged_task`](https://wg21.cmeerw.net/lwg/issue3039)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- thread / packaged_task : 不要なdecayを削除</title>
      <link href="https://cpprefjp.github.io/reference/thread/thread/op_constructor.html"/>
      <id>a6d5a15cc5bf6f31df45dcccceb70f2fa71d1926:reference/thread/thread/op_constructor.md</id>
      <updated>2020-11-25T15:35:47+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/thread/thread/op_constructor.md b/reference/thread/thread/op_constructor.md
index 10cba0c98..b3a740980 100644
--- a/reference/thread/thread/op_constructor.md
+++ b/reference/thread/thread/op_constructor.md
@@ -53,7 +53,7 @@ thread(thread&amp;amp;&amp;amp;) noexcept;              // (4)
 
 ## 備考
 - (2) :
-    - C++14 : [`std::decay`](/reference/type_traits/decay.md)`&amp;lt;F&amp;gt;::type`が`std::thread`型である場合、この関数はオーバーロード解決に参加しない。
+    - C++14 : [`std::remove_cvref`](/reference/type_traits/remove_cvref.md)`&amp;lt;F&amp;gt;::type`が`std::thread`型である場合、この関数はオーバーロード解決に参加しない。
 
 
 ## 例
@@ -111,4 +111,4 @@ int main()
 
 ## 参照
 - [LWG Issue 2097. `packaged_task` constructors should be constrained](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2097)
-
+- [LWG Issue 3039. Unnecessary `decay` in `thread` and `packaged_task`](https://wg21.cmeerw.net/lwg/issue3039)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>