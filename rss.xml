<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2022-12-28T03:21:40.676874</updated>
  <id>a0bdfabb-2bfe-4d7d-9b9a-1276ca62cf05</id>

  
    <entry>
      <title>iterator -- イテレータの図 : URLを修正</title>
      <link href="https://cpprefjp.github.io/reference/iterator.html"/>
      <id>140fd715d8f4c2a2b628575913b288cf09a2e323:reference/iterator.md</id>
      <updated>2022-12-28T12:17:07+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;iterator&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;iterator&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;ヘッダでは、イテレータに関する機能群を提供する。
イテレータは日本語では反復子とも呼ばれ、配列やコンテナのような範囲を横断する手段として使用できる。&lt;/p&gt;
&lt;p&gt;C++標準ライブラリのイテレータは、以下のように階層的に定義される。
この階層はC++言語機能の継承と同じように見なせる。たとえば、入力イテレータと前方向イテレータはis a関係が成り立っており、前方向イテレータは入力イテレータと見なすことができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://raw.github.com/cpprefjp/image/master/reference/iterator/iterators.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;C++20以降の標準ライブラリでは、任意のイテレータに対して可能な操作によって上記5つに隣接イテレータ（&lt;em&gt;contiguous iterator&lt;/em&gt;）を加えた6つのイテレータカテゴリを定義する。それぞれ次のイテレータコンセプトが対応する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入力イテレータ : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/input_iterator.html&#34;&gt;input_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;出力イテレータ : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/output_iterator.html&#34;&gt;output_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;前方向イテレータ : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/forward_iterator.html&#34;&gt;forward_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;双方向イテレータ : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/bidirectional_iterator.html&#34;&gt;bidirectional_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ランダムアクセスイテレータ : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/random_access_iterator.html&#34;&gt;random_access_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;隣接イテレータ : &lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/contiguous_iterator.html&#34;&gt;contiguous_iterator&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このヘッダでは、以下の標準ヘッダをインクルードする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts.html&#34;&gt;&amp;lt;concepts&amp;gt;&lt;/a&gt;&lt;/code&gt; (C++20)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/compare.html&#34;&gt;&amp;lt;compare&amp;gt;&lt;/a&gt;&lt;/code&gt; (C++20)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;イテレータコンセプト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_readable.html&#34;&gt;indirectly_readable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;間接参照によって読み取り可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_writable.html&#34;&gt;indirectly_writable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;間接参照によって書き込み可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/weakly_incrementable.html&#34;&gt;weakly_incrementable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前置/後置インクリメント可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/incrementable.html&#34;&gt;incrementable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;weakly_incrementable&lt;/code&gt;かつ&lt;a href=&#34;https://cpprefjp.github.io/reference/concepts/regular.html&#34;&gt;正則&lt;/a&gt; (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/input_or_output_iterator.html&#34;&gt;input_or_output_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基礎的なイテレータコンセプト (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/sentinel_for.html&#34;&gt;sentinel_for&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同じ範囲についてのイテレータと番兵 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/sized_sentinel_for.html&#34;&gt;sized_sentinel_for&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;距離を定義可能なイテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/disable_sized_sentinel_for.html&#34;&gt;disable_sized_sentinel_for&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sentinel_for&amp;lt;S, I&amp;gt;&lt;/code&gt;について、&lt;code&gt;sized_sentinel_for&lt;/code&gt;を不適合にする (variable template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/input_iterator.html&#34;&gt;input_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/output_iterator.html&#34;&gt;output_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/forward_iterator.html&#34;&gt;forward_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前方向イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/bidirectional_iterator.html&#34;&gt;bidirectional_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双方向イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/random_access_iterator.html&#34;&gt;random_access_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/contiguous_iterator.html&#34;&gt;contiguous_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;隣接イテレータ (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;イテレータを介した関数呼び出しに関するコンセプト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_unary_invocable.html&#34;&gt;indirectly_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの要素型によって呼び出し可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_unary_invocable.html&#34;&gt;indirectly_regular_unary_invocable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正則な&lt;code&gt;indirectly_unary_invocable&lt;/code&gt; (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirect_unary_predicate.html&#34;&gt;indirect_unary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの要素型についての単項述語 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirect_binary_predicate.html&#34;&gt;indirect_binary_predicate&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータの要素型についての二項述語 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirect_equivalence_relation.html&#34;&gt;indirect_equivalence_relation&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータの要素型についての同値関係 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirect_strict_weak_order.html&#34;&gt;indirect_strict_weak_order&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータの要素型についての狭義の弱順序 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;イテレータによるアルゴリズムに関するコンセプト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_movable.html&#34;&gt;indirectly_movable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;片方のイテレータからもう片方のイテレータへ要素をムーブ可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_movable_storable.html&#34;&gt;indirectly_movable_storable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;片方のイテレータからもう片方のイテレータへ中間オブジェクトを介して要素をムーブ可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_copyable.html&#34;&gt;indirectly_copyable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;片方のイテレータからもう片方のイテレータへ要素をコピー可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_copyable_storable.html&#34;&gt;indirectly_copyable_storable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;片方のイテレータからもう片方のイテレータへ中間オブジェクトを介して要素をコピー可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_swappable.html&#34;&gt;indirectly_swappable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータ間で要素を交換可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_comparable.html&#34;&gt;indirectly_comparable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータ間で要素を比較可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/permutable.html&#34;&gt;permutable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを介して要素を並べ替え可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/mergeable.html&#34;&gt;mergeable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを介して範囲をマージ可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/sortable.html&#34;&gt;sortable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを介して範囲をソート可能 (concept)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;イテレータの情報&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iterator_traits.html&#34;&gt;iterator_traits&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータに関する型情報(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iterator.html&#34;&gt;iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを定義するための基底クラス(class template)&lt;/td&gt;
&lt;td&gt;C++17から非推奨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iter_difference_t.html&#34;&gt;iter_difference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの&lt;code&gt;difference_type&lt;/code&gt;を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iter_value_t.html&#34;&gt;iter_value_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの&lt;code&gt;value_type&lt;/code&gt;を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iter_reference_t.html&#34;&gt;iter_reference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの&lt;code&gt;reference_type&lt;/code&gt;を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iter_rvalue_reference_t.html&#34;&gt;iter_rvalue_reference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの指す要素の右辺値参照型を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iter_common_reference_t.html&#34;&gt;iter_common_reference_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの&lt;code&gt;value_type&lt;/code&gt;と&lt;code&gt;reference_type&lt;/code&gt;の&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/type_traits/common_reference.html&#34;&gt;common_reference&lt;/a&gt;&lt;/code&gt;を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirect_result_t.html&#34;&gt;indirect_result_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数呼び出し可能な型&lt;code&gt;F&lt;/code&gt;を複数のイテレータ&lt;code&gt;Is...&lt;/code&gt;によって呼び出した時の戻り値型を取得する (alias template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/projected.html&#34;&gt;projected&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータ&lt;code&gt;I&lt;/code&gt;の&lt;code&gt;Proj&lt;/code&gt;による射影操作の結果を表すことのできる&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_readable.html&#34;&gt;indirectly_readable&lt;/a&gt;&lt;/code&gt;なクラス (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/incrementable_traits.html&#34;&gt;incrementable_traits&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;iter_difference_t&lt;/code&gt;にアダプトするためのカスタマイゼーションポイント (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/indirectly_readable_traits.html&#34;&gt;indirectly_readable_traits&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;iter_value_t&lt;/code&gt;にアダプトするためのカスタマイゼーションポイント (class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iterator_tag.html&#34;&gt;input_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iterator_tag.html&#34;&gt;output_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iterator_tag.html&#34;&gt;forward_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前方向イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iterator_tag.html&#34;&gt;bidirectional_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双方向イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iterator_tag.html&#34;&gt;random_access_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iterator_tag.html&#34;&gt;contiguous_iterator_tag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;隣接イテレータを表すタグ(class)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;イテレータの進行と距離&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/advance.html&#34;&gt;advance&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;回イテレータを進める(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/distance.html&#34;&gt;distance&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータ間の距離を求める(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/next.html&#34;&gt;next&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;回前方に進めたイテレータを返す(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/prev.html&#34;&gt;prev&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;回後方に進めたイテレータを返す(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ranges_advance.html&#34;&gt;ranges::advance&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータを進める(function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ranges_distance.html&#34;&gt;ranges::distance&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の長さを求める(function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ranges_next.html&#34;&gt;ranges::next&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前方に進めたイテレータを返す(function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ranges_prev.html&#34;&gt;ranges::prev&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;後方に進めたイテレータを返す(function template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;逆順イテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/reverse_iterator.html&#34;&gt;reverse_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逆方向に進むイテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/make_reverse_iterator.html&#34;&gt;make_reverse_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;reverse_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;挿入イテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_insert_iterator.html&#34;&gt;back_insert_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;末尾に要素を挿入する出力イテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/back_inserter.html&#34;&gt;back_inserter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;back_insert_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_insert_iterator.html&#34;&gt;front_insert_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;先頭に要素を挿入する出力イテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/front_inserter.html&#34;&gt;front_inserter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;front_insert_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/insert_iterator.html&#34;&gt;insert_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意の位置に要素を挿入する出力イテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/inserter.html&#34;&gt;inserter&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;insert_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;要素を移動するイテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/move_iterator.html&#34;&gt;move_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;間接参照時にムーブするイテレータアダプタ(class template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/make_move_iterator.html&#34;&gt;make_move_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;move_iterator&lt;/code&gt;オブジェクトを作るヘルパ関数(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/move_sentinel.html&#34;&gt;move_sentinel&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;move_iterator&lt;/code&gt;の終端を表す番兵型(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ストリームイテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/istream_iterator.html&#34;&gt;istream_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力ストリームイテレータ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ostream_iterator.html&#34;&gt;ostream_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力ストリームイテレータ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/istreambuf_iterator.html&#34;&gt;istreambuf_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;入力ストリームバッファイテレータ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ostreambuf_iterator.html&#34;&gt;ostreambuf_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;出力ストリームバッファイテレータ(class template)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;その他のイテレータアダプタ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/common_iterator.html&#34;&gt;common_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータ型と番兵型が異なる場合に型を共通化するためのラッパーイテレータ(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/counted_iterator.html&#34;&gt;counted_iterator&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;予め指定された&lt;code&gt;N&lt;/code&gt;個の要素だけをイテレートするラッパーイテレータ(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;番兵型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/default_sentinel_t.html&#34;&gt;default_sentinel_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意の範囲の終端を表すことのできるデフォルトの番兵型(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/default_sentinel_t.html&#34;&gt;default_sentinel&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意の範囲の終端を表すことのできるデフォルトの番兵オブジェクト(constant variable)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/unreachable_sentinel_t.html&#34;&gt;unreachable_sentinel_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;別の方法で終端が指定される範囲の仮想的な終端を表す番兵型(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/unreachable_sentinel_t.html&#34;&gt;unreachable_sentinel&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;別の方法で終端が指定される範囲の仮想的な終端を表す番兵オブジェクト(class template)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;先頭イテレータと末尾イテレータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/begin.html&#34;&gt;begin&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の先頭を指すイテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/end.html&#34;&gt;end&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の末尾の次を指すイテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/cbegin.html&#34;&gt;cbegin&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の先頭を指す読み取り専用イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/cend.html&#34;&gt;cend&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の末尾の次を指す読み取り専用イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/rbegin.html&#34;&gt;rbegin&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の末尾を指す逆イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/rend.html&#34;&gt;rend&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の先頭の前を指す逆イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/crbegin.html&#34;&gt;crbegin&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の末尾を指す読み取り専用逆イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/crend.html&#34;&gt;crend&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲の先頭の前を指す読み取り専用逆イテレータを取得する(function template)&lt;/td&gt;
&lt;td&gt;C++14&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;コンテナアクセス&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/size.html&#34;&gt;size&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンテナの要素数を取得する (function)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/ssize.html&#34;&gt;ssize&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンテナの要素数を、符号付き整数型で取得する (function)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/empty.html&#34;&gt;empty&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンテナが空かどうかを判定する (function)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/data.html&#34;&gt;data&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンテナの要素配列へのポインタを取得する (function)&lt;/td&gt;
&lt;td&gt;C++17&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;カスタマイゼーションポイントオブジェクト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iter_move.html&#34;&gt;ranges::iter_move&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの指す要素をムーブする (customization point object)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/iterator/iter_swap.html&#34;&gt;ranges::iter_swap&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つのイテレータの指す要素を&lt;em&gt;swap&lt;/em&gt;する (customization point object)&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf&#34; target=&#34;_blank&#34;&gt;P0896R4 The One Ranges Proposal (was Merging the Ranges TS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2051r0.html&#34; target=&#34;_blank&#34;&gt;P2051R0 C++ Standard Library Issues to be moved in Prague&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>スタイル -- 訳語： rangeの使い分けを記載 #1011</title>
      <link href="https://cpprefjp.github.io/working_style.html"/>
      <id>60acb8b5126f8d3548b943d8934b3bd6f721c085:working_style.md</id>
      <updated>2022-12-28T11:13:33+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;スタイル&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本サイトで作業を行う上でのスタイルです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「である」調&lt;/li&gt;
&lt;li&gt;句読点は「、」「。」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型修飾のスタイル：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A) const T &amp;amp;v&lt;/li&gt;
&lt;li&gt;B) const T&amp;amp; v&lt;/li&gt;
&lt;li&gt;C) const T &amp;amp; v&lt;/li&gt;
&lt;li&gt;D) T const &amp;amp;v&lt;/li&gt;
&lt;li&gt;E) T const&amp;amp; v&lt;/li&gt;
&lt;li&gt;F) T const &amp;amp; v&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本サイトでは、Bのスタイルで型修飾を行います。&lt;/p&gt;
&lt;h2&gt;バージョンの表記&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;p&gt;C++11以降対応については対応バージョンを明記します。バージョン表記が省略されている場合、C++03、C++98対応であることを表します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;C++17&lt;/li&gt;
&lt;li&gt;C++14&lt;/li&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;li&gt;C++03&lt;/li&gt;
&lt;li&gt;C++98&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;p&gt;開発環境の表記がない場合は、C++98対応のあらゆる環境で使用できるものとします。 
処理系の記載は、作業者が確認できたものを記載します。&lt;/p&gt;
&lt;h4&gt;例&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Clang: 2.1, 2.8&lt;/li&gt;
&lt;li&gt;GCC: 4.3.4, 4.4.3, 4.4.4, 4.5.2&lt;/li&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1, 12.0&lt;/li&gt;
&lt;li&gt;PathScale: 3.2&lt;/li&gt;
&lt;li&gt;QCC&lt;/li&gt;
&lt;li&gt;Visual C++: 2003, 2008, 2010&lt;/li&gt;
&lt;li&gt;pgCC: 11.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それと、訳語表を随時更新していってください。&lt;/p&gt;
&lt;h3&gt;訳語表&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英語&lt;/th&gt;
&lt;th&gt;日本語&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abstract class&lt;/td&gt;
&lt;td&gt;抽象クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;aggregate&lt;/td&gt;
&lt;td&gt;集成体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alignment&lt;/td&gt;
&lt;td&gt;アライメント (表示位置ではなくメモリの文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;apply, application&lt;/td&gt;
&lt;td&gt;適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arithmetic type&lt;/td&gt;
&lt;td&gt;算術型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;associative container(s)&lt;/td&gt;
&lt;td&gt;連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;base class&lt;/td&gt;
&lt;td&gt;基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bidirectional iterator&lt;/td&gt;
&lt;td&gt;双方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bucket&lt;/td&gt;
&lt;td&gt;バケット&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;complexity&lt;/td&gt;
&lt;td&gt;計算量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compound type&lt;/td&gt;
&lt;td&gt;複合型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const iterator&lt;/td&gt;
&lt;td&gt;読み取り専用イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const reverse iterator&lt;/td&gt;
&lt;td&gt;読み取り専用逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;covariant&lt;/td&gt;
&lt;td&gt;共変的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data member&lt;/td&gt;
&lt;td&gt;メンバ変数 (ユーザー視点ではデータメンバより一般的のため)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereference&lt;/td&gt;
&lt;td&gt;間接参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dereferenceable&lt;/td&gt;
&lt;td&gt;間接参照可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;derived class&lt;/td&gt;
&lt;td&gt;派生クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;direct base class&lt;/td&gt;
&lt;td&gt;直接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delegate&lt;/td&gt;
&lt;td&gt;委譲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;effects&lt;/td&gt;
&lt;td&gt;効果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emplace&lt;/td&gt;
&lt;td&gt;直接構築&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equal&lt;/td&gt;
&lt;td&gt;等値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence class&lt;/td&gt;
&lt;td&gt;同値分類 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalence relation&lt;/td&gt;
&lt;td&gt;同値関係 (数学的文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;equivalent&lt;/td&gt;
&lt;td&gt;同値 (数学的文脈)、等価 (その他文脈)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forward iterator&lt;/td&gt;
&lt;td&gt;前方向イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fundamental type&lt;/td&gt;
&lt;td&gt;単純型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ill-formed&lt;/td&gt;
&lt;td&gt;&lt;a class=&#34;cpprefjp-defined-word&#34;&gt;不適格&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;implementation-defined&lt;/td&gt;
&lt;td&gt;処理系定義&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indirect base class&lt;/td&gt;
&lt;td&gt;間接基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;inherited&lt;/td&gt;
&lt;td&gt;継承&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input iterator&lt;/td&gt;
&lt;td&gt;入力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;literal type&lt;/td&gt;
&lt;td&gt;リテラル型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load factor&lt;/td&gt;
&lt;td&gt;負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lvalue reference&lt;/td&gt;
&lt;td&gt;左辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max load factor&lt;/td&gt;
&lt;td&gt;最大負荷率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;member&lt;/td&gt;
&lt;td&gt;メンバ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move&lt;/td&gt;
&lt;td&gt;(std::move 的な意味で)ムーブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move assignment&lt;/td&gt;
&lt;td&gt;ムーブ代入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;move constructor&lt;/td&gt;
&lt;td&gt;ムーブコンストラクタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mutable iterator&lt;/td&gt;
&lt;td&gt;可変イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;non-virtual base class&lt;/td&gt;
&lt;td&gt;非仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;note&lt;/td&gt;
&lt;td&gt;注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output iterator&lt;/td&gt;
&lt;td&gt;出力イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overload&lt;/td&gt;
&lt;td&gt;オーバーロード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(proposal) paper&lt;/td&gt;
&lt;td&gt;提案文書&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partial ordering&lt;/td&gt;
&lt;td&gt;半順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partition&lt;/td&gt;
&lt;td&gt;区分化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ポインタ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;polymorphic&lt;/td&gt;
&lt;td&gt;多相的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;power of N&lt;/td&gt;
&lt;td&gt;Nの累乗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;predicate&lt;/td&gt;
&lt;td&gt;述語&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;propagation, propagate&lt;/td&gt;
&lt;td&gt;伝播&lt;br /&gt; (伝搬は誤用が広まったものなので使わない)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pure virtual function&lt;/td&gt;
&lt;td&gt;純粋仮想関数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;random access iterator&lt;/td&gt;
&lt;td&gt;ランダムアクセスイテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;一般用途の場合：範囲&lt;br /&gt; Rangeアルゴリズム・Rangeアダプタ・Rangeオブジェクトの場合：Range&lt;br /&gt; range-based for：範囲for文&lt;br /&gt; 2つのイテレータによる範囲：イテレータ範囲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;remarks&lt;/td&gt;
&lt;td&gt;備考&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;requires&lt;/td&gt;
&lt;td&gt;要件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;returns&lt;/td&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reverse iterator&lt;/td&gt;
&lt;td&gt;逆イテレータ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rvalue reference&lt;/td&gt;
&lt;td&gt;右辺値参照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sequence container(s)&lt;/td&gt;
&lt;td&gt;シーケンスコンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;signed&lt;/td&gt;
&lt;td&gt;符号付き&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop request&lt;/td&gt;
&lt;td&gt;停止要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stop state&lt;/td&gt;
&lt;td&gt;停止状態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spurious Failure&lt;/td&gt;
&lt;td&gt;見かけ上の失敗&lt;br /&gt; &lt;a href=&#34;https://togetter.com/li/430770&#34; target=&#34;_blank&#34;&gt;https://togetter.com/li/430770&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strict weak ordering&lt;/td&gt;
&lt;td&gt;狭義の弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;strong ordering&lt;/td&gt;
&lt;td&gt;全順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;structural type&lt;/td&gt;
&lt;td&gt;構造的型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;synchronization&lt;/td&gt;
&lt;td&gt;同期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;total ordering relationalship&lt;/td&gt;
&lt;td&gt;全順序関係&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trailing return type&lt;/td&gt;
&lt;td&gt;後置戻り値型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trait&lt;/td&gt;
&lt;td&gt;トレイト&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trivial&lt;/td&gt;
&lt;td&gt;トリビアル (逆は非トリビアル)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underlying type&lt;/td&gt;
&lt;td&gt;基底型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unordered associative container(s)&lt;/td&gt;
&lt;td&gt;非順序連想コンテナ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unspecified&lt;/td&gt;
&lt;td&gt;未規定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;virtual base class&lt;/td&gt;
&lt;td&gt;仮想基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;weak ordering&lt;/td&gt;
&lt;td&gt;弱順序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;well-formed&lt;/td&gt;
&lt;td&gt;適格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eligible&lt;/td&gt;
&lt;td&gt;資格のある&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_find -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/adjacent_find.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/adjacent_find.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/adjacent_find.md b/reference/algorithm/adjacent_find.md
index a8a3d83d6..f6050f8b4 100644
--- a/reference/algorithm/adjacent_find.md
+++ b/reference/algorithm/adjacent_find.md
@@ -43,7 +43,7 @@ namespace std {
 ```
 
 ## 概要
-隣接する要素で条件を満たしている最初の要素を検索する。
+イテレータ範囲`[first, last)`から、隣接する要素で条件を満たしている最初の要素を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/binary_search.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/binary_search.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/binary_search.md b/reference/algorithm/binary_search.md
index 9bf8bd586..2eeb4495d 100644
--- a/reference/algorithm/binary_search.md
+++ b/reference/algorithm/binary_search.md
@@ -30,7 +30,7 @@ namespace std {
 ```
 
 ## 概要
-二分探索法による検索を行う。
+イテレータ範囲`[first, last)`から、二分探索法によって条件一致する要素の検索を行う。
 
 
 ## 要件
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/copy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/copy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/copy_n.md b/reference/algorithm/copy_n.md
index efcd1a4e1..529f8ce0c 100644
--- a/reference/algorithm/copy_n.md
+++ b/reference/algorithm/copy_n.md
@@ -30,7 +30,7 @@ namespace std {
 ```
 
 ## 概要
-指定された数の要素をコピーする。
+イテレータ範囲`[first, first + n)` (範囲の先頭N個) の要素をコピーする。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/count.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/count.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/count.md b/reference/algorithm/count.md
index 2ce75bc80..afedd7ede 100644
--- a/reference/algorithm/count.md
+++ b/reference/algorithm/count.md
@@ -28,11 +28,11 @@ namespace std {
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-指定された値と等値な要素の数を数える。
+イテレータ範囲`[first, last)`から、指定された値と等値な要素の数を数える。
 
 
 ## 戻り値
-`[first,last)` 内のイテレータ `i` について、`*i == value` であるイテレータの数を返す
+イテレータ範囲`[first,last)` 内のイテレータ `i` について、`*i == value` であるイテレータの数を返す
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>count_if -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/count_if.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/count_if.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/count_if.md b/reference/algorithm/count_if.md
index 9f9b8885f..a8bc4938a 100644
--- a/reference/algorithm/count_if.md
+++ b/reference/algorithm/count_if.md
@@ -28,11 +28,11 @@ namespace std {
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-条件を満たしている要素の数を数える。
+イテレータ範囲`[first, last)`から、条件を満たしている要素の数を数える。
 
 
 ## 戻り値
-`[first,last)` 内のイテレータ `i` について、`pred(*i) != false` であるイテレータの数を返す
+イテレータ範囲`[first,last)` 内のイテレータ `i` について、`pred(*i) != false` であるイテレータの数を返す
 
 
 ## 計算量
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/find.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find.md b/reference/algorithm/find.md
index 6eae74b7a..958f3f53a 100644
--- a/reference/algorithm/find.md
+++ b/reference/algorithm/find.md
@@ -24,7 +24,7 @@ namespace std {
 ```
 
 ## 概要
-指定された値を検索する。
+イテレータ範囲`[first, last)`から、指定された値を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>find_first_of -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/find_first_of.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/find_first_of.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/find_first_of.md b/reference/algorithm/find_first_of.md
index 0ff2d6b78..be67c0a13 100644
--- a/reference/algorithm/find_first_of.md
+++ b/reference/algorithm/find_first_of.md
@@ -71,7 +71,7 @@ namespace std {
 ```
 
 ## 概要
-ある集合の1つとマッチする最初の要素を検索する。
+イテレータ範囲`[first1, last1)`から、集合`[first2, last2)`のいずれかの要素とマッチする最初の要素を検索する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iter_swap -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/iter_swap.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/iter_swap.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/iter_swap.md b/reference/algorithm/iter_swap.md
index 3e678b73e..aa599262d 100644
--- a/reference/algorithm/iter_swap.md
+++ b/reference/algorithm/iter_swap.md
@@ -6,10 +6,10 @@
 ```cpp
 namespace std {
   template &amp;lt;class ForwardIterator1, class ForwardIterator2&amp;gt;
-  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);           // C++03
+  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);           // (1) C++03
 
   template &amp;lt;class ForwardIterator1, class ForwardIterator2&amp;gt;
-  constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b); // C++20
+  constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b); // (1) C++20
 }
 ```
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>binary_search -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_binary_search.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/ranges_binary_search.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_binary_search.md b/reference/algorithm/ranges_binary_search.md
index 49266fd76..744e28660 100644
--- a/reference/algorithm/ranges_binary_search.md
+++ b/reference/algorithm/ranges_binary_search.md
@@ -6,13 +6,30 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool binary_search(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr bool binary_search(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    binary_search(I first,
+                  S last,
+                  const T&amp;amp; value,
+                  Comp comp = {},
+                  Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr bool
+    binary_search(R&amp;amp;&amp;amp; r,
+                  const T&amp;amp; value,
+                  Comp comp = {},
+                  Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,6 +45,9 @@ namespace std::ranges {
 ## 概要
 二分探索法による検索を行う。
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 `[first,last)` の要素 `e` は `e &amp;lt; value` および `!(value &amp;lt; e)`、または `comp(e, value)` および `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていなければならない。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_copy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/ranges_copy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_copy_n.md b/reference/algorithm/ranges_copy_n.md
index 9aa2645ef..817d7ef2c 100644
--- a/reference/algorithm/ranges_copy_n.md
+++ b/reference/algorithm/ranges_copy_n.md
@@ -7,9 +7,13 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;input_iterator I, weakly_incrementable O&amp;gt;
+  template &amp;lt;input_iterator I,
+            weakly_incrementable O&amp;gt;
     requires indirectly_copyable&amp;lt;I, O&amp;gt;
-  constexpr copy_n_result&amp;lt;I, O&amp;gt; copy_n(I first, iter_difference_t&amp;lt;I&amp;gt; n, O result);
+  constexpr copy_n_result&amp;lt;I, O&amp;gt;
+    copy_n(I first,
+           iter_difference_t&amp;lt;I&amp;gt; n,
+           O result); // (1) C++20
 }
 ```
 * copy_n_result[link ranges_in_out_result.md]
@@ -20,6 +24,8 @@ namespace std::ranges {
 ## 概要
 指定された数の要素をコピーする。
 
+- (1): イテレータ範囲を指定する
+
 
 ## 効果
 0 以上 `n` 未満であるそれぞれの `i` について、`*(result + i) = *(first + i)` を行う。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>upper_bound -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/algorithm/ranges_upper_bound.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/algorithm/ranges_upper_bound.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/algorithm/ranges_upper_bound.md b/reference/algorithm/ranges_upper_bound.md
index 37d48b82a..393ea4619 100644
--- a/reference/algorithm/ranges_upper_bound.md
+++ b/reference/algorithm/ranges_upper_bound.md
@@ -6,13 +6,30 @@
 
 ```cpp
 namespace std::ranges {
-  template&amp;lt;forward_iterator I, sentinel_for&amp;lt;I&amp;gt; S, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr I upper_bound(I first, S last, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
-
-  template&amp;lt;forward_range R, class T, class Proj = identity,
-           indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
-  constexpr borrowed_iterator_t&amp;lt;R&amp;gt; upper_bound(R&amp;amp;&amp;amp; r, const T&amp;amp; value, Comp comp = {}, Proj proj = {});
+  template &amp;lt;forward_iterator I,
+            sentinel_for&amp;lt;I&amp;gt; S,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;const T*, projected&amp;lt;I, Proj&amp;gt;&amp;gt; Comp = ranges::less&amp;gt;
+  constexpr I
+    upper_bound(I first,
+                S last,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (1) C++20
+
+  template &amp;lt;forward_range R,
+            class T,
+            class Proj = identity,
+            indirect_strict_weak_order&amp;lt;
+              const T*,
+              projected&amp;lt;iterator_t&amp;lt;R&amp;gt;, Proj&amp;gt;
+            &amp;gt; Comp = ranges::less&amp;gt;
+  constexpr borrowed_iterator_t&amp;lt;R&amp;gt;
+    upper_bound(R&amp;amp;&amp;amp; r,
+                const T&amp;amp; value,
+                Comp comp = {},
+                Proj proj = {}); // (2) C++20
 }
 ```
 * forward_iterator[link /reference/iterator/forward_iterator.md]
@@ -28,6 +45,9 @@ namespace std::ranges {
 ## 概要
 指定された要素より大きい値が現れる最初の位置のイテレータを取得する
 
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
+
 
 ## 事前条件
 - `[first,last)` の要素 `e` は `!(value &amp;lt; e)` または `!comp(value, e)` によって[区分化](/reference/algorithm.md#sequence-is-partitioned)されていること。  
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/array/array/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/array/array/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/array/array/op_equal.md b/reference/array/array/op_equal.md
index 7b890f066..1cfd8b7da 100644
--- a/reference/array/array/op_equal.md
+++ b/reference/array/array/op_equal.md
@@ -77,7 +77,7 @@ equal
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1023R0 `constexpr` comparison operators for `std::array`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1023r0.pdf)
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>from_chars -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/charconv/from_chars.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/charconv/from_chars.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/from_chars.md b/reference/charconv/from_chars.md
index 54c5e3dea..98dbda731 100644
--- a/reference/charconv/from_chars.md
+++ b/reference/charconv/from_chars.md
@@ -21,13 +21,13 @@ namespace std {
 ```
 
 ## 概要
-与えられた`[first, last)`内の文字列から、オーバーロードと基数・フォーマット指定によって決まるパターンにマッチングする最初の数字文字列を見つけて、数値へ変換する。  
+与えられたイテレータ範囲`[first, last)`内の文字列から、オーバーロードと基数・フォーマット指定によって決まるパターンにマッチングする最初の数字文字列を見つけて、数値へ変換する。  
 変換に際し、メモリ確保を行わず例外を投げることもない。
 
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
 ## 要件
-- 全て : 出力範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
+- 全て : 出力イテレータ範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
 - (2)～(4)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>to_chars -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/charconv/to_chars.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/charconv/to_chars.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/charconv/to_chars.md b/reference/charconv/to_chars.md
index fef05dad3..cb05cd2f4 100644
--- a/reference/charconv/to_chars.md
+++ b/reference/charconv/to_chars.md
@@ -41,7 +41,7 @@ namespace std {
 C++標準はこれら関数の実装の詳細について何も規定しない。これは、各実装において可能な最も高速なアルゴリズムが選択されることを意図しての事である。
 
 ## 要件
-- 全て : 出力範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
+- 全て : 出力イテレータ範囲`[first, last)`は有効な範囲であること（charのオブジェクトが構築済みであり、連続していること）。
 - (1) : `base`は2～36までの値であること。
 - (5)～(10)  : `fmt`は[`chars_format`](../charconv/chars_format.md)の列挙値のうちの一つであること。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/deque/deque/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/assign.md b/reference/deque/deque/assign.md
index 3db3876d7..21c062e0d 100644
--- a/reference/deque/deque/assign.md
+++ b/reference/deque/deque/assign.md
@@ -19,7 +19,7 @@ void assign(initializer_list&amp;lt;T&amp;gt; init);                // (3) C++11
 
 
 ## 効果
-- (1) : `*this`の全ての要素を解放し、`[first, last)`の範囲の要素のコピーを`*this`にコピーする。
+- (1) : `*this`の全ての要素を解放し、イテレータ範囲`[first, last)`の要素のコピーを`*this`にコピーする。
 - (2) : `*this`の全ての要素が解放され、`t`オブジェクトの`n`個のコピーから`*this`を再構築する。
 - (3) : `*this`の全ての要素を解放し、`x`の全ての要素を`*this`にコピーする。
 
@@ -43,7 +43,7 @@ int main ()
 {
   std::deque&amp;lt;int&amp;gt; c = {1, 2, 3};
 
-  // 範囲の代入
+  // イテレータ範囲の代入
   std::deque&amp;lt;int&amp;gt; c1;
   c1.assign(c.begin(), c.end());
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/deque/deque/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/erase.md b/reference/deque/deque/erase.md
index 1db733248..303d0facb 100644
--- a/reference/deque/deque/erase.md
+++ b/reference/deque/deque/erase.md
@@ -18,7 +18,7 @@ iterator erase(const_iterator first, const_iterator last); // (2) C++11
 
 ## 効果
 - (1) : `position`が指す要素を削除する。
-- (2) : `[first, last)`で示される範囲の要素を削除する。
+- (2) : イテレータ範囲`[first, last)`の要素を削除する。
 
 もし削除がシーケンスの先頭または末尾から行われた場合、削除された要素へのイテレータと参照は無効化される。もし削除が中間位置から行われた場合、全てのイテレータと削除は無効化される。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/deque/deque/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/insert.md b/reference/deque/deque/insert.md
index 21de19dbb..57ad542bd 100644
--- a/reference/deque/deque/insert.md
+++ b/reference/deque/deque/insert.md
@@ -43,7 +43,7 @@ iterator insert(const_iterator position, initializer_list&amp;lt;T&amp;gt; init); // (5) C++11
 - `x`挿入される要素の初期化に使われる値。`T`はひとつめのテンプレートパラメータ（コンテナに格納される要素の型）である。
 - `y`直接挿入される値。`T`はひとつめのテンプレートパラメータ（コンテナに格納される要素の型）である。
 - `n`挿入する要素の数。それぞれの要素は x の値によって初期化される。メンバ型`size_type`は符号なし整数型である。
-- `first, last`要素の範囲を指定する。範囲 `[first, last)` の中にある要素のコピーが位置`position`に挿入される。`first`と`last`の間の範囲は、`first`で指定された要素を含むが、`last`で指定された要素を含まない点に注意。テンプレート型はどんな入力イテレータでも構わない。
+- `first, last`要素のイテレータ範囲を指定する。イテレータ範囲 `[first, last)` の中にある要素のコピーが位置`position`に挿入される。`first`と`last`の間の範囲は、`first`で指定された要素を含むが、`last`で指定された要素を含まない点に注意。テンプレート型はどんな入力イテレータでも構わない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/deque/deque/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/deque/deque/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/deque/deque/op_equal.md b/reference/deque/deque/op_equal.md
index 8c3f42d56..f4310152c 100644
--- a/reference/deque/deque/op_equal.md
+++ b/reference/deque/deque/op_equal.md
@@ -83,6 +83,6 @@ false
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>directory_iterator -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/directory_iterator.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/directory_iterator.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/directory_iterator.md b/reference/filesystem/directory_iterator.md
index cf9f44763..844f2da3b 100644
--- a/reference/filesystem/directory_iterator.md
+++ b/reference/filesystem/directory_iterator.md
@@ -43,7 +43,7 @@ namespace std::filesystem {
 
 
 ## 非メンバ関数
-### 範囲
+### イテレータ範囲
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/path/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/assign.md b/reference/filesystem/path/assign.md
index 415223703..aded291aa 100644
--- a/reference/filesystem/path/assign.md
+++ b/reference/filesystem/path/assign.md
@@ -35,7 +35,7 @@ path&amp;amp; assign(InputIterator first, InputIterator last); // (3)
 ## 効果
 - (1) : `source`のパスフォーマットを検出して内部用に変換し、`*this`にムーブ代入する。この関数を呼び出したあと、`source`は「有効だが未規定の状態」となる
 - (2) : `source`のパスフォーマットを検出して内部用に変換し、`*this`にそのパスのコピーを保持する
-- (3) : 範囲`[first, last)`を`path source{first, last};`として、`source`のパスフォーマットを検出して内部用に変換し、`*this`にそのパスのコピーを保持する
+- (3) : イテレータ範囲`[first, last)`を`path source{first, last};`として、`source`のパスフォーマットを検出して内部用に変換し、`*this`にそのパスのコピーを保持する
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lexically_relative -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/lexically_relative.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/path/lexically_relative.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/lexically_relative.md b/reference/filesystem/path/lexically_relative.md
index 4d73b888a..efd8b4fe1 100644
--- a/reference/filesystem/path/lexically_relative.md
+++ b/reference/filesystem/path/lexically_relative.md
@@ -23,11 +23,11 @@ path lexically_relative(const path&amp;amp; base) const;
 2. 以下の式で、`*this`と`base`が異なる最初の位置を見つける：
     - `auto [a, b] =` [`std::mismatch`](/reference/algorithm/mismatch.md)`(`[`begin()`](begin.md)`,` [`end()`](end.md)`, base.`[`begin()`](begin.md)`, base.`[`end()`](end.md)`);`
 3. `a ==` [`end()`](end.md)かつ`b == base.`[`end()`](end.md)の場合、`path(&amp;#34;.&amp;#34;)`が返る
-4. 範囲`[b, base.`[`end()`](end.md)`)`の非`&amp;#34;.&amp;#34;` (ドットx1) かつ非`&amp;#34;..&amp;#34;` (ドットx2) の数から、同範囲内の `&amp;#34;..&amp;#34;` の数を引いたものを`n`とする
+4. イテレータ範囲`[b, base.`[`end()`](end.md)`)`の非`&amp;#34;.&amp;#34;` (ドットx1) かつ非`&amp;#34;..&amp;#34;` (ドットx2) の数から、同範囲内の `&amp;#34;..&amp;#34;` の数を引いたものを`n`とする
 5. `n &amp;lt; 0`であれば、空のパスが返る
 6. 新たな`path`型オブジェクト`p`をデフォルト構築し、
 7. 式`p /= path(&amp;#34;..&amp;#34;)`をn回を適用する
-8. 範囲`[a,` [`end()`](end.md)`)`の各要素`x`を、式`p /= x`で加算する
+8. イテレータ範囲`[a,` [`end()`](end.md)`)`の各要素`x`を、式`p /= x`で加算する
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/path/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/op_constructor.md b/reference/filesystem/path/op_constructor.md
index dd5ce9489..71b931945 100644
--- a/reference/filesystem/path/op_constructor.md
+++ b/reference/filesystem/path/op_constructor.md
@@ -59,12 +59,12 @@ path(InputIterator first, InputIterator last,
 - (3) : `p`の保持するパスを`*this`に移動する。このコンストラクタ呼び出しのあと、`p`は「有効だが未規定の状態」となる
 - (4) : 必要であればパスのフォーマットを変換し、`source`を`*this`に移動する。このコンストラクタ呼び出しのあと、`source`は「有効だが未規定の状態」となる
 - (5) : 必要であればパスのフォーマットを変換し、`source`を`*this`にコピーする
-- (6) : 範囲`[first, last)`をパス文字列とし、必要であればパスのフォーマットを変換て、そのコピーを`*this`にコピーする
+- (6) : イテレータ範囲`[first, last)`をパス文字列とし、必要であればパスのフォーマットを変換て、そのコピーを`*this`にコピーする
 - (7) :
     - `path`クラスの`value_type`が`wchar_t`であれば、[`std::codecvt`](/reference/locale/codecvt.md)`&amp;lt;wchar_t, char, mbstate_t&amp;gt;`ファセットを使用して、`source`をシステムのワイド文字コードに変換をする。そうでなければ、同ファセットを使用して、システムのマルチバイト文字コードに変換をする
     - さらに必要であればパスのフォーマットを変換し、その結果を`*this`にコピーする
 - (8) :
-    - `path`クラスの`value_type`が`wchar_t`であれば、[`std::codecvt`](/reference/locale/codecvt.md)`&amp;lt;wchar_t, char, mbstate_t&amp;gt;`ファセットを使用して、範囲`[first, last)`のパス文字列をシステムのワイド文字コードに変換をする。そうでなければ、同ファセットを使用して、システムのマルチバイト文字コードに変換をする
+    - `path`クラスの`value_type`が`wchar_t`であれば、[`std::codecvt`](/reference/locale/codecvt.md)`&amp;lt;wchar_t, char, mbstate_t&amp;gt;`ファセットを使用して、イテレータ範囲`[first, last)`のパス文字列をシステムのワイド文字コードに変換をする。そうでなければ、同ファセットを使用して、システムのマルチバイト文字コードに変換をする
     - さらに必要であればパスのフォーマットを変換し、その結果を`*this`にコピーする
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>recursive_directory_iterator -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/recursive_directory_iterator.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/filesystem/recursive_directory_iterator.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/recursive_directory_iterator.md b/reference/filesystem/recursive_directory_iterator.md
index 77db2aec7..65e497b1a 100644
--- a/reference/filesystem/recursive_directory_iterator.md
+++ b/reference/filesystem/recursive_directory_iterator.md
@@ -61,7 +61,7 @@ namespace std::filesystem {
 
 
 ## 非メンバ関数
-### 範囲
+### イテレータ範囲
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>format -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/format/format.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/format/format.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/format.md b/reference/format/format.md
index b847d6fb8..35dec427a 100644
--- a/reference/format/format.md
+++ b/reference/format/format.md
@@ -100,7 +100,7 @@ string s3 = format(&amp;#34;{} {1}&amp;#34;,  &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;); // コンパイルエラー
 
 #### 文字型 / `bool`型 / 整数型の場合
 
-`[first, last)`を[`to_chars`](/reference/charconv/to_chars.md)の結果を格納するのに十分な範囲、`value`をフォーマットする値、`charT`を`char`または`wchar_t`とする。
+イテレータ範囲`[first, last)`を[`to_chars`](/reference/charconv/to_chars.md)の結果を格納するのに十分な範囲、`value`をフォーマットする値、`charT`を`char`または`wchar_t`とする。
 
 * 以下の表の通りに[`to_chars`](/reference/charconv/to_chars.md)を呼び出したあと、その結果を出力へコピーするかのような振る舞いをする。ただし、実際に[`to_chars`](/reference/charconv/to_chars.md)を呼び出すかどうかは規定されていない。
 * 実際には、出力へコピーする際にパディングなども行われる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>formatter -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/format/formatter.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/format/formatter.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/formatter.md b/reference/format/formatter.md
index b32d4e61d..e40791996 100644
--- a/reference/format/formatter.md
+++ b/reference/format/formatter.md
@@ -58,15 +58,15 @@ namespace std {
 
 1. 式 `f.parse(pc)` が有効であり、
     * 戻り値の型が`PC::iterator`である
-    * `[pc.begin(), pc.end())`の範囲を解析して`format_error`を投げるか、解析が終わった位置を指すイテレータを返す
+    * イテレータ範囲`[pc.begin(), pc.end())`を解析して`format_error`を投げるか、解析が終わった位置を指すイテレータを返す
 2. 式 `f.format(t, fc)` が有効であり、
     * 戻り値の型が`FC::iterator`である
     * フォーマット結果を`fc.out()`へ出力し、出力後のイテレータを返す
-    * 出力は`t`、`fc.locale()`、最後に呼び出された`f.parse(pc)`の`[pc.begin(), pc.end())`の範囲以外に依存しない
+    * 出力は`t`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
 3. 式 `f.format(u, fc)` が有効であり、
     * 戻り値が`FC::iterator`である
     * フォーマット結果を`fc.out()`へ出力し、出力後のイテレータを返す
-    * 出力は`u`、`fc.locale()`、最後に呼び出された`f.parse(pc)`の`[pc.begin(), pc.end())`の範囲以外に依存しない
+    * 出力は`u`、`fc.locale()`、最後に呼び出された`f.parse(pc)`のイテレータ範囲`[pc.begin(), pc.end())`以外に依存しない
     * `u`を変更しない
 
 条件内の各要素を、以下のように定義する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>vformat_to -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/format/vformat_to.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/format/vformat_to.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/format/vformat_to.md b/reference/format/vformat_to.md
index d7d696d9a..ce3287278 100644
--- a/reference/format/vformat_to.md
+++ b/reference/format/vformat_to.md
@@ -54,7 +54,7 @@ namespace std {
 
 ## 効果
 
-書式文字列`fmt`に従ったフォーマットで`args`の文字列表現を出力イテレータ`out`の`[out, out + N)`の範囲に出力する。ロケール`loc`が指定された場合は、ロケール依存のフォーマットにおいて使用される。
+書式文字列`fmt`に従ったフォーマットで`args`の文字列表現を出力イテレータ`out`の`[out, out + N)`のイテレータ範囲に出力する。ロケール`loc`が指定された場合は、ロケール依存のフォーマットにおいて使用される。
 (ただし、`N`=`formatted_size(fmt, args...)` または `formatted_size(loc, fmt, args...)`)
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/assign.md b/reference/forward_list/forward_list/assign.md
index 0e4172c29..8c423c557 100644
--- a/reference/forward_list/forward_list/assign.md
+++ b/reference/forward_list/forward_list/assign.md
@@ -19,9 +19,9 @@ void assign(initializer_list&amp;lt;T&amp;gt; init);                // (3)
 
 コンテナの再代入
 
-- (1) : 範囲を代入。
-- (2) : `n`個の値`t`を代入。
-- (3) : 初期化子リストを代入。
+- (1) : イテレータ範囲を代入
+- (2) : `n`個の値`t`を代入
+- (3) : 初期化子リストを代入
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace_after -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/emplace_after.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/emplace_after.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/emplace_after.md b/reference/forward_list/forward_list/emplace_after.md
index 67b376ee2..ebfd19ceb 100644
--- a/reference/forward_list/forward_list/emplace_after.md
+++ b/reference/forward_list/forward_list/emplace_after.md
@@ -19,7 +19,7 @@ iterator emplace_after(const_iterator position, Args&amp;amp;&amp;amp;... args);
 
 
 ## 要件
-第1パラメータ`position`が、[`before_begin()`](before_begin.md)もしくは`[`[`begin()`](begin.md)`,` [`end()`](end.md)`)`の範囲の間接参照可能なイテレータであること。
+第1パラメータ`position`が、[`before_begin()`](before_begin.md)もしくはイテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md)`)`の間接参照可能なイテレータであること。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase_after -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/erase_after.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/erase_after.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/erase_after.md b/reference/forward_list/forward_list/erase_after.md
index 4f59c9396..dfff5301e 100644
--- a/reference/forward_list/forward_list/erase_after.md
+++ b/reference/forward_list/forward_list/erase_after.md
@@ -19,12 +19,12 @@ iterator erase_after(const_iterator position,
 第1引数`position`の次が間接参照可能なイテレータであること
 
 - (1) : `position`イテレータが指す次の要素単体を削除する
-- (2) : 範囲`(position, last)`の要素を削除する
+- (2) : イテレータ範囲`(position, last)`の要素を削除する
 
 
 ## 効果
 - (1) : `position`が指す次の要素が削除される
-- (2) : `(position, last)`で示される範囲の要素が削除される
+- (2) : イテレータ範囲`(position, last)`の要素が削除される
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert_after -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/insert_after.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/insert_after.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/insert_after.md b/reference/forward_list/forward_list/insert_after.md
index 043969cbd..2352f90bf 100644
--- a/reference/forward_list/forward_list/insert_after.md
+++ b/reference/forward_list/forward_list/insert_after.md
@@ -28,12 +28,12 @@ iterator insert_after(const_iterator position,
 
 - (1), (2) : 新たな要素をひとつ挿入する
 - (3) : 新たな要素`x`のコピーを`n`個挿入する
-- (4) : `[first, last)`の範囲の要素を挿入する
+- (4) : イテレータ範囲`[first, last)`の要素を挿入する
 - (5) : `initializer_list`の全て要素を挿入する
 
 
 ## 要件
-- 第1パラメータ`position`が、[`before_begin()`](/reference/forward_list/forward_list/before_begin.md)もしくは`[`[`begin()`](begin.md)`,` [`end()`](/reference/forward_list/forward_list/end.md)`)`の範囲の間接参照可能なイテレータであること。
+- 第1パラメータ`position`が、[`before_begin()`](/reference/forward_list/forward_list/before_begin.md)もしくはイテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](/reference/forward_list/forward_list/end.md)`)`の間接参照可能なイテレータであること。
 - `first`、`last`は`*this`のイテレータではないこと。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>merge -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/merge.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/merge.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/merge.md b/reference/forward_list/forward_list/merge.md
index fedb6c7c2..b15d163e3 100644
--- a/reference/forward_list/forward_list/merge.md
+++ b/reference/forward_list/forward_list/merge.md
@@ -26,7 +26,7 @@ void merge(forward_list&amp;amp;&amp;amp; x, Compare comp); // (4)
 
 
 ## 効果
-2つのソート済み範囲`[begin(), end())`と`[x.begin(), x.end())`をマージする。2つの`forward_list`オブジェクトの要素を`*this`に併合し、`x`はマージ後に空となる。
+2つのソート済みイテレータ範囲`[begin(), end())`と`[x.begin(), x.end())`をマージする。2つの`forward_list`オブジェクトの要素を`*this`に併合し、`x`はマージ後に空となる。
 
 マージ後、`x`の要素に対するイテレータおよび参照は無効にならない。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/op_constructor.md b/reference/forward_list/forward_list/op_constructor.md
index 541f2dc30..128c2807e 100644
--- a/reference/forward_list/forward_list/op_constructor.md
+++ b/reference/forward_list/forward_list/op_constructor.md
@@ -47,7 +47,7 @@ forward_list(initializer_list&amp;lt;T&amp;gt; il,
 - (4)
     - C++11 : `n` 個の `T()` で初期化された要素を保持した `forward_list` オブジェクトを構築する。
     - C++14 : アロケータを指定して `n` 個の `T()` で初期化された要素を保持した `forward_list` オブジェクトを構築する。
-- (5) : `[first, last)` の範囲を要素としてコピーした `forward_list` オブジェクトを構築する。
+- (5) : イテレータ範囲`[first, last)` を要素としてコピーした `forward_list` オブジェクトを構築する。
 - (6) : コピーコンストラクタ。`x` と同じ要素を保持した `forward_list` オブジェクトを構築する。
 - (7) : ムーブコンストラクタ。`x` の指す先を自分の領域として `forward_list` オブジェクトを構築する。
 - (8) : アロケータを指定したコピーコンストラクタ  
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/op_equal.md b/reference/forward_list/forward_list/op_equal.md
index df415d350..5cd8904ce 100644
--- a/reference/forward_list/forward_list/op_equal.md
+++ b/reference/forward_list/forward_list/op_equal.md
@@ -79,5 +79,5 @@ false
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>splice_after -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/splice_after.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/splice_after.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/splice_after.md b/reference/forward_list/forward_list/splice_after.md
index 712bd8cfd..c49b9f8fb 100644
--- a/reference/forward_list/forward_list/splice_after.md
+++ b/reference/forward_list/forward_list/splice_after.md
@@ -28,7 +28,7 @@ void splice_after(const_iterator position, forward_list&amp;amp;&amp;amp; x,
 
 
 ## 要件
-- 第1パラメータ`position`が、[`before_begin()`](before_begin.md)もしくは`[`[`begin()`](begin.md)`,` [`end()`](end.md))の範囲の間接参照可能なイテレータであること。
+- 第1パラメータ`position`が、[`before_begin()`](before_begin.md)もしくはイテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md))の間接参照可能なイテレータであること。
 - `i`, `first`, `last`が、`x`のイテレータであること。
 - [`get_allocator()`](get_allocator.md) `== x.`[`get_allocator()`](get_allocator.md)であること。(C++14)
 - [`addressof`](/reference/memory/addressof.md)`(x) != this`であること
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/forward_list/forward_list/unique.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/forward_list/forward_list/unique.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/forward_list/forward_list/unique.md b/reference/forward_list/forward_list/unique.md
index 890463007..340c86a39 100644
--- a/reference/forward_list/forward_list/unique.md
+++ b/reference/forward_list/forward_list/unique.md
@@ -25,7 +25,7 @@ size_type unique(BinaryPredicate pred); // (2) C++20
 
 
 ## 効果
-範囲`[first + 1, last)`の全てのイテレータ`i`について、
+イテレータ範囲`[first + 1, last)`の全てのイテレータ`i`について、
 
 - (1) : `*i == *(i - 1)`
 - (2) : `pred(*i, *(i - 1))`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/boyer_moore_horspool_searcher/op_call.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/boyer_moore_horspool_searcher/op_call.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/boyer_moore_horspool_searcher/op_call.md b/reference/functional/boyer_moore_horspool_searcher/op_call.md
index 3c51883d4..b9cea812b 100644
--- a/reference/functional/boyer_moore_horspool_searcher/op_call.md
+++ b/reference/functional/boyer_moore_horspool_searcher/op_call.md
@@ -26,7 +26,7 @@ std::pair&amp;lt;RandomAccessIterator2, RandomAccessIterator2&amp;gt;
 ## 戻り値
 - 部分シーケンス`[pat_first, pat_last)`が空である場合、[`make_pair`](/reference/utility/make_pair.md)`(first, first)`を返す
 - イテレータ`i`と`j`として以下を定義し、
-    - `i` : 範囲`[first, last)`のうち、部分範囲`[pat_first, pat_last)`が現れる最初の位置を指すイテレータ。各要素の等値比較は、`pred(*(i + n), *(pat_first + n)) != false`で判定する
+    - `i` : イテレータ範囲`[first, last)`のうち、部分範囲`[pat_first, pat_last)`が現れる最初の位置を指すイテレータ。各要素の等値比較は、`pred(*(i + n), *(pat_first + n)) != false`で判定する
     - `j` : [`next`](/reference/iterator/next.md)`(i,` [`distance`](/reference/iterator/distance.md)`(pat_first, pat_last))`
     - 合致する部分シーケンスが見つかった場合、[`make_pair`](/reference/utility/make_pair.md)`(i, j)`を返す
 - 合致する部分シーケンスが見つからなかった場合、[`make_pair`](/reference/utility/make_pair.md)`(last, last)`を返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/boyer_moore_horspool_searcher/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/boyer_moore_horspool_searcher/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/boyer_moore_horspool_searcher/op_constructor.md b/reference/functional/boyer_moore_horspool_searcher/op_constructor.md
index 1070c2d26..54a33d62f 100644
--- a/reference/functional/boyer_moore_horspool_searcher/op_constructor.md
+++ b/reference/functional/boyer_moore_horspool_searcher/op_constructor.md
@@ -21,7 +21,7 @@ boyer_moore_horspool_searcher(boyer_moore_horspool_searcher&amp;amp;&amp;amp; other) = default;
 
 このクラスにデフォルトコンストラクタは定義されない。
 
-- (1) : 検索対象 (pattern) の範囲`[pat_first, pat_last)`を登録する
+- (1) : 検索対象 (pattern) のイテレータ範囲`[pat_first, pat_last)`を登録する
 - (2) : コピーコンストラクタ
 - (3) : ムーブコンストラクタ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/boyer_moore_searcher/op_call.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/boyer_moore_searcher/op_call.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/boyer_moore_searcher/op_call.md b/reference/functional/boyer_moore_searcher/op_call.md
index 7d5843e45..82134094e 100644
--- a/reference/functional/boyer_moore_searcher/op_call.md
+++ b/reference/functional/boyer_moore_searcher/op_call.md
@@ -26,7 +26,7 @@ std::pair&amp;lt;RandomAccessIterator2, RandomAccessIterator2&amp;gt;
 ## 戻り値
 - 部分シーケンス`[pat_first, pat_last)`が空である場合、[`make_pair`](/reference/utility/make_pair.md)`(first, first)`を返す
 - イテレータ`i`と`j`として以下を定義し、
-    - `i` : 範囲`[first, last)`のうち、部分範囲`[pat_first, pat_last)`が現れる最初の位置を指すイテレータ。各要素の等値比較は、`pred(*(i + n), *(pat_first + n)) != false`で判定する
+    - `i` : イテレータ範囲`[first, last)`のうち、部分範囲`[pat_first, pat_last)`が現れる最初の位置を指すイテレータ。各要素の等値比較は、`pred(*(i + n), *(pat_first + n)) != false`で判定する
     - `j` : [`next`](/reference/iterator/next.md)`(i,` [`distance`](/reference/iterator/distance.md)`(pat_first, pat_last))`
     - 合致する部分シーケンスが見つかった場合、[`make_pair`](/reference/utility/make_pair.md)`(i, j)`を返す
 - 合致する部分シーケンスが見つからなかった場合、[`make_pair`](/reference/utility/make_pair.md)`(last, last)`を返す
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/boyer_moore_searcher/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/boyer_moore_searcher/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/boyer_moore_searcher/op_constructor.md b/reference/functional/boyer_moore_searcher/op_constructor.md
index 04f65d5de..21595bb6e 100644
--- a/reference/functional/boyer_moore_searcher/op_constructor.md
+++ b/reference/functional/boyer_moore_searcher/op_constructor.md
@@ -21,7 +21,7 @@ boyer_moore_searcher(boyer_moore_searcher&amp;amp;&amp;amp; other) = default;      // (3)
 
 このクラスにデフォルトコンストラクタは定義されない。
 
-- (1) : 検索対象 (pattern) の範囲`[pat_first, pat_last)`を登録する
+- (1) : 検索対象 (pattern) のイテレータ範囲`[pat_first, pat_last)`を登録する
 - (2) : コピーコンストラクタ
 - (3) : ムーブコンストラクタ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/default_searcher/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/default_searcher/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/default_searcher/op_constructor.md b/reference/functional/default_searcher/op_constructor.md
index fd3e348c8..ea787ffa7 100644
--- a/reference/functional/default_searcher/op_constructor.md
+++ b/reference/functional/default_searcher/op_constructor.md
@@ -23,7 +23,7 @@ default_searcher(default_searcher&amp;amp;&amp;amp; other) = default;       // (3) C++17
 
 このクラスにデフォルトコンストラクタは定義されない。
 
-- (1) : 検索対象 (pattern) の範囲`[pat_first, pat_last)`を登録する
+- (1) : 検索対象 (pattern) のイテレータ範囲`[pat_first, pat_last)`を登録する
 - (2) : コピーコンストラクタ
 - (3) : ムーブコンストラクタ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>identity -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/functional/identity.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/functional/identity.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/identity.md b/reference/functional/identity.md
index 4e00fc7ae..4bb18e412 100644
--- a/reference/functional/identity.md
+++ b/reference/functional/identity.md
@@ -39,7 +39,7 @@ namespace std {
 
 ## 備考
 
-これは主に範囲（`range`）をとるアルゴリズムにおいて、カスタマイズ可能な射影操作のデフォルトとして利用される。
+これは主にRangeをとるアルゴリズムにおいて、カスタマイズ可能な射影操作のデフォルトとして利用される。
 
 ## 例
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>advance -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/iterator/ranges_advance.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/iterator/ranges_advance.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/ranges_advance.md b/reference/iterator/ranges_advance.md
index 0c05e2ad9..9b67945fb 100644
--- a/reference/iterator/ranges_advance.md
+++ b/reference/iterator/ranges_advance.md
@@ -35,11 +35,11 @@ namespace std::ranges {
 ## 事前条件
 
 - (1) : `I`が[`bidirectional_iterator`](bidirectional_iterator.md)のモデルとならない場合、`n`は負数ではない
-- (2) : `[i, bound)`は有効な範囲である
+- (2) : `[i, bound)`は有効なイテレータ範囲である
 - (3) : 次のいずれか
-    - `n &amp;gt;  0` : `[i, bound)`は有効な範囲である
-    - `n == 0` : `[i, bound)`もしくは`[bound, i)`は有効な範囲である
-    - `n &amp;lt;  0` : `[bound, i)`は有効な範囲であり、`I`は[`bidirectional_iterator`](bidirectional_iterator.md)のモデルであり、`I, S`は[`same_as`](/reference/concepts/same_as.md)`&amp;lt;I, S&amp;gt;`のモデルとなる。
+    - `n &amp;gt;  0` : `[i, bound)`は有効なイテレータ範囲である
+    - `n == 0` : `[i, bound)`もしくは`[bound, i)`は有効なイテレータ範囲である
+    - `n &amp;lt;  0` : `[bound, i)`は有効なイテレータ範囲であり、`I`は[`bidirectional_iterator`](bidirectional_iterator.md)のモデルであり、`I, S`は[`same_as`](/reference/concepts/same_as.md)`&amp;lt;I, S&amp;gt;`のモデルとなる。
 
 ## 効果
 
@@ -133,4 +133,4 @@ diff : 2
 
 ## 参照
 
-- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
\ No newline at end of file
+- [P0896R4 The One Ranges Proposal (was Merging the Ranges TS)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0896r4.pdf)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>distance -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/iterator/ranges_distance.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/iterator/ranges_distance.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/ranges_distance.md b/reference/iterator/ranges_distance.md
index a8f36ef0f..e058d313b 100644
--- a/reference/iterator/ranges_distance.md
+++ b/reference/iterator/ranges_distance.md
@@ -32,8 +32,8 @@ namespace std::ranges {
 ## 事前条件
 
 - (1) : 次のいずれか
-    - `[first, last)`は有効な範囲である
-    - `[last, first)`は有効な範囲であり、`S, I`は[`same_as`](/reference/concepts/same_as.md)`&amp;lt;S, I&amp;gt;`および[`sized_sentinel_for`](sized_sentinel_for.md)`&amp;lt;S, I&amp;gt;`のモデルとなる
+    - `[first, last)`は有効なイテレータ範囲である
+    - `[last, first)`は有効なイテレータ範囲であり、`S, I`は[`same_as`](/reference/concepts/same_as.md)`&amp;lt;S, I&amp;gt;`および[`sized_sentinel_for`](sized_sentinel_for.md)`&amp;lt;S, I&amp;gt;`のモデルとなる
 
 ## 効果
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/assign.md b/reference/list/list/assign.md
index 9793cc0ff..b86075321 100644
--- a/reference/list/list/assign.md
+++ b/reference/list/list/assign.md
@@ -16,9 +16,9 @@ void assign(initializer_list&amp;lt;T&amp;gt; init); // (3) C++11
 ## 概要
 コンテナの再代入
 
-- (1) : 範囲を代入。
-- (2) : `n` 個の値 `t` を代入。
-- (3) : 初期化子リストを代入。
+- (1) : イテレータ範囲を代入
+- (2) : `n` 個の値 `t` を代入
+- (3) : 初期化子リストを代入
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>emplace -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/emplace.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/emplace.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/emplace.md b/reference/list/list/emplace.md
index 984761bbe..f8b80f2a4 100644
--- a/reference/list/list/emplace.md
+++ b/reference/list/list/emplace.md
@@ -18,7 +18,7 @@ iterator emplace(const_iterator position, Args&amp;amp;&amp;amp;... args);
 
 
 ## 要件
-第1パラメータ`position`が、`[`[`begin()`](begin.md)`,` [`end()`](end.md)`]`の範囲の間接参照可能なイテレータであること。
+第1パラメータ`position`が、イテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md)`]`の間接参照可能なイテレータであること。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/erase.md b/reference/list/list/erase.md
index ac038a40b..536f40022 100644
--- a/reference/list/list/erase.md
+++ b/reference/list/list/erase.md
@@ -23,7 +23,7 @@ iterator erase(const_iterator position,
 
 ## 効果
 - (1) : `position`が指す要素が削除される。
-- (2) : `[position, last)`で示される範囲の要素が削除される。
+- (2) : イテレータ範囲`[position, last)`の要素が削除される。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/insert.md b/reference/list/list/insert.md
index e1da4ea24..70f3fb176 100644
--- a/reference/list/list/insert.md
+++ b/reference/list/list/insert.md
@@ -36,12 +36,12 @@ iterator insert(const_iterator position,
 
 - (1), (2) : 新たな要素をひとつ挿入する
 - (3) : 新たな要素`x`のコピーを`n`個挿入する
-- (4) : `[first, last)`の範囲の要素を挿入する
+- (4) : イテレータ範囲`[first, last)`の要素を挿入する
 - (5) : `initializer_list`の全て要素を挿入する
 
 
 ## 要件
-第1パラメータ`position`が、`[`[`begin()`](begin.md)`,` [`end()`](end.md)`]`の範囲の間接参照可能なイテレータであること。
+第1パラメータ`position`が、イテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md)`]`の間接参照可能なイテレータであること。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/op_constructor.md b/reference/list/list/op_constructor.md
index 24ceb7194..2ec356e95 100644
--- a/reference/list/list/op_constructor.md
+++ b/reference/list/list/op_constructor.md
@@ -42,7 +42,7 @@ list オブジェクトの構築
 - (2) : アロケータを指定して空のコンテナを作る。
 - (3) : `value` のコピーを `n` 個要素として保持した `list` を構築する。
 - (4) : `n` 個の `T()` 初期化された要素を保持した `list` を構築する。
-- (5) : `[first, last)` の範囲を要素としてコピーした `list` を構築する。
+- (5) : イテレータ範囲`[first, last)`を要素としてコピーした `list` を構築する。
 - (6) : コピーコンストラクタ。`x` と同じ要素を保持した `list` を構築する。
 - (7) : ムーブコンストラクタ。`x` の指す先を自分の領域として `list` を構築する。
 - (8) : アロケータを指定したコピーコンストラクタ。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/op_equal.md b/reference/list/list/op_equal.md
index ada8d47a5..5da792d08 100644
--- a/reference/list/list/op_equal.md
+++ b/reference/list/list/op_equal.md
@@ -67,6 +67,6 @@ false
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>splice -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/splice.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/splice.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/splice.md b/reference/list/list/splice.md
index 23a7f3947..044bd84f6 100644
--- a/reference/list/list/splice.md
+++ b/reference/list/list/splice.md
@@ -30,13 +30,13 @@ void splice(const_iterator position, list&amp;amp;&amp;amp; x,
 ## 概要
 他の`list`オブジェクトから、要素を移動する。
 
-- (1), (2) : `position`の指す要素の前に、`x`の全ての要素を移動する。  
-- (3), (4) : `position`の指す要素の前に、`x`の要素のうち`i`の指す要素を移動する。  
-- (5), (6) : `position`の指す要素の前に、`x`の要素のうち`[first, last)`の範囲を移動する。  
+- (1), (2) : `position`の指す要素の前に、`x`の全ての要素を移動する
+- (3), (4) : `position`の指す要素の前に、`x`の要素のうち`i`の指す要素を移動する
+- (5), (6) : `position`の指す要素の前に、`x`の要素のうち`[first, last)`の範囲を移動する
 
 
 ## 要件
-- 第1パラメータ`position`が、`[`[`begin()`](begin.md)`,` [`end()`](end.md)`)`の範囲の間接参照可能なイテレータであること。
+- 第1パラメータ`position`が、イテレータ範囲`[`[`begin()`](begin.md)`,` [`end()`](end.md)`)`の間接参照可能なイテレータであること。
 - `i`, `first`, `last`が、`x`のイテレータであること。
 - (1), (2) :
     - C++03 : `&amp;amp;x != this`であること
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unique -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/list/list/unique.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/list/list/unique.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/list/list/unique.md b/reference/list/list/unique.md
index 6ad371e02..3384c7698 100644
--- a/reference/list/list/unique.md
+++ b/reference/list/list/unique.md
@@ -24,7 +24,7 @@ size_type unique(BinaryPredicate pred); // (2) C++20
 
 
 ## 効果
-範囲`[first + 1, last)`の全てのイテレータ`i`について、オーバーロードごとに、以下の条件が`true`となる要素を削除する。
+イテレータ範囲`[first + 1, last)`の全てのイテレータ`i`について、オーバーロードごとに、以下の条件が`true`となる要素を削除する。
 
 - (1) : `*i == *(i - 1)`
 - (2) : `pred(*i, *(i - 1))`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/map/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/map/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/erase.md b/reference/map/map/erase.md
index 6db545f7f..b0105266c 100644
--- a/reference/map/map/erase.md
+++ b/reference/map/map/erase.md
@@ -15,7 +15,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 ```
 
 ## 概要
-単一要素または要素範囲（`[first, last)`）を `map` コンテナから削除する。
+単一要素またはイテレータ範囲`[first, last)`を `map` コンテナから削除する。
 
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
@@ -23,7 +23,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 ## パラメータ
 - `position` : `map` から削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
 - `x` : `map` から削除される値のキー。`key_type` はメンバ型であり、`map` コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素のキーの型である。
-- `first, last` : `map` コンテナ内の、削除される範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+- `first, last` : `map` コンテナ内の、削除されるイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/map/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/map/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/insert.md b/reference/map/map/insert.md
index 809d7025f..67fa49823 100644
--- a/reference/map/map/insert.md
+++ b/reference/map/map/insert.md
@@ -48,7 +48,7 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (8) C++17か
 - (2) : `value_type` は、コンテナに対してムーブ挿入可能でなければならない。
 - (3) : `value_type` は、コンテナに対してコピー挿入可能でなければならない。
 - (4) : `value_type` は、コンテナに対してムーブ挿入可能でなければならない。
-- (5) : 範囲`[first, last)`の各イテレータが、`*this`の要素を指さないこと。
+- (5) : イテレータ範囲`[first, last)`の各イテレータが、`*this`の要素を指さないこと。
 - (6) : (5)の要件と同じである。
 - (7) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`である。
 - (8) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`である。
@@ -59,7 +59,7 @@ iterator           insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh); // (8) C++17か
 - (2) : [`emplace`](emplace.md)`(`[`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
 - (3) : `x`を`*this`の要素としてコピー挿入する。ただし、`x`のキーと等価のキーを持つ要素が`*this`に存在する場合には、挿入されない。可能であれば、挿入位置のヒントを表すイテレータ`position`のすぐ前に挿入する。
 - (4) : [`emplace_hint`](emplace_hint.md)`(position,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
-- (5) : 範囲`[first, last)`の各要素を`*this`の要素として挿入する。ただし、`*this`にすでに存在するキーと等価なキーを持つ要素については、挿入されない。
+- (5) : イテレータ範囲`[first, last)`の各要素を`*this`の要素として挿入する。ただし、`*this`にすでに存在するキーと等価なキーを持つ要素については、挿入されない。
 - (6) : `insert(init.begin(), init.end())`と等価。
 - (7) : `nh`が空の場合、効果はない。
 それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/map/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/map/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map/op_equal.md b/reference/map/map/op_equal.md
index a0e188ba0..e520b4dd3 100644
--- a/reference/map/map/op_equal.md
+++ b/reference/map/map/op_equal.md
@@ -67,6 +67,6 @@ int main()
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/multimap/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/erase.md b/reference/map/multimap/erase.md
index b2e280818..3a5579f7f 100644
--- a/reference/map/multimap/erase.md
+++ b/reference/map/multimap/erase.md
@@ -16,7 +16,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 
 
 ## 概要
-単一要素または要素範囲（`[first, last)`）を `multimap` コンテナから削除する。
+単一要素またはイテレータ範囲`[first, last)`を `multimap` コンテナから削除する。
 
 これは削除された要素の数だけコンテナの `size` を減らし、それぞれの要素のデストラクタを呼び出す。
 
@@ -24,7 +24,7 @@ iterator erase(const_iterator first, const_iterator last); // (3) C++11
 ## パラメータ
 - `position` : `multimap` から削除する単一要素を指すイテレータ。`iterator` はメンバ型であり、双方向イテレータとして定義される。
 - `x` : `multimap` から削除される値のキー。`key_type` はメンバ型であり、`multimap` コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素のキーの型である。
-- `first, last` : `multimap` コンテナ内の、削除される範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+- `first, last` : `multimap` コンテナ内の、削除されるイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/multimap/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/insert.md b/reference/map/multimap/insert.md
index b7a5a6370..1005aac1a 100644
--- a/reference/map/multimap/insert.md
+++ b/reference/map/multimap/insert.md
@@ -43,7 +43,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
 - (1), (4) : `value_type` は、コンテナに対してコピー挿入可能でなければならない。
 - (2), (5) : `value_type` は、コンテナに対してムーブ挿入可能でなければならない。
 - (3), (6) : `P`から`value_type`が構築可能であること。
-- (7), (8) : 範囲`[first, last)`（`[list.begin(), list.end())`）の各イテレータが、`*this` の要素を指さないこと。また `value_type` は `*first` から`multimap` コンテナへの`Cpp17EmplaceConstructible`であること。
+- (7), (8) : イテレータ範囲`[first, last)`の各イテレータが、`*this` の要素を指さないこと。また `value_type` は `*first` から`multimap` コンテナへの`Cpp17EmplaceConstructible`であること。
 - (9), (10) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`である。
 
 ## 効果
@@ -53,7 +53,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
 - (4) : 新たな要素`x`を`position`より前の出来るだけ近い位置にコピー挿入する。`position`パラメータに適切な挿入位置を指定すれば、高速に挿入できる。
 - (5) : 新たな要素`y`を`position`より前の出来るだけ近い位置にムーブ挿入する。`position`パラメータに適切な挿入位置を指定すれば、高速に挿入できる。
 - (6) : [`emplace_hint`](emplace_hint.md)`(position,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(x))`と等価。
-- (7) : 範囲`[first, last)`の各要素を`*this`の要素として挿入する。
+- (7) : イテレータ範囲`[first, last)`の各要素を`*this`の要素として挿入する。
 - (8) : `insert(init.begin(), init.end())`と等価（(7)へ委譲）。
 - (9) : `nh`が空の場合、効果はない。そうでなければ、`nh`によって所有されている要素を挿入する。`nh.key()` と等価なキーを持つ要素を含む範囲がコンテナ内に存在する場合、要素はその範囲の終端に挿入される。
 - (10) : `nh`が空の場合、効果はない。そうでなければ、`nh` によって所有されている要素を`p`より前の出来るだけ近い位置に挿入する。 `nh.key()` と等価なキーを持つ要素を含む範囲がコンテナ内に存在する場合、要素はその範囲の終端に挿入される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/map/multimap/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/map/multimap/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/multimap/op_equal.md b/reference/map/multimap/op_equal.md
index 71c3b4e9a..99363d07d 100644
--- a/reference/map/multimap/op_equal.md
+++ b/reference/map/multimap/op_equal.md
@@ -68,6 +68,6 @@ int main()
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/destroy.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/destroy.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/destroy.md b/reference/memory/destroy.md
index c383726a7..294969c83 100644
--- a/reference/memory/destroy.md
+++ b/reference/memory/destroy.md
@@ -27,7 +27,7 @@ namespace std {
 ```
 
 ## 概要
-範囲`[first, last)`の各要素に対してデストラクタを呼び出す。
+イテレータ範囲`[first, last)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトの配列を破棄するために使用する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/destroy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/destroy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/destroy_n.md b/reference/memory/destroy_n.md
index 6e52010ee..22b9947c3 100644
--- a/reference/memory/destroy_n.md
+++ b/reference/memory/destroy_n.md
@@ -27,7 +27,7 @@ namespace std {
 ```
 
 ## 概要
-範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
+イテレータ範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトの配列を破棄するために使用する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-forward-range -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-forward-range.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/no-throw-forward-range.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-forward-range.md b/reference/memory/no-throw-forward-range.md
index acf22d09e..97f2dc755 100644
--- a/reference/memory/no-throw-forward-range.md
+++ b/reference/memory/no-throw-forward-range.md
@@ -18,7 +18,7 @@ namespace std {
 
 ## 概要
 
-`no-throw-forward-range`は、`R`型のオブジェクトに対する以下の操作で例外を投げない入力範囲の説明用コンセプトである：
+`no-throw-forward-range`は、`R`型のオブジェクトに対する以下の操作で例外を投げない入力Rangeの説明用コンセプトである：
 
 - [`std::ranges::begin`](/reference/ranges/begin.md)
 - [`std::ranges::end`](/reference/ranges/end.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>no-throw-input-range -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/no-throw-input-range.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/no-throw-input-range.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/no-throw-input-range.md b/reference/memory/no-throw-input-range.md
index ef4654724..55347cf01 100644
--- a/reference/memory/no-throw-input-range.md
+++ b/reference/memory/no-throw-input-range.md
@@ -21,7 +21,7 @@ namespace std {
 
 ## 概要
 
-`no-throw-input-range`は、`R`型のオブジェクトに対する以下の操作で例外を投げない入力範囲の説明用コンセプトである：
+`no-throw-input-range`は、`R`型のオブジェクトに対する以下の操作で例外を投げない入力Rangeの説明用コンセプトである：
 
 - [`std::ranges::begin`](/reference/ranges/begin.md)
 - [`std::ranges::end`](/reference/ranges/end.md)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_destroy.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy.md b/reference/memory/ranges_destroy.md
index 95430df99..22139a999 100644
--- a/reference/memory/ranges_destroy.md
+++ b/reference/memory/ranges_destroy.md
@@ -27,8 +27,8 @@ namespace std::ranges {
 
 この関数は、配置`new`で構築したオブジェクトを破棄するために使用する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>destroy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_destroy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_destroy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_destroy_n.md b/reference/memory/ranges_destroy_n.md
index 54064c431..5b89f82e9 100644
--- a/reference/memory/ranges_destroy_n.md
+++ b/reference/memory/ranges_destroy_n.md
@@ -17,7 +17,7 @@ namespace std::ranges {
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 
 ## 概要
-範囲 (`[first, first + n)`) の各要素に対してデストラクタを呼び出す。
+イテレータ範囲`[first, first + n)`の各要素に対してデストラクタを呼び出す。
 
 この関数は、配置`new`で構築したオブジェクトを破棄するために使用する。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_copy.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy.md b/reference/memory/ranges_uninitialized_copy.md
index b829fd24b..dea3cc027 100644
--- a/reference/memory/ranges_uninitialized_copy.md
+++ b/reference/memory/ranges_uninitialized_copy.md
@@ -35,10 +35,10 @@ namespace std::ranges {
 * borrowed_iterator_t[link /reference/ranges/borrowed_iterator_t.md]
 
 ## 概要
-未初期化領域の範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
+未初期化領域のイテレータ範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力イテレータ範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
@@ -56,7 +56,7 @@ namespace std::ranges {
 
 ## 事前条件
 
-- 範囲`[ofirst, olast)`が範囲`[ifirst, ilast)`と重ならないこと
+- イテレータ範囲`[ofirst, olast)`が`[ifirst, ilast)`と重ならないこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_copy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_copy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_copy_n.md b/reference/memory/ranges_uninitialized_copy_n.md
index b82f8c4c1..499506e34 100644
--- a/reference/memory/ranges_uninitialized_copy_n.md
+++ b/reference/memory/ranges_uninitialized_copy_n.md
@@ -31,9 +31,9 @@ namespace std::ranges {
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 
 ## 概要
-未初期化領域の範囲`[ofirst, ofirst + n)`を配置`new`で`[ifirst, ifirst + n)`の対応する要素から初期化してコピー出力する。
+未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してコピー出力する。
 
-- (1): イテレータペアで範囲を指定する
+- (1): イテレータ範囲を指定する
 
 
 ## テンプレートパラメータ制約
@@ -46,7 +46,7 @@ namespace std::ranges {
 
 ## 事前条件
 
-- 範囲`[ofirst, olast)`が範囲`ifirst + [0, n)`と重ならないこと
+- イテレータ範囲`[ofirst, olast)`が`ifirst + [0, n)`と重ならないこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_default_construct.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_default_construct.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_default_construct.md b/reference/memory/ranges_uninitialized_default_construct.md
index b6da9354d..1003a3096 100644
--- a/reference/memory/ranges_uninitialized_default_construct.md
+++ b/reference/memory/ranges_uninitialized_default_construct.md
@@ -26,8 +26,8 @@ namespace std::ranges {
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素をデフォルト構築する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_fill.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_fill.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_fill.md b/reference/memory/ranges_uninitialized_fill.md
index 2a8869e3e..a4df77097 100644
--- a/reference/memory/ranges_uninitialized_fill.md
+++ b/reference/memory/ranges_uninitialized_fill.md
@@ -29,8 +29,8 @@ namespace std::ranges {
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) を、指定された値で配置`new`で初期化する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_move.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move.md b/reference/memory/ranges_uninitialized_move.md
index edba00187..37ae4a90f 100644
--- a/reference/memory/ranges_uninitialized_move.md
+++ b/reference/memory/ranges_uninitialized_move.md
@@ -37,8 +37,8 @@ namespace std::ranges {
 ## 概要
 未初期化領域の範囲（`out_range`、`[ofirst, olast)`）を配置`new`で入力範囲（`in_range`、`[ifirst, ilast)`）の対応する要素から初期化してムーブ出力する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
@@ -56,7 +56,7 @@ namespace std::ranges {
 
 ## 事前条件
 
-- 範囲`[ofirst, olast)`が範囲`[ifirst, ilast)`と重ならないこと
+- イテレータ範囲`[ofirst, olast)`が`[ifirst, ilast)`と重ならないこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_move_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_move_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_move_n.md b/reference/memory/ranges_uninitialized_move_n.md
index f7a925e0d..70f40c0c6 100644
--- a/reference/memory/ranges_uninitialized_move_n.md
+++ b/reference/memory/ranges_uninitialized_move_n.md
@@ -31,9 +31,9 @@ namespace std::ranges {
 * iter_difference_t[link /reference/iterator/iter_difference_t.md]
 
 ## 概要
-未初期化領域の範囲`[ofirst, ofirst + n)`を配置`new`で`[ifirst, ifirst + n)`の対応する要素から初期化してムーブ出力する。
+未初期化領域のイテレータ範囲`[ofirst, ofirst + n)`を配置`new`でイテレータ範囲`[ifirst, ifirst + n)`の対応する要素から初期化してムーブ出力する。
 
-- (1): イテレータペアで範囲を指定する
+- (1): イテレータ範囲を指定する
 
 
 ## テンプレートパラメータ制約
@@ -46,7 +46,7 @@ namespace std::ranges {
 
 ## 事前条件
 
-- 範囲`[ofirst, olast)`が範囲`ifirst + [0, n)`と重ならないこと
+- イテレータ範囲`[ofirst, olast)`が`ifirst + [0, n)`と重ならないこと
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/ranges_uninitialized_value_construct.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/ranges_uninitialized_value_construct.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/ranges_uninitialized_value_construct.md b/reference/memory/ranges_uninitialized_value_construct.md
index e71e07a6f..32ae40a9f 100644
--- a/reference/memory/ranges_uninitialized_value_construct.md
+++ b/reference/memory/ranges_uninitialized_value_construct.md
@@ -26,8 +26,8 @@ namespace std::ranges {
 ## 概要
 未初期化領域の範囲 (`r`、`[first, last)`) の各要素を値構築する。
 
-- (1): イテレータペアで範囲を指定する
-- (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_copy_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_copy_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_copy_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_copy_n.md b/reference/memory/uninitialized_copy_n.md
index f2def28be..374055f2a 100644
--- a/reference/memory/uninitialized_copy_n.md
+++ b/reference/memory/uninitialized_copy_n.md
@@ -24,7 +24,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち、先頭`N`個の要素を配置`new`で初期化してコピー出力する。
 
-入力範囲`[first, first + n)`のコピーを未初期化出力範囲`[result, result + n)`に書き込む。
+入力イテレータ範囲`[first, first + n)`のコピーを未初期化出力イテレータ範囲`[result, result + n)`に書き込む。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_default_construct.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_default_construct.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_default_construct.md b/reference/memory/uninitialized_default_construct.md
index cc3b84cd9..6fdf2633f 100644
--- a/reference/memory/uninitialized_default_construct.md
+++ b/reference/memory/uninitialized_default_construct.md
@@ -20,7 +20,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲の各要素をデフォルト構築する。
 
-未初期化領域の入力範囲`[first, last)`の各要素をデフォルト構築する (ゼロ初期化しない)。
+未初期化領域の入力イテレータ範囲`[first, last)`の各要素をデフォルト構築する (ゼロ初期化しない)。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_default_construct_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_default_construct_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_default_construct_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_default_construct_n.md b/reference/memory/uninitialized_default_construct_n.md
index 4500d7e0b..18919f615 100644
--- a/reference/memory/uninitialized_default_construct_n.md
+++ b/reference/memory/uninitialized_default_construct_n.md
@@ -22,7 +22,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち、先頭N個の要素をデフォルト構築する。
 
-未初期化領域の入力範囲`[first, first + n)`の各要素をデフォルト構築する (ゼロ初期化しない)。
+未初期化領域の入力イテレータ範囲`[first, first + n)`の各要素をデフォルト構築する (ゼロ初期化しない)。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_fill.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_fill.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_fill.md b/reference/memory/uninitialized_fill.md
index 0e51a40a4..59d8a5dcd 100644
--- a/reference/memory/uninitialized_fill.md
+++ b/reference/memory/uninitialized_fill.md
@@ -21,7 +21,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲を、指定された値で配置`new`する。
 
-未初期化入力範囲`[first, last)`を初期化しつつ値`x`で埋める。
+未初期化入力イテレータ範囲`[first, last)`を初期化しつつ値`x`で埋める。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_fill_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_fill_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_fill_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_fill_n.md b/reference/memory/uninitialized_fill_n.md
index 7c896d2b7..5e362ff29 100644
--- a/reference/memory/uninitialized_fill_n.md
+++ b/reference/memory/uninitialized_fill_n.md
@@ -23,7 +23,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち、先頭`N`個の要素を指定された値で配置`new`する。
 
-未初期化入力範囲`[first, first + n)`を初期化しつつ値`x`で埋める。
+未初期化入力イテレータ範囲`[first, first + n)`を初期化しつつ値`x`で埋める。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_move_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_move_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_move_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_move_n.md b/reference/memory/uninitialized_move_n.md
index ef0ff491e..8352c6f19 100644
--- a/reference/memory/uninitialized_move_n.md
+++ b/reference/memory/uninitialized_move_n.md
@@ -24,7 +24,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち先頭`N`個の要素を配置`new`で初期化してムーブ出力する。
 
-入力範囲`[first, first + n)`からムーブして未初期化出力範囲`[result, )`に書き込む。
+入力イテレータ範囲`[first, first + n)`からムーブして未初期化出力イテレータ範囲`[result, )`に書き込む。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_value_construct.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_value_construct.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_value_construct.md b/reference/memory/uninitialized_value_construct.md
index 40a40f771..4f27319ed 100644
--- a/reference/memory/uninitialized_value_construct.md
+++ b/reference/memory/uninitialized_value_construct.md
@@ -20,7 +20,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲の各要素を値構築する。
 
-未初期化領域の入力範囲`[first, last)`の各要素を値構築する (ゼロ初期化する)。
+未初期化領域の入力イテレータ範囲`[first, last)`の各要素を値構築する (ゼロ初期化する)。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>uninitialized_value_construct_n -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/memory/uninitialized_value_construct_n.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/memory/uninitialized_value_construct_n.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/uninitialized_value_construct_n.md b/reference/memory/uninitialized_value_construct_n.md
index f6ce9b8ff..5645f1872 100644
--- a/reference/memory/uninitialized_value_construct_n.md
+++ b/reference/memory/uninitialized_value_construct_n.md
@@ -22,7 +22,7 @@ namespace std {
 ## 概要
 未初期化領域の範囲のうち、先頭N個の要素を値構築する。
 
-未初期化領域の入力範囲`[first, first + n)`の各要素を値構築する (ゼロ初期化する)。
+未初期化領域の入力イテレータ範囲`[first, first + n)`の各要素を値構築する (ゼロ初期化する)。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>accumulate -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/accumulate.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/accumulate.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/accumulate.md b/reference/numeric/accumulate.md
index 55fafa2c1..0e1324c5f 100644
--- a/reference/numeric/accumulate.md
+++ b/reference/numeric/accumulate.md
@@ -20,9 +20,9 @@ namespace std{
 ```
 
 ## 概要
-`accumulate()`は、範囲を集計する関数である。
+`accumulate()`は、イテレータ範囲`[first, last)`を集計する関数である。
 
-初期値(`init`)に対して、範囲`[first, last)`の各要素`i`を前から順番に、任意の二項演算関数`binary_op`を`init = f(init, *i)`のように適用していき、範囲の全ての要素を集計した結果を戻り値として返す。
+初期値(`init`)に対して、イテレータ範囲`[first, last)`の各要素`i`を前から順番に、任意の二項演算関数`binary_op`を`init = f(init, *i)`のように適用していき、範囲の全ての要素を集計した結果を戻り値として返す。
 
 他の言語でこのような処理は、`foldL` (Haskell)、`reduce` (Common Lisp, Ruby)、`aggregate` (C#)などと呼ばれている。
 
@@ -32,7 +32,7 @@ namespace std{
 
 ## 要件
 - C++03まで : `binary_op`は副作用を起こしてはならない
-- C++11から : `binary_op`は、範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
+- C++11から : `binary_op`は、イテレータ範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
@@ -52,7 +52,7 @@ namespace std{
 
 
 ## 計算量
-範囲`[first, last)`の要素数に対して線形時間
+イテレータ範囲`[first, last)`の要素数に対して線形時間
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacent_difference -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/adjacent_difference.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/adjacent_difference.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/adjacent_difference.md b/reference/numeric/adjacent_difference.md
index bc3f0e93a..561c6f3e3 100644
--- a/reference/numeric/adjacent_difference.md
+++ b/reference/numeric/adjacent_difference.md
@@ -50,7 +50,7 @@ namespace std {
 ## 概要
 隣接する要素間の差を計算する。
 
-この関数に与えられた範囲`[first, last)`を`r`として、その範囲の隣接する要素同士の差を、`{r[0], r[1] - r[0], r[2] - r[1], r[3] - r[2], r[4] - r[3]}`のように演算して求められた新たな範囲を返す。
+この関数に与えられたイテレータ範囲`[first, last)`を`r`として、その範囲の隣接する要素同士の差を、`{r[0], r[1] - r[0], r[2] - r[1], r[3] - r[2], r[4] - r[3]}`のように演算して求められた新たな範囲を返す。
 
 - (1), (3) : 各隣接要素`a`と`b`を`operator-(b, a)`で減算した結果を、`result`出力イテレータに書き込む
 - (2), (4) : 各隣接要素`a`と`b`を`binary_op(b, a)`で減算した結果を、`result`出力イテレータに書き込む
@@ -59,9 +59,9 @@ namespace std {
 ## 要件
 - (2) :
     - C++03まで : 関数オブジェクト`binary_op`の呼び出しは、副作用を起こしてはならない
-    - C++11から : 関数オブジェクト`binary_op`の呼び出しが、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更、イテレータの無効化をしてはならない
+    - C++11から : 関数オブジェクト`binary_op`の呼び出しが、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更、イテレータの無効化をしてはならない
 - (3), (4) :
-    - 範囲`[first, last)`と範囲`[result, result + (last - first))`は重なってはならない
+    - イテレータ範囲`[first, last)`とイテレータ範囲`[result, result + (last - first))`は重なってはならない
 
 
 ## テンプレートパラメータ制約
@@ -82,14 +82,14 @@ namespace std {
 
 
 ## 効果
-- (1), (2) : 非空の範囲`[first, last)`について、
+- (1), (2) : 非空のイテレータ範囲`[first, last)`について、
     1. `*result = *first`で結果の初期値を書き込む。`acc = *first`としてひとつ前の位置の値を保持する
-    2. 範囲`[first + 1, last)`の各イテレータを`i`、そのイテレータが指す値を`val`として定義する
+    2. イテレータ範囲`[first + 1, last)`の各イテレータを`i`、そのイテレータが指す値を`val`として定義する
     3.
         - C++17 : (1)であれば`val - acc`、(2)であれば`binary_op(val, acc)`で隣接値を求めて、その結果を`*result`に代入する
         - C++20 : (1)であれば`val -` [`std::move`](/reference/utility/move.md)`(acc)`、(2)であれば`binary_op(val,` [`std::move`](/reference/utility/move.md)`d(acc))`で隣接値を求めて、その結果を`*result`に代入する
     4. `val`を`acc`にムーブ代入し、ひとつ前の位置の値を更新する
-- (3), (4) : 非空の範囲`[first, last)`について、
+- (3), (4) : 非空のイテレータ範囲`[first, last)`について、
     1. `*result = *first`で結果の初期値を代入する
     2. インデックス範囲`[1, last - first - 1]`のそれぞれの値`d`として定義する
     3. (3)であれば`val = *(first + d) - *(first + d - 1)`、(4)であれば`val = binary_op(*(first + d), *(first + d - 1))`として、隣接値を求める
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>exclusive_scan -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/exclusive_scan.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/exclusive_scan.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/exclusive_scan.md b/reference/numeric/exclusive_scan.md
index c2d383d83..c3ea1ad86 100644
--- a/reference/numeric/exclusive_scan.md
+++ b/reference/numeric/exclusive_scan.md
@@ -55,7 +55,7 @@ namespace std{
 ```
 
 ## 概要
-範囲の部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含めず範囲`[0, i)`までの部分和を計算する。
+イテレータ範囲`[first, last)`の部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含めず範囲`[0, i)`までの部分和を計算する。
 
 `exclusive_scan()`の引数として初期値`0`、およびシーケンス`{1, 2, 3}`が与えられた場合、以下のような結果が行われる：
 
@@ -75,7 +75,7 @@ namespace std{
 
 ## 要件
 - (2), (4) :
-    - 関数オブジェクト`binary_op`の呼び出しは、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
+    - 関数オブジェクト`binary_op`の呼び出しは、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inclusive_scan -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/inclusive_scan.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/inclusive_scan.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/inclusive_scan.md b/reference/numeric/inclusive_scan.md
index 17092d984..1ec04f407 100644
--- a/reference/numeric/inclusive_scan.md
+++ b/reference/numeric/inclusive_scan.md
@@ -74,7 +74,7 @@ namespace std{
 ```
 
 ## 概要
-範囲の部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含め、範囲`[0, i]`までの部分和を計算する。
+イテレータ範囲`[first, last)`の部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含め、範囲`[0, i]`までの部分和を計算する。
 
 `inclusive_scan()`の引数として、初期値`0`、およびシーケンス`{1, 2, 3}`が与えられた場合、以下のような結果が行われる：
 
@@ -97,7 +97,7 @@ namespace std{
 
 
 ## 要件
-- (2), (3), (5), (6) : 関数オブジェクト`binary_op`の呼び出しは、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
+- (2), (3), (5), (6) : 関数オブジェクト`binary_op`の呼び出しは、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>inner_product -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/inner_product.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/inner_product.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/inner_product.md b/reference/numeric/inner_product.md
index e0f5578c9..a15b27bd9 100644
--- a/reference/numeric/inner_product.md
+++ b/reference/numeric/inner_product.md
@@ -40,9 +40,9 @@ namespace std {
 ## 概要
 2つのシーケンスの内積(inner product)を計算する。
 
-この関数は、範囲`[first1, last1)`および範囲`[first2, first2 + (last1 - first1))`をそれぞれ任意次元のベクトルとみなし、その2つのベクトルの内積を計算する。
+この関数は、イテレータ範囲`[first1, last1)`およびイテレータ範囲`[first2, first2 + (last1 - first1))`をそれぞれ任意次元のベクトルとみなし、その2つのベクトルの内積を計算する。
 
-範囲`[first1, last1)`をベクトル`v`、範囲`[first2, first2 + (last1 - first1))`をベクトル`u`として、この関数は以下の効果を持つ：
+イテレータ範囲`[first1, last1)`をベクトル`v`、イテレータ範囲`[first2, first2 + (last1 - first1))`をベクトル`u`として、この関数は以下の効果を持つ：
 
 - (1) : `init + (v[0] * u[0]) + (v[1] * u[1]) + … (v[N - 1] * u[N - 1])`
 - (2) : `operator()+`を`binary_op1`、`operator*()`を`binary_op2`で代用して、(1)の演算を行う
@@ -50,7 +50,7 @@ namespace std {
 
 ## 要件
 - C++03まで : `binary_op1`および`binary_op2`は、副作用を起こしてはならない
-- C++11から : `binary_op1`および`binary_op2`が、範囲`[first1, last1]`と範囲`[first2, first2 + (last1 - first2)]`の要素変更およびイテレータの無効化をしてはならない
+- C++11から : `binary_op1`および`binary_op2`が、イテレータ範囲`[first1, last1]`とイテレータ範囲`[first2, first2 + (last1 - first2)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
@@ -60,11 +60,11 @@ namespace std {
 
 ## 効果
 - (1) :
-    - C++03 : `acc = init;`、範囲`[first1, last1)`の各イテレータを`i`、範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = acc + (*i) * (*j);` の演算を行い、`acc`を返す
-    - C++20 : `acc = init;`、範囲`[first1, last1)`の各イテレータを`i`、範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc =` [`std::move`](/reference/utility/move.md)`(acc) + (*i) * (*j);` の演算を行い、`acc`を返す
+    - C++03 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = acc + (*i) * (*j);` の演算を行い、`acc`を返す
+    - C++20 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc =` [`std::move`](/reference/utility/move.md)`(acc) + (*i) * (*j);` の演算を行い、`acc`を返す
 - (2) :
-    - C++03 : `acc = init;`、範囲`[first1, last1)`の各イテレータを`i`、範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(acc, binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
-    - C++20 : `acc = init;`、範囲`[first1, last1)`の各イテレータを`i`、範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(`[`std::move`](/reference/utility/move.md)`(acc), binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
+    - C++03 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(acc, binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
+    - C++20 : `acc = init;`、イテレータ範囲`[first1, last1)`の各イテレータを`i`、イテレータ範囲`[first2, first2 + (last1 - first1))`の各イテレータ`をj`として、`acc = binary_op1(`[`std::move`](/reference/utility/move.md)`(acc), binary_op2((*i), (*j)));` の演算を行い、`acc`を返す
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iota -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/iota.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/iota.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/iota.md b/reference/numeric/iota.md
index 7da16a1d3..86800506e 100644
--- a/reference/numeric/iota.md
+++ b/reference/numeric/iota.md
@@ -29,7 +29,7 @@ namespace std{
 
 
 ## 効果
-範囲`[first, last)`の各要素`it`について、先頭から順番に `*it = value; ++value;` を行う
+イテレータ範囲`[first, last)`の各要素`it`について、先頭から順番に `*it = value; ++value;` を行う
 
 
 ## 戻り値
@@ -37,7 +37,7 @@ namespace std{
 
 
 ## 計算量
-範囲`[first, last)`の要素数をnとして、n回のインクリメントと代入が行われる。
+イテレータ範囲`[first, last)`の要素数をnとして、n回のインクリメントと代入が行われる。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>partial_sum -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/partial_sum.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/partial_sum.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/partial_sum.md b/reference/numeric/partial_sum.md
index 2c3a8a341..f6305b306 100644
--- a/reference/numeric/partial_sum.md
+++ b/reference/numeric/partial_sum.md
@@ -32,7 +32,7 @@ namespace std {
 ```
 
 ## 概要
-範囲の値の部分和を計算する。
+イテレータ範囲`[first, last)`の値の部分和を計算する。
 
 [`accumulate()`](accumulate.md)は最終結果のみを得るが、`partial_sum()`は計算の途中結果のシーケンスを得る。
 
@@ -67,12 +67,12 @@ namespace std {
 - C++11から : `InputIterator`の値型は、`*first`の型から構築可能でなければならない
 - C++11から : `binary_op`の戻り値が、`InputIterator`の値型に変換可能でなければならない
 - C++11から : `binary_op`の戻り値が、`result`出力イテレータに書き込めなければならない
-- C++11から : `binary_op`は入力範囲`[first, last]`および出力範囲`[result, result + (last - first)]`の要素を変更してはならず、そのイテレータと部分範囲を無効化してはならない
+- C++11から : `binary_op`は入力イテレータ範囲`[first, last]`および出力イテレータ範囲`[result, result + (last - first)]`の要素を変更してはならず、そのイテレータと部分範囲を無効化してはならない
 
 
 ## 効果
 - (1) : `binary_op`を`operator+`として、(2)の演算を行う
-- (2) : 出力結果の範囲`[result, result + (last - first))`には、以下が書き込まれる：
+- (2) : 出力結果のイテレータ範囲`[result, result + (last - first))`には、以下が書き込まれる：
     - C++03 :
 
     ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>iota -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/ranges_iota.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/ranges_iota.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/ranges_iota.md b/reference/numeric/ranges_iota.md
index 07df75b5f..afd8ae3e7 100644
--- a/reference/numeric/ranges_iota.md
+++ b/reference/numeric/ranges_iota.md
@@ -28,8 +28,8 @@ namespace std::ranges {
 ## 概要
 指定された値から始まる、インクリメント演算子による増加列を生成する。
 
-* (1): イテレータペアで範囲を指定する
-* (2): 範囲を直接指定する
+- (1): イテレータ範囲を指定する
+- (2): Rangeを直接指定する
 
 `iota()`関数は、値の範囲`[value, value + (last - first))`を前から順番に範囲`[first, last)`の各要素に代入する。
 
@@ -37,7 +37,7 @@ namespace std::ranges {
 
 
 ## 効果
-範囲`[first, last)`の各要素`it`について、先頭から順番に `*it = value; ++value;` を行う
+イテレータ範囲`[first, last)`の各要素`it`について、先頭から順番に `*it = value; ++value;` を行う
 
 
 ## 戻り値
@@ -45,7 +45,7 @@ namespace std::ranges {
 
 
 ## 計算量
-範囲`[first, last)`の要素数をnとして、n回のインクリメントと代入が行われる。
+イテレータ範囲`[first, last)`の要素数をnとして、n回のインクリメントと代入が行われる。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>reduce -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/reduce.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/reduce.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/reduce.md b/reference/numeric/reduce.md
index 755e20e55..c49640fea 100644
--- a/reference/numeric/reduce.md
+++ b/reference/numeric/reduce.md
@@ -50,11 +50,11 @@ namespace std{
 * iterator_traits[link /reference/iterator/iterator_traits.md]
 
 ## 概要
-`reduce()`は、範囲を集計する関数である。[`accumulate()`](accumulate.md)関数は範囲の先頭から順に要素を集計するが、この関数は並列計算のために集計順を規定しない。
+`reduce()`は、イテレータ範囲`[first, last)`を集計する関数である。[`accumulate()`](accumulate.md)関数は範囲の先頭から順に要素を集計するが、この関数は並列計算のために集計順を規定しない。
 
-初期値(`init`)と範囲`[first, last)`を合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
+初期値(`init`)とイテレータ範囲`[first, last)`を合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
 
-- (1) : 集計の初期値を範囲の要素型の値初期化値 (算術型なら`0`) とし、二項演算に`operator+`を使用する。それによって、このオーバーロードは、範囲の合計値を求める処理となる
+- (1) : 集計の初期値をイテレータ範囲の要素型の値初期化値 (算術型なら`0`) とし、二項演算に`operator+`を使用する。それによって、このオーバーロードは、範囲の合計値を求める処理となる
 - (2) : 初期値をパラメータ`init`として受け取り、二項演算は`operator+`を使用する
 - (3) : 初期値をパラメータ`init`として受け取り、任意の二項演算`binary_op`を使用して集計を行う
 - (4) : (1)の並列アルゴリズム版。第1パラメータとして実行ポリシーをとる
@@ -63,7 +63,7 @@ namespace std{
 
 
 ## 要件
-- (3), (6) : 関数オブジェクト`binary_op`の呼び出しは、範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
+- (3), (6) : 関数オブジェクト`binary_op`の呼び出しは、イテレータ範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
@@ -89,7 +89,7 @@ namespace std{
     ```
     * plus[link /reference/functional/plus.md]
 
-- (3), (6) : 範囲`[first, last)`について、リスト`[init, *first, *(first + 1), *(first + 2), ... *(first + (last - first - 1))]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op(sum1, sum2)`のように集計して返す
+- (3), (6) : イテレータ範囲`[first, last)`について、リスト`[init, *first, *(first + 1), *(first + 2), ... *(first + (last - first - 1))]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op(sum1, sum2)`のように集計して返す
 
 - (4) : 以下と等価
     ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform_exclusive_scan -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/transform_exclusive_scan.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/transform_exclusive_scan.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/transform_exclusive_scan.md b/reference/numeric/transform_exclusive_scan.md
index 52fd1d58c..1ec2938fc 100644
--- a/reference/numeric/transform_exclusive_scan.md
+++ b/reference/numeric/transform_exclusive_scan.md
@@ -40,7 +40,7 @@ namespace std{
 ```
 
 ## 概要
-範囲の要素を変換しながら部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含めず範囲`[0, i)`までの部分和を計算する。
+イテレータ範囲`[first, last)`の要素を変換しながら部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含めず範囲`[0, i)`までの部分和を計算する。
 
 `transform_exclusive_scan()`の引数として初期値`0`、シーケンス`{1, 2, 3}`が与えられ、和に相当する二項演算関数オブジェクト`binary_op`を`operator+`、要素変換の関数オブジェクト`unary_op`をパラメータをそのまま返す関数`f()`であるとして、、以下のような結果が行われる：
 
@@ -58,7 +58,7 @@ namespace std{
 
 ## 要件
 - (1), (2) :
-    - 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
+    - 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform_inclusive_scan -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/transform_inclusive_scan.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/transform_inclusive_scan.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/transform_inclusive_scan.md b/reference/numeric/transform_inclusive_scan.md
index 86a5fd071..8c604ea5d 100644
--- a/reference/numeric/transform_inclusive_scan.md
+++ b/reference/numeric/transform_inclusive_scan.md
@@ -68,7 +68,7 @@ namespace std{
 ```
 
 ## 概要
-範囲の要素を変換しながら部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含め、範囲`[0, i]`までの部分和を計算する。
+イテレータ範囲`[first, last)`の要素を変換しながら部分和を計算する。この関数は、i番目の部分和を求める際にi番目の要素を含め、範囲`[0, i]`までの部分和を計算する。
 
 `transform_inclusive_scan()`の引数として、初期値`0`、シーケンス`{1, 2, 3}`が与えられ、和に相当する二項演算関数オブジェクト`binary_op`を`operator+`、要素変換の関数オブジェクト`unary_op`をパラメータをそのまま返す関数`f()`であるとして、以下のような結果が行われる：
 
@@ -89,7 +89,7 @@ namespace std{
 
 
 ## 要件
-- (1), (2), (3), (4) : 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、範囲`[first, last]`および範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
+- (1), (2), (3), (4) : 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、イテレータ範囲`[first, last]`およびイテレータ範囲`[result, result + (last - first)]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>transform_reduce -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/numeric/transform_reduce.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/numeric/transform_reduce.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/transform_reduce.md b/reference/numeric/transform_reduce.md
index ae05eaadd..0c5a6d108 100644
--- a/reference/numeric/transform_reduce.md
+++ b/reference/numeric/transform_reduce.md
@@ -84,11 +84,11 @@ namespace std{
 ```
 
 ## 概要
-`transform_reduce()`は、範囲の要素を変換しながら集計する関数である。
+`transform_reduce()`は、イテレータ範囲の要素を変換しながら集計する関数である。
 
-(1)、(2)、(4)、(5)は、範囲`[first1, last1)`の各要素を`x`、範囲`[first2, first2+(last1 - first1))`の各要素を`y`として、初期値(`init`)と`binary_op2(x, y)`した各要素を合算したリストの任意の組み合わせに、順不同で`binary_op1(binary_op1(a, b), binary_op1(c, d))`のように適用していき、集計値を計算する。
+(1)、(2)、(4)、(5)は、イテレータ範囲`[first1, last1)`の各要素を`x`、イテレータ範囲`[first2, first2+(last1 - first1))`の各要素を`y`として、初期値(`init`)と`binary_op2(x, y)`した各要素を合算したリストの任意の組み合わせに、順不同で`binary_op1(binary_op1(a, b), binary_op1(c, d))`のように適用していき、集計値を計算する。
 
-(3)と(6)は、初期値(`init`)と、範囲`[first, last)`の各要素に関数オブジェクト`unary_op`を適用して合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
+(3)と(6)は、初期値(`init`)と、イテレータ範囲`[first, last)`の各要素に関数オブジェクト`unary_op`を適用して合算したリストの任意の組み合わせに、順不同で`binary_op(binary_op(a, b), binary_op(c, d))`のように適用していき、集計値を計算する。
 
 - (1) : リスト集計の二項演算に`operator+`を使用し、2つの範囲の要素を掛け合わせる二項演算に`operator*`を使用する
 - (2) : リスト集計の二項演算に`binary_op1`を使用し、2つの範囲の要素を掛け合わせる二項演算に`binary_op2`を使用する
@@ -99,8 +99,8 @@ namespace std{
 
 
 ## 要件
-- (1), (2), (4), (5) : 関数オブジェクト`binary_op1`と`binary_op2`の呼び出しは、範囲`[first1, last1]`と`[first2, first2 + (last1 - first1)]`の要素変更およびイテレータの無効化をしてはならない
-- (3), (6) : 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
+- (1), (2), (4), (5) : 関数オブジェクト`binary_op1`と`binary_op2`の呼び出しは、イテレータ範囲`[first1, last1]`と`[first2, first2 + (last1 - first1)]`の要素変更およびイテレータの無効化をしてはならない
+- (3), (6) : 関数オブジェクト`unary_op`と`binary_op`の呼び出しは、イテレータ範囲`[first, last]`の要素変更およびイテレータの無効化をしてはならない
 
 
 ## テンプレートパラメータ制約
@@ -125,9 +125,9 @@ namespace std{
     * plus[link /reference/functional/plus.md]
     * multiplies[link /reference/functional/multiplies.md]
 
-- (2), (5) : 範囲`[first1, last1)`と`[first2, first2+(last1 - first1))`について、リスト`[init, binary_op2(*first1, *first2), binary_op2(*(first1 + 1), *(first2 + 1)), binary_op2(*(first1 + 2), *(first2 + 2)), ...]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op1(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op1(sum1, sum2)`のように集計して返す
+- (2), (5) : イテレータ範囲`[first1, last1)`と`[first2, first2+(last1 - first1))`について、リスト`[init, binary_op2(*first1, *first2), binary_op2(*(first1 + 1), *(first2 + 1)), binary_op2(*(first1 + 2), *(first2 + 2)), ...]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op1(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op1(sum1, sum2)`のように集計して返す
 
-- (3), (6) : 範囲`[first, last)`について、リスト`[init, unary_op(*first), unary_op(*(first + 1)), unary_op(*(first + 2)), ... unary_op(*(first + (last - first - 1)))]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op(sum1, sum2)`のように集計して返す
+- (3), (6) : イテレータ範囲`[first, last)`について、リスト`[init, unary_op(*first), unary_op(*(first + 1)), unary_op(*(first + 2)), ... unary_op(*(first + (last - first - 1)))]`を任意の部分リストへ分割し、各部分リストの要素を順不同に`binary_op(a, b)`を実行していき、それを実行していった結果同士も順不同に`binary_op(sum1, sum2)`のように集計して返す
 
 - (4) : 以下と等価
     ```cpp
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/queue/priority_queue/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/queue/priority_queue/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/queue/priority_queue/op_constructor.md b/reference/queue/priority_queue/op_constructor.md
index 6ea308258..12aebaeb3 100644
--- a/reference/queue/priority_queue/op_constructor.md
+++ b/reference/queue/priority_queue/op_constructor.md
@@ -174,11 +174,11 @@ int main()
   // que2からムーブ構築
   std::priority_queue&amp;lt;int&amp;gt; que3 = std::move(que2);
 
-  // イテレータの範囲から構築
+  // イテレータ範囲から構築
   const std::vector&amp;lt;int&amp;gt; v = {3, 1, 4};
   std::priority_queue&amp;lt;int&amp;gt; que4(v.begin(), v.end());
 
-  // イテレータの範囲、比較関数オブジェクト、コンテナから構築
+  // イテレータ範囲、比較関数オブジェクト、コンテナから構築
   const std::vector&amp;lt;int&amp;gt; v2 = {5, 2};
   std::priority_queue&amp;lt;int&amp;gt; que5(v.begin(), v.end(), {}, v2);
 
@@ -208,4 +208,4 @@ que5 : 5 4 3 2 1
 
 ## 参照
 
-- [P0935R0 Eradicating unnecessarily explicit default constructors from the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0935r0.html)
\ No newline at end of file
+- [P0935R0 Eradicating unnecessarily explicit default constructors from the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0935r0.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>subrange -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/ranges/subrange.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange.md b/reference/ranges/subrange.md
index 6d5d3a8ce..816694692 100644
--- a/reference/ranges/subrange.md
+++ b/reference/ranges/subrange.md
@@ -18,7 +18,7 @@ namespace std::ranges {
 * view_interface[link view_interface.md]
 
 ## 概要
-`subrange`は、イテレータ`i`と番兵`s`が表す範囲`[i, s)`をRangeとして扱うクラステンプレート。
+`subrange`は、イテレータ`i`と番兵`s`が表すイテレータ範囲`[i, s)`をRangeとして扱うクラステンプレート。
 
 `subrange`は[`borrowed_range`](borrowed_range.md)、[`view`](view.md)のモデルであり、また、大きさ2のtuple-likeな型である。第0要素はイテレータ、第1要素は番兵。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/ranges/subrange/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/ranges/subrange/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ranges/subrange/op_constructor.md b/reference/ranges/subrange/op_constructor.md
index 4f5a4a2d3..6abc563de 100644
--- a/reference/ranges/subrange/op_constructor.md
+++ b/reference/ranges/subrange/op_constructor.md
@@ -40,8 +40,8 @@ constexpr subrange(R&amp;amp;&amp;amp; r, make-unsigned-like-t&amp;lt;iter_difference_t&amp;lt;I&amp;gt;&amp;gt; n)
 
 ## 概要
 - (1) : 空の`subrange`を構築する(デフォルトコンストラクタ)
-- (2) : イテレータ`i`と番兵`s`が表す範囲`[i, s)`で初期化する
-- (3) : イテレータ`i`と番兵`s`が表す範囲`[i, s)`で初期化し、`subrange`の長さを`n`にする
+- (2) : イテレータ`i`と番兵`s`が表すイテレータ範囲`[i, s)`で初期化する
+- (3) : イテレータ`i`と番兵`s`が表すイテレータ範囲`[i, s)`で初期化し、`subrange`の長さを`n`にする
 - (4) : 範囲 `r` で初期化する
 - (5) : 範囲 `r` で初期化し、`subrange`の長さを`n`にする ((3)へ委譲)
 
@@ -65,8 +65,8 @@ static constexpr bool StoreSize = (K == subrange_kind::sized &amp;amp;&amp;amp; !sized_sentinel_
 
 ## 事前条件
 
-- (2): `[i, s)`は有効な範囲であること
-- (3): `[i, s)`は有効な範囲であり、`n`はその範囲の長さ([`ranges::distance](/reference/iterator/ranges_distance.md)`(i, s)`)と等しいこと
+- (2): `[i, s)`は有効なイテレータ範囲であること
+- (3): `[i, s)`は有効なイテレータ範囲であり、`n`はその範囲の長さ([`ranges::distance](/reference/iterator/ranges_distance.md)`(i, s)`)と等しいこと
 - (4): `r`は有効な範囲であること
 - (5): `r`は有効な範囲であり、`n`はその範囲の長さと等しいこと
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/multiset/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/erase.md b/reference/set/multiset/erase.md
index d306aa296..5d22911a4 100644
--- a/reference/set/multiset/erase.md
+++ b/reference/set/multiset/erase.md
@@ -16,14 +16,14 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 概要
-単一要素または要素範囲（`[first, last)`）を `multiset` コンテナから削除する。 
+単一要素またはイテレータ範囲`[first, last)`を `multiset` コンテナから削除する。 
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 
 ## パラメータ
 - `position` : `multiset` から削除する単一要素を指すイテレータ。`iterator`、および、`const_iterator` はメンバ型であり、双方向イテレータとして定義される。
 - `x` : `set` から削除される値。`key_type` はメンバ型であり、`multiset` コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素の型である。
-- `first, last` : `multiset` コンテナ内の、削除される範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+- `first, last` : `multiset` コンテナ内の、削除されるイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/multiset/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/multiset/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/multiset/op_equal.md b/reference/set/multiset/op_equal.md
index 4ec2134ac..1c3cc1ac2 100644
--- a/reference/set/multiset/op_equal.md
+++ b/reference/set/multiset/op_equal.md
@@ -62,6 +62,6 @@ int main()
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/set/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/set/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/erase.md b/reference/set/set/erase.md
index 3ab8a206e..7dfa75ab7 100644
--- a/reference/set/set/erase.md
+++ b/reference/set/set/erase.md
@@ -16,14 +16,14 @@ size_type erase(const key_type&amp;amp; x);                        // (3)
 
 
 ## 概要
-単一要素または要素範囲（`[first, last)`）を `set` コンテナから削除する。 
+単一要素またはイテレータ範囲`[first, last)`を `set` コンテナから削除する。 
 これは削除された要素の数だけコンテナの [`size`](size.md)`()` を減らし、それぞれの要素のデストラクタを呼び出す。
 
 
 ## パラメータ
 - `position` : `set` から削除する単一要素を指すイテレータ。`iterator`、および、`const_iterator` はメンバ型であり、双方向イテレータとして定義される。
 - `x` : `set` から削除される値。`key_type` はメンバ型であり、`set` コンテナの中で `Key` の別名として定義される。ここで `Key` は 1 番目のテンプレートパラメータであり、コンテナに格納される要素の型である。
-- `first, last` : `set` コンテナ内の、削除される範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
+- `first, last` : `set` コンテナ内の、削除されるイテレータ範囲 `[first, last)` を指定するイテレータ。ここでいう範囲は `first` と `last` の間の全ての要素を含み、`first` が指す要素を含むが `last` が指す要素は含まない。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/set/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/set/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/op_constructor.md b/reference/set/set/op_constructor.md
index cb27c3e8b..d87fbf344 100644
--- a/reference/set/set/op_constructor.md
+++ b/reference/set/set/op_constructor.md
@@ -49,7 +49,7 @@ set(initializer_list&amp;lt;value_type&amp;gt; init,
 - (2) : 比較関数オブジェクトを受け取るコンストラクタ。受け取った比較関数オブジェクトを、このコンテナでの要素比較に使用する。要素数が空の`set`オブジェクトを構築する。
 - (1) + (2) : デフォルトコンストラクタ。空のコンテナを構築する。
 - (3) : アロケータを別で受け取り、要素数が空の`set`オブジェクトを構築する。
-- (4) : 範囲 `[first, last)` のコンテンツで構築する。
+- (4) : イテレータ範囲 `[first, last)` のコンテンツで構築する。
 - (5) : (4)のコンストラクタを `set(first, last, Compare(), a)` のように呼び出して、`set`オブジェクトを構築する。
 - (6), (8) : コピーコンストラクタ。`x`のコンテンツのコピーでコンテナを構築する。もし `alloc` が与えられなかった場合、アロケータを `std::`[`allocator_traits`](../../memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::`[`select_on_container_copy_construction`](../../memory/allocator_traits/select_on_container_copy_construction.md)`(x.`[`get_allocator`](get_allocator.md)`())` の呼び出しによって取得する。
 - (7), (9) : ムーブコンストラクタ。`y` のコンテンツをムーブすることでコンテナを構築する。もし `alloc` が与えられなかった場合、アロケータを `y` に属しているアロケータをムーブして取得する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/set/set/op_equal.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/set/set/op_equal.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set/op_equal.md b/reference/set/set/op_equal.md
index 8c0fd1e0e..187e927cb 100644
--- a/reference/set/set/op_equal.md
+++ b/reference/set/set/op_equal.md
@@ -62,6 +62,6 @@ int main()
 
 ## 参照
 - [LWG Issue 2257. Simplify container requirements with the new algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2257)
-    - C++14から、2つ目の範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
+    - C++14から、2つ目のイテレータ範囲のendイテレータをとる`equal()`アルゴリズムを使用するようになった。
 - [P1614R2 The Mothership has Landed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1614r2.html)
     - C++20での三方比較演算子の追加と、関連する演算子の自動導出
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/span/span/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/span/span/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span/op_constructor.md b/reference/span/span/op_constructor.md
index 06765a532..39633c584 100644
--- a/reference/span/span/op_constructor.md
+++ b/reference/span/span/op_constructor.md
@@ -92,11 +92,11 @@ constexpr explicit(extent != dynamic_extent &amp;amp;&amp;amp; OtherExtent == dynamic_extent)
 
 ## 事前条件
 - (2) :
-    - `[first, first + count)`が妥当な範囲であること
+    - `[first, first + count)`が妥当なイテレータ範囲であること
     - 型 `It` はコンセプト [`std::contiguous_iterator`](/reference/iterator/contiguous_iterator.md) のモデルであること
     - メンバ定数`extent`が[`dynamic_extent`](/reference/span/dynamic_extent.md)と等値ではない場合、`count`と`extent`が等値であること
 - (3) :
-    - `[first, last)`が妥当な範囲であること
+    - `[first, last)`が妥当なイテレータ範囲であること
     - メンバ定数`extent`が[`dynamic_extent`](/reference/span/dynamic_extent.md)と等値ではない場合、`last - first`と`extent`が等値であること
     - 型 `It` はコンセプト [`std::contiguous_iterator`](/reference/iterator/contiguous_iterator.md) のモデルであること
     - 型 `End` はコンセプト [`std::sized_sentinel_for`](/reference/iterator/sized_sentinel_for.md)`&amp;lt;It&amp;gt;` のモデルであること
@@ -109,8 +109,8 @@ constexpr explicit(extent != dynamic_extent &amp;amp;&amp;amp; OtherExtent == dynamic_extent)
 
 
 ## 効果
-- (2) : 範囲`[first, first + count)`を参照する`span`オブジェクトを構築する
-- (3) : 範囲`[first, last)`を参照する`span`オブジェクトを構築する
+- (2) : イテレータ範囲`[first, first + count)`を参照する`span`オブジェクトを構築する
+- (3) : イテレータ範囲`[first, last)`を参照する`span`オブジェクトを構築する
 - (4), (5), (6) : 範囲`[`[`data`](/reference/iterator/data.md)`(arr),` [`data`](/reference/iterator/data.md)`(arr) + N)`を参照する`span`オブジェクトを構築する
 - (7) : 範囲`[std::ranges::data(r), std::ranges::data(r) + std::ranges::size(r))`を参照する`span`オブジェクトを構築する
 - (9) : 範囲`[s.`[`data()`](data.md)`, s.`[`data()`](data.md) `+ s.`[`size()`](size.md)`)`を参照する`span`オブジェクトを構築する
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>current -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/stacktrace/basic_stacktrace/current.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/stacktrace/basic_stacktrace/current.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stacktrace/basic_stacktrace/current.md b/reference/stacktrace/basic_stacktrace/current.md
index 9e18a3e87..f1a5e8f9b 100644
--- a/reference/stacktrace/basic_stacktrace/current.md
+++ b/reference/stacktrace/basic_stacktrace/current.md
@@ -37,10 +37,10 @@ static basic_stacktrace
     - `alloc`は[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数に渡される
 - (2) :
     - `basic_stacktrace::current(alloc)`で構築されたオブジェクト`st`の[`st.size()`](size.md)を`n`として、
-    - 範囲`[st.begin() + min(n, skip), st.end())`と`alloc`を、[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数として保持する。ただし、その初期化に失敗した場合、`basic_stacktrace`オブジェクトは空になる
+    - イテレータ範囲`[st.begin() + min(n, skip), st.end())`と`alloc`を、[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数として保持する。ただし、その初期化に失敗した場合、`basic_stacktrace`オブジェクトは空になる
 - (3) :
     - `basic_stacktrace::current(alloc)`で構築されたオブジェクト`st`の[`st.size()`](size.md)を`n`として、
-    - 範囲`[st.begin() + min(n, skip), st.begin() + min(n, skip + max_depth))`と`alloc`を、[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数として保持する。ただし、その初期化に失敗した場合、`basic_stacktrace`オブジェクトは空になる
+    - イテレータ範囲`[st.begin() + min(n, skip), st.begin() + min(n, skip + max_depth))`と`alloc`を、[`stacktrace_entry`](/reference/stacktrace/stacktrace_entry.md)オブジェクトの配列を保持する[`std::vector`](/reference/vector/vector.md)型メンバ変数として保持する。ただし、その初期化に失敗した場合、`basic_stacktrace`オブジェクトは空になる
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>append -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/append.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/append.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/append.md b/reference/string/basic_string/append.md
index 593e99a65..8ebc7b88d 100644
--- a/reference/string/basic_string/append.md
+++ b/reference/string/basic_string/append.md
@@ -73,10 +73,10 @@ constexpr basic_string&amp;amp;
     - [`is_convertible_v`](/reference/type_traits/is_convertible.md)`&amp;lt;const T&amp;amp;, const charT*&amp;gt; == false`
 
 ## 要件
-- (2) では、`pos &amp;lt;=` [`size`](size.md)`()` であること。
-- (3) では、`s` は少なくとも `n` の長さを持つ `charT` 型の配列を指していること。
-- (4) では、`s` は少なくとも `traits_type::length(s) + 1` の長さを持つ `charT` 型の配列を指していること。
-- (6) では、`[first, last)` が有効な範囲であること。
+- (2) : `pos &amp;lt;=` [`size`](size.md)`()` であること。
+- (3) : `s` は少なくとも `n` の長さを持つ `charT` 型の配列を指していること。
+- (4) : `s` は少なくとも `traits_type::length(s) + 1` の長さを持つ `charT` 型の配列を指していること。
+- (6) : `[first, last)` が有効なイテレータ範囲であること。
 
 
 ## 効果
@@ -100,7 +100,7 @@ constexpr basic_string&amp;amp;
 - (5) 対象オブジェクトの末尾に、文字 `c` が `n` 文字追加（コピー）される。
     * `append(`[`basic_string`](op_constructor.md)`&amp;lt;value_type, traits_type, allocator_type&amp;gt;(n, c))` と等価。
 
-- (6) 対象オブジェクトの末尾に、範囲 `[first, last)` の文字列が追加（コピー）される。
+- (6) 対象オブジェクトの末尾に、イテレータ範囲 `[first, last)` の文字列が追加（コピー）される。
     * `append(`[`basic_string`](op_constructor.md)`&amp;lt;value_type, traits_type, allocator_type&amp;gt;(first, last))` と等価。
 
 - (7) 対象オブジェクトの末尾に初期化リスト `il` で表された文字列が追加される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/assign.md b/reference/string/basic_string/assign.md
index 0e5cb3015..cb7ef5d7c 100644
--- a/reference/string/basic_string/assign.md
+++ b/reference/string/basic_string/assign.md
@@ -93,7 +93,7 @@ constexpr basic_string&amp;amp;
     - `assign(s,` [`traits::length`](/reference/string/char_traits/length.md)`(s))`を呼び出す。
 - (6) : 文字`c`の`n`回繰り返した文字列からなる`basic_string`オブジェクトを構築する。
     - `assign(basic_string(n, c))`と等価。
-- (7) : 文字列の範囲`[begin, end)`から`basic_string`オブジェクトを構築する。
+- (7) : 文字列のイテレータ範囲`[begin, end)`から`basic_string`オブジェクトを構築する。
     - `assign(basic_string(first, last))`と等価。
 - (8) : 文字の初期化子リストから`basic_string`オブジェクトを構築する。
     - `assign(il.begin(), il.end())`を呼び出す。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/erase.md b/reference/string/basic_string/erase.md
index ae00ecada..3c66ba808 100644
--- a/reference/string/basic_string/erase.md
+++ b/reference/string/basic_string/erase.md
@@ -42,7 +42,7 @@ constexpr iterator
 ## 効果
 - (1) : `n`と[`size()`](size.md) `- pos`のうち小さい方を`xlen`とし、`pos`番目から`xlen`個の要素を削除する。
 - (2) : イテレータ`p`が指す要素を削除する。
-- (3) : 範囲`[first, last)`の文字列を削除する。
+- (3) : イテレータ範囲`[first, last)`の文字列を削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/op_constructor.md b/reference/string/basic_string/op_constructor.md
index cae297a95..b64ae154e 100644
--- a/reference/string/basic_string/op_constructor.md
+++ b/reference/string/basic_string/op_constructor.md
@@ -113,7 +113,7 @@ basic_string(nullptr_t) = delete; // (16) C++23
 - (7) : 文字配列`s`の先頭`n`文字からなる部分文字列のコピーから`basic_string`オブジェクトを構築する。
 - (8) : 文字配列`s`のコピーから`basic_string`オブジェクトを構築する。
 - (9) : 文字`c`の`n`回繰り返した文字列からなる`basic_string`オブジェクトを構築する。
-- (10) : 文字列の範囲`[begin, end)`から`basic_string`オブジェクトを構築する。
+- (10) : 文字列のイテレータ範囲`[begin, end)`から`basic_string`オブジェクトを構築する。
 - (11) : 文字の初期化子リストから`basic_string`オブジェクトを構築する。
 - (12) : アロケータを受け取るコピーコンストラクタ。
 - (13) : アロケータを受け取るムーブコンストラクタ。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>replace -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string/basic_string/replace.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string/basic_string/replace.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/basic_string/replace.md b/reference/string/basic_string/replace.md
index 47abcbde2..1ffedb7c8 100644
--- a/reference/string/basic_string/replace.md
+++ b/reference/string/basic_string/replace.md
@@ -201,13 +201,13 @@ constexpr basic_string&amp;amp;
 - (2) : `pos1 &amp;lt;=` [`size()`](size.md)、および`pos2 &amp;lt;= str.`[`size()`](size.md)であること。
 - (3) : `pos1 &amp;lt;=` [`size()`](size.md)、および文字配列へのポインタ`s`が、少なくても`n2`個の要素を持つ配列を指していること。
 - (4) : `pos &amp;lt;=` [`size()`](size.md)、および文字配列へのポインタ`s`が、少なくても[`traits::length`](/reference/string/char_traits/length.md)`(s) + 1`個の要素を指す配列を指していること。
-- (6) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。
-- (7) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。また、文字配列へのポインタ`s`が、少なくても`n`個の要素を持つ配列を指していること。
-- (8) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。および文字配列へのポインタ`s`が、少なくても[`traits::length`](/reference/string/char_traits/length.md)`(s) + 1`個の要素を指す配列を指していること。
-- (9) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。
-- (10) : `[`[`begin()`](begin.md)`, i1)`、`[i1, i2)`、および`[j1, j2)`が有効な範囲であること。
-- (11) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。
-- (14) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効な範囲であること。
+- (6) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。
+- (7) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。また、文字配列へのポインタ`s`が、少なくても`n`個の要素を持つ配列を指していること。
+- (8) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。および文字配列へのポインタ`s`が、少なくても[`traits::length`](/reference/string/char_traits/length.md)`(s) + 1`個の要素を指す配列を指していること。
+- (9) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。
+- (10) : `[`[`begin()`](begin.md)`, i1)`、`[i1, i2)`、および`[j1, j2)`が有効なイテレータ範囲であること。
+- (11) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。
+- (14) : `[`[`begin()`](begin.md)`, i1)`および`[i1, i2)`が有効なイテレータ範囲であること。
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;&lt; -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/string_view/basic_string_view/op_ostream.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/string_view/basic_string_view/op_ostream.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string_view/basic_string_view/op_ostream.md b/reference/string_view/basic_string_view/op_ostream.md
index 2ae0c4d97..bce2a8bc2 100644
--- a/reference/string_view/basic_string_view/op_ostream.md
+++ b/reference/string_view/basic_string_view/op_ostream.md
@@ -16,7 +16,7 @@ namespace std {
 文字列をストリームへ出力する。
 
 ## 効果
-`[sv.`[`begin()`](begin.md)`, sv.`[`end()`](end.md)`)`の範囲の文字を`os`に出力する。
+イテレータ範囲`[sv.`[`begin()`](begin.md)`, sv.`[`end()`](end.md)`)`の文字を`os`に出力する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_map/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/erase.md b/reference/unordered_map/unordered_map/erase.md
index 1e94b8032..cfbdeb6f0 100644
--- a/reference/unordered_map/unordered_map/erase.md
+++ b/reference/unordered_map/unordered_map/erase.md
@@ -26,7 +26,7 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 ## 効果
 - (1) : `position` で指定された要素を削除する。
 - (2) : `k` と等価なキーの要素を削除する。
-- (3) : `[first, last)` の範囲にある要素を全て削除する。
+- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_map/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/insert.md b/reference/unordered_map/unordered_map/insert.md
index 3f6c2052f..81f309137 100644
--- a/reference/unordered_map/unordered_map/insert.md
+++ b/reference/unordered_map/unordered_map/insert.md
@@ -42,7 +42,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
         - なお、C++11 では「`P` が `value_type` に暗黙変換可能」という、より厳しい条件の記載になってしまっていた。これは規格の誤りとして C++14 で修正されたが、使用する処理系やバージョンによる挙動の差異に注意が必要である
 - (4), (6) : `position` は、このコンテナの有効な読み取り専用イテレータであること
 - (7) :
-    - 引数 `first`、および、`last`は、入力イテレータの要件を満たし、参照先の要素は `value_type` 型で、かつ、範囲 `[first, last)` がこのコンテナ **以外を指す** 有効な範囲であること
+    - 引数 `first`、および、`last`は、入力イテレータの要件を満たし、参照先の要素は `value_type` 型で、かつ、イテレータ範囲 `[first, last)` がこのコンテナ **以外を指す** 有効な範囲であること
     - このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能であること
 - (8) : `value_type` はこのコンテナに対してコピー挿入可能であること
 - (9), (10) : `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`でなければならない
@@ -62,7 +62,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
     - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない
     - このバージョンの動作は、[`emplace_hint`](emplace_hint.md)`(hint,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(obj))` を呼び出した場合と等価である
 - (7) :
-    - 範囲 `[first, last)` のすべての要素 `t` に対して、`insert(t)` を呼び出した場合と等価である（`*first` の型によって (1)、あるいは(3)の形式が呼び出される）。
+    - イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、`insert(t)` を呼び出した場合と等価である（`*first` の型によって (1)、あるいは(3)の形式が呼び出される）。
 - (8) :
     - (7)の形式を `insert(il.`[`begin`](/reference/initializer_list/initializer_list/begin.md)`(), il.`[`end`](/reference/initializer_list/initializer_list/end.md)`())` として呼び出した場合と等価である
 - (9) :
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_map/op_assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_assign.md b/reference/unordered_map/unordered_map/op_assign.md
index a037e044f..78d4f8134 100644
--- a/reference/unordered_map/unordered_map/op_assign.md
+++ b/reference/unordered_map/unordered_map/op_assign.md
@@ -40,7 +40,7 @@ unordered_map&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 	[`max_load_factor`](max_load_factor.md)`()` の値はコピーされる。
 	アロケータオブジェクトは、`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value` が `true` の場合に限りムーブされる。コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
-- (3) : 範囲 `[il.begin(), il.end())` がコピー代入される。
+- (3) : イテレータ範囲 `[il.begin(), il.end())` がコピー代入される。
 	コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_map/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map/op_constructor.md b/reference/unordered_map/unordered_map/op_constructor.md
index f284dac00..460492d9c 100644
--- a/reference/unordered_map/unordered_map/op_constructor.md
+++ b/reference/unordered_map/unordered_map/op_constructor.md
@@ -97,7 +97,7 @@ unordered_map(initializer_list&amp;lt;value_type&amp;gt; il,
 - (1) + (2) バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で、要素を持たない空の `unordered_map` を構築する。
     引数 `n` のデフォルト値は実装依存である。
 
-- (3) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で `unordered_map` が構築された後、`[first, last)` の範囲の要素が挿入される。
+- (3) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で `unordered_map` が構築された後、イテレータ範囲`[first, last)` の要素が挿入される。
 
 - (4) : コピーコンストラクタ。`v` の全ての要素をコピーした、`unordered_map` を構築する。
     ハッシュ関数オブジェクトとキー比較関数オブジェクト、および、[`max_load_factor`](max_load_factor.md)`()` の値も `v` からコピーされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_multimap/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/erase.md b/reference/unordered_map/unordered_multimap/erase.md
index f8761b3eb..804e96d93 100644
--- a/reference/unordered_map/unordered_multimap/erase.md
+++ b/reference/unordered_map/unordered_multimap/erase.md
@@ -26,7 +26,7 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 ## 効果
 - (1) : `position` で指定された要素を削除する。
 - (2) : `k` と等価なキーの要素を削除する。
-- (3) : `[first, last)` の範囲にある要素を全て削除する。
+- (3) : イテレータ範囲`[first, last)` にある要素を全て削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_multimap/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/insert.md b/reference/unordered_map/unordered_multimap/insert.md
index c38f54adb..ddac0d8b6 100644
--- a/reference/unordered_map/unordered_multimap/insert.md
+++ b/reference/unordered_map/unordered_multimap/insert.md
@@ -41,7 +41,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
     - [`std::constructible_from`](/reference/concepts/constructible_from.md)`&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;`要件を満たすこと
         - なお、C++11 では「`P` が `value_type` に暗黙変換可能」という、より厳しい条件の記載になってしまっていた。これは規格の誤りとして C++14 で修正されたが、使用する処理系やバージョンによる挙動の差異に注意が必要である
 - (7) :
-    - 引数 `first`、および、`last`は、入力イテレータの要件を満たし、参照先の要素は `value_type` 型で、かつ、範囲 `[first, last)` が当該コンテナ **以外を指す** 有効な範囲であること
+    - 引数 `first`、および、`last`は、入力イテレータの要件を満たし、参照先の要素は `value_type` 型で、かつ、イテレータ範囲 `[first, last)` が当該コンテナ **以外を指す** 有効な範囲であること
     - このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能であること
 - (8) : `value_type` はこのコンテナに対してコピー挿入可能であること
 - (9), (10)の形式では、 `nh` は空である、または、`(*this).get_allocator() == nh.get_allocator()`でなければならない。
@@ -61,7 +61,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (10) C++17
     - 引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない
     - このバージョンの動作は、[`emplace_hint`](emplace_hint.md)`(hint,` [`std::forward`](/reference/utility/forward.md)`&amp;lt;P&amp;gt;(obj))` を呼び出した場合と等価である
 - (7) :
-    - 範囲 `[first, last)` のすべての要素 `t` に対して、`insert(t)` を呼び出した場合と等価である（`*first` の型によって (1)、あるいは(2)の形式が呼び出される）
+    - イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、`insert(t)` を呼び出した場合と等価である（`*first` の型によって (1)、あるいは(2)の形式が呼び出される）
 - (8) :
     - (7)の形式を `insert(il.`[`begin`](/reference/initializer_list/initializer_list/begin.md)`(), il.`[`end`](/reference/initializer_list/initializer_list/end.md)`())` として呼び出した場合と等価である
 - (9) :
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/op_assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_multimap/op_assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/op_assign.md b/reference/unordered_map/unordered_multimap/op_assign.md
index 7a522d6c0..dc4d79ae0 100644
--- a/reference/unordered_map/unordered_multimap/op_assign.md
+++ b/reference/unordered_map/unordered_multimap/op_assign.md
@@ -40,7 +40,7 @@ unordered_multimap&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 	[`max_load_factor`](max_load_factor.md)`()` の値はコピーされる。
 	アロケータオブジェクトは、`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value` が `true` の場合に限りムーブされる。コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
-- (3) : 範囲 `[il.begin(), il.end())` がコピー代入される。
+- (3) : イテレータ範囲 `[il.begin(), il.end())` がコピー代入される。
 	コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_multimap/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_map/unordered_multimap/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_multimap/op_constructor.md b/reference/unordered_map/unordered_multimap/op_constructor.md
index e766357df..16246a678 100644
--- a/reference/unordered_map/unordered_multimap/op_constructor.md
+++ b/reference/unordered_map/unordered_multimap/op_constructor.md
@@ -100,7 +100,7 @@ unordered_multimap(initializer_list&amp;lt;value_type&amp;gt; il,
 - (1) + (2) バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で、要素を持たない空の `unordered_multimap` を構築する。
     引数 `n` のデフォルト値は実装依存である。
 
-- (3) : (1)と同様に `unordered_multimap` が構築された後、`[first, last)` の範囲の要素が挿入される。
+- (3) : (1)と同様に `unordered_multimap` が構築された後、イテレータ範囲`[first, last)`の要素が挿入される。
 
 - (4) : コピーコンストラクタ。`v` の全ての要素をコピーした、`unordered_multimap` を構築する。
     ハッシュ関数オブジェクトとキー比較関数オブジェクト、および、[`max_load_factor`](max_load_factor.md)`()` の値も `v` からコピーされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_multiset/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/erase.md b/reference/unordered_set/unordered_multiset/erase.md
index 54c3d5456..683a634b6 100644
--- a/reference/unordered_set/unordered_multiset/erase.md
+++ b/reference/unordered_set/unordered_multiset/erase.md
@@ -26,7 +26,7 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 ## 効果
 - (1) : `position` で指定された要素を削除する。
 - (2) : `k` と等価なキーの要素を削除する。
-- (3) : `[first, last)` の範囲にある要素を全て削除する。
+- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_multiset/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/insert.md b/reference/unordered_set/unordered_multiset/insert.md
index 06f836c4f..5847a7f22 100644
--- a/reference/unordered_set/unordered_multiset/insert.md
+++ b/reference/unordered_set/unordered_multiset/insert.md
@@ -40,7 +40,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 - 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。  
 	なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
 
-- 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
+- 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
 	また、引数 `first`、および、`last` を引数にとる形式（(3)）では、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。  
 	ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
 
@@ -57,7 +57,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 - (1) : 引数 `v`、あるいは `rv` で指定した値の要素を追加する。
 - (2) : 引数 `v`、あるいは `rv` で指定した値の要素を追加する。  
 	引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
-- (3) : 範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
+- (3) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
 - (4) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
 - (5) : `nh`が空の場合、効果はない。そうでなければ、`nh`が所有する要素を挿入し、新しく挿入された要素を指すイテレータを返す。`nh.key()` と等価なキーを持つ要素を含む範囲がコンテナ内に存在する場合、要素はその範囲の終端に挿入される。
 - (6) : `nh`が空の場合、効果はなく、`(*this).end()`を返す。そうでなければ、 `nh` によって所有されている要素をコンテナに挿入し、 `nh.key()` と等価なキーを持つ要素を指すイテレータを返す。 `nh.key()` と等しいキーを持つ要素を含む範囲がコンテナ内に存在する場合、要素はその範囲の終端に挿入される。要素は、`p`の直前の位置のできるだけ近くに挿入される。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/op_assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_multiset/op_assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/op_assign.md b/reference/unordered_set/unordered_multiset/op_assign.md
index a12394850..881f7f268 100644
--- a/reference/unordered_set/unordered_multiset/op_assign.md
+++ b/reference/unordered_set/unordered_multiset/op_assign.md
@@ -40,7 +40,7 @@ unordered_multiset&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 	[`max_load_factor`](max_load_factor.md)`()` の値はコピーされる。
 	アロケータオブジェクトは、`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value` が `true` の場合に限りムーブされる。コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
-- (3) : 範囲 `[il.begin(), il.end())` がコピー代入される。
+- (3) : イテレータ範囲 `[il.begin(), il.end())` がコピー代入される。
 	コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_multiset/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_multiset/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_multiset/op_constructor.md b/reference/unordered_set/unordered_multiset/op_constructor.md
index 76dd75338..45cc19700 100644
--- a/reference/unordered_set/unordered_multiset/op_constructor.md
+++ b/reference/unordered_set/unordered_multiset/op_constructor.md
@@ -101,7 +101,7 @@ unordered_multiset(initializer_list&amp;lt;value_type&amp;gt; il,
 - (1) + (2) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で、要素を持たない空の `unordered_multiset` を構築する。
 	引数 `n` のデフォルト値は実装依存である。
 
-- (3) : (2)と同様に `unordered_multiset` が構築された後、`[first, last)` の範囲の要素が挿入される。
+- (3) : (2)と同様に `unordered_multiset` が構築された後、イテレータ範囲`[first, last)`の要素が挿入される。
 
 - (4) : コピーコンストラクタ。`v` の全ての要素をコピーした、`unordered_multiset` を構築する。
 	ハッシュ関数オブジェクトとキー比較関数オブジェクト、および、[`max_load_factor`](max_load_factor.md)`()` の値も `v` からコピーされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_set/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/erase.md b/reference/unordered_set/unordered_set/erase.md
index 4131c3ee2..835a8e0e1 100644
--- a/reference/unordered_set/unordered_set/erase.md
+++ b/reference/unordered_set/unordered_set/erase.md
@@ -26,7 +26,7 @@ iterator erase(const_iterator first, const_iterator last); // (3)
 ## 効果
 - (1) : `position` で指定された要素を削除する。
 - (2) : `k` と等価なキーの要素を削除する。
-- (3) : `[first, last)` の範囲にある要素を全て削除する。
+- (3) : イテレータ範囲`[first, last)`にある要素を全て削除する。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>insert -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/insert.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_set/insert.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/insert.md b/reference/unordered_set/unordered_set/insert.md
index 846ddf212..245d184a8 100644
--- a/reference/unordered_set/unordered_set/insert.md
+++ b/reference/unordered_set/unordered_set/insert.md
@@ -41,7 +41,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 - 引数 `position` は、コンテナの有効な読み取り専用イテレータでなければならない。  
 	なお、標準では間接参照可能（dereferenceable）である必要があることになっているが、その必要はない（つまり、最終要素の次を指すイテレータでも良い）ものと思われる。
 
-- 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
+- 引数 `first`、および、`last`は、入力イテレータの要件を満たし、かつ、イテレータ範囲 `[first, last)` が当該コンテナ**以外を指す**有効な範囲でなければならない。  
 	また、引数 `first`、および、`last` を引数にとる形式（(3)）では、このコンテナの要素型 `value_type` は、コンテナに対して `*first` から直接構築可能（EmplaceConstructible）でなければならない。  
 	ここで、コンテナに対して `*first` から直接構築可能とは、`m` をアロケータ型 `allocator_type` の左辺値、`p` を要素型 `value_type` へのポインタとすると、以下の式が適格（well-formed）であるということである。
 
@@ -58,7 +58,7 @@ iterator insert(const_iterator hint, node_type&amp;amp;&amp;amp; nh);          // (6) C++17
 - (1) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。
 - (2) : 引数 `v`、あるいは `rv` で指定した値と等価なキーがコンテナに存在していなければ、当該要素を追加する。  
 	引数 `position` は、要素の挿入位置を探し始める場所のヒントとして使用されるが、実装によって無視されるかもしれない。
-- (3) : 範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
+- (3) : イテレータ範囲 `[first, last)` のすべての要素 `t` に対して、(1)の形式の `insert(t)` を呼び出した場合と等価である。
 - (4) : (3)の形式を `insert(il.begin(), il.end())` として呼び出した場合と等価である。
 - (5) : `nh`が空の場合、効果はない。
 それ以外の場合、`nh.key()`と等価のキーを持つ要素がコンテナにない場合に限り、`nh`が所有する要素を挿入する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator= -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/op_assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_set/op_assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/op_assign.md b/reference/unordered_set/unordered_set/op_assign.md
index 82730726c..ab7b61faa 100644
--- a/reference/unordered_set/unordered_set/op_assign.md
+++ b/reference/unordered_set/unordered_set/op_assign.md
@@ -40,7 +40,7 @@ unordered_set&amp;amp; operator=(initializer_list&amp;lt;value_type&amp;gt; il); // (3)
 	[`max_load_factor`](max_load_factor.md)`()` の値はコピーされる。
 	アロケータオブジェクトは、`std::`[`allocator_traits`](/reference/memory/allocator_traits.md)`&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value` が `true` の場合に限りムーブされる。コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
-- (3) : 範囲 `[il.begin(), il.end())` がコピー代入される。
+- (3) : イテレータ範囲 `[il.begin(), il.end())` がコピー代入される。
 	コンテナ内に元々存在していた要素は、代入されるか、破棄される（デストラクタが呼び出される）。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/unordered_set/unordered_set/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set/op_constructor.md b/reference/unordered_set/unordered_set/op_constructor.md
index ed0988551..35b256e33 100644
--- a/reference/unordered_set/unordered_set/op_constructor.md
+++ b/reference/unordered_set/unordered_set/op_constructor.md
@@ -101,7 +101,7 @@ unordered_set(initializer_list&amp;lt;value_type&amp;gt; il,
 - (1) + (2) : バケット数最低 `n`、ハッシュ関数オブジェクト `hf`、キー比較用関数オブジェクト `eql`、アロケータオブジェクト `a` で、要素を持たない空の `unordered_set` を構築する。
     引数 `n` のデフォルト値は実装依存である。
 
-- (3) : (2)と同様に `unordered_set` が構築された後、`[first, last)` の範囲の要素が挿入される。
+- (3) : (2)と同様に `unordered_set` が構築された後、イテレータ範囲`[first, last)`の要素が挿入される。
 
 - (4) : コピーコンストラクタ。`v` の全ての要素をコピーした、`unordered_set` を構築する。
     ハッシュ関数オブジェクトとキー比較関数オブジェクト、および、[`max_load_factor`](max_load_factor.md)`()` の値も `v` からコピーされる。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/valarray/valarray/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_constructor.md b/reference/valarray/valarray/op_constructor.md
index 7d4a314af..d8270d06b 100644
--- a/reference/valarray/valarray/op_constructor.md
+++ b/reference/valarray/valarray/op_constructor.md
@@ -28,7 +28,7 @@ valarray(initializer_list&amp;lt;T&amp;gt; init);   // (11) C++11 から
 - (1) : デフォルトコンストラクタ
 - (2) : `n`個の`T()`初期化された要素を保持した`valarray`オブジェクトを構築する。
 - (3) : `value`のコピーを`n`個要素として保持した`valarray`オブジェクトを構築する。
-- (4) : `[first, first + n)`の範囲を要素としてコピーした`valarray`オブジェクトを構築する。
+- (4) : イテレータ範囲`[first, first + n)`を要素としてコピーした`valarray`オブジェクトを構築する。
 - (5) : コピーコンストラクタ
 - (6) : ムーブコンストラクタ
 - (7) : [`slice_array`](/reference/valarray/slice_array.md)オブジェクトから`valarray`への変換を行う。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assign -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector/assign.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/vector/vector/assign.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector/assign.md b/reference/vector/vector/assign.md
index a4457cbd4..677211063 100644
--- a/reference/vector/vector/assign.md
+++ b/reference/vector/vector/assign.md
@@ -32,7 +32,7 @@ constexpr void assign(initializer_list&amp;lt;T&amp;gt;); // (3) C++20
 
 
 ## 効果
-- (1) : `[first, last)`の範囲の要素のコピーで`*this`の要素を置き換える。
+- (1) : イテレータ範囲`[first, last)`の要素のコピーで`*this`の要素を置き換える。
 - (2) : `*this`の要素をすべて`n`個の`u`のコピーに置き換える。
 - (3) : `assign(il.begin(), il.end())`と等価。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>erase -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector/erase.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/vector/vector/erase.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector/erase.md b/reference/vector/vector/erase.md
index 5c8d8a31a..30b9ce33d 100644
--- a/reference/vector/vector/erase.md
+++ b/reference/vector/vector/erase.md
@@ -26,7 +26,7 @@ constexpr iterator erase(const_iterator first,
 
 ## 効果
 - (1) : `position`が指す要素が削除される。
-- (2) : `[first, last)`で示される範囲の要素が削除される。
+- (2) : `[first, last)`で示されるイテレータ範囲の要素が削除される。
 
 削除された要素またはそれ以降の要素を指すイテレータや参照は無効になる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- 残りのアルゴリズムも、できるだけ用語「イテレータ範囲」を使用するよう修正 #1011</title>
      <link href="https://cpprefjp.github.io/reference/vector/vector/op_constructor.html"/>
      <id>85c9622baaa4f9826771355800d35ab9b90ed226:reference/vector/vector/op_constructor.md</id>
      <updated>2022-12-28T11:13:14+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/vector/vector/op_constructor.md b/reference/vector/vector/op_constructor.md
index 963fb6a69..6c76bec67 100644
--- a/reference/vector/vector/op_constructor.md
+++ b/reference/vector/vector/op_constructor.md
@@ -73,7 +73,7 @@ constexpr vector(initializer_list&amp;lt;T&amp;gt; il,
 	- C++14 : アロケータ `a` を使用して、`n` 個の `T()` で初期化された要素を保持した `vector` オブジェクトを構築する。
 - (4) : 繰り返しシーケンスコンストラクタ。アロケータ `a` を使用して、`value` のコピーを `n` 個要素として保持した `vector` オブジェクトを構築する。
 - (3) + (4) : 繰り返しシーケンスコンストラクタ。アロケータ `a` を使用して、`value` のコピーを `n` 個要素として保持した `vector` オブジェクトを構築する。
-- (5) : イテレータ範囲コンストラクタ。アロケータ `a` を使用して、`[first, last)` の範囲を要素としてコピーした `vector` オブジェクトを構築する。
+- (5) : イテレータ範囲コンストラクタ。アロケータ `a` を使用して、イテレータ範囲`[first, last)` を要素としてコピーした `vector` オブジェクトを構築する。
 - (6) : コピーコンストラクタ。`x` と同じ要素を保持した `vector` オブジェクトを構築する。
 - (7) : ムーブコンストラクタ。`x` の指す先を自分の領域として `vector` オブジェクトを構築する。
 - (8) : アロケータを別で受け取り、`vector` オブジェクトをコピー構築する。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>インライン変数 -- C++17インライン変数 : 名前のないクラスオブジェクトをインライン指定しても同じ実体にはならないことを記載</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/inline_variables.html"/>
      <id>e68299bcaf7535ffe11dcb21247647dd980bd6e7:lang/cpp17/inline_variables.md</id>
      <updated>2022-12-28T00:53:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp17/inline_variables.md b/lang/cpp17/inline_variables.md
index bb89382a8..10e98f1bb 100644
--- a/lang/cpp17/inline_variables.md
+++ b/lang/cpp17/inline_variables.md
@@ -94,6 +94,10 @@ function-specifier:
   explicit
 ```
 
+## 備考
+- 名前のないクラスのオブジェクトは、インライン指定しても同じ実体にはならない
+
+
 ## 例
 
 ```cpp example
@@ -264,3 +268,4 @@ func
 - [P0386R2 - Inline Variables](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf), 2016-06-24
 - [P0607R0 - Inline Variables for the Standard Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0607r0.html), 2017-02-27
 - [C++1z インライン変数 - Faith and Brave - C++で遊ぼう](https://faithandbrave.hateblo.jp/entry/2016/11/11/172954)
+- [インライン変数が翻訳単位毎に別々の実体となってしまう - Stackoverflow](https://ja.stackoverflow.com/questions/93046/)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>