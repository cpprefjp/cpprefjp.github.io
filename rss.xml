<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2023-02-22T11:48:17.359732</updated>
  <id>0ce777a5-b2d2-4f4d-896f-1752cd8ed051</id>

  
    <entry>
      <title>stdfloat -- &lt;stdfloat&gt; : 残りを書いた #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat.html"/>
      <id>dcbf835672a941482bd4eab44a9cdb713eabba2b:reference/stdfloat.md</id>
      <updated>2023-02-22T20:44:11+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;stdfloat&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;stdfloat&lt;/span&gt;&lt;span class=&#34;cpp cpp23&#34; title=&#34;C++23で追加&#34;&gt;(C++23)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;stdfloat&amp;gt;&lt;/code&gt;ヘッダでは、実装定義の拡張浮動小数点数型を定義する。&lt;/p&gt;
&lt;p&gt;これらの拡張浮動小数点数型は、ISO/IEC/IEEE 60559 (IEEE 754) 浮動小数点数規格に従った内部表現をもつことが規定される。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdfloat/float16_t.html&#34;&gt;float16_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;16ビット半精度の浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdfloat/float32_t.html&#34;&gt;float32_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;32ビット単精度の浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdfloat/float64_t.html&#34;&gt;float64_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64ビット倍精度の浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdfloat/float128_t.html&#34;&gt;float128_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;128ビット四倍精度の浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;https://cpprefjp.github.io/reference/stdfloat/bfloat16_t.html&#34;&gt;bfloat16_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;16ビットのbrain floating point型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++23&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html&#34; target=&#34;_blank&#34;&gt;P1467R9 Extended floating-point types and standard names&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bfloat16_t -- &lt;stdfloat&gt; : 残りを書いた #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/bfloat16_t.html"/>
      <id>dcbf835672a941482bd4eab44a9cdb713eabba2b:reference/stdfloat/bfloat16_t.md</id>
      <updated>2023-02-22T20:44:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/bfloat16_t.md b/reference/stdfloat/bfloat16_t.md
new file mode 100644
index 000000000..6fb603150
--- /dev/null
+++ b/reference/stdfloat/bfloat16_t.md
@@ -0,0 +1,187 @@
+# bfloat16_t
+* stdfloat[meta header]
+* std[meta namespace]
+* type-alias[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+#if defined(__STDCPP_BFLOAT16_T__)
+  using bfloat16_t = implementation-defined;
+#endif
+}
+```
+
+## 概要
+16ビットのbrain floating point型。
+
+
+### 内部表現
+この型はISO/IEC/IEEE 60559 (IEEE 754) にはない16ビットの浮動小数点数型である。
+
+Google社のTPUや、NVIDIAのGPUなどで採用されている内部表現をもつ。
+
+| 型           | 符号ビット数 | 指数ビット数 | 仮数ビット数 | 最大指数 |
+|--------------|--------------|--------------|--------------|----------|
+| `bfloat16_t` | 1            | 8            | 7            | 127      |
+| `float16_t`  | 1            | 5            | 10           | 15       |
+
+
+### リテラル
+値にサフィックスとして`bf16`もしくは`BF16`を指定することで、`std::bfloat16_t`のリテラルとすることができる。
+
+```cpp
+std::bfloat16_t a = 1.0bf16;
+std::bfloat16_t b = 2.0BF16;
+```
+
+
+### 事前定義マクロ
+- この型は、事前定義マクロ`__STDCPP_BFLOAT16_T__`が定義されない場合、定義されない
+
+
+### 順位
+浮動小数点数の変換で使用される順位 (rank) は、以下のように定義される：
+
+- `long double` &amp;gt; `double` &amp;gt; `float`のように、`long double`が最も高い順位をもつ
+- 同じ値集合をもつ2つの拡張浮動小数点数型は、同じ順位をもつ
+- 標準浮動小数点数型と同じ値集合をもつ拡張浮動小数点数型は、同じ順位をもつ
+- 標準浮動小数点数型より多くの値集合をもつ拡張浮動小数点数型は、`double`と同じ順位をもつ
+
+注意として、浮動小数点数型`T1`の値集合が浮動小数点数型`T2`の値集合の部分集合でも上位集合でもない場合、浮動小数点数型`T1`と`T2`の変換順位は順位通りではない。これは、一方の型が他方より大きな範囲と低い精度の両方を持つ場合に起こり得る。
+
+順位が同じ浮動小数点数型は、サブ順位 (subrank) で順序付けられる。拡張浮動小数点数は、標準浮動小数点数型よりも大きなサブ順位をもつ。
+
+
+### 昇格と変換
+C言語の名残と後方互換性のために、オーバーロード解決での`float`から`double`への変換は昇格と見なされるが、ほかの浮動小数点数型では昇格はない。
+
+2つの浮動小数点型の少なくとも一方が拡張浮動小数点型である場合、変換先の型が変換元の型より大きいか等しい場合にのみ、2つの浮動小数点型間の変換が暗黙的に行われる。いかなる暗黙の変換も損失なく、値を正確に保持する。潜在的に損失のある変換はすべて明示的でなければならない。
+
+小さい精度への変換は、`()`と`{}`による直接初期化、もしくは明示的なキャストのみ許可される。
+
+```cpp
+void f(std::float16_t);
+void g() {
+  std::float16_t a = 1.0; // エラー！小さい精度への暗黙変換はできない
+  std::float16_t b(2.0);  // OK : 直接初期化
+  std::float16_t c{3.0};  // OK : 直接初期化
+  a = 4.0;                // エラー！小さい精度への暗黙変換はできない
+  f(5.0);                 // エラー！小さい精度への暗黙変換はできない
+  f(static_cast&amp;lt;std::float16_t&amp;gt;(5.0)); // OK : 明示的なキャスト
+}
+```
+
+
+### 通常の算術変換
+算術演算での型変換は、以下のような規則で行われる。
+
+- どちらかのオペランドが浮動小数点数型である場合、
+    - 両方のオペランドが同じ型であれば、型変換は行われない
+    - そうでなく、オペランドの一方が浮動小数点数型でなければ、浮動小数点数型のオペランドの型に変換される
+    - そうでなく、オペランドの浮動小数点数型の変換順位が等しくない場合、小さい方の順位をもつ浮動小数点数型は、もう一方の浮動小数点数型に変換される
+        - `float + double`は`double`に、`std::float16_t + float`は`float`に変換される
+    - そうでなく、変換順位が等しい場合、サブ順位で比較が行われ、より大きいサブ順位をもつ浮動小数点数型に変換される
+        - `float + std::float32_t`は`std::float32_t`に変換される
+    - そうでなければ、式は不適格となる
+        - `std::float16_t + std::bfloat16_t`は不適格
+
+```cpp example
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+
+int main() {
+  float f32 = 1.0;
+  std::float16_t f16{2.0};
+  std::bfloat16_t b16{3.0};
+  std::float32_t f32b{4.0};
+
+  auto r1 = f32 + f16; // OK : f16は`float`に変換され、結果の型は`float`となる
+  auto r2 = f32 + b16; // OK : b16は`float`に変換され、結果の型は`float`となる
+  //auto r3 = f16 + b16; // エラー！どちらの型も算術変換でもう一方の型に変換できない
+  auto r4 = f32 + f32b;  // OK : f32はより大きいサブ順位をもつ`std::float32_t`に変換される
+  static_assert(std::is_same_v&amp;lt;decltype(r4), std::float32_t&amp;gt;);
+}
+```
+
+### オーバーロード解決
+- 浮動小数点数型の変換をともなうオーバーロード解決は、値を維持する変換が優先され、同じ変換順位をもつ他の浮動小数点数型への変換が優先して行われる
+    - 値を維持する変換が曖昧な場合、プログラムは不適格となる
+
+```cpp
+#include &amp;lt;stdfloat&amp;gt;
+
+void f(std::float32_t) {}
+void f(std::float64_t) {}
+void f(long long) {}
+
+int main() {
+  float x;
+  std::float16_t y;
+  f(x); // f(std::float32_t)が呼び出される。
+        // floatとstd::float32_tが同じ変換順位をもつ
+  //f(y); // エラー！曖昧。変換順位が等しいオーバーロードが見つからない
+}
+```
+
+
+
+## 備考
+- この型は、C23で定義されるオプションキーワード`_Float16`の別名として定義されることになるだろう
+    - この型は、`_Float16`と相互運用できることが望ましい
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;cmath&amp;gt;
+
+int main() {
+  std::bfloat16_t a = 1.0bf16;
+  auto b = 2.0f32; // bの型はstd::float32_t
+
+  // 明示的型変換によって、
+  // float16_tとの間の変換ができる
+  auto aa = static_cast&amp;lt;std::float16_t&amp;gt;(a);
+
+  // aはより大きい精度の型float32_tに変換される
+  auto c = a + b; // cの型はstd::float32_t
+
+  // 精度を落とす縮小変換は明示的型変換で行う。
+  // 拡張浮動小数点数型は数学関数にも渡すことができ、
+  // 標準浮動小数点数型への暗黙変換もできる
+  double d = std::log(static_cast&amp;lt;std::bfloat16_t&amp;gt;(c));
+
+  // 同じ精度の浮動小数点数型との間で、精度を落とさず変換でき、
+  // coutでも拡張浮動小数点数のまま出力できる
+  std::cout &amp;lt;&amp;lt; static_cast&amp;lt;std::float64_t&amp;gt;(d) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::log[link /reference/cmath/log.md]
+
+### 出力
+```
+1.10156
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 13.1
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`std::float16_t`](float16_t.md)
+- [`std::float32_t`](float32_t.md)
+- [`std::float64_t`](float64_t.md)
+- [`std::float128_t`](float128_t.md)
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float128_t -- &lt;stdfloat&gt; : 残りを書いた #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/float128_t.html"/>
      <id>dcbf835672a941482bd4eab44a9cdb713eabba2b:reference/stdfloat/float128_t.md</id>
      <updated>2023-02-22T20:44:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/float128_t.md b/reference/stdfloat/float128_t.md
new file mode 100644
index 000000000..26535c112
--- /dev/null
+++ b/reference/stdfloat/float128_t.md
@@ -0,0 +1,179 @@
+# float128_t
+* stdfloat[meta header]
+* std[meta namespace]
+* type-alias[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+#if defined(__STDCPP_FLOAT128_T__)
+  using float128_t = implementation-defined;
+#endif
+}
+```
+
+## 概要
+128ビット四倍精度の浮動小数点数型。
+
+### 内部表現
+この型は、ISO/IEC/IEEE 60559 (IEEE 754) 浮動小数点数規格のbinary128フォーマットをもつ。
+
+| 符号ビット数 | 指数ビット数 | 仮数ビット数 | 最大指数 |
+|--------------|--------------|--------------|----------|
+| 1            | 15           | 112          | 16383    |
+
+### リテラル
+値にサフィックスとして`f128`もしくは`F128`を指定することで、`std::float128_t`のリテラルとすることができる。
+
+```cpp
+std::float128_t a = 1.0f128;
+std::float128_t b = 2.0F128;
+```
+
+
+### 事前定義マクロ
+- この型は、事前定義マクロ`__STDCPP_FLOAT128_T__`が定義されない場合、定義されない
+    - ISO/IEC/IEEE 60559 (IEEE 754) のbinary128フォーマットが実装される環境でこのマクロは定義される
+
+
+### 順位
+浮動小数点数の変換で使用される順位 (rank) は、以下のように定義される：
+
+- `long double` &amp;gt; `double` &amp;gt; `float`のように、`long double`が最も高い順位をもつ
+- 同じ値集合をもつ2つの拡張浮動小数点数型は、同じ順位をもつ
+- 標準浮動小数点数型と同じ値集合をもつ拡張浮動小数点数型は、同じ順位をもつ
+- 標準浮動小数点数型より多くの値集合をもつ拡張浮動小数点数型は、`double`と同じ順位をもつ
+
+注意として、浮動小数点数型`T1`の値集合が浮動小数点数型`T2`の値集合の部分集合でも上位集合でもない場合、浮動小数点数型`T1`と`T2`の変換順位は順位通りではない。これは、一方の型が他方より大きな範囲と低い精度の両方を持つ場合に起こり得る。
+
+順位が同じ浮動小数点数型は、サブ順位 (subrank) で順序付けられる。拡張浮動小数点数は、標準浮動小数点数型よりも大きなサブ順位をもつ。
+
+
+### 昇格と変換
+C言語の名残と後方互換性のために、オーバーロード解決での`float`から`double`への変換は昇格と見なされるが、ほかの浮動小数点数型では昇格はない。
+
+2つの浮動小数点型の少なくとも一方が拡張浮動小数点型である場合、変換先の型が変換元の型より大きいか等しい場合にのみ、2つの浮動小数点型間の変換が暗黙的に行われる。いかなる暗黙の変換も損失なく、値を正確に保持する。潜在的に損失のある変換はすべて明示的でなければならない。
+
+小さい精度への変換は、`()`と`{}`による直接初期化、もしくは明示的なキャストのみ許可される。
+
+```cpp
+void f(std::float16_t);
+void g() {
+  std::float16_t a = 1.0; // エラー！小さい精度への暗黙変換はできない
+  std::float16_t b(2.0);  // OK : 直接初期化
+  std::float16_t c{3.0};  // OK : 直接初期化
+  a = 4.0;                // エラー！小さい精度への暗黙変換はできない
+  f(5.0);                 // エラー！小さい精度への暗黙変換はできない
+  f(static_cast&amp;lt;std::float16_t&amp;gt;(5.0)); // OK : 明示的なキャスト
+}
+```
+
+
+### 通常の算術変換
+算術演算での型変換は、以下のような規則で行われる。
+
+- どちらかのオペランドが浮動小数点数型である場合、
+    - 両方のオペランドが同じ型であれば、型変換は行われない
+    - そうでなく、オペランドの一方が浮動小数点数型でなければ、浮動小数点数型のオペランドの型に変換される
+    - そうでなく、オペランドの浮動小数点数型の変換順位が等しくない場合、小さい方の順位をもつ浮動小数点数型は、もう一方の浮動小数点数型に変換される
+        - `float + double`は`double`に、`std::float16_t + float`は`float`に変換される
+    - そうでなく、変換順位が等しい場合、サブ順位で比較が行われ、より大きいサブ順位をもつ浮動小数点数型に変換される
+        - `float + std::float32_t`は`std::float32_t`に変換される
+    - そうでなければ、式は不適格となる
+        - `std::float16_t + std::bfloat16_t`は不適格
+
+```cpp example
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+
+int main() {
+  float f32 = 1.0;
+  std::float16_t f16{2.0};
+  std::bfloat16_t b16{3.0};
+  std::float32_t f32b{4.0};
+
+  auto r1 = f32 + f16; // OK : f16は`float`に変換され、結果の型は`float`となる
+  auto r2 = f32 + b16; // OK : b16は`float`に変換され、結果の型は`float`となる
+  //auto r3 = f16 + b16; // エラー！どちらの型も算術変換でもう一方の型に変換できない
+  auto r4 = f32 + f32b;  // OK : f32はより大きいサブ順位をもつ`std::float32_t`に変換される
+  static_assert(std::is_same_v&amp;lt;decltype(r4), std::float32_t&amp;gt;);
+}
+```
+
+### オーバーロード解決
+- 浮動小数点数型の変換をともなうオーバーロード解決は、値を維持する変換が優先され、同じ変換順位をもつ他の浮動小数点数型への変換が優先して行われる
+    - 値を維持する変換が曖昧な場合、プログラムは不適格となる
+
+```cpp
+#include &amp;lt;stdfloat&amp;gt;
+
+void f(std::float32_t) {}
+void f(std::float64_t) {}
+void f(long long) {}
+
+int main() {
+  float x;
+  std::float16_t y;
+  f(x); // f(std::float32_t)が呼び出される。
+        // floatとstd::float32_tが同じ変換順位をもつ
+  //f(y); // エラー！曖昧。変換順位が等しいオーバーロードが見つからない
+}
+```
+
+
+
+## 備考
+- この型は、C23で定義されるオプションキーワード`_Float16`の別名として定義されることになるだろう
+    - この型は、`_Float16`と相互運用できることが望ましい
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;cmath&amp;gt;
+
+int main() {
+  std::float16_t a = 1.0f16;
+  auto b = 2.0f32; // bの型はstd::float32_t
+
+  // aはより大きい精度の型float32_tに変換される
+  auto c = a + b; // cの型はstd::float32_t
+
+  // 精度を落とす縮小変換は明示的型変換で行う。
+  // 拡張浮動小数点数型は数学関数にも渡すことができ、
+  // 標準浮動小数点数型への暗黙変換もできる
+  double d = std::log(static_cast&amp;lt;std::float16_t&amp;gt;(c));
+
+  // 同じ精度の浮動小数点数型との間で、精度を落とさず変換でき、
+  // coutでも拡張浮動小数点数のまま出力できる
+  std::cout &amp;lt;&amp;lt; static_cast&amp;lt;std::float64_t&amp;gt;(d) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::log[link /reference/cmath/log.md]
+
+### 出力
+```
+1.09863
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 13.1
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`std::float16_t`](float16_t.md)
+- [`std::float32_t`](float32_t.md)
+- [`std::float64_t`](float64_t.md)
+- [`std::bfloat16_t`](bfloat16_t.md)
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float16_t -- &lt;stdfloat&gt; : 残りを書いた #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/float16_t.html"/>
      <id>dcbf835672a941482bd4eab44a9cdb713eabba2b:reference/stdfloat/float16_t.md</id>
      <updated>2023-02-22T20:44:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/float16_t.md b/reference/stdfloat/float16_t.md
index c7e6d4c2f..8bdb7a312 100644
--- a/reference/stdfloat/float16_t.md
+++ b/reference/stdfloat/float16_t.md
@@ -16,8 +16,7 @@ namespace std {
 16ビット半精度の浮動小数点数型。
 
 ### 内部表現
-
-ISO/IEC/IEEE 60559 (IEEE 754) 浮動小数点数規格のbinary16フォーマットをもつ。
+この型は、ISO/IEC/IEEE 60559 (IEEE 754) 浮動小数点数規格のbinary16フォーマットをもつ。
 
 | 符号ビット数 | 指数ビット数 | 仮数ビット数 | 最大指数 |
 |--------------|--------------|--------------|----------|
@@ -32,6 +31,11 @@ std::float16_t b = 2.0F16;
 ```
 
 
+### 事前定義マクロ
+- この型は、事前定義マクロ`__STDCPP_FLOAT16_T__`が定義されない場合、定義されない
+    - ISO/IEC/IEEE 60559 (IEEE 754) のbinary16フォーマットが実装される環境でこのマクロは定義される
+
+
 ### 順位
 浮動小数点数の変換で使用される順位 (rank) は、以下のように定義される：
 
@@ -65,40 +69,92 @@ void g() {
 ```
 
 
-### オーバーロード解決
-TBD
+### 通常の算術変換
+算術演算での型変換は、以下のような規則で行われる。
+
+- どちらかのオペランドが浮動小数点数型である場合、
+    - 両方のオペランドが同じ型であれば、型変換は行われない
+    - そうでなく、オペランドの一方が浮動小数点数型でなければ、浮動小数点数型のオペランドの型に変換される
+    - そうでなく、オペランドの浮動小数点数型の変換順位が等しくない場合、小さい方の順位をもつ浮動小数点数型は、もう一方の浮動小数点数型に変換される
+        - `float + double`は`double`に、`std::float16_t + float`は`float`に変換される
+    - そうでなく、変換順位が等しい場合、サブ順位で比較が行われ、より大きいサブ順位をもつ浮動小数点数型に変換される
+        - `float + std::float32_t`は`std::float32_t`に変換される
+    - そうでなければ、式は不適格となる
+        - `std::float16_t + std::bfloat16_t`は不適格
 
-- 浮動小数点数型`FP1`と浮動小数点数型`FP2`の間のいずれかの方向への変換は、`FP1`と算術型`T3`の間の同じ方向への変換よりも優先される
+```cpp example
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+
+int main() {
+  float f32 = 1.0;
+  std::float16_t f16{2.0};
+  std::bfloat16_t b16{3.0};
+  std::float32_t f32b{4.0};
+
+  auto r1 = f32 + f16; // OK : f16は`float`に変換され、結果の型は`float`となる
+  auto r2 = f32 + b16; // OK : b16は`float`に変換され、結果の型は`float`となる
+  //auto r3 = f16 + b16; // エラー！どちらの型も算術変換でもう一方の型に変換できない
+  auto r4 = f32 + f32b;  // OK : f32はより大きいサブ順位をもつ`std::float32_t`に変換される
+  static_assert(std::is_same_v&amp;lt;decltype(r4), std::float32_t&amp;gt;);
+}
+```
+
+### オーバーロード解決
+- 浮動小数点数型の変換をともなうオーバーロード解決は、値を維持する変換が優先され、同じ変換順位をもつ他の浮動小数点数型への変換が優先して行われる
+    - 値を維持する変換が曖昧な場合、プログラムは不適格となる
 
 ```cpp
-int f(std::float32_t);
-int f(std::float64_t);
-int f(long long);
-
-float x;
-std::float16_t y;
-int i = f(x); // f(std::float32_t)が呼び出される。
-              // floatとstd::float32_tが同じ変換順位をもつ
-int j = f(y); // エラー！曖昧。変換ランクが等しくない
+#include &amp;lt;stdfloat&amp;gt;
+
+void f(std::float32_t) {}
+void f(std::float64_t) {}
+void f(long long) {}
+
+int main() {
+  float x;
+  std::float16_t y;
+  f(x); // f(std::float32_t)が呼び出される。
+        // floatとstd::float32_tが同じ変換順位をもつ
+  //f(y); // エラー！曖昧。変換順位が等しいオーバーロードが見つからない
+}
 ```
-* std::float32_t[link float32_t.md.nolink]
-* std::float64_t[link float32_t.md.nolink]
 
 
 
 ## 備考
 - この型は、C23で定義されるオプションキーワード`_Float16`の別名として定義されることになるだろう
     - この型は、`_Float16`と相互運用できることが望ましい
-- この型は、`__STDCPP_FLOAT16_T__`マクロが定義されない場合、定義されない
-    - ISO/IEC/IEEE 60559 (IEEE 754) のbinary16フォーマットが実装される環境でこのマクロは定義される
 
 
 ## 例
 ```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;cmath&amp;gt;
+
+int main() {
+  std::float16_t a = 1.0f16;
+  auto b = 2.0f32; // bの型はstd::float32_t
+
+  // aはより大きい精度の型float32_tに変換される
+  auto c = a + b; // cの型はstd::float32_t
+
+  // 精度を落とす縮小変換は明示的型変換で行う。
+  // 拡張浮動小数点数型は数学関数にも渡すことができ、
+  // 標準浮動小数点数型への暗黙変換もできる
+  double d = std::log(static_cast&amp;lt;std::float16_t&amp;gt;(c));
+
+  // 同じ精度の浮動小数点数型との間で、精度を落とさず変換でき、
+  // coutでも拡張浮動小数点数のまま出力できる
+  std::cout &amp;lt;&amp;lt; static_cast&amp;lt;std::float64_t&amp;gt;(d) &amp;lt;&amp;lt; std::endl;
+}
 ```
+* std::log[link /reference/cmath/log.md]
 
 ### 出力
 ```
+1.09863
 ```
 
 ## バージョン
@@ -106,7 +162,18 @@ int j = f(y); // エラー！曖昧。変換ランクが等しくない
 - C++23
 
 ### 処理系
-- [Clang](/implementation.md#clang): 
-- [GCC](/implementation.md#gcc): 
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 13.1
 - [Visual C++](/implementation.md#visual_cpp): ??
 
+
+## 関連項目
+- [`std::float32_t`](float32_t.md)
+- [`std::float64_t`](float64_t.md)
+- [`std::float128_t`](float128_t.md)
+- [`std::bfloat16_t`](bfloat16_t.md)
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float32_t -- &lt;stdfloat&gt; : 残りを書いた #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/float32_t.html"/>
      <id>dcbf835672a941482bd4eab44a9cdb713eabba2b:reference/stdfloat/float32_t.md</id>
      <updated>2023-02-22T20:44:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/float32_t.md b/reference/stdfloat/float32_t.md
new file mode 100644
index 000000000..fd915b943
--- /dev/null
+++ b/reference/stdfloat/float32_t.md
@@ -0,0 +1,179 @@
+# float32_t
+* stdfloat[meta header]
+* std[meta namespace]
+* type-alias[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+#if defined(__STDCPP_FLOAT32_T__)
+  using float32_t = implementation-defined;
+#endif
+}
+```
+
+## 概要
+32ビット単精度の浮動小数点数型。
+
+### 内部表現
+この型は、ISO/IEC/IEEE 60559 (IEEE 754) 浮動小数点数規格のbinary32フォーマットをもつ。
+
+| 符号ビット数 | 指数ビット数 | 仮数ビット数 | 最大指数 |
+|--------------|--------------|--------------|----------|
+| 1            | 8            | 23           | 127      |
+
+### リテラル
+値にサフィックスとして`f32`もしくは`F32`を指定することで、`std::float32_t`のリテラルとすることができる。
+
+```cpp
+std::float32_t a = 1.0f32;
+std::float32_t b = 2.0F32;
+```
+
+
+### 事前定義マクロ
+- この型は、事前定義マクロ`__STDCPP_FLOAT32_T__`が定義されない場合、定義されない
+    - ISO/IEC/IEEE 60559 (IEEE 754) のbinary32フォーマットが実装される環境でこのマクロは定義される
+
+
+### 順位
+浮動小数点数の変換で使用される順位 (rank) は、以下のように定義される：
+
+- `long double` &amp;gt; `double` &amp;gt; `float`のように、`long double`が最も高い順位をもつ
+- 同じ値集合をもつ2つの拡張浮動小数点数型は、同じ順位をもつ
+- 標準浮動小数点数型と同じ値集合をもつ拡張浮動小数点数型は、同じ順位をもつ
+- 標準浮動小数点数型より多くの値集合をもつ拡張浮動小数点数型は、`double`と同じ順位をもつ
+
+注意として、浮動小数点数型`T1`の値集合が浮動小数点数型`T2`の値集合の部分集合でも上位集合でもない場合、浮動小数点数型`T1`と`T2`の変換順位は順位通りではない。これは、一方の型が他方より大きな範囲と低い精度の両方を持つ場合に起こり得る。
+
+順位が同じ浮動小数点数型は、サブ順位 (subrank) で順序付けられる。拡張浮動小数点数は、標準浮動小数点数型よりも大きなサブ順位をもつ。
+
+
+### 昇格と変換
+C言語の名残と後方互換性のために、オーバーロード解決での`float`から`double`への変換は昇格と見なされるが、ほかの浮動小数点数型では昇格はない。
+
+2つの浮動小数点型の少なくとも一方が拡張浮動小数点型である場合、変換先の型が変換元の型より大きいか等しい場合にのみ、2つの浮動小数点型間の変換が暗黙的に行われる。いかなる暗黙の変換も損失なく、値を正確に保持する。潜在的に損失のある変換はすべて明示的でなければならない。
+
+小さい精度への変換は、`()`と`{}`による直接初期化、もしくは明示的なキャストのみ許可される。
+
+```cpp
+void f(std::float16_t);
+void g() {
+  std::float16_t a = 1.0; // エラー！小さい精度への暗黙変換はできない
+  std::float16_t b(2.0);  // OK : 直接初期化
+  std::float16_t c{3.0};  // OK : 直接初期化
+  a = 4.0;                // エラー！小さい精度への暗黙変換はできない
+  f(5.0);                 // エラー！小さい精度への暗黙変換はできない
+  f(static_cast&amp;lt;std::float16_t&amp;gt;(5.0)); // OK : 明示的なキャスト
+}
+```
+
+
+### 通常の算術変換
+算術演算での型変換は、以下のような規則で行われる。
+
+- どちらかのオペランドが浮動小数点数型である場合、
+    - 両方のオペランドが同じ型であれば、型変換は行われない
+    - そうでなく、オペランドの一方が浮動小数点数型でなければ、浮動小数点数型のオペランドの型に変換される
+    - そうでなく、オペランドの浮動小数点数型の変換順位が等しくない場合、小さい方の順位をもつ浮動小数点数型は、もう一方の浮動小数点数型に変換される
+        - `float + double`は`double`に、`std::float16_t + float`は`float`に変換される
+    - そうでなく、変換順位が等しい場合、サブ順位で比較が行われ、より大きいサブ順位をもつ浮動小数点数型に変換される
+        - `float + std::float32_t`は`std::float32_t`に変換される
+    - そうでなければ、式は不適格となる
+        - `std::float16_t + std::bfloat16_t`は不適格
+
+```cpp example
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+
+int main() {
+  float f32 = 1.0;
+  std::float16_t f16{2.0};
+  std::bfloat16_t b16{3.0};
+  std::float32_t f32b{4.0};
+
+  auto r1 = f32 + f16; // OK : f16は`float`に変換され、結果の型は`float`となる
+  auto r2 = f32 + b16; // OK : b16は`float`に変換され、結果の型は`float`となる
+  //auto r3 = f16 + b16; // エラー！どちらの型も算術変換でもう一方の型に変換できない
+  auto r4 = f32 + f32b;  // OK : f32はより大きいサブ順位をもつ`std::float32_t`に変換される
+  static_assert(std::is_same_v&amp;lt;decltype(r4), std::float32_t&amp;gt;);
+}
+```
+
+### オーバーロード解決
+- 浮動小数点数型の変換をともなうオーバーロード解決は、値を維持する変換が優先され、同じ変換順位をもつ他の浮動小数点数型への変換が優先して行われる
+    - 値を維持する変換が曖昧な場合、プログラムは不適格となる
+
+```cpp
+#include &amp;lt;stdfloat&amp;gt;
+
+void f(std::float32_t) {}
+void f(std::float64_t) {}
+void f(long long) {}
+
+int main() {
+  float x;
+  std::float16_t y;
+  f(x); // f(std::float32_t)が呼び出される。
+        // floatとstd::float32_tが同じ変換順位をもつ
+  //f(y); // エラー！曖昧。変換順位が等しいオーバーロードが見つからない
+}
+```
+
+
+
+## 備考
+- この型は、C23で定義されるオプションキーワード`_Float16`の別名として定義されることになるだろう
+    - この型は、`_Float16`と相互運用できることが望ましい
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;cmath&amp;gt;
+
+int main() {
+  std::float16_t a = 1.0f16;
+  auto b = 2.0f32; // bの型はstd::float32_t
+
+  // aはより大きい精度の型float32_tに変換される
+  auto c = a + b; // cの型はstd::float32_t
+
+  // 精度を落とす縮小変換は明示的型変換で行う。
+  // 拡張浮動小数点数型は数学関数にも渡すことができ、
+  // 標準浮動小数点数型への暗黙変換もできる
+  double d = std::log(static_cast&amp;lt;std::float16_t&amp;gt;(c));
+
+  // 同じ精度の浮動小数点数型との間で、精度を落とさず変換でき、
+  // coutでも拡張浮動小数点数のまま出力できる
+  std::cout &amp;lt;&amp;lt; static_cast&amp;lt;std::float64_t&amp;gt;(d) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::log[link /reference/cmath/log.md]
+
+### 出力
+```
+1.09863
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 13.1
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`std::float16_t`](float16_t.md)
+- [`std::float64_t`](float64_t.md)
+- [`std::float128_t`](float128_t.md)
+- [`std::bfloat16_t`](bfloat16_t.md)
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>float64_t -- &lt;stdfloat&gt; : 残りを書いた #1022</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat/float64_t.html"/>
      <id>dcbf835672a941482bd4eab44a9cdb713eabba2b:reference/stdfloat/float64_t.md</id>
      <updated>2023-02-22T20:44:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stdfloat/float64_t.md b/reference/stdfloat/float64_t.md
new file mode 100644
index 000000000..2af32056b
--- /dev/null
+++ b/reference/stdfloat/float64_t.md
@@ -0,0 +1,179 @@
+# float64_t
+* stdfloat[meta header]
+* std[meta namespace]
+* type-alias[meta id-type]
+* cpp23[meta cpp]
+
+```cpp
+namespace std {
+#if defined(__STDCPP_FLOAT64_T__)
+  using float64_t = implementation-defined;
+#endif
+}
+```
+
+## 概要
+64ビット倍精度の浮動小数点数型。
+
+### 内部表現
+この型は、ISO/IEC/IEEE 60559 (IEEE 754) 浮動小数点数規格のbinary64フォーマットをもつ。
+
+| 符号ビット数 | 指数ビット数 | 仮数ビット数 | 最大指数 |
+|--------------|--------------|--------------|----------|
+| 1            | 11           | 52           | 1023     |
+
+### リテラル
+値にサフィックスとして`f64`もしくは`F64`を指定することで、`std::float64_t`のリテラルとすることができる。
+
+```cpp
+std::float64_t a = 1.0f64;
+std::float64_t b = 2.0F64;
+```
+
+
+### 事前定義マクロ
+- この型は、事前定義マクロ`__STDCPP_FLOAT64_T__`が定義されない場合、定義されない
+    - ISO/IEC/IEEE 60559 (IEEE 754) のbinary64フォーマットが実装される環境でこのマクロは定義される
+
+
+### 順位
+浮動小数点数の変換で使用される順位 (rank) は、以下のように定義される：
+
+- `long double` &amp;gt; `double` &amp;gt; `float`のように、`long double`が最も高い順位をもつ
+- 同じ値集合をもつ2つの拡張浮動小数点数型は、同じ順位をもつ
+- 標準浮動小数点数型と同じ値集合をもつ拡張浮動小数点数型は、同じ順位をもつ
+- 標準浮動小数点数型より多くの値集合をもつ拡張浮動小数点数型は、`double`と同じ順位をもつ
+
+注意として、浮動小数点数型`T1`の値集合が浮動小数点数型`T2`の値集合の部分集合でも上位集合でもない場合、浮動小数点数型`T1`と`T2`の変換順位は順位通りではない。これは、一方の型が他方より大きな範囲と低い精度の両方を持つ場合に起こり得る。
+
+順位が同じ浮動小数点数型は、サブ順位 (subrank) で順序付けられる。拡張浮動小数点数は、標準浮動小数点数型よりも大きなサブ順位をもつ。
+
+
+### 昇格と変換
+C言語の名残と後方互換性のために、オーバーロード解決での`float`から`double`への変換は昇格と見なされるが、ほかの浮動小数点数型では昇格はない。
+
+2つの浮動小数点型の少なくとも一方が拡張浮動小数点型である場合、変換先の型が変換元の型より大きいか等しい場合にのみ、2つの浮動小数点型間の変換が暗黙的に行われる。いかなる暗黙の変換も損失なく、値を正確に保持する。潜在的に損失のある変換はすべて明示的でなければならない。
+
+小さい精度への変換は、`()`と`{}`による直接初期化、もしくは明示的なキャストのみ許可される。
+
+```cpp
+void f(std::float16_t);
+void g() {
+  std::float16_t a = 1.0; // エラー！小さい精度への暗黙変換はできない
+  std::float16_t b(2.0);  // OK : 直接初期化
+  std::float16_t c{3.0};  // OK : 直接初期化
+  a = 4.0;                // エラー！小さい精度への暗黙変換はできない
+  f(5.0);                 // エラー！小さい精度への暗黙変換はできない
+  f(static_cast&amp;lt;std::float16_t&amp;gt;(5.0)); // OK : 明示的なキャスト
+}
+```
+
+
+### 通常の算術変換
+算術演算での型変換は、以下のような規則で行われる。
+
+- どちらかのオペランドが浮動小数点数型である場合、
+    - 両方のオペランドが同じ型であれば、型変換は行われない
+    - そうでなく、オペランドの一方が浮動小数点数型でなければ、浮動小数点数型のオペランドの型に変換される
+    - そうでなく、オペランドの浮動小数点数型の変換順位が等しくない場合、小さい方の順位をもつ浮動小数点数型は、もう一方の浮動小数点数型に変換される
+        - `float + double`は`double`に、`std::float16_t + float`は`float`に変換される
+    - そうでなく、変換順位が等しい場合、サブ順位で比較が行われ、より大きいサブ順位をもつ浮動小数点数型に変換される
+        - `float + std::float32_t`は`std::float32_t`に変換される
+    - そうでなければ、式は不適格となる
+        - `std::float16_t + std::bfloat16_t`は不適格
+
+```cpp example
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;type_traits&amp;gt;
+
+int main() {
+  float f32 = 1.0;
+  std::float16_t f16{2.0};
+  std::bfloat16_t b16{3.0};
+  std::float32_t f32b{4.0};
+
+  auto r1 = f32 + f16; // OK : f16は`float`に変換され、結果の型は`float`となる
+  auto r2 = f32 + b16; // OK : b16は`float`に変換され、結果の型は`float`となる
+  //auto r3 = f16 + b16; // エラー！どちらの型も算術変換でもう一方の型に変換できない
+  auto r4 = f32 + f32b;  // OK : f32はより大きいサブ順位をもつ`std::float32_t`に変換される
+  static_assert(std::is_same_v&amp;lt;decltype(r4), std::float32_t&amp;gt;);
+}
+```
+
+### オーバーロード解決
+- 浮動小数点数型の変換をともなうオーバーロード解決は、値を維持する変換が優先され、同じ変換順位をもつ他の浮動小数点数型への変換が優先して行われる
+    - 値を維持する変換が曖昧な場合、プログラムは不適格となる
+
+```cpp
+#include &amp;lt;stdfloat&amp;gt;
+
+void f(std::float32_t) {}
+void f(std::float64_t) {}
+void f(long long) {}
+
+int main() {
+  float x;
+  std::float16_t y;
+  f(x); // f(std::float32_t)が呼び出される。
+        // floatとstd::float32_tが同じ変換順位をもつ
+  //f(y); // エラー！曖昧。変換順位が等しいオーバーロードが見つからない
+}
+```
+
+
+
+## 備考
+- この型は、C23で定義されるオプションキーワード`_Float16`の別名として定義されることになるだろう
+    - この型は、`_Float16`と相互運用できることが望ましい
+
+
+## 例
+```cpp example
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;stdfloat&amp;gt;
+#include &amp;lt;cmath&amp;gt;
+
+int main() {
+  std::float16_t a = 1.0f16;
+  auto b = 2.0f32; // bの型はstd::float32_t
+
+  // aはより大きい精度の型float32_tに変換される
+  auto c = a + b; // cの型はstd::float32_t
+
+  // 精度を落とす縮小変換は明示的型変換で行う。
+  // 拡張浮動小数点数型は数学関数にも渡すことができ、
+  // 標準浮動小数点数型への暗黙変換もできる
+  double d = std::log(static_cast&amp;lt;std::float16_t&amp;gt;(c));
+
+  // 同じ精度の浮動小数点数型との間で、精度を落とさず変換でき、
+  // coutでも拡張浮動小数点数のまま出力できる
+  std::cout &amp;lt;&amp;lt; static_cast&amp;lt;std::float64_t&amp;gt;(d) &amp;lt;&amp;lt; std::endl;
+}
+```
+* std::log[link /reference/cmath/log.md]
+
+### 出力
+```
+1.09863
+```
+
+## バージョン
+### 言語
+- C++23
+
+### 処理系
+- [Clang](/implementation.md#clang): ??
+- [GCC](/implementation.md#gcc): 13.1
+- [Visual C++](/implementation.md#visual_cpp): ??
+
+
+## 関連項目
+- [`std::float16_t`](float16_t.md)
+- [`std::float32_t`](float32_t.md)
+- [`std::float128_t`](float128_t.md)
+- [`std::bfloat16_t`](bfloat16_t.md)
+
+
+## 参照
+- [P1467R9 Extended floating-point types and standard names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html)
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 未初期化領域への暗黙的なオブジェクト構築 : 複数のオブジェクトが構築されうるように修正 #1117</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>4818ff7a040a83267ebc5ee506299e44ea6195a3:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-22T18:12:25+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index 9e5eab7c4..032c88222 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -216,13 +216,13 @@ C++においては、ポインタに対する演算（`+ -`など）はそのポ
 
 ### 暗黙的なオブジェクト構築
 
-オブジェクトを暗黙的に構築する操作では、そうすることでプログラムが定義された振る舞いをするようになる（すなわち、未定義動作が回避できる）場合に、*implicit-lifetime types*の０個以上のオブジェクトを暗黙的に構築しその生存期間を開始させる。そのような、暗黙的なオブジェクト構築によってプログラムに定義された振る舞いをもたらすオブジェクトが１つも存在しない場合は未定義動作となる（これは今まで通り）。逆に、そのようなオブジェクトが複数存在している場合は、どのオブジェクトが暗黙的に構築されるかは未規定（これは、都度適切なオブジェクトが選択され構築されることを意図している）。
+オブジェクトを暗黙的に構築する操作では、そうすることでプログラムが定義された振る舞いをするようになる（すなわち、未定義動作が回避できる）場合に、*implicit-lifetime types*の0個以上のオブジェクトを暗黙的に構築しその生存期間を開始させる。そのような、暗黙的なオブジェクト構築によってプログラムに定義された振る舞いをもたらすオブジェクトの集合が1つも存在しない場合は未定義動作となる（これは今まで通り）。逆に、そのようなオブジェクトの集合が複数存在している場合は、どのオブジェクトが暗黙的に構築されるかは未規定（これは、都度適切なオブジェクトが選択され構築されることを意図している）。
 
 暗黙的なオブジェクト構築が行われる場合、そのサブオブジェクトの*implicit-lifetime types*のオブジェクトも暗黙的に構築され生存期間が開始されるが、*implicit-lifetime types*ではないオブジェクトは暗黙的に構築されないため明示的な初期化が必要となる。
 
 暗黙的なオブジェクト構築を行わなくてもプログラムが定義された振る舞いをする（未定義動作とならない）場合、対象の操作は暗黙的にオブジェクトを構築せず、通常の効果のみをもたらす。
 
-さらに、オブジェクトを暗黙的に構築する操作の内メモリを確保する関数等一部の操作では、暗黙的なオブジェクト構築によって作成されたオブジェクトを指す適切なポインタを返すことが規定される。これらの操作においては、そのポインタ値を返すことでプログラムが定義された振る舞いをするようになる場合に、指定された領域の先頭アドレスをアドレスとする暗黙的に構築されたオブジェクトの１つを選択し、そのオブジェクトを指すポインタ値を生成しそれを返す。そのような、プログラムに定義された振る舞いをもたらすようなポインタ値が存在しない場合は未定義動作となる。逆に、そのようなポインタ値が複数存在している場合は、どのポインタ値が生成されるかは未規定。
+さらに、オブジェクトを暗黙的に構築する操作の内メモリを確保する関数等一部の操作では、暗黙的なオブジェクト構築によって作成されたオブジェクトを指す適切なポインタを返すことが規定される。これらの操作においては、そのポインタ値を返すことでプログラムが定義された振る舞いをするようになる場合に、指定された領域の先頭アドレスをアドレスとする暗黙的に構築されたオブジェクトの1つを選択し、そのオブジェクトを指すポインタ値を生成しそれを返す。そのような、プログラムに定義された振る舞いをもたらすようなポインタ値が存在しない場合は未定義動作となる。逆に、そのようなポインタ値が複数存在している場合は、どのポインタ値が生成されるかは未規定。
 
 そのようなポインタ生成を行わなくてもプログラムが定義された振る舞いをする場合、そのようなポインタ値は生成されず、対象の操作は通常のポインタ値を返す。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 未初期化領域への暗黙的なオブジェクト構築 : 共用体の例と問題解決例を追加</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>04deaac7dfd476246698e5046dffb52e63625c51:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-22T17:52:51+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index fa76066ac..9e5eab7c4 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -15,7 +15,7 @@ X *make_x() {
   // malloc()はメモリの確保だけを行う
   X *p = (X*)malloc(sizeof(struct X));
   
-  // pの領域にはオブジェクトが構築されていない
+  // pの領域にはXのオブジェクトが構築されていない
   p-&amp;gt;a = 1; // 💀 UB
   p-&amp;gt;b = 2; // 💀 UB
 
@@ -31,7 +31,7 @@ X *make_x() {
   // new式はメモリの確保とオブジェクト構築を行う
   X *p = new X;
   
-  // pの領域にはオブジェクトが構築済
+  // pの領域にはXのオブジェクトが構築済
   p-&amp;gt;a = 1; // ✅ ok
   p-&amp;gt;b = 2; // ✅ ok
 
@@ -50,12 +50,12 @@ X *make_x() {
 `new`式ではなく`operator new()`を直接使用する場合は同様の問題がある。
 
 ```cpp
-// new式を使用する場合
+// new演算子を使用する場合
 X *make_x() {
   // operator new()はメモリの確保だけを行う
   X *p = (X*)::operator new(sizeof(struct X));
   
-  // pの領域にはオブジェクトが構築されていない
+  // pの領域にはXのオブジェクトが構築されていない
   p-&amp;gt;a = 1; // 💀 UB
   p-&amp;gt;b = 2; // 💀 UB
 
@@ -195,6 +195,25 @@ C++においては、ポインタに対する演算（`+ -`など）はそのポ
 
 また、これらの操作に限らず、`char, unsigned char, std::byte`の配列オブジェクトを構築しその生存期間を開始する操作は、その配列オブジェクトが占有する領域内にその要素のオブジェクトを暗黙的に構築する。
 
+#### 共用体のコピー操作
+
+共用体のデフォルトのコピー/ムーブコンストラクタと代入演算子では、次のようにオブジェクトを暗黙的に構築する
+
+- コンストラクタ
+    - コピー元オブジェクトにネストした各オブジェクトに対して、コピー先内で対応するオブジェクト`o`を
+        - サブオブジェクトの場合 : 特定する
+        - それ以外の場合 : 暗黙的に構築する
+            - 別のオブジェクトにストレージを提供している場合やサブオブジェクトのサブオブジェクトなど
+    - `o`の生存期間はコピーの前に開始される
+- 代入演算子
+  - 代入元と代入先が同じオブジェクトではない場合
+  - コピー元オブジェクトにネストした各オブジェクトに対して、コピー先内で対応するオブジェクト`o`が暗黙的に構築され
+  - `o`の生存期間はコピーの前に開始される
+
+どちらの場合も、コピー元で生存期間内にあるオブジェクトがコピー先で（可能なら）暗黙的に構築される。
+
+クラス型をメンバとして保持する場合など、デフォルトのコンストラクタ/代入演算子が`delete`されている場合はこれは行われない。
+
 ### 暗黙的なオブジェクト構築
 
 オブジェクトを暗黙的に構築する操作では、そうすることでプログラムが定義された振る舞いをするようになる（すなわち、未定義動作が回避できる）場合に、*implicit-lifetime types*の０個以上のオブジェクトを暗黙的に構築しその生存期間を開始させる。そのような、暗黙的なオブジェクト構築によってプログラムに定義された振る舞いをもたらすオブジェクトが１つも存在しない場合は未定義動作となる（これは今まで通り）。逆に、そのようなオブジェクトが複数存在している場合は、どのオブジェクトが暗黙的に構築されるかは未規定（これは、都度適切なオブジェクトが選択され構築されることを意図している）。
@@ -237,32 +256,182 @@ static_assert(f() == 123);  // C++20からはUBが起こるため不適格、C++
 
 したがって、これらの変更によって実行時に何かすべきことが増えるわけではなく、暗黙的なオブジェクト構築は実際にコンストラクタを呼んだり何か初期化を行うものではないし、擬似デストラクタ呼び出しが実行時に何かをするようになるわけでもない。
 
-## 例
-(執筆中)
-```cpp example
-// (ここには、言語機能の使い方を解説するための、サンプルコードを記述します。)
-// (インクルードとmain()関数を含む、実行可能なサンプルコードを記述してください。そのようなコードブロックにはexampleタグを付けます。)
+## 以前の問題の修正例
+
+### `malloc()`/ `operator new`
+
+```cpp
+// Xはimplicit-lifetime class types
+struct X {
+  int a;
+  int b;
+};
+
+X *make_x() {
+  // 後続のXのメンバアクセスを定義された振る舞いとするために
+  // malloc()はメモリの確保とともにXのオブジェクト（とメンバオブジェクト）を暗黙的に構築する
+  // そして、構築されたXのオブジェクトへの適切なポインタを返す
+  X *p = (X*)malloc(sizeof(struct X));
+  
+  // pの領域にはXのオブジェクトが暗黙的に構築されている
+  p-&amp;gt;a = 1; // ✅ ok
+  p-&amp;gt;b = 2; // ✅ ok
+
+  return p;
+}
+```
+
+```cpp
+// new演算子を使用する場合
+X *make_x() {
+  // 後続のXのメンバアクセスを定義された振る舞いとするために
+  // operator new()はメモリの確保とともにXのオブジェクト（とメンバオブジェクト）を暗黙的に構築する
+  // そして、構築されたXのオブジェクトへの適切なポインタを返す
+  X *p = (X*)::operator new(sizeof(struct X));
+  
+  // pの領域にはXのオブジェクトが暗黙的に構築されている
+  p-&amp;gt;a = 1; // ✅ ok
+  p-&amp;gt;b = 2; // ✅ ok
+
+  return p;
+}
+```
+
+### 共用体のコピー
+
+```cpp
+union U {
+  int n;
+  float f;
+};
+
+float pun(int n) {
+  // U::nの生存期間が開始
+  U u = {.n = n};
+  
+  // このコピーではuのオブジェクト表現がコピーされるとともに
+  // uのアクティブメンバに対応するメンバがコピー先でアクティブとなる
+  U u2 = u;
+  
+  // u2.fは非アクティブ
+  return u2.f; // 💀 UB
+}
+```
+
+共用体のコピーにおいてはあくまでコピー元で生存期間内にあったオブジェクトに対応するオブジェクトがコピー先でも生存期間内にあることが保証されるだけで、*type-punning*のようなことを可能にするわけではない。
+
+```cpp
+int f(int n) {
+  U u = {.n = n};
+
+  U u2 = u;
+  
+  // これならok
+  return u2.n; // ✅ ok
+}
+```
+
+### バイト配列の読み込み
 
-#include &amp;lt;iostream&amp;gt;
+```cpp
+// 何かバイト列ストリームを受け取って処理する関数とする
+void process(Stream *stream) {
+  // バイト配列の読み出し
+  std::unique_ptr&amp;lt;char[]&amp;gt; buffer = stream-&amp;gt;read();
 
-int main()
-{
-  int variable = 0;
-  std::cout &amp;lt;&amp;lt; variable &amp;lt;&amp;lt; std::endl;
+  // 先頭バイトの状態によって分岐
+  if (buffer[0] == FOO) {
+    process_foo(reinterpret_cast&amp;lt;Foo*&amp;gt;(buffer.get())); // #1
+  } else {
+    process_bar(reinterpret_cast&amp;lt;Bar*&amp;gt;(buffer.get())); // #2
+  }
 }
 ```
-* variable[color ff0000]
 
-(コードブロック中の識別子に、文字色を付ける例です。)
+`Foo`も`Bar`も*implicit-lifetime types*だとして、以前のこのコードに対して`Stream::read()`が次のように実装されている場合
 
-### 出力
+```cpp
+unique_ptr&amp;lt;char[]&amp;gt; Stream::read() {
+  // ... determine data size ...
+  unique_ptr&amp;lt;char[]&amp;gt; buffer(new char[N]);
+  // ... copy data into buffer ...
+  return buffer;
+}
 ```
-0
+
+この`read()`内の`new char[N]`によって呼ばれる`operator new[]`によって`Foo`/`Bar`のオブジェクトが暗黙的に構築される。この場合、`buffer[0] == FOO`による分岐によってプログラムに定義された振る舞いをもたらすオブジェクトは、`Foo`と`Bar`のオブジェクトとして2つ存在する。したがって、ここでは先頭バイトの状態に応じて適切なオブジェクトが構築される（そうすることでプログラムに定義された振る舞いをもたらす）ため、`process()`内では未定義動作は回避される。
+
+```cpp
+void process(Stream *stream) {
+  // バイト配列の読み出し
+  std::unique_ptr&amp;lt;char[]&amp;gt; buffer = stream-&amp;gt;read();
+
+  // 先頭バイトの状態によって適切なオブジェクトがStream::read()内で構築されている
+  if (buffer[0] == FOO) {
+    process_foo(reinterpret_cast&amp;lt;Foo*&amp;gt;(buffer.get())); // ✅ ok
+  } else {
+    process_bar(reinterpret_cast&amp;lt;Bar*&amp;gt;(buffer.get())); // ✅ ok
+  }
+}
 ```
 
-(ここには、サンプルコードの実行結果を記述します。何も出力がない場合は、項目を削除せず、空の出力にしてください。)  
-(実行結果が処理系・実行環境によって異なる場合は、項目名を「出力例」に変更し、可能であればその理由も併記してください。)
+### 動的配列の実装
+
+```cpp
+// std::vectorの様な動的配列型を実装したい
+template&amp;lt;typename T&amp;gt;
+struct Vec {
+  char *buf = nullptr;
+  char *buf_end_size = nullptr;
+  char *buf_end_capacity = nullptr;
+
+  void reserve(std::size_t n) {
+    // 後続の操作を適格にするためのオブジェクトを暗黙的に構築する
+    // ここでは、Tの配列型T[]のオブジェクトが暗黙的に構築される（要素のオブジェクトは構築されない）
+    // 同時に、char[]のオブジェクトも暗黙的に構築される
+    char *newbuf = (char*)::operator new(n * sizeof(T), std::align_val_t(alignof(T)));
+
+    // newbufにはT[]のオブジェクトが生存期間内にあるため、ポインタT*をイテレータとして使用可能となる
+    // ここで、T[]の要素のTのオブジェクトが構築される（明示的）
+    std::uninitialized_copy(begin(), end(), (T*)newbuf); // #a ✅ ok
+
+    ::operator delete(buf, std::align_val_t(alignof(T)));
+    
+    // newbufにはchar[]のオブジェクトが生存期間内にあるため、newbuf(char*)をイテレータとして使用可能となる
+    buf_end_size = newbuf + sizeof(T) * size(); // #b ✅ ok
+    buf_end_capacity = newbuf + sizeof(T) * n;  // #c ✅ ok
+    buf = newbuf;
+  }
+
+  void push_back(T t) {
+    if (buf_end_size == buf_end_capacity)
+      reserve(std::max&amp;lt;std::size_t&amp;gt;(size() * 2, 1));
+    new (buf_end_size) T(t);
+
+    // buf_end_sizeの指す領域にはchar[]のオブジェクトが生存期間内にあるため、ポインタをイテレータとして使用可能
+    buf_end_size += sizeof(T); // #d ✅ ok
+  }
+
+  T *begin() { return (T*)buf; }
+
+  T *end() { return (T*)buf_end_size; }
+
+  // buf及びbuf_end_sizeの指す領域にはT[]のオブジェクトが生存期間内にあるため、ポインタをイテレータとして使用可能
+  std::size_t size() { return end() - begin(); } // #e ✅ ok
+};
+
+int main() {
+  Vec&amp;lt;int&amp;gt; v;
+  v.push_back(1);
+  v.push_back(2);
+  v.push_back(3);
+
+  // 実装内部で暗黙的に配列オブジェクトが構築されることでUBが回避される
+  for (int n : v) { /*...*/ } // #f ✅ ok
+}
+```
 
+この例では、`reserve()`内`newbuf`及びそれを保存している`Vec::buf`の領域に`T[]`（`T`の配列型）と`char[]`のオブジェクトが暗黙的に構築され、同時に生存期間内にあることで、問題（配列オブジェクトを指さないポインタのイテレータとしての使用）が解消され、すべての箇所で定義された振る舞いをもたらしている。
 
 ## この機能が必要になった背景・経緯
 (執筆中)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hash -- functional/hash: 説明増補</title>
      <link href="https://cpprefjp.github.io/reference/functional/hash.html"/>
      <id>496bf9cbdced56bf08284bc1b984977a18136cee:reference/functional/hash.md</id>
      <updated>2023-02-21T18:40:46+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/functional/hash.md b/reference/functional/hash.md
index f1b626178..764b4ff5c 100644
--- a/reference/functional/hash.md
+++ b/reference/functional/hash.md
@@ -36,9 +36,11 @@ namespace std {
 ## 概要
 クラステンプレート`hash`は、非順序連想コンテナ（[`unordered_map`](/reference/unordered_map/unordered_map.md)/[`unordered_multimap`](/reference/unordered_map/unordered_multimap.md)/[`unordered_set`](/reference/unordered_set/unordered_set.md)/[`unordered_multiset`](/reference/unordered_set/unordered_multiset.md)）のキーとなる型のためのハッシュ値を計算する関数オブジェクトである。
 
-このクラスはそのものにデフォルトの定義は存在せず、ユーザーが任意の型で特殊化する際の要件を定義する。`hash`クラステンプレートを特殊化する場合、以下に記述するメンバ関数を持たせる必要がある。
+このクラスはそのものにデフォルトの定義は存在せず、ユーザーが任意の型で特殊化する際の要件を定義する。`hash`クラステンプレートを特殊化する場合、後述するメンバ関数を持たせる必要がある。
 
-`&amp;lt;functional&amp;gt;`ヘッダでは、以下の特殊化を提供する。これ以外の特殊化は、対象型を定義する各種ヘッダファイルにて提供される：
+### 基本型のハッシュサポート
+`&amp;lt;functional&amp;gt;`ヘッダでは、基本型に対する特殊化を提供する。
+`std::string`などC++標準ライブラリ定義の型に対する特殊化は、対象型を定義する各種ヘッダファイルにて提供される。
 
 | 型                   | 対応バージョン |
 |----------------------|----------------|
@@ -69,18 +71,25 @@ namespace std {
 ## メンバ関数
 
 | 名前 | 説明 |
-|-----------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|
-| `hash()`&amp;lt;br/&amp;gt;`hash(const hash&amp;amp;)`&amp;lt;br/&amp;gt;`hash(hash&amp;amp;&amp;amp;)` | デフォルトコンストラクタ、コピーコンストラクタ、ムーブコンストラクタを持つ |
-| `~hash()` | デストラクタを持つ |
-| `hash&amp;amp; operator=(const hash&amp;amp;)`&amp;lt;br/&amp;gt;`hash&amp;amp; operator=(hash&amp;amp;&amp;amp;)` | コピー代入演算子とムーブ代入演算子を持つ |
-| `size_t operator()(T key) const` | 関数呼び出し演算子によって、キーに対応するハッシュ値を返す |
+|------|------|
+| `(constructor)` | デフォルトコンストラクタ、コピーコンストラクタ、ムーブコンストラクタを持つ |
+| `(destructor)` | デストラクタを持つ |
+| `operator=` | コピー代入演算子とムーブ代入演算子を持つ |
+| `operator()` | 関数呼び出し演算子によって、キー値`k`に対応する`size_t`型のハッシュ値を返す。`const`修飾メンバ関数。 |
+
+関数呼び出し演算子に関する制約は次の通り :
+
+- 引数に指定するキー値`k`を変更してはならない。
+- ハッシュ計算は引数で指定したキー値以外に依存してはいけない（状態をもってはいけない）。
+- 式`k1 == k2`を満たす2個のキー値に対しては、同一ハッシュ値を返すこと。
+    - 異なる2個のキーに対して同一ハッシュ値を返すこと（collision; 衝突）は許容されるが、入力に対する出力ハッシュ値は`size_t`型の値域において均等分布することが好ましい。
 
 
 ## メンバ型
 
 | 名前 | 説明 | 対応バージョン |
 |------|------|----------------|
-| `is_transparent` | 省略可。ハッシュ計算の関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt;この型は、例として`hash&amp;lt;string&amp;gt;`が`hash&amp;lt;const char*&amp;gt;`や`hash&amp;lt;string_view&amp;gt;`と等価なハッシュ値を生成できるような場合に定義される。 | C++20 |
+| `is_transparent` | 省略可。ハッシュ計算を行う関数オブジェクトがこの型を持っている場合、非順序連想コンテナの透過的な検索関数が有効になる。&amp;lt;br/&amp;gt;この型は、例えば関数オブジェクトが`string`型／`string_view`型／ヌル終端文字列(`const char*`)に対して等価なハッシュ値を生成できる場合に定義される。 | C++20 |
 
 
 ## 例
@@ -89,6 +98,8 @@ namespace std {
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;functional&amp;gt;
 
+enum class E { A = 1, B = 42, C = 100 };
+
 int main()
 {
   int x;
@@ -104,6 +115,10 @@ int main()
 
   // int*型のアドレス値(&amp;amp;x)に対するハッシュ値を求める
   std::cout &amp;lt;&amp;lt; std::hash&amp;lt;int*&amp;gt;()(&amp;amp;x) &amp;lt;&amp;lt; std::endl;
+
+  // 列挙型の値E::Bに対するハッシュ値を求める（C++14から）
+  E e = E::B;
+  std::cout &amp;lt;&amp;lt; std::hash&amp;lt;E&amp;gt;()(e) &amp;lt;&amp;lt; std::endl;
 }
 ```
 * std::hash[color ff0000]
@@ -114,10 +129,11 @@ int main()
 100
 1427109137
 3219530756
+42
 ```
 
 ### 透過的にハッシュ値を計算できる場合 (C++20)
-`is_transparent`が定義される場合、以下のようなコードにおいて、`find()`メンバ関数に文字列リテラルを指定しても、一時的な[`string`](/reference/string/basic_string.md)オブジェクトが作成されず、パフォーマンス向上が期待できる。
+メンバ型`is_transparent`が定義される場合、以下のようなコードにおいて、[`find`](/reference/unordered_map/unordered_map/find.md)メンバ関数に文字列リテラルを指定しても、一時的な[`string`](/reference/string/basic_string.md)オブジェクトが作成されず、パフォーマンス向上が期待できる。
 
 ```cpp example
 #include &amp;lt;iostream&amp;gt;
@@ -135,6 +151,7 @@ struct string_hash {
 
 int main()
 {
+  // キー型=std::string, 値型=int
   std::unordered_map&amp;lt;std::string, int, string_hash, std::equal_to&amp;lt;&amp;gt;&amp;gt; um = {
     {&amp;#34;Alice&amp;#34;, 3},
     {&amp;#34;Bob&amp;#34;, 1},
@@ -142,7 +159,7 @@ int main()
   };
 
   // string_hashおよびstd::equal_to&amp;lt;&amp;gt;はいずれもメンバ型にis_transparentを持つため、
-  // find()などの検索関数に引数を渡す場合に、std::string一時オブジェクトが作られない
+  // find()などの検索関数に値を渡す場合に、キー型(std::string)一時オブジェクトが作られない
   auto it = um.find(&amp;#34;Alice&amp;#34;);
   if (it != um.end()) {
     std::cout &amp;lt;&amp;lt; &amp;#34;found : &amp;#34; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; std::endl;
@@ -189,7 +206,9 @@ found : 3
 
 ## 参照
 - [ハッシュ関数 - Wikipedia](https://ja.wikipedia.org/wiki/ハッシュ関数)
-- [LWG 2148 - Hashing enums should be supported directly by std::hash](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148)
+- [LWG 2148 - Hashing enums should be supported directly by `std::hash`](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2148)
 - [LWG 2291 - std::hash is vulnerable to collision DoS attack](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2291)
+- [LWG 2543 - LWG 2148 (hash support for enum types) seems under-specified](https://cplusplus.github.io/LWG/issue2543)
+- [LWG 2817 - `std::hash` for `nullptr_t`](https://cplusplus.github.io/LWG/issue2817)
 - [P0919R3 Heterogeneous lookup for unordered containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0919r3.html)
 - [P1690R1 Refinement Proposal for P0919 Heterogeneous lookup for unordered containers](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1690r1.html)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>未初期化領域への暗黙的なオブジェクト構築 -- 未初期化領域への暗黙的なオブジェクト構築 : 表現修正</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.html"/>
      <id>9755c4c685f21f8cfb47980a23f619306afdcbff:lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md</id>
      <updated>2023-02-21T14:43:11+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
index ed4a4415f..fa76066ac 100644
--- a/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
+++ b/lang/cpp20/implicit_creation_of_objects_for_low-level_object_manipulation.md
@@ -209,9 +209,9 @@ C++においては、ポインタに対する演算（`+ -`など）はそのポ
 
 ### 擬似デストラクタ呼び出しによる生存期間の終了
 
-一部の文脈では、スカラー型のオブジェクトに対してデストラクタ呼び出しを行うことができ、その場合のデストラクタ呼び出しのことを擬似デストラクタ呼び出し（*pseudo-destructor call*）と呼ぶ。
+一部の文脈では、スカラ型のオブジェクトに対してデストラクタ呼び出しを行うことができ、その場合のデストラクタ呼び出しのことを擬似デストラクタ呼び出し（*pseudo-destructor call*）と呼ぶ。
 
-C++17まで、擬似デストラクタ呼び出しには何の効果もなかった（テンプレートの文脈でクラス型との構文上の互換性を取るためのものでしかなかった）が、C++20からは擬似デストラクタ呼び出しはそのスカラー型オブジェクトの生存期間を終了させることが規定される。
+C++17まで、擬似デストラクタ呼び出しには何の効果もなかった（テンプレートの文脈でクラス型との構文上の互換性を取るためのものでしかなかった）が、C++20からは擬似デストラクタ呼び出しはそのスカラ型オブジェクトの生存期間を終了させることが規定される。
 
 ```cpp
 constexpr int f() {
@@ -235,7 +235,7 @@ static_assert(f() == 123);  // C++20からはUBが起こるため不適格、C++
 
 これらの変更はあくまでオブジェクト生存期間に関する規則を変更しただけに過ぎず、その影響はコンパイラ等の実装のオブジェクト生存期間の認識が変わるだけである。それによって、今まで未定義動作となっていたコードが未定義動作ではなくなり、未定義動作をトリガーとする最適化を受ける可能性が将来にわたって取り除かれることになる（ただし、擬似デストラクタ呼び出し周りの変更だけは、未定義動作ではなかったコードを未定義動作にしうる）。
 
-したがって、擬似デストラクタ呼び出しを除いて、これらの変更によって最適化によるもの以外の実行時の振る舞いが変化することはなく、暗黙的なオブジェクト構築は実際にコンストラクタを呼んだり何か初期化を行うものではない。
+したがって、これらの変更によって実行時に何かすべきことが増えるわけではなく、暗黙的なオブジェクト構築は実際にコンストラクタを呼んだり何か初期化を行うものではないし、擬似デストラクタ呼び出しが実行時に何かをするようになるわけでもない。
 
 ## 例
 (執筆中)
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>onihusube</name>
        <email>44743040+onihusube@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>