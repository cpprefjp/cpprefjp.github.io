<!doctype html>
<html class="cpprefjp" lang="ja" itemscope="" itemtype="http://schema.org/WebPage">
    <head>
        <meta charset="UTF-8">

        <title>コンセプト - cpprefjp C++日本語リファレンス</title>

        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta name="keywords" content="
  C++,標準ライブラリ,リファレンス,ドキュメント,STL,std,cpp20
">
        <meta name="title" content="コンセプト - cpprefjp C++日本語リファレンス" />
        <meta itemprop="name" content="コンセプト - cpprefjp C++日本語リファレンス" />
        <meta property="og:title" content="コンセプト - cpprefjp C++日本語リファレンス" />
        <meta property="og:url" content="https://cpprefjp.github.io//lang/cpp20/concepts.html" />
        <meta property="og:site_name" content="cpprefjp - C++日本語リファレンス" />
        <meta property="og:type" content="article" />
        <meta property="og:description" content="(執筆中)" />
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:title" content="コンセプト - cpprefjp C++日本語リファレンス" />
        <meta name="twitter:url" content="https://cpprefjp.github.io//lang/cpp20/concepts.html" />
        <meta name="twitter:description" content="(執筆中)" />

        
  <link rel="alternate" type="application/atom+xml" title="Atom" href="https://cpprefjp.github.io/rss.xml" />


<link rel="apple-touch-icon" sizes="180x180" href="/static/favicons/apple-touch-icon.png?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357">
<link rel="icon" type="image/png" sizes="32x32" href="/static/favicons/favicon-32x32.png?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357">
<link rel="icon" type="image/png" sizes="16x16" href="/static/favicons/favicon-16x16.png?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357">
<link rel="manifest" href="/static/favicons/manifest.json?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357">
<link rel="mask-icon" href="/static/favicons/safari-pinned-tab.svg?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357" color="#f5f8fc">
<meta name="theme-color" content="#f5f8fc">

<link rel="stylesheet" href="/static/pygments/default.css?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357">
<!-- <link rel="stylesheet" href="/static/css/root.css"> -->

        
  


<link href="/static/kunai/css/kunai-stage-0.css?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357" rel="stylesheet">
<link href="/static/kunai/css/kunai-stage-1.css?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357" rel="stylesheet">
<link href="/static/kunai/css/kunai-stage-2.css?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357" rel="stylesheet">
<link href="/static/kunai/css/kunai-stage-3.css?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357" rel="stylesheet">

<script type="text/javascript" src="/static/kunai/js/kunai-vendor.js?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357"></script>
<script type="text/javascript" src="/static/kunai/js/kunai.js?cachebust=95d828cc1bbccaa034ea340c2c18de37354fb357"></script>

<script type="text/javascript">
  document.addEventListener('DOMContentLoaded', function() {
    var kn = new Kunai;
    kn.cpprefjp();
  });
</script>

    
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56896607-1', 'auto');
  ga('send', 'pageview');
</script>


    </head>
    <body>
<header data-kunai-mdinfo="{&#34;sources&#34;: [{&#34;source&#34;: &#34;&#34;, &#34;id&#34;: &#34;b6589fc6ab0dc82cf12099d1c2d40ab994e8410c&#34;}], &#34;meta&#34;: {&#34;cpp&#34;: [&#34;cpp20&#34;]}, &#34;page_id&#34;: [&#34;lang&#34;, &#34;cpp20&#34;, &#34;concepts&#34;]}">
  <nav class="navbar navbar-default" role="navigation">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">
          <div class="title-wrapper clearfix">
            <div class="title">cpprefjp - C++日本語リファレンス</div>
          </div>
        </a>
      </div>

      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <div class="google-search">
              
  
<script>
  (function() {
    var cx = '013316413321391058734:ji_u66hl7hq';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<div class="gcse-search"></div>


            </div>
          </li>
          <li>
  <a href="https://github.com/cpprefjp/site">GitHub Project</a>
</li>
        </ul>
      </div>
    </div>
  </nav>
</header>

        <main id="main" role="main">
            <div class="container-fluid">
<div class="row">
  <div class="col-sm-9 col-sm-push-3" itemscope itemtype="http://schema.org/Article">
    <div class="row">
      <div class="col-sm-12 google-search-result">
        <gcse:searchresults></gcse:searchresults>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 content-header">
        
  <ol class="breadcrumb">
    
      <li  itemscope itemtype="http://www.schema.org/SiteNavigationElement">
        <span>
          
            <a href="/index.html" itemprop="url">
              
                <i class="fa fa-fw fa-home"></i>
              
            </a>
          
        </span>
      </li>
    
      <li  itemscope itemtype="http://www.schema.org/SiteNavigationElement">
        <span>
          
            <a href="/lang.html" itemprop="url">
              
                <span itemprop="name">言語機能</span>
              
            </a>
          
        </span>
      </li>
    
      <li  itemscope itemtype="http://www.schema.org/SiteNavigationElement">
        <span>
          
            <a href="/lang/cpp20.html" itemprop="url">
              
                <span itemprop="name">C++20</span>
              
            </a>
          
        </span>
      </li>
    
      <li class="active" itemscope itemtype="http://www.schema.org/SiteNavigationElement">
        <span>
          
            
              <span itemprop="name">コンセプト</span>
            
          
        </span>
      </li>
    
  </ol>
  <div class="crsearch"></div>

      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 edit-button">
        
  
    <p class="text-right"><small>
      最終更新日時(UTC):
      <span itemprop="datePublished" content="2019-08-28T06:41:02">
        2019年08月28日 06時41分02秒
      </span>
      <br/>
      <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Akira Takahashi</span>
      </span>
      が更新
    </small></p>
  

        <p class="text-right">
          <a class="history" target="_blank" href="https://github.com/cpprefjp/site/commits/master/lang/cpp20/concepts.md">
            <span class="fa fa-fw fa-clock-o fa-flip-horizontal"></span>履歴
          </a>
          <a class="edit" target="_blank" href="https://github.com/cpprefjp/site/edit/master/lang/cpp20/concepts.md">
            <span class="fa fa-fw fa-pencil"></span>編集
          </a>
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 content-body">
        
  <h1 itemprop="name"><span class="token">コンセプト</span><span class="cpp cpp20" title="C++20で追加">(C++20)</span></h1>
<div itemprop="articleBody"><h2>概要</h2>
<p>(執筆中)</p>
<h2>仕様</h2>
<h3>コンセプト定義</h3>
<ul>
<li>
<p>「コンセプト (concept)」は、テンプレート引数に対する制約を定義するテンプレートである。コンセプトは、以下の構文で定義する：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="err">テンプレートパラメータ宣言</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="err">コンセプト名</span> <span class="o">=</span> <span class="n">requires</span><span class="err">式</span><span class="p">;</span>
</pre></div>
</p>
</li>
<li>
<p>コンセプトは、<code>bool</code>型のprvalueを持つ定数式である：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="n">static_assert</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</p>
</li>
<li>
<p>コンセプトは、関連制約を持ってはならない (条件によって定義が存在しないことは許可されない)
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">A</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">A</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// コンパイルエラー！コンセプトは制約できない</span>
<span class="n">concept</span> <span class="n">B</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></div>
</p>
</li>
<li>
<p>コンセプトはインスタンス化されない。コンセプトを明示的にインスタンス化、明示的に特殊化、部分的に特殊化した場合、プログラムは不適格となる</p>
</li>
</ul>
<h3>requires式</h3>
<ul>
<li>「requires式 (Requires expressions)」は、「型<code>T</code>がメンバ関数<code>f()</code>を持っていなければならない」「型<code>T</code>がメンバ型<code>value_type</code>を持っていなければならない」といったテンプレートパラメータの型がもつプロパティを検査し、要件を定義するための機能である</li>
<li>requires式の結果は、<code>bool</code>型のprvalueを持つ定数式である</li>
<li>
<p>requires式のサンプルをいくつか示す：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">R</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>       <span class="c1">// 型Tの値iがあるとして、</span>
  <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">;</span>                <span class="c1">// 型Tがメンバ型typeを持つこと。</span>
  <span class="p">{</span><span class="o">*</span><span class="n">i</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="k">const</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="o">&amp;</span><span class="p">;</span> <span class="c1">// 型Tの値に対して式*iが妥当であり、</span>
                                   <span class="c1">// その式の戻り値型としてconst typename T::type&amp;が返ること</span>
<span class="p">};</span>
</pre></div>
</p>
<ul>
<li>ここでは、関数形式でローカルパラメータをひとつ (<code>T i</code>) とるrequires式によってコンセプト<code>R</code>を定義している</li>
<li>ローカルパラメータである<code>T i</code>の変数定義では、<code>T</code>型に対して「コピー構築可能であること」といった要求は行わず、そのような評価はコンパイル時にも行われない。これは<code><a href="https://cpprefjp.github.io/reference/utility/declval.html">std::declval()</a></code>関数と同様に、「<code>T</code>型のなんらかの値」であることのみを表し、特定の値は持たず、構築もされない</li>
<li>パラメータリスト後の波括弧 { } で囲まれた本体中には、要件のシーケンスをセミコロン区切りで記述する。各要件は、ローカルパラメータ、テンプレートパラメータ、およびその文脈から見えるほかの宣言を参照できる</li>
<li>ローカルパラメータは、リンケージ、記憶域、生存期間をもたない</li>
<li>ローカルパラメータのスコープは、名前が導入されてから本体の閉じカッコまでである</li>
<li>ローカルパラメータはデフォルト引数を持ってはならず、パラメータリストの最後が <code>...</code> であってはならない</li>
<li>型<code>T</code>がrequires式で列挙された要件は定義順に検査され、全ての要件を満たす場合、<code>bool</code>型の定数<code>true</code>が返る。requires式内では、無効な型や式が形成されたり、意味論的な制約に違反する場合があるが、そういった場合はプログラムが不適格にはならず、<code>false</code>が返る</li>
<li>テンプレートパラメータに関わらず無効になる型や式が現れた場合、プログラムは不適格となる</li>
<li>対象となる型がひとつである場合でも、requires式のパラメータは複数とることができる：</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 型Tの値aとbがあるとして、</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 式a + bが妥当であること</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>ローカルパラメータをとらないrequires式も定義できる：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">{</span>
  <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">inner</span><span class="p">;</span> <span class="c1">// メンバ型innerの存在を要求</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>requires式で定義できる要件の種類は、以下である：</p>
<ul>
<li>単純要件</li>
<li>型要件</li>
<li>複合要件</li>
<li>入れ子要件</li>
</ul>
</li>
</ul>
<h4>単純要件</h4>
<ul>
<li>
<p>「単純要件 (Simple requirements)」は、式の妥当性を表明する要件である。テンプレート引数で型を置き換えた結果として式が無効な場合、<code>false</code>に評価される
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 型Tの値aとbがあるとして、</span>
  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 式a + bが妥当であること</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>この要件には、任意の定数式を含めることができるが、直接的にそのような方法をとったとしても、その定数式の評価された結果が<code>true</code>であること、というような要件にはできない。あくまで式が妥当であることの要件である</p>
</li>
</ul>
<h4>型要件</h4>
<ul>
<li>「型要件 (Type requirements)」は、型の妥当性を表明する要件である。テンプレート引数で型を置き換えた結果として型が無効な場合、<code>false</code>に評価される</li>
<li>
<p>型要件の構文は以下のようになる：
  <br />
<div class="codehilite"><pre><span class="k">typename</span> <span class="err">入れ子指定</span><span class="p">(</span><span class="err">省略可</span><span class="p">)</span> <span class="err">要求する型名</span><span class="p">;</span>
</pre></div>
</p>
<ul>
<li>つまり、先頭に<code>typename</code>が記述されていれば型要件である。テンプレートパラメータの型が保持するメンバ型を<code>typename T::nested_type;</code>のように要求することもできるが、特定のクラステンプレートにテンプレート引数を渡した結果が妥当であること、というような要求もできる</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">S</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">Ref</span> <span class="o">=</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">{</span>
  <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">inner</span><span class="p">;</span> <span class="c1">// メンバ型innerの存在を要求</span>
  <span class="k">typename</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>     <span class="c1">// クラステンプレートの特殊化を要求</span>
  <span class="k">typename</span> <span class="n">Ref</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>   <span class="c1">// エイリアステンプレートRefに型Tを渡せることを要求</span>
                     <span class="c1">// (Tがvoidだったら失敗することを意図)</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>ただし特殊化の要求は、テンプレート引数を渡した結果として完全型になること、という要求ではない</p>
<ul>
<li>そのため、宣言のみのプライマリテンプレートと、定義をもつ特殊化、という構成になっているクラステンプレートは、特殊化されていないテンプレート引数に対しては不完全型になるのみで非妥当ではない</li>
</ul>
</li>
</ul>
<h4>複合要件</h4>
<ul>
<li>「複合要件 (Compound requirements)」は、式のプロパティを表明する要件である。式の妥当性、<code>noexcept</code>、式の戻り値型に対する要件を順に検査する</li>
<li>
<p>複合要件の構文は以下のようになる：
  <br />
<div class="codehilite"><pre><span class="p">{</span> <span class="err">妥当性を検査する式</span> <span class="p">}</span> <span class="n">noexcept</span><span class="p">(</span><span class="err">省略可</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="err">戻り値型、もしくは戻り値型の制約</span><span class="p">(</span><span class="err">省略可</span><span class="p">);</span>
</pre></div>
</p>
</li>
<li>
<p>この要件は、以下のように検査される：</p>
<ul>
<li>テンプレート引数で型を置き換えて式を評価し、妥当でなければ<code>false</code>に評価される</li>
<li><code>noexcept</code>を指定した場合、式は例外送出の可能性がある場合は<code>false</code>に評価される</li>
<li>戻り値の型要件が指定された場合、<ul>
<li>テンプレート引数で型を置き換えて型を評価し、妥当でなければ<code>false</code>に評価される</li>
<li>制約ではなく戻り値型が指定された場合、式の戻り値型が指定された戻り値型に変換可能であること。変換できなければ<code>false</code>に評価される</li>
<li>制約が指定された場合、戻り値の型が制約の要件を満たすこと。満たさなければ<code>false</code>に評価される。制約として制約名のみが指定された場合、<code>{E} -&gt; Concept;</code>は<code>E; Concept&lt;decltype((E))&gt;;</code>と等価であり、唯一の制約引数として式の型が渡される。制約として引数付きの制約が指定された場合、<code>{E} -&gt; Concept&lt;Args...&gt;;</code>は<code>E; Concept&lt;decltype((E)), Args...&gt;;</code>と等価となり、先頭の制約引数として式の型が渡される</li>
</ul>
</li>
</ul>
</li>
<li>
<p>例として、式のみを指定する場合、単純要件と等価である：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C1</span> <span class="o">=</span> <span class="n">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">{</span><span class="n">x</span><span class="o">++</span><span class="p">};</span> <span class="c1">// 型Tの値xに対して式x++が妥当であること</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>式と戻り値型を指定した場合：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">{</span><span class="o">*</span><span class="n">x</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">inner</span><span class="p">;</span> <span class="c1">// 型Tの値xに対して式*xが妥当であり、</span>
                             <span class="c1">// その戻り値型がtypename T::inner型に暗黙変換可能であること</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>式と<code>noexcept</code>を指定した場合、指定した式<code>g(x)</code>が例外送出の可能性がないことが検査される：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C3</span> <span class="o">=</span> <span class="n">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">{</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span> <span class="n">noexcept</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>式と制約を指定した場合、指定した式が妥当であることと、その戻り値型が指定した制約を満たすことが検査される：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C4</span> <span class="o">=</span> <span class="n">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">{</span><span class="n">x</span><span class="o">++</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Incrementable</span><span class="p">;</span>     <span class="c1">// 式x++の戻り値型がIncrementable制約を満たすこと。</span>
                              <span class="c1">// x; Incrementable&lt;decltype((x++))&gt;; と等価</span>
  <span class="p">{</span><span class="o">*</span><span class="n">x</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Constructible</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 式*xの戻り値型がConstructible制約を満たすこと (intから構築可能であること)。</span>
                              <span class="c1">// x; Constructible&lt;decltype((*x)), int&gt;; と等価</span>
<span class="p">}</span>
</pre></div>
</p>
</li>
</ul>
<h4>入れ子要件</h4>
<ul>
<li>「入れ子要件 (Nested requirements)」は、requires式内で<code>bool</code>型の定数式で制約する要件である。コンセプトには<code>bool</code>型の定数式を直接指定できるため入れ子要件と等価な指定ができるが、こちらは先に述べた単純要件、型要件、複合要件に対する追加の制約として使用する。要件は定義順に検査されるため、要件Aが成り立たなければ要件Bを検査しない、というような状況で入れ子要件を使用できるだろう</li>
<li>
<p>入れ子要件の構文は以下のようになる：
  <br />
<div class="codehilite"><pre><span class="n">requires</span> <span class="err">制約式</span><span class="p">;</span>
</pre></div>
</p>
<ul>
<li>ここでの制約式とは、<code>concept C = 制約定数式;</code>のようになっているコンセプト定義に指定する<code>bool</code>型の定数式と同じである</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">D</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">requires</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">decltype</span> <span class="p">(</span><span class="o">+</span><span class="n">t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>                   <span class="c1">// コンセプトを指定できる</span>
  <span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/type_traits/is_default_constructible.html">std::is_default_constructible_v</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// 判定系の型特性も指定できる</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>入れ子要件では、requires式で導入したローカルパラメータを使用できる。ただし、ローカルパラメータは特定の値を意味しない「その型のなんらかの値をもつオブジェクト」でしかないため、ローカルパラメータの値を参照しようとする式は不適格となる。ローカルパラメータを使用できるのは、値が評価されない文脈のみである (<code>sizeof</code>、<code>decltype</code>、<code>alignof</code>など)
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">requires</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// OK : 値が評価されない文脈でローカルパラメータを使用</span>
  <span class="c1">//requires a == 0;       // コンパイルエラー！: 制約変数は値を評価できない</span>
<span class="p">}</span>
</pre></div>
</p>
</li>
</ul>
<h3>制約テンプレート</h3>
<ul>
<li>
<p>テンプレートは、クラス、関数、変数、エイリアスに加えて、コンセプトに対して宣言でき、その全てに対して制約を適用できる
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="err">パラメータリスト</span><span class="p">...</span><span class="o">&gt;</span>
<span class="n">requires</span><span class="err">節</span>
<span class="err">宣言</span><span class="p">;</span>
</pre></div>
</p>
</li>
<li>
<p>テンプレートパラメータを「制約パラメータ (constrained parameter)」として宣言することで、requires節を指定することなくテンプレートパラメータを制約できる。制約パラメータを使用したテンプレートパラメータの宣言は、以下の構文である：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="err">名前空間修飾付きのコンセプト名もしくはテンプレート引数付きコンセプト</span> <span class="err">識別子</span> <span class="err">デフォルトテンプレート引数</span><span class="p">(</span><span class="err">省略可</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</p>
<ul>
<li>コンセプト名を指定した場合、指定されたテンプレート引数が自動的にコンセプトの第1テンプレート引数として渡される：</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span><span class="p">;</span>

<span class="c1">// 以下と等価</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span><span class="p">;</span>
</pre></div>
</p>
<ul>
<li>第1テンプレート引数を除いたコンセプトを制約パラメータとして指定することで、第1テンプレート引数以外のテンプレート引数を任意に指定することができる：</li>
</ul>
<p><div class="codehilite"><pre><span class="c1">// 2つのテンプレートパラメータをもつコンセプト</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">Addable</span> <span class="o">=</span> <span class="n">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Addableコンセプトの第1テンプレート引数としてTが渡され、</span>
<span class="c1">// 第2テンプレート引数としてintが渡される</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">Addable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// requires Addable&lt;T, int&gt; と等価</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{};</span>

<span class="n">X</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// requires Addable&lt;char, int&gt;</span>
</pre></div>
</p>
<ul>
<li>コンセプトのテンプレートパラメータが非型である場合、そのコンセプトを使用した制約テンプレートパラメータは非型になる：</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">C</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{};</span>

<span class="n">X</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">//X&lt;-1&gt; y; // コンパイルエラー！制約を満たさない</span>
</pre></div>
</p>
<ul>
<li>制約パラメータに省略記号がついている場合、パラメータパックと見なされる。単一パラメータのコンセプトをパラメータパックにした場合、パラメータパックの各テンプレートパラメータがそのコンセプトを満たすべきという制約になる。複数パラメータをとるコンセプトをパラメータパックにした場合、そのパラメータパックに渡された引数列がコンセプトに渡される：</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C3</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">C1</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">s1</span><span class="p">;</span>      <span class="c1">// requires C1&lt;T&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">C1</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">s2</span><span class="p">;</span>   <span class="c1">// requires (C1&lt;T&gt; &amp;&amp; ...)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">C2</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">s3</span><span class="p">;</span>   <span class="c1">// requires C2&lt;T...&gt;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">C3</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">s4</span><span class="p">;</span> <span class="c1">// requires C3&lt;T, int&gt;</span>
</pre></div>
</p>
</li>
<li>
<p>制約された関数以外のテンプレート、もしくは制約されたテンプレートテンプレートパラメータ、ただし不明な特殊化のメンバテンプレート以外で、全てのテンプレート引数が依存名でない場合、その制約テンプレートの関連制約は全て満たされなければならない
  <br />
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C1</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">C1</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">S1</span> <span class="p">{};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">C1</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">Ptr</span> <span class="o">=</span> <span class="n">T</span><span class="o">*</span><span class="p">;</span>

<span class="n">S1</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// コンパイルエラー！制約を満たさない</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// コンパイルエラー！制約を満たさない</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S2</span> <span class="p">{</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// コンパイルエラー！制約を満たさない</span>
                           <span class="c1">// intは依存名ではないので、この定義段階で制約チェックされる</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S3</span> <span class="p">{</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// OK。Tは依存名なので、この段階では制約チェックされない</span>

<span class="n">S3</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// コンパイルエラー！使用段階 (依存名でなくなった段階) で制約を満たさない</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="n">C1</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">X</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S4</span> <span class="p">{</span>
  <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// コンパイルエラー！制約を満たさない</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C2</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">C2</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">S</span> <span class="p">{};</span>

<span class="k">template</span> <span class="k">struct</span> <span class="n">S</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>      <span class="c1">// コンパイルエラー！テンプレート引数が制約を満たさない</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">S</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{};</span> <span class="c1">// コンパイルエラー！テンプレート引数が制約を満たさない</span>
</pre></div>
</p>
</li>
<li>
<p>クラステンプレートのメンバを宣言と定義で分ける場合、制約テンプレートの宣言は等価でなければならない：
  <br />
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">D</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">C</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">g</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">h</span><span class="p">();</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="n">D</span> <span class="n">U</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">Inner</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">C</span> <span class="n">A</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>        <span class="c1">// OK。テンプレート宣言が一致している</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// コンパイルエラー！S&lt;T&gt;の宣言と一致していない</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">h</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>                      <span class="c1">// コンパイルエラー！機能的には等価だが宣言が一致していない</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">C</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">template</span><span class="o">&lt;</span><span class="n">D</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;::</span><span class="n">Inner</span> <span class="p">{</span> <span class="p">};</span> <span class="c1">// OK</span>
</pre></div>
</p>
<ul>
<li>メンバテンプレートも同様に、テンプレート宣言が宣言と定義で等価でなければならない：</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C2</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">C1</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="n">C2</span> <span class="n">U</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="n">C2</span> <span class="n">U</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">C1</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">template</span><span class="o">&lt;</span><span class="n">C2</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// OK。テンプレート宣言が一致している</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">C1</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">g</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// コンパイルエラー！テンプレート宣言が一致していない</span>
</pre></div>
</p>
</li>
<li>
<p>クラステンプレートおよび変数テンプレートの部分特殊化も制約できる：
  <br />
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">X</span> <span class="p">{};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="p">{};</span> <span class="c1">// #1</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">C</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{};</span>         <span class="c1">// #2</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">constexpr</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">constexpr</span> <span class="kt">int</span> <span class="n">value</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1">// #1</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">C</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">constexpr</span> <span class="kt">int</span> <span class="n">value</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>           <span class="c1">// #2</span>
</pre></div>
</p>
<ul>
<li>この例において、#1 と #2 の部分特殊化はどちらも、プライマリテンプレートよりも特殊化されている。#1 の部分特殊化は成功するが、コンセプトによる制約の方がより特殊化されるため、<code>int*</code>型をテンプレート引数とした場合、#2 が選択される</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">f</span><span class="p">();</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="p">};</span> <span class="c1">// #1</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">C</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">S</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>     <span class="c1">// #2</span>

<span class="k">struct</span> <span class="n">Arg</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span> <span class="p">};</span>

<span class="n">S</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s1</span><span class="p">;</span> <span class="c1">// #1 が選択される。#2 の制約を満たさない</span>
<span class="n">S</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span> <span class="n">s2</span><span class="p">;</span> <span class="c1">// #2 が選択される。両方の制約を満たすが、#2 の方がより特殊化されている</span>
</pre></div>
</p>
</li>
<li>
<p>ラムダ式においても、テンプレートパラメータを個別に制約できる：
  <br />
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="c1">// テンプレート構文を使用したラムダ式のテンプレートパラメータを制約</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="n">C</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="n">requires</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">T1</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">t2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// autoプレースホルダーによる簡略構文を使用したラムダ式のテンプレートパラメータを制約</span>
<span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[](</span><span class="n">C</span> <span class="k">auto</span> <span class="n">t1</span><span class="p">,</span> <span class="n">C</span> <span class="k">auto</span> <span class="n">t2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
</ul>
<h3>requires節</h3>
<ul>
<li>「requires節 (Requires clauses)」は、テンプレートパラメータに対する制約を表明する構文である</li>
<li>
<p>requires節は、<code>&amp;&amp;</code> (AND条件、conjunction、連言)、<code>||</code> (OR条件、disjunction、選言) の論理演算子によって複合的に制約を指定できる
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">||</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/CopyConstructible.html">std::CopyConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyVector</span><span class="p">;</span>
</pre></div>
</p>
</li>
<li>
<p><code>&amp;&amp;</code>と<code>||</code>でつなげる個々の制約を「原子制約 (Atomic constraints)」という。制約単体、もしくは<code>&amp;&amp;</code>と<code>||</code>を含まない定数条件式が原子制約となる</p>
</li>
<li>
<p>requires節は、非テンプレートの関数宣言にも記述できる。これは、クラステンプレートの非テンプレートメンバ関数に対する制約として使用できる</p>
<ul>
<li>requires節は関数宣言のみに現れ、定義には現れてはならない</li>
<li>戻り値の型を前置する構文では、CV修飾や<code>noexcept</code>のうしろに記述する</li>
<li>
<p>戻り値の型を後置する構文では、戻り値型のうしろに記述する

<div class="codehilite"><pre><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="n">requires</span> <span class="nb">true</span><span class="p">;</span>         <span class="c1">// OK</span>
<span class="k">auto</span> <span class="n">f2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="n">requires</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="k">auto</span> <span class="n">f3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="n">requires</span> <span class="nb">true</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span> <span class="c1">// コンパイルエラー！requires節は戻り値型のうしろに記述すること</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)()</span> <span class="n">requires</span> <span class="nb">true</span><span class="p">;</span>      <span class="c1">// コンパイルエラー！変数は制約できない</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)()</span> <span class="n">requires</span> <span class="nb">true</span><span class="p">);</span> <span class="c1">// コンパイルエラー！パラメータ宣言は制約できない</span>

<span class="k">auto</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span><span class="p">)</span> <span class="n">requires</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// コンパイルエラー！関数宣言ではない</span>
                                           <span class="c1">// (関数シグニチャの一部ではないため関数ポインタの宣言には現れない)</span>
</pre></div>
</p>
</li>
<li>
<p>非テンプレートの関数宣言に対するrequires節は、仮想関数に対しては記述できない</p>
</li>
</ul>
<p><div class="codehilite"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="n">requires</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// コンパイルエラー！仮想関数は制約できない</span>
<span class="p">};</span>
</pre></div>
</p>
<ul>
<li>非テンプレートの関数宣言に対するrequires節は、クラステンプレートの非テンプレートメンバ関数に対する制約として使用する</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyVector</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span>
    <span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/type_traits/is_copy_constructible.html">std::is_copy_constructible_v</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span>
    <span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</p>
<ul>
<li>関数宣言と関数定義を分ける場合、非テンプレートの関数宣言に対するrequires節は宣言と定義は等価でなければならない</li>
</ul>
<p><div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyVector</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span>
    <span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/CopyConstructible.html">std::CopyConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span>
    <span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">)</span>
  <span class="n">requires</span> <span class="n">CopyConstructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{}</span>                                    <span class="c1">// OK</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">MyVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">)</span>
<span class="p">{}</span>                                    <span class="c1">// コンパイルエラー！宣言と一致していない</span>
</pre></div>
</p>
</li>
<li>
<p>requires節は、requires式を持てる
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// ひとつめのrequiresはrequires節</span>
<span class="n">T</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// ふたつめのrequiresはrequires式</span>
</pre></div>
</p>
</li>
<li>
<p>非テンプレートのfriend宣言は、requires節を持ってはならない</p>
</li>
</ul>
<h3>関数オーバーロード</h3>
<ul>
<li>同じ名前の2つの関数宣言が、同じスコープ、等価なパラメータ宣言、等価なrequires節を持つ場合、同じ関数を参照するものとする<ul>
<li>同じ関数の再宣言と見なされ、オーバーロードにはならない</li>
</ul>
</li>
<li>
<p>関数のオーバーロードとしては、より制約が強い関数が選択される：
  <br />
<div class="codehilite"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="s">"move"</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/CopyConstructible.html">std::CopyConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="s">"move&amp;copy"</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/CopyConstructible.html">std::CopyConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="s">"move&amp;copy"</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n"><a href="https://cpprefjp.github.io/reference/concepts/MoveConstructible.html">std::MoveConstructible</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="s">"move"</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
<span class="p">}</span>

<span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// move&amp;copy</span>
<span class="n">g</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// move&amp;copy</span>
</pre></div>
</p>
</li>
<li>
<p>オーバーロードの優先順は、以下のようになる：</p>
<ol>
<li>非関数テンプレート</li>
<li>より強い制約を満たすオーバーロード</li>
<li>関数テンプレート</li>
</ol>
</li>
<li>満たされない制約を持つ全ての関数は、オーバーロード解決の候補から除外される</li>
</ul>
<h2>autoに対する制約</h2>
<ul>
<li><a href="https://cpprefjp.github.io/lang/cpp14/generic_lambdas.html">ジェネリックラムダ</a>では<code>[](auto a, auto b) { … }</code>のようにパラメータの型として<code>auto</code>を使用することで関数テンプレートとして関数呼び出し演算子が定義され、それぞれの変数にテンプレートパラメータが割り振られていた</li>
<li>コンセプトの導入にともない、この仕様を以下のように拡大する：<ul>
<li>ラムダ式以外の通常の関数もまたパラメータ型<code>auto</code>とすることで関数テンプレートを定義できるようにする</li>
<li>関数の戻り値型として使用する<code>auto</code>、変数定義の<code>auto</code>、パラメータ型の<code>auto</code>をコンセプトで制約できるようにする構文を追加する</li>
</ul>
</li>
</ul>
<h3>autoパラメータによる関数テンプレートの簡易定義</h3>
<ul>
<li>
<p>パラメータ型を<code>auto</code>にすることにより、それぞれのパラメータにテンプレートパラメータが振り分けられる。
  <br />
<div class="codehilite"><pre><span class="k">auto</span> <span class="nf">f</span><span class="p">(</span><span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 以下と同じ</span>
<span class="c1">// template &lt;class T, class U&gt;</span>
<span class="c1">// auto f(T a, T b) { return a + b; }</span>

<span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>     <span class="c1">// パラメータaとbの型はint</span>
<span class="n">f</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">);</span> <span class="c1">// パラメータaとbの型はdouble</span>
</pre></div>
</p>
<ul>
<li>これはコンセプトによる制約がされない、単純な関数テンプレートの定義である</li>
</ul>
</li>
</ul>
<h3>auto変数、autoパラメータ、auto戻り値に対する制約</h3>
<ul>
<li>
<p>変数定義のauto、関数パラメータのauto、戻り値型のautoをそれぞれ制約できる。単純な使い方は以下のようになる：
  <br />
<div class="codehilite"><pre><span class="n">concept</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="c1">// 変数を制約する。制約を満たさない型が代入されようとしたらコンパイルエラー</span>
<span class="n">C</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// パラメータ型を制約する</span>
<span class="c1">// (constは制約の前)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">C</span> <span class="k">auto</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
<span class="c1">// 以下と同じ意味になる：</span>
<span class="c1">// template &lt;class T, class U, class V&gt;</span>
<span class="c1">// requires C&lt;T&gt; &amp;&amp; C&lt;U&gt; &amp;&amp; C&lt;V&gt;</span>
<span class="c1">// void f(const T&amp; a, U b, V&amp;&amp; c) {}</span>

<span class="c1">// 戻り値型を制約する (<a href="https://cpprefjp.github.io/lang/cpp14/decltype_auto.html">decltype(auto)</a>も同様)</span>
<span class="n">C</span> <span class="k">auto</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 非型テンプレート引数を制約する</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">C</span> <span class="k">auto</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="n">Y</span> <span class="p">{</span>
  <span class="c1">// 型変換演算子の戻り値型を制約する</span>
  <span class="k">operator</span> <span class="n">C</span> <span class="k">auto</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</p>
</li>
<li>
<p>テンプレート引数付きコンセプトを使用する場合、コンセプトの第1テンプレート引数として<code>auto</code>プレースホルダーで置き換わる型が自動的に渡される：
  <br />
<div class="codehilite"><pre><span class="c1">// <a href="https://cpprefjp.github.io/reference/concepts/CopyConstructible.html">std::CopyConstructible</a>&lt;decltype(x)&gt;を意味する</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n"><a href="https://cpprefjp.github.io/reference/concepts/CopyConstructible.html">std::CopyConstructible</a></span> <span class="k">auto</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// <span href="https://cpprefjp.github.io/reference/concepts/Constructible.md.nolink">std::Constructible</span>&lt;decltype(x), int&gt;を意味する</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="n"><span href="https://cpprefjp.github.io/reference/concepts/Constructible.md.nolink">std::Constructible</span></span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</p>
</li>
</ul>
<h2>備考</h2>
<ul>
<li>GCC 9.1では、コンセプトが正式サポートされていないため、コンパイルオプションとして<code>-fconcepts</code>を付ける必要がある</li>
</ul>
<h2>例</h2>
<p><div class="yata" id="b6589fc6ab0dc82cf12099d1c2d40ab994e8410c"><div class="codehilite"><pre>
</pre></div>
</div></p>
<h3>出力</h3>
<p><pre><code></code></pre></p>
<h2>この機能が必要になった背景・経緯</h2>
<h2>関連項目</h2>
<ul>
<li><code><a href="https://cpprefjp.github.io/reference/concepts.html">&lt;concepts&gt;</a></code></li>
<li><code><a href="https://cpprefjp.github.io/reference/iterator.html">&lt;iterator&gt;</a></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/ranges.md.nolink">&lt;ranges&gt;</span></code></li>
</ul>
<h2>参照</h2>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0734r0.pdf" target="_blank">P0734R0 Wording Paper, C++ extensions for Concepts</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0857r0.html" target="_blank">P0857R0 Wording for "functionality gaps in constraints"</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1084r2.pdf" target="_blank">P1084R2 Today's return-type-requirement s Are Insufcient</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r2.html" target="_blank">P1141R2 Yet another approach for constrained declarations</a></li>
</ul></div>

      </div>
    </div>
  </div>
  
  
    <div id="sidebar" class="col-sm-3 col-sm-pull-9">
    </div>
  

</div>
            </div>
        </main>
<footer class="footer navbar navbar-default">
  <div class="container-fluid">
    <p><small>
      本サイトの情報は、
        <a href="https://creativecommons.org/licenses/by/3.0/deed.ja" rel="nofollow">クリエイティブ・コモンズ 表示 3.0 非移植 ライセンス(CC BY)</a>
      の下に提供されています。
    </small></p>
  </div>
</footer>
    </body>
</html>