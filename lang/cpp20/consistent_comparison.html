<!doctype html>
<html class="cpprefjp" lang="ja" itemscope="" itemtype="http://schema.org/WebPage">
    <head>
        <meta charset="UTF-8">

        <title>一貫比較 - cpprefjp C++日本語リファレンス</title>

        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta name="keywords" content="
  C++,標準ライブラリ,リファレンス,ドキュメント,STL,std,cpp20
">
        <meta name="title" content="一貫比較 - cpprefjp C++日本語リファレンス" />
        <meta itemprop="name" content="一貫比較 - cpprefjp C++日本語リファレンス" />
        <meta property="og:title" content="一貫比較 - cpprefjp C++日本語リファレンス" />
        <meta property="og:url" content="https://cpprefjp.github.io//lang/cpp20/consistent_comparison.html" />
        <meta property="og:site_name" content="cpprefjp - C++日本語リファレンス" />
        <meta property="og:type" content="article" />
        <meta property="og:description" content="新しく三方比較演算子`&lt;=&gt;`が導入されることにより、順序付けと同値比較の6つの関係演算子（`&lt;`, `&lt;=`, `&gt;`, `&gt;=`, `==`, `!=`）を容易に実装することができるようになる。" />
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:title" content="一貫比較 - cpprefjp C++日本語リファレンス" />
        <meta name="twitter:url" content="https://cpprefjp.github.io//lang/cpp20/consistent_comparison.html" />
        <meta name="twitter:description" content="新しく三方比較演算子`&lt;=&gt;`が導入されることにより、順序付けと同値比較の6つの関係演算子（`&lt;`, `&lt;=`, `&gt;`, `&gt;=`, `==`, `!=`）を容易に実装することができるようになる。" />

        
  <link rel="alternate" type="application/atom+xml" title="Atom" href="https://cpprefjp.github.io/rss.xml" />


<link rel="apple-touch-icon" sizes="180x180" href="/static/favicons/apple-touch-icon.png?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf">
<link rel="icon" type="image/png" sizes="32x32" href="/static/favicons/favicon-32x32.png?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf">
<link rel="icon" type="image/png" sizes="16x16" href="/static/favicons/favicon-16x16.png?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf">
<link rel="manifest" href="/static/favicons/manifest.json?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf">
<link rel="mask-icon" href="/static/favicons/safari-pinned-tab.svg?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf" color="#f5f8fc">
<meta name="theme-color" content="#f5f8fc">

<link rel="stylesheet" href="/static/pygments/default.css?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf">
<!-- <link rel="stylesheet" href="/static/css/root.css"> -->

        
  


<link href="/static/kunai/css/kunai-stage-0.css?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf" rel="stylesheet">
<link href="/static/kunai/css/kunai-stage-1.css?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf" rel="stylesheet">
<link href="/static/kunai/css/kunai-stage-2.css?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf" rel="stylesheet">
<link href="/static/kunai/css/kunai-stage-3.css?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf" rel="stylesheet">

<script type="text/javascript" src="/static/kunai/js/kunai-vendor.js?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf"></script>
<script type="text/javascript" src="/static/kunai/js/kunai.js?cachebust=fbf951ccc4fb923fd49170397242489a5fdd5adf"></script>

<script type="text/javascript">
  document.addEventListener('DOMContentLoaded', function() {
    var kn = new Kunai;
    kn.cpprefjp();
  });
</script>

    
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56896607-1', 'auto');
  ga('send', 'pageview');
</script>


    </head>
    <body>
<header data-kunai-mdinfo="{&#34;sources&#34;: [{&#34;source&#34;: &#34;#include &lt;compare&gt;  //&lt;=&gt;\u5229\u7528\u306e\u5834\u5408\u5fc5\u9808\n#include &lt;iostream&gt;\n\nstruct C {\n  int x;\n  int y;\n  double v;\n  char str[32];\n\n  //&lt;=&gt;\u3092public\u3067\u5b9a\u7fa9\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u305d\u306e\u4ed6\u306e\u6f14\u7b97\u5b50\u304c\u5c0e\u51fa\u3055\u308c\u308b\n  auto operator&lt;=&gt;(const C&amp;) const = default;\n};\n\n\nint main() {\n  C c1 = {10, 20, 3.1415, \&#34;Three-way Comparison\&#34; };\n  C c2 = {10, 20, 3.1415, \&#34;Spaceship Operator\&#34; };\n\n  //\u4e09\u65b9\u6bd4\u8f03\u6f14\u7b97\u5b50\u305d\u306e\u3082\u306e\u306b\u3088\u308b\u6bd4\u8f03\n  std::cout &lt;&lt; ((c1 &lt;=&gt; c2) == 0) &lt;&lt; std::endl;\n  std::cout &lt;&lt; ((c1 &lt;=&gt; c2) &lt;  0) &lt;&lt; std::endl;\n  std::cout &lt;&lt; ((c1 &lt;=&gt; c2) &gt;  0) &lt;&lt; std::endl;\n\n  //\u30af\u30e9\u30b9C\u306f6\u3064\u306e\u6f14\u7b97\u5b50\u306b\u3088\u308b\u6bd4\u8f03\u304c\u53ef\u80fd\n  std::cout &lt;&lt; (c1 &lt;  c2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (c1 &lt;= c2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (c1 &gt;  c2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (c1 &gt;= c2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (c1 == c2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (c1 != c2) &lt;&lt; std::endl;\n}\n&#34;, &#34;id&#34;: &#34;a0566d908445668a1af8c1a83fec724865fd892a&#34;}, {&#34;source&#34;: &#34;#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n\nstruct S  {\n  int x;\n  double d;\n  char str[4];\n\n  constexpr bool operator&lt;(const S&amp; rhs) const {\n    return std::tie(x, d, str[0], str[1], str[2], str[3])\n         &lt; std::tie(rhs.x, rhs.d, rhs.str[0], rhs.str[1], rhs.str[2], rhs.str[3]);\n  }\n\n  constexpr bool operator==(const S&amp; rhs) const {\n    return std::tie(x, d, str[0], str[1], str[2], str[3])\n        == std::tie(rhs.x, rhs.d, rhs.str[0], rhs.str[1], rhs.str[2], rhs.str[3]);\n  }\n\n  constexpr bool operator!=(const S&amp; rhs) const {\n    return !(*this == rhs);\n  }\n\n  constexpr bool operator&gt;(const S&amp; rhs) const {\n    return rhs &lt; *this;\n  }\n\n  constexpr bool operator&lt;=(const S&amp; rhs) const {\n    return !(*this &gt; rhs);\n  }\n\n  constexpr bool operator&gt;=(const S&amp; rhs) const {\n    return !(*this &lt; rhs);\n  }\n};\n\nint main()\n{\n  S s1 = {10, 0.1, \&#34;abc\&#34;};\n  S s2 = {10, 0.1, \&#34;ABC\&#34;};\n\n  std::cout &lt;&lt; std::boolalpha;\n\n  std::cout &lt;&lt; (s1 &lt;  s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 &lt;= s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 &gt;  s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 &gt;= s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 == s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 != s2) &lt;&lt; std::endl;\n}\n&#34;, &#34;id&#34;: &#34;5e10a49bbc4f514cdd29dc7609f7e35056270388&#34;}, {&#34;source&#34;: &#34;#include &lt;compare&gt;\n#include &lt;iostream&gt;\n\nstruct S {\n  int x;\n  double d;\n  char str[4];\n\n  auto operator&lt;=&gt;(const S&amp;) const = default;\n};\n\nint main()\n{\n  S s1 = {10, 0.1, \&#34;abc\&#34;};\n  S s2 = {10, 0.1, \&#34;ABC\&#34;};\n\n  std::cout &lt;&lt; std::boolalpha;\n\n  std::cout &lt;&lt; (s1 &lt;  s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 &lt;= s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 &gt;  s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 &gt;= s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 == s2) &lt;&lt; std::endl;\n  std::cout &lt;&lt; (s1 != s2) &lt;&lt; std::endl;\n}\n&#34;, &#34;id&#34;: &#34;976551b9151bbe3c280a2c86632d51ca346d88dc&#34;}], &#34;meta&#34;: {&#34;cpp&#34;: [&#34;cpp20&#34;]}, &#34;page_id&#34;: [&#34;lang&#34;, &#34;cpp20&#34;, &#34;consistent_comparison&#34;]}">
  <nav class="navbar navbar-default" role="navigation">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">
          <div class="title-wrapper clearfix">
            <div class="title">cpprefjp - C++日本語リファレンス</div>
          </div>
        </a>
      </div>

      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <div class="google-search">
              
  
<script>
  (function() {
    var cx = '013316413321391058734:ji_u66hl7hq';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<div class="gcse-search"></div>


            </div>
          </li>
          <li>
  <a href="https://github.com/cpprefjp/site">GitHub Project</a>
</li>
        </ul>
      </div>
    </div>
  </nav>
</header>

        <main id="main" role="main">
            <div class="container-fluid">
<div class="row">
  <div class="col-sm-9 col-sm-push-3" itemscope itemtype="http://schema.org/Article">
    <div class="row">
      <div class="col-sm-12 google-search-result">
        <gcse:searchresults></gcse:searchresults>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 content-header">
        
  <ol class="breadcrumb">
    
      <li  itemscope itemtype="http://www.schema.org/SiteNavigationElement">
        <span>
          
            <a href="/index.html" itemprop="url">
              
                <i class="fa fa-fw fa-home"></i>
              
            </a>
          
        </span>
      </li>
    
      <li  itemscope itemtype="http://www.schema.org/SiteNavigationElement">
        <span>
          
            <a href="/lang.html" itemprop="url">
              
                <span itemprop="name">言語機能</span>
              
            </a>
          
        </span>
      </li>
    
      <li  itemscope itemtype="http://www.schema.org/SiteNavigationElement">
        <span>
          
            <a href="/lang/cpp20.html" itemprop="url">
              
                <span itemprop="name">C++20</span>
              
            </a>
          
        </span>
      </li>
    
      <li class="active" itemscope itemtype="http://www.schema.org/SiteNavigationElement">
        <span>
          
            
              <span itemprop="name">一貫比較</span>
            
          
        </span>
      </li>
    
  </ol>
  <div class="crsearch"></div>

      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 edit-button">
        
  
    <p class="text-right"><small>
      最終更新日時(UTC):
      <span itemprop="datePublished" content="2019-06-11T15:33:44">
        2019年06月11日 15時33分44秒
      </span>
      <br/>
      <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Mitsuru Kariya</span>
      </span>
      が更新
    </small></p>
  

        <p class="text-right">
          <a class="history" target="_blank" href="https://github.com/cpprefjp/site/commits/master/lang/cpp20/consistent_comparison.md">
            <span class="fa fa-fw fa-clock-o fa-flip-horizontal"></span>履歴
          </a>
          <a class="edit" target="_blank" href="https://github.com/cpprefjp/site/edit/master/lang/cpp20/consistent_comparison.md">
            <span class="fa fa-fw fa-pencil"></span>編集
          </a>
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 content-body">
        
  <h1 itemprop="name"><span class="token">一貫比較</span><span class="cpp cpp20" title="C++20で追加">(C++20)</span></h1>
<div itemprop="articleBody"><h2>概要</h2>
<p>新しく三方比較演算子<code>&lt;=&gt;</code>が導入されることにより、順序付けと同値比較の6つの関係演算子（<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>）を容易に実装することができるようになる。</p>
<p><div class="yata" id="a0566d908445668a1af8c1a83fec724865fd892a"><div class="codehilite"><pre><span class="cp">#include &lt;compare&gt;  </span><span class="c1">//&lt;=&gt;利用の場合必須</span>
<span class="cp">#include <a href="https://cpprefjp.github.io/reference/iostream.html">&lt;iostream&gt;</a></span>

<span class="k">struct</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">v</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

  <span class="c1">//&lt;=&gt;をpublicで定義しておくことで、その他の演算子が導出される</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">C</span> <span class="n">c1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">,</span> <span class="s">"Three-way Comparison"</span> <span class="p">};</span>
  <span class="n">C</span> <span class="n">c2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">,</span> <span class="s">"Spaceship Operator"</span> <span class="p">};</span>

  <span class="c1">//三方比較演算子そのものによる比較</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">c1</span> <span class="o">&lt;=&gt;</span> <span class="n">c2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">c1</span> <span class="o">&lt;=&gt;</span> <span class="n">c2</span><span class="p">)</span> <span class="o">&lt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">c1</span> <span class="o">&lt;=&gt;</span> <span class="n">c2</span><span class="p">)</span> <span class="o">&gt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>

  <span class="c1">//クラスCは6つの演算子による比較が可能</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&lt;</span>  <span class="n">c2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&lt;=</span> <span class="n">c2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span>  <span class="n">c2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;=</span> <span class="n">c2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div></p>
<p>この様な三方比較の事を一貫比較（Consistent comparison）と言い、この演算子は三方比較演算子（Three-way comparison operator）と呼ぶ。また、演算子の見た目から宇宙船演算子と呼ばれることもある。</p>
<p>この様に、三方比較演算子を用いれば比較演算子の定義が非常に容易になるため<code><a href="https://cpprefjp.github.io/reference/utility/rel_ops.html">std::rel_ops</a></code>はその役割をほとんど失い、非推奨となった。</p>
<h2>仕様</h2>
<h3>三方比較</h3>
<p>ある型の値<code>a, b</code>についての<code>a &lt;=&gt; b</code>による比較の結果は単純な<code>bool</code>ではなく、未満・等しい・超える、という3つの関係を同時に表す値を返す。<br />
そこから<code>a, b</code>の関係を<code>bool</code>の形で得るには、<code>0</code>リテラルとの比較を用いる。</p>
<p><div class="codehilite"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;=&gt;</span> <span class="n">b</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">comp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="s">"a &lt; b"</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">comp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="s">"a &gt; b"</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="s">"a = b"</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</p>
<p>戻り値の値は左辺に対する右辺の関係を表すので、引数順を入れ替えると順序の方向も逆転する。（上記の例の場合、<code>comp = b &lt;=&gt; a</code>とすると<code>comp &lt; 0 == false, 0 &lt; comp == true</code>となり、<code>a &gt; b</code>が出力される）</p>
<p>なお、三方比較演算子の戻り値の<code>0</code>リテラル以外との比較は未定義動作とされる。<code>1</code>だったり<code>0.0</code>であってはならない。</p>
<p><div class="codehilite"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;=&gt;</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">//全て未定義動作</span>
<span class="kt">bool</span> <span class="n">is_less</span> <span class="o">=</span> <span class="n">comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">is_greator</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">comp</span>
<span class="kt">bool</span> <span class="n">is_equal</span> <span class="o">=</span> <span class="n">comp</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">;</span>
</pre></div>
</p>
<h3>比較カテゴリ型（Comparison category type）</h3>
<p>三方比較演算子の戻り値型は<code>int</code>などの整数型ではなく、比較カテゴリ型と呼ばれる専用の型である。<br />
これは、比較対象となる型の満たしている同値や順序の関係についてを専用の型によって表明し、コンセプト等の機構によってその性質に応じた適切な処理へのディスパッチを行うことを出来るようにするためである（例えば、以下で述べる比較カテゴリ型によって導出する演算子を変化させるのに利用されている）。</p>
<p>以下の5つの比較カテゴリ型が提供される。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th align="left">比較カテゴリ型</th>
<th align="center">対応する数学的な関係</th>
<th align="center">導出される演算子</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code><span href="https://cpprefjp.github.io/reference/compare/weak_equality.md.nolink">weak_equality</span></code></td>
<td align="center">同値関係</td>
<td align="center"><code>== !=</code></td>
</tr>
<tr>
<td align="left"><code><span href="https://cpprefjp.github.io/reference/compare/strong_equality.md.nolink">strong_equality</span></code></td>
<td align="center">相等関係：最も細かい同値関係</td>
<td align="center"><code>== !=</code></td>
</tr>
<tr>
<td align="left"><code><span href="https://cpprefjp.github.io/reference/compare/partial_ordering.md.nolink">partial_ordering</span></code></td>
<td align="center">半順序</td>
<td align="center"><code>== != &lt; &lt;= &gt; &gt;=</code></td>
</tr>
<tr>
<td align="left"><code><span href="https://cpprefjp.github.io/reference/compare/weak_ordering.md.nolink">weak_ordering</span></code></td>
<td align="center">弱順序</td>
<td align="center"><code>== != &lt; &lt;= &gt; &gt;=</code></td>
</tr>
<tr>
<td align="left"><code><span href="https://cpprefjp.github.io/reference/compare/strong_ordering.md.nolink">strong_ordering</span></code></td>
<td align="center">全順序</td>
<td align="center"><code>== != &lt; &lt;= &gt; &gt;=</code></td>
</tr>
</tbody>
</table>
<p>表にあるように5つの比較カテゴリ型はそれぞれ数学的な2項関係の一つと対応している。また、それによって（orderingでないカテゴリでは）、順序の4つの演算子が導出されない。</p>
<p>三方比較演算子による比較の結果となる値は、これら比較カテゴリ型のいずれかの<code>prvalue</code>オブジェクトとなる。<br />
全てのカテゴリにおいてそのようなオブジェクトの<code>0</code>リテラル以外との比較は未定義動作となる。</p>
<h4>比較カテゴリ間の順序関係</h4>
<p>各比較カテゴリ型はその条件の強いものから弱いものへの暗黙変換が定義される。この方向は各カテゴリに対応する数学的な関係の包含関係によって定義されている。<br />
ordering -&gt; equalityに変換できてもequality -&gt; orderingに変換できないのは、同値関係を満たしていても順序関係を満たさないような関係を考えることができるため。</p>
<p><img alt="" src="https://raw.github.com/cpprefjp/image/master/reference/lang/cpp20/consistent_comparison_01.png.nolink" /></p>
<p>これはつまり、各比較カテゴリ間の順序関係を示している。この順序は半順序となる。</p>
<p>クラス型に対するdefaultな三方比較演算子の戻り値型は比較に参加するすべての型の<code>&lt;=&gt;</code>による比較の結果となるカテゴリ型から共通して変換できる最も強い型となる。そのような型を共通比較カテゴリ型（common comparison category type）と呼ぶ。</p>
<p>比較に参加するすべての型の<code>&lt;=&gt;</code>による比較カテゴリ型をそれぞれ<code>Ti (0 &lt;= i &lt; N)</code>として、共通比較カテゴリ型<code>U</code>は以下のように決定される。</p>
<ol>
<li><code>Ti</code>の中に一つでも比較カテゴリ型でない型がある場合、<code>U = void</code></li>
<li><code>Ti</code>の中に1つでも<code>weak_equality</code>か<code>strong_equality</code>があり、それ以外の<code>Ti</code>の中に1つでも<code>partial_ordering</code>か<code>weak_ordering</code>がある場合、<code>U = weak_equality</code></li>
<li><code>Ti</code>の中に1つでも<code>strong_equality</code>がある場合、<code>U = strong_equality</code></li>
<li><code>Ti</code>の中に1つでも<code>partial_ordering</code>がある場合、<code>U = partial_ordering</code></li>
<li><code>Ti</code>の中に1つでも<code>weak_ordering</code>がある場合、<code>U = weak_ordering</code></li>
<li>それ以外の場合、<code>U = strong_ordering</code></li>
</ol>
<p>この共通比較カテゴリ型を求めるのは場合によっては困難なので、それを求めるために<code>&lt;compare&gt;</code>ヘッダにて<code><span href="https://cpprefjp.github.io/reference/compare/common_comparison_category.md.nolink">common_comparison_category&lt;Ts...&gt;</span></code>というメタ関数が提供される。</p>
<h3>operator==</h3>
<p><code>&lt;=&gt;</code>のdefault宣言によって6つの関係演算子が導出されるが、実際には同値比較演算子（<code>== !=</code>）は<code>&lt;=&gt;</code>から導出される訳ではない。<br />
<code>&lt;=&gt;</code>をdefault宣言した場合、同じアクセス指定で<code>==</code>が暗黙的にdefault宣言され、<code>!=</code>は<code>==</code>から導出される。そのような<code>==</code>の戻り値型は<code>bool</code>である。</p>
<p>このために、異種型間比較や特殊な比較を実装するために<code>&lt;=&gt;</code>を独自に定義する場合、6×2個の関係演算子全てを導出するためには<code>==</code>も独自に定義しなければならない。</p>
<p>これは、<code>&lt;=&gt;</code>を用いた同値比較において発生しうるオーバーヘッドを回避するためである。</p>
<p>なお、<code>&lt;=&gt;</code>がdelete宣言されている場合でも<code>==</code>は暗黙的にdefault宣言される。</p>
<p><div class="codehilite"><pre><span class="k">struct</span> <span class="n">C</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">C</span> <span class="n">c1</span><span class="p">{},</span> <span class="n">c2</span><span class="p">{};</span>

  <span class="c1">//共にok</span>
  <span class="kt">bool</span> <span class="n">eq</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">ne</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">!=</span> <span class="n">c2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</p>
<h3>演算子の導出とオーバーロード候補</h3>
<p><code>&lt;=&gt;</code>及び<code>==</code>から導出される演算子は暗黙的に宣言され実装されているわけではなく、それらの演算子を呼び出した際のオーバーロード候補に、<code>&lt;=&gt; ==</code>を利用して生成した候補を入れることによって導出される。<br />
そのため、そのアドレスを取ることは出来ない。</p>
<p>詳細な手順は以下のようになる。</p>
<p>任意の演算子<code>@</code>を任意の型<code>T1, T2</code>のオブジェクト<code>a, b</code>に対して<code>a @ b</code>のように呼び出したとき</p>
<ol>
<li>オーバーロード候補に、<code>a @ b</code>を加える</li>
<li><code>@</code>が三方比較演算子ならば、そのオーバーロード候補に<code>&lt;=&gt;</code>を使って生成した逆順の式<code>0 @ (b &lt;=&gt; a)</code>を加える</li>
<li><code>@</code>が関係演算子（<code>&lt; &lt;= &gt; &gt;=</code>）ならば、そのオーバーロード候補に<code>&lt;=&gt;</code>を使って生成した2種類の式<code>(a &lt;=&gt; b) @ 0, 0 @ (b &lt;=&gt; a)</code>を加える</li>
<li><code>@</code>が同値比較演算子（<code>== !=</code>）ならば、そのオーバーロード候補に<code>==</code>を使って生成した式（後述）を加える</li>
<li>式の生成は、その式が有効であるような<code>&lt;=&gt; ==</code>演算子のメンバー・非メンバー・組み込みのそれぞれの候補毎に行われ、それらの演算子に対して再帰的に式の生成を行わない。</li>
<li>それらの候補からのオーバーロード解決の結果、生成された候補が選択された場合、元の呼び出し<code>a @ b</code>をその生成された式で書き換える（生成された式を元の呼び出し<code>a @ b</code>として実行する）</li>
</ol>
<p>結果、各演算子を呼び出したときに考慮されるオーバーロード候補は以下のようになる。  </p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th align="center">呼び出す演算子 <code>a @ b</code></th>
<th align="center">オーバーロード候補</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>a &lt;=&gt; b</code></td>
<td align="center"><code>a &lt;=&gt; b</code> <br /> <code>0 &lt;=&gt; (b &lt;=&gt; a)</code></td>
</tr>
<tr>
<td align="center"><code>a == b</code></td>
<td align="center"><code>a == b</code><br /><code>(b == a) ? true : false</code></td>
</tr>
<tr>
<td align="center"><code>a != b</code></td>
<td align="center"><code>a != b</code><br /><code>(a == b) ? false : true</code><br /> <code>(b == a) ? false : true</code></td>
</tr>
<tr>
<td align="center"><code>a &lt; b</code></td>
<td align="center"><code>a &lt; b</code><br /><code>(a &lt;=&gt; b) &lt; 0</code><br /><code>0 &lt; (b &lt;=&gt; a)</code></td>
</tr>
<tr>
<td align="center"><code>a &lt;= b</code></td>
<td align="center"><code>a &lt;= b</code><br /><code>(a &lt;=&gt; b) &lt;= 0</code><br /><code>0 &lt;= (b &lt;=&gt; a)</code></td>
</tr>
<tr>
<td align="center"><code>a &gt; b</code></td>
<td align="center"><code>a &gt; b</code><br /><code>(a &lt;=&gt; b) &gt; 0</code><br /><code>0 &gt; (b &lt;=&gt; a)</code></td>
</tr>
<tr>
<td align="center"><code>a &gt;= b</code></td>
<td align="center"><code>a &gt;= b</code><br /><code>(a &lt;=&gt; b) &gt;= 0</code><br /><code>0 &gt;= (b &lt;=&gt; a)</code></td>
</tr>
</tbody>
</table>
<p>この様に、異種型間比較においても片方の<code>&lt;=&gt; ==</code>を定義しておけば、その引数準を逆にした演算子も生成され、演算子の対称性が自動で補完される。</p>
<p>ただし、表内オーバーロード候補の形式の1つに対して複数の候補が存在しうるため、表にかかれている数よりも候補は多くなる可能性がある。</p>
<p>どの演算子<code>@</code>においても、元々<code>@</code>が定義されている場合はその定義が優先される。</p>
<h3>default比較</h3>
<p>ここまで書いてきたように、あるクラス型に対する<code>&lt;=&gt;</code>および<code>==</code>演算子は<code>default</code>指定することができる。<br />
そうした場合、コンパイラによってそのクラスの基底及び全メンバの宣言順の辞書式比較を行う実装が暗黙に定義される。</p>
<p>あるクラス<code>C</code>に対する<code>&lt;=&gt; ==</code>の<code>default</code>指定できる宣言は、<code>C</code>の関数テンプレートでないメンバとして宣言されていて、かつ<code>const C&amp;</code>型の1つの引数をもつ非静的constメンバ関数であるか、<code>const C&amp;</code>型の2つの引数を持つ<code>C</code>の<code>friend</code>関数、である必要がある。<br />
つまり以下の様な宣言が有効である。</p>
<p><div class="codehilite"><pre><span class="k">struct</span> <span class="n">C</span> <span class="p">{</span>
  <span class="c1">//有効な&lt;=&gt;のdefault宣言</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">//有効な==のdefault宣言</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">auto</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</p>
<p><code>&lt;=&gt;</code>をdefault宣言した場合、対応する<code>==</code>が暗黙的にdefault宣言される。そのアクセス指定は同一であり、<code>friend</code>であるかも<code>&lt;=&gt;</code>に従う。<br />
また、これらのdefault宣言はその定義が<code>constexpr</code>関数の要件を満たしていれば、暗黙的に<code>constexpr</code>指定される。</p>
<p><code>default</code>指定された三方比較演算子の戻り値型は基底クラス及び全メンバの<code>&lt;=&gt;</code>の結果型の共通比較カテゴリ型となるが、その型が<code>void</code>である場合は暗黙的に<code>delete</code>される。<br />
その際、暗黙宣言される<code>==</code>演算子は定義可能（比較に参加するすべての型について<code>==</code>の呼び出しが適格）ならば<code>default</code>で宣言される。</p>
<h4>default実装</h4>
<p>default宣言された<code>&lt;=&gt; ==</code>演算子はその基底クラスと非静的メンバを宣言順に比較していくことで実装される。</p>
<p>その手順は以下のようになる（演算子<code>@</code>は<code>&lt;=&gt; ==</code>のどちらかとする）。</p>
<ol>
<li>基底クラスの<code>@</code>を呼び出して比較を行う。その順番は継承順（<code>:</code>の後ろに書いてある型を左から右）、深さ優先で比較される。<ul>
<li>この時、仮想基底クラスが複数回比較されるかは未規定。</li>
</ul>
</li>
<li>宣言された順番（上から下）で非静的メンバを<code>@</code>によって比較する。<ul>
<li>この時、配列は要素ごとに比較する。</li>
</ul>
</li>
<li>これらの比較の際、結果が<code>0</code>（<code>==</code>なら<code>true</code>）とならない時点でその結果を返して終了する。</li>
</ol>
<p>この手順を明示的に書くと以下の様な実装になる。</p>
<p><div class="codehilite"><pre><span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">v</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="c1">//auto operator&lt;=&gt;(const D&amp;) const = default;</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Base1</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Base1</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">that</span><span class="p">);</span> <span class="n">comp</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">comp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Base2</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Base2</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">that</span><span class="p">);</span> <span class="n">comp</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">comp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;=&gt;</span> <span class="n">that</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">comp</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">comp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&lt;=&gt;</span> <span class="n">that</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">comp</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">comp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=&gt;</span> <span class="n">that</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">comp</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">comp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=&gt;</span> <span class="n">that</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">comp</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">comp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=&gt;</span> <span class="n">that</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">comp</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">comp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">&lt;=&gt;</span> <span class="n">that</span><span class="p">.</span><span class="n">v</span><span class="p">;</span>
   <span class="p">}</span>

  <span class="c1">//auto operator==(const D&amp;) const = default;</span>
  <span class="k">auto</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Base1</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Base1</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">that</span><span class="p">);</span> <span class="n">comp</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Base2</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Base2</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">that</span><span class="p">);</span> <span class="n">comp</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">comp</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">comp</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">that</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">comp</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">that</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">comp</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">that</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">comp</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">==</span> <span class="n">that</span><span class="p">.</span><span class="n">v</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</p>
<h4>その他の比較演算子のdefault宣言</h4>
<p><code>&lt;=&gt; ==</code>だけでなく、残りの比較演算子もdefault指定で宣言することができる。<br />
有効な宣言は<code>&lt;=&gt; ==</code>に準ずるが、<code>friend</code>で宣言することは出来ない。</p>
<p>そのようなdefault実装は、オーバーロード解決時に生成される式と同様の式を使って実装される（すなわち、<code>&lt;=&gt; ==</code>から実装される）。</p>
<p>使用する<code>&lt;=&gt; ==</code>演算子が曖昧である、アクセスできない、削除されている場合や、<code>&lt;=&gt;</code>の戻り値型が対象の演算子を生成できないか<code>==</code>の戻り値型が文脈的に<code>bool</code>に変換できない場合は、そのdefault宣言は暗黙的に<code>delete</code>される。</p>
<p><div class="codehilite"><pre><span class="k">struct</span> <span class="n">C</span> <span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/cstddef/nullptr_t.html">std::nullptr_t</a></span> <span class="n">np</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>


  <span class="n">std</span><span class="o">::</span><span class="n">strong_equality</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>  <span class="c1">//ok、暗黙的にdeleteされる</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>  <span class="c1">//ok、使用可能</span>
<span class="p">};</span>
</pre></div>
</p>
<p>これは、比較演算子のアドレスを取りたいときに使用する。</p>
<h3>組み込み型の三方比較</h3>
<p>三方比較演算子は<code>void</code>と参照型を除く組み込みの型に対して、組み込みの物が提供される。<br />
その比較カテゴリ型は以下のようになる（以下、比較とは<code>&lt;=&gt;</code>によるものを指す）。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th align="left">型</th>
<th align="center">カテゴリ</th>
<th align="left">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>bool</code></td>
<td align="center"><code>std::strong_ordering</code></td>
<td align="left"><code>bool</code>同士でしか比較不可</td>
</tr>
<tr>
<td align="left"><code><a href="https://cpprefjp.github.io/reference/type_traits/is_integral.html">整数型</a></code></td>
<td align="center"><code>std::strong_ordering</code></td>
<td align="left">縮小変換が行われる場合は比較不可</td>
</tr>
<tr>
<td align="left"><code><a href="https://cpprefjp.github.io/reference/type_traits/is_floating_point.html">浮動小数点型</a></code></td>
<td align="center"><code>std::partial_ordering</code></td>
<td align="left">縮小変換が行われる場合は比較不可<br /><code>NaN</code>や<code>±0.0</code>の存在のため半順序</td>
</tr>
<tr>
<td align="left">オブジェクトポインタ</td>
<td align="center"><code>std::strong_ordering</code></td>
<td align="left">あらゆるポインタ変換が施された後、同じポインタ型にならなければ比較不可<br />配列と配列は比較不可</td>
</tr>
<tr>
<td align="left">関数/メンバポインタ</td>
<td align="center"><code>std::strong_equality</code></td>
<td align="left">あらゆるポインタ変換が施された後、同じポインタ型にならなければ比較不可</td>
</tr>
<tr>
<td align="left"><code>std::nullptr_t</code></td>
<td align="center"><code>std::strong_equality</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">列挙型</td>
<td align="center"><code>std::strong_ordering</code></td>
<td align="left">スコープ有無に関わらず同じ列挙型同士でしか比較不可</td>
</tr>
</tbody>
</table>
<p>なお、参照型に対する<code>&lt;=&gt;</code>による比較は参照先の型による比較になる。</p>
<h4>従来の比較演算子との差異及び修正</h4>
<p>三方比較演算子による比較は従来の比較演算子の挙動とは異なるところがある（より安全な比較となっている）。<br />
それに伴って、いくつかの比較演算子の挙動が修正された。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th align="left">比較するペア</th>
<th align="left">従来演算子での比較の可否</th>
<th align="left"><code>&lt;=&gt;</code>での比較の可否</th>
<th align="left">従来演算子の修正（C++20より、非推奨扱い）</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">符号なし整数型と符号付整数型</td>
<td align="left">〇</td>
<td align="left">×<br />ただし定数式で符号付きオペランドが正の値に評価されれば可能</td>
<td align="left">ー（従来通り）</td>
</tr>
<tr>
<td align="left">列挙型と算術型</td>
<td align="left">〇<br />例えば、列挙型と浮動小数点型の比較が可能</td>
<td align="left">△<br />スコープ無し列挙型と整数型のみ可能</td>
<td align="left">△<br />列挙型と浮動小数点型間比較は不可<br />それ以外は従来通り</td>
</tr>
<tr>
<td align="left">異なる列挙型間</td>
<td align="left">〇</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">配列同士</td>
<td align="left">△<br />標準は未規定だが多くの実装ではポインタに変換して比較する</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left"><code>nullptr</code>とポインタ</td>
<td align="left">△<br />関係演算子では不可</td>
<td align="left">〇<br />ただし、ポインタが<code>nullptr</code>でない場合の結果は未規定</td>
<td align="left">ー</td>
</tr>
<tr>
<td align="left">関数ポインタ間</td>
<td align="left">〇<br />異なるポインタ間の順序付けの結果は未規定</td>
<td align="left">〇</td>
<td align="left">ー</td>
</tr>
</tbody>
</table>
<h2>C++17までの比較演算子実装の一例</h2>
<p><div class="yata" id="5e10a49bbc4f514cdd29dc7609f7e35056270388"><div class="codehilite"><pre><span class="cp">#include <a href="https://cpprefjp.github.io/reference/iostream.html">&lt;iostream&gt;</a></span>
<span class="cp">#include <a href="https://cpprefjp.github.io/reference/tuple.html">&lt;tuple&gt;</a></span>

<span class="k">struct</span> <span class="n">S</span>  <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

  <span class="n">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n"><a href="https://cpprefjp.github.io/reference/tuple/tie.html">std::tie</a></span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
         <span class="o">&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/tuple/tie.html">std::tie</a></span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">d</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rhs</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rhs</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">rhs</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n"><a href="https://cpprefjp.github.io/reference/tuple/tie.html">std::tie</a></span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="o">==</span> <span class="n"><a href="https://cpprefjp.github.io/reference/tuple/tie.html">std::tie</a></span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">d</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rhs</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rhs</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">rhs</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span> <span class="o">&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">S</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">};</span>
  <span class="n">S</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s">"ABC"</span><span class="p">};</span>

  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ios/boolalpha.html">std::boolalpha</a></span><span class="p">;</span>

  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&lt;</span>  <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&lt;=</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&gt;</span>  <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&gt;=</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div></p>
<h3>出力</h3>
<p><pre><code>false
false
true
true
false
true
</code></pre></p>
<h2>C++20での比較演算子実装例</h2>
<p><div class="yata" id="976551b9151bbe3c280a2c86632d51ca346d88dc"><div class="codehilite"><pre><span class="cp">#include &lt;compare&gt;</span>
<span class="cp">#include <a href="https://cpprefjp.github.io/reference/iostream.html">&lt;iostream&gt;</a></span>

<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

  <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">S</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">};</span>
  <span class="n">S</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s">"ABC"</span><span class="p">};</span>

  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ios/boolalpha.html">std::boolalpha</a></span><span class="p">;</span>

  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&lt;</span>  <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&lt;=</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&gt;</span>  <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">&gt;=</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/iostream/cout.html">std::cout</a></span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/ostream/endl.html">std::endl</a></span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div></p>
<h3>出力</h3>
<p><pre><code>false
false
true
true
false
true
</code></pre></p>
<h2>この機能が必要になった背景・経緯</h2>
<p>C++17以前の例に示したように、従来のC++における比較演算子の実装は煩雑でボイラープレートの様なコードを大量にコピーアンドペーストすることになる。さらに、異種型間比較を加えるとその対称性のために同じ比較について引数型を逆にしたものを用意しなければならないため、そのようなボイラープレートは更に倍になることになる。<br />
この問題は以前から認識されており、比較演算子が実際には<code>&lt; ==</code>の2つから残りのすべてを導出できることを利用して実装を簡易にする、<a href="https://boostjp.github.io/tips/operators.html" target="_blank">Boost Operators Library</a>や<code><a href="https://cpprefjp.github.io/reference/utility/rel_ops.html">std::rel_ops</a></code>等が提供されていた。しかし、これを用いても異種型間比較におけるボイラープレートを完全に取り除くことは出来ない。</p>
<p>また、比較演算子の実装に伴う別の問題として、クラスの全メンバが参加するような構造的な比較を提供する際にも、メンバの列挙方法が無いために全てのメンバを<code>&lt;</code>や<code>==</code>で繋いで回るコードを書くことを強いられていた。<br />
比較演算子実装の多くの場合はこのような構造的な比較を提供すれば十分であり、その場合はクラスによってメンバ名等が違えど全メンバの辞書式比較を行うという点に変わりはない。</p>
<p>これらの問題の解決を言語機能によって提供するために、三方比較演算子が導入された。</p>
<p>上で示したように、任意のクラス型に対する比較演算子の実装は<code>&lt;=&gt;</code>を1つ定義するだけで完結する。その比較が構造的なものであるならば、<code>default</code>指定することで定義を書く必要すらない。<br />
そして、<code>default</code>指定された<code>&lt;=&gt;</code>と<code>==</code>は基底クラス及び全メンバの宣言順の辞書式比較を行う。<br />
異種型間比較においても、1つの引数順の<code>&lt;=&gt;</code>と<code>==</code>の2つを定義することで残りの11個の比較演算子を導出することができる。</p>
<h2>検討されたほかの選択肢</h2>
<p>当初の三方比較演算子から導出される演算子は同値比較（<code>== !=</code>）のものも含めた最大6つであった。しかし、同値比較なら比較ついての処理を短絡評価できる場合に、<code>&lt;=&gt;</code>を用いて<code>== !=</code>を導出すると短絡評価が行われず非効率になるケースがあったため、<code>&lt;=&gt;</code>から<code>==</code>を切り離し、<code>!=</code>は<code>==</code>から導出するように変更された。</p>
<p>例えば、<code><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></code>で<code>&lt;=&gt;</code>を実装することを考えてみる。</p>
<p><div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n"><span href="https://cpprefjp.github.io/reference/compare/strong_ordering.md.nolink">strong_ordering</span></span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/cstddef/size_t.html">size_t</a></span> <span class="n">min_size</span> <span class="o">=</span> <span class="n"><a href="https://cpprefjp.github.io/reference/algorithm/min.html">std::min</a></span><span class="p">(</span><span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector/size.html">lhs.size()</a></span><span class="p">,</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector/size.html">rhs.size()</a></span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n"><a href="https://cpprefjp.github.io/reference/cstddef/size_t.html">size_t</a></span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">min_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n"><span href="https://cpprefjp.github.io/reference/algorithm/compare_3way.md.nolink">std::compare_3way</span></span><span class="p">(</span><span class="n">lhs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">cmp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">cmp</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector/size.html">lhs.size()</a></span> <span class="o">&lt;=&gt;</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector/size.html">rhs.size()</a></span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</p>
<p>これは、保持する要素に対する辞書式比較を行う実装で既存の比較演算子と等価の処理である。<br />
実際の比較は<code><span href="https://cpprefjp.github.io/reference/algorithm/compare_3way.md.nolink">compare_3way</span></code>に移譲しているが、これは<code>T</code>に<code>&lt;=&gt;</code>があればそれを利用し無ければ<code>&lt;</code>と<code>==</code>を使って比較を行う関数である（C++20より利用可能）。</p>
<p>これは順序付けにおいては問題ないが、同値比較を行おうとすると非効率な点がある。それは、長さを一番最後に比較していることで、同値比較の場合は一番最初に<code>vector</code>の長さをチェックし異なっていれば、その時点で結果が<code>false</code>になると分かり、処理を終えることができる。<br />
従って、<code>vector</code>における<code>==</code>の効率的な実装は以下のようになる。</p>
<p><div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//サイズを先にチェックすることで比較をショートサーキット</span>
  <span class="k">const</span> <span class="n"><a href="https://cpprefjp.github.io/reference/cstddef/size_t.html">size_t</a></span> <span class="n">size</span> <span class="o">=</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector/size.html">lhs.size()</a></span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector/size.html">rhs.size()</a></span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="n"><a href="https://cpprefjp.github.io/reference/cstddef/size_t.html">size_t</a></span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//ネストする比較においても&lt;=&gt;ではなく==を使う（ようにしたい）</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</p>
<p>この様にしておけば、<code>vector</code>のオブジェクト同士の同値比較においては常に効率的な実装が選択される。</p>
<p>ところで、当初の仕様では<code>== !=</code>も三方比較演算子から導出されており、その際に生成する式は以下のように規定されていた。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th align="center">呼び出す演算子 <code>a @ b</code></th>
<th align="center">オーバーロード候補</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>a == b</code></td>
<td align="center"><code>a == b</code><br /><code>(a &lt;=&gt; b) == 0</code><br /><code>0 == (b &lt;=&gt; a)</code></td>
</tr>
<tr>
<td align="center"><code>a != b</code></td>
<td align="center"><code>a != b</code><br /><code>(a &lt;=&gt; b) != 0</code><br /><code>0 != (b &lt;=&gt; a)</code></td>
</tr>
</tbody>
</table>
<p>この前提の下で上記の効率的な<code>==</code>実装をした<code>vector</code>を保持する別の型を考えてみると困ったことが起こる。</p>
<p><div class="codehilite"><pre><span class="k">struct</span> <span class="n">has_vector</span> <span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

  <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">has_vector</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</p>
<p>この<code>has_vector</code>クラスは以前の仕様の下でも<code>&lt;=&gt;</code>を利用して6つの比較演算子による比較が可能である。<br />
しかし、この<code>has_vector</code>クラスのオブジェクトに対して<code>== !=</code>による比較を行った時、呼び出されるのは<code>vector</code>に定義された<code>&lt;=&gt;</code>であって効率的に実装された<code>==</code>ではない。<br />
この<code>has_vector</code>の同値比較において、内部<code>vector</code>に実装された効率的な<code>==</code>を呼び出すには以下のようにしなければならない。</p>
<p><div class="codehilite"><pre><span class="k">struct</span> <span class="n">has_vector</span> <span class="p">{</span>
  <span class="n"><a href="https://cpprefjp.github.io/reference/vector/vector.html">std::vector</a></span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

  <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">has_vector</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">has_vector</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">vec</span> <span class="o">==</span> <span class="n">that</span><span class="p">.</span><span class="n">vec</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">has_vector</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">vec</span> <span class="o">!=</span> <span class="n">that</span><span class="p">.</span><span class="n">vec</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</p>
<p><code>vector</code>に対して行ったように<code>== !=</code>を独自に定義する。しかも、この<code>has_vector</code>を包含するまた別のクラスでも同様にしなければならない。<br />
また、この様なボイラープレートのコピーアンドペーストが必要になるかどうかは、クラスに含まれる型の全ての<code>== !=</code>演算子の実装を再帰的に辿り判断する必要がある。</p>
<p>これは当初の一貫比較が目指した方向性とは真逆であり、RustやHaskell等の他言語においても同値比較と順序付けの演算子は区別されたうえで自動実装が行われていることから、C++においても同様に<code>&lt;=&gt;</code>から<code>== !=</code>が切り離されることとなった。</p>
<p>しかし、当初の一貫比較仕様の簡便さを損なわないために、default実装の<code>&lt;=&gt;</code>があれば暗黙的に<code>==</code>を宣言するという仕様を追加し、効率的な<code>==</code>の実装が必要ない型では当初の仕様にほぼ沿った形で恩恵を受けることができる。</p>
<h2>関連項目</h2>
<ul>
<li><code><span href="https://cpprefjp.github.io/reference/compare.md.nolink">&lt;compare&gt;</span></code><ul>
<li>比較カテゴリ型<ul>
<li><code><span href="https://cpprefjp.github.io/reference/compare/weak_equality.md.nolink">weak_equality</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/strong_equality.md.nolink">strong_equality</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/partial_ordering.md.nolink">partial_ordering</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/weak_ordering.md.nolink">weak_ordering</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/strong_ordering.md.nolink">strong_ordering</span></code></li>
</ul>
</li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/common_comparison_category.md.nolink">common_comparison_category</span></code></li>
<li>比較関数<ul>
<li><code><span href="https://cpprefjp.github.io/reference/compare/strong_order.md.nolink">strong_order</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/weak_order.md.nolink">weak_order</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/partial_order.md.nolink">partial_order</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/strong_equal.md.nolink">strong_equal</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/compare/weak_equal.md.nolink">weak_equal</span></code></li>
</ul>
</li>
</ul>
</li>
<li><code><span href="https://cpprefjp.github.io/reference/algorithm/compare_3way.md.nolink">compare_3way</span></code></li>
<li><code><span href="https://cpprefjp.github.io/reference/algorithm/lexicographical_compare_3way.md.nolink">lexicographical_compare_3way</span></code></li>
</ul>
<h2>参照</h2>
<ul>
<li>C++20にて承認された提案文書<ul>
<li><a href="http://wg21.link/p0515" target="_blank">P0515R3 Consistent comparison</a></li>
<li><a href="http://wg21.link/p0768" target="_blank">P0768R1 Library support for the spaceship (comparison) operator</a></li>
<li><a href="http://wg21.link/p1120" target="_blank">P1120R0 Consistency improvements for &lt;=&gt; and other comparison operators</a></li>
<li><a href="http://wg21.link/p1185" target="_blank">p1185R2 &lt;=&gt; != ==</a></li>
</ul>
</li>
<li>以前に検討されていた提案文書<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3950.html" target="_blank">N3950 Defaulted comparison operators</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4114.htm" target="_blank">N4114 Defaulted comparison operators</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4126.htm" target="_blank">N4126 Explicitly defaulted comparison operators</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4475.pdf" target="_blank">N4475 Default comparisons (R2)</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4476.pdf" target="_blank">N4476 Thoughts about Comparisons (R2)</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0221r2.html" target="_blank">P0221R2: Proposed wording for default comparisons, revision 4</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0100r2.html" target="_blank">P0100R2 Comparison in C++</a></li>
</ul>
</li>
</ul></div>

      </div>
    </div>
  </div>
  
  
    <div id="sidebar" class="col-sm-3 col-sm-pull-9">
    </div>
  

</div>
            </div>
        </main>
<footer class="footer navbar navbar-default">
  <div class="container-fluid">
    <p><small>
      本サイトの情報は、
        <a href="https://creativecommons.org/licenses/by/3.0/deed.ja" rel="nofollow">クリエイティブ・コモンズ 表示 3.0 非移植 ライセンス(CC BY)</a>
      の下に提供されています。
    </small></p>
  </div>
</footer>
    </body>
</html>