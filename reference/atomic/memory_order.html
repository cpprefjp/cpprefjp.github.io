<h1>memory_order (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  typedef enum memory_order {
    memory_order_relaxed, memory_order_consume, memory_order_acquire,
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
  } memory_order;
}</span></code></pre>
</p>
<h2>概要</h2>
<p>コンパイラに許可されている最適化の一つに、「プログラムの意味を変えない限りにおいて、メモリアクセスの順番を変えたり、省略したりしてもよい」というものがある。また、マルチコアCPUにおいては、あるCPUコアによるメモリアクセスの順序が他のコアからも同じように見えるとは限らない。このような挙動はマルチスレッドプログラミングにおいて問題になることがある。
この問題への対処として、C++11では各スレッドの実行に順序付けをするための"happens before"(先行発生)という関係を定義し、それによってあるスレッドでの操作が他スレッドから可視になるか否かを定めている。
atomic変数においては、"release"操作によって書き込まれた値を"acquire"操作によって別のスレッドが読み出した場合に、そのrelease操作とacquire操作の間に順序付けが行われる。以下に例を挙げる。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">memory_order_acquire</span>)) {
  }

  std::cout &lt;&lt; data &lt;&lt; std::endl;   // (2)
}

int main()
{
  std::thread t(f);

  data = 3;   // (1)
  ready.store(true, std::<span style="color:#ff0000">memory_order_release</span>);

  t.join();
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
int data;
std::atomic&lt;bool&gt; ready(false);

void f()
{
  while (!ready.load(std::</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">3
</span></code></pre>
<a href="http://cpprefjp.github.io/reference/atomic/atomic.html"><code><span style="color: #000">atomic&lt;bool&gt;</span></code></a>型の変数<code><span style="color: #000">ready</span></code>への読み書きに注目すると、<code><span style="color: #000">main()</span></code>では変数<code><span style="color: #000">ready</span></code>に <code><span style="color: #000">true</span></code> を"release"操作として書き込み、<code><span style="color: #000">f()</span></code>では"acquire"操作としての読み込みを <code><span style="color: #000">true</span></code> が返されるまで繰り返している。よって、<code><span style="color: #000">f()</span></code>の<code><span style="color: #000">while</span></code>ループを抜けた時点で、<code><span style="color: #000">main()</span></code>の<code><span style="color: #000">ready.store()</span></code>と<code><span style="color: #000">f()</span></code>の<code><span style="color: #000">ready.load()</span></code>の間に順序付け(happens before関係)が成立している。
ここでさらに変数<code><span style="color: #000">data</span></code>への読み書き(1), (2)に注目すると、(1)は<code><span style="color: #000">ready.store()</span></code>より前、(2)は<code><span style="color: #000">ready.load()</span></code>より後にあるので、以下のようなスレッド間の順序付け(happens before関係)が成立することになる。
   (1) → <code><span style="color: #000">ready.store()</span></code> → <code><span style="color: #000">ready.load()</span></code> → (2)
よって、(1)における書き込みが(2)の時点で可視であることが保証される。
このようにしてC++のマルチスレッドプログラムにおける実行順序および可視性を理解することができる。</p>
<p>以下の列挙値はatomic変数への操作に指定可能な順序付けの種類を表す。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>列挙値</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">memory_order_relaxed</span></code></td>
<td>スレッド間の順序付けの効果は一切持たない。</td>
</tr>
<tr>
<td><code><span style="color: #000">memory_order_consume</span></code></td>
<td>acquire操作と似ているが、それより弱い順序付けでの読み込みを行うことを指示する。acquire操作は後続の全ての操作に対して順序付けを行うのに対し、consume操作は読み込まれた値に依存(ただし条件分岐による依存は除く)する操作のみに順序付けを保証する点が異なる。<a href="http://cpprefjp.github.io/reference/atomic/atomic/store.html">store()</a>など、書き込みのみを行う操作に対しては指定できない。</td>
</tr>
<tr>
<td><code><span style="color: #000">memory_order_acquire</span></code></td>
<td>aquire操作としての読み込みを行うことを指示する。<a href="http://cpprefjp.github.io/reference/atomic/atomic/store.html">store()</a>など、書き込みのみを行う操作に対しては指定できない。</td>
</tr>
<tr>
<td><code><span style="color: #000">memory_order_release</span></code></td>
<td>release操作としての書き込みを行うことを指示する。<a href="http://cpprefjp.github.io/reference/atomic/atomic/load.html">load()</a>など、読み込みのみを行う操作に対しては指定できない。</td>
</tr>
<tr>
<td><code><span style="color: #000">memory_order_acq_rel</span></code></td>
<td>読み込みと書き込みを同時に行う操作(Read-Modify-Write操作)に対してのみ指定することができ、acquireとreleaseを合わせた効果を持つ。</td>
</tr>
<tr>
<td><code><span style="color: #000">memory_order_seq_cst</span></code></td>
<td>aquire(読み込み操作の場合)、release(書き込み操作の場合)、acq_rel(Read-Modify-Write操作の場合)としての効果を持つ。さらに、同じseq_cstが指定されている他のatomic操作との間での順序一貫性も保証する。これは最も強い保証であり、標準のatomic操作におけるデフォルトのメモリオーダーとして使用される。「seq_cst」は「sequential consistency(順序一貫性)」を意味する。</td>
</tr>
</tbody>
</table>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang</a>: ??</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC</a>: </li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++0x mode</a>: 4.7.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#icc">ICC</a>: ??</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>: 11.0, 12.0</li>
</ul>
<h2>参照</h2>
<ul>
<li><a href="http://d.hatena.ne.jp/bsdhouse/20090720/1248085754" target="_blank">そろそろvolatileについて一言いっておくか - yamasaのネタ帳</a></li>
<li><a href="http://d.hatena.ne.jp/bsdhouse/20090816/1250446250" target="_blank">次期C++に導入されるメモリバリアについて解説してみる - yamasaのネタ帳</a></li>
<li><a href="http://d.hatena.ne.jp/bsdhouse/20090929/1254237835" target="_blank">C++0xのメモリバリアをより深く解説してみる - yamasaのネタ帳</a></li>
<li><a href="http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html" target="_blank">C/C++11 mappings to processors</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1525.htm" target="_blank">N1525: Memory-Order Rationale</a></li>
<li><a href="http://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/" target="_blank">The Purpose of memory_order_consume in C++11</a></li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/atomic/memory_order.md" target="_blank">編集</a></footer>