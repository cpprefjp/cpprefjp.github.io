<h1>decay (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  template &lt;class T&gt;
  struct decay {
    typedef … type;
  };
}</span></code></pre>
</p>
<h2>概要</h2>
<p>型<code><span style="color: #000">T</span></code>に対して関数テンプレートと同じ規則で推論した型を取得する。</p>
<h2>効果</h2>
<p><a href="http://cpprefjp.github.io/reference/type_traits/remove_reference.html"><code><span style="color: #000">remove_reference</span></code></a><code><span style="color: #000">&lt;T&gt;::type</span></code>した型を<code><span style="color: #000">U</span></code>とする。<br />
型<code><span style="color: #000">U</span></code>が配列型<code><span style="color: #000">U[N]</span></code>であれば、<code><span style="color: #000">U*</span></code>型をメンバ型<code><span style="color: #000">type</span></code>として定義する。<br />
型<code><span style="color: #000">U</span></code>が関数型<code><span style="color: #000">R(Args...)</span></code>であれば、<code><span style="color: #000">R(*)(Args...)</span></code>型をメンバ型<code><span style="color: #000">type</span></code>として定義する。<br />
それ以外の場合は、<a href="http://cpprefjp.github.io/reference/type_traits/remove_cv.html"><code><span style="color: #000">remove_cv</span></code></a><code><span style="color: #000">&lt;U&gt;::type</span></code>した型を、メンバ型<code><span style="color: #000">type</span></code>として定義する。  </p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;type_traits&gt;

template &lt;class T1, class T2&gt;
struct my_pair {
  T1 first;
  T2 second;

  template &lt;class U1, class U2&gt;
  my_pair(const U1&amp; a, const U2&amp; b)
    : first(a), second(b) {}
};

template &lt;class T1, class T2&gt;
my_pair&lt;T1, T2&gt; my_bad_make_pair(const T1&amp; a, const T2&amp; b)
{
  return my_pair&lt;T1, T2&gt;(a, b);
}

template &lt;class T1, class T2&gt;
my_pair&lt;
  typename std::decay&lt;const T1&gt;::type,
  typename std::decay&lt;const T2&gt;::type
&gt;
  my_make_pair(const T1&amp; a, const T2&amp; b)
{
  return my_pair&lt;
           typename std::decay&lt;const T1&gt;::type,
           typename std::decay&lt;const T2&gt;::type
          &gt;(a, b);
}

int main()
{
  // コンパイルエラー！
  // 配列をコンストラクタの初期化子で初期化できない
//auto p = my_bad_make_pair("hello", "world");

  // OK
  // decltype(q) == my_pair&lt;const char*, const char*&gt;
  auto q = my_make_pair("hello", "world");

  // OK
  // decltype(a) == mu_pair&lt;int, int&gt;
  auto a = my_make_pair(3, 1);
  a.first = 2;
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000"></span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang</a>: 3.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++0x mode</a>: 4.4.7</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>: ??</li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/type_traits/decay.md" target="_blank">編集</a></footer>