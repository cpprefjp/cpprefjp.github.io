<h1>aligned_storage (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><i>default-alignment</i>&gt;
  struct aligned_storage {
    typedef … type;
  };
}<span style="color: #000">namespace std {
  template &lt;std::size_t Len,
            std::size_t Align = </span></code></pre>
</p>
<h2>概要</h2>
<p>アラインメント調整された領域を作る。</p>
<h2>要件</h2>
<p><code><span style="color: #000">Len</span></code>が非ゼロであること。<code><span style="color: #000">Align</span></code>は、得ようとしてる領域の要素型<code><span style="color: #000">T</span></code>に対する<code><span style="color: #000">alignof(T)</span></code>と同じ大きさか、もしくはデフォルト値であること。</p>
<h2>効果</h2>
<p><code><span style="color: #000">aligned_storage</span></code>は、領域サイズ<code><span style="color: #000">Len</span></code>、アラインメント<code><span style="color: #000">Align</span></code>で調整した未初期化領域をメンバ型<code><span style="color: #000">type</span></code>として定義する。<br />
メンバ型<code><span style="color: #000">type</span></code>はPOD型となる(参照：<a href="http://cpprefjp.github.io/reference/type_traits/is_pod.html"><code><span style="color: #000">is_pod</span></code></a>)。  </p>
<p><code><span style="color: #000">Align</span></code>のデフォルト値は、<code><span style="color: #000">Len</span></code>よりも大きくない、最も厳格なアラインメント要件を持つ、C++の何らかのオブジェクト型のアラインメント値。</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template &lt;class T, std::size_t Capacity&gt;
class StackContainer {
  // 長さ：sizeof(T) * Count、
  // アラインメント：alignof(T)
  // でアラインメント調整された領域を作る
  typename
    std::aligned_storage&lt;sizeof(T) * Capacity, alignof(T)&gt;::type
  storage;

  std::size_t size_ = 0;

  T* data()
  {
    return static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;storage));
  }

public:
  void push(T value)
  {
    // 未初期化領域に要素を作る
    new (data() + size_) T(value);
    ++size_;
  }

  T&amp; front()
  {
    return *data();
  }

  ~StackContainer()
  {
    for (std::size_t i = 0; i &lt; size_; ++i) {
      (data() + i)-&gt;~T();
    }
  }
};

int main()
{
  StackContainer&lt;int, 3&gt; cont;
  cont.push(1);

  std::cout &lt;&lt; cont.front() &lt;&lt; std::endl;
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">1
</span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang</a>: 3.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++0x mode</a>: 4.5.4</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>: ??</li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/type_traits/aligned_storage.md" target="_blank">編集</a></footer>