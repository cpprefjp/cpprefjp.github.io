<h1>iterator</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  template&lt;class Category,
           class T,
           class Distance = ptrdiff_t,
           class Pointer = T*,
           class Reference = T&amp;&gt;
  struct iterator {
    typedef T value_type;
    typedef Distance difference_type;
    typedef Pointer pointer;
    typedef Reference reference;
    typedef Category iterator_category;
  };
}</span></code></pre>
</p>
<h2>概要</h2>
<p><code><span style="color: #000">std::iterator</span></code>クラスは、イテレータを定義するための基本クラスである。
イテレータ定義に必要ないくつかの<code><span style="color: #000">typedef</span></code>を簡略化するために使用できる。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>テンプレートパラメータ</td>
<td>説明</td>
</tr>
<tr>
<td><code><span style="color: #000">Category</span></code></td>
<td>イテレータの分類。 (参照： <a href="http://cpprefjp.github.io/reference/iterator/iterator_tag.html">iterator tag</a>)</td>
</tr>
<tr>
<td><code><span style="color: #000">T</span></code></td>
<td>イテレータが指す値型</td>
</tr>
<tr>
<td><code><span style="color: #000">Distance</span></code></td>
<td>イテレータ間の差を表す型。 デフォルトは<code><span style="color: #000">std::ptrdiff_t</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">Pointer</span></code></td>
<td>イテレータが指す値のポインタ型 デフォルトは<code><span style="color: #000">T*</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">Reference</span></code></td>
<td>イテレータが指す値の参照型 デフォルトは<code><span style="color: #000">T&amp;</span></code></td>
</tr>
</tbody>
</table>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">std::iterator</span>&lt;std::input_iterator_tag, int&gt; {

  int x_;

public:
  increment_iterator(int x = 0) : x_(x) {}

  increment_iterator&amp; operator++()
  {
    ++x_;
    return *this;
  }

  increment_iterator operator++(int)
  {
    int tmp = x_;
    ++x_;
    return increment_iterator(tmp);
  }

  int operator*() const
    { return x_; }
};

inline bool operator==(const increment_iterator&amp; a, const increment_iterator&amp; b)
  { return *a == *b; }

inline bool operator!=(const increment_iterator&amp; a, const increment_iterator&amp; b)
  { return !(a == b); }

inline bool operator&lt;(const increment_iterator&amp; a, const increment_iterator&amp; b)
  { return *a &lt; *b; }

inline bool operator&lt;=(const increment_iterator&amp; a, const increment_iterator&amp; b)
  { return !(b &lt; a); }

inline bool operator&gt;(const increment_iterator&amp; a, const increment_iterator&amp; b)
  { return b &lt; a; }

inline bool operator&gt;=(const increment_iterator&amp; a, const increment_iterator&amp; b)
  { return !(a &lt; b); }

int main()
{
  increment_iterator first(0);
  increment_iterator last(10);

  std::for_each(first, last, [](int x) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
  });
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt; // for_each

// インクリメントするイテレータ
class increment_iterator
    : public </span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">0
1
2
3
4
5
6
7
8
9
</span></code></pre></p>
<h2>参照</h2>
<ul>
<li><code><span style="color: #000">std::iterator</span></code>は型定義のみを簡略化するが、これを発展させた<a href="http://www.boost.org/doc/libs/release/libs/iterator/doc/index.html" target="_blank">Boost Iterators Library</a>は、演算子定義も簡略化する機能を提供している。</li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/iterator/iterator.md" target="_blank">編集</a></footer>