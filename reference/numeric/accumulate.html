<h1>accumulate</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std{
  template &lt;class InputIterator, class T&gt;
  T accumulate(InputIterator first, InputIterator last, T init);

  template &lt;class InputIterator, class T, class BinaryOperation&gt;
  T accumulate(InputIterator first, InputIterator last, T init,
               BinaryOperation binary_op);
}</span></code></pre>
</p>
<h2>概要</h2>
<p>1つのシーケンスの任意の範囲の値を足し合わせる。</p>
<h2>パラメータ</h2>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">first</span></code></td>
<td>シーケンスの先頭</td>
</tr>
<tr>
<td><code><span style="color: #000">last</span></code></td>
<td>シーケンスの終端</td>
</tr>
<tr>
<td><code><span style="color: #000">init</span></code></td>
<td>初期値</td>
</tr>
<tr>
<td><code><span style="color: #000">binary_op</span></code></td>
<td>アキュームレータ</td>
</tr>
</tbody>
</table>
<h2>戻り値</h2>
<p>シーケンスの値の型。</p>
<h2>計算量</h2>
<p>Ο(n)</p>
<h2>実装例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class InputIterator, class T&gt;
T accumulate(InputIterator first, InputIterator last, T init) {
  while (first != last)
    init = init + *first++;
  return init;
}</span></code></pre>
</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class InputIterator, class T, class BinaryOperation&gt;
T accumulate(InputIterator first, InputIterator last, T init,
             BinaryOperation binary_op) {
  while (first != last)
    init = binary_op(init, *first++);
  return init;
}</span></code></pre>
</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">std::accumulate</span>(a.begin(), a.end(), .0) &lt;&lt; "\n"
    &lt;&lt; <span style="color:#ff0000">std::accumulate</span>(a.begin(), a.end(), 100.0
      , [](const u&amp; a, const u&amp; b)-&gt;u{
        return a+b*b;
      })
    &lt;&lt; std::endl;
}<span style="color: #000">#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;array&gt;

int main(){
  typedef std::array&lt;double, 5&gt; t;
  typedef t::value_type u;
  const t a = {.0,0.2,0.4,0.6,0.8};
  std::cout
    &lt;&lt; </span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">2
101.2
</span></code></pre></p>
<h2>備考</h2>
<p>C++03 の場合、<code><span style="color: #000">binary_op</span></code> で副作用を起こすことを禁止していた。これについては Effective STL 第37項で以下のように書かれている。 </p>
<p>(後で引用する) </p>
<p>C++11 以降では、要素を書き換えることと、イテレータを無効にすること以外の操作は全て認められるようになっている。 
つまり Effective STL 第37項に載っているような例を、何の問題も無く使用することができるようになっている。</p>
<p>この関数は、他の言語では<code><span style="color: #000">foldL</span></code>や<code><span style="color: #000">reduce</span></code>、<code><span style="color: #000">aggregate</span></code>といった名前で提供されている。</p>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/numeric/accumulate.md" target="_blank">編集</a></footer>