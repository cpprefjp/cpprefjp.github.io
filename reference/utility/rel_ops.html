<h1>rel_ops</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
namespace rel_ops {
  template &lt;class T&gt; bool operator!= ( const T&amp; x, const T&amp; y );
  template &lt;class T&gt; bool operator&gt;  ( const T&amp; x, const T&amp; y );
  template &lt;class T&gt; bool operator&lt;= ( const T&amp; x, const T&amp; y );
  template &lt;class T&gt; bool operator&gt;= ( const T&amp; x, const T&amp; y );
}}</span></code></pre>
</p>
<h2>概要</h2>
<p><code><span style="color: #000">std::rel_ops</span></code>名前空間は、関係演算子を自動的に定義する。</p>
<p><code><span style="color: #000">operator!=()</span></code>は、<code><span style="color: #000">operator==()</span></code>によって定義され、<code><span style="color: #000">operator&gt;()</span></code>、<code><span style="color: #000">operator&lt;=()</span></code>、<code><span style="color: #000">operator&gt;=()</span></code>は、<code><span style="color: #000">operator==()</span></code>によって定義される。</p>
<p>各演算子の定義は以下の通りである：</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
namespace rel_ops {
  template &lt;class T&gt; bool operator!= ( const T&amp; x, const T&amp; y ) { return !( x == y ); }
  template &lt;class T&gt; bool operator&gt;  ( const T&amp; x, const T&amp; y ) { return    y &lt; x;   }
  template &lt;class T&gt; bool operator&lt;= ( const T&amp; x, const T&amp; y ) { return !( y &lt; x ); }
  template &lt;class T&gt; bool operator&gt;= ( const T&amp; x, const T&amp; y ) { return !( x &lt; y ); }
}}</span></code></pre>
</p>
<h2>要件</h2>
<p><code><span style="color: #000">operator!=()</span></code>に対し、型<code><span style="color: #000">T</span></code>は<code><span style="color: #000">EqualityComparable</span></code>である必要がある。</p>
<p>すなわち、型<code><span style="color: #000">T</span></code>は<code><span style="color: #000">operator==()</span></code>による比較が可能であり、その比較は反射律、対象律、推移律を満たさねばならない。</p>
<p><code><span style="color: #000">operator&gt;()</span></code>、<code><span style="color: #000">operator&lt;=()</span></code>、<code><span style="color: #000">operator&gt;=()</span></code>に対し、型<code><span style="color: #000">T</span></code>は<code><span style="color: #000">LessThanComparable</span></code>である必要がある。</p>
<p>すなわち、型<code><span style="color: #000">T</span></code>は<code><span style="color: #000">operator&lt;()</span></code>による比較が可能であり、その比較は<a href="http://cpprefjp.github.io/reference/algorithm.html#strict-weak-ordering">狭義の弱順序</a>でなければならない。</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">std::rel_ops::operator!=</span>(a, b);
}

bool operator&gt;(const X&amp; a, const X&amp; b)
{
  return <span style="color:#ff0000">std::rel_ops::operator&gt;</span>(a, b);
}

bool operator&lt;=(const X&amp; a, const X&amp; b)
{
  return <span style="color:#ff0000">std::rel_ops::operator&lt;=</span>(a, b);
}

bool operator&gt;=(const X&amp; a, const X&amp; b)
{
  return <span style="color:#ff0000">std::rel_ops::operator&gt;</span>=(a, b);
}

int main()
{
  const X a = {1};
  const X b = {1};
  const X c = {2};

  if (a == b) {}
  if (a != b) {}
  if (a &lt;  c) {}
  if (a &lt;= c) {}
  if (a &gt;  c) {}
  if (a &gt;= c) {}
}<span style="color: #000">#include &lt;utility&gt;

struct X {
  int value;
};

bool operator==(const X&amp; a, const X&amp; b)
{
  return a.value == b.value;
}

bool operator&lt;(const X&amp; a, const X&amp; b)
{
  return a.value &lt; b.value;
}

// operator==()、operator&lt;()以外は自動定義
bool operator!=(const X&amp; a, const X&amp; b)
{
  return </span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000"></span></code></pre></p>
<h2>参照</h2>
<p>このライブラリを使う場合、 Boost Operators Libraryの使用も検討すべきである。
- <a href="http://www.boost.org/doc/libs/release/libs/utility/operators.htm" target="_blank">Boost Operators Library</a>
- <a href="https://sites.google.com/site/boostjp/tips/operators" target="_blank">演算子を自動定義する - Boost逆引きリファレンス</a></p>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/utility/rel_ops.md" target="_blank">編集</a></footer>