<h1>thread (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  class thread;
}</span></code></pre>
</p>
<h2>概要</h2>
<p>クラス<code><span style="color: #000">thread</span></code>は、新しい実行のスレッド(thread of execution)（以下、単にスレッドとする）の作成／待機／その他操作を行う機構を提供する。</p>
<h3>threadオブジェクトとスレッドとの関係性</h3>
<p><code><span style="color: #000">thread</span></code>オブジェクトとスレッドは1:1の関係で対応づけられるが、両者は同一ではないことに留意。<code><span style="color: #000">thread</span></code>コンストラクタによって新しく作成されたスレッドは、その<code><span style="color: #000">thread</span></code>オブジェクトに関係付けられる。</p>
<p><code><span style="color: #000">thread</span></code>コンストラクタでは新しいスレッドを1つ作成し、同コンストラクタを呼び出したスレッドはそのまま後続処理を続ける。一方で、新しいスレッド上では<code><span style="color: #000">thread</span></code>コンストラクタに与えた関数オブジェクトが呼び出される。つまりプログラム内に複数のスレッドが存在し、並行にそれぞれの処理を行うことが可能な状態となる。なお、複数のスレッドが真に並行実行されるか否かは処理系に依存する。（たとえばDual Core環境で4つのスレッドを作成することはできるが、ハードウェアの制約から同時処理されるのは2スレッド以下に制限される。）</p>
<p>新しいスレッド上で呼び出される関数オブジェクトから例外が送出された場合、<a href="http://cpprefjp.github.io/reference/exception/terminate.html"><code><span style="color: #000">std::terminate()</span></code></a>関数が呼び出されてプログラムは終了する。この動作が好ましくないのであれば、同関数オブジェクトから外に例外送出されないことをプログラマが保証しなければならない。</p>
<p>また、デフォルトコンストラクトされた<code><span style="color: #000">thread</span></code>オブジェクトは、何も指さない空の<code><span style="color: #000">thread</span></code>オブジェクトとなる。</p>
<h3>join操作とdetach操作</h3>
<p><code><span style="color: #000">thread</span></code>オブジェクトとスレッドが関連付けられた状態では、<code><span style="color: #000">thread</span></code>オブジェクトのメンバ関数<code><span style="color: #000">join()</span></code>を介してそのスレッド完了を待機することができる（join操作）。メンバ関数<code><span style="color: #000">join()</span></code>が呼び出された時点で<code><span style="color: #000">thread</span></code>オブジェクトに関連付けられたスレッドがまだ処理継続中だった場合、その対象スレッドが完了するまで呼び出し元スレッドがブロックされる。このjoin操作が終わった<code><span style="color: #000">thread</span></code>オブジェクトは、何も指さない空の<code><span style="color: #000">thread</span></code>オブジェクトとなる。</p>
<p>また<code><span style="color: #000">thread</span></code>オブジェクトのメンバ関数<code><span style="color: #000">detach()</span></code>により、<code><span style="color: #000">thread</span></code>オブジェクトとスレッドの関連付けを切ることもできる（detach操作）。detach操作がなされたスレッドは、それ以後は他スレッドから直接関与することが出来なくなる。またdetach操作が終わった<code><span style="color: #000">thread</span></code>オブジェクトは、何も指さない空の<code><span style="color: #000">thread</span></code>オブジェクトとなる。</p>
<p><code><span style="color: #000">thread</span></code>オブジェクトを破棄するデストラクタでは、その<code><span style="color: #000">thread</span></code>オブジェクトが何も指していないことが要件となっている。言い換えると、新しいスレッドを作成した<code><span style="color: #000">thread</span></code>オブジェクトでは、破棄される前にjoin操作またはdetach操作のいずれか一方が必ず行われなければならない。この要件に反した場合、<code><span style="color: #000">thread</span></code>オブジェクトのデストラクタは<a href="http://cpprefjp.github.io/reference/exception/terminate.html"><code><span style="color: #000">std::terminate()</span></code></a>関数を呼び出してプログラム終了する。</p>
<h3>メンバ関数</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/thread.html"><code><span style="color: #000">(constructor)</span></code></a></td>
<td>コンストラクタ</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/-thread.html"><code><span style="color: #000">(destructor)</span></code></a></td>
<td>デストラクタ</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/op_assign.html"><code><span style="color: #000">operator=</span></code></a></td>
<td>代入演算子</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/swap.html"><code><span style="color: #000">swap</span></code></a></td>
<td>別の<code><span style="color: #000">thread</span></code>と交換する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/joinable.html"><code><span style="color: #000">joinable</span></code></a></td>
<td>スレッドに関連付けられているか否かを取得する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/join.html"><code><span style="color: #000">join</span></code></a></td>
<td>スレッドが終了するまで待機する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/detach.html"><code><span style="color: #000">detach</span></code></a></td>
<td>スレッドの管理を手放す</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/get_id.html"><code><span style="color: #000">get_id</span></code></a></td>
<td>関連付けられているスレッドのスレッド識別子を取得する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/native_handle.html"><code><span style="color: #000">native_handle</span></code></a></td>
<td>スレッドに関連付けられたネイティブハンドルを取得する［処理系定義］</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h3>静的メンバ関数</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/hardware_concurrency.html"><code><span style="color: #000">hardware_concurrency</span></code></a></td>
<td>処理系によりサポートされるスレッド並行数を取得する</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h3>型</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/id.html"><code><span style="color: #000">id</span></code></a></td>
<td>スレッド識別子 (class)</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">native_handle_type</span></code></td>
<td>ネイティブハンドル型 (typedef)［処理系定義］</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h3>非メンバ関数</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/thread/thread/swap_free.html"><code><span style="color: #000">swap</span></code></a></td>
<td>2つの<code><span style="color: #000">thread</span></code>オブジェクトを入れ替える</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h2>備考</h2>
<p>型<code><span style="color: #000">native_handle_type</span></code>およびメンバ関数<code><span style="color: #000">native_handle</span></code>について、同メンバの存在有無およびその意味は処理系定義となる。</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;cassert&gt;
#include &lt;thread&gt;

int main()
{
  int x = 0, y = 0;

  std::thread thd([&amp;]{ ++x; });
  --y;
  thd.join();

  assert(x == 1 &amp;&amp; y == -1);
  return 0;
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000"></span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang</a>: ??</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC</a>: </li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++0x mode</a>: 4.7.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#icc">ICC</a>: ??</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a> 11.0(メモリリークするバグあり <a href="http://stackoverflow.com/questions/14238670/is-this-a-big-bug-of-microsofts-implementation-of-stdthread" target="_blank">link</a>)</li>
</ul>
<h2>参照</h2>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/thread/thread.md" target="_blank">編集</a></footer>