<h1>コンストラクタ (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><i>デフォルト</i>
thread() noexcept;

// <i>explicitテンプレート</i>
template &lt;class F, class ...Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);

// <i>コピー</i>
thread(const thread&amp;) = delete;

// <i>ムーブ</i>
thread(thread&amp;&amp;) noexcept;<span style="color: #000">// </span></code></pre>
</p>
<h2>概要</h2>
<p>新しいスレッドを生成し、そのスレッド上で引数<code><span style="color: #000">args...</span></code>を渡して関数オブジェクトfを呼び出す。
デフォルトコンストラクタでは新しいスレッドを生成しない。また<code><span style="color: #000">thread</span></code>オブジェクトはムーブコンストラクト可能／コピーコンストラクト不可。</p>
<h2>要件（explicitコンストラクタのみ）</h2>
<p>型<code><span style="color: #000">F</span></code>および<code><span style="color: #000">Args</span></code>に含まれるすべての型<code><span style="color: #000">Ti</span></code>はムーブコンストラクト可能な型でなければならない。また、<a href="http://cpprefjp.github.io/reference/functional/invoke.html"><code><span style="color: #000">INVOKE</span></code></a><code><span style="color: #000">(DECAY_COPY(</span></code><a href="http://cpprefjp.github.io/reference/utility/forward.html"><code><span style="color: #000">std::forward</span></code></a><code><span style="color: #000">&lt;F&gt;(f)), DECAY_COPY(</span></code><a href="http://cpprefjp.github.io/reference/utility/forward.html"><code><span style="color: #000">std::forward</span></code></a><code><span style="color: #000">&lt;Args&gt;(args))...)</span></code>が有効な式でなければならない。</p>
<h2>効果（explicitコンストラクタのみ）</h2>
<p>新しいスレッドを生成し、<a href="http://cpprefjp.github.io/reference/functional/invoke.html"><code><span style="color: #000">INVOKE</span></code></a><code><span style="color: #000">(DECAY_COPY(</span></code><a href="http://cpprefjp.github.io/reference/utility/forward.html"><code><span style="color: #000">std::forward</span></code></a><code><span style="color: #000">&lt;F&gt;(f)), DECAY_COPY(</span></code><a href="http://cpprefjp.github.io/reference/utility/forward.html"><code><span style="color: #000">std::forward</span></code></a><code><span style="color: #000">&lt;Args&gt;(args))...)</span></code>を実行する。ただし<code><span style="color: #000">DECAY_COPY</span></code>は同コンストラクタを呼び出したスレッド上にて評価される。また<code><span style="color: #000">f</span></code>のコピーの戻り値は無視される。</p>
<ul>
<li>
<p><code><span style="color: #000">DECAY_COPY(x)</span></code>は <code><span style="color: #000">template &lt;class T&gt; typename std::decay&lt;T&gt;::type decay_copy(T&amp;&amp; v) { return</span></code><a href="http://cpprefjp.github.io/reference/utility/forward.html"><code><span style="color: #000">std::forward</span></code></a><code><span style="color: #000">&lt;T&gt;(v); }</span></code> と定義される。おおよそ、<code><span style="color: #000">x</span></code>が配列型なら先頭要素へのポインタ、<code><span style="color: #000">x</span></code>が関数型ならその関数ポインタ、<code><span style="color: #000">x</span></code>がコピーコンストラクト可能な型なら<code><span style="color: #000">x</span></code>からコピーされたオブジェクト、<code><span style="color: #000">x</span></code>がムーブコンストラクト可能な型なら<code><span style="color: #000">x</span></code>からムーブされたオブジェクトとなる。</p>
</li>
<li>
<p><code><span style="color: #000">INVOKE(f, arg...)</span></code>は<code><span style="color: #000">f</span></code>が関数オブジェクトならば <code><span style="color: #000">f(arg...)</span></code> 形式の関数呼び出しとなる。詳細は<a href="http://cpprefjp.github.io/reference/functional/invoke.html"><code><span style="color: #000">INVOKE</span></code></a>の定義参照。
もし<code><span style="color: #000">INVOKE(DECAY_COPY(</span></code><a href="http://cpprefjp.github.io/reference/utility/forward.html"><code><span style="color: #000">std::forward</span></code></a><code><span style="color: #000">&lt;F&gt;(f)), DECAY_COPY(</span></code><a href="http://cpprefjp.github.io/reference/utility/forward.html"><code><span style="color: #000">std::forward</span></code></a><code><span style="color: #000">&lt;Args&gt;(args))...)</span></code>呼び出しからcatchされない例外が送出された場合、<a href="http://cpprefjp.github.io/reference/exception/terminate.html"><code><span style="color: #000">std::terminate()</span></code></a>が呼び出されてプログラムは異常終了する。</p>
</li>
</ul>
<h2>同期（explicitコンストラクタのみ）</h2>
<p>同コンストラクタの呼び出し完了は、fのコピーの呼び出し開始と<strong>同期する</strong>。つまり、「コンストラクタ呼び出し側スレッドT0でのコンストラクタ呼び出し完了」は、「新しいスレッド<code><span style="color: #000">T1</span></code>上での<code><span style="color: #000">f</span></code>のコピーの呼び出し開始」よりも<strong>前に発生する</strong>。</p>
<h2>事後条件</h2>
<ul>
<li>デフォルトコンストラクタ： <a href="http://cpprefjp.github.io/reference/thread/thread/get_id.html"><code><span style="color: #000">get_id()</span></code></a> <code><span style="color: #000">==</span></code> <a href="http://cpprefjp.github.io/reference/thread/thread/id.html"><code><span style="color: #000">id()</span></code></a>。</li>
<li>explicitコンストラクタ： <a href="http://cpprefjp.github.io/reference/thread/thread/get_id.html"><code><span style="color: #000">get_id()</span></code></a> <code><span style="color: #000">!=</span></code> <a href="http://cpprefjp.github.io/reference/thread/thread/id.html"><code><span style="color: #000">id()</span></code></a>。<code><span style="color: #000">*this</span></code>は新しいスレッドと関連付けられる。</li>
<li>ムーブコンストラクタ：ムーブ前の<code><span style="color: #000">x.</span></code><a href="http://cpprefjp.github.io/reference/thread/thread/get_id.html"><code><span style="color: #000">get_id()</span></code></a> <code><span style="color: #000">==</span></code> <a href="http://cpprefjp.github.io/reference/thread/thread/get_id.html"><code><span style="color: #000">get_id()</span></code></a> かつ ムーブ後の<code><span style="color: #000">x.</span></code><a href="http://cpprefjp.github.io/reference/thread/thread/get_id.html"><code><span style="color: #000">get_id()</span></code></a> <code><span style="color: #000">==</span></code> <a href="http://cpprefjp.github.io/reference/thread/thread/id.html"><code><span style="color: #000">id()</span></code></a></li>
</ul>
<h2>例外（explicitコンストラクタのみ）</h2>
<p>新しいスレッドの作成に失敗した場合、<a href="http://cpprefjp.github.io/reference/system_error/system_error.html"><code><span style="color: #000">system_error</span></code></a>例外を投げる。その例外オブジェクトには、以下のエラー状態が設定されうる：</p>
<ul>
<li><code><span style="color: #000">resource_unavailable_try_again</span></code> : 新たなスレッドを作るためのリソースが不足している。もしくはシステムやプロセスが規定するスレッド数の上限を超過した。</li>
</ul>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html">std::shared_ptr</a>&lt;int&gt; sp, <a href="http://cpprefjp.github.io/reference/memory/unique_ptr.html">std::unique_ptr</a>&lt;int&gt; up)
{
  // spはコピーされた値が、upはムーブされた値が渡されてくる
  v = ri = 42;

  int x = *sp + *up;
  assert(x == 7);
  return x;  // この戻り値は無視される
}

int main()
{
  int i1 = 0;
  int i2;
  <a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html">std::shared_ptr</a>&lt;int&gt; sp0 = <a href="http://cpprefjp.github.io/reference/memory/make_shared.html">std::make_shared</a>&lt;int&gt;(5);
  <a href="http://cpprefjp.github.io/reference/memory/unique_ptr.html">std::unique_ptr</a>&lt;int&gt; up0(new int(2));

  std::thread thd( func, i1,  std::ref(i2), sp0, std::move(up0) );
  // ...
  thd.join();

  assert(i1 == 0 &amp;&amp; i2 == 42);

  return 0;
}<span style="color: #000">#include &lt;memory&gt;
#include &lt;thread&gt;
#include &lt;cassert&gt;

int func(int v, int&amp; ri, </span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000"></span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang</a>: </li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC</a>:</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++0x mode</a>: 4.6.3, 4.7.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#icc">ICC</a>:</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>:</li>
</ul>
<h2>参照</h2>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/thread/thread/thread.md" target="_blank">編集</a></footer>