<h1>scoped_allocator_adaptor (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  template &lt;class OuterAlloc, class... InnerAllocs&gt;
  class scoped_allocator_adaptor : public OuterAlloc;
}</span></code></pre>
</p>
<h2>概要</h2>
<p><code><span style="color: #000">scoped_allocator_adaptor</span></code>は、<a href="http://cpprefjp.github.io/reference/vector.html"><code><span style="color: #000">vector</span></code></a><code><span style="color: #000">&lt;</span></code><a href="http://cpprefjp.github.io/reference/string/basic_string.html"><code><span style="color: #000">string</span></code></a><code><span style="color: #000">&gt;</span></code>のように、メモリ確保を行う型が入れ子になっているような場合に、外側と内側でアロケータオブジェクトを共有するための、アロケータクラスのアダプタである。</p>
<p>以下は、このアダプタクラスを使用することによって変化する、コンテナのメモリイメージである。</p>
<p><img alt="" src="https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_01.png" /></p>
<p>図1 コンテナ、および各要素がそれぞれに別個のアロケータオブジェクトを持つ</p>
<p><img alt="" src="https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_03.png" /></p>
<p>図2 コンテナとその要素で、アロケータオブジェクトの状態を伝搬させる(例1)</p>
<p><img alt="" src="https://raw.github.com/cpprefjp/image/master/reference/scoped_allocator/scoped_allocator_adaptor/ScopedAllocatorModel_02.png" /></p>
<p>図3 全ての要素にアロケータオブジェクトの状態を伝搬させる(例2)</p>
<p>テンプレートパラメータは、以下を意味する：</p>
<ul>
<li><code><span style="color: #000">OuterAlloc</span></code> : 外側のアロケータ。(たとえばコンテナのアロケータ)</li>
<li><code><span style="color: #000">InnerAlloc...</span></code> : 内側のアロケータ。(たとえばコンテナの要素に対するアロケータ)</li>
</ul>
<h2>メンバ関数</h2>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/scoped_allocator_adaptor.html"><code><span style="color: #000">(constructor)</span></code></a></td>
<td>コンストラクタ</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">~scoped_allocator_adaptor() = default</span></code></td>
<td>デストラクタ</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/inner_allocator.html"><code><span style="color: #000">inner_allocator</span></code></a></td>
<td>内側のアロケータを取得する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/outer_allocator.html"><code><span style="color: #000">outer_allocator</span></code></a></td>
<td>外側のアロケータを取得する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/allocate.html"><code><span style="color: #000">allocate</span></code></a></td>
<td>メモリを確保する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/deallocate.html"><code><span style="color: #000">deallocate</span></code></a></td>
<td>メモリを解放する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/max_size.html"><code><span style="color: #000">max_size</span></code></a></td>
<td>一度に確保可能なメモリの最大サイズを取得する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/construct.html"><code><span style="color: #000">construct</span></code></a></td>
<td>オブジェクトを構築する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/destroy.html"><code><span style="color: #000">destroy</span></code></a></td>
<td>オブジェクトを破棄する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/select_on_container_copy_construction.html"><code><span style="color: #000">select_on_container_copy_construction</span></code></a></td>
<td>コンテナのコピー構築に必要なアロケータを取得する</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h2>メンバ型</h2>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">outer_allocator_type</span></code></td>
<td>外側のアロケータ<code><span style="color: #000">OuterAlloc</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">inner_allocator_type</span></code></td>
<td>内側のアロケータ。 <code><span style="color: #000">InnerAllocs</span></code>が空だったら<code><span style="color: #000">scoped_allocator_adaptor&lt;OuterAlloc&gt;</span></code>。空じゃなければ<code><span style="color: #000">scoped_allocator_adaptor&lt;InnerAllocs...&gt;</span></code>。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">value_type</span></code></td>
<td>要素型<code><span style="color: #000">allocator_traits&lt;OuterAlloc&gt;::value_type</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">size_type</span></code></td>
<td>要素数を表す符号なし整数型 <code><span style="color: #000">allocator_traits&lt;OuterAlloc&gt;::size_type</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">difference_type</span></code></td>
<td>ポインタの差を表す符号あり整数型<code><span style="color: #000">allocator_traits&lt;OuterAlloc&gt;::difference_type</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">pointer</span></code></td>
<td>要素のポインタ型<code><span style="color: #000">allocator_traits&lt;OuterAlloc&gt;::pointer</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">const_pointer</span></code></td>
<td>読み取り専用の要素のポインタ型 <code><span style="color: #000">allocator_traits&lt;OuterAlloc&gt;::const_pointer</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">void_pointer</span></code></td>
<td><code><span style="color: #000">void</span></code>ポインタ型 <code><span style="color: #000">allocator_traits&lt;OuterAlloc&gt;::void_pointer</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">const_void_pointer</span></code></td>
<td>読み取り専用の<code><span style="color: #000">void</span></code>ポインタ型 <code><span style="color: #000">allocator_traits&lt;OuterAlloc&gt;::const_void_pointer</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">propagate_on_container_copy_assignment</span></code></td>
<td>コンテナのコピー代入でアロケータを置き換えるかどうかを示す論理型。<br /> <code><span style="color: #000">OuterAlloc::propagate_on_container_copy_assignment</span></code>が存在する場合はその型が使用され、そうでなければ<a href="http://cpprefjp.github.io/reference/type_traits/integral_constant-true_type-false_type.html"><code><span style="color: #000">false_type</span></code></a>が使用される。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">propagate_on_container_move_assignment</span></code></td>
<td>コンテナのムーブ代入でアロケータを置き換えるかどうかを示す論理型。<br /> <code><span style="color: #000">OuterAlloc::propagate_on_container_move_assignment</span></code>が存在する場合はその型が使用され、そうでなければ<a href="http://cpprefjp.github.io/reference/type_traits/integral_constant-true_type-false_type.html"><code><span style="color: #000">false_type</span></code></a>が使用される。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">propagate_on_container_swap</span></code></td>
<td>コンテナの<code><span style="color: #000">swap</span></code>操作でアロケータを置き換えるかどうかを示す論理型。<br /> <code><span style="color: #000">OuterAlloc::propagate_on_container_swap</span></code>が存在する場合はその型が使用され、そうでなければ<a href="http://cpprefjp.github.io/reference/type_traits/integral_constant-true_type-false_type.html"><code><span style="color: #000">false_type</span></code></a>が使用される。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">rebind&lt;U&gt;</span></code></td>
<td>型<code><span style="color: #000">U</span></code>を確保するように再束縛する</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h2>非メンバ関数</h2>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/op_equal.html"><code><span style="color: #000">operator==</span></code></a></td>
<td>等値比較</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/scoped_allocator/scoped_allocator_adaptor/op_not_equal.html"><code><span style="color: #000">operator!=</span></code></a></td>
<td>非等値比較</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h2>例1 コンテナとその要素で、アロケータオブジェクトの状態を伝搬させる</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

#include &lt;scoped_allocator&gt;

// std::allocatorに状態変数を持たせただけのクラス
template &lt;class T&gt;
class MyAlloc : public std::allocator&lt;T&gt; {
  int state_; // 状態

  using BaseType = std::allocator&lt;T&gt;;
  template &lt;class&gt; friend class MyAlloc;
public:
  using BaseType::BaseType;

  MyAlloc(int state = 0)
    : state_(state) {}

  template &lt;class U&gt;
  MyAlloc(const MyAlloc&lt;U&gt;&amp; alloc)
    : state_(alloc.state_) {}

  int getState() const { return state_; }
};

template &lt;class T, class U&gt;
bool operator==(const MyAlloc&lt;T&gt;&amp;, const MyAlloc&lt;U&gt;&amp;)
{ return true; }

template &lt;class T, class U&gt;
bool operator!=(const MyAlloc&lt;T&gt;&amp;, const MyAlloc&lt;U&gt;&amp;)
{ return false; }

template &lt;class T&gt;
using alloc = MyAlloc&lt;T&gt;;

// コンテナの要素(Inner)
using string = std::basic_string&lt;
  char,
  std::char_traits&lt;char&gt;,
  alloc&lt;char&gt;
&gt;;

// コンテナ(Outer)
template &lt;class T&gt;
using vector = std::vector&lt;
  T,
  std::scoped_allocator_adaptor&lt;alloc&lt;T&gt;&gt;
&gt;;

int main()
{
  // stringで使用するアロケータオブジェクトを、
  // vectorでも使用する
  int state = 5;
  MyAlloc&lt;string&gt; alloc(state);
  vector&lt;string&gt; v(alloc);

  v.push_back("hello");
  v.push_back("world");

  // 同じアロケータオブジェクトが使われていることを確認する。
  // getState()の値が、どちらも5になる。
  std::cout &lt;&lt; v.get_allocator().getState() &lt;&lt; std::endl;
  std::cout &lt;&lt; v.front().get_allocator().getState() &lt;&lt; std::endl;
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">5
5
</span></code></pre></p>
<h2>例2 全ての要素にアロケータオブジェクトの状態を伝搬させる</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

#include &lt;scoped_allocator&gt;

// std::allocatorに状態変数を持たせただけのクラス
template &lt;class T&gt;
class MyAlloc : public std::allocator&lt;T&gt; {
  int state_; // 状態

  using BaseType = std::allocator&lt;T&gt;;
  template &lt;class&gt; friend class MyAlloc;
public:
  using BaseType::BaseType;

  MyAlloc(int state = 0)
    : state_(state) {}

  template &lt;class U&gt;
  MyAlloc(const MyAlloc&lt;U&gt;&amp; alloc)
    : state_(alloc.state_) {}

  int getState() const { return state_; }
};

template &lt;class T, class U&gt;
bool operator==(const MyAlloc&lt;T&gt;&amp;, const MyAlloc&lt;U&gt;&amp;)
{ return true; }

template &lt;class T, class U&gt;
bool operator!=(const MyAlloc&lt;T&gt;&amp;, const MyAlloc&lt;U&gt;&amp;)
{ return false; }

template &lt;class T&gt;
using alloc_t = MyAlloc&lt;T&gt;;

// コンテナの要素(Inner)
using string = std::basic_string&lt;
  char,
  std::char_traits&lt;char&gt;,
  alloc_t&lt;char&gt;
&gt;;

// コンテナ(Outer)
template &lt;class T&gt;
using vector = std::vector&lt;
  T,
  std::scoped_allocator_adaptor&lt;alloc_t&lt;T&gt;, alloc_t&lt;typename T::value_type&gt;&gt;
&gt;;

int main()
{
  int outer_state = 5;
  int inner_state = 2;
  vector&lt;string&gt;::allocator_type alloc {
    alloc_t&lt;string&gt;(outer_state), // vector自体のアロケータオブジェクト
    alloc_t&lt;char&gt;(inner_state)    // vectorの全ての要素に使用するアロケータオブジェクト
  };
  vector&lt;string&gt; v(alloc);

  v.push_back("hello");
  v.push_back("world");

  // コンテナに使用されるアロケータの状態を確認
  // 5になる(outer_state)
  std::cout &lt;&lt; "container allocator : " &lt;&lt; v.get_allocator().getState() &lt;&lt; std::endl;

  // 要素に使用されるアロケータの状態を確認
  // 全ての要素に、アロケータの状態が伝搬される
  for (const string&amp; x : v) {
    std::cout &lt;&lt; "element allocator : " &lt;&lt; x.get_allocator().getState() &lt;&lt; std::endl;
  }
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">container allocator : 5
element allocator : 2
element allocator : 2
</span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang, C++11 mode</a>: 3.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++11 mode</a>: (4.8時点でサポートされてるはずだが、サンプルが動かない)</li>
<li><a href="http://cpprefjp.github.io/implementation.html#icc">ICC</a>: ??</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>: ??</li>
</ul>
<h3>参照</h3>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2554.pdf" target="_blank">N2554 The Scoped Allocator Model (Rev 2)</a></li>
<li><a href="http://www32.ocn.ne.jp/~ons/text/CPP0xFAQ.html.ja#scoped-allocator" target="_blank">スコープ付きアロケータ - C++11 FAQ</a></li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/scoped_allocator/scoped_allocator_adaptor.md" target="_blank">編集</a></footer>