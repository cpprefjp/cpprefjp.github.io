<h1>inner_allocator (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">inner_allocator_type&amp; inner_allocator() noexcept;             // (1)
const inner_allocator_type&amp; inner_allocator() const noexcept; // (2)</span></code></pre>
</p>
<h2>概要</h2>
<p>内側のアロケータを取得する。</p>
<h2>戻り値</h2>
<p>内側のアロケータオブジェクトを返す。</p>
<p>このクラスのテンプレートパラメータ<code><span style="color: #000">InnerAlloc...</span></code>が空の場合は、外側と同じアロケータを内側でも使用するものと見なし、<code><span style="color: #000">*this</span></code>を返す。</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

#include &lt;scoped_allocator&gt;

// std::allocatorに状態変数を持たせただけのクラス
template &lt;class T&gt;
class MyAlloc : public std::allocator&lt;T&gt; {
  int state_; // 状態

  using BaseType = std::allocator&lt;T&gt;;
  template &lt;class&gt; friend class MyAlloc;
public:
  using BaseType::BaseType;

  MyAlloc(int state = 0)
    : state_(state) {}

  template &lt;class U&gt;
  MyAlloc(const MyAlloc&lt;U&gt;&amp; alloc)
    : state_(alloc.state_) {}

  int getState() const { return state_; }
};

template &lt;class T, class U&gt;
bool operator==(const MyAlloc&lt;T&gt;&amp;, const MyAlloc&lt;U&gt;&amp;)
{ return true; }

template &lt;class T, class U&gt;
bool operator!=(const MyAlloc&lt;T&gt;&amp;, const MyAlloc&lt;U&gt;&amp;)
{ return false; }

template &lt;class T&gt;
using alloc_t = MyAlloc&lt;T&gt;;

// コンテナの要素(Inner)
using string = std::basic_string&lt;
  char,
  std::char_traits&lt;char&gt;,
  alloc_t&lt;char&gt;
&gt;;

// コンテナ(Outer)
template &lt;class T&gt;
using vector = std::vector&lt;
  T,
  std::scoped_allocator_adaptor&lt;alloc_t&lt;T&gt;, alloc_t&lt;typename T::value_type&gt;&gt;
&gt;;

int main()
{
  int outer_state = 5;
  int inner_state = 2;
  vector&lt;string&gt;::allocator_type alloc {
    alloc_t&lt;string&gt;(outer_state), // vector自体のアロケータオブジェクト
    alloc_t&lt;char&gt;(inner_state)    // vectorの全ての要素に使用するアロケータオブジェクト
  };

  // 内側(vectorの全ての要素)のアロケータオブジェクトを取得
  alloc_t&lt;char&gt; inner_alloc = alloc.inner_allocator();
  std::cout &lt;&lt; inner_alloc.getState() &lt;&lt; std::endl;
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">2
</span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang, C++11 mode</a>: 3.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++11 mode</a>: 4.7.3</li>
<li><a href="http://cpprefjp.github.io/implementation.html#icc">ICC</a>: ??</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a> ??</li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/scoped_allocator/scoped_allocator_adaptor/inner_allocator.md" target="_blank">編集</a></footer>