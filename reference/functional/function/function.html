<h1>コンストラクタ (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><a href="http://cpprefjp.github.io/reference/cstddef/nullptr_t.html">nullptr_t</a>) noexcept; // (2)
function(const function&amp; f);  // (3)
function(function&amp;&amp; f);       // (4)

template &lt;class F&gt;
function(F f);                // (5)

template &lt;class Alloc&gt;
function(<a href="http://cpprefjp.github.io/reference/memory/allocator_arg_t.html">allocator_arg_t</a>, const Alloc&amp; alloc) noexcept;            // (6)

template &lt;class Alloc&gt;
function(<a href="http://cpprefjp.github.io/reference/memory/allocator_arg_t.html">allocator_arg_t</a>, const Alloc&amp; alloc, <a href="http://cpprefjp.github.io/reference/cstddef/nullptr_t.html">nullptr_t</a>) noexcept; // (7)

template &lt;class Alloc&gt;
function(<a href="http://cpprefjp.github.io/reference/memory/allocator_arg_t.html">allocator_arg_t</a>, const Alloc&amp; alloc, const function&amp; f);  // (8)

template &lt;class Alloc&gt;
function(<a href="http://cpprefjp.github.io/reference/memory/allocator_arg_t.html">allocator_arg_t</a>, const Alloc&amp; alloc, function&amp;&amp; f);       // (9)

template &lt;class F, class Alloc&gt;
function(<a href="http://cpprefjp.github.io/reference/memory/allocator_arg_t.html">allocator_arg_t</a>, const Alloc&amp; alloc, F f);                // (10)<span style="color: #000">function() noexcept;          // (1)
function(</span></code></pre>
</p>
<h2>要件</h2>
<ul>
<li>(5), (10) : <code><span style="color: #000">F</span></code>はコピー構築可能であること。<code><span style="color: #000">F</span></code>は、パラメータとして<code><span style="color: #000">ArgTypes...</span></code>型をとり、戻り値として<code><span style="color: #000">R</span></code>型を返す関数ポインタ、メンバ関数ポインタ、メンバ変数ポインタ、または関数オブジェクトであること。また、そのコピーコンストラクタとデストラクタは、例外を投げるべきではない。</li>
</ul>
<h2>効果</h2>
<ul>
<li>(1), (2) : 関数を持たない空の<code><span style="color: #000">function</span></code>オブジェクトを構築する。この方法で構築した後、<a href="http://cpprefjp.github.io/reference/functional/function/op_bool"><code><span style="color: #000">operator bool</span></code></a>は<code><span style="color: #000">false</span></code>を返す。</li>
<li>(3) : <code><span style="color: #000">f</span></code>が保持する関数、または関数オブジェクトをコピーする。</li>
<li>(4) : <code><span style="color: #000">f</span></code>が保持する状態を<code><span style="color: #000">*this</span></code>に移動する。移動された後の<code><span style="color: #000">f</span></code>は、未規定な値を持つ有効な状態となる。</li>
<li>(5) : <code><span style="color: #000">f</span></code>がヌルの関数ポインタ、もしくはメンバポインタである場合、構築後の<a href="http://cpprefjp.github.io/reference/functional/function/op_bool"><code><span style="color: #000">operator bool</span></code></a>は<code><span style="color: #000">false</span></code>を返す。<code><span style="color: #000">f</span></code>が有効な関数ポインタ、メンバポインタ、もしくは関数オブジェクトである場合は、<code><span style="color: #000">f</span></code>が持つターゲットを<code><span style="color: #000">*this</span></code>に移動する。</li>
<li>(6), (7) : アロケータを設定し、関数を持たない空の<code><span style="color: #000">function</span></code>オブジェクトを構築する。この方法で構築した後、<a href="http://cpprefjp.github.io/reference/functional/function/op_bool"><code><span style="color: #000">operator bool</span></code></a>は<code><span style="color: #000">false</span></code>を返す。</li>
<li>(9) : アロケータを設定し、<code><span style="color: #000">f</span></code>が保持する状態を<code><span style="color: #000">*this</span></code>に移動する。移動された後の<code><span style="color: #000">f</span></code>は、未規定な値を持つ有効な状態となる。</li>
<li>(10) : アロケータを設定する。<code><span style="color: #000">f</span></code>がヌルの関数ポインタ、もしくはメンバポインタである場合、構築後の<a href="http://cpprefjp.github.io/reference/functional/function/op_bool"><code><span style="color: #000">operator bool</span></code></a>は<code><span style="color: #000">false</span></code>を返す。<code><span style="color: #000">f</span></code>が有効な関数ポインタ、メンバポインタ、もしくは関数オブジェクトである場合は、<code><span style="color: #000">f</span></code>が持つターゲットを<code><span style="color: #000">*this</span></code>に移動する。</li>
</ul>
<h2>例外</h2>
<ul>
<li>(3), (8) : <code><span style="color: #000">f</span></code>が<a href="http://cpprefjp.github.io/reference/functional/reference_wrapper.html"><code><span style="color: #000">reference_wrapper</span></code></a>か関数ポインタを保持している場合は、例外を投げるべきではない。<code><span style="color: #000">f</span></code>が関数オブジェクトを保持している場合は、そのコピーコンストラクタが<a href="http://cpprefjp.github.io/reference/new/bad_alloc.html"><code><span style="color: #000">bad_alloc</span></code></a>やその他の例外を投げる可能性がある。</li>
<li>(10) : <code><span style="color: #000">f</span></code>が<a href="http://cpprefjp.github.io/reference/functional/reference_wrapper.html"><code><span style="color: #000">reference_wrapper</span></code></a>か関数ポインタを保持している場合は、例外を投げるべきではない。<code><span style="color: #000">f</span></code>が関数オブジェクトを保持している場合は、そのコピーコンストラクタもしくはムーブコンストラクタが<a href="http://cpprefjp.github.io/reference/new/bad_alloc.html"><code><span style="color: #000">bad_alloc</span></code></a>やその他の例外を投げる可能性がある。</li>
</ul>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

struct ident_functor {
  int operator()(int x) const
  { return x; }
};

int ident_func(int x)
{ return x; }

struct X {
  int value;
  X() : value(3) {}

  int ident_member_func(int x) const
  { return x; }
};

int main()
{
  // (1)
  // デフォルトコンストラクタ
  // 空のfunctionオブジェクトを作る
  {
    std::function&lt;int(int)&gt; f;
    assert(!f);
  }

  // (2)
  // ヌルポインタを受け取るコンストラクタ
  // デフォルトコンストラクタと同様、空のfunctionオブジェクトを作る
  {
    std::function&lt;int(int)&gt; f = nullptr;
    assert(!f);
  }

  // (3)
  // コピー構築
  {
    std::function&lt;int(int)&gt; f = ident_functor();
    std::function&lt;int(int)&gt; g = f;

    int result = g(1);
    std::cout &lt;&lt; "(3) : " &lt;&lt; result &lt;&lt; std::endl;
  }

  // (4)
  // ムーブ構築
  {
    std::function&lt;int(int)&gt; f = ident_functor();
    std::function&lt;int(int)&gt; g = std::move(f);

    int result = g(1);
    std::cout &lt;&lt; "(4) : " &lt;&lt; result &lt;&lt; std::endl;
  }

  // (5)
  // 関数ポインタを受け取って構築
  {
    std::function&lt;int(int)&gt; f = ident_func;

    int result = f(1);
    std::cout &lt;&lt; "(5) function pointer : " &lt;&lt; result &lt;&lt; std::endl;
  }

  // (5)
  // 関数オブジェクトを受け取って構築
  {
    std::function&lt;int(int)&gt; f = ident_functor();

    int result = f(1);
    std::cout &lt;&lt; "(5) function object : " &lt;&lt; result &lt;&lt; std::endl;
  }

  // (5)
  // メンバ関数ポインタを受け取った構築
  {
    std::function&lt;int(const X&amp;, int)&gt; f = &amp;X::ident_member_func;

    X x;
    int result = f(x, 1);
    std::cout &lt;&lt; "(5) member function pointer : " &lt;&lt; result &lt;&lt; std::endl;
  }

  // (5)
  // メンバ変数ポインタを受け取った構築
  {
    std::function&lt;int(const X&amp;)&gt; f = &amp;X::value;

    X x;
    int result = f(x);
    std::cout &lt;&lt; "(5) member variable pointer : " &lt;&lt; result &lt;&lt; std::endl;
  }

  // (6)
  // アロケータを受け取って空のfunctionオブジェクトを構築
  {
    // ※ここではint型を対象とするアロケータを渡しているが、内部で適切な関数の型にrebindして使われる。
    std::function&lt;int(int)&gt; f(std::allocator_arg, std::allocator&lt;int&gt;());
    assert(!f);
  }

  // (7)
  // アロケータとヌルポインタを受け取って、空のfunctionオブジェクトを構築
  {
    std::function&lt;int(int)&gt; f(std::allocator_arg, std::allocator&lt;int&gt;(), nullptr);
    assert(!f);
  }

  // (8)
  // アロケータを受け取り、functionオブジェクトをコピー構築
  {
    std::function&lt;int(int)&gt; f = ident_functor();
    std::function&lt;int(int)&gt; g(std::allocator_arg, std::allocator&lt;int&gt;(), f);

    int result = g(1);
    std::cout &lt;&lt; "(8) : " &lt;&lt; result &lt;&lt; std::endl;
  }

  // (9)
  // アロケータを受け取り、functionオブジェクトをムーブ構築
  {
    std::function&lt;int(int)&gt; f = ident_functor();
    std::function&lt;int(int)&gt; g(std::allocator_arg, std::allocator&lt;int&gt;(), std::move(f));

    int result = g(1);
    std::cout &lt;&lt; "(9) : " &lt;&lt; result &lt;&lt; std::endl;
  }

  // (10)
  // 関数ポインタ、関数オブジェクト、メンバポインタのいずれかを受け取った構築
  {
    std::function&lt;int(int)&gt; f(std::allocator_arg, std::allocator&lt;int&gt;(), ident_functor());

    int result = f(1);
    std::cout &lt;&lt; "(10) : " &lt;&lt; result &lt;&lt; std::endl;
  }
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">(3) : 1
(4) : 1
(5) function pointer : 1
(5) function object : 1
(5) member function pointer : 1
(5) member variable pointer : 3
(8) : 1
(9) : 1
(10) : 1
</span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang, C++11 mode</a>: 3.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++11 mode</a>: 4.3.6(アロケータを受け取るバージョンは、4.8.2時点でサポートされていない)</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>: ??</li>
</ul>
<h2>参照</h2>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/functional/function/function.md" target="_blank">編集</a></footer>