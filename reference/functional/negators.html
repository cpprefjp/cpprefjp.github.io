<h1>論理反転関数オブジェクト</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  template &lt;typename Pred&gt;
  struct unary_negate {
    explicit unary_negate(const Pred &amp;pred);
    bool operator()(const typename Pred::argument_type &amp;x) const;
    typedef typename Pred::argument_type argument_type;
    typedef bool result_type;
  };

  template &lt;typename Pred&gt;
  unary_negate&lt;Pred&gt; not1(const Pred &amp;pred);

  template &lt;typename Pred&gt;
  struct binary_negate {
    explicit binary_negate(const Pred &amp;pred);
    bool operator()(const typename Pred::first_argument_type &amp;x, const typename Pred::second_argument_type &amp;y) const;
    typedef typename Pred::first_argument_type first_argument_type;
    typedef typename Pred::second_argument_type second_argument_type;
    typedef bool result_type;
  };

  template &lt;typename Pred&gt;
  binary_negate&lt;Pred&gt; not2(const Pred &amp;pred);
}</span></code></pre>
</p>
<h2>概要</h2>
<p>述語関数オブジェクトの結果を反転する関数オブジェクトアダプタ。<code><span style="color: #000">unary_negate</span></code> は1引数述語用、 <code><span style="color: #000">binary_negate</span></code> は2引数述語用。</p>
<p>テンプレート引数 <code><span style="color: #000">Pred</span></code> に対する要求
- <code><span style="color: #000">unary_negate</span></code>の場合
- 型<code><span style="color: #000">Pred</span></code>に<code><span style="color: #000">argument_type</span></code>という nested typedef が存在すること
- 型<code><span style="color: #000">Pred</span></code>への<code><span style="color: #000">const</span></code>参照<code><span style="color: #000">pred</span></code>に対して、式 <code><span style="color: #000">(bool)pred(x)</span></code> が有効であること。ただし <code><span style="color: #000">x</span></code> は <code><span style="color: #000">argument_type</span></code> への <code><span style="color: #000">const</span></code> 参照。
- <code><span style="color: #000">binary_negate</span></code>の場合
- 型<code><span style="color: #000">Pred</span></code>に<code><span style="color: #000">first_argument_type</span></code>、<code><span style="color: #000">second_argument_type</span></code>という nested typedef が存在すること
- 型<code><span style="color: #000">Pred</span></code>への<code><span style="color: #000">const</span></code>参照<code><span style="color: #000">pred</span></code>に対して、式 <code><span style="color: #000">(bool)pred(x, y)</span></code> が有効であること。ただし <code><span style="color: #000">x</span></code> と <code><span style="color: #000">y</span></code> は、それぞれ <code><span style="color: #000">first_argument_type</span></code> と <code><span style="color: #000">second_argument_type</span></code> への <code><span style="color: #000">const</span></code> 参照。メンバ関数</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">unary_negate&lt;Pred&gt;::operator()</span></code></td>
<td><code><span style="color: #000">!pred(x)</span></code> と等価</td>
</tr>
<tr>
<td><code><span style="color: #000">binary_negate&lt;Pred&gt;::operator()</span></code></td>
<td><code><span style="color: #000">!pred(x, y)</span></code> と等価</td>
</tr>
</tbody>
</table>
<h3>メンバ型</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">argument_type</span></code></td>
<td>(<code><span style="color: #000">unary_negate</span></code>のみ) <code><span style="color: #000">typename Pred::argument_type</span></code> と等価</td>
</tr>
<tr>
<td><code><span style="color: #000">first_argument_type</span></code></td>
<td>(<code><span style="color: #000">binary_negate</span></code>のみ) <code><span style="color: #000">typename Pred::first_argument_type</span></code> と等価</td>
</tr>
<tr>
<td><code><span style="color: #000">second_argument_type</span></code></td>
<td>(<code><span style="color: #000">binary_negate</span></code>のみ) <code><span style="color: #000">typename Pred::second_argument_type</span></code> と等価<br /></td>
</tr>
<tr>
<td><code><span style="color: #000">result_type</span></code></td>
<td><code><span style="color: #000">bool</span></code></td>
</tr>
<tr>
<td>フリー関数</td>
<td></td>
</tr>
</tbody>
</table>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">not1(const Pred&amp; pred)</span></code></td>
<td><code><span style="color: #000">unary_negate&lt;Pred&gt;(pred)</span></code> を構築して返す</td>
</tr>
<tr>
<td><code><span style="color: #000">not2(const Pred&amp; pred)</span></code></td>
<td><code><span style="color: #000">binary_negate&lt;Pred&gt;(pred)</span></code> を構築して返す</td>
</tr>
</tbody>
</table>
<h3>例</h3>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{
  std::cout &lt;&lt; std::boolalpha &lt;&lt; std::not2(std::less&lt;int&gt;())(3, 5) &lt;&lt; std::endl;
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">false
</span></code></pre></p>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/functional/negators.md" target="_blank">編集</a></footer>