<h1>for_each</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  template &lt;class InputIterator, class Function&gt;
  Function for_each(InputIterator first,
                    InputIterator last,
                    Function f);
}</span></code></pre>
</p>
<h2>概要</h2>
<p>範囲の全ての要素に、指定された関数を適用する。</p>
<h2>要件</h2>
<p><code><span style="color: #000">Function</span></code> は <code><span style="color: #000">MoveConstructible</span></code> の要件を満たす必要があるが、<code><span style="color: #000">CopyConstructible</span></code> の要件を満たす必要はない。（C++11のみ）</p>
<h2>効果</h2>
<p><code><span style="color: #000">[first,last)</span></code> 内の全てのイテレータ <code><span style="color: #000">i</span></code> に <code><span style="color: #000">f(*i)</span></code> という操作を行う。<code><span style="color: #000">first</span></code> から順番に処理し、<code><span style="color: #000">last - 1</span></code> まで行う。</p>
<p>このアルゴリズムはその他のアルゴリズムと違い、<code><span style="color: #000">Function</span></code> の内部で <code><span style="color: #000">*i</span></code> の値を書き換えても構わない（もちろんイテレータの型が <code><span style="color: #000">mutable iterator</span></code> の要件を満たしている場合に限る）。</p>
<h2>戻り値</h2>
<ul>
<li>C++03 の場合 : <code><span style="color: #000">f</span></code></li>
<li>C++11 の場合 : <code><span style="color: #000">std::move(f)</span></code></li>
</ul>
<h2>計算量</h2>
<p>正確に <code><span style="color: #000">f</span></code> を <code><span style="color: #000">last - first</span></code> 回適用する</p>
<h2>備考</h2>
<p><code><span style="color: #000">f</span></code> に戻り値がある場合、それは単に無視される。</p>
<h2>例(C++03バージョン)</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">for_each</span>(v.begin(), v.end(), disp);

  std::cout &lt;&lt; "----" &lt;&lt; std::endl;

  // 要素の内容を書き換えても構わないし、呼び出し順序に依存した処理を書いても構わない
  std::<span style="color:#ff0000">for_each</span>(v.begin(), v.end(), mutate());
  std::<span style="color:#ff0000">for_each</span>(v.begin(), v.end(), disp);
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

void disp(int x) {
  std::cout &lt;&lt; x &lt;&lt; std::endl;
}

struct mutate {
  int n;
  mutate() : n(0) { }
  void operator()(int&amp; v) {
    v += n++;
  }
};

int main() {
  std::vector&lt;int&gt; v;

  v.push_back(3);
  v.push_back(1);
  v.push_back(4);

  // vの全ての要素にdisp()関数を適用する
  std::</span></code></pre>
</p>
<h2>例(C++11バージョン)</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">for_each</span>(v.begin(), v.end(), [](int x) { std::cout &lt;&lt; x &lt;&lt; std::endl; });

  std::cout &lt;&lt; "----" &lt;&lt; std::endl;

  // 要素の内容を書き換えても構わないし、呼び出し順序に依存した処理を書いても構わない
  int n = 0;
  std::<span style="color:#ff0000">for_each</span>(v.begin(), v.end(), [n](int&amp; x) mutable { x += n++; });
  std::<span style="color:#ff0000">for_each</span>(v.begin(), v.end(), [](int x) { std::cout &lt;&lt; x &lt;&lt; std::endl; });
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
  std::vector&lt;int&gt; v = { 3, 1, 4 };

  // vの全ての要素にラムダ式を適用する
  std::</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">3
1
4
----
3
2
6
</span></code></pre></p>
<h2>実装例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class InputIterator, class Function&gt;
Function for_each(InputIterator first, InputIterator last, Function f) {
  for ( ; first != last; ++first)
    f(*first);
  return move(f);
}</span></code></pre>
</p>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/algorithm/for_each.md" target="_blank">編集</a></footer>