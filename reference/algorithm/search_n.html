<h1>search_n</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  template&lt;class ForwardIterator, class Size, class T&gt;
  ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                           Size count, const T&amp; value);

  template&lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;
  ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                           Size count, const T&amp; value, BinaryPredicate pred);
}</span></code></pre>
</p>
<h2>概要</h2>
<p>あるシーケンスの中から、特定のサブシーケンスを探す。</p>
<h2>要件</h2>
<p><code><span style="color: #000">Size</span></code>は整数型に変換できる型である必要がある。</p>
<h2>戻り値</h2>
<p><code><span style="color: #000">[first,last-count)</span></code> 内のイテレータ <code><span style="color: #000">i</span></code> があるとき、0 以上 <code><span style="color: #000">count</span></code> 未満の整数 <code><span style="color: #000">n</span></code> について、それぞれ <code><span style="color: #000">*(i + n) == value</span></code> もしくは <code><span style="color: #000">pred(*(i + n),value) != false</span></code> であるようなサブシーケンスを探し、見つかった最初のサブシーケンスの先頭のイテレータを返す。</p>
<p>そのようなイテレータが見つからない場合は <code><span style="color: #000">last</span></code> を返す。</p>
<h2>計算量</h2>
<p>最大で <code><span style="color: #000">last - first</span></code> 回の対応する比較もしくは述語が適用される。</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">search_n</span>(v.cbegin(), v.cend(), 2, 3);
  // v[5] の位置を指すイテレータが見つかる。
  if (it1 == v.cend()) {
    std::cout &lt;&lt; "not found" &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "found: index==" &lt;&lt; std::distance(v.cbegin(), it1) &lt;&lt; std::endl;
  }

  // 3 未満が 2 つ連続している最初のシーケンスを探す
  auto it2 = std::<span style="color:#ff0000">search_n</span>(v.cbegin(), v.cend(), 2, 3, [](int x, int y) { return x &lt; y; });
  // v[0] の位置を指すイテレータが見つかる。
  if (it2 == v.cend()) {
    std::cout &lt;&lt; "not found" &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "found: index==" &lt;&lt; std::distance(v.cbegin(), it2) &lt;&lt; std::endl;
  }
}<span style="color: #000">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v = { 1,2,3,2,1,3,3,2,3,3,1 };

  // 3 が 2 つ連続している最初のシーケンスを探す
  auto it1 = std::</span></code></pre>
</p>
<h3>出力</h3>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">found: index==5
found: index==0</span></code></pre>
</p>
<h2>実装例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class ForwardIterator, class Size, class T&gt;
ForwardIterator search_n(ForwardIterator first, ForwardIterator last, Size count, T const&amp; value)
{
  if (first == last || count &lt;= 0)
    return first;

  while (first != last) {
    if (*first == value) {
      ForwardIterator it = first;
      ++it;
      Size i = 1;
      for (; i &lt; count &amp;&amp; it != last &amp;&amp; *it == value; ++i, ++it)
        ;
      if (i == count)
        return first;
      else if (it == last)
        return last;
      else
        first = it;
    }
    ++first;
  }
  return last;
}

template &lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;
ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                         Size count, T const&amp; value, BinaryPredicate pred)
{
  if (first == last || count &lt;= 0)
    return first;

  while (first != last) {
    if (pred(*first, value)) {
      ForwardIterator it = first;
      ++it;
      Size i = 1;
      for (; i &lt; count &amp;&amp; it != last &amp;&amp; pred(*it, value); ++i, ++it)
        ;
      if (i == count)
        return first;
      else if (it == last)
        return last;
      else
        first = it;
    }
    ++first;
  }
  return last;
}</span></code></pre>
</p>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/algorithm/search_n.md" target="_blank">編集</a></footer>