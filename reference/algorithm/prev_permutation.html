<h1>prev_permutation</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  template &lt;class BidirectionalIterator&gt;
  bool prev_permutation(BidirectionalIterator first,
                        BidirectionalIterator last);

  template &lt;class BidirectionalIterator, class Compare&gt;
  bool prev_permutation(BidirectionalIterator first,
                        BidirectionalIterator last, Compare comp);

}</span></code></pre>
</p>
<h2>概要</h2>
<p>前の順列を生成する。</p>
<h2>要件</h2>
<p><code><span style="color: #000">BidriectionalIterator</span></code>が<code><span style="color: #000">ValueSwappable</span></code>の要件を満たしていること。</p>
<h2>効果</h2>
<p><code><span style="color: #000">[first, last)</span></code>の範囲を前の順列に変換する。</p>
<p><code><span style="color: #000">operator&lt;</span></code>または<code><span style="color: #000">comp</span></code>によって辞書順に並んでいる全ての順列の集合があると仮定すると、前の順列が発見される。</p>
<h2>戻り値</h2>
<p>前の順列が存在する場合は<code><span style="color: #000">true</span></code>を返し、そうでなければ<code><span style="color: #000">false</span></code>を返す。</p>
<h2>計算量</h2>
<p>高々<code><span style="color: #000">(last - first)/2</span></code>回の要素の交換</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">prev_permutation</span>(v.begin(), v.end()));
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

void print(const std::vector&lt;int&gt;&amp; v)
{
  std::for_each(v.begin(), v.end(), [](int x) {
    std::cout &lt;&lt; x &lt;&lt; " ";
  });
  std::cout &lt;&lt; std::endl;
}

int main ()
{
  std::vector&lt;int&gt; v = {3, 2, 1};

  do {
    print(v);
  } while (std::</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">3 2 1 
3 1 2 
2 3 1 
2 1 3 
1 3 2 
1 2 3 
</span></code></pre></p>
<h2>実装例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class BidirectionalIterator, class Compare&gt;
bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp)
{
  if (first == last)
    return false;

  BidirectionalIterator i = first;
  ++i;

  if (i == last)
    return false;

  i = last;
  --i;

  for(;;) {
    BidirectionalIterator ii = i;
    --i;
    if (comp(*ii, *i)) {
      BidirectionalIterator j = last;
      while (!comp(*--j, *i)) {}

      std::swap(*i, *j);
      std::reverse(ii, last);
      return true;
    }
    if (i == first) {
      std::reverse(first, last);
      return false;
    }
  }
}

template &lt;class BidirectionalIterator&gt;
bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last)
{
  typedef
    typename std::iterator_traits&lt;BidirectionalIterator&gt;::value_type
  value_type;

  return prev_permutation(first, last, std::less&lt;value_type&gt;());
}</span></code></pre>
</p>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/algorithm/prev_permutation.md" target="_blank">編集</a></footer>