<h1>is_modulo</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">// C++03
static const bool is_modulo;

// C++11
static constexpr bool is_modulo;</span></code></pre>
</p>
<h2>概要</h2>
<p>加算 (<code><span style="color: #000">+</span></code>) ・減算 (<code><span style="color: #000">-</span></code>) ・乗算 (<code><span style="color: #000">*</span></code>) における数学的な値と、その型での値との間に (<code><span style="color: #000">max() - min() + 1</span></code>) を法として常に合同関係があるかを判定する。<br />
符号なし整数型の場合は常に<code><span style="color: #000">true</span></code>となる。<br />
多くの場合浮動小数点数型の場合は<code><span style="color: #000">false</span></code>に、符号あり整数型の場合は<code><span style="color: #000">true</span></code>になる。</p>
<h2>備考</h2>
<p>符号あり整数型において<code><span style="color: #000">is_modulo</span></code>が<code><span style="color: #000">true</span></code>であるとしても、符号あり整数型のオーバーフローは未定義の動作を起こす。</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">is_modulo</span>;
  constexpr bool b = std::numeric_limits&lt;float&gt;::<span style="color:#ff0000">is_modulo</span>;
  constexpr bool c = std::numeric_limits&lt;double&gt;::<span style="color:#ff0000">is_modulo</span>;
  constexpr bool d = std::numeric_limits&lt;char&gt;::<span style="color:#ff0000">is_modulo</span>;

  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "int : " &lt;&lt; a &lt;&lt; std::endl;
  std::cout &lt;&lt; "float : " &lt;&lt; b &lt;&lt; std::endl;
  std::cout &lt;&lt; "double : " &lt;&lt; c &lt;&lt; std::endl;
  std::cout &lt;&lt; "char : " &lt;&lt; d &lt;&lt; std::endl;
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;limits&gt;

int main()
{
  constexpr bool a = std::numeric_limits&lt;int&gt;::</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">int : true
float : false
double : false
char : true
</span></code></pre></p>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/limits/numeric_limits/is_modulo.md" target="_blank">編集</a></footer>