<h1>algorithm</h1>
<p>全てのアルゴリズムはデータ構造の実装の詳細から切り離されていて、イテレータによってパラメータ化されている。これはアルゴリズムの要件を満たすイテレータを提供しているなら、どのようなデータ構造であっても動作するということを示している。</p>
<p>関数オブジェクトを使用するアルゴリズムでは、<code><span style="color: #000">for_each</span></code>以外、引数として渡されたオブジェクトを書き換えてはならない。</p>
<p>ここでは、各アルゴリズムのテンプレートパラメータ名を、型の要件を表すために使っている。アルゴリズムを正しく利用するためには、テンプレートパラメータ名に応じたこれらの要件を満たしている必要がある。以下の通りである。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>テンプレートパラメータ名</th>
<th>要件</th>
</tr>
</thead>
<tbody>
<tr>
<td>InputIterator<br /> InputIterator1<br /> InputIterator2</td>
<td>input iterator</td>
</tr>
<tr>
<td>OutputIterator<br /> OutputIterator1<br /> OutputIterator2</td>
<td>output iterator</td>
</tr>
<tr>
<td>ForwardIterator<br /> ForwardIterator1<br /> ForwardIterator2</td>
<td>forward iterator</td>
</tr>
<tr>
<td>BidirectionalIterator<br /> BidirectionalIterator1<br /> BidirectionalIterator2</td>
<td>bidirectional iterator</td>
</tr>
<tr>
<td>RandomAccessIterator<br /> RandomAccessIterator1<br /> RandomAccessIterator2</td>
<td>random-access iterator</td>
</tr>
</tbody>
</table>
<p>もし「効果」のセクションで、イテレータの値を書き換えるという旨の文章が書かれている場合、その引数の型は mutable iterator の要件を満たしていなければならないという追加の要件がある。
もちろん、output iterator は常に書き換え可能であるため、この追加の要件は無意味である。</p>
<p>いくつかのアルゴリズムは <code><span style="color: #000">_copy</span></code> というサフィックスが付いている。これは <code><span style="color: #000">_copy</span></code> サフィックスの付いていないアルゴリズムと違い、処理の結果を別のイテレータへ出力するアルゴリズムである。コピーバージョンを含めるかどうかの判断は、通常バージョンの計算量を考慮する。操作を行うコストがコピーのコストを大きく上回る場合、コピーバージョンは含めないようになっている。例えば <code><span style="color: #000">sort_copy</span></code> は存在しない。なぜなら、ソートのコストは大きいし、そのような場合、ユーザは <code><span style="color: #000">copy</span></code> してから <code><span style="color: #000">sort</span></code> するからだ。</p>
<p>テンプレートパラメータ名が <code><span style="color: #000">Predicate</span></code> となっている場合、<code><span style="color: #000">Predicate</span></code> の値 <code><span style="color: #000">pred</span></code> と、引数として渡すイテレータ <code><span style="color: #000">i</span></code> について以下の要件を満たす必要がある</p>
<ul>
<li><code><span style="color: #000">pred(*i)</span></code> が <code><span style="color: #000">bool</span></code> として評価できなければならない。</li>
<li><code><span style="color: #000">pred(*i)</span></code> 内で <code><span style="color: #000">*i</span></code> を書き変えてはならない。</li>
</ul>
<p>テンプレートパラメータ名が <code><span style="color: #000">BinaryPredicate</span></code> となっている場合、<code><span style="color: #000">BinaryPredicate</span></code> の値 <code><span style="color: #000">binary_pred</span></code> と、引数として渡すイテレータ <code><span style="color: #000">i1</span></code>, <code><span style="color: #000">i2</span></code> について以下の要件を満たす必要がある</p>
<ul>
<li><code><span style="color: #000">binary_pred(*i1, *i2)</span></code> が <code><span style="color: #000">bool</span></code> として評価できなければならない。</li>
<li><code><span style="color: #000">binary_pred(*i1, *i2)</span></code> 内で <code><span style="color: #000">*i1</span></code> や <code><span style="color: #000">*i2</span></code> を書き変えてはならない。</li>
</ul>
<p>関数オブジェクトを引数に取る <code><span style="color: #000">for_each</span></code> 以外のアルゴリズムは、その関数オブジェクトを自由にコピーしても構わない。そのため、アルゴリズムの利用者はそのことに注意する必要がある。コピーされてしまうことが問題である場合、<code><span style="color: #000">reference_wrapper&lt;T&gt;</span></code> や同様の解決手段を使ってオブジェクトの中身をコピーしないようなラッパークラスを使うといった対策を行う必要がある。</p>
<p>アルゴリズムの説明で <code><span style="color: #000">+</span></code> や <code><span style="color: #000">-</span></code> を使っているが、random-access iterator 以外のイテレータはそれを定義していない。そういった場合、 <code><span style="color: #000">a+n</span></code> というのは</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">X tmp = a;
advance(tmp, n);
return tmp;</span></code></pre>

を意味する。また、<code><span style="color: #000">b-a</span></code> は</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">return distance(a, b);</span></code></pre>

を意味する。</p>
<h2>シーケンスを変更しない操作</h2>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/all_of.html"><code><span style="color: #000">all_of</span></code></a></td>
<td>全ての要素が条件を満たしているかを調べる</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/any_of.html"><code><span style="color: #000">any_of</span></code></a></td>
<td>どれかの要素が条件を満たしているかを調べる</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/none_of.html"><code><span style="color: #000">none_of</span></code></a></td>
<td>全ての要素が条件を満たしていないかを調べる</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/for_each.html"><code><span style="color: #000">for_each</span></code></a></td>
<td>全ての要素に対して処理を行う</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/find.html"><code><span style="color: #000">find</span></code></a></td>
<td>指定された値を検索する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/find_if.html"><code><span style="color: #000">find_if</span></code></a></td>
<td>条件を満たす最初の要素を検索する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/find_if_not.html"><code><span style="color: #000">find_if_not</span></code></a></td>
<td>条件を満たしていない最初の要素を検索する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/find_end.html"><code><span style="color: #000">find_end</span></code></a></td>
<td>指定された最後のサブシーケンスを検索する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/find_first_of.html"><code><span style="color: #000">find_first_of</span></code></a></td>
<td>ある集合の1つとマッチする最初の要素を検索する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/adjacent_find.html"><code><span style="color: #000">adjacent_find</span></code></a></td>
<td>隣接する要素で条件を満たしている最初の要素を検索する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/count.html"><code><span style="color: #000">count</span></code></a></td>
<td>指定された値である要素の数を数える</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/count_if.html"><code><span style="color: #000">count_if</span></code></a></td>
<td>条件を満たしている要素の数を数える</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/mismatch.html"><code><span style="color: #000">mismatch</span></code></a></td>
<td>2つの範囲が一致していない場所を検索する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/equal.html"><code><span style="color: #000">equal</span></code></a></td>
<td>2つの範囲を等値比較する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/search.html"><code><span style="color: #000">search</span></code></a></td>
<td>指定された最初のサブシーケンスを検索する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/search_n.html"><code><span style="color: #000">search_n</span></code></a></td>
<td>指定された最初のサブシーケンスを検索する</td>
<td></td>
</tr>
</tbody>
</table>
<h2>シーケンスを変更する操作</h2>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/copy.html"><code><span style="color: #000">copy</span></code></a></td>
<td>指定された範囲の要素をコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/copy_n.html"><code><span style="color: #000">copy_n</span></code></a></td>
<td>指定された数の要素をコピーする</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/copy_if.html"><code><span style="color: #000">copy_if</span></code></a></td>
<td>条件を満たす要素のみをコピーする</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/copy_backward.html"><code><span style="color: #000">copy_backward</span></code></a></td>
<td>指定された範囲の要素を後ろからコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/move.html"><code><span style="color: #000">move</span></code></a></td>
<td>指定された範囲の要素をムーブする</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/move_backward.html"><code><span style="color: #000">move_backward</span></code></a></td>
<td>指定された範囲の要素を後ろからムーブする</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/swap_ranges.html"><code><span style="color: #000">swap_ranges</span></code></a></td>
<td>指定された2つの範囲同士を swap する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/iter_swap.html"><code><span style="color: #000">iter_swap</span></code></a></td>
<td>2つのイテレータの要素を swap する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/transform.html"><code><span style="color: #000">transform</span></code></a></td>
<td>全ての要素に関数を適用する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/replace.html"><code><span style="color: #000">replace</span></code></a></td>
<td>指定された値と一致する要素を指定された値に置き換える</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/replace_if.html"><code><span style="color: #000">replace_if</span></code></a></td>
<td>条件を満たす要素を指定された値に置き換える</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/replace_copy.html"><code><span style="color: #000">replace_copy</span></code></a></td>
<td>指定された値を一致する要素を指定された値に置き換え、その結果を出力の範囲へコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/replace_copy_if.html"><code><span style="color: #000">replace_copy_if</span></code></a></td>
<td>条件を満たす要素を指定された値に置き換え、その結果を出力の範囲へコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/fill.html"><code><span style="color: #000">fill</span></code></a></td>
<td>指定された値で出力の範囲に書き込む</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/fill_n.html"><code><span style="color: #000">fill_n</span></code></a></td>
<td>指定された値で出力の範囲に n 個書き込む</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/generate.html"><code><span style="color: #000">generate</span></code></a></td>
<td>出力の範囲へ関数の結果を書き込む</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/generate_n.html"><code><span style="color: #000">generate_n</span></code></a></td>
<td>出力の範囲へ関数の結果を n 個書き込む</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/remove.html"><code><span style="color: #000">remove</span></code></a></td>
<td>指定された要素を除ける</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/remove_if.html"><code><span style="color: #000">remove_if</span></code></a></td>
<td>条件を満たす要素を除ける</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/remove_copy.html"><code><span style="color: #000">remove_copy</span></code></a></td>
<td>指定された要素を除け、その結果を出力の範囲へコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/remove_copy_if.html"><code><span style="color: #000">remove_copy_if</span></code></a></td>
<td>条件を満たす要素を除け、その結果を出力の範囲へコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/unique.html"><code><span style="color: #000">unique</span></code></a></td>
<td>重複した要素を除ける</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/unique_copy.html"><code><span style="color: #000">unique_copy</span></code></a></td>
<td>重複した要素を除け、その結果を出力の範囲へコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/reverse.html"><code><span style="color: #000">reverse</span></code></a></td>
<td>要素の並びを逆にする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/reverse_copy.html"><code><span style="color: #000">reverse_copy</span></code></a></td>
<td>要素の並びを逆にし、その結果を出力の範囲へコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/rotate.html"><code><span style="color: #000">rotate</span></code></a></td>
<td>要素の並びを回転させる</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/rotate_copy.html"><code><span style="color: #000">rotate_copy</span></code></a></td>
<td>要素の並びを回転させ、その結果を出力の範囲へコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/random_shuffle.html"><code><span style="color: #000">random_shuffle</span></code></a></td>
<td>それぞれの要素をランダムな位置に移動させる</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/shuffle.html"><code><span style="color: #000">shuffle</span></code></a></td>
<td>それぞれの要素をランダムな位置に移動させる</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/is_partitioned.html"><code><span style="color: #000">is_partitioned</span></code></a></td>
<td>与えられた範囲が条件によって<a href="http://cpprefjp.github.io/reference/algorithm.html#sequence-is-partitioned">区分化</a>されているか判定する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/partition.html"><code><span style="color: #000">partition</span></code></a></td>
<td>与えられた範囲を条件によって<a href="http://cpprefjp.github.io/reference/algorithm.html#sequence-is-partitioned">区分化</a>する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/stable_partition.html"><code><span style="color: #000">stable_partition</span></code></a></td>
<td>与えられた範囲を相対順序を保ちながら条件によって<a href="http://cpprefjp.github.io/reference/algorithm.html#sequence-is-partitioned">区分化</a>する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/partition_copy.html"><code><span style="color: #000">partition_copy</span></code></a></td>
<td>与えられた範囲を条件によって 2 つの出力の範囲へ分けてコピーする</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/partition_point.html"><code><span style="color: #000">partition_point</span></code></a></td>
<td>与えられた範囲から条件によって<a href="http://cpprefjp.github.io/reference/algorithm.html#sequence-is-partitioned">区分化</a>されている位置を得る</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h2>ソートや、それに関連した操作</h2>
<p>ここで挙げる操作には全て２つのバージョンがある。一つは <code><span style="color: #000">Compare</span></code> 型の関数オブジェクトを取る関数、もう一つは <code><span style="color: #000">operator&lt;</span></code> を使用する関数である。</p>
<p><code><span style="color: #000">Compare</span></code> は関数オブジェクト型である。<br />
<code><span style="color: #000">Compare</span></code> 型のオブジェクトに適用した関数呼び出しの戻り値は、 <code><span style="color: #000">bool</span></code> へ文脈依存の変換をされたとき、第一引数が第二引数より小さい場合は <code><span style="color: #000">true</span></code> を、そうでない場合は <code><span style="color: #000">false</span></code> を返す。<br />
何らかの順序関係 (ordering relation) を前提とするアルゴリズム全般に対して <code><span style="color: #000">Compare</span></code> 型の <code><span style="color: #000">comp</span></code> を使用する。<br />
<code><span style="color: #000">comp</span></code> は間接参照したイテレータを通して非 <code><span style="color: #000">const</span></code> な関数を適用しないものとする。  </p>
<p><code><span style="color: #000">Compare</span></code> を取るアルゴリズムには全て、代わりに <code><span style="color: #000">operator&lt;</span></code> を使うバージョンもある。<br />
つまり、<code><span style="color: #000">comp(*i, *j) != false</span></code> はデフォルトで <code><span style="color: #000">*i &lt; *j != false</span></code> である。<br />
<a name="strict-weak-ordering"></a>
<a href="http://cpprefjp.github.io/reference/algorithm.html#alg.binary.search">二分探索</a>以外のアルゴリズムでは、<code><span style="color: #000">comp</span></code> は「狭義の弱順序 (strict weak ordering) 」を示さなければならない。  </p>
<p>ここでの用語「狭義 (strict) 」 は非反射関係 (irreflexive relation) (全ての <code><span style="color: #000">x</span></code> について <code><span style="color: #000">!comp(x,x)</span></code> である）の要求を示し、用語「弱 (weak) 」は全順序 (total ordering) ほど強くはないが半順序 (partial ordering) よりは強い要求を示す。<code><span style="color: #000">!comp(a, b) &amp;&amp; !comp(b, a)</span></code> として <code><span style="color: #000">equiv(a, b)</span></code> を定義する場合、用語「弱」の要求は <code><span style="color: #000">comp</span></code> と <code><span style="color: #000">equiv</span></code> の両方が以下のように推移的関係 (transitive relations) となることである。  </p>
<ul>
<li><code><span style="color: #000">comp(a, b) &amp;&amp; comp(b, c)</span></code> は <code><span style="color: #000">comp(a, c)</span></code> を意味する</li>
<li><code><span style="color: #000">equiv(a, b) &amp;&amp; equiv(b, c)</span></code> は <code><span style="color: #000">equiv(a, c)</span></code> を意味する</li>
</ul>
<p>これらの前提のもと、以下を示すことができる。</p>
<ul>
<li><code><span style="color: #000">equiv</span></code> は等価関係 (equivalence relation) である</li>
<li><code><span style="color: #000">comp</span></code> は <code><span style="color: #000">equiv</span></code> によって決まる同値類の間での明確な関係を示す</li>
<li>その示される関係は狭義の全順序 (strict total ordering) である</li>
</ul>
<p><a name="sequence-is-sorted"></a>
あるシーケンスを指す任意のイテレータ <code><span style="color: #000">i</span></code> と、<code><span style="color: #000">i + n</span></code> がそのシーケンス上の要素を指す有効なイテレータであるような任意の非負整数 <code><span style="color: #000">n</span></code> について、<code><span style="color: #000">comp(*(i + n), *i) == false</span></code> であれば、そのシーケンスは比較関数 (comparator) <code><span style="color: #000">comp</span></code> によってソートされているという。  </p>
<p><a name="sequence-is-partitioned"></a>
あるシーケンス <code><span style="color: #000">[start,finish)</span></code> があり、<code><span style="color: #000">0 &lt;= i &lt; (finish - start)</span></code> 内の全ての整数 <code><span style="color: #000">i</span></code> について、<code><span style="color: #000">i &lt; n</span></code> の時かつその時に限り <code><span style="color: #000">f(*(start + i))</span></code> が <code><span style="color: #000">true</span></code> となるような整数 <code><span style="color: #000">n</span></code> が存在するなら、そのシーケンス <code><span style="color: #000">[start,finish)</span></code> は式 <code><span style="color: #000">f(e)</span></code> によって区分化されているという。  </p>
<ul>
<li>「区分化されている」と「ソートされている」との関係<br />
  あるシーケンスが比較関数 <code><span style="color: #000">comp</span></code> でソートされている場合、そのシーケンスは <code><span style="color: #000">comp</span></code> に任意の検索キー <code><span style="color: #000">k</span></code> を部分適用した式 <code><span style="color: #000">comp(e, k)</span></code> や <code><span style="color: #000">!comp(k, e)</span></code> などにより区分化されているともいえる。<br />
  例えば、ソートされた整数列 <code><span style="color: #000">[1, 5, 13, 17, 25]</span></code> は「 <code><span style="color: #000">10</span></code> より小さい」によって区分化されている。さらに、そのほかの任意の数値についても「～より小さい」あるいは「～より小さくない（～以上）」などによって区分化されているといえる。<br />
  C++03 までの二分探索アルゴリズムは比較関数が狭義の弱順序となることおよび対象シーケンスがその比較関数でソートされていることを要求していた。しかしその後、 C++11 で異なる型のキーによる検索を明示的に許すために制限が見直された結果、比較関数そのものに対する要求はなくなり、比較関数に検索キーを部分適用した式による区分化のみに要求が緩められた。（参照: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270" target="_blank">LWG issue 270 "Binary search requirements overly strict"</a> ）<br />
  これにより、例えばソートされていない整数列 <code><span style="color: #000">[5, 1, 25, 13, 17]</span></code> に対しても <code><span style="color: #000">10</span></code> をキーとして <a href="http://cpprefjp.github.io/reference/algorithm/lower_bound.html"><code><span style="color: #000">lower_bound()</span></code></a> を用いることにより <code><span style="color: #000">10</span></code> より小さい範囲の境界を取り出すことが可能になっている。しかし <code><span style="color: #000">15</span></code> をキーとすることは不正である。<br />
  ただ、 C++03 の要件に合わない（特にソートされていない範囲に対する）二分探索を行いたい場合は、同じく C++11 で追加された <a href="http://cpprefjp.github.io/reference/algorithm/partition_point.html"><code><span style="color: #000">partition_point()</span></code></a> の使用も検討したほうがよい。  </li>
</ul>
<p>順序関係を扱う関数の説明において、この節では安定性 (stability) のようなコンセプトを説明するために等価性 (equivalence) の概念を頻繁に使う。<br />
この節で参照する等価性は必ずしも <code><span style="color: #000">operator==</span></code> ではなく、<a href="http://cpprefjp.github.io/reference/algorithm.html#strict-weak-ordering">狭義の弱順序</a>によって示される等価関係である。つまりそれは、２つの要素 <code><span style="color: #000">a</span></code> と <code><span style="color: #000">b</span></code> は <code><span style="color: #000">!(a &lt; b) &amp;&amp; !(b &lt; a)</span></code> の時かつその時に限り等価とみなされるということである。  </p>
<h3>ソート</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/sort.html"><code><span style="color: #000">sort</span></code></a></td>
<td>範囲を並べ替える</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/stable_sort.html"><code><span style="color: #000">stable_sort</span></code></a></td>
<td>範囲を安定ソートで並べ替える</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/partial_sort.html"><code><span style="color: #000">partial_sort</span></code></a></td>
<td>範囲を部分的にソートし、先頭N個を並んだ状態にする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/partial_sort_copy.html"><code><span style="color: #000">partial_sort_copy</span></code></a></td>
<td>範囲を部分的にソートした結果を他の範囲にコピーする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/is_sorted.html"><code><span style="color: #000">is_sorted</span></code></a></td>
<td>ソート済みか判定する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/is_sorted_until.html"><code><span style="color: #000">is_sorted_until</span></code></a></td>
<td>ソート済みか判定し、ソートされていない位置のイテレータを取得する</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h3>N 番目の要素</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/nth_element.html"><code><span style="color: #000">nth_element</span></code></a></td>
<td>基準となる要素よりも小さい要素が、前に来るよう並べ替える</td>
<td></td>
</tr>
</tbody>
</table>
<h3><a name="alg.binary.search"></a>二分探索</h3>
<p>これらのアルゴリズムは全て二分探索を行う。これらは探索されるシーケンスが検索キーを比較関数（暗黙の <code><span style="color: #000">operator &lt;</span></code> 、または明示的に渡された <code><span style="color: #000">Compare comp</span></code> ）の引数として部分適用することで得られる式によって<a href="http://cpprefjp.github.io/reference/algorithm.html#sequence-is-partitioned">区分化</a>されていると仮定している。<br />
これらはランダムアクセスイテレータでない場合でも最小の比較回数で動作する。<br />
これらのアルゴリズムに渡されたイテレータがランダムアクセスイテレータである場合、データ構造を渡るときに対数のステップ数で済むため、このイテレータが適している。ランダムアクセスイテレータでない場合は線形のステップ数になる。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/lower_bound.html"><code><span style="color: #000">lower_bound</span></code></a></td>
<td>指定された要素以上の値が現れる最初の位置のイテレータを取得する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/upper_bound.html"><code><span style="color: #000">upper_bound</span></code></a></td>
<td>指定された要素より大きい値が現れる最も後ろの位置のイテレータを取得する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/equal_range.html"><code><span style="color: #000">equal_range</span></code></a></td>
<td><code><span style="color: #000">lower_bound</span></code>と<code><span style="color: #000">upper_bound</span></code>の結果を組で取得する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/binary_search.html"><code><span style="color: #000">binary_search</span></code></a></td>
<td>二分探索法による検索を行う</td>
<td></td>
</tr>
</tbody>
</table>
<h3>マージ</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/merge.html"><code><span style="color: #000">merge</span></code></a></td>
<td>2つのソート済み範囲をマージする</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/inplace_merge.html"><code><span style="color: #000">inplace_merge</span></code></a></td>
<td>2つの連続したソート済み範囲をマージする</td>
<td></td>
</tr>
</tbody>
</table>
<h3>ソート済み構造に対する集合演算</h3>
<p>このセクションでは基本的なソート済み構造に対する集合演算を定義する。<br />
これらの演算は、等価な要素を複数格納できる <code><span style="color: #000">multiset</span></code> であっても動作する。集合演算のセマンティクスは、等価な要素が複数あっても、一般化された標準的な方法で演算できるようになっている。<br />
例えば <a href="http://cpprefjp.github.io/reference/algorithm/set_union.html"><code><span style="color: #000">set_union()</span></code></a> ならそれぞれの要素の最大数を格納する、<a href="http://cpprefjp.github.io/reference/algorithm/set_intersection.html"><code><span style="color: #000">set_intersection()</span></code></a> なら最小数を格納するといったようになる。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/set_union.html"><code><span style="color: #000">set_union</span></code></a></td>
<td>2つのソート済み範囲の和集合を得る</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/set_intersection.html"><code><span style="color: #000">set_intersection</span></code></a></td>
<td>2つのソート済み範囲の積集合を得る</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/set_difference.html"><code><span style="color: #000">set_difference</span></code></a></td>
<td>2つのソート済み範囲の差集合を得る</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/set_symmetric_difference.html"><code><span style="color: #000">set_symmetric_difference</span></code></a></td>
<td>2つのソート済み範囲の互いに素な集合を得る</td>
<td></td>
</tr>
</tbody>
</table>
<h3>ヒープ</h3>
<p>２つのランダムアクセスイテレータ <code><span style="color: #000">[a,b)</span></code> の範囲を特定の構造で構築したものをヒープ(heap)と呼ぶ。ヒープには２つの特性がある。</p>
<ul>
<li><code><span style="color: #000">*a</span></code> より大きい要素は無い</li>
<li><code><span style="color: #000">*a</span></code> は、<code><span style="color: #000">pop_heap()</span></code> で削除したり、<code><span style="color: #000">push_heap()</span></code> で要素を追加する操作が O(log(N)) でできる</li>
</ul>
<p>これらの特性はプライオリティキューで有用である。<br />
<code><span style="color: #000">make_heap()</span></code> は heap の中の範囲を変換し、<code><span style="color: #000">sort_heap()</span></code> はソート済みシーケンスの中にあるヒープを turn する。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/push_heap.html"><code><span style="color: #000">push_heap</span></code></a></td>
<td>ヒープ化された範囲に要素を追加したヒープ範囲を得る</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/pop_heap.html"><code><span style="color: #000">pop_heap</span></code></a></td>
<td>ヒープ化された範囲の先頭と末尾を入れ替え、ヒープ範囲を作り直す</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/make_heap.html"><code><span style="color: #000">make_heap</span></code></a></td>
<td>範囲をヒープ化する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/sort_heap.html"><code><span style="color: #000">sort_heap</span></code></a></td>
<td>ヒープ化された範囲を並べ替える</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/is_heap_until.html"><code><span style="color: #000">is_heap_until</span></code></a></td>
<td>範囲がヒープ化されているか判定し、ヒープ化されていない最初の要素を指すイテレータを取得する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/is_heap.html"><code><span style="color: #000">is_heap</span></code></a></td>
<td>範囲がヒープ化されているか判定する</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h3>最小と最大</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/min.html"><code><span style="color: #000">min</span></code></a></td>
<td>最小値を取得する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/max.html"><code><span style="color: #000">max</span></code></a></td>
<td>最大値を取得する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/minmax.html"><code><span style="color: #000">minmax</span></code></a></td>
<td>最小値と最大値を取得する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/min_element.html"><code><span style="color: #000">min_element</span></code></a></td>
<td>範囲内の最小要素へのイテレータを取得する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/max_element.html"><code><span style="color: #000">max_element</span></code></a></td>
<td>範囲内の最大要素へのイテレータを取得する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/minmax_element.html"><code><span style="color: #000">minmax_element</span></code></a></td>
<td>範囲内の最小要素と最大要素へのイテレータを取得する</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h3>辞書式比較</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/lexicographical_compare.html"><code><span style="color: #000">lexicographical_compare</span></code></a></td>
<td>2つの範囲を辞書式順序で比較する</td>
<td></td>
</tr>
</tbody>
</table>
<h3>順列</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/next_permutation.html"><code><span style="color: #000">next_permutation</span></code></a></td>
<td>次の順列を生成する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/prev_permutation.html"><code><span style="color: #000">prev_permutation</span></code></a></td>
<td>前の順列を生成する</td>
<td></td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/is_permutation.html"><code><span style="color: #000">is_permutation</span></code></a></td>
<td>範囲が順列かを判定する</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/algorithm.md" target="_blank">編集</a></footer>