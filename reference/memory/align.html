<h1>align (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  void* align(std::size_t alignment, std::size_t size,
              void*&amp; ptr, std::size_t&amp; space);
}</span></code></pre>
</p>
<h2>概要</h2>
<p>アラインメント調整された領域を得る。</p>
<h2>効果</h2>
<p>範囲<code><span style="color: #000">[ptr, ptr + space)</span></code>の中に<code><span style="color: #000">alignment</span></code>バイトでアラインメント調整された領域の<code><span style="color: #000">size</span></code>バイトに一致するバッファがあるなら、</p>
<ul>
<li><code><span style="color: #000">ptr</span></code>を一致する領域の先頭アドレスへと更新し、</li>
<li><code><span style="color: #000">space</span></code>から使用したバイト数を減算する。</li>
</ul>
<p>そのようなバッファがなければ、この関数は何もしない。</p>
<h2>戻り値</h2>
<p>更新された<code><span style="color: #000">ptr</span></code>を返す。一致する領域がなければ、ヌルポインタを返す。</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main()
{
  char buffer[256];
  void* ptr = buffer;
  std::size_t space = sizeof(buffer) - 1;

  // intアラインメントで、intをN個確保。
  std::size_t N = 3;
  if (std::align(alignof(int), sizeof(int) * N, ptr, space)) {
    std::cout &lt;&lt; ptr &lt;&lt; " " &lt;&lt; space &lt;&lt; std::endl;
  }
}</span></code></pre>
</p>
<h3>出力例</h3>
<p><pre><code><span style="color: #000">0x7fffd930ca40 255
</span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang, C++11 mode</a>: 3.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++11 mode</a>: (4.8.2時点で未実装)</li>
<li><a href="http://cpprefjp.github.io/implementation.html#icc">ICC</a>: ??</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>: 11.0, 12.0<ul>
<li>Visual C++ 11.0はマニュアル（MSDNライブラリ）に記載がないものの、実装されている。</li>
</ul>
</li>
</ul>
<h2>参照</h2>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/memory/align.md" target="_blank">編集</a></footer>