<h1>allocator_traits (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">namespace std {
  template &lt;class Alloc&gt;
  struct allocator_traits;
}</span></code></pre>
</p>
<h2>概要</h2>
<p><code><span style="color: #000">allocator_traits</span></code>は、アロケータクラスの機能に間接的にアクセスするためのインタフェースを提供するクラスである。</p>
<h2>備考</h2>
<p>このクラスはC++11から導入され、メモリアロケータを扱うクラス(たとえばコンテナ)は、アロケータクラスの機能に直接アクセスする従来の仕様から、<code><span style="color: #000">allocator_traits</span></code>を介してアロケータにアクセスするように変更された。</p>
<p><code><span style="color: #000">allocator_traits</span></code>はアロケータに必要な機能の多くに対してデフォルト実装を用意しているため、この変更により、ユーザーが自作アロケータを作るのが容易になった。</p>
<h3>静的メンバ関数</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/memory/allocator_traits/allocate.html"><code><span style="color: #000">allocate</span></code></a></td>
<td>メモリを確保する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/memory/allocator_traits/deallocate.html"><code><span style="color: #000">deallocate</span></code></a></td>
<td>メモリを解放する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/memory/allocator_traits/max_size.html"><code><span style="color: #000">max_size</span></code></a></td>
<td>一度に確保可能なメモリの最大サイズを取得する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/memory/allocator_traits/construct.html"><code><span style="color: #000">construct</span></code></a></td>
<td>引数を元にインスタンスを構築する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/memory/allocator_traits/destroy.html"><code><span style="color: #000">destroy</span></code></a></td>
<td>インスタンスを破棄する</td>
<td>C++11</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/memory/allocator_traits/select_on_container_copy_construction.html"><code><span style="color: #000">select_on_container_copy_construction</span></code></a></td>
<td>コンテナのコピー構築に使用するアロケータオブジェクトを取得する</td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h3>メンバ型</h3>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
<th>対応バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">allocator_type</span></code></td>
<td>アロケータ型 <code><span style="color: #000">Alloc</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">value_type</span></code></td>
<td>要素の型 <code><span style="color: #000">typename Alloc::value_type</span></code></td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">pointer</span></code></td>
<td>要素のポインタ型。<br /> <code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">pointer</span></code>を持っていればそれを使用し、そうでなければ<code><span style="color: #000">value_type*</span></code>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">const_pointer</span></code></td>
<td>読み取り専用の要素のポインタ型。<br /> <code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">const_pointer</span></code>を持っていればそれを使用し、そうでなければ<a href="http://cpprefjp.github.io/reference/memory/pointer_traits.html"><code><span style="color: #000">pointer_traits</span></code></a><code><span style="color: #000">&lt;pointer&gt;::rebind&lt;const value_type&gt;</span></code>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">void_pointer</span></code></td>
<td><code><span style="color: #000">void</span></code>のポインタ型。<br /> <code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">void_pointer</span></code>を持っていればそれを使用し、そうでなければ<a href="http://cpprefjp.github.io/reference/memory/pointer_traits.html"><code><span style="color: #000">pointer_traits</span></code></a><code><span style="color: #000">&lt;pointer&gt;::rebind&lt;void&gt;</span></code>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">const_void_pointer</span></code></td>
<td>読み取り専用の<code><span style="color: #000">void</span></code>のポインタ型。<br /> <code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">const_void_pointer</span></code>を持っていればそれを使用し、そうでなければ<a href="http://cpprefjp.github.io/reference/memory/pointer_traits.html"><code><span style="color: #000">pointer_traits</span></code></a><code><span style="color: #000">&lt;pointer&gt;::rebind&lt;const void&gt;</span></code>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">difference_type</span></code></td>
<td>ポインタの差を表す符号あり整数型。<br /> <code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">difference_type</span></code>を持っていればそれを使用し、そうでなければ<a href="http://cpprefjp.github.io/reference/memory/pointer_traits.html"><code><span style="color: #000">pointer_traits</span></code></a><code><span style="color: #000">::difference_type</span></code>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">size_type</span></code></td>
<td>要素数を表す符号なし整数型。<br /> <code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">size_type</span></code>を持っていればそれを使用し、そうでなければ<a href="http://cpprefjp.github.io/reference/type_traits/make_unsigned.html"><code><span style="color: #000">make_unsigned</span></code></a><code><span style="color: #000">&lt;difference_type&gt;::type</span></code>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">propagate_on_container_copy_assignment</span></code></td>
<td>コンテナのコピー代入時に、アロケータオブジェクトをコピー(伝搬)するか否か。<br /><code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">propagate_on_container_copy_assignment</span></code>を持っていればそれを使用し、そうでなければ<a href="http://cpprefjp.github.io/reference/type_traits/integral_constant-true_type-false_type.html"><code><span style="color: #000">false_type</span></code></a>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">propagate_on_container_move_assignment</span></code></td>
<td>コンテナのムーブ代入時に、アロケータオブジェクトをコピー(伝搬)するか否か。<br /><code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">propagate_on_container_move_assignment</span></code>を持っていればそれを使用し、そうでなければ<a href="http://cpprefjp.github.io/reference/type_traits/integral_constant-true_type-false_type.html"><code><span style="color: #000">false_type</span></code></a>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">propagate_on_container_swap</span></code></td>
<td>コンテナの交換時に、アロケータオブジェクトをコピー(伝搬)するか否か。<br /><code><span style="color: #000">Alloc</span></code>がメンバ型<code><span style="color: #000">propagate_on_container_swap</span></code>を持っていればそれを使用し、そうでなければ<a href="http://cpprefjp.github.io/reference/type_traits/integral_constant-true_type-false_type.html"><code><span style="color: #000">false_type</span></code></a>を使用する。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">rebind_alloc&lt;U&gt;</span></code></td>
<td>型<code><span style="color: #000">U</span></code>を確保するようにアロケータ型を再束縛する。<br /> <code><span style="color: #000">Alloc::rebind&lt;U&gt;::other</span></code>が有効ならそれを使用し、そうでなければ<code><span style="color: #000">Alloc&lt;U, Args</span></code>&gt;を使用する。<code><span style="color: #000">Alloc</span></code>がクラステンプレートでない場合、<code><span style="color: #000">rebind_alloc</span></code>の使用は不適格となる。</td>
<td>C++11</td>
</tr>
<tr>
<td><code><span style="color: #000">rebind_traits&lt;U&gt;</span></code></td>
<td>再束縛した型<code><span style="color: #000">U</span></code>に対する<code><span style="color: #000">allocator_traits</span></code>。<code><span style="color: #000">allocator_traits&lt;rebind_alloc&lt;U&gt;&gt;</span></code></td>
<td>C++11</td>
</tr>
</tbody>
</table>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;memory&gt;

template &lt;class T, class Alloc&gt;
class MyVector {
  T* data_;
  std::size_t size_;
  Alloc alloc_;
public:
  MyVector(std::size_t size)
  {
    using traits = std::allocator_traits&lt;Alloc&gt;;

    size_ = size;

    // メモリを確保
    data_ = traits::allocate(alloc_, size);

    // 要素を構築
    for (std::size_t i = 0; i &lt; size_; ++i) {
      traits::construct(alloc_, &amp;data_[i]);
    }
  }

  ~MyVector()
  {
    using traits = std::allocator_traits&lt;Alloc&gt;;

    // 要素を破棄
    for (std::size_t i = 0; i &lt; size_; ++i) {
      traits::destroy(alloc_, &amp;data_[i]);
    }

    // メモリを解放
    traits::deallocate(alloc_, data_, size_);
  }
};

int main()
{
  MyVector&lt;int, std::allocator&lt;int&gt;&gt; v(3);
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000"></span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++11 mode</a>: 4.7.3</li>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang libc++, C++11 mode</a>: 3.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#icc">ICC</a>: ?</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>: 11.0, 12.0</li>
</ul>
<h3>参照</h3>
<ul>
<li><a href="http://www.slideshare.net/Cryolite/allocator11final" target="_blank">Allocators@C++11 - Cryolite</a></li>
<li><a href="https://rawgit.com/google/cxx-std-draft/allocator-paper/allocator_user_guide.html" target="_blank">A visitor’s guide to C++ allocators</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf" target="_blank">N2982 Allocators post Removal of C++ Concepts (Rev 1)</a></li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/memory/allocator_traits.md" target="_blank">編集</a></footer>