<h1>lock (C++11)</h1>
<p><pre class="codehilite"><code class="language-cpp"><a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html">shared_ptr</a>&lt;T&gt; lock() const noexcept;<span style="color: #000"></span></code></pre>
</p>
<h2>概要</h2>
<p>監視している<a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html"><code><span style="color: #000">shared_ptr</span></code></a>オブジェクトを取得する。</p>
<h2>戻り値</h2>
<p><pre class="codehilite"><code class="language-cpp"><a href="http://cpprefjp.github.io/reference/memory/weak_ptr/expired.html">expired()</a> ? <a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html">shared_ptr</a>&lt;T&gt;() : <a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html">shared_ptr</a>&lt;T&gt;(*this)<span style="color: #000"></span></code></pre>

監視している<a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html"><code><span style="color: #000">shared_ptr</span></code></a>オブジェクトが有効な状態なら、その<a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html"><code><span style="color: #000">shared_ptr</span></code></a>オブジェクトとリソースを共有する<a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html"><code><span style="color: #000">shared_ptr</span></code></a>オブジェクトを作って返す。これによって、ロックしている間、<a href="http://cpprefjp.github.io/reference/memory/shared_ptr"><code><span style="color: #000">shared_ptr</span></code></a>オブジェクトの寿命が尽きないようにする。</p>
<p>監視している<a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html"><code><span style="color: #000">shared_ptr</span></code></a>オブジェクトが寿命切れ状態なら、空の<a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html"><code><span style="color: #000">shared_ptr</span></code></a>オブジェクトを作って返す。</p>
<ul>
<li>C++14</li>
</ul>
<p>C++14以降では、上記に相当することをアトミックに実行する。</p>
<h2>備考</h2>
<p>(この関数が<code><span style="color: #000">shared_ptr</span></code>オブジェクトではなく生ポインタを返す設計になっていない理由を解説する。以下のコードを考えてみよう：</p>
<p><pre class="codehilite"><code class="language-cpp"><a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html">shared_ptr</a>&lt;int&gt; sp(new int(3));
std::weak_ptr&lt;int&gt; wp = sp;

// …この間に、spの寿命が切れるかもしれない…

if (int* r = wp.lock()) {
  std::cout &lt;&lt; *r &lt;&lt; std::endl;
}<span style="color: #000">std::</span></code></pre>

このコードの場合、ロックを取得した<code><span style="color: #000">if</span></code>文内で、<code><span style="color: #000">shared_ptr</span></code>オブジェクト<code><span style="color: #000">sp</span></code>に対して<a href="http://cpprefjp.github.io/reference/memory/shared_ptr/reset.html"><code><span style="color: #000">reset()</span></code></a>が呼ばれると、ポインタ<code><span style="color: #000">p</span></code>がダングリングポインタ(dangling pointer : 不正な領域を指すポインタ)になってしまう。</p>
<p>この関数が<a href="http://cpprefjp.github.io/reference/memory/shared_ptr.html"><code><span style="color: #000">shared_ptr</span></code></a>オブジェクトを返す設計になっていることで、ロック取得したポインタがダングリングポインタになってしまう問題を回避できる。</p>
<h2>例外</h2>
<p>投げない</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main()
{
  std::shared_ptr&lt;int&gt; sp(new int(3));
  std::weak_ptr&lt;int&gt; wp = sp;

  // …この間に、spの寿命が切れるかもしれない…

  // wpが監視しているshared_ptrオブジェクトの
  // 寿命が切れていなければ処理する
  if (std::shared_ptr&lt;int&gt; r = wp.lock()) {
    std::cout &lt;&lt; *r &lt;&lt; std::endl;
  }
  else {
    // shared_ptrオブジェクトの寿命が切れている
    std::cout &lt;&lt; "sp is expired" &lt;&lt; std::endl;
  }
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000">3
</span></code></pre></p>
<h2>バージョン</h2>
<h3>言語</h3>
<ul>
<li>C++11</li>
</ul>
<h3>処理系</h3>
<ul>
<li><a href="http://cpprefjp.github.io/implementation.html#gcc">GCC, C++11 mode</a>: 4.3.6</li>
<li><a href="http://cpprefjp.github.io/implementation.html#clang">Clang libc++, C++11 mode</a>: 3.0</li>
<li><a href="http://cpprefjp.github.io/implementation.html#icc">ICC</a>: ?</li>
<li><a href="http://cpprefjp.github.io/implementation.html#visual_cpp">Visual C++</a>: ?</li>
</ul>
<h2>参照</h2>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2316" target="_blank">LWG 2316 - weak_ptr::lock() should be atomic</a></li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/memory/weak_ptr/lock.md" target="_blank">編集</a></footer>