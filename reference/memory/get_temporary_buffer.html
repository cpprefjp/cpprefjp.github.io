<h1>get_temporary_buffer</h1>
<p><pre class="codehilite"><code class="language-cpp"><a href="http://cpprefjp.github.io/reference/utility/pair.html">pair</a>&lt;T*, <a href="http://cpprefjp.github.io/reference/cstddef/ptrdiff_t.html">ptrdiff_t</a>&gt; get_temporary_buffer(<a href="http://cpprefjp.github.io/reference/cstddef/ptrdiff_t.html">ptrdiff_t</a> n);

// C++11
template &lt;class T&gt;
<a href="http://cpprefjp.github.io/reference/utility/pair.html">pair</a>&lt;T*, <a href="http://cpprefjp.github.io/reference/cstddef/ptrdiff_t.html">ptrdiff_t</a>&gt; get_temporary_buffer(<a href="http://cpprefjp.github.io/reference/cstddef/ptrdiff_t.html">ptrdiff_t</a> n) noexcept;<span style="color: #000">// C++03
template &lt;class T&gt;
</span></code></pre>
</p>
<h2>概要</h2>
<p>短期的なメモリ領域を確保する。</p>
<h2>効果</h2>
<p>この関数は、型<code><span style="color: #000">T</span></code>のオブジェクトを<code><span style="color: #000">n</span></code>個格納するのに十分な領域を確保する。</p>
<h2>戻り値</h2>
<p>バッファへのアドレスを<code><span style="color: #000">first</span></code>、確保した要素数を<code><span style="color: #000">second</span></code>とする<a href="http://cpprefjp.github.io/reference/utility/pair.html"><code><span style="color: #000">pair</span></code></a>オブジェクトを返す。</p>
<p><code><span style="color: #000">n &lt;= 0</span></code>の場合は、バッファをヌルポインタ、確保した要素数を<code><span style="color: #000">0</span></code>として返す。</p>
<h2>例外</h2>
<ul>
<li>C++11 : 投げない</li>
</ul>
<h2>備考</h2>
<p>アルゴリズムによっては、一時的なメモリ確保を必要とするものがある。</p>
<p>この関数は、短期的なメモリ領域のために実装が最適化している可能性がある。<a href="http://cpprefjp.github.io/reference/memory/allocator.html"><code><span style="color: #000">std::allocator</span></code></a><code><span style="color: #000">::</span></code><a href="http://cpprefjp.github.io/reference/memory/allocator/allocate.html"><code><span style="color: #000">allocate()</span></code></a>を長期的に使用するメモリとして使用することで、この関数との使い分けができるだろう。</p>
<p>ただし、Visual C++ 12.0、GCC 4.8 (libstdc++)、Clang 3.4 (libc++)は単に<a href="http://cpprefjp.github.io/reference/new/new.html"><code><span style="color: #000">new</span></code></a>を呼んでいるだけで、最適化はとくに行っていない。</p>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main()
{
  // int型のオブジェクトが3つ入る領域を確保
  std::pair&lt;int*, std::ptrdiff_t&gt; result = std::get_temporary_buffer&lt;int&gt;(3);

  int* p = result.first;
  std::size_t size = static_cast&lt;std::size_t&gt;(result.second);

  std::allocator&lt;int&gt; alloc;
  using traits = std::allocator_traits&lt;std::allocator&lt;int&gt;&gt;;

  // オブジェクトを構築
  for (std::size_t i = 0; i &lt; size; ++i) {
    traits::construct(alloc, p + i);
  }

  // オブジェクトを破棄
  for (std::size_t i = 0; i &lt; size; ++i) {
    traits::destroy(alloc, p + i);
  }

  // 確保した領域を解放
  std::return_temporary_buffer(p);
}</span></code></pre>
</p>
<h3>出力</h3>
<p><pre><code><span style="color: #000"></span></code></pre></p>
<h2>参照</h2>
<ul>
<li><a href="http://stackoverflow.com/questions/3264299/why-do-i-need-stdget-temporary-buffer" target="_blank">Why do I need std::get_temporary_buffer? - Stack Overflow</a></li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/memory/get_temporary_buffer.md" target="_blank">編集</a></footer>