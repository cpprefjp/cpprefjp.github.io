<h1>find</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">size_type find(const basic_string&amp; str, size_type pos = 0) const noexcept; // (1)
size_type find(const charT* s, size_type pos, size_type n) const;          // (2)
size_type find(const charT* s, size_type pos = 0) const;                   // (3)
size_type find(charT c, size_type pos = 0) const;                          // (4) C++11
size_type find(charT c, size_type pos = 0) const noexcept;                 // (4) C++14</span></code></pre>
</p>
<h2>概要</h2>
<p>指定した文字列を検索する。</p>
<h2>要件</h2>
<p>(3) の形式の場合、<code><span style="color: #000">s</span></code> は少なくとも <code><span style="color: #000">traits_type::length(s) + 1</span></code> の要素を持つ <code><span style="color: #000">charT</span></code> の配列を指していること。</p>
<h2>効果</h2>
<ul>
<li>(1) <code><span style="color: #000">pos</span></code> 以降で最初に <code><span style="color: #000">str</span></code> と一致する位置を返す。</li>
<li>(2) <code><span style="color: #000">pos</span></code> 以降で最初に <code><span style="color: #000">s</span></code> と一致する位置を返す。<code><span style="color: #000">s</span></code> は長さ <code><span style="color: #000">n</span></code> の文字列へのポインタである。</li>
<li>(3) (2) と同様だが、こちらは NULL 終端の文字列を扱う。</li>
<li>(4) <code><span style="color: #000">pos</span></code> 以降で最初に <code><span style="color: #000">c</span></code> と一致する位置を返す。</li>
</ul>
<h2>戻り値</h2>
<p>見つかればその位置を返し、見つからない場合は <code><span style="color: #000">basic_string::npos</span></code> を返す。</p>
<h2>例外</h2>
<ul>
<li>(1) 投げない</li>
<li>(2) -</li>
<li>(3) -</li>
<li>(4) 投げない（但し、備考参照）</li>
</ul>
<h2>備考</h2>
<ul>
<li>文字列の一致は、文字列の各文字について <code><span style="color: #000">traits_type::eq</span></code> を用いて検査される。<br />
    例えば、(1) の形式の場合、以下のような条件を満たす最小の <code><span style="color: #000">xpos</span></code> を求める。<ul>
<li><code><span style="color: #000">pos &lt;= xpos</span></code> かつ <code><span style="color: #000">xpos + str.size() &lt;= size()</span></code></li>
<li><code><span style="color: #000">0 &lt;= I</span></code> かつ <code><span style="color: #000">I &lt; str.size()</span></code> を満たす全ての <code><span style="color: #000">I</span></code> について、<code><span style="color: #000">traits_type::eq(at(xpos + I), str.at(I))</span></code></li>
</ul>
</li>
<li>(3) の形式の場合、<code><span style="color: #000">s</span></code> の文字列長は <code><span style="color: #000">traits_type::length(s)</span></code> で求められる。</li>
<li>C++03 では、例外指定は無い。</li>
<li>C++11 では、(4) の形式には <code><span style="color: #000">noexcept</span></code> が付いているが、下記の実装例のような実装を許すために C++14 では削除されるかもしれない。<br />
    （そのような実装では新たな <code><span style="color: #000">std::basic_string</span></code> が割り当てられるため、メモリのアロケーションが行われる）</li>
<li>コンテナに対して同様の検索を行う関数は <a href="http://cpprefjp.github.io/reference/algorithm.html"><code><span style="color: #000">algorithm</span></code></a> ヘッダの <a href="http://cpprefjp.github.io/reference/algorithm/search.html"><code><span style="color: #000">search</span></code></a>（検索対象がシーケンスの場合）、あるいは <a href="http://cpprefjp.github.io/reference/algorithm/find.html"><code><span style="color: #000">find</span></code></a>（検索対象が単一の値の場合）であるが、これらがイテレータベースであるのに対して、本メンバ関数は添字ベースであることに注意。</li>
</ul>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">find</span>(find_word);
  while (pos != std::string::npos) {
    std::cout &lt;&lt; pos &lt;&lt; std::endl;
    pos = s.<span style="color:#ff0000">find</span>(find_word, pos + find_word.length());
  }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  const std::string s("hello, world. welcome to C++ world.");
  const std::string find_word("world");
  std::string::size_type pos = s.</span></code></pre>
</p>
<h3>出力</h3>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">7
29</span></code></pre>
</p>
<h2>実装例</h2>
<p>(1) 以外の形式は、(1) の形式を使用して実装することができる。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">// (2)
template &lt;class charT, class traits, class Allocator&gt;
size_type basic_string&lt;charT, traits, Allocator&gt;::find(const charT* s, size_type pos, size_type n) const
{
  return find(std::basic_string(s, n), pos);
}

// (3)
template &lt;class charT, class traits, class Allocator&gt;
size_type basic_string&lt;charT, traits, Allocator&gt;::find(const charT* s, size_type pos = 0) const
{
  return find(std::basic_string(s), pos);
}

// (4)
template &lt;class charT, class traits, class Allocator&gt;
size_type basic_string&lt;charT, traits, Allocator&gt;::find(charT c, size_type pos = 0) const noexcept
{
  return find(std::basic_string(1, c), pos);
}</span></code></pre>
</p>
<h2>参照</h2>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>名前</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/search.html"><code><span style="color: #000">search</span></code></a></td>
<td>指定された最初のサブシーケンスを検索する</td>
</tr>
<tr>
<td><a href="http://cpprefjp.github.io/reference/algorithm/find.html"><code><span style="color: #000">find</span></code></a></td>
<td>指定された値を検索する</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2064" target="_blank">LWG2064 - More noexcept issues in basic_string</a></li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/string/basic_string/find.md" target="_blank">編集</a></footer>