<h1>find_last_not_of</h1>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">size_type find_last_not_of(const basic_string&amp; str, size_type pos = npos) const noexcept; // (1)
size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;             // (2)
size_type find_last_not_of(const charT* s, size_type pos = npos) const;                   // (3)
size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;                 // (4) C++11
size_type find_last_not_of(charT c, size_type pos = npos) const;                          // (4) C++14</span></code></pre>
</p>
<h2>概要</h2>
<p>指定された文字列中のいずれの文字にも一致しない最後の場所を検索する。</p>
<h2>要件</h2>
<p>(3) の形式の場合、<code><span style="color: #000">s</span></code> は少なくとも <code><span style="color: #000">traits_type::length(s) + 1</span></code> の要素を持つ <code><span style="color: #000">charT</span></code> の配列を指していること。</p>
<h2>効果</h2>
<ul>
<li>(1) <code><span style="color: #000">pos</span></code> 以前で最後に <code><span style="color: #000">str</span></code> 内に存在しない文字の位置を返す。</li>
<li>(2) <code><span style="color: #000">pos</span></code> 以前で最後に <code><span style="color: #000">s</span></code> 内に存在しない文字の位置を返す。<code><span style="color: #000">s</span></code> は長さ <code><span style="color: #000">n</span></code> の文字列へのポインタである。</li>
<li>(3) (2) と同様だが、こちらは NULL 終端の文字列を扱う。</li>
<li>(4) <code><span style="color: #000">pos</span></code> 以前で最後に <code><span style="color: #000">c</span></code> と一致しない文字の位置を返す。</li>
</ul>
<h2>戻り値</h2>
<p>見つかればその位置を返し、見つからない場合は <code><span style="color: #000">basic_string::npos</span></code> を返す。</p>
<h2>例外</h2>
<ul>
<li>(1) 投げない</li>
<li>(2) -</li>
<li>(3) -</li>
<li>(4) 投げない（但し、備考参照）</li>
</ul>
<h2>備考</h2>
<ul>
<li>一致しない文字の検索は、指定された文字列の各文字について <code><span style="color: #000">traits_type::eq</span></code> を使用することで行われる。<br />
    例えば、(1) の形式の場合、以下のような条件を満たす最大の <code><span style="color: #000">xpos</span></code> を求める。<ul>
<li><code><span style="color: #000">xpos &lt;= pos</span></code> かつ <code><span style="color: #000">xpos &lt; size()</span></code></li>
<li><code><span style="color: #000">0 &lt;= I</span></code> かつ <code><span style="color: #000">I &lt; str.size()</span></code> を満たす全ての <code><span style="color: #000">I</span></code> について、<code><span style="color: #000">!traits_type::eq(at(xpos), str.at(I))</span></code></li>
</ul>
</li>
<li>(3) の形式の場合、<code><span style="color: #000">s</span></code> の文字列長は <code><span style="color: #000">traits_type::length(s)</span></code> で求められる。</li>
<li>C++03 では、例外指定は無い。</li>
<li>C++11 では、(4) の形式には <code><span style="color: #000">noexcept</span></code> が付いているが、下記の実装例のような実装を許すために C++14 では削除されるかもしれない。<br />
    （そのような実装では新たな <code><span style="color: #000">std::basic_string</span></code> が割り当てられるため、メモリのアロケーションが行われる）</li>
</ul>
<h2>例</h2>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">find_last_not_of</span>(str, 11) &lt;&lt; std::endl;

  // "Welcome to C++ world." を検索すると、"," が見つかる
  std::cout &lt;&lt; s.<span style="color:#ff0000">find_last_not_of</span>("Welcome to C++ world.") &lt;&lt; std::endl;

  // "C++" の 2 つめの "+" 以前で '+' を検索すると "C" が見つかる
  std::cout &lt;&lt; s.<span style="color:#ff0000">find_last_not_of</span>('+', 27) &lt;&lt; std::endl;
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  const std::string s("Hello, world. Welcome to C++ world.");
  const std::string str("world");

  // 1 つめの "world" の "d" 以前で "world" を検索すると、最初の空白が見つかる
  std::cout &lt;&lt; s.</span></code></pre>
</p>
<h3>出力</h3>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">6
5
25</span></code></pre>
</p>
<h2>実装例</h2>
<p>(1) 以外の形式は、(1) の形式を使用して実装することができる。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">// (2)
template &lt;class charT, class traits, class Allocator&gt;
size_type basic_string&lt;charT, traits, Allocator&gt;::find_last_not_of(const charT* s, size_type pos, size_type n) const
{
  return find_last_not_of(std::basic_string(s, n), pos);
}

// (3)
template &lt;class charT, class traits, class Allocator&gt;
size_type basic_string&lt;charT, traits, Allocator&gt;::find_last_not_of(const charT* s, size_type pos = npos) const
{
  return find_last_not_of(std::basic_string(s), pos);
}

// (4)
template &lt;class charT, class traits, class Allocator&gt;
size_type basic_string&lt;charT, traits, Allocator&gt;::find_last_not_of(charT c, size_type pos = npos) const noexcept
{
  return find_last_not_of(std::basic_string(1, c), pos);
}</span></code></pre>
</p>
<h2>参照</h2>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2064" target="_blank">LWG2064 - More noexcept issues in basic_string</a></li>
</ul>
<footer><a href="https://github.com/cpprefjp/site/edit/master/reference/string/basic_string/find_last_not_of.md" target="_blank">編集</a></footer>